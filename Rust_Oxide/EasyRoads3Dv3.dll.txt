public class EasyRoads3Dv3.BinaryWriterEx : BinaryWriter {
    public BinaryWriterEx(string fileName);
    public long Seek(long offset, SeekOrigin origin);
    public void WriteStruct(object theStruct);
    public void Write(Int32[] array);
    public void Write(Single[] array);
}
public class EasyRoads3Dv3.CombineClass : ValueType {
    
public Material m;
    
public List`1<MeshInstance> objects;
}
public enum EasyRoads3Dv3.ConnectedTo : Enum {
    
public int value__;
    
public static ConnectedTo Start;
    
public static ConnectedTo End;
    
public static ConnectedTo None;
}
public class EasyRoads3Dv3.CRedge : ValueType {
    
public int v1;
    
public int v2;
    
public int count;
    public CRedge(int v_1, int v_2);
}
public class EasyRoads3Dv3.CrossingCornerClass : object {
    
public string presetName;
    
public double id;
    
public double timestamp;
    
public float cornerRadius;
    
public int cornerSegments;
    
public float innerSegmentDistance;
    public CrossingCornerClass(QDOQDSQOOQDDD sw, string name);
}
public class EasyRoads3Dv3.EasyRoads3DTerrainIDv3 : MonoBehaviour {
    
public string terrainid;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERBend : MonoBehaviour {
    
public float roundAboutRadius;
    
public float roundAboutResolution;
    
public float rDist;
    
public Vector3 raStartPos;
    
public float roundaboutWidth;
    
public float bendAngle;
    
public bool meshInstance;
    
public float roadWidth;
    
public bool lockLeftRightRoundingRadius;
    
public float leftRoundingRadius;
    
public float rightRoundingRadius;
    
public int roundingSegments;
    
public float connectionLength;
    
public float maxRoadWidth;
    
public float maxRoundingRadius;
    
public List`1<Vector3> meshVecs;
    
public List`1<Vector3> mainRightPoints;
    
public List`1<Vector3> mainCenterPoints;
    
public List`1<Vector3> mainLeftPoints;
    
public List`1<Vector3> OCCDQOCCDQ;
    
public List`1<Vector3> splinePoints;
    
public List`1<Vector2> mainRightPointsUVs;
    
public List`1<Vector2> mainCenterPointsUVs;
    
public List`1<Vector2> mainLeftPointsUVs;
    
public List`1<Vector2> OCCDQOCCDQUVs;
    
public Vector3 leftPoint;
    
public Vector3 leftPoint1;
    
public Vector3 rightPoint;
    
public Vector3 rightPoint1;
    
public Vector3 centerOnLine;
    
public Vector3 leftOuterPoint;
    
public Vector3 rightOuterPoint;
    
public Vector3 pl;
    
public Vector3 pr;
    
public List`1<Vector3> edgePoints;
    
public int newSegmentInt;
    
public List`1<ERRoundaboutElement> connections;
    
public String[] QDOOOQOOQQQQD;
    
public int selectedConnection;
    
public int tmpSelectedConnection;
    
public int centerInt;
    
public int leftOuterInt;
    
public int rightOuterInt;
    
public List`1<Vector3> leftOuterSegments;
    
public List`1<Vector3> leftInnerSegments;
    
public List`1<Vector3> rightOuterSegments;
    
public List`1<Vector3> rightInnerSegments;
    
public List`1<Vector2> leftOuterSegmentsUVs;
    
public List`1<Vector2> leftInnerSegmentsUVs;
    
public List`1<Vector2> rightOuterSegmentsUVs;
    
public List`1<Vector2> rightInnerSegmentsUVs;
    
public Material roadMaterial;
    
public List`1<Vector3> innerRoundaboutPoints;
    
public List`1<Vector2> innerRoundaboutUVs;
    
public float innerSegmentDistance;
    
public bool leftFlag;
    
public bool rightFlag;
    private void Start();
    private void Update();
    public void OOCCCDQDCQ();
}
public class EasyRoads3Dv3.ERBlendVecs : object {
    
public int verticeIndex;
    
public int meshIndex;
    
public float blendWeight;
    
public int connection;
    
public int blendType;
    public ERBlendVecs(int index, int mIndex, float weight, int conn, int type);
}
public class EasyRoads3Dv3.ERCamNodes : ScriptableObject {
    [SerializeField]

public float sleep;
    [SerializeField]

public float speed;
    [SerializeField]

public float easeOutDistance;
    [SerializeField]

public float easeInDistance;
    [SerializeField]

public GameObject startLookat;
    [SerializeField]

public GameObject endLookat;
}
public class EasyRoads3Dv3.ERCell : ValueType {
    
public int x;
    
public int y;
    public ERCell(int _x, int _y);
}
public class EasyRoads3Dv3.ERChildsSO : ValueType {
    
public double id;
    
public float startOffset;
    
public float endOffset;
    
public float xOffset;
    
public float yOffset;
    public ERChildsSO(int _id);
}
public class EasyRoads3Dv3.ERConnection : object {
    
public string name;
    
public ERCrossingPrefabs prefabScript;
    
public GameObject gameObject;
    
public ERConnectionData[] connectionData;
    
public static string str;
    public ERConnection(GameObject go, string g_name);
    private static ERConnection();
    public static ERConnection Create(GameObject go);
    public void SetPosition(Vector3 pos);
    public string GetName();
    public void SetName(string name);
    public void SetRotation(Vector3 euler);
    public void Destroy();
    public void UnConnect(int connectionIndex);
    public ERConnectionData[] GetConnectionData();
    public Vector3 GetLocalConnectionPosition(int connectionIndex);
    public Vector3[] GetLocalConnectionPositions();
    public Vector3[] GetConnectionWorldPositions();
    public Vector3 GetConnectionWorldPosition(int connectionIndex);
    public int FindNearestConnectionIndex(Vector3 position);
    public bool SwapTurn();
    public bool RotateConnections();
    public ERRoad GetConnectedRoad(int index, ConnectedTo& connectedTo);
    public ERLaneConnector[] GetLaneData(int connectionIndex);
    public ERLaneConnector[] GetLaneData(int connectionIndex, int lane);
    public int GetConnectionCount();
    public void AverageNormals(bool flag);
    public bool RecalculateNormals();
    public bool RecalculateTangents();
    public void Refresh();
    public bool IsFlexConnector();
}
public class EasyRoads3Dv3.ERConnectionData : object {
    
public ERRoad road;
    
public int marker;
    
public int connectionIndex;
    
public Vector3 position;
    public ERConnectionData(ERRoad rd, int rm, int index);
}
public class EasyRoads3Dv3.ERConnectionGUIStatus : ValueType {
    
public int id;
    
public bool favourite;
    public ERConnectionGUIStatus(int _id, bool value);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERConnectionParent : MonoBehaviour {
}
public class EasyRoads3Dv3.ERConnectionSibling : object {
    
public string name;
    
public ERModularRoad road;
    
public Transform transform;
    
public Vector3 angleControlPoint;
    
public QDQDOOQQDQODD roadType;
    
public double roadTypeID;
    
public QDQDOOQQDQODD roadTypeAI;
    
public double roadTypeAIid;
    
public bool aIInit;
    
public int roadTypeIndex;
    
public int priorityLevel;
    
public bool priorityRoad;
    
public int prioritySectionStart;
    
public int prioritySectionEnd;
    
public float angle;
    
public float prevAngle;
    
public float roadWidth;
    
public Vector3 controlPoint;
    
public List`1<Vector2> roadShape;
    
public List`1<bool> hardEdge;
    
public List`1<float> roadShapeUVs;
    
public List`1<bool> originalShapeVecs;
    
public bool includeOuterLaneOffset;
    
public float leftFixedDistance;
    
public float rightFixedDistance;
    
public int buildPriority;
    
public bool highPriorityConnection;
    
public int triangulationType;
    
public bool adjustRadius;
    
public float resolution;
    
public int defaultSegments;
    
public int segments;
    
public float radius;
    
public float leftCornerAngle;
    
public float rightCornerAngle;
    
public Vector3 leftCurvatureDir;
    
public Vector3 leftCurvatureVec;
    
public Vector3 rightCurvatureDir;
    
public Vector3 rightCurvatureVec;
    
public ERFlexConnectionType leftConnectionType;
    
public ERFlexConnectionType rightConnectionType;
    
public Vector3 cp;
    
public Vector3 oldCP;
    
public Vector3 cp1;
    
public Vector3 lStart;
    
public Vector3 lEnd;
    
public Vector3 rStart;
    
public Vector3 rEnd;
    
public Vector3 ip;
    
public Vector3 dir;
    
public Vector3 outerCorner;
    
public float cornerHandleScale;
    
public List`1<Vector3> leftRoundingPoints;
    
public List`1<Vector3> rightRoundingPoints;
    
public List`1<Vector3> innerRoundingPoints;
    
public List`1<Vector3> priorityLeftPoints;
    
public List`1<Vector3> priorityRightPoints;
    
public List`1<Vector3> priorityPointsMain;
    
public List`1<Vector2> priorityPointsMainUVs;
    
public List`1<List`1<Vector3>> roadVecs;
    
public List`1<List`1<Vector3>> roadVecsRight;
    
public List`1<List`1<Vector3>> roadVecsLeft;
    
public List`1<List`1<Vector2>> roadUVs;
    
public List`1<List`1<Vector2>> roadUVsLeft;
    
public List`1<List`1<Vector2>> roadUVsRight;
    
public List`1<int> connectionVecInts;
    
public List`1<float> roadVecPerc;
    
public int leftFixedIndex;
    
public int rightFixedIndex;
    
public int middleIndex;
    
public int middleIndentIndexLeft;
    
public int middleIndentIndexRight;
    
public ERSideWalk leftSidewalk;
    
public ERSideWalk rightSidewalk;
    
public bool leftSidewalkActive;
    
public bool rightSidewalkActive;
    
public List`1<List`1<Vector3>> leftSidewalkVecs;
    
public List`1<List`1<Vector2>> leftSidewalkUVs;
    
public List`1<List`1<Vector3>> rightSidewalkVecs;
    
public List`1<List`1<Vector2>> rightSidewalkUVs;
    
public List`1<Vector3> leftIndentvecs;
    
public List`1<Vector3> rightIndentvecs;
    
public List`1<Vector3> leftSurroundingvecs;
    
public List`1<Vector3> rightSurroundingvecs;
    
public int leftIndent;
    
public int rightIndent;
    
public Vector3 leftIndentV3;
    
public Vector3 rightIndentV3;
    
public int leftSurrounding;
    
public int rightSurrounding;
    
public Vector3 leftSurroundingV3;
    
public Vector3 rightSurroundingV3;
    
public float uvRatio;
    
public float uvy;
    
public int mainRoadConnectionEdgeDecal;
    
public GameObject mainConnectionDecal;
    
public List`1<Vector3> mainConnectionDecalVecs;
    
public Vector3 mainConnectionDecalEndDir;
    
public int middleInt;
    
public bool primaryPriorityConnection;
    
public bool secondaryPriorityConnection;
    
public bool shapeSubSegments;
    
public List`1<int> normalIndexes;
    
public bool primarySection;
    
public ERLaneData laneData;
    
public bool hasChanged;
    public void Clear();
    private void Init(ERModularRoad scr, float angle, Vector3 controlPoint, Transform transform);
    public static ERConnectionSibling CreateInstance(ERModularRoad scr, float angle, Vector3 controlPoint, Transform transform, List`1<ERConnectionSibling> siblings);
    private void GetRoadTypeIndex(double id, List`1<QDQDOOQQDQODD> types);
    public void ODDQDOCDCC(int index, List`1<QDQDOOQQDQODD> types);
    public void OCQQDCCOQO(List`1<QDQDOOQQDQODD> types);
    private void BuildRoadShape();
    public static void SetPriorityConnection(List`1<ERConnectionSibling> siblings, int index);
    public Vector2 GetVector2(Vector2 v1, Vector2 v2, Vector2 v3);
    public void OCQODDOQQC(double type, List`1<QDQDOOQQDQODD> roadTypes);
    public static Vector3 GetAngleControlPoint(Vector3 cp, Vector3 p0, Vector3 p1, Vector3 p2);
}
public class EasyRoads3Dv3.ERConnectionVecs : object {
    
private List`1<int> ᙃ;
    
private List`1<int> ᙄ;
}
public class EasyRoads3Dv3.ERCPUpdate : ValueType {
    
public ERModularRoad road;
    
public ERCrossingPrefabs prefab;
    
public int startEnd;
    
public int connection;
    
public Vector3 cp;
    public ERCPUpdate(ERModularRoad v_road, ERCrossingPrefabs v_prefab, int v_startEnd, int v_connection, Vector3 v_cp);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERCrossingMainRoad : MonoBehaviour {
    
public ERModularBase baseScript;
    
public double roadType1;
    
public int roadTypeInt1;
    
public double roadType2;
    
public int roadTypeInt2;
    
public double roadType3;
    
public int roadTypeInt3;
    
public float indent1;
    
public float indent2;
    
public float roadWidth1;
    
public float roadWidth2;
    
public float roadWidth3;
    
public bool tCrossing;
    
public List`1<Vector3> leftOuter1;
    
public List`1<Vector3> rightOuter1;
    
public List`1<Vector2> leftOuterUV1;
    
public List`1<Vector2> rightOuterUV1;
    
public List`1<Vector3> leftOuter2;
    
public List`1<Vector3> rightOuter2;
    
public List`1<Vector2> leftOuterUV2;
    
public List`1<Vector2> rightOuterUV2;
    
public List`1<Vector3> leftOuter3;
    
public List`1<Vector3> rightOuter3;
    
public List`1<Vector2> leftOuterUV3;
    
public List`1<Vector2> rightOuterUV3;
    
public Material sourceMaterial;
    
public Material sourceMaterial1;
    
public Material targetMaterial;
    
public float bottom2;
    
public float bottom2Inner;
    
public float bottom3;
    
public float bottom3Inner;
    
public float top2;
    
public float top2Inner;
    
public float top3;
    
public float top3Inner;
    
public float left2;
    
public float left3;
    
public float right2;
    
public float right3;
    
public int vec2Count;
    
public int vec3Count;
    
public float uvStart1;
    
public float uvEnd1;
    
public float uvStart2;
    
public float uvEnd2;
    
public Vector2 rightTopL;
    
public Vector2 rightTopR;
    
public Vector2 rightBottomL;
    
public Vector2 rightBottomR;
    
public Vector2 leftTopL;
    
public Vector2 leftTopR;
    
public Vector2 leftBottomL;
    
public Vector2 leftBottomR;
    
public float rightLeftUV;
    
public float rightRightUV;
    
public float leftLeftUV;
    
public float leftRightUV;
    
public float bottomuvInner2;
    
public float topuvInner2;
    
public float innerHeight2;
    
public float outerHeight2;
    
public float bottomuvInner3;
    
public float topuvInner3;
    
public float innerHeight3;
    
public float outerHeight3;
    
public float rightInnerStretch;
    
public float leftInnerStretch;
    
public Material mat1;
    
public Material mat2;
    
public Material mat3;
    
public string name;
    public void OCQOQCDCQC();
    public void Clear();
    private List`1<int> Triangulate(List`1<Vector3> vecs, List`1<Vector3> edges);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERCrossingPrefabs : MonoBehaviour {
    
public List`1<QDOODOQQDQODD> crossingElements;
    
public List`1<QDOQDSQOOQDDD> sidewalkControlElements;
    
public List`1<ERConnectionSibling> siblings;
    
public Vector3[] meshVecs;
    
public Vector3[] fullMeshVecs;
    
public Vector3[] tmpMeshVecs;
    
public Vector3[] tmpFullMeshVecs;
    
public Vector3[] tCrossingTmpFullMeshVecs;
    
public Int32[] outerVecInts;
    
public List`1<Vector3> surfaceVecs;
    
public List`1<int> surfaceVecType;
    
public List`1<int> surfaceConnectionInt;
    
public List`1<ERBlendVecs> tCrossingBlendData;
    
public List`1<Vector3> indentVecs;
    
public GameObject sourcePrefab;
    
public int prefabId;
    
public string guid;
    
public List`1<int> prioritySegments;
    
public float minNodeDistance;
    
public int nodeWithinRange;
    
public GameObject sourceObject;
    
public bool meshInstance;
    
public int selectedConnection;
    
public String[] QDOOOQOOQQQQD;
    
public bool deformTerrain;
    
public bool isRoundabout;
    
public bool isERCrossing;
    
public bool isYConnector;
    
public bool isIConnector;
    
public bool isFlexConnector;
    
public bool isSnapConnector;
    
public bool isExitRoadConnector;
    
public Vector3 prefabCenterDummy;
    
public float snapRadius;
    
public ERRoundabouts roundaboutScript;
    
public ERCrossings crossingsScript;
    
public ERIConnector iConnectorScript;
    
public bool isCustomPrefab;
    
public int customPrefabVersion;
    
public bool recalculateNormals;
    
public bool planarUVs;
    
public float planarTiling;
    
public int lastVecRoadIndex;
    
public bool isSceneObject;
    
public GameObject surfaceObject;
    
public Vector3[] surfaceMeshVecs;
    
public Vector3[] tmpSurfaceMeshVecs;
    
public Vector3[] tmpSurfaceVecsTCrossings;
    
public Int32[] surfaceInts;
    
public Vector3 leftBottomCorner;
    
public Vector3 leftTopCorner;
    
public Vector3 rightBottomCorner;
    
public Vector3 rightTopCorner;
    
public bool tCrossing;
    
public bool tStraightBending;
    
public int tCrossingLeftRight;
    
public float tMainRoadWidth;
    
public float tConnectionRoadWidth;
    
public float bottomLeftSidewalkWidth;
    
public float bottomLeftSidewalkOuterOffset;
    
public float bottomLeftSidewalkCurbDepth;
    
public float bottomRightSidewalkWidth;
    
public float bottomRightSidewalkOuterOffset;
    
public float bottomRightSidewalkCurbDepth;
    
public float topLeftSidewalkWidth;
    
public float topLeftSidewalkOuterOffset;
    
public float topLeftSidewalkCurbDepth;
    
public float topRightSidewalkWidth;
    
public float topRightSidewalkOuterOffset;
    
public float topRightSidewalkCurbDepth;
    
public ERConnection connObject;
    
public Vector3 testVec;
    
public List`1<int> surfaceSurroundingInts;
    
public int rotationPriorityElement;
    
public Vector3 cornerPos;
    
public Vector3 mainCorner;
    
public Vector3 connectedCorner;
    
public Vector3 mainVecOuter;
    
public Vector3 connectionVecOuter;
    
public Vector3 indentTopVec;
    
public Vector3 indentRightVec;
    
public Vector3 mainIndent;
    
public Vector3 connectionIndent;
    
public int selectedRotationConnection;
    
public Vector3 bottomVec;
    
public Vector3 rightVec;
    
public Vector3 bottomIndent;
    
public Vector3 rightIndent;
    
public float sAngle;
    
public ERModularBase baseScript;
    
public bool QDQDQOOQQDQOQQ;
    
public Vector3 tp1;
    
public Vector3 tp2;
    
public bool doTerrainDeformation;
    
public bool includeOuterVertices;
    
public bool averageNormals;
    
public float surroundingDistance;
    
public Mesh surfaceMesh;
    
public List`1<Vector3> debugVecs1;
    
public List`1<Vector3> debugVecs2;
    
public bool lightmapAdjusted;
    
public bool isFlexUpdating;
    
public Vector3 oldPosition;
    
public Vector3 oldRotation;
    
public bool lockScale;
    
public float extraIndentMargin;
    
public float indent;
    
public float surrounding;
    public void OCOODQQDQO();
    public void OOCQCCQDOQ(Vector3 v1, Vector3 v2, int connectionElement, ERModularRoad road);
    public void OCQDDQODCC(int el);
    public void OCDOCCODOC(int elInt, float distance);
    public void DeformTCossingConnection(int elInt, float distance, float defaultDistance, List`1<Vector3> controlPoints, float multiplyFactor, float angle, Vector3 cpCenterPoint, float curveStrength);
    public void OOODCOOOCQ(List`1<int> affectedVecs, List`1<Vector2> tmpVecs);
    public void OQOQDDOCDC(bool ignorePriority, ERModularRoad road);
    public void OQQODODQCQ();
    public void OQQCDODDQQ(bool forceFlag);
    public void CheckPlanarUVs();
    public static bool OOCCOODCOO(List`1<ERModularRoad> affectedObjects, ERModularRoad roadScr);
    public void OCCDCDDOOQ(bool flag);
    public void OODODQQCOD(int el);
    public bool HasConnections();
    public bool HasConnectionsFull();
    public void OOQOQQODCD();
    public void OCODDQDQCC(int el, int startend);
    public void PopulateSiblingsList();
    public void InitFlexConnector();
    public void AttachRoadToFlexConnector(ERModularBase scr, float OCCDOQCODC, Vector3 OCCQOCQOQD);
    public void OQQQQOOCDO(int index);
    public void SetElementInfo(int index, int sourceIndex);
    public static void ODDQDDQOOD();
    public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERCrossings : MonoBehaviour {
    [SerializeField]

public ERConnectionData cdata;
    
public List`1<List`1<Vector3>> startConnectionV3;
    
public List`1<List`1<Vector3>> endConnectionV3;
    
public List`1<List`1<Vector3>> leftConnectionV3;
    
public List`1<List`1<Vector3>> rightConnectionV3;
    
public List`1<List`1<Vector2>> startConnectionUV;
    
public List`1<List`1<Vector2>> endConnectionUV;
    
public List`1<List`1<Vector2>> leftConnectionUV;
    
public List`1<List`1<Vector2>> rightConnectionUV;
    
public List`1<List`1<int>> startConnectionTris;
    
public List`1<List`1<int>> endConnectionTris;
    
public List`1<List`1<int>> leftConnectionTris;
    
public List`1<List`1<int>> rightConnectionTris;
    
public List`1<List`1<Vector3>> leftSidewalkStartV3;
    
public List`1<List`1<Vector3>> rightSidewalkStartV3;
    
public List`1<List`1<Vector3>> leftSidewalkEndV3;
    
public List`1<List`1<Vector3>> rightSidewalkEndV3;
    
public List`1<List`1<Vector2>> leftSidewalkStartUV;
    
public List`1<List`1<Vector2>> rightSidewalkStartUV;
    
public List`1<List`1<Vector2>> leftSidewalkEndUV;
    
public List`1<List`1<Vector2>> rightSidewalkEndUV;
    
public List`1<List`1<Vector3>> leftSidewalkLeftV3;
    
public List`1<List`1<Vector3>> leftSidewalkRightV3;
    
public List`1<List`1<Vector3>> rightSidewalkLeftV3;
    
public List`1<List`1<Vector3>> rightSidewalkRightV3;
    
public List`1<List`1<Vector2>> leftSidewalkLeftUV;
    
public List`1<List`1<Vector2>> leftSidewalkRightUV;
    
public List`1<List`1<Vector2>> rightSidewalkLeftUV;
    
public List`1<List`1<Vector2>> rightSidewalkRightUV;
    
public List`1<List`1<int>> leftSidewalkStartTris;
    
public List`1<List`1<int>> rightSidewalkStartTris;
    
public List`1<List`1<int>> leftSidewalkEndTris;
    
public List`1<List`1<int>> rightSidewalkEndTris;
    
public List`1<List`1<int>> leftSidewalkLeftTris;
    
public List`1<List`1<int>> leftSidewalkRightTris;
    
public List`1<List`1<int>> rightSidewalkLeftTris;
    
public List`1<List`1<int>> rightSidewalkRightTris;
    
public List`1<float> uvArrayFront;
    
public List`1<float> uvArrayBack;
    
public List`1<float> uvArrayLeft;
    
public List`1<float> uvArrayRight;
    
public List`1<int> OCCODQDOQO;
    
public List`1<int> OOQODQDOQC;
    
public List`1<int> OQCCQOCQDQ;
    
public List`1<int> OQDQOQOCQD;
    
public List`1<int> ODQDCCQOQD;
    
public List`1<int> ODOQODQODO;
    
public List`1<int> OOOQCQDOCD;
    
public List`1<int> OQCDOOCDCD;
    
public List`1<int> OCCODQDOQOStart;
    
public List`1<int> OOQODQDOQCStart;
    
public List`1<int> OQCCQOCQDQStart;
    
public List`1<int> OQDQOQOCQDStart;
    
public List`1<int> ODQDCCQOQDStart;
    
public List`1<int> ODOQODQODOStart;
    
public List`1<int> OOOQCQDOCDStart;
    
public List`1<int> OQCDOOCDCDStart;
    
public List`1<int> frontLeftRoadInts;
    
public List`1<int> frontRightRoadInts;
    
public List`1<int> backLeftRoadInts;
    
public List`1<int> backRightRoadInts;
    
public List`1<int> leftLeftRoadInts;
    
public List`1<int> leftRightRoadInts;
    
public List`1<int> rightLeftRoadInts;
    
public List`1<int> rightRightRoadInts;
    
public List`1<ERSideWalk> sidewalkCorners;
    
public List`1<float> sidewalkWidths;
    
public List`1<float> curbHeights;
    
public List`1<float> curbDepths;
    
public List`1<bool> beveledCurbs;
    
public List`1<float> beveledHeights;
    
public List`1<float> beveledDepths;
    
public List`1<bool> outerCurbs;
    
public List`1<bool> lockUVs;
    
public List`1<Material> materials;
    
public int leftStartSidewalkCornerInt;
    
public int rightStartSidewalkCornerInt;
    
public int leftEndSidewalkCornerInt;
    
public int rightEndSidewalkCornerInt;
    
public int leftLeftSidewalkCornerInt;
    
public int rightLeftSidewalkCornerInt;
    
public int leftRightSidewalkCornerInt;
    
public int rightRightSidewalkCornerInt;
    
public Vector3[] sidewalkControlPoints;
    
public Boolean[] sidewalkControlStatus;
    
public bool copySettingsFlag;
    
public bool generalSettingsFlag;
    
public bool connectionSettingsFlag;
    
public bool cornerSettingsFlag;
    
public bool sidewalkSettingsFlag;
    
public String[] QDOOOQOOQQQQD;
    
public int selectedConnection;
    
public float startAngle;
    
public bool roundedCorners;
    
public float roundingRadius;
    
public int roundingSegments;
    
public float innerSegmentDistance;
    
public bool tCrossing;
    
public bool tStraightBending;
    
public bool oldTCrossing;
    
public int tCrossingLeftRight;
    
public int oldtCrossingLeftRight;
    
public int geometryType;
    
public float resolution;
    
public bool includeSidewalks;
    
public bool defaultSidewalkEnabledStatus;
    
public bool planarUVs;
    
public float planarTiling;
    
public bool isSceneObject;
    
public int connectionHandling;
    
public List`1<QDQDOOQQDQODD> roadTypesDynamic;
    
public int frontRoadTypeInt;
    
public double frontRoadTypeID;
    
public float frontRoadWidth;
    
public Material frontMaterial;
    
public Material frontRoadMaterial;
    
public float frontRoadUVTiling;
    
public int backRoadTypeInt;
    
public double backRoadTypeID;
    
public float backRoadWidth;
    
public Material backMaterial;
    
public Material backRoadMaterial;
    
public float backRoadUVTiling;
    
public int leftRoadTypeInt;
    
public double leftRoadTypeID;
    
public float leftRoadWidth;
    
public Material leftMaterial;
    
public Material leftRoadMaterial;
    
public float leftRoadUVTiling;
    
public int rightRoadTypeInt;
    
public double rightRoadTypeID;
    
public float rightRoadWidth;
    
public Material rightMaterial;
    
public Material rightRoadMaterial;
    
public float rightRoadUVTiling;
    
public int selectedRoadType;
    
public bool uniformCornersFlag;
    
public int selectedCorner;
    
public int selectedCornerPreset;
    
public string cornerPresetName;
    
public int selectedSidewalkPreset;
    
public string sidewalkPresetName;
    
public int OCOQDODDQQCorner;
    
public Vector3 leftBottom;
    
public Vector3 rightBottom;
    
public Vector3 leftTop;
    
public Vector3 rightTop;
    
public Vector3 frontCenter;
    
public Vector3 backCenter;
    
public Vector3 leftCenter;
    
public Vector3 rightCenter;
    
public int prefabId;
    
public ERCrossingPrefabs prefabScript;
    
public QDOODOQQDQODD connectionElement;
    
public int crossingOuterElement;
    
public string crossingName;
    
public bool guiChanged;
    
public bool includeSidewalkChangeFlag;
    
public List`1<Vector3> debugVecs;
    
public List`1<NormalPairs> normalPairs;
    
public float maxConnectionWidth;
    
public int crossingStructure;
    
public ERModularBase baseScript;
    
public List`1<ERConnectionSibling> siblings1;
    
public List`1<ERConnectionSibling> prioritySiblings;
    
public Vector3 crossPointCenter;
    
public List`1<Vector3> edges;
    
public ERConnectionSibling primaryPriorityConnection;
    
public ERConnectionSibling secondPriorityConnection;
    
public bool adjustMainRadiusFlag;
    
public bool disableAdjustMainRadiusFlag;
    
public bool showScaleSliderAtPrimary;
    
public bool showScaleSliderAtSecondary;
    
public ERRoadWayType priorityWayType;
    
public float leftIntOffset;
    
public float rightIntOffset;
    
public bool isUpdating;
    
public int serializeTest;
    
public int updateQueue;
    public void Refresh();
    public void ODOCCDCQOC();
    public Vector3 OOQCQDQCOO(int index, Vector3 p0, Vector3 p1, Vector3 p2, bool update);
    public void UpdateAllConnectionAngles();
    public void OOOCDCQQCO();
    public bool UpdateToRoadType(QDQDOOQQDQODD sourcePreset, List`1& updatedRoads);
    public bool RoadIsUpdated(ERModularRoad rd, List`1& updatedRoads);
    public int SetRoadTypeInt(double id);
    public void OCQCQODOQC(ERCrossings source, bool refreshFlag);
    public void OQCQCOOCDD();
    public void OCQDQODOQD(bool sidewalkSceneHandleFlag, bool rebuildRoads);
    public void OQCQDQDCOD();
    public void ODDDOCDCQO(bool rebuildRoads);
    public void OQCQQCQDCQ(int el, List`1<List`1<int>> trIntArray, List`1<float> uvArray, List`1<List`1<int>> leftSidewalkIntArray, List`1<List`1<int>> rightSidewalkIntArray, int startend);
    public void ODQCODQDDQ(int el, Material roadMaterial, int leftCorner, int rightCorner, int leftVecCount, int rightVecCount);
    public void OCDDOCDDOQ(List`1<Vector3> meshVecs, List`1<int> connectionVecInts, List`1& roadShapeVecs, List`1<List`1<Vector3>> vecArrays, List`1<List`1<Vector3>> leftSidewalkArray, List`1<List`1<Vector3>> rightSidewalkArray, int connectionElement, int startend);
    public static void ODOODQDCCQ(List`1<Vector3> sourceVecs, List`1& roadShapeVecs, Vector3 centerPoint, Vector3 startPoint, float halfWayDistance);
    public static string GetRoadShapeVecString(List`1<Vector2> vecs, List`1<Vector2> lvecs, List`1<Vector2> rvecs, Int32& matchCount);
    public void ODCCCQCQOO();
    public void ODCDCDDOCC(List`1<SidewalkPresetClass> sidewalkPresets, int el);
    public void OCCODQDOCO();
    public void OQDOQDQQQQ(int el);
    public void OODOQQQQCO();
    public void OQCOOQQOOD();
    public bool OQDOOCDOCD(ERModularRoad road, float angle);
}
public class EasyRoads3Dv3.ERDebug : object {
    
public static List`1<Vector3> leftTHandles;
    
public static List`1<Vector3> rightTHandles;
    private static ERDebug();
}
public class EasyRoads3Dv3.ERDecal : ScriptableObject {
    
public int id;
    
public string name;
    
public ERDecalType type;
    
public double roadType1;
    
public double roadType2;
    
public int connection;
    
public GameObject decalPrefab;
    
public float baseWidth;
    
public float meshWidth;
    
public float scale;
    
public Vector3 localScale;
    
public int priority;
    
public bool collapsed;
    
public float heightOffset;
    
public Material material;
    
public Vector2 uvLeftTop;
    
public Vector2 uvRightBottom;
    
public float width;
    
public float length;
    
public float xOffset;
    
public float startOffset;
    
public float endOffset;
    
public float endRotation;
    
public List`1<Vector2> uvBreakPoints;
    
public List`1<float> distances;
    
public ERDecalPosition position;
    
public Vector2 uvLeftTop1;
    
public Vector2 uvRightBottom1;
    
public Vector2 uvLeftTop2;
    
public Vector2 uvRightBottom2;
    
public float width1;
    
public float width2;
    public void Init(GameObject prefab, float baseWidth);
    public static ERDecal CreateInstance(GameObject prefab, float baseWidth);
    public static void CopyDecal(ERDecalClass source, ERDecal target);
    public static void OODDOCCOCC(ERDecal source, ERDecal target);
    public void OCQCQCOCOO();
    public static ERDecal OCQCDQDODQ(int id, List`1<ERDecal> decalPresets);
    public static List`1<ERDecal> FilterByType(List`1<ERDecal> lst, ERDecalType type);
    public static String[] OQDOCOQOQD(List`1& decals, string firstItem, int id1, int id2, Int32& _index1, Int32& _index2, ERDecalType type, ERDecalPosition position);
    public static int ODCOCCOOOO(List`1<ERDecal> decals, int tindex, ERDecalType type);
    public static GameObject[] OCCODDOQDO(List`1<ERDecal> decals, List`1& priority, List`1& scale);
    public void MatchDistances(List`1& distances, List`1<Vector2> uvBreakPoints, float length);
    public void SetBreakPointDistances(List`1& distances, List`1<Vector2> uvBreakPoints, float length);
}
public class EasyRoads3Dv3.ERDecalClass : object {
    
public int id;
    
public ERDecalType type;
    
public string name;
    
public double roadType1;
    
public double roadType2;
    
public int connection;
    
public GameObject decalPrefab;
    
public float baseWidth;
    
public float meshWidth;
    
public float scale;
    
public Vector3 localScale;
    
public int priority;
    
public bool collapsed;
    
public float heightOffset;
    
public Material material;
    
public Vector2 uvLeftTop;
    
public Vector2 uvRightBottom;
    
public float width;
    
public float length;
    
public float xOffset;
    
public float startOffset;
    
public float endOffset;
    
public List`1<Vector2> uvBreakPoints;
    
public List`1<float> distances;
    
public Vector2 uvLeftTop1;
    
public Vector2 uvRightBottom1;
    
public Vector2 uvLeftTop2;
    
public Vector2 uvRightBottom2;
    
public float width1;
    
public float width2;
    public static void CopyDecal(ERDecal source, ERDecalClass target);
}
public enum EasyRoads3Dv3.ERDecalPosition : Enum {
    
public int value__;
    
public static ERDecalPosition Start;
    
public static ERDecalPosition End;
    
public static ERDecalPosition Both;
}
public enum EasyRoads3Dv3.ERDecalType : Enum {
    
public int value__;
    
public static ERDecalType StartEnd;
    
public static ERDecalType LineMarking;
    
public static ERDecalType StopMarking;
    
public static ERDecalType MainConnectionLineMarking;
    
public static ERDecalType MotorwayRampLineMarking;
    
public static ERDecalType MotorwayRampSplitMarking;
}
public enum EasyRoads3Dv3.ERDirectionType : Enum {
    
public int value__;
    
public static ERDirectionType Straight;
    
public static ERDirectionType Left;
    
public static ERDirectionType Right;
}
public enum EasyRoads3Dv3.ERExitType : Enum {
    
public int value__;
    
public static ERExitType RightExit;
    
public static ERExitType RightEntry;
    
public static ERExitType LeftExit;
    
public static ERExitType LeftEntry;
    
public static ERExitType BusStop;
}
public class EasyRoads3Dv3.ERExtension : object {
}
public enum EasyRoads3Dv3.ERFlexConnectionType : Enum {
    
public int value__;
    
public static ERFlexConnectionType Priority;
    
public static ERFlexConnectionType SameType;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERIConnector : MonoBehaviour {
    
public float roadWidth1;
    
public float leftIndentInner1;
    
public float leftIndent1;
    
public float leftUVXInner1;
    
public float leftUVX1;
    
public float rightUVX1;
    
public float rightUVXInner1;
    
public float rightIndentInner1;
    
public float rightIndent1;
    
public float cornerRadius1;
    
public int cornerSegments1;
    
public float angle1;
    
public float prevAngle1;
    
public Material road1Material;
    
public Material road1MaterialActive;
    
public int roadType1;
    
public double roadType1ID;
    
public ERTexture road1ERTexture;
    
private float ᙃ;
    
private float ᙄ;
    
private float ᙅ;
    
private float 4AAAA;
    
public float road1Stretch;
    
public int road1StretchType;
    
public int subdivide1;
    
public float roadWidth2;
    
public float leftIndentInner2;
    
public float leftIndent2;
    
public float leftUVXInner2;
    
public float leftUVX2;
    
public float rightUVX2;
    
public float rightUVXInner2;
    
public float rightIndentInner2;
    
public float rightIndent2;
    
public float cornerRadius2;
    
public int cornerSegments2;
    
public float angle2;
    
public float prevAngle2;
    
public Material road2Material;
    
public Material road2MaterialActive;
    
public int roadType2;
    
public double roadType2ID;
    
public ERTexture road2ERTexture;
    
private float 5AAA1;
    
private float 6AAAA;
    
private float 7AAA1;
    
private float 8AAAA;
    
public float road2Stretch;
    
public int road2StretchType;
    
public int subdivide2;
    
public float resolution;
    
public int crossingStructure;
    
public bool blend;
    
public int textureType;
    
public int roadStructureType;
    
public String[] crossingStructureStrings;
    
public bool clampUVs;
    
public float attachAngle;
    
public List`1<QDQDOOQQDQODD> roadTypesDynamic;
    
public List`1<Vector3> splinePoints1;
    
public List`1<Vector3> splinePoints2;
    
public List`1<int> roadShapeMaterialInts1;
    
public List`1<int> roadShapeMaterialInts2;
    
public List`1<Vector3> leftRoundingPoints1;
    
public List`1<Vector3> centerPoints1;
    
public List`1<Vector3> rightRoundingPoints1;
    
public List`1<Vector3> leftPointsIndents1;
    
public List`1<Vector3> rightPointsIndents1;
    
public List`1<Vector3> middlePoints1;
    
public List`1<Vector3> leftPoints13;
    
public List`1<Vector3> rightPoints12;
    
public List`1<Vector2> leftRoundingPointsUV1;
    
private List`1<Vector2> 9AAA1;
    
public List`1<Vector2> rightRoundingPointsUV1;
    
public List`1<Vector2> leftPointsIndentsUV1;
    
public List`1<Vector2> rightPointsIndentsUV1;
    
public List`1<Vector3> leftRoundingPoints2;
    
public List`1<Vector3> centerPoints2;
    
public List`1<Vector3> rightRoundingPoints2;
    
public List`1<Vector3> leftPointsIndents2;
    
public List`1<Vector3> rightPointsIndents2;
    
public List`1<Vector3> middlePoints2;
    
public List`1<Vector3> rightPoints23;
    
public List`1<Vector2> leftRoundingPointsUV2;
    
private List`1<Vector2> BAAAA;
    
public List`1<Vector2> rightRoundingPointsUV2;
    
public List`1<Vector2> leftPointsIndentsUV2;
    
public List`1<Vector2> rightPointsIndentsUV2;
    
public List`1<Vector3> priorityConnectionPoints;
    
public List`1<Vector2> priorityConnectionPointsUV;
    
public float minAngle12;
    
public float minAngle13;
    
public float minAngle23;
    
public Vector2 cpUV1;
    
public Vector2 cpUV2;
    
public Vector2 cpUV3;
    
public List`1<Vector3> ll1;
    
public List`1<Vector3> ll2;
    
public List`1<Vector3> ll3;
    
public List`1<Vector3> ll4;
    
public Vector3 l1Start;
    
public Vector3 l1End;
    
public Vector3 l2Start;
    
public Vector3 l2End;
    
public Vector3 l3Start;
    
public Vector3 l3End;
    
public Vector3 r1Start;
    
public Vector3 r1End;
    
public Vector3 r2Start;
    
public Vector3 r2End;
    
public Vector3 r3Start;
    
public Vector3 r3End;
    
public Vector3 ip12;
    
public Vector3 ip23;
    
public Vector3 ip13;
    
public Vector3 ip13Left;
    
public Vector3 ip12right;
    
public Vector3 ip23right;
    
public Vector3 cp1Left;
    
public Vector3 cp1Right;
    
public Vector3 cp2Left;
    
public Vector3 cp2Right;
    
public Vector3 cp3Left;
    
public Vector3 cp3Right;
    
public bool lock1;
    
public bool lock2;
    
public bool lock3;
    
private float CAAA1;
    
private float 00AAA;
    
public ERModularRoad road1;
    
public ERModularRoad road2;
    
public List`1<Vector2> roadShape1;
    
public List`1<Vector2> roadShape2;
    
public List`1<float> roadShapeUVs1;
    
public List`1<float> roadShapeUVs2;
    
public List`1<Material> roadMaterials1;
    
public List`1<Material> roadMaterials2;
    
public List`1<Vector3> leftPoints;
    
public List`1<Vector3> rightPoints;
    
public float connectorLength1;
    
public float connectorLength2;
    
public float blendDistance;
    
public int blendSection;
    
public bool triangleStrip;
    
public float triangleStripDistance;
    
public float triangleStripUVStart;
    
public float triangleStripUVEnd;
    
public Material triangleStripMaterial;
    
public Material blendMaterial;
    
public Material transitionMaterial;
    
public bool transitionSwap;
    
public int proceduralMaterialIndex;
    
public bool presetSwapped;
    
public float t1;
    
public float t2;
    
public GameObject go1;
    
public GameObject go2;
    
public GameObject go3;
    
public GameObject go4;
    
public ERCrossingPrefabs prefabScript;
    
public List`1<Vector3> surfaceVecs;
    
public Vector3 testPoint;
    
public GameObject surfaceMesh;
    
public ERModularBase baseScript;
    
public Vector3 centerDir;
    
public Vector3 cp1;
    
public Vector3 cp2;
    
public Vector3 cp3;
    
public Vector3 cp4;
    
public Vector3 tv;
    
public List`1<Vector3> tvecs;
    public void UpdateERTexture(int road);
    public void OCQOQCDCQC(ERModularRoad sourceRoad);
    public void GetIConnectionData(List`1<Vector3> vecs1, List`1<bool> conInts1, List`1<bool> conInts2, bool reversed1, bool reversed2, int road2Start);
    public void GetLeftRightInts(List`1<Vector2> roadShape, Int32& mostLeftInt, Int32& mostRightInt);
    public void OQQCQCCODO(List`1<Vector3> splinePoints, List`1<Vector3> splinePointsOther, List`1& vecs, List`1& uvs, List`1& tris, List`1<Vector2> roadShape, List`1<float> roadShapeUVs, List`1<int> roadShapeMaterialInts, float uvRatio, float stretchRatio, float stretchType, List`1& leftPoints, List`1& rightPoints, bool reversed, Vector3 cDir, int firstSecond, int startEnd);
    public List`1<Vector2> OODCQQQQCQ(float startY, List`1<Vector3> splinePoints, List`1<float> roadShapeUVs, float uvRatio, bool reversed, float sourceUV);
    public void OCOQOQOCOQ(List`1& colors, List`1<Vector3> splinePoints1, List`1<Vector3> splinePoints2, List`1<Vector2> roadShape1, List`1<Vector2> roadShape2);
    public void ODDCCDQDCO(List`1& targetArray, List`1<Vector3> otherArray);
    public void SetUVS(List`1<Vector3> leftRoundingPoints, List`1<Vector3> leftPointsIndents, List`1<Vector3> centerPoints, List`1<Vector3> rightPointsIndents, List`1<Vector3> rightRoundingPoints, List`1& leftRoundingPointsUV, List`1& leftPointsIndentsUV, List`1& centerPointsUV, List`1& rightPointsIndentsUV, List`1& rightRoundingPointsUV, Vector2& cp, float leftIndentUVX, float rightIndentUVX);
    public Mesh ODDDOCDCQO();
    private void OCOQOCDCCQ(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs);
    private void OCQODCOQDO(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs);
    private List`1<int> Triangulate(List`1<Vector3> vecs, List`1<Vector3> edges);
    public List`1<Vector3> OQDDOOOOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float tension, float res, float distance, Single& tValue);
    public void OQCDDQOCOD(List`1& splinePoints, float distance);
    public void Clear();
    public void OOODDOCOOO();
    public void OOOQQDDCCQ(ERTexture roadERTexture, Single& roadWidth, Single& leftIndent, Single& rightIndent, Single& leftUVX, Single& rightUVX, Single& leftIndentInner, Single& rightIndentInner, Single& roadOuterUVXInner, float cornerRadius);
    public static void OCDCCQQQCO(List`1<Vector3> leftPoints, List`1<Vector3> rightPoints, GameObject& surfaceMesh, Transform tr, List`1& surfaceVecs, float indentLeftStart, float indentLeftEnd, float surroundingLeftStart, float surroundingLeftEnd, float indentRightStart, float indentRightEnd, float surroundingRightStart, float surroundingRightEnd, ERModularBase baseScript, bool hasMesh);
}
public enum EasyRoads3Dv3.ERIndentAlignment : Enum {
    
public int value__;
    
public static ERIndentAlignment Road;
    
public static ERIndentAlignment Terrain;
    
public static ERIndentAlignment Surrounding;
}
public class EasyRoads3Dv3.ERLane : ValueType {
    
public float position;
    
public ERLaneDirection direction;
    
public ERDirectionType turnDirection;
    
public int laneIndex;
    public ERLane(float position, ERLaneDirection direction, int index);
    public ERLane(ERLane lane);
    public void Copy(ERLane lane);
}
public class EasyRoads3Dv3.ERLaneConnector : object {
    
public Vector3 connectorStart;
    
public Vector3 connectorEnd;
    
public Vector3 connectorStartLocal;
    
public Vector3 connectorEndLocal;
    
public Vector3[] points;
    
public int startLaneIndex;
    
public int endLaneIndex;
    
public int endConnectionIndex;
    
public ERLane laneType;
    
public ERDirectionType laneDirection;
    
public float startOffset;
    
public float endOffset;
    
public float strength;
    
public bool mainConnection;
    
public bool stop;
    
public float speedLimit;
    
public float minSpeed;
    
public float maxSpeed;
    public static ERLaneConnector CreateInstance();
    public static List`1<ERLaneConnector> GetLaneConnectors(ERLaneData laneData, int index);
}
public class EasyRoads3Dv3.ERLaneData : object {
    
public Vector3[] points;
    
public List`1<ERLaneConnector> connectors;
    
public ERLane laneType;
    
public int laneIndex;
    
public ERLaneDirection direction;
    public static ERLaneData CreateInstance();
    public static ERLaneData OOOOCQCDDC(List`1<ERLaneData> laneData, int index);
    public bool Exists(int index, int lane);
}
public enum EasyRoads3Dv3.ERLaneDirection : Enum {
    
public int value__;
    
public static ERLaneDirection Left;
    
public static ERLaneDirection Right;
}
public class EasyRoads3Dv3.ERLocalGrid : ScriptableObject {
    
public int id;
    
public string name;
    
public bool gridActive;
    
public bool gridGUIActive;
    
public Color gridColor;
    
public float gridSize;
    
public float gridRadius;
    
public float gridRotation;
    
public Vector3 tl;
    
public Vector3 bl;
    
public Vector3 br;
    
public float xOffset;
    
public float yOffset;
    
public Vector3 OOCDQCOOQC;
    public void Init(ERModularBase scr);
    public static ERLocalGrid CreateInstance(ERModularBase scr);
    public static String[] GridNames(ERModularBase scr);
    public void SetOffsets(ERModularBase scr, Vector3 pos, Vector3 v);
}
public class EasyRoads3Dv3.ERMarker : object {
    
public bool activeSplineNode;
    
public float leftIndent;
    
public int leftIndentAlignment;
    
public float rightIndent;
    
public int rightIndentAlignment;
    
public float leftSurrounding;
    
public float rightSurrounding;
    
public bool bridgeObject;
    
public float bridgeStartLevelDistance;
    
public float bridgeEndLevelDistance;
    
public float rotation;
    
public Vector3 position;
    
public int controlType;
    
public int rotations;
    
public float circularRadius;
    
public float circularAngle;
    
public int circularSegments;
    
public float splineStrength;
    
public Vector3 direction;
    
public Vector3 direction1;
    
public bool followTerrainContours;
    
public int startSplinePoint;
    
public float startDistance;
    
public float startUVY;
    
public float totalDistance;
    
public string totalDistanceString;
    
public string angleString;
    
public float rotationCenter;
    
public List`1<ERSOMarker> soData;
    
public ERMarkerControlType controllerType;
    
public bool attachExit;
    
public int exitType;
    
public int exitGeometryType;
    
public int startExitInt;
    
public int endExitInt;
    
public float startExitOffset;
    
public float extrusionDistance;
    
public int extrusionType;
    
public float fixedDistance;
    
public float connectionAngle;
    
public float connectionRadius;
    
public Material exitMaterial;
    
public Material connectionMaterial;
    
public int exitRoadType;
    
public int connectionRoadType;
    
public List`1<List`1<Vector3>> exitOuterVerticesExtrusion;
    
public List`1<List`1<Vector3>> exitOuterVerticesFixed;
    
public List`1<List`1<Vector3>> exitOuterVerticesCurve;
    
public List`1<Vector3> exitInnerVertices;
    
public List`1<Vector2> roadShape;
    
public List`1<Vector3> roadShapeVecsGlobal;
    
public float markerStartUVY;
    
public Vector3 perpDir;
    
public Vector3 perpDirRotated;
    public ERMarker(Vector3 pos, ERModularRoad scr, int element);
    public void SetControlType(ERMarkerControlType type);
}
public enum EasyRoads3Dv3.ERMarkerControlType : Enum {
    
public int value__;
    
public static ERMarkerControlType Spline;
    
public static ERMarkerControlType StraightXZ;
    
public static ERMarkerControlType StraightXZY;
    
public static ERMarkerControlType Circular;
}
public class EasyRoads3Dv3.ERMarkerExt : ScriptableObject {
    
public bool activeSplineNode;
    
public float leftIndent;
    
public int leftIndentAlignment;
    
public float rightIndent;
    
public int rightIndentAlignment;
    
public float leftSurrounding;
    
public float rightSurrounding;
    
public float radius;
    
public bool bridgeObject;
    
public float bridgeStartLevelDistance;
    
public float bridgeEndLevelDistance;
    
public float rotation;
    
public Vector3 position;
    
public Vector3 oldPosition;
    
public Vector3 positionTmp;
    
public int controlType;
    
public int controlTypeTmp;
    
public int rotations;
    
public float circularRadius;
    
public float circularAngle;
    
public int circularSegments;
    
public float splineStrength;
    
public Vector3 direction;
    
public Vector3 direction1;
    
public Vector3 rl;
    
public Vector3 rr;
    
public bool followTerrainContours;
    
public int startSplinePoint;
    
public float startDistance;
    
public float startUVY;
    
public float totalDistance;
    
public string totalDistanceString;
    
public string angleString;
    
public string gradeString;
    
public float rotationCenter;
    
public List`1<ERSOMarkerExt> soData;
    
public ERMarkerControlType controllerType;
    
public float randomYPosition;
    
public float randomMinYPosition;
    
public float randomMaxYPosition;
    
public float minRandomYPositionDistance;
    
public float maxRandomYPositionDistance;
    
public float randomMinRotation;
    
public float randomMaxRotation;
    
public float minRandomRotationDistance;
    
public float maxRandomRotationDistance;
    
public float prevLeftIndent;
    
public float prevRightIndent;
    
public float prevLeftSurrounding;
    
public float prevRightSurrounding;
    
public int prevControlType;
    
public bool attachExit;
    
public int exitType;
    
public int exitGeometryType;
    
public int startExitInt;
    
public int endExitInt;
    
public float startExitOffset;
    
public float extrusionDistance;
    
public int extrusionType;
    
public float fixedDistance;
    
public float connectionAngle;
    
public float connectionRadius;
    
public Material exitMaterial;
    
public Material connectionMaterial;
    
public int exitRoadType;
    
public int connectionRoadType;
    
public List`1<List`1<Vector3>> exitOuterVerticesExtrusion;
    
public List`1<List`1<Vector3>> exitOuterVerticesFixed;
    
public List`1<List`1<Vector3>> exitOuterVerticesCurve;
    
public List`1<Vector3> exitInnerVertices;
    
public Color customColor;
    
public List`1<Vector2> roadShape;
    
public List`1<Vector3> roadShapeVecsGlobal;
    
public float roadShapeDistanceMin;
    
public float roadShapeDistanceMax;
    
public Vector3 perpDir;
    
public Vector3 perpDirRotated;
    
public float markerStartUVY;
    
public List`1<Vector3> customPoints;
    public void Init(Vector3 pos, ERModularRoad scr, int element);
    public static ERMarkerExt CreateInstance(Vector3 pos, ERModularRoad scr, int element);
    public void SetControlType(ERMarkerControlType type);
    public String[] SoNames();
    public static void OOQQCOQDQC(ERMarkerExt source, ERMarkerExt target, string name);
}
public class EasyRoads3Dv3.ERMaterial : ScriptableObject {
    
public int id;
    
public string name;
    
public double roadType1ID;
    
public double roadType2ID;
    
public double roadType3ID;
    
public Material road1Material;
    
public Material road2Material;
    
public Material road3Material;
    
public float connectorLength1;
    
public float connectorLength2;
    
public float connectorLength3;
    
public float road1Stretch;
    
public float road2Stretch;
    
public float road3Stretch;
    
public int road1StretchType;
    
public int road2StretchType;
    
public int road3StretchType;
    
public int subdivide1;
    
public int subdivide2;
    
public int subdivide3;
    
public float resolution;
    
public bool blend;
    
public float blendDistance;
    
public int blendSection;
    
public bool triangleStrip;
    
public float triangleStripDistance;
    
public float triangleStripUVStart;
    
public float triangleStripUVEnd;
    
public Material triangleStripMaterial;
    public void Init(ERModularBase scr);
    public static ERMaterial CreateInstance(ERModularBase scr);
    public static String[] OCQOOCOQQC(ERModularBase scr);
    public static ERMaterial OQDQOCCODO(ERModularBase scr, ERIConnector prefab, Int32& targetRoad, Int32& index);
    public static Material OOQCDDQODC(ERModularBase scr, ERIConnector prefab);
}
public class EasyRoads3Dv3.ERMath : object {
    public static Vector3 GetPosition(Vector3[] points, Vector3 position, Single& distance, Int32& currentIndex, Single& t);
}
public class EasyRoads3Dv3.ERMesh : object {
    
public List`1<int> vecsInt;
    
public List`1<Vector3> vecs;
    
public List`1<Vector2> uv;
    
public List`1<Vector2> uv2;
    
public List`1<Color> colors;
    
public List`1<Vector3> normals;
    
public List`1<Vector4> tangents;
    
public List`1<int> triangles;
    
public List`1<int> triangles2;
    
public List`1<int> startVecsInt;
    
public List`1<Vector3> startVecs;
    
public List`1<Vector2> startUv;
    
public List`1<Vector2> startUv2;
    
public List`1<Color> startColors;
    
public List`1<Vector3> startNormals;
    
public List`1<Vector4> startTangents;
    
public List`1<int> startTriangles;
    
public List`1<int> startTriangles2;
    
public List`1<int> endVecsInt;
    
public List`1<Vector3> endVecs;
    
public List`1<Vector2> endUv;
    
public List`1<Vector2> endUv2;
    
public List`1<Color> endColors;
    
public List`1<Vector3> endNormals;
    
public List`1<Vector4> endTangents;
    
public List`1<int> endTriangles;
    
public List`1<int> endTriangles2;
    
public List`1<int> suVecsInt;
    
public List`1<Vector3> suVecs;
    
public List`1<Vector2> suUv;
    
public List`1<Vector2> suUv2;
    
public List`1<Color> suColors;
    
public List`1<Vector3> suNormals;
    
public List`1<Vector4> suTangents;
    
public List`1<int> suTriangles;
    
public List`1<int> suTriangles2;
    
public List`1<int> sdVecsInt;
    
public List`1<Vector3> sdVecs;
    
public List`1<Vector2> sdUv;
    
public List`1<Vector2> sdUv2;
    
public List`1<Color> sdColors;
    
public List`1<Vector3> sdNormals;
    
public List`1<Vector4> sdTangents;
    
public List`1<int> sdTriangles;
    
public List`1<int> sdTriangles2;
    
public List`1<Material> materials;
    
public List`1<Vector3> sVecs;
    
public List`1<Vector2> sUv;
    
public List`1<Vector2> sUv2;
    
public List`1<Color> sColors;
    
public List`1<Vector3> sNormals;
    
public List`1<Vector4> sTangents;
    
public List`1<int> sTriangles;
    
public List`1<Vector3> sTerrainNormals;
    
public List`1<List`1<Vector3>> sVecsGroups;
    
public List`1<List`1<Vector2>> sUvGroups;
    
public List`1<List`1<Vector2>> sUv2Groups;
    
public List`1<List`1<Color>> sColorsGroups;
    
public List`1<List`1<Vector3>> sNormalsGroups;
    
public List`1<List`1<Vector4>> sTangentsGroups;
    
public List`1<List`1<int>> sTrianglesGroups;
    
public List`1<List`1<Vector3>> sTerrainNormalsGroups;
    
public List`1<Vector3> sStartVecs;
    
public List`1<Vector2> sStartUv;
    
public List`1<Vector2> sStartUv2;
    
public List`1<Color> sStartColors;
    
public List`1<Vector3> sStartNormals;
    
public List`1<Vector4> sStartTangents;
    
public List`1<int> sStartTriangles;
    
public List`1<Vector3> sEndVecs;
    
public List`1<Vector2> sEndUv;
    
public List`1<Vector2> sEndUv2;
    
public List`1<Color> sEndColors;
    
public List`1<Vector3> sEndNormals;
    
public List`1<Vector4> sEndTangents;
    
public List`1<int> sEndTriangles;
    
public List`1<Vector3> sSuVecs;
    
public List`1<Vector2> sSuUv;
    
public List`1<Vector2> sSuUv2;
    
public List`1<Color> sSuColors;
    
public List`1<Vector3> sSuNormals;
    
public List`1<Vector4> sSuTangents;
    
public List`1<int> sSuTriangles;
    
public List`1<Vector3> sSdVecs;
    
public List`1<Vector2> sSdUv;
    
public List`1<Vector2> sSdUv2;
    
public List`1<Color> sSdColors;
    
public List`1<Vector3> sSdNormals;
    
public List`1<Vector4> sSdTangents;
    
public List`1<int> sSdTriangles;
    
public int startEndVecCount;
    
public int middleStartVecCount;
    
public int middleEndVecCount;
    
public int endStartVecCount;
    
public List`1<Vector3> middleEndVecs;
    
public List`1<int> startEndInts;
    
public List`1<int> middleStartInts;
    
public List`1<int> middleEndInts;
    
public List`1<int> middleStartStartInts;
    
public List`1<int> middleEndEndInts;
    
public List`1<int> endStartInts;
    
public List`1<int> startEndIntsNC;
    
public List`1<int> middleStartStartIntsNC;
    
public List`1<int> middleStartIntsNC;
    
public List`1<int> middleEndIntsNC;
    
public List`1<int> middleEndEndIntsNC;
    
public List`1<int> endStartIntsNC;
    
public int OQOQODDQCCInt;
    
public int ODQCDQCCODInt;
    
public int middleLeftInt;
    
public int middleRightInt;
    
public int endLeftInt;
    
public int endRightInt;
    
public List`1<int> normalArray1;
    
public List`1<int> normalArray2;
    
public List`1<List`1<int>> normalArray1Group;
    
public List`1<List`1<int>> normalArray2Group;
    
public int vecCount;
    
public List`1<float> zValues;
    
public List`1<ZIndexArray> zValueVecIndexes;
    
public List`1<float> zValuesStart;
    
public List`1<ZIndexArray> zValueVecIndexesStart;
    
public List`1<float> zValuesEnd;
    
public List`1<ZIndexArray> zValueVecIndexesEnd;
    
public List`1<float> zValuesStepUp;
    
public List`1<ZIndexArray> zValueVecIndexesStepUp;
    
public List`1<float> zValuesStepDown;
    
public List`1<ZIndexArray> zValueVecIndexesStepDown;
    
public float minZ;
    
public float minMiddleZ;
    
public float maxZ;
    
public float maxMiddleZ;
    
public float totalZDistance;
    
public float offset1;
    
public float offset2;
    
public List`1<int> vertexBatches;
    
public List`1<int> triangleBatches;
    
public int lodIndex;
    
public bool castShadows;
    
public string name;
    
public bool terrainMesh;
    public ERMesh(GameObject m_go, SideObject soScript, float minZ, Transform sourceTransform, Vector3 scale, Mesh m, Material mat, float startMin, bool rotate180);
    public void OCQQQCQQDD();
    private void OCDCDCQQDQ(GameObject m_go, SideObject soScript, float minZ, Transform sourceTransform, Vector3 scale, Mesh m, Material mat, float startMin, bool namingConvention);
    private void OCDCQCQQOC(List`1<Vector3> vecs, List`1& zValueVecIndexes, List`1& zValues);
    public void GetMiddleSementInfo(List`1<Vector3> vecs, Single& minMiddleZ, Single& maxMiddleZ, List`1& middleStartInts, List`1& middleEndInts);
    public void GetMiddleEdges(List`1<Vector3> vecs, float z, List`1& edgeInts);
    public bool OOCDOCOCQO(Vector3 v, int index, List`1<float> zV, List`1& zVIndexes);
    public void OCDQOQOCCD(int index, Vector3 v, List`1& vecsInts, List`1& vecs, List`1& uv, List`1& uv2, List`1& normals, List`1& colors, List`1& tangents, Vector2 sourceUv, Vector2 sourceUv2, Vector3 sourceNormal, Color sourceColor, Vector4 sourceTangent, Int32& tri);
    public void ODDDDDQDOQ(int index, List`1& vecsInts);
    public void InEdgePairArray(int index1, int index2, List`1& vecsInts);
    public void OQCDQOQOCQ(float adjustZ);
    public void OCDDCDODQQ(List`1& groups, List`1<int> triInts, List`1<int> edgeInts);
    public void OOQOCOQOOO(List`1<CRedge> edges, Int32& curInt);
    public bool OCCCOQOCQO(List`1<CRedge> edges, int index, int curInt);
    public bool ODDDDDQDOQ(int index, List`1<int> edgeInts);
    public bool OCDOQODCCQ(List`1<CRedge> edges, int index1, int index2);
    public void MatchEdgePairs(List`1<CRedge> startEdgePairs, List`1<CRedge> endEdgePairs, List`1& startInts, List`1& endInts, List`1& startIntsNC, List`1& endIntsNC, List`1<Vector3> startVecs, List`1<Vector3> endVecs, List`1<Vector3> startNormals, List`1<Vector3> normals, Int32& OQOQODDQCCInt, Int32& ODQCDQCCODInt);
    public void OQOCDDCQDD(List`1<List`1<int>> startGroups, List`1<List`1<int>> endGroups, List`1& startInts, List`1& endInts, List`1<Vector3> startVecs, List`1<Vector3> endVecs);
    public void ODDDOCDCQO(ERModularRoad roadScr, GameObject go, SideObject so, ERModularBase scr, bool mirrored, int sectionListIndex, List`1<int> sectionIndexes, int autoSectionStart);
    public static bool OQCQCDQDOO(ERModularRoad rd, int listIndex, int listItemIndex, SideObject so, bool mirrored);
    private void OODCCOCQOC(GameObject go, SideObject so, ERModularBase scr, List`1<Vector3> sVecs, List`1<Vector2> sUv, List`1<Vector2> sUv2, List`1<Color> sColors, List`1<Vector3> sNormals, List`1<Vector4> sTangents, List`1<int> sTriangles, List`1<int> normalArray1, List`1<int> normalArray2, List`1<Material> materials, List`1<Vector3> sTerrainNormals);
    private void OCOCOQQOOO(Int32& vecCount, List`1& intList, List`1<Vector3> vecsList, float zValue);
    private void OCODQQOCDD(List`1& targetIntList, List`1<int> sourceIntList, List`1<Vector3> targetVecs, List`1<Vector3> sourceVecs);
    public void Clear();
}
public class EasyRoads3Dv3.ERMeshCombineUtility : object {
    public static Mesh Combine(Transform container, MeshInstance[] combines, bool generateStrips);
    private static void Copy(int vertexcount, Vector3[] src, Vector3[] dst, Int32& offset, Matrix4x4 transform);
    private static void CopyNormal(int vertexcount, Vector3[] src, Vector3[] dst, Int32& offset, Matrix4x4 transform);
    private static void Copy(int vertexcount, Vector2[] src, Vector2[] dst, Int32& offset);
    private static void CopyTangents(int vertexcount, Vector4[] src, Vector4[] dst, Int32& offset, Matrix4x4 transform);
    public static void CombineMesh(GameObject go, Mesh mesh, Transform container, bool isSideObject);
    public static List`1<MeshInstance> GetCombinedInstances(List`1<CombineClass> mToMesh, Material m);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERMeshUtility : MonoBehaviour {
    
public ERModularBase baseScript;
    
public int sourceInt;
    
public string name;
    public void OCQOQCDCQC();
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERModularBase : MonoBehaviour {
    
public int updateInt;
    
public bool newSplatMapRestoreCode;
    
public int toolbarInt;
    
public int oldToolbarInt;
    
public int roadToolbarInt;
    
public int markerToolbarInt;
    
public Texture[] menuTexs;
    
public Texture[] subMenuTexs;
    
public GameObject cprefab;
    
public Texture nodeHandleTexture;
    
public Texture lockedTexture;
    
public Texture unLockedTexture;
    
public Texture favOffTexture;
    
public Texture favOffFreeTexture;
    
public Texture favOnTexture;
    
public Texture selRoadTexture;
    
public Texture headerTexture;
    
public Texture sceneGUITex;
    
public Texture soIcon;
    
public Transform roadObjectsParent;
    
public Transform connectionObjectsParent;
    
public GameObject OCOQDODDQQ;
    
public List`1<QDQDOOQQDQODD> roadTypes;
    
public int selectedRoadType;
    
public int selectedNewRoadType;
    
public List`1<QDQDOOQQDQODD> inspRoadTypes;
    
public List`1<int> inspRoadTypeInts;
    
public List`1<ERDecal> decalPresets;
    
public float roadWidth;
    
public Material roadMaterial;
    
public Material crossingMaterial;
    
public Material roundAboutMaterial;
    
public Material roundAboutConnectionMaterial;
    
public Material roundAboutRoadMaterial;
    
public Material sidewalkMaterial;
    
public Material targetMaterial;
    
public Terrain sourceTerrain;
    
public String[] roadMaterials;
    
public String[] connectionMaterials;
    
public int selectedMaterial;
    
public int selectedConnectionMaterial;
    
public List`1<ERMaterial> materials;
    
public int selectedRoadRoadType;
    
public bool roadOptions;
    
public bool sidewalkOptions;
    
public bool markerOptions;
    
public bool showRoadSideObjects;
    
public bool markerSOOptions;
    
public bool roadTerrainOptions;
    
public bool camFlyOver;
    
public int selectedRoadMaterial;
    
public int roadTextureInfoIndex;
    
public Texture2D selectedRoadTexture;
    
public float selectedRoadWidth;
    
public float selectedRoadLeftOffset;
    
public float selectedRoadRightOffset;
    
public float selectedRoadLeftInnerOffset;
    
public float selectedRoadRightInnerOffset;
    
public int selectedCrossingMaterial;
    
public int crossingTextureInfoIndex;
    
public int handleSelection;
    
public int positionHandleSelection;
    
public bool markerDirXZ;
    
public GameObject defaultCrossing;
    
public GameObject defaultTCrossing;
    
public GameObject defaultCulDeSac;
    
public GameObject defaultRoundabout;
    
public Texture2D tex;
    
public Texture2D infoTexture;
    
public bool showAllPrefabs;
    
public bool standardPrefabsFlag;
    
public bool sceneSettingsFoldOut;
    
public bool sceneRoadsFoldOut;
    
public bool scenePrefabsFoldOut;
    
public bool sidewalksFoldOut;
    
public bool terrainManagementFoldOut;
    
public bool importRoadDataFoldOut;
    
public bool lodGroupsFoldOut;
    
public bool defaultMaterialsFoldOut;
    
public bool aiTrafficFoldout;
    
public bool kmlFlag;
    
public bool osmFlag;
    
public bool useOSMHeights;
    
public float heightRatio;
    
public bool dynamicPrefabsFoldOut;
    
public bool customPrefabsFoldOut;
    
public List`1<ERConnectionGUIStatus> dynamicFavList;
    
public List`1<ERConnectionGUIStatus> customFavList;
    
public float prefabsDisplayType;
    
public bool ignoreTerrainAlerts;
    
public double osmTerrainTopLon;
    
public double osmTerrainBottomLon;
    
public double osmTerrainLeftLat;
    
public double osmTerrainRightLat;
    
public float terrainMinIndent;
    
public float minIndent;
    
public float minSurrounding;
    
public float maxIndentSurrounding;
    
public float terrainY;
    
public float terrainDetailSplatX;
    
public float terrainDetailSplatY;
    
public Vector3 detailOffsetVec;
    
public float raise;
    
public Vector3 baseVector;
    
public bool mirrorCrossings;
    
public String[] terrainNames;
    
public Terrain[] terrainObjects;
    
public String[] terrainSplatTextures;
    
public Terrain activeTerrain;
    
public float activeTerrainY;
    
public int selectedTerrain;
    
public bool selectedRoadsOnly;
    
public bool terrainDone;
    
public bool enableBackWithoutRestore;
    
public float detailDistance;
    
public float treeDistance;
    
public bool doHeightmap;
    
public bool doTrees;
    
public bool soTrees;
    
public bool doDetail;
    
public Rect terrainRect;
    
public List`1<GameObject> tunnelObjects;
    
public List`1<GameObject> surfaceObjects;
    
public float preserveTerrainFloat;
    
public float terrainSmoothIndentDistance;
    
public float terrainSmoothSurroundingDistance;
    
public int indentSmoothStep;
    
public int surroundingSmoothStep;
    
public bool doTangents;
    
public bool doLightmapUVs;
    
public bool doLODGroups;
    
public bool doSplatmaps;
    
public int sLayer;
    
public List`1<Vector3> terrainHits;
    
public List`1<Vector3> osmCrossingPoints;
    
public List`1<CrossingCornerClass> cornerPresets;
    
public List`1<SidewalkPresetClass> sidewalkPresets;
    
public List`1<ERSideWalk> sidewalks;
    
public int selectedSidewalk;
    
public int selectedRoadTypeSidewalk;
    
public int osmMotorway;
    
public int osmMotorwayLink;
    
public int osmTrunk;
    
public int osmPrimary;
    
public int osmSecondary;
    
public int osmTertiary;
    
public int osmUnclassified;
    
public int osmResidential;
    
public int osmService;
    
public int osmTrack;
    
public int osmPath;
    
public int osmWalkway;
    
public int osmRaceway;
    
public int osmHighwayStringInt;
    
public bool osmMotorwayFlag;
    
public bool osmMotorwayLinkFlag;
    
public bool osmTrunkFlag;
    
public bool osmPrimaryFlag;
    
public bool osmSecondaryFlag;
    
public bool osmTertiaryFlag;
    
public bool osmUnclassifiedFlag;
    
public bool osmResidentialFlag;
    
public bool osmServiceFlag;
    
public bool osmTrackFlag;
    
public bool osmPathFlag;
    
public bool osmWalkwayFlag;
    
public bool osmRacewayFlag;
    
public string osmHighwayString;
    
public int kmlRoadType;
    
public bool lodGroups;
    
public int LODLevels;
    
public List`1<float> LODLevelValues;
    
public List`1<float> LODLevelResolution;
    
public bool embedRoadShape;
    
public bool hideSurfaces;
    
public bool showSurfaces;
    
public bool useLightProbes;
    
public bool hideLockedObjects;
    
public bool ODQCODODDD;
    
public bool isInBuildMode;
    
public bool progressFlag;
    
public int progressTerrain;
    
public float progressStatus;
    
public float progressMax;
    [SerializeField]

public List`1<SideObject> QOQDQOOQDDQOOQ;
    
public String[] sideObjectNames;
    
public int selSideObject;
    
public int selSubSideObject;
    
public string soID;
    
public string sideObjectName;
    [SerializeField]

public int sideObjectType;
    
public GameObject sideObjectSource;
    
public GameObject soEndObject;
    
public int sideObjectTerrainVegetationInt;
    
public int prefabChildHandling;
    
public float sideObjectDistance;
    
public int soYAxisRotation;
    
public float soSidewaysDistance;
    
public int soSidewaysDistanceHandling;
    
public float soDensity;
    
public float soOffset;
    
public int soTerrainAligment;
    
public bool soCombine;
    
public bool soWeld;
    
public int soControllerType;
    
public Material soMaterial;
    
public float soXPosition;
    
public float soYPosition;
    
public bool soMarkerActive;
    
public bool enableSOHandles;
    
public bool enableShapeNodeHandles;
    
public bool enableSOShapeNodeHandles;
    
public bool displayCriticalPoints;
    
public bool highlightRoad;
    
public bool highlightIndents;
    
public bool highlightSurroundings;
    
public bool highlightSideObject;
    
public Color highlightRoadColor;
    
public Color highlightIndentColor;
    
public Color highlightSurroundingColor;
    
public bool onlyShowSelectedRoad;
    
public List`1<GameObject> soDeformationObjects;
    
public List`1<GameObject> soSplatmapObjects;
    
public bool buildSOinEditMode;
    
public bool tangentsInEditMode;
    
public bool calculateSmoothNormals;
    
public bool importSideObjectsAlert;
    
public bool importRoadPresetsAlert;
    
public bool importCrossingPresetsAlert;
    
public bool importSidewalkPresetsAlert;
    
public bool updateSideObjectsAlert;
    
public bool updateRoadPresetsAlert;
    
public bool updateCrossingPresetsAlert;
    
public bool updateSidewalkPresetsAlert;
    
public float waypointDistance;
    
public List`1<ERModularRoad> RoadObjectsSoUpdates;
    
public string assetsFolderID;
    
public GameObject meshSurface;
    
public Collider meshTerrainCollider;
    
public float markerScale;
    
public float markerDistance;
    
public float minMarkerDistance;
    
public float maxMarkerDistance;
    
public bool debugFlag;
    
public List`1<Vector3> leftTHandles;
    
public List`1<Vector3> rightTHandles;
    
public float roadNetworkY;
    
public bool ignoreMinIndents;
    
public Vector3 zoomStart;
    
public Vector3 zoomEnd;
    
public Vector3 lookAtStart;
    
public Vector3 lookAtEnd;
    
public Quaternion zoomRot;
    
public float zoomStartTime;
    
public bool hideSurfaceHandles;
    
public bool dirtyBool;
    
public bool dirtyOnSceneBool;
    
public bool forceRoadNetworkSelect;
    
public bool ODQDQDQDCO;
    
public ERCrossingPrefabs OCOQDODDQQScript;
    
public ERCrossings OOOQDOQCCOCrossingsScript;
    
public ERCrossingPrefabs OOOQDOQCCOScript;
    
public int OCOQDODDQQElement;
    
public int OQCOQCOQQQ;
    
public ERModularRoad OCCQOOOQQO;
    
public ERModularRoad OODDQOOCOD;
    
public int OCODDDQOQC;
    
public int selectedRoadSOMarker;
    
public int selectedMarkerNode;
    
public List`1<int> selectedMarkerNodes;
    
public int selectedMarkerSONode;
    
public List`1<int> selectedMarkerSONodes;
    
public List`1<SelectedObject> selectedObjects;
    
public int selectedExitRoad;
    
public bool newRoadFlag;
    
public bool roadTypeUpdateFlag;
    
public List`1<ERModularRoad> roadScripts;
    
public List`1<ERCrossingPrefabs> prefabScripts;
    
public bool globalGridActive;
    
public bool gridGUIActive;
    
public Color globalGridColor;
    
public float globalGridSize;
    
public float globalGridRadius;
    
public float globalGridRotation;
    
public Vector2 gridOffset;
    
public Vector3 ggTL;
    
public Vector3 ggBL;
    
public Vector3 ggBR;
    
public bool localGridActive;
    
public List`1<ERLocalGrid> localGrids;
    
public int selectedLocalGrid;
    
public MethodInfo crMethod;
    
public MethodInfo upMethod;
    
public MethodInfo hmMethod;
    
public MethodInfo rmMethod;
    
public MethodInfo crBiomeMethod;
    
public MethodInfo upBiomeMethod;
    
public MethodInfo rmBiomeMethod;
    
public MethodInfo thMethodGet;
    
public MethodInfo thMethodSet;
    
public ERSideWalk sw;
    
public bool roadUpdated;
    
public bool clampUVs;
    
public int soCategoryInt;
    
public int soRoadCategoryInt;
    
public float minRoadWidth;
    
public float maxRoadWidth;
    
public float maxCurbHeight;
    
public float minCornerRadius;
    
public float maxCornerRadius;
    
public GameObject SoTestObject;
    
public bool lockRoadNetwork;
    
public bool showNotifications;
    
public bool multipleTerrainsWarning;
    
public Texture2D[] OCDCDDQDQC;
    
public Texture2D[] OCDCOCCCCC;
    
public int textureCounter;
    
public static bool AssembliesSet;
    
public bool vegetationStudio;
    
public bool vegetationStudioPro;
    
public bool vegetationStudioActive;
    
public bool vegetationStudioMaskLineActive;
    
public float vegetationStudioGrassPerimeter;
    
public float vegetationStudioPlantPerimeter;
    
public float vegetationStudioTreePerimeter;
    
public float vegetationStudioObjectPerimeter;
    
public float vegetationStudioLargeObjectPerimeter;
    
public bool vegetationStudioBiomeMaskActive;
    
public float vegetationStudioBiomeMaskDistance;
    
public float vegetationStudioBiomeMaskBlendDistance;
    
public float vegetationStudioBiomeMaskNoiseScale;
    
public bool aiTraffic;
    
public bool aiMatchingLanesOnly;
    
public bool aiconnectNonMatchinglaneCounts;
    
public bool aiIgnoreConnections;
    
public bool displayLaneData;
    
public int rightHandDriving;
    
public Color leftLaneHandleColour;
    
public Color rightLaneHandleColour;
    
public Color laneHandleSelectedColour;
    
public float roadUvThreshold;
    
public int updateQueue;
    
public static bool checkPresets;
    
public bool logChange;
    
public bool debugMode;
    
public bool RoadNetworkInitFlag;
    
public static RoadUpdate onRoadUpdate;
    
public static OnBuildMode onBuildModeEnter;
    
public List`1<GameObject> excludeFromSelection;
    
public GameObject addExcludeFromSelection;
    
public Color shapeUVColor;
    
public Color startCapColor;
    
public Color endCapColor;
    
public Material soSectionMaterial;
    
public bool v32b4Flag;
    private static ERModularBase();
    public void OnBuildModeEnter();
    public void OnRoadUpdate(ERRoad road);
    public void RoadNetworkInit();
    public void UpdateQueue();
    public void SetRoadTypeList();
    public void UpdateRoadTypeStatus();
    public void OCOCQOODCO();
    public void OCQODDDCQQ();
    public void ODODOQOODO();
    public void OOCQCCCQCD();
    public void OQDQQODDCD(GameObject go, Vector3 pos);
    public void ODCDQQCQOC();
    public ERCrossingPrefabs OCDQQCQCQQ(GameObject prefab, ERModularRoad OCCQOOOQQO, int OCODDDQOQC, int connectionSegment);
    public ERCrossingPrefabs AttachConnector(ERModularRoad OCCQOOOQQO, int OCODDDQOQC);
    public void OCCDCDQOOD(ERModularRoad OCCQOOOQQO, int selectedMarker);
    public int OOOCOQQDQO(ERModularRoad OCCQOOOQQO, ERCrossingPrefabs prefabScript, int OCODDDQOQC, int startConnection, bool swapFlag);
    public int OOQQQQCCOC(string roadShapeString, List`1<string> strings, List`1<QDOODOQQDQODD> crossingElements);
    public GameObject OOQDQOOQQQ(GameObject prefab, Vector3 hitPos, GameObject& newPrefab, ERCrossingPrefabs& prefabScript, ERCrossings& crossingsScript);
    public void OQOCDOOQCQ(ERCrossingPrefabs prefabScript);
    public void OQCDDCDDQC(GameObject newPrefab, GameObject prefab);
    public void ODDQCOQCQC();
    public List`1<ERTerrain> OODQQODOOC(Boolean& multTerrainResFlag);
    public void ODDCCODOOC();
    public void OQQQDCQOOC(bool restoreTerrain);
    public void OQQOOCQQCD(Vector3 pos);
    public void OCDDQOCDCO(Vector3& pos);
    public Vector3 OQOODODDQO(Vector3 pos);
    public Vector2 GetTerrainUV(Vector3 pos);
    public Terrain OQOQDDOQOD(Vector3& pos, bool setSelected);
    public void OQCQQQDQQD();
    public void UpdateLODLevels(int levels);
    public void UpdateSideObjectsInScene();
    public void OOCDOOCQQC();
    public void OQQDDOQQOO();
    public ERRoadType[] GetRoadTypes();
    public ERRoadType GetRoadTypeByName(string name);
    public string GetNewRoadName(double id);
    public string GetRoadNameByID(double id);
    public SideObject OQCDCQCDCQ(string name);
    public void InitLoadImage(string url);
    private IEnumerator LoadImage(string url);
    public IEnumerator BuildTerrainRoutine(ERRoadNetwork roadNetwork);
    public float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERModularRoad : MonoBehaviour {
    
public ERModularBase baseScript;
    
public string roadName;
    
public bool locked;
    
public double roadType;
    
public QDQDOOQQDQODD rt;
    
public int defaultControlType;
    
public bool isCustomRoadSet;
    
public bool isCustomRoad;
    
public List`1<ERMarker> markers;
    
public List`1<ERMarker> tmpMarkers;
    
public List`1<ERMarkerExt> markersExt;
    
public List`1<ERMarkerExt> tmpMarkersExt;
    
public List`1<float> tValues;
    
public float roadWidth;
    
public float faceDistance;
    
public float angleTreshold;
    
public bool resolutionFlag;
    
public bool angleThresholdFlag;
    
public bool closedTrack;
    
public float minNodeDistance;
    
public int nodeWithinRange;
    
public float uvTiling;
    
public bool planarUVs;
    
public bool flipNormals;
    
public int defaultLeftSidewalk;
    
public int defaultRightSidewalk;
    
public bool leftSidewalkActive;
    
public bool rightSidewalkActive;
    
public List`1<ERSideWalkInstance> leftSidewalks;
    
public List`1<ERSideWalkInstance> rightSidewalks;
    
public List`1<OQQCCQCDQQ> exitRoads;
    
public int selectedExit;
    
public bool randomnessFlag;
    
public bool randomnessMarkerFlag;
    
public float randomYPosition;
    
public float randomMinYPosition;
    
public float randomMaxYPosition;
    
public float minRandomYPositionDistance;
    
public float maxRandomYPositionDistance;
    
public float randomMinRotation;
    
public float randomMaxRotation;
    
public float minRandomRotationDistance;
    
public float maxRandomRotationDistance;
    
public bool vegetationStudioMaskLineActive;
    
public float vegetationStudioGrassPerimeter;
    
public float vegetationStudioPlantPerimeter;
    
public float vegetationStudioTreePerimeter;
    
public float vegetationStudioObjectPerimeter;
    
public float vegetationStudioLargeObjectPerimeter;
    
public bool vegetationStudioBiomeMaskActive;
    
public float vegetationStudioBiomeMaskDistance;
    
public float vegetationStudioBiomeMaskBlendDistance;
    
public float vegetationStudioBiomeMaskNoiseScale;
    
public int vertsStats;
    
public int trisStats;
    
public float indent;
    
public float surrounding;
    
public bool followTerrainContours;
    
public float terrainContoursOffset;
    
public List`1<Vector2> roadShape;
    
public List`1<int> roadShapeIntsStart;
    
public List`1<int> roadShapeIntsEnd;
    
public List`1<int> roadShapeIntsStartFull;
    
public List`1<int> roadShapeIntsEndFull;
    
public string roadShapeString;
    
public string roadShapeReversedString;
    
public int roadShapeMatchCount;
    
public int geoReversed;
    
public int roadShapeCols;
    
public bool flipRoadUVs;
    
public int subSegments;
    
public List`1<float> nodeDistance;
    
public List`1<float> roadShapeUVs;
    
public List`1<float> roadShapeUVs2;
    
public List`1<bool> doConnectionTri;
    
public List`1<float> randomRotations;
    
public List`1<bool> hardEdge;
    
public List`1<int> roadShapeMaterialInts;
    
public int subMeshCount;
    
public List`1<int> roadShapeMaterialIntCounts;
    
public List`1<Vector3> controlPoints;
    
public List`1<Vector3> splinePoints;
    
public List`1<float> distances;
    
public List`1<int> markerInts;
    
public List`1<Vector3> insertSplinePoints;
    
public List`1<Vector3> soSplinePoints;
    
public List`1<Vector3> soSplinePointsLeft;
    
public List`1<Vector3> soSplinePointsRight;
    
public List`1<Vector3> soSplinePointsLeftClamped;
    
public List`1<Vector3> soSplinePointsRightClamped;
    
public List`1<float> OQCOCCQCCD;
    
public List`1<float> OQQOODQCCC;
    
public List`1<float> bendAngles;
    
public List`1<Vector3> meshVecs;
    
public List`1<Vector2> meshUVs;
    
public List`1<Vector2> meshUVs2;
    
public List`1<List`1<int>> tris;
    
public List`1<Vector3> surfaceMeshVecs;
    
public List`1<Vector3> leftIndentVecs;
    
public List`1<Vector3> rightIndentVecs;
    
public List`1<Vector3> middleIndentVecs;
    
public List`1<Vector3> leftSurroundingVecs;
    
public List`1<Vector3> rightSurroundingVecs;
    
public List`1<Vector3> leftIndentVecsSV;
    
public List`1<Vector3> rightIndentVecsSV;
    
public List`1<bool> bridgeElement;
    
public List`1<Vector3> vecsBelowTerrain;
    
public List`1<Vector3> treeVecs;
    
public List`1<Vector3> detailVecs;
    
public List`1<int> vegetationTris;
    
public List`1<bool> doLeftSurrounding;
    
public List`1<bool> doRightSurrounding;
    
public float totalDistance;
    
public List`1<int> nodeSplinePoint;
    
public string totalDistanceString;
    
public ERCrossingPrefabs startPrefabScript;
    
public ERCrossingPrefabs endPrefabScript;
    
public int startConnectionSegment;
    
public bool startConnectionFlag;
    
public int endConnectionSegment;
    
public bool endConnectionFlag;
    
public bool startSegmentIntAdjusted;
    
public bool endSegmentIntAdjusted;
    
public bool tCrossingConnected;
    
public Material roadMaterial;
    
public Material[] roadMaterials;
    
public PhysicMaterial roadPhysicsMaterial;
    
public PhysicMaterial[] roadPhysicsMaterials;
    
public Vector3 startDir;
    
public Vector3 endDir;
    
public float startAngle;
    
public float endAngle;
    
private int ᙃ;
    
private int ᙄ;
    
public int startbendLeftRight;
    
public int endbendLeftRight;
    
public float connectionAdjustDistanceStart;
    
public float connectionAdjustDistanceEnd;
    
public Vector3 pivotp;
    
public Vector3 p1;
    
public Vector3 p2;
    
public Vector3 p3;
    
public Vector3 p4;
    
public Vector3 p5;
    
public Vector3 p6;
    
public Vector3 p7;
    
public Vector3 cp1;
    
public Vector3 cp2;
    
public Vector3 cp3;
    
public Vector3 cp4;
    
public Vector3 cp5;
    
public Vector3 cp6;
    
public Vector3 cp7;
    
public Vector3 cp8;
    
public Vector3 cp9;
    
public Vector3 cpcenter;
    
public Vector3 p1Circle;
    
public Vector3 p2Circle;
    
public float cpradius;
    
public float cpangle;
    
public Vector3 dp1;
    
public Vector3 dp2;
    
public Vector3 dp3;
    
public Vector3 dp4;
    
public List`1<Vector3> segPoints;
    
public List`1<Vector3> testPoints;
    
public List`1<Vector3> testPoints2;
    
public Vector3 OQOQODDQCC;
    
public Vector3 ODQCDQCCOD;
    
public Vector3 endLeft;
    
public Vector3 endRight;
    
public Mesh testmesh;
    
public GameObject surfaceMesh;
    
public Vector3 sv1;
    
public Vector3 sv2;
    
public Vector3 prefabIndentLeft;
    
public Vector3 prefabIndentRight;
    
public Vector3 roadIndent1;
    
public static int ODQQCDOQOD;
    
public static int OCOQCCDDQC;
    
public static int ODCDCCQCQC;
    
public static int OQDCDCOCQC;
    
public static int OQQQOQOQOQ;
    
public static int OQOQDOCQCD;
    
public Vector3 tmpPerpCP;
    
public Vector3 tmpCP;
    
private int ᙅ;
    
private int 4AAAA;
    
public float splinePos;
    
public float camHeight;
    
public Vector3[] flyOverPoints;
    
public Vector3 splinePosV3;
    
public List`1<float> markerDistances;
    
public string osmRoadType;
    
public List`1<ERSORoad> soData;
    
public List`1<ERSORoadExt> soDataExt;
    
public String[] sideObjectNames;
    
public int selectedSO;
    
public bool rebuildSos;
    
public bool sosCleared;
    
public bool isSideObject;
    
public int startOffsetActiveMarker;
    
public int endOffsetActiveMarker;
    
public float leftToCenterPerc;
    
public ERRoad road;
    
public bool splatMapActive;
    
public int splatIndex;
    
public int expandLevel;
    
public int smoothLevel;
    
public float splatOpacity;
    
public int layer;
    
public bool isStatic;
    
public string tag;
    
public int tagInt;
    
public bool castShadow;
    
public bool fadeInFlag;
    
public float fadeInDistance;
    
public bool fadeOutFlag;
    
public float fadeOutDistance;
    
public bool doSurroundingSurfaces;
    
public bool terrainDeformation;
    
public bool snapToTerrain;
    
public List`1<ERSOSection> soSectionList1;
    
public List`1<ERSOSection> soSectionList2;
    
public List`1<ERSOSection> soSectionList3;
    
public List`1<ERSOSection> soSectionList4;
    
public List`1<ERSOSection> soSectionList5;
    
public List`1<ERSOSection> soSectionList6;
    
public List`1<ERSOSection> soSectionList7;
    
public List`1<ERSOSection> soSectionList8;
    
public bool snapVertices;
    
public float snapOffset;
    
public bool hasMeshCollider;
    
public bool isUpdated;
    
public bool QDDDQODQQDQDQQD;
    
public int uv4Type;
    
public float detailDistance;
    
public bool startDecalCollapsed;
    
public ERDecal startDecal;
    
public ERDecal endDecal;
    
public GameObject startDecalPrefab;
    
public GameObject startDecalPrefabSource;
    
public bool endDecalCollapsed;
    
public GameObject endDecalPrefab;
    
public GameObject endDecalPrefabSource;
    
public int startDecalID;
    
public int endDecalID;
    
public Vector3 lastForward;
    
public bool roadUpdate;
    
public Bounds bounds;
    
public List`1<Vector3> debugVecs;
    
public List`1<float> debugFloats;
    
public Vector3 exitExtrudeEnd;
    
public Vector3 exitFixedEnd;
    
public Vector3 exitSplitEnd;
    
public Texture2D splatTextureMask;
    
public bool lockUVs;
    
public List`1<ERLaneData> laneData;
    
public bool oneWayRoad;
    
public ERLaneDirection oneWayDirection;
    public bool ODDQCOCDQQ(ERCrossingPrefabs prefabScript);
    public void ODQCQCDCDQ(List`1<ERDecal> decalPresets);
    public void OOQOCCOOOD();
    public float GetRoadWidth();
    public void OQQOCOQDCQ(Vector3 pos);
    public int OCDQCCCDCC(Vector3 pos);
    public void GetInsertPointExt(Vector3 pos, Int32& n1, int marker);
    public void OCOOCCODDD(Vector3 pos, Int32& n1);
    public void OOODDDDQQO(Vector3 pos, Int32& n1, int selectedMarker, bool sameRoad);
    public int OQCCQDDOQD(Vector3 pos);
    public int OOCDODCOOD(Vector3 pos, int selectedMarker);
    public int HandleAddMarkerAtStart(Vector3 pos, int selectedMarker);
    public void ODDDCDQCCO(ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool UpdateResolutionFlag);
    public void OOOCDCQQCO(bool ignorePrefabAlignment, int selectedMarker);
    public void PrintRoadShape(List`1<Vector2> lst);
    public void OCQOQCDCQC(bool ignorePrefabAlignment, bool forceAutoRotate);
    private void OCODCOOQOC(List`1& vecs, List`1& uvs, List`1& uvs2, int cols, Int32& addedRows, List`1& isPlanar, List`1& colors, Single& uv, Single& uv4);
    public void OCDCOOQOQD(Mesh m);
    public void OQOOOOOOCQ(ERDecal decal, GameObject& decalPrefab, string name);
    public float ODCDOQOOOO(ERDecal decal, float roadWidth);
    public void OOOCOODQCO(string type);
    public void OQOCCDCCDD(GameObject decal, int index);
    public float OCDDDDQDQQ(int startEnd);
    public Vector3[] AdjustNormals(Vector3[] normals);
    public void AdjustPrefabNormals(List`1<int> roadInts, List`1<int> prefabInts, Vector3[] normals, GameObject prefab, Vector3[] verts);
    public bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck);
    public void OODCOQOQOD(List`1& surfaceVecs, ERCrossingPrefabs prefabScript, Boolean& startSurfacesSafe, float distance, float minIndent);
    public void ODOCCQDCQO(List`1& surfaceVecs, ERCrossingPrefabs prefabScript, int el, Boolean& surfacesSafe, float distance, float minIndent);
    public bool OQCODQODCO(Vector3 ODCQDOOOCCIndent, Vector3 otherPrefabIndent, Vector3 v);
    public void OCQOQQCDOD(List`1<Vector3> surfaceVecs, List`1<Vector2> uvs, int h, List`1<bool> doBridge, Vector3 firstDir, Vector3 lastDir, float indent, float surrounding, List`1<bool> tunnelSegments);
    public void InterpolateSurfaces(List`1& surfaceVecs, List`1& uvs, List`1& tris, Vector3 dir, int vecCount, int startEnd, float indent, float surrounding);
    public void OOCCDCDCQD();
    public List`1<Vector3> OQDDOOOOQD(List`1<ERMarkerExt> markersExt, float faceDist, bool ignorePrefabAlignment, List`1& tValues, List`1& markerDistances, bool forceAutoRotate, List`1& rotationArray, List`1& bendAngles);
    public void OCQOOCCQDD(List`1<ERMarkerExt> tmpMarkers, int j, Vector3[] tr, Vector3 circleDir, float totalDist, Vector3& startCP, int startMarker, List`1<Vector3> p);
    public void OQDOQOCDDQ(List`1<ERMarkerExt> tmpMarkersExt, int j, Vector3[] tr, Vector3& endCP, int startMarker);
    public void OOCCQCCDQC(Vector3& endCP, Vector3 curV3, Vector3 nextV3, Vector3 nextNextV3);
    public List`1<float> OQDOOOQODD(List`1<float> tValues, List`1<float> markerDistances, List`1<ERMarkerExt> markers, int startMarker, int endMarker, List`1& OQQOODQCCC, List`1<float> randomRotations);
    public void RoadSmoothness(float curDist, ERMarkerExt marker, float totalDistance, Single& randomYDistanceStart, Single& randomYDistanceEnd, Single& randomYDistanceMiddle, Vector3& randomYDistanceV3, Vector3& v, Single& currentRandomYDistance, Single& randomRotationStart, Single& randomRotationEnd, Single& randomRotationMiddle, Vector3& randomRotationV3, Single& currentRandomRotation, List`1& rotationArray);
    public List`1<List`1<Vector2>> GetRoadShapeValues(List`1<float> tValues, List`1<float> markerDistances, List`1<ERMarkerExt> markers, int startMarker, int endMarker, List`1<Vector2> roadShape);
    public List`1<float> GetSurfaceValues(List`1<float> tValues, List`1<float> markerDistances, List`1<ERMarkerExt> markers, int startMarker, int endMarker, List`1& leftIndents, List`1& rightIndents, List`1& leftSurrounding, List`1& rightSurrounding, float minRequiredIndent);
    public bool OCCQQDDDQC(SideObject obj, bool flag);
    public bool ODQCOQQDCD(SideObject obj, int marker, bool flag);
    public bool ERSetSideObjectOffset(SideObject obj, int marker, OffsetPosition position, float value);
    public bool ODQCOQQDCD(SideObject obj, Int32[] markers, bool flag);
    public List`1<Vector3> OQOQDCODCD(bool flag);
    public void OQOQDQCDCQ();
    public List`1<float> ODQQOQQDOO(Vector3[] tr);
    public Vector3 OOOOQCODCQ(float offset);
    public static Vector3 OODODQQQCD(Vector3 P0, Vector3 P1, Vector3 P2, Vector3 P3, float t, float tension);
    public Vector3 OCCDDOCCDQ(int startend, ERCrossingPrefabs prefab);
    public void OQDQOOQODD(bool lineMask, bool biomeMask);
    public void SetMarkerShape(List`1<Vector2> conVecs, Vector3 scale, ERCrossingPrefabs prefab, int connectionIndex);
    public void ODQOCQCCDC(ERIndentAlignment value, int marker, ERRoadSide type);
    public ERIndentAlignment ERGetIndentAlignment(int marker, ERRoadSide type);
    public void FlipRoadUVs(bool update);
    public ERRoadType GetRoadType(ERRoadType[] roadTypes);
}
public class EasyRoads3Dv3.ERPoint : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private double ᙂ;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private double ᙃ;
    
public double x { get; public set; }
    
public double y { get; public set; }
    public ERPoint(double x, double y);
    [CompilerGeneratedAttribute]
public void set_x(double value);
    [CompilerGeneratedAttribute]
public double get_x();
    [CompilerGeneratedAttribute]
public void set_y(double value);
    [CompilerGeneratedAttribute]
public double get_y();
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERPrefab : MonoBehaviour {
    
public bool isRoadType;
    
public bool isSidewalk;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERPrefabInstance : MonoBehaviour {
    
public SideObject so;
    
public GameObject prefab;
    
public ERSORoadExt soData;
    
public double id;
    
public ERModularRoad roadScript;
    
public bool buildFlag;
    
public bool locked;
    
public bool child;
    
public int sectionIndex;
    public void Copy(ERPrefabInstance source);
}
public class EasyRoads3Dv3.ERRoad : object {
    
public ERModularRoad roadScript;
    
public GameObject gameObject;
    
public string str;
    public ERRoad(ERModularRoad scr);
    public void AddInititialMarkers(Vector3 pos);
    public void AddMarker(Vector3 pos);
    public void ClampUVs(bool value);
    public void FlipTexture();
    public void AddMarkers(Vector3[] pos);
    public void InsertMarker(Vector3 pos);
    public void InsertMarkerAt(Vector3 pos, int index);
    public void DeleteMarker(int i);
    public void SetLayer(int layer);
    public void SetTag(string tag);
    public void SetWidth(float width);
    public float GetWidth();
    public ERRoadType GetRoadType(ERRoadType[] roadTypes);
    public ERRoadType GetRoadType();
    public bool SetRoadType(ERRoadType roadType);
    public bool SetMarkerControlType(int marker, ERMarkerControlType type);
    public bool SetSplineStrength(int marker, float strength);
    public float GetSplineStrength(int marker);
    public void IsSideObject(bool isSideObject);
    public ERRoad InsertIConnector(int index);
    public ERRoad InsertIConnector(int index, string connectionName);
    public ERRoad InsertIConnector(int index, string connectionName, ERConnection& connection);
    private ERRoad InsertIConnectorCore(int index, ERCrossingPrefabs& pScript);
    public ERRoad SplitRoad(int markerIndex);
    [EditorBrowsableAttribute("1")]
private ERModularRoad SplitRoadExt(int markerIndex);
    public void SetSideObjects(List`1<ERSORoadExt> soDataExt);
    public void SetSplatmap(bool active);
    public void SetSplatmap(bool active, int splatIndex, int expand, int smoothLevel, float opacity);
    public void SetMaterial(Material mat);
    public void SetMarkerPosition(int marker, Vector3 vec);
    public void SetResolution(float res);
    public void IsStatic(bool value);
    public bool IsStatic();
    public float GetResolution();
    public void SetAngleThreshold(float res);
    public float GetAngleTreshold(float res);
    public bool ClosedTrack(bool value);
    public void FollowTerrainContours(bool value);
    [ObsoleteAttribute("obsolete")]
public void SetFollowTerrainContoursOffset(float value);
    public void FollowTerrainContourThreshold(float value);
    public void FollowTerrainContours(int markerIndex, bool value);
    public bool IsClosedTrack();
    public void SetMarkerPositions(Vector3[] vecs);
    public void SetMarkerPositions(Vector3[] vecs, int index);
    public Vector3 GetMarkerPosition(int marker);
    public Vector3[] GetMarkerPositions();
    public int GetMarkerCount();
    public void SetMarkerTilting(float value, int index);
    public float GetMarkerTilting(int index);
    public void SetMarkerTiltingCenter(float value, int index);
    public float GetRadius(int markerIndex);
    public float GetMarkerTiltingCenter(int index);
    public Color GetVertexColor(int index);
    public void SetVertexColor(int index, Color color);
    public void SetDistances();
    public Vector3 GetPosition(float distance, Int32& currentElement);
    public Vector3 GetLookatSmooth(float distance, int currentElement);
    [ObsoleteAttribute("obsolete")]
public Vector3 GetLookatAtDistanceSmooth(float distance, Int32& currentElement);
    public int GetMarkerByPoint(int el);
    public Vector3[] GetSplinePointsCenter();
    public Vector3[] GetSplinePointsRightSide();
    public Vector3[] GetSplinePointsRightSideExt();
    public Vector3[] GetSplinePointsLeftSide();
    public float SetIndent(float value, int marker);
    public float SetIndent(float value, int marker, ERRoadSide type);
    [ObsoleteAttribute("obsolete")]
public float SetRightIndent(float value, int marker);
    [ObsoleteAttribute("obsolete")]
public float SetLeftIndent(float value, int marker);
    public float SetSurrounding(float value, int marker);
    public float SetSurrounding(float value, int marker, ERRoadSide type);
    public void SetIndentAlignment(ERIndentAlignment value, int marker, ERRoadSide type);
    public ERIndentAlignment GetIndentAlignment(int marker, ERRoadSide type);
    [ObsoleteAttribute("obsolete")]
public float SetRightSurrouding(float value, int marker);
    [ObsoleteAttribute("obsolete")]
public float SetLeftSurrouding(float value, int marker);
    public Vector3[] GetRightIndentPoints();
    public Vector3[] GetLeftIndentPoints();
    public Vector3[] GetRightSurroundingPoints();
    public Vector3[] GetLeftSurroudingPoints();
    [ObsoleteAttribute("obsolete")]
public float GetLength();
    public float GetDistance();
    public float GetDistance(int markerIndex);
    public void SideObjectSetActive(SideObject obj, bool value);
    public void SideObjectMarkerSetActive(SideObject obj, int marker, bool value);
    public void SideObjectMarkerSetActive(SideObject obj, Int32[] markers, bool value);
    public void SetSideObjectOffset(SideObject obj, int marker, OffsetPosition position, float value);
    public void SetTerrainDeformation(bool value);
    public void SetTerrainDeformation(int markerIndex, bool value);
    public void SetMeshCollider(bool flag);
    public void Refresh();
    public ERConnection GetConnectionAtStart();
    public GameObject GetConnectionObjectAtStart();
    public ERConnection GetConnectionAtStart(Int32& connectionIndex);
    public ERConnection GetConnectionObjectAtEnd();
    public ERConnection GetConnectionAtEnd();
    public ERConnection GetConnectionAtEnd(Int32& connectionIndex);
    public GameObject GetConnectionObjectAtEnd(Int32& connection);
    public bool ConnectionCheck(ERCrossingPrefabs prefab, int index, int startEnd);
    public bool ConnectToStart(ERConnection connectionObject, int connectionIndex);
    public bool ConnectToStart(ERConnection connectionObject, int connectionIndex, bool autoAlign);
    public bool ConnectToStartExt(ERConnection connectionObject, int connectionIndex, bool autoAlign);
    public bool ConnectToEnd(ERConnection connectionObject, int connectionIndex);
    public bool ConnectToEnd(ERConnection connectionObject, int connectionIndex, bool autoAlign);
    public bool ConnectToEndEx(ERConnection connectionObject, int connectionIndex, bool autoAlign);
    public ERConnection AttachToStart(ERConnection connectionObject);
    public ERConnection AttachToEnd(ERConnection connectionObject);
    public ERConnection AttachToStart(ERConnection OQQCOQOCDO, int connectionIndex);
    public ERConnection AttachToEnd(ERConnection connectionInstance, int connectionIndex);
    public bool ConnectionMatch(ERConnection connection);
    public void SetCustomMarkerPoints(int markerIndex, List`1<Vector3> points);
    public ERConnection InsertConnector(ERConnection connectionObject, int markerIndex, int connectionIndex1, int connectionIndex2, ERRoad& road);
    public void UnConnectStart();
    public void UnConnectEnd();
    public bool ConnectionMatch(ERConnection connection, int connectionIndex);
    public void SnapToTerrain(bool flag);
    public void SnapToTerrain(bool flag, float offset);
    public string GetName();
    public void SetName(string name);
    public Vector2[] GetShapeNodes();
    public Vector2[] GetRoadShapeNodes(int markerIndex);
    public void SetRoadShapeNodes(int markerIndex, Vector2[] nodes);
    public void SetRoadShapeNodes(Int32[] markerIndexes, Vector2[] nodes);
    public void Clear();
    public void Destroy();
}
public class EasyRoads3Dv3.ERRoadNetwork : object {
    
public ERModularBase roadNetwork;
    
public bool isInBuildMode;
    
public string str;
    
public static RoadUpdateCallback onRoadUpdate;
    
public static BuildModeCallback onBuildModeEnter;
    
public static EditModeCallback onEditModeEnter;
    public static void OnBuildModeEnter();
    public static void OnEditModeEnter();
    public static void OnRoadUpdated(ERRoad road);
    public void GetTerrainData();
    public ERTrafficDirection GetTrafficDirection();
    public void Translate(Vector3 pos);
    public void CenterPivotPoints();
    public ERRoad[] GetRoads();
    public ERRoad GetRoadByName(string name);
    public ERRoad GetRoadByGameObject(GameObject go);
    public ERRoad CreateRoad(string roadName);
    public ERRoad CreateRoad(string roadName, Vector3[] markers);
    public ERRoad CreateRoad(string roadName, ERRoadType roadType);
    public ERRoad CreateRoad(string roadName, ERRoadType roadType, Vector3[] markers);
    public ERModularRoad InitRoad(string roadName, ERRoadType roadType, Material roadMaterial);
    public void AddInititialMarkers(ERRoad road, Vector3[] markers);
    public void AddIntersection(ERCrossingPrefabs crossing, GameObject crossingPrefab);
    public void BuildRoadNetwork(bool splatmaps, bool trees, bool detail, ERRoad[] roads);
    public void BuildRoadNetwork(bool splatmaps, bool trees, bool detail);
    public void BuildRoadNetwork();
    public void DoBuildRoadNetwork();
    public void RestoreRoadNetwork();
    public ERRoadType[] GetRoadTypes();
    public ERRoadType GetRoadTypeByName(string name);
    public SideObject GetSideObjectByName(string name);
    public ERRoadType AddRoadType();
    public void HideWhiteSurfaces(bool flag);
    public ERConnection[] GetConnections();
    public ERConnection GetConnectionByName(string name);
    public ERConnection[] LoadConnections();
    [ObsoleteAttribute("obsolete")]
public ERConnection GetSourceConnectionByName(string name);
    public ERConnection GetConnectionPrefabByName(string name);
    public ERConnection InstantiateConnection(ERConnection OQQCOQOCDO, string name, Vector3 position, Vector3 euler);
    public void SetRaiseOffset(float value);
    public ERRoad OODOOOQQCO(ERRoad road);
    public float GetRaiseOffset();
    public void ClampUVs(bool clamp);
    public ERRoad ConnectRoads(ERRoad road1, ERRoad road2);
    public ERRoad ConnectRoads(ERRoad road1, int marker1, ERRoad road2, int marker2);
    private bool CheckRoads(ERRoad road1, ERRoad road2, String& str);
    public static void SetTerrainNormals(Mesh m, GameObject go);
    public void Refresh();
    public void FinalizeObjects();
}
public class EasyRoads3Dv3.ERRoadNetworkObject : MonoBehaviour {
}
public class EasyRoads3Dv3.ERRoadShape : ValueType {
    
public List`1<Vector2> nodes;
    
public List`1<bool> hardEdge;
    
public int priorityNodeIndexLeft;
    
public int priorityNodeIndexRight;
    
public List`1<Vector3> nodesV3;
    
public List`1<ERLane> lanes;
    
public int leftLanes;
    
public int rightLanes;
    
public bool symmetrical;
    
public float leftSidewalkOffset;
    
public float rightSidewalkOffset;
    
public int outerLaneMarkingLeftIndex;
    
public bool includeOuterlaneLeftInShape;
    
public bool includeOuterlaneRightInShape;
    
public int outerLaneMarkingRightIndex;
    
public int outerOuterLaneMarkingLeftIndex;
    
public int outerOuterLaneMarkingRightIndex;
    
public int selectedNode;
    
public int selectedLaneNode;
    
public int isSymmetrical;
    
public bool isset;
    public ERRoadShape(float width);
    public void OCCQQDOQOD(List`1<Vector2> _nodes);
    public void Copy(ERRoadShape shape);
    public void IsSymmetrical();
}
public enum EasyRoads3Dv3.ERRoadSide : Enum {
    
public int value__;
    
public static ERRoadSide Left;
    
public static ERRoadSide Right;
    
public static ERRoadSide Both;
}
public class EasyRoads3Dv3.ERRoadType : object {
    
public double id;
    
public string roadTypeName;
    
public List`1<Vector2> roadShape;
    
public List`1<Vector2> roadShapeExt;
    
public List`1<bool> doConnectionTri;
    
public List`1<float> roadShapeUVs;
    
public List`1<float> roadShapeExtUVs;
    
public List`1<float> roadShapeUVs2;
    
public List`1<bool> hardEdge;
    
public float roadWidth;
    
public float faceDistance;
    
public float angleTreshold;
    
public bool sidewalks;
    
public float sidewalkHeight;
    
public float sidewalkWidth;
    
public Material roadMaterial;
    
public PhysicMaterial roadPhysicsMaterial;
    
public Material connectionMaterial;
    
public bool isSideObject;
    
public List`1<ERSORoad> soData;
    
public List`1<ERSORoadExt> soDataExt;
    
public List`1<ERSORoadLog> soDataLog;
    
public int layer;
    
public string tag;
    
public bool hasMeshCollider;
    
public bool terrainDeformation;
    
private ERRoadShape ᙃ;
    public void Update();
    public static QDQDOOQQDQODD GetRoadType(ERRoadType t, ERModularBase baseScript);
}
public enum EasyRoads3Dv3.ERRoadWayType : Enum {
    
public int value__;
    
public static ERRoadWayType Primary;
    
public static ERRoadWayType Secondary;
    
public static ERRoadWayType Tertiary;
    
public static ERRoadWayType Path;
    
public static ERRoadWayType MotorwayRamp;
}
public class EasyRoads3Dv3.ERRoundaboutElement : object {
    
public float roadWidth;
    
public float prevRoadWidth;
    
public int roundingSegments;
    
public bool lockLeftRightRoundingRadius;
    
public float leftRoundingRadius;
    
public float prevLeftRoundingRadius;
    
public float rightRoundingRadius;
    
public float prevRightRoundingRadius;
    
public float connectionLength;
    
public int centerInt;
    
public int prevCenterInt;
    
public float positionPercentage;
    
public int leftOuterInt;
    
public int rightOuterInt;
    
public int intsFromCenter;
    
public List`1<Vector3> leftOuterSegments;
    
public List`1<Vector3> leftInnerSegments;
    
public List`1<Vector3> rightOuterSegments;
    
public List`1<Vector3> rightInnerSegments;
    
public List`1<Vector2> leftOuterSegmentsUVs;
    
public List`1<Vector2> leftInnerSegmentsUVs;
    
public List`1<Vector2> rightOuterSegmentsUVs;
    
public List`1<Vector2> rightInnerSegmentsUVs;
    
public List`1<List`1<Vector3>> leftSidewalkV3;
    
public List`1<List`1<Vector3>> rightSidewalkV3;
    
public List`1<List`1<Vector2>> leftSidewalkUV;
    
public List`1<List`1<Vector2>> rightSidewalkUV;
    
public List`1<List`1<int>> leftSidewalkTris;
    
public List`1<List`1<int>> rightSidewalkTris;
    
public List`1<int> leftSidewalkNormalsStart;
    
public List`1<int> leftSidewalkNormalsEnd;
    
public List`1<int> rightSidewalkNormalsStart;
    
public List`1<int> rightSidewalkNormalsEnd;
    
public List`1<List`1<int>> roadConnectionTris;
    
public List`1<Vector3> leftSidewalkSourceVecs;
    
public List`1<Vector3> rightSidewalkSourceVecs;
    
public Vector3 outerCenterPoint;
    
public List`1<Vector3> innerRoundaboutPoints;
    
public List`1<Vector2> innerRoundaboutUVs;
    
public bool leftFlag;
    
public bool rightFlag;
    
public bool blendFlag;
    
public Material roadMaterial;
    
public Material connectionMaterial;
    
public int prefabElement;
    
public List`1<int> connectionVecInts;
    
public List`1<int> fullConnectionVecInts;
    
public Vector3 centerPoint;
    
public Vector3 controlPointV3;
    
public List`1<Vector2> roadShapeVecs;
    
public string roadShapeVecsString;
    
public List`1<float> roadShapeUVY;
    
public List`1<int> blendCornerPointInts;
    
public List`1<float> blendCornerPointWeights;
    
public Vector3 sceneSelectionV3;
    
public Vector3 sceneSelectionV3Global;
    
public List`1<Vector3> rightIndentvecs;
    
public List`1<Vector3> rightSurroundingvecs;
    
public List`1<Vector3> leftIndentvecs;
    
public List`1<Vector3> leftSurroundingvecs;
    
public int rightIndentBorderInt;
    
public int leftIndentBorderInt;
    
public double roadType;
    
public double prevRoadType;
    
public double roadTypeTimestamp;
    
public double prevTimestamp;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERRoundabouts : MonoBehaviour {
    
public float roundAboutRadius;
    
public float prevRoundAboutRadius;
    
public float roundAboutResolution;
    
public float prevRoundAboutResolution;
    
public float rDist;
    
public Vector3 raStartPos;
    
public float roundaboutWidth;
    
public float prevRoundaboutWidth;
    
public int roadTypeInt;
    
public int prevRoadTypeInt;
    
public float roadWidth;
    
public float prevRoadWidth;
    
public bool lockLeftRightRoundingRadius;
    
public float leftRoundingRadius;
    
public float prevLeftRoundingRadius;
    
public float rightRoundingRadius;
    
public float prevRightRoundingRadius;
    
public int roundingSegments;
    
public float connectionLength;
    
public float maxRoadWidth;
    
public float maxRoundingRadius;
    
public List`1<Vector3> meshVecs;
    
public List`1<Vector3> mainRightPoints;
    
public List`1<Vector3> mainCenterPoints;
    
public List`1<Vector3> mainLeftPoints;
    
public List`1<Vector3> OCCDQOCCDQ;
    
public List`1<Vector2> mainRightPointsUVs;
    
public List`1<Vector2> mainCenterPointsUVs;
    
public List`1<Vector2> mainLeftPointsUVs;
    
public List`1<Vector2> OCCDQOCCDQUVs;
    
public List`1<Vector3> innerRoundaboutSidewalkV3;
    
public List`1<Vector2> innerRoundaboutSidewalUV;
    
public List`1<int> innerRoundaboutSidewalTris;
    
public Material innerRoundaboutSidewalkMaterial;
    
public List`1<int> innerRoundaboutSidewalkIntsStart;
    
public List`1<int> innerRoundaboutSidewalkIntsEnd;
    
public int innerSidewalkSegments;
    
public Vector3 leftPoint;
    
public Vector3 leftPoint1;
    
public Vector3 rightPoint;
    
public Vector3 rightPoint1;
    
public Vector3 centerOnLine;
    
public Vector3 leftOuterPoint;
    
public Vector3 rightOuterPoint;
    
public Vector3 pl;
    
public Vector3 pr;
    
public List`1<Vector3> edgePoints;
    
public int newSegmentInt;
    
public int prevNewSegmentInt;
    
public List`1<ERRoundaboutElement> connections;
    
public String[] QDOOOQOOQQQQD;
    
public int selectedConnection;
    
public int activeConnection;
    
public int tmpSelectedConnection;
    
public int minStartInt;
    
public int maxEndInt;
    
public int centerInt;
    
public int leftOuterInt;
    
public int rightOuterInt;
    
public List`1<Vector3> leftOuterSegments;
    
public List`1<Vector3> leftInnerSegments;
    
public List`1<Vector3> rightOuterSegments;
    
public List`1<Vector3> rightInnerSegments;
    
public List`1<Vector2> leftOuterSegmentsUVs;
    
public List`1<Vector2> leftInnerSegmentsUVs;
    
public List`1<Vector2> rightOuterSegmentsUVs;
    
public List`1<Vector2> rightInnerSegmentsUVs;
    
public Vector3 outerCenterPoint;
    
public bool blendFlag;
    
public Material mainRoadMaterial;
    
public Material roadMaterial;
    
public Material connectionMaterial;
    
public Material defaultConnectionMaterial;
    
public double roadType;
    
public double roadTypeTimestamp;
    
public List`1<Vector3> innerRoundaboutPoints;
    
public List`1<Vector2> innerRoundaboutUVs;
    
public float innerSegmentDistance;
    
public float innerSidewalkWidth1;
    
public float innerSidewalkWidth2;
    
public float innerCurbHeight;
    
public float innerCurbDepth;
    
public bool innerBeveledCurb;
    
public float innerBeveledHeight;
    
public float innerBeveledDepth;
    
public bool innerOuterCurb;
    
public bool innerRoadSideCurbUVControl;
    
public bool innerOuterSideCurbUVControl;
    
public Material innerSidewalkMaterial;
    
public List`1<float> innerSidewalkUVs;
    
public List`1<float> innerCurbUVs;
    
public int selectedCorner;
    
public int selectedCornerPreset;
    
public int selectedSidewalkPreset;
    
public string sidewalkPresetName;
    
public int innerRoundaboutPreset;
    
public bool leftFlag;
    
public bool rightFlag;
    
private bool ᙃ;
    
public ERCrossingPrefabs prefabScript;
    
public QDOODOQQDQODD connectionElement;
    
public ERModularBase baseScript;
    
public bool isSceneObject;
    
public bool guiChanged;
    
public string crossingName;
    
public bool activeSidewalks;
    
public bool newConnectionFlag;
    
public Vector3 testIndentMiddlePoint;
    
public List`1<QDQDOOQQDQODD> roadTypesDynamic;
    private void Start();
    public bool UpdateToRoadType(QDQDOOQQDQODD sourcePreset);
    public void ResetData();
    public void ODQDCCOQOD();
    public void OOQQDCCCCC();
    public void GetConnectionData();
    public void UpdateMinMaxInts();
    public void ChecknewSegmentInt();
    public int GetRoadPresetInt(double id);
    public void OCQCQODOQC(ERRoundabouts source, bool refreshFlag);
    public void OCDCOQOOQO();
    public void ODCDCDDOCC(List`1<SidewalkPresetClass> sidewalkPresets, int el);
    public void OOCDDOQDDO();
    public void OQQCDOQOOQ();
    public void OQCQDQDCOD(int currentIndex);
    public void OQQOCQQDOQ(List`1& OCCDQOCCDQ, List`1& innerSegmentPoints, int leftRight, int startElement, Vector3 leftPoint, Vector3 rightPoint, Vector3 forward, int currentIndex);
    public void OOCCDCDOQC(int currentIndex);
    public void ODDDOCDCQO();
    public void OQCQQCQDCQ(int el, List`1<int> trIntArray, List`1<float> uvArray, List`1<List`1<int>> leftSidewalkIntArray, List`1<List`1<int>> rightSidewalkIntArray, int startend);
    public void OCDDOCDDOQ(List`1<Vector3> meshVecs, List`1<int> connectionVecInts, List`1& roadShapeVecs, List`1<Vector2> vecArrays, List`1<List`1<Vector3>> leftSidewalkArray, List`1<List`1<Vector3>> rightSidewalkArray, int connectionElement, int startend);
    public void ODQCODQDDQ(int el, Material roadMaterial, int leftVecCount, int rightVecCount);
    public void ODCQOCOOQO();
    public void OCQOCDQQQD(int el);
    public static bool OQQCODDOOQ(int el, float roundaboutIndent, Vector3 prevVec, bool boolCheck, Vector3& vec, Int32& indentBorderInt);
    public void ODQOOCQDDD(float minSurrounding, Vector3 middleVec, Vector3 origVec, bool boolCheck, Vector3& vec);
    public void CheckAgainstFirstSurroundingVec(Vector3 firstIndent, Vector3 firstSurrounding, bool boolCheck, Vector3& vec);
    public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4);
    public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERRoundaboutsFunctions : MonoBehaviour {
    public static void ODCCQQODCO(ERRoundabouts scr, int currentIndex);
    public static void OQQDDDCCDO(ERRoundabouts scr, int currentIndex);
    public static void OOCCDQCCOQ(ERRoundabouts scr, int currentIndex);
    public static void OOOQCOQOOQ(ERRoundabouts scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt);
    public static List`1<Vector3> ODCODDCCOC(List`1<Vector3> outer, List`1<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQCDDCOODQ(ERRoundabouts scr, List`1<Vector3> innerArray, List`1<Vector3> outerOther, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQODQDOQOQ(List`1<Vector3> outer, float height);
    public static void ODQDQQOQCC(ERRoundabouts scr, List`1<List`1<Vector3>> vecArray, List`1& uvArray, QDOQDSQOOQDDD corner, bool reverse);
    public static void ODQOQOCCOC(List`1<List`1<Vector3>> vecArray, List`1& sidewalkUVs);
    public static void OCCQQQDDDQ(ERRoundabouts scr);
    public static void SetInnerSidewalkVars(ERRoundabouts scr, int preset);
    public static void BuildInnerRoundaboutSidewalkData(ERRoundabouts scr, ERModularBase baseScr, List`1<Vector3> mainRightPoints, List`1& innerRoundaboutSidewalkV3, List`1& innerRoundaboutSidewalUV, List`1& innerRoundaboutSidewalTris, Int32& innerSidewalkSegments);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideObjectInstance : MonoBehaviour {
    [HideInInspector]

public SideObject so;
    [HideInInspector]

public double id;
    [HideInInspector]

public ERModularRoad roadScript;
    [HideInInspector]

public List`1<GameObject> childs;
    [HideInInspector]

public List`1<Vector3> vecs;
    [HideInInspector]

public List`1<bool> terrainIndexes;
    [HideInInspector]

public bool buildFlag;
    [HideInInspector]

public bool postProcess;
    [HideInInspector]

public bool batches;
    [HideInInspector]

public bool combined;
    [HideInInspector]

public List`1<GameObject> batchedObjects;
    [HideInInspector]

public List`1<Vector3> startEndPositions;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideObjectLog : MonoBehaviour {
    
public List`1<SideObjectLog> QOQDQOOQDDQOOQ;
    
public List`1<int> ints;
    
public List`1<QDQDOOQQDQODD> roadPresets;
    
public List`1<CrossingCornerClass> crossingCornerPresets;
    
public List`1<ERSideWalk> sidewalkPresets;
    
public List`1<ERTexture> textureData;
    
public List`1<string> presetAssets;
    
public int logIndex;
    
public int updateInt;
    public void AddRoadPreset(List`1<SideObject> sceneSideObjects, List`1<SideObjectLog> projectSideObjects, QDQDOOQQDQODD sourcePreset);
    public void UpdateRoadPreset(QDQDOOQQDQODD sourcePreset, int element, List`1<SideObject> sceneSideObjects, List`1<SideObjectLog> projectSideObjects, bool copyShapeData);
    public void UpdateTextureList(int element, Texture2D _texture, float _roadWidth, float _leftOffset, float _rightOffset, float _leftInnerOffset, float _rightInnerOffset);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideObjectSection : MonoBehaviour {
    
public ERModularRoad road;
    
public int sectionListIndex;
    
public int sectionIndex;
    
public double soId;
    
public int leftright;
    
public bool mirrored;
    public void Copy(ERSideObjectSection source);
}
public class EasyRoads3Dv3.ERSideWalk : object {
    
public string name;
    
public double id;
    
public double timestamp;
    
public float sidewalkWidth;
    
public float curbHeight;
    
public float curbDepth;
    
public bool beveledCurb;
    
public float beveledHeight;
    
public float beveledDepth;
    
public bool outerCurb;
    
public bool roadSideCurbUVControl;
    
public bool outerSideCurbUVControl;
    
public Material material;
    
public bool hardEdges;
    
public List`1<Vector2> shape;
    
public List`1<float> sidewalkUVs;
    
public List`1<float> curbUVs;
    
public List`1<bool> doConnectionTri;
    
public Rect tileRect;
    
public float tileSize;
    
public float tiling;
    
public float uvRatio;
    
public float minEnd;
    
public float maxEnd;
    
public bool lockUVs;
    
public float cornerRadius;
    
public int cornerSegments;
    
public float innerSegmentDistance;
    public static ERSideWalk CreateInstance(int count);
    public void UpdateTimestamp();
    public static String[] SidewalkNames(List`1<ERSideWalk> sidewalks);
    public static void CopySidewalk(ERSideWalk source, ERSideWalk target);
    public static void RefreshSidewalks(List`1<ERSideWalk> sidewalks);
    public void OOQQDCCDQO();
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideWalkInstance : object {
    
public ERSideWalk sidewalk;
    
public GameObject swObject;
    
public double id;
    [HideInInspector]

public float start;
    [HideInInspector]

public float end;
    [HideInInspector]

public Vector3 startPos;
    [HideInInspector]

public Vector3 endPos;
    public ERSideWalkInstance(ERSideWalk msidewalk, float mStart, float mEnd, Vector3 mStartPos, Vector3 mEndPos, ERModularRoad road, string side);
    public void CreateObject(ERModularRoad road, string side);
    public void GetObject(ERModularRoad road, string side);
}
public class EasyRoads3Dv3.ERSideWalkInstanceScript : MonoBehaviour {
    
public ERSideWalkInstance instance;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERSideWalkVecs : MonoBehaviour {
    
public static GameObject sidewalk;
    public static void OQOQDODDCD(ERCrossings scr);
    public static void ODCCDOQOOC(ERCrossings scr);
    public static void OQOQDOOOQO(ERCrossings scr, List`1<Vector3> vecArray, Vector3 firstOther, float sidewalkWidth, int xorz, Int32& cornerInt);
    public static void OOOQCOQOOQ(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt);
    public static void OODDCODCCQ(ERCrossings scr);
    public static List`1<Vector3> ODCODDCCOC(List`1<Vector3> outer, List`1<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQCDDCOODQ(ERCrossings scr, List`1<Vector3> innerArray, List`1<Vector3> outerOther, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQODQDOQOQ(List`1<Vector3> outer, float height);
    public static void ODQDQQOQCC(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1& uvArray, QDOQDSQOOQDDD corner, bool reverse, float uvTiling);
    public static void ODQOQOCCOC(List`1<List`1<Vector3>> vecArray, List`1& sidewalkUVs);
    public static void ODDCDODCCQ(List`1& outer1, List`1& outer2);
    public static Vector3[] OODDQOQDCC(ERCrossings scr, Vector3[] normals);
    public static Vector4[] AdjustSidewalkTangents1(ERCrossings scr, Vector4[] tangents);
    public static Vector4[] AdjustSidewalkTangents(ERCrossings scr, Vector4[] tangents);
    public static Vector3[] ODDQQCCODD(ERRoundabouts scr, Vector3[] normals);
    public static Vector3[] SnapSidewalkCornersVecs(ERCrossings scr, Vector3[] vecs);
    public static void ODCQCQDODC(ERModularBase baseScript, ERSideWalk sw, Vector3 pos);
    public static void OQOOQDCQOC(ERSideWalk sw, GameObject sidewalkGO, List`1<Vector3> vecs, int leftRight, float offsetX, bool updateMesh);
    private static List`1<Vector2> OCDODCQCCC(ERSideWalk sw, Int32& innerIndex, List`1& trisFlag);
    public static void ODDDOCDCQO(ERSideWalk sw, List`1<Vector2> shape, List`1<bool> trisFlag, List`1<float> uv, List`1<Vector3> spline, List`1<Vector3> spline2, int leftright, GameObject sidewalkGO, float offsetX, bool closedStart, bool closedEnd);
    public static void OQCODDOCCD(ERSideWalk sw, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1& vecs, List`1& uvs, List`1& tris, int pointsCount, int leftrightroad, int startEnd);
}
public class EasyRoads3Dv3.ERSOMarker : object {
    
public SideObject sideObject;
    
public double id;
    
public bool active;
    
public float startOffset;
    
public float endOffset;
    
public bool splineActive;
    
public float sidewaysDistance;
    
public Vector3 startOffsetV3;
    
public Vector3 endOffsetV3;
    
public Vector3 startOffsetDir;
    
public Vector3 endOffsetDir;
    
public Vector3 startOffsetV3nb;
    
public Vector3 endOffsetV3nb;
    
public int curStartInt;
    
public int curEndInt;
    
public bool startOffsetActive;
    
public bool endOffsetActive;
    
public List`1<Vector2> nodeList;
    
public List`1<Vector3> nodeShapeVecsGlobal;
    
public Vector3 rotation;
    
public float rotationAngle;
    
public float rotationDistance;
    
public float rotationCenter;
    public ERSOMarker(SideObject so, bool flag);
    public void OODOOOQQCO(ERSOMarkerExt source);
}
public class EasyRoads3Dv3.ERSOMarkerExt : ScriptableObject {
    
public SideObject sideObject;
    
public double id;
    
public bool active;
    
public float startOffset;
    
public float endOffset;
    
public bool splineActive;
    
public float sidewaysDistance;
    
public float xPosition;
    
public Vector3 startOffsetV3;
    
public Vector3 endOffsetV3;
    
public Vector3 startOffsetDir;
    
public Vector3 endOffsetDir;
    
public Vector3 startOffsetV3nb;
    
public Vector3 endOffsetV3nb;
    
public int curStartInt;
    
public int curEndInt;
    
public bool startOffsetActive;
    
public bool endOffsetActive;
    
public List`1<Vector2> nodeList;
    
public List`1<Vector3> nodeShapeVecsGlobal;
    
public int shapeTransitionType;
    
public Vector3 rotation;
    
public float rotationAngle;
    
public float rotationDistance;
    
public float rotationCenter;
    
public ERRoadSide side;
    
public ERSOMarkerExt otherSide;
    public void Init(SideObject so, bool flag);
    public void OODOOOQQCO(ERSOMarkerExt source);
    public void Copy(ERSOMarkerExt source);
    public static ERSOMarkerExt CreateInstance(SideObject so, bool flag);
    public void ODCOCDOOCQ(SideObject so);
}
public class EasyRoads3Dv3.ERSORoad : object {
    
public SideObject sideObject;
    
public double id;
    
public bool active;
    
public List`1<Vector3> vecPositions;
    
public bool toggleActive;
    
public float xPosition;
    
public float yPosition;
    
public Vector3 randomRotation;
    
public float randomMinRotation;
    
public float randomMaxRotation;
    
public float minRandomRotationDistance;
    
public float maxRandomRotationDistance;
    
public bool xPosChange;
    
public bool yPosChange;
    
public bool rotationAngleChange;
    
public bool rotationDistanceChange;
    
public bool lockRandomRotations;
    
public bool randomXPositionChange;
    
public bool xPositionDistanceChange;
    
public bool randomYPositionChange;
    
public bool yPositionDistanceChange;
    
public float randomXPosition;
    
public float randomMinXPosition;
    
public float randomMaxXPosition;
    
public float minRandomXPositionDistance;
    
public float maxRandomXPositionDistance;
    
public float randomYPosition;
    
public float randomMinYPosition;
    
public float randomMaxYPosition;
    
public float minRandomYPositionDistance;
    
public float maxRandomYPositionDistance;
    public ERSORoad(SideObject so);
}
public class EasyRoads3Dv3.ERSORoadExt : ScriptableObject {
    
public SideObject sideObject;
    
public double id;
    
public bool active;
    
public List`1<Vector3> vecPositions;
    
public bool toggleActive;
    
public bool autoGenerate;
    
public bool markerActive;
    
public float m_distance;
    
public float xPosition;
    [HideInInspector]

public float oldXPosition;
    
public float yPosition;
    
public Vector3 randomRotation;
    
public float randomMinRotation;
    
public float randomMaxRotation;
    
public float minRandomRotationDistance;
    
public float maxRandomRotationDistance;
    
public bool distanceChange;
    
public bool xPosChange;
    
public bool yPosChange;
    
public bool rotationAngleChange;
    
public bool rotationDistanceChange;
    
public bool lockRandomRotations;
    
public bool randomXPositionChange;
    
public bool randomYPositionChange;
    
public bool xPositionDistanceChange;
    
public float randomXPosition;
    
public float randomMinXPosition;
    
public float randomMaxXPosition;
    
public float minRandomXPositionDistance;
    
public float maxRandomXPositionDistance;
    
public Vector3 boxColliderScale;
    
public bool yPositionDistanceChange;
    
public float randomYPosition;
    
public float randomMinYPosition;
    
public float randomMaxYPosition;
    
public float minRandomYPositionDistance;
    
public float maxRandomYPositionDistance;
    
public GameObject sourceObject;
    
public List`1<ERSOSection> sections;
    
public List`1<GameObject> objects;
    
public bool clampToMarkers;
    public void Init(SideObject so);
    public static ERSORoadExt CreateInstance(SideObject so);
    public static void Copy(ERSORoadExt source, ERSORoadExt target);
}
public class EasyRoads3Dv3.ERSORoadLog : object {
    
public double id;
    
public bool active;
    public ERSORoadLog(double so);
}
public class EasyRoads3Dv3.ERSOSection : ValueType {
    
public Vector3 startPosition;
    
public Vector3 endPosition;
    
public Vector3 p2;
    
public Vector3 p3;
    
public Vector3 ms1;
    
public Vector3 ms2;
    
public Vector3 ms3;
    
public Vector3 ms4;
    
public Vector3 me1;
    
public Vector3 me2;
    
public Vector3 me3;
    
public Vector3 me4;
    
public Vector3 startSplinePointOrig;
    
public float startDistance;
    
public int startSplinePointObject;
    
public int startSplinePoint;
    
public int endSplinePoint;
    
public float startFraction;
    
public float endFraction;
    
public float hsStart;
    
public float hsEnd;
    
public int startSplinePointGeo;
    
public float startDistanceGeo;
    
public int endSplinePointGeo;
    
public float endDistanceGeo;
    
public float maxHeightDifference;
    
public SideObject so;
    
public bool forceSo;
    
public ERRoadSide roadSide;
    
public double soid;
    
public bool acceptBarriers;
    
public bool active;
    
public double linkedSoId1;
    
public double linkedSoId2;
    public ERSOSection(Vector3 _startPos, Vector3 _endPos, int _startIndex, int _endIndex, float _startFraction, float _endFraction, float _hsStart, float _hsEnd);
    public static ERSOSection GetERSOSection(ERModularRoad road, int listIndex, Int32& index, int leftright, String& soType, List`1& sections);
    public static ERSOSection AdjustEndOffset(ERSOSection target, ERSOSection source);
}
public class EasyRoads3Dv3.ERSplatmap : ValueType {
    
public int x;
    
public int y;
    
public int index;
    
public int layer;
    
public float value;
    
public ERModularRoad script;
    
public float tValue1;
    
public float tValue2;
    
public float tValue3;
    
public float tValue4;
    
public float tValue5;
    
public float tValue6;
    
public float tValue7;
    
public float tValue8;
    
public float tValue9;
    
public float tValue10;
    
public float tValue11;
    
public float tValue12;
    public ERSplatmap(int m_x, int m_y, int m_index, int m_layer, float m_value, ERModularRoad scr, float tv1, float tv2, float tv3, float tv4, float tv5, float tv6, float tv7, float tv8, float tv9, float tv10, float tv11, float tv12);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERTerrain : MonoBehaviour {
    
public List`1<Vector3> surfacevecs;
    
public Single[] tdataFloat;
    
public TerrainData terrainData;
    
public int xStart;
    
public int zStart;
    
public GameObject roadSurface;
    
public Mesh surfaceMesh;
    
public MeshCollider surfaceCollider;
    
public List`1<ERTerrainData> terrainDataStored;
    
public List`1<ERTerrainChange> terrainChanges;
    
public List`1<ERTree> terrainTrees;
    
public List`1<List`1<tPoint>> detailInstancesOld;
    
public List`1<tPoint> detailInstances;
    
public List`1<int> detailInstanceStarts;
    
public List`1<GameObject> surfaceObjects;
    
public List`1<Vector3> terrainTestPoints;
    
public List`1<ERSplatmap> splatData;
    
public List`1<ERTreeInstance> addedTrees;
    
public List`1<ERCell> holes;
    
public List`1<ERTerrainData> terrainHeightsBackup;
    
public List`1<ERTree> terrainTreesBackup;
    
public List`1<tPoint> terrainDetailBackup;
    
public List`1<ERSplatmap> terrainSplatBackup;
    
public List`1<int> detailInstanceStartsBackUp;
    
public bool heightmapFlag;
    
public bool splatmapFlag;
    
public bool treeFlag;
    
public bool detailFlag;
    
public bool holesFlag;
    
public bool terrainDone;
    
public bool backupFlagNotification;
    
public bool ignore;
    
public GameObject backupObject;
    
public TerrainData terrain;
}
public class EasyRoads3Dv3.ERTerrainChange : ValueType {
    
public int index;
    
public int value;
    public ERTerrainChange(int v_index, int v_value);
}
public class EasyRoads3Dv3.ERTerrainData : object {
    
public int terrainWidth;
    
public int terrainHeight;
    
public float originalHeight;
    
public float flattenedHeight;
    
public float outerHeightDifference;
    
public bool critical;
    
public float perc;
    
public Vector3 hitpos;
    
public Vector3 outerPos;
    
public bool ignorePreserveHeights;
    public ERTerrainData(int m_terrainWidth, int m_terrainHeight, float m_originalHeight, float m_flattenedHeight, bool m_critical, float m_perc, float m_outerHeight, Vector3 m_hitPoint, Vector3 m_outerPoint);
}
public class EasyRoads3Dv3.ERTexture : object {
    
public Texture2D texture;
    
public float roadWidth;
    
public float leftOffset;
    
public float rightOffset;
    
public float leftInnerOffset;
    
public float rightInnerOffset;
    public ERTexture(Texture2D _texture, float _roadWidth, float _leftOffset, float _rightOffset, float _leftInnerOffset, float _rightInnerOffset);
    public static ERTexture GetERTexture(Material mat);
}
public enum EasyRoads3Dv3.ERTrafficDirection : Enum {
    
public int value__;
    
public static ERTrafficDirection LHT;
    
public static ERTrafficDirection RHT;
}
public class EasyRoads3Dv3.ERTree : object {
    
public Color color;
    
public float heightScale;
    
public Color lightmapColor;
    
public Vector3 position;
    
public int prototypeIndex;
    
public float widthScale;
    public ERTree(TreeInstance instance);
    public TreeInstance SetERTreeInstance(ERTree eRTreeinstance);
}
public class EasyRoads3Dv3.ERTreeInstance : object {
    
public int prototypeIndex;
    
public Vector3 position;
    public ERTreeInstance(TreeInstance tree);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ERTSidewalkTriangulation : MonoBehaviour {
    public static void OQDCOQDQDO(ERCrossings scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& materialList);
    public static void OQCQDDDOQD(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& intArray, List`1& materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt);
    public static List`1<int> OCCQOODCCO(List`1<int> col1, List`1<int> col2);
    public static List`1<int> OODOODOQOO(int outerPoint, List`1<int> innerCol, int startPoint, bool reverse);
    public static void OQCODDOCCD(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, List`1<Material> materialList, int leftrightroad);
    public static void OOCQCDDQOD();
    public static void ODOOOODDOO(List`1& materialList, List`1& triList, Material sidewalkMaterial, Int32& triArrayElement);
}
public class EasyRoads3Dv3.ERVSData : ValueType {
    
public Vector3 position;
    
public bool active;
    
public float width;
    
public Vector3 leftPosition;
    
public Vector3 rightPosition;
    
public Vector3 dir;
    public ERVSData(Vector3 node, bool active, float width, Vector3 leftPosition, Vector3 rightPosition);
}
public class EasyRoads3Dv3.NormalPairs : ValueType {
    
public int index1;
    
public int index2;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OCCQQCCDDD : MonoBehaviour {
    public static List`1<Vector3> OQDDOOOOQD(ERModularRoad scr, int startMarker, int endMarker, List`1<ERMarkerExt> markers, float faceDist, bool ignorePrefabAlignment, List`1& tValues, List`1& markerDistances, List`1& bendAngles);
    public static void OCQOQCDCQC(ERModularRoad scr, bool ignorePrefabAlignment, List`1<Vector3> splinePoints, List`1<float> tValues, List`1<float> markerDistances, int startMarker, int endMarker, int startInt);
    public static void OCQOQCDCQC(ERModularRoad scr);
    public static ERModularRoad DuplicateObject(ERModularRoad scr);
    public static GameObject ODOCOCQODQ(ERModularRoad scr, Transform parent, Vector3 p1, Vector3 p2, float x1, float x2, float height, Vector3 heighthmapscale);
    public static void CreateSplatMeshes(ERModularRoad scr, List`1& soSplatmapObjects, float splatSize);
    public static GameObject BuildSplatMesh(ERModularRoad scr, List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<int> tris, string name, int pos);
    public static void SetMarkerIndentAlignment(ERMarkerExt m, ERModularRoad scr);
    public static float GetleftToCenterPerc(List`1<Vector2> nodeList, int left, int right);
    public static void OQCDDDDOOQ(ERModularRoad r1, ERModularRoad r2, ERCrossingPrefabs prefab);
    public static void ODOOODOOOQ(ERModularRoad r1, ERModularRoad r2, int road1StartEnd, int road2StartEnd);
    public static void AverageTangentsRoadPrefab(ERModularRoad r1, ERCrossingPrefabs prefab, int road1StartEnd, int prefabStartEnd);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OCOCDDODDQ : MonoBehaviour {
    public static void OQCODQOCQD(ERSideWalk sw, List`1& vecs, Vector3 startVec, int rows, int closedVecCountStart, int closedVecCountEnd, int startEnd);
}
public class EasyRoads3Dv3.OCQOCDODDQ : MonoBehaviour {
    public static void ODCOOOQQQD(ERCrossingPrefabs scr, Vector3[] meshVecs, Vector3[]& surfaceMeshVecs);
    public static void OQCDOQOQDC(ERCrossingPrefabs scr, float angle, int dirInt, bool leftrightFlag);
    public static Vector3 ODQODDQDQO(Vector3 cornerPos, float indent, Vector3 outerPos, Vector3& dir);
    public static void OCCCQDODDD(ERCrossingPrefabs scr, Vector3 vecOuter1, Vector3 vecOuter2, Vector3& mainSurrounding, Vector3& connectedSurrounding);
    public static void CheckIndentOQCDCDOOCD(Vector3 dir1, Vector3 dir2, Vector3 cornerPos, Vector3 outer2, Vector3& indent2, Vector3& indent1, float angle, float minIndent, bool leftrightFlag);
    public static void OQDCOQOCQC(ERCrossingPrefabs scr, Vector3 corner, Vector3 indentMain, Vector3 indentConnection, Vector3& mainSurrounding, Vector3& connectedSurrounding, int dirInt);
    public static void ODDDDCCQCD(ERCrossingPrefabs scr, int connection, Vector3 leftIndent, Vector3 leftSurrounding, Vector3 rightIndent, Vector3 rightSurrounding);
    public static void OOOOCQCOQO(ERCrossingPrefabs scr, int connection, int leftIndent, int leftSurrounding, int rightIndent, int rightSurrounding);
    public static void ODQDODQOCC(ERCrossingPrefabs scr, int connection, Vector3 outerPoint, Vector3 crosspoint);
    public static float OOCDQCOCQO(Vector3 v11, Vector3 v12, Vector3 v21, Vector3 v22);
    public static void OODCQQDCCD(Vector3 inner, Vector3& outer, float minDist);
    public static void ODOODODQCO(ERCrossingPrefabs scr, Vector3[] meshVecs);
    public static void ODQQQCOCCD(ERCrossingPrefabs scr, int connection);
    public static void ODCQDDDOOO(ERCrossingPrefabs scr, QDOODOQQDQODD el1, QDOODOQQDQODD el2, int leftright);
    public static void OCDOQOOCCC(ERCrossingPrefabs scr);
    public static Vector3 ODCCDOCDQD(Transform transform, Vector3 pos, ERModularBase scr);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OCQOQOOOCO : MonoBehaviour {
    public static float OCOCQCDDCD(List`1& splinePoints, ERModularRoad scr, int marker, List`1& segPoints, List`1& tValues, Single& totalDist, int startMarker, Single& xzDistance, bool getDistance, Single& radius, List`1& bendAngles);
    public static Vector3 OOODCCODQD(Vector3& m2, Vector3& m1, Vector3& dir1, Vector3& dir2, Vector3 p1, Vector3 p4, Boolean& isAhead, Int32& firstLastAdjust, Boolean& isNoAdjust, ERModularRoad scr);
    public static float ODOCQOODDO(List`1& splinePoints, ERModularRoad scr, int marker, List`1& segPoints, List`1& tValues, Single& totalDist, int startMarker, Single& xzDistance, bool getDistance, List`1& bendAngles);
    public static Vector3 OCOCQCDDCD(ERModularRoad scr, int marker, Boolean& flag);
    public static void OOCCQCOOQQ(List`1& splinePoints, ERModularRoad scr, int marker, Vector3& pivotp, Vector3& p1, Vector3& p2, List`1& segPoints, List`1& tValues);
    public static void OQCQQDCDQO(ERModularRoad roadScr, List`1& tmpNodes, List`1<float> splineStrength, ERCrossingPrefabs prefabInstance, int connectionSegment, Vector3& connectionDir, Vector3& lastForward, int startEnd);
    public static int OCCCDCOQCC(ERModularRoad scr, List`1<Vector3> splinePoints, float minIndent, float outerRoadDistance, Vector3 ODCQDOOOCCIndent, Vector3 startPrefabIndent, int leftright);
    public static int OOQQDDDOQC(ERModularRoad scr, List`1<Vector3> splinePoints, float minIndent, float outerRoadDistance, Vector3 ODCQDOOOCCIndent, Vector3 startPrefabIndent, int leftright, Int32& endAdjustInt, Single& endAdjustDistance);
    public static ERModularRoad OCQDOCOODD(ERModularRoad scr, int marker);
    public static ERMarkerExt DuplicateMarker(ERMarkerExt sourceMarker);
    public static GameObject JoinRoads(List`1& objects, ERModularRoad& road, Int32& marker);
    public static void SwapIndentsSurroundings(ERModularRoad scr);
    public static void SwapSideObjects(ERModularRoad scr);
    public static int SoIndexMatch(ERSOMarkerExt markerSO, List`1<ERSOMarkerExt> Sos, int index);
    public static bool ODCODDQDCC(List`1<Vector3> splinePoints, int markers);
    public static void ODQDCODODC(ERModularRoad scr, Vector3 OOCDQCOOQC, ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool forceAutoRotate);
    public static void OODCOQOQOD(ERModularRoad scr, List`1& surfaceVecs, ERCrossingPrefabs prefabScript, Boolean& startSurfacesSafe, float distance, float minIndent);
    public static void ODOCCQDCQO(ERModularRoad scr, List`1& surfaceVecs, ERCrossingPrefabs prefabScript, int el, Boolean& surfacesSafe, float distance, float minIndent);
    public static void OCDCDQQQDO(ERModularRoad scr, ERCrossingPrefabs ODCQDOOOCC, int targetElement, bool reverse, bool uvReverse, bool UpdateResolutionFlag);
    public static void ODQOCCDCOC(List`1& uv1, List`1& uv2);
    public static List`1<int> OCCCDQCDOC(ERModularRoad scr, List`1<Vector2> roadShapeVecs, List`1<Vector2> connectionVecs, int startend);
    public static List`1<int> ODDCOQQDCO(ERModularRoad scr, List`1<Vector2> roadShapeVecs, ERCrossingPrefabs prefab, int connection, int startend);
    public static void OOCQODCOOQ(ERModularBase baseScr, ERModularRoad scr, int m1, int m2, int m3);
    public static void ODQDQOQQCO(ERModularBase baseScr, ERModularRoad scr, int m1, int m2, int m3);
    public static void OCDDCDDCQC(ERModularBase baseScript, List`1& vecs, List`1<float> tValues, float heigthOffset, Vector3& lastHeightAdjustCP, float resolution, float distance, bool nextMarkerContourAdjust, List`1<Vector3> currentVecs, List`1& testPoints, List`1& randomRotations);
    public static void OQDOQOCDCC(int lastInt, int currentInt, List`1<float> tValues, List`1& tmpTValues);
    public static bool OQCODQODCO(Vector3 ODCQDOOOCCIndent, Vector3 otherPrefabIndent, Vector3 v);
    public static Vector3 OQOCQCOCQQ(Vector3 position, Vector3 sourceV3, float angle, Vector3 euler);
    public static Vector3 ODOQCDQQCC(Vector3 position, Vector3 sourceV3, float angle, Vector3 euler);
    public static Vector3 GetEulerAngles(Vector3 v3direction);
    public static void ODCQCQCQDQ(GameObject road, Mesh sourceMesh, int LODCount, int LODLevel, int colCount, List`1<bool> hardEdge, List`1<int> roadShapeMaterialIntCounts);
    public static void ODQCQCOOCQ(ERCrossingPrefabs prefab, ERModularRoad road, int connectionIndex, int startEnd);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODCCODOCQQ : MonoBehaviour {
    
public static GameObject rtg;
    
public static GameObject swgLeft;
    
public static GameObject swgRight;
    
public static Vector3 camdir;
    
public static List`1<List`1<Vector3>> vecs;
    private static ODCCODOCQQ();
    public static void OODDQCQQDQ(ERModularBase baseScript, ERModularRoad scr);
    public static void CleanMeshData(Mesh m, List`1<List`1<int>> mtris, List`1& vecs, List`1& uvs, List`1& uvs2, List`1& normals, List`1& tangents, List`1& colors, List`1& tris);
    public static void OCDCQCOQQO(Mesh mesh);
    public static void OOCQQCOQQC(Mesh mesh);
    public static void GenerateWaypoints(ERModularRoad scr, float distance);
    public static void OOQDCQODOD(List`1<SelectedObject> selectedObjects, int alignType);
    public static void OOCDQDQDCQ(GameObject go, SideObject so, List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<Vector2> uvs1, List`1<Color> color, List`1<Vector4> tangents, List`1<int> triangles, List`1<Vector3> normals, List`1<int> normalArray1, List`1<int> normalArray2);
    public static void GetRoadShape(float width, int subSegments, List`1& roadShape, List`1& uvs, List`1& uvs1, float dir);
    public static void GetRoadShape(float oldWidth, QDQDOOQQDQODD roadType, float dir);
    public static void UpdateRoadType(ERModularBase scr, int index);
    public static bool UpdateRoadTypeByRoad(ERModularBase scr, ERModularRoad road, int index, QDQDOOQQDQODD type);
    public static int OCDQQQDDQO(List`1<Vector2> roadShape);
    public static void OCDQCDQQDD(List`1& tmpMarkersExt);
    public static void ODOCDOQDDQ(QDQDOOQQDQODD roadType);
    public static void RebuildMainRoadShape(QDQDOOQQDQODD roadType);
    public static void OQDCDQDCQC(QDQDOOQQDQODD roadType, List`1& roadShape, List`1& roadShapeUVs, List`1& doConnectionTri, List`1& hardEdge, Int32& currentMostLeftInt, Int32& currentMostRightInt, Int32& sectionRoadShapeCols, int leftright, int lineIndexTarget, bool transition, List`1<Vector2> origRoadShape);
    public static List`1<int> OODCQDDQDC(List`1<Vector2> _rs1, List`1<bool> _hd1, int cols1, List`1<Vector2> _rs2, List`1<bool> _hd2, int cols2, List`1& tris, bool flipNormals, int vecCount, int i1, int i2, int last1, int last2);
    public static void OOQCCCDODD(QDQDOOQQDQODD roadType, List`1& roadShapeVecs, List`1& roadShapeUVs, List`1& hardEdge, Int32& rightOuterIndex);
    public static void VisualizeRoadType(ERModularBase baseScript, GameObject prefab, QDQDOOQQDQODD rt, Vector3 pos, Vector3 dir);
    public static void ODODDQCQQC(QDQDOOQQDQODD rt);
    public static void OODDDCCOQO(List`1<Vector3> cvecs, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, List`1<float> breakpoints, float OQQOOQOOQQ, Vector3 startDir, Vector3 endDir, List`1& vecs, float length, Vector3 firstRounding, float uvRatio);
    public static void RoadShapeChangeTriangulation(List`1<Vector3> shape1, List`1<Vector3> shape2, int startIndex1, int endIndex1, int startIndex2, int endIndex2, List`1& tris);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODDCOQCOOO : MonoBehaviour {
    public static void OQOQDODDCD(ERCrossings scr);
    public static void ODCCDOQOOC(ERCrossings scr);
    public static void OQOQDOOOQO(ERCrossings scr, List`1<Vector3> vecArray, Vector3 firstOther, float sidewalkWidth, int xorz, Int32& cornerInt);
    public static void OOOQCOQOOQ(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector3>> vecArrayOther, QDOQDSQOOQDDD corner, int startEnd, int mainOrConnected, int outerCornerInt, bool crossingSide);
    public static void OODDCODCCQ(ERCrossings scr);
    public static List`1<Vector3> ODCODDCCOC(List`1<Vector3> outer, List`1<Vector3> outerOther, float dist, float height, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OOQQQQQCOO(List`1<Vector3> outer, float dist, float height, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQCDDCOODQ(ERCrossings scr, List`1<Vector3> innerArray, float dist, float height, float sidewalkWidth, int startend, int leftright, int outerCornerInt);
    public static List`1<Vector3> OQODQDOQOQ(List`1<Vector3> outer, float height);
    public static void ODQDQQOQCC(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1& uvArray, QDOQDSQOOQDDD corner, bool reverse, float uvTiling);
    public static void ODQOQOCCOC(List`1<List`1<Vector3>> vecArray, List`1& sidewalkUVs);
    public static void ODDCDODCCQ(List`1& outer1, List`1& outer2);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODDCQDDCDD : MonoBehaviour {
    public static void ODQQCQOODQ(List`1<ERRoundaboutElement> connections, List`1<Vector3> mainLeftPoints, List`1& meshVecs, List`1& meshUVs, List`1& fullTris);
    public static void OODQCCOOQC(List`1<ERRoundaboutElement> connections, List`1<Vector3> meshVecs, int vecCount, List`1& connectionVecs, List`1& connectionUVs, List`1& connectionTris, List`1& triList, List`1& materialList);
    public static void OCDDOCDDOQ(List`1<Vector3> meshVecs, List`1<int> connectionVecInts, List`1& roadShapeVecs, List`1& roadShapeUVY);
    public static Vector2 SetUV(Vector3 p1, Vector3 p2, Vector3 p3, Vector2 uv1, Vector2 uv2);
    public static bool OCCQDQQDCC(int nvert, List`1<Vector2> vert, float testx, float testy);
    public static bool OCCDQOCQQQ(int nvert, List`1<float> vertx, List`1<float> verty, float testx, float testy);
    public static bool OQOCDCDOQO(List`1<Vector3> vecs, List`1<OOCOCQCQOQ> edges, int p1, int p2, int p3);
    public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODDDDDCCQQ : MonoBehaviour {
    public static void OQDCOQDQDO(ERCrossings scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1<Material> materialList, List`1<Material> connectionMaterialList);
    public static float GetCenterUVY(ERCrossings scr, float uvTiling, List`1<List`1<Vector3>> vecArray, int connection);
    public static void OCODCOCODQ(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& intArray, int startRow, int triArrayIndex, int centerPointIndex);
    public static List`1<int> OODCODOODC(List`1<List`1<int>> intArray);
    public static List`1<int> OCCQOODCCO(List`1<int> col1, List`1<int> col2, int startRow);
    public static List`1<int> OOQCQQDDQC(List`1<int> col1, List`1<int> col2, List`1<Vector3> vecs1, List`1<Vector3> vecs2, int frontLeft, int topBottom, int startRow);
    public static void InitODCOCQQDDC(ERCrossings scr);
    public static void ODCOCQQDDC(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1& uvs, List`1& uvArray, int verthorz, float uvTiling);
    public static Vector3[] OOQOODDQCC(ERCrossings scr, Vector3[] vecs);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODDQODOOOC : MonoBehaviour {
    
public static List`1<Vector3> debugvecs;
    
public static bool sidewaysFlag;
    
public static bool useLastFowardFlag;
    
public static bool lastvecPositionsArray;
    
public static int currentSplineInt;
    
private static float ᙃ;
    
private static float ᙄ;
    
private static float ᙅ;
    
private static float 4AAAA;
    
private static Vector3 5AAA1;
    
private static Vector3 6AAAA;
    
private static float 7AAA1;
    
private static float 8AAAA;
    
private static float 9AAA1;
    
private static float BAAAA;
    
private static float CAAA1;
    
private static Vector3 00AAA;
    
private static Vector3 10AA1;
    
private static float 20AAA;
    
private static float 30AA1;
    
private static float 40AAA;
    
private static float 50AA1;
    
private static float 60AAA;
    
private static Vector3 70AA1;
    
private static Vector3 80AAA;
    
private static float 90AA1;
    
private static float B0AAA;
    
private static float C0AA1;
    
private static float 01AAA;
    
private static float 11AA1;
    
private static float 21AAA;
    
private static Vector3 31AA1;
    
private static Vector3 41AAA;
    
private static float 51AA1;
    
private static Bounds 61AAA;
    
private static int 71AA1;
    
private static int 81AAA;
    
private static int 91AA1;
    
private static bool B1AAA;
    
private static bool C1AA1;
    
private static bool 02AAA;
    private static ODDQODOOOC();
    public static void OOCOCOOQCC(List`1<SideObject> QOQDQOOQDDQOOQ, List`1& soDataExt);
    public static void OOCDDOCODO(ERModularBase scr, SideObject so);
    public static void OQOCQOCDOO(ERModularBase scr, SideObject so);
    public static bool ODOOCCCOQD(ERModularRoad scr, SideObject so, bool forceMarkerActive);
    public static void InitOtherMarkerSO(ERModularRoad scr, ERSOMarkerExt soData, SideObject so);
    public static ERSOMarkerExt[] ODODCDDCOD(ERModularRoad scr, SideObject so, Boolean& terrainSurfaceFlag);
    public static void SynchSideObjects(ERModularRoad scr1, ERModularRoad scr2);
    public static void OCCQDQOQCO(ERModularRoad scr, int marker);
    public static String[] OODDQDQDOQ(ERModularRoad scr);
    public static bool OOQDOCDDCO(ERModularRoad scr, SideObject so, int marker, bool mirrored);
    public static bool OOQDOCDDCO(ERModularRoad scr, SideObject so, int marker, Single& startOffset, Single& endOffset, ERSOMarkerExt& soMarker, bool mirrored);
    public static bool GetSidewaysPosition(ERModularRoad scr, SideObject so, List`1& sidewaysList, Boolean& customNodelistFlag, List`1& nodeListValues, List`1& shapeTransitionTypes);
    public static bool OOQOOQCQQO(ERModularBase scr, ERModularRoad roadScr);
    public static void ODQOCCQQCQ(ERModularRoad rScr, SideObject so);
    public static bool ODOOODCQCD(ERModularRoad road, int marker, int soIndex);
    public static bool OCCODCQODC(ERModularRoad road, int marker, int soIndex);
    public static bool OCOCCOODQC(List`1<SideObject> list, SideObject so);
    public static void ODQCOCOCOQ(ERModularBase scr, ERModularRoad roadScr, SideObject so);
    public static void ODOODCCDOC(ERModularBase scr, ERModularRoad roadScr, bool isSideObjectFlag);
    public static void OODQCDDCQO(ERModularBase scr, ERModularRoad roadScr, SideObject so, bool isParent);
    public static void OOOCCQDQCC(GameObject go, SideObject so, ERModularRoad roadScr, ERSORoadExt soData, bool mirrored, bool isChild);
    public static void AddBoxCollider(GameObject go, SideObject so, float zDist, float curDist, List`1<Vector3> vecPositions, List`1<float> vecDistances, int currentVecArrayInt, ERModularRoad roadScr, List`1<Vector3> vecPositionsCenter, List`1<Vector3> vecPositionsRight, ERSORoadExt soData);
    public static void CheckVertexLimit(SideObject so, int segment, bool force);
    public static void ODOCOOOQOC(float curDist, ERMesh mobject, int meshSegment, List`1<ERMarkerExt> markers, List`1<float> segmentDistances, List`1<float> segmentAccDistances, int markerIndex, List`1<Vector3> vecPositions, List`1<Vector3> vecPositionsLeft, List`1<Vector3> vecPositionsRight, List`1<Vector3> vecPositionsCenter, List`1<float> vecAngles, List`1<float> vecDistances, int currentVecArrayInt, bool debugFlag, int segmentCount, bool lastSegment, float scaleFactor, SideObject so, float halfRoadWidth, ERModularRoad roadScr, bool newSegment, bool skipStartBlend, bool skipEndBlend, Vector3& forward, Vector3& startPos, ERSORoadExt soData, bool mirrored, Single& steppedHeight, Int32& lastStep);
    public static void ODCQCCDOQO(float curDist, ERMesh mobject, int meshSegment, List`1<ERMarkerExt> markers, List`1<float> segmentDistances, List`1<float> segmentAccDistances, int markerIndex, List`1<Vector3> vecPositions, List`1<Vector3> vecPositionsLeft, List`1<Vector3> vecPositionsRight, List`1<Vector3> vecPositionsCenter, List`1<float> vecAngles, List`1<float> vecDistances, int currentVecArrayInt, bool debugFlag, int segmentCount, bool lastSegment, float scaleFactor, SideObject so, ERModularRoad roadScr, List`1<List`1<Vector2>> fullNodeList, float clampUVYPerc, float uvyShapeRatio, ERSORoadExt soData, bool mirrored, bool shapeDirFlag);
    public static void ODOODODODO(GameObject parentGo, float curDist, float scaleFactor, SideObject so, List`1<Vector3> vecPositions, List`1<Vector3> vecPositionsLeft, List`1<Vector3> vecPositionsRight, List`1<Vector3> vecPositionsCenter, List`1<float> vecAngles, List`1<float> vecDistances, int currentVecArrayInt, int num, ERModularRoad roadScr, int startConnectionEnd, ERSORoadExt soData, bool mirrored, bool rotateFlag, List`1<int> sectionIndexes, bool shapeDirFlag, int k);
    public static void ODCCQODCOQ(float tmpDist, List`1<Vector3> vecPositions, List`1<float> vecDistances, int currentVecArrayInt, Vector3& v, Vector3& v1, bool doSecond, bool debugFlag);
    public static void GetSplinePositionsMin(float tmpDist, List`1<Vector3> vecPositions, List`1<float> vecDistances, int currentVecArrayInt, Vector3& v, Vector3& v1, bool doSecond, bool debugFlag);
    public static void OCQCOOQCDO(float curDist, List`1<float> vecDistances, Int32& currentVecArrayInt);
    private static void GetRandomXDistance(float distance, Vector3& adjustedRotation, Vector3& currentRandomRotation, float randomRotationStart, float randomRotationMiddle, float randomRotationEnd, float randomRotationDistance, Vector3 randomRotation);
    private static void OCQQCOOQDQ(float distance, Vector3& adjustedRotation, Vector3& currentRandomRotation, float randomRotationStart, float randomRotationMiddle, float randomRotationEnd, float randomRotationDistance, Vector3 randomRotation);
    private static void OCCOOCDCQQ(float distance, Vector3& adjustedRotation);
    public static Terrain OQQOOCQQCD(Vector3 pos);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODOCDOQDCO : MonoBehaviour {
    public static void OQQQQQODDO(ERCrossings scr, Single& firstSegmentDistance);
    public static void OODDQCQOQQ(List`1& vecs, float firstX, float firstZ, float lastX, float lastZ);
    public static Vector3 OCCDQDCQCD(int i, float radius, float angle);
    public static void OQODOQQCOO(ERCrossings scr);
    public static void ODOODDOQOQ(List`1<Vector3> vecs, float firstX, float firstZ, float sidewalkWidth, float resolution, float currentDist);
    public static void OOOCDOCQQO(ERCrossings scr);
    public static void OOOCOQODOO(List`1<Vector3> targetVecs, float targetValue, float firstX, float firstZ, float resolution, int xorz);
    public static void OCOOOQQQQO(ERCrossings scr);
    public static List`1<Vector3> OOOCCCCDDQ(List`1<Vector3> sourceVecs, float leftRight, float distance);
    public static void OOCCOQQDQQ(ERCrossings scr);
    public static List`1<Vector3> OOOODDQDCC(List`1<Vector3> sourceVecs, int xorz);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODOOCCQDOC : MonoBehaviour {
    public static void ODCQCQCQDQ(Mesh mesh);
    public static void OptimizeMeshFull(Mesh mesh);
    public static void OptimizeVertices(List`1<Vector3> vecs, List`1<int> triangles);
    public static int OQQQCDCOOO(Vector3[]& verts, int start, Vector3 v);
    public static void OCDDOQQCDO(Int32[]& tris, int old, int newInt);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODQDQDQDQO : MonoBehaviour {
    public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, bool flag);
    public static float OQDDCCCOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p);
    public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck);
    public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint);
    public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle);
    public static float GetYAngleByDir(Vector3 dir);
    public static Vector3 OCOOCOOODQ(Vector3 point, float angle, Vector3 axis);
    public static Vector3 OQQDCOCCCO(Vector3 source, float angle);
    public static int ODOCOCDQCO(List`1<Material> mats, Material mat);
    public static float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up);
    public static bool OQOQCCCODC(GameObject go, Bounds& bounds);
    public static float OOCQOOCOQC(Vector3 pos, ERModularBase scr);
    public static Vector3 ODCCDOCDQD(Vector3 pos, Vector3 dir);
    public static Vector3 OCCDCCQDDO(Vector3 pos, Vector3 dir);
    public static Vector3 OOQODCCOQD(Vector3 pos, ERModularRoad scr);
    public static int ODQCDQOOCO(int segmentCount, SideObject so, bool newSegment, ERMesh mobject, bool lastSegment, bool skipStartBlend, bool skipEndBlend);
    public static void OCCQCDQQOQ(Vector3& v2, Vector3& n, Vector3 v, Vector3 dir, Vector2 vec, ERModularRoad roadScr, Vector3 randomRotation);
    public static void OQODQODDOQ(Vector3& v2, Vector3& n, Vector3 v, Vector3 dir, Vector2 vec, float angle, Vector3 randomRotation);
    public static void RandomAlignment(Vector3& v2, Vector3& n, Vector3 v, Vector3 dir, Vector2 vec, Vector3 randomRotation);
    public static void OCCDCDCQQQ(GameObject go, Vector3 v, ERModularRoad roadScr, Vector3 randomRotation);
    public static void OQQOODCODQ(GameObject go, Vector3 v1, Vector3 v3, Vector3 dir, Vector3 randomRotation);
    public static void OCOQCDDODO(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation, Vector3 cp2, Vector3 cp3);
    public static void InstantiatedRandomRotation(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation);
    public static bool RayTriangleOODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Ray ray);
    public static void OCDODCQDDO(ERModularBase scr, Vector3 v1, Vector3 v2, Single& minY, Single& maxY);
    public static List`1<Vector3> GetSoSplinePoints(ERModularRoad scr, List`1<float> sidewaysList, List`1& markerInts, List`1& tValues, List`1& markerDistances, List`1& tmpMarkers);
    public static List`1<Vector3> OOODQCOOCC(List`1<Vector3> points, float tension, float incr);
    public static List`1<Vector3> OOODQCOOCC(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float incr);
    public static List`1<List`1<Vector2>> GetRoadShapeValues(List`1<float> tValues, List`1<float> markerDistances, List`1<List`1<Vector2>> nodeListValues, int startMarker, int endMarker, List`1<Vector2> roadShape, List`1<int> shapeTransitionTypes, bool closedTrack);
    public static List`1<Vector3> GetSoMarkerPositionVecs(ERModularRoad scr, List`1<float> sidewaysList, List`1& soMarkerDir, List`1& soMarkerInt);
    public static void CheckGetSoMarkerPositionVecs(ERModularRoad scr, int marker, List`1& soMarkerVecs, List`1& soMarkerDir, List`1& soMarkerInt);
    public static void TerrainSmooth(Terrain terrain, ERModularRoad road, float size, int type, Int32& smoothStep);
    public static bool CheckSmoothPoint(int x, int z, float sampleWidth, float sampleHeight, ERModularBase scr);
    private static float Smooth(int x, int y, TerrainData terrainInfo);
    private static float Smooth1(float indent, float surrounding, float posY);
    public static bool CompareVector2List(List`1<Vector2> list1, List`1<Vector2> list2);
    public static string CheckMesh(GameObject go);
    public static void OCQOQODOCQ(Mesh m, MeshRenderer ren);
    public static List`1<float> OCOCDCOQCD(List`1<Vector2> nodes);
    public List`1<Vector2> ODCOCDCDQC(List`1<Vector3> vecs, float x);
    public static bool CheckConnectAngle(Vector3 r1, Vector3 p1, Vector3 p2);
    public static void OOQQCCOQOC(Transform parent, GameObject& go, string name, List`1<Vector3> OCDCOCQQOO, Material mat, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, float ODCCDDDODQ, float ODDQQCDDOD, float OCQCODCDCO, Vector2 OQCOCDQODQ, Vector2 ODDCOOCQCO, float uvRatio);
    public static bool InIntArray(int v, List`1<int> arr);
    public static void OOQCCQCCCC(ERModularBase scr);
    public static OQQCCQCDQQ OQQOCDDDCC(ERModularRoad road, Vector3 pos, QDQDOOQQDQODD rt, int splineIndex);
    public static int GetEdgePositionByDistance(List`1<Vector3> splinePoints, float distance, int startSplinePoint);
    public static int OCOODQDDDO(List`1<Vector3> splinePoints, float distance, int startSplinePoint, Vector3& pos);
    public static int GetSplinePointIndex(List`1<Vector3> splinePoints, float distance, int startIndex, int dir);
    public static float OQQOQODCCC(Terrain terrain, Vector3 p1, Vector3 p2);
    public static bool RaycastRoadsSurfaces(int layer, Vector3 pos, Vector2& uv, GameObject& go, bool checkHeightFlag);
    public static void GetIndexAndFraction(List`1<Vector3> points, float fraction, int index, float dist, Int32& targetIndex, Single& targetFraction, int dir);
    public static ERPoint ODCDDDCCDD(ERPoint source);
    public static void MergeVertices(Mesh m);
    public static int in_array(List`1<Vector3> vecs, List`1<Color> colors, Vector3 v, Color c);
    public static bool Vector2ListComparer(List`1<Vector2> list1, List`1<Vector2> list2);
    public static bool FloatListComparer(List`1<float> list1, List`1<float> list2);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.ODQDQDQDQOExt : MonoBehaviour {
    public static void OOODCQCQOC(ERModularBase scr);
    public static String[] OQDQCCCDQO(ERModularRoad scr, String[] prefabs, ERCrossingPrefabs[]& prefs, int type);
    public static bool OQDOQQDDOC(ERModularRoad road, Boolean& left, Boolean& right);
    public static bool OCCCQODODQ(ERCrossingPrefabs prefab, ERModularRoad road, int marker, int connection);
    public static bool OCQDQQDOOD(ERCrossingPrefabs prefab, ERModularRoad road, int marker, int connection);
}
public enum EasyRoads3Dv3.OffsetPosition : Enum {
    
public int value__;
    
public static OffsetPosition Start;
    
public static OffsetPosition End;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OOCQQOOQOD : MonoBehaviour {
    public static void OOQCQDDOOC(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, int startend);
    public static void OCOCOCCDOO(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, int startend);
    public static void OODQQOQDOC(ERModularBase baseScript, ERCrossingPrefabs scr, int connectionSegment, ERModularRoad road, ERCrossingPrefabs otherPrefabScript, int otherConnection);
    public static void ODOCQDCDOQ(ERCrossingPrefabs scr, int lookUpElement, Boolean& roadOnNeighbour, Int32& cornerElement, Boolean& centerStatus);
    public static void OQOOQCDOCD(ERCrossingPrefabs scr, int lookUpElement, Boolean& roadOnNeighbour, Int32& cornerElement, Boolean& centerStatus);
    public static bool CheckRoadTypeChanges(ERModularBase baseScript, ERCrossingPrefabs prefabScript, bool ercrossing, bool erroundabout);
    public static void UpdateToRoadType(ERCrossingPrefabs prefabScript, QDQDOOQQDQODD sourcePreset, List`1& updatedRoads);
    public static void SwapConnectionInit(ERModularBase scr, ERCrossingPrefabs prefab, Int32& newIndex, Int32& oldIndex, Int32& index1, Int32& index2, ERModularRoad& road1, ERModularRoad& road2);
    public static void OCCDCDQOOD(ERModularBase scr, ERCrossingPrefabs prefab, int newIndex, int oldIndex, int index1, int index2, ERModularRoad road1, ERModularRoad road2);
    public static void OCODDODODQ(ERCrossingPrefabs prefab, int index, Int32& newIndex);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OODODOQDCC : MonoBehaviour {
    public static void OQCCCDDOQO(ERBend scr, List`1& leftOuterSegments, List`1& leftInnerSegments, List`1& rightOuterSegments, List`1& rightInnerSegments);
    public static List`1<Vector3> OOOOOOODCO(Vector3 prefabCenterpos, Vector3 cpCenterposV3, Vector3 v1, Vector3 cp, Single& totalDistance, List`1& controlPoints);
    public static List`1<Vector3> ODQOQQOQOC(Vector3 prefabCenterpos, Vector3 cpCenterposV3, Vector3 v1, Vector3 cp, Single& totalDistance, List`1& controlPoints, float angle, float multiplyFactor);
    public static Vector3[] OOOOCDQODC(ERCrossingPrefabs scr, int connection, List`1<Vector3> controlPoints, float segmentDistance, float defaultDistance, Vector3[] meshVecs, Vector3[]& tCrossingTmpFullMeshVecs, float multiplyFactor, float angle, float curveStrength);
    public static Vector3[] OCOOCQDCDD(ERCrossingPrefabs scr, int connection, List`1<Vector3> controlPoints, float segmentDistance, float defaultDistance, Vector3[] meshVecs, Vector3[]& tmpSurfaceVecsTCrossings, float multiplyFactor, float angle, float curveStrength);
    public static Vector3[] OCDDOQCCQC(ERCrossingPrefabs scr, int connection, List`1<Vector3> controlPoints, float segmentDistance, Vector3[] meshVecs, float multiplyFactor, float angle, Vector3 cpCenterPoint);
    private static float GetZAdjust(Vector3 vec, float angle);
    public static void OCQQDDOCCD(ERCrossings scr, int connection, int x, int y, List`1<List`1<Vector3>> vecArray);
    public static void OQDDOCOOOO(ERCrossings scr, int connection, List`1<List`1<Vector3>> vecArray, int leftright);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OOODCDOCOC : MonoBehaviour {
    public static void OCCCOOOCDO(ERCrossingPrefabs scr, ERModularBase baseScript);
    public static void OQCDCQOQDC(List`1& indentVecs, List`1& baseVecs, List`1& uvs, List`1& doSurroundingTriangle, List`1<Vector3> vecs, List`1<int> surfaceVecType, float indent, float surrounding, ERCrossingPrefabs scr, Boolean& lastIndentIsRight);
    public static void ODCCDDODCD(Vector3& indentVec, Vector3& dir, Vector3 vec, Vector3 prefVec, Vector3 nextVec, float indent, int leftOrRight);
    public static bool OCQODQCOOC(Vector3 vec, Vector3& rightIndentVec, Vector3& rightVec, Vector3& leftIndentVec, Vector3& leftVec, Int32& startInt, List`1<Vector3> vecs, List`1<int> surfaceVecType, float indent, Vector3 leftIndentDir, Vector3 checkVec);
    public static float ERGetInterpolationDistance(Vector3 pos, Vector3 dir, Vector3 vec);
    public static Vector3 GetNextRightVec(int startInt, List`1<Vector3> vecs, List`1<int> surfaceVecType);
    public static void ODDDDQDDQC(List`1& indentVecs, List`1& baseVecs, List`1& doSurroundingTriangle, Vector3 rightVec, Vector3 baseVec);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OOQOQOODQC : MonoBehaviour {
    public static void OCDCCCCCCQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void ODCQCQQQCQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OQDDCCCQQQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OODCCQQDOO(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OQCDQQODOD(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OCQDQCQDCC(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, int startEnd, bool hardEdge);
    public static void ODOODOCDOD(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OODDQQQDDQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void OCCDCDCODO(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static void ODOQCDCCOQ(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, int triArrayElement, int leftrightroad, bool hardEdge);
    public static float OQDDDOODCQ(Vector3 v1, Vector3 v2, float uvRatio, float startUV, float dir);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OOQQQDOCDD : MonoBehaviour {
    public static void OCODDOCODQ(Int32& startInt, float startOffset, List`1& markerInts, List`1& vecPositions, List`1& soSplinePointLeft, List`1<Vector3> soSplinePointRight, ERSOMarkerExt& soMarker, ERModularRoad roadScr, List`1& nodeList);
    public static void OCQCDCDCQC(int startInt, float endOffset, List`1& markerInts, List`1& vecPositions, List`1& soSplinePointLeft, List`1<Vector3> soSplinePointRight, ERSOMarkerExt& soMarker, ERModularRoad roadScr, List`1& nodeList);
    public static bool MoveDirection(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v);
    public static void OQDCCQDCQQ(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v, Camera cam, Int32& xDir, Int32& yDir);
    public static void ODODODDCCQ(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v, Vector3 vOld, float movement);
    public static void OODCOCOCCO(ERModularRoad road, ERSOMarkerExt markerSO, Vector3 v);
    public static void OCQQDCQQCO(int startInt, List`1<Vector3> vecPositions, List`1<int> markersInts, ERSOMarkerExt& soMarker, bool startFlag, ERModularRoad roadScr);
    public static void SynchSoData(ERSORoadExt soData, bool flag);
    public static void OOQQCOQDQC(ERSORoadExt soData, ERSORoadExt source);
    public static void UnlockSORotation(List`1<ERSORoadExt> soDataList);
    public static void CheckMarkerSOData(SideObject so, ERModularRoad road);
    public static void ResetMarkerSOData(ERModularRoad road);
    public static void OQOQCQQCQQ(ERModularRoad road, SideObject so);
    public static void OOCDDOOOOQ(ERModularBase scr, SideObject so, GameObject go);
    public static bool IsActiveAsChild(ERModularBase scr, double soid, double targetSOId);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQCDCDQCCD : MonoBehaviour {
    public static void OQQODODQCQ(ERCrossingPrefabs scr, Vector3[] meshVecs, Vector3[]& surfaceMeshVecs);
    public static void UpdateYCrossingSurfaces(ERCrossingPrefabs scr, Vector3[] meshVecs, List`1<ERConnectionSibling> siblings, Vector3[]& surfaceMeshVecs);
}
public class EasyRoads3Dv3.OQDQODQQCC : MonoBehaviour {
    public static void OODDQOQCCD(int el, List`1& OQCODQQCOO, List`1& OOOQOOOODO, List`1& OCCDOQDDOD, List`1<Vector2> OODQOODCOQ, List`1<Vector2> OCOCQQCDOQ, Int32[] OCQDQOCDCQ, Int32[] OCDCODCDQC, Int32[] ODCQQOQCCC, Int32[] ODCOCDCQDO, Vector3[]& OODOOCCDQO, Vector2[]& OQQOCCDCQO, Int32[]& OOOOQOODCD, Vector3[]& OQCDOCDOQQ, Vector3[]& OOCOOQQDCO, Vector3[]& OCCQCDCOCD, Vector3[]& OCQCCCOOCO, int ODQCCQDCDC, bool OQQOOQCCDD, Vector3 OQCCCODDCD);
    public static void OCOOQCQOQO(List`1& OOQCOODQDO, List`1& OQQQCQQCOC, List`1& OCQQOCQQQD, List`1& OOOQDCCCQD, List`1<Vector3> vecs, List`1<Vector3> OCDQDQQCCC, int start, int end, Vector3 OQCCCODDCD, string OQDQOQDOCO, bool OQQOOQCCDD, Vector3 OCQQCCCQOQ, Vector3 OCDOOQOOCO, List`1& ODQOOOCDQO, List`1& OCOQQDODOO, List`1<Vector2> UVs);
    public static void OQCQCDCOQQ(List`1<Vector2> OCOCQQCDOQ, Vector3 OQCCCODDCD, List`1<Vector3> OOCCDCODCC, List`1<Vector3> OQDQQDCOQO, List`1<Vector2> OCDOCDODOD, List`1<Vector2> OCODQCCQOD, int el, Vector3[] OQODCDCQDD, Vector3[] OQQOCQOQQO, Vector2[] OCDOQODDCC, Vector2[] OOOQOCCOQO, Vector3 OCCCOQCCQO, Vector3 OOCCOQDQOD, Vector2 OCCOCQCDCQ, Vector2 OOCQDQCQDO);
    public static void OCDCOOOCCC(List`1<Vector2> OODQOODCOQ, Vector3 OQCCCODDCD, List`1<Vector3> OQODCDCQDD, List`1<Vector3> OQQOCQOQQO, List`1<Vector2> OCDOCDODOD, List`1<Vector2> OCODQCCQOD, int el, Vector3[] OOCCDCODCC, Vector3[] OQDQQDCOQO, Vector2[] ODQDDQDCCD, Vector2[] ODQQOQQODQ, Vector3 OQOQQDODOO, Vector3 OQOCDOQQOD, Vector2 OQOQQDODOOUV, Vector2 OQOCDOQQODUV);
    public static void ODDDCOCCQO(int el, Vector3[] OQDOQQCOCQ, Vector2[] ODQOOOCDQO, Vector3[] OQODCDCQDD, Vector3[] OOCCDCODCC, Vector2[] OCDOQODDCC, Vector2[] ODQDDQDCCD, Vector3 OQCCCODDCD);
    public static void OQQDCQOCQC(int el, Vector3[] OOQCQCOODD, Vector2[] OCOQQDODOO, Vector3[] OQQOCQOQQO, Vector3[] OQDQQDCOQO, Vector2[] OOOQOCCOQO, Vector2[] ODQQOQQODQ, Vector3 OQCCCODDCD);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQOQCCCDDQ : MonoBehaviour {
    public static void OQDCOQDQDO(ERCrossings scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& materialList);
    public static void OQCDQOQCOQ(ERRoundabouts scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& materialList);
    public static void OQCCQQOCCO(ERRoundabouts scr, List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<int> tris, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& materialList);
    public static void OQCQDDDOQD(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& intArray, List`1& materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt, List`1& normalInts, List`1& normalIntsStart);
    public static void OQOCDQDDCO(ERRoundabouts scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& startNormalInts, List`1& endNormalInts, List`1& meshUVs, List`1& triList, List`1& intArray, List`1& materialList, bool reverse, QDOQDSQOOQDDD corner, int outerCornerInt);
    public static List`1<int> OCCQOODCCO(List`1<int> col1, List`1<int> col2);
    public static List`1<int> OODOODOQOO(int outerPoint, List`1<int> innerCol, int startPoint, bool reverse);
    public static void OQCODDOCCD(ERCrossings scr, QDOQDSQOOQDDD corner, List`1<List`1<Vector3>> sourceVecs, List`1<List`1<Vector2>> sourceUVs, List`1<List`1<int>> sourceTris, List`1& vecs, List`1& uvs, List`1& triList, List`1<Material> materialList, int leftrightroad);
    public static void OOCQCDDQOD();
    public static void ODOOOODDOO(List`1& materialList, List`1& triList, Material sidewalkMaterial, Int32& triArrayElement);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQOQQODODO : MonoBehaviour {
    public static void OQQQQQODDO(ERCrossings scr, Single& firstSegmentDistance);
    public static void OODDQCQOQQ(List`1& vecs, float firstX, float firstZ, float lastX, float lastZ);
    public static Vector3 OCCDQDCQCD(int i, float radius, float angle);
    public static void OQODOQQCOO(ERCrossings scr);
    public static void ODOODDOQOQ(List`1<Vector3> vecs, float firstX, float firstZ, float sidewalkWidth, float resolution, float currentDist);
    public static void OOOCDOCQQO(ERCrossings scr);
    public static void OOOCOQODOO(List`1<Vector3> targetVecs, float targetValue, float firstX, float firstZ, float resolution, int xorz);
    public static void OCOOOQQQQO(ERCrossings scr);
    public static List`1<Vector3> OOOCCCCDDQ(List`1<Vector3> sourceVecs, float leftRight, float distance);
    public static void OOCCOQQDQQ(ERCrossings scr);
    public static List`1<Vector3> OOOODDQDCC(List`1<Vector3> sourceVecs, int xorz);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQQCCQCDQQ : MonoBehaviour {
    [HideInInspector]

public QDQDOOQQDQODD roadType;
    [HideInInspector]

public double roadTypeID;
    [HideInInspector]

public int roadTypeIndex;
    [HideInInspector]

public int geometryType;
    [HideInInspector]

public ERExitType exitType;
    [HideInInspector]

public float offset;
    [HideInInspector]

public int halfwayIndex;
    [HideInInspector]

public int startSplineIndex;
    [HideInInspector]

public int endSplineIndex;
    [HideInInspector]

public Vector3 endSplinePointRight;
    [HideInInspector]

public Vector3 endSplinePointLeft;
    [HideInInspector]

public float startDistance;
    [HideInInspector]

public float endDistance;
    [HideInInspector]

public int markerIndex;
    [HideInInspector]

public int extrusionType;
    [HideInInspector]

public AnimationCurve extrusionCurve;
    [HideInInspector]

public float extrusionDistance;
    [HideInInspector]

public int startDistanceIndex;
    [HideInInspector]

public float startDecalDistance;
    [HideInInspector]

public float fixedDistance;
    [HideInInspector]

public int fixedDistanceIndex;
    [HideInInspector]

public float splitDistance;
    [HideInInspector]

public AnimationCurve splitCurve;
    [HideInInspector]

public float splitEndWidth;
    [HideInInspector]

public float connectionAngle;
    [HideInInspector]

public float connectionRadius;
    [HideInInspector]

public ERModularRoad road;
    [HideInInspector]

public ERCrossingPrefabs connector;
    [HideInInspector]

public Vector3 connectionHandlePosition;
    [HideInInspector]

public Vector3 OCODOQDODQ;
    [HideInInspector]

public Vector3 handleDirection;
    [HideInInspector]

public GameObject surfaceMesh;
    [HideInInspector]

public GameObject exitSignObject;
    [HideInInspector]

public float exitSignObjectOffset;
    [HideInInspector]

public GameObject exitSignObjectInstance;
    [HideInInspector]

public GameObject exitSplitSpawnObject;
    [HideInInspector]

public int exitSplitSpawnType;
    [HideInInspector]

public float exitSplitSpawnDistance;
    [HideInInspector]

public float exitSplitSpawnStartOffset;
    [HideInInspector]

public float exitSplitSpawnOffset;
    [HideInInspector]

public float exitSplitSpawnObjectBounds;
    [HideInInspector]

public List`1<GameObject> spawnedSplitObjects;
    [HideInInspector]

public List`1<Vector3> soPointsRightStart;
    [HideInInspector]

public int soRightSplitEndIndex;
    [HideInInspector]

public List`1<Vector3> soPointsLeftStart;
    [HideInInspector]

public int startLineMarkingDecal;
    [HideInInspector]

public bool startDecalFoldout;
    [HideInInspector]

public int splitLineMarkingDecal1;
    [HideInInspector]

public bool splitDecal1Foldout;
    [HideInInspector]

public int splitLineMarkingDecal2;
    [HideInInspector]

public bool splitDecal2Foldout;
    [HideInInspector]

public List`1<Vector3> edgeVecs;
    [HideInInspector]

public List`1<Vector3> vecs;
    [HideInInspector]

public List`1<Vector2> uvsArray;
    [HideInInspector]

public List`1<Vector2> uvsArray2;
    [HideInInspector]

public List`1<Color> customColors;
    [HideInInspector]

public List`1<Color> colors;
    [HideInInspector]

public List`1<int> tris;
    [HideInInspector]

private int ᙃ;
    [HideInInspector]

private int ᙄ;
    [HideInInspector]

private int ᙅ;
    [HideInInspector]

private List`1<Vector3> 4AAAA;
    [HideInInspector]

private List`1<Vector3> 5AAA1;
    [HideInInspector]

private List`1<Vector3> 6AAAA;
    [HideInInspector]

private List`1<float> 7AAA1;
    [HideInInspector]

private List`1<Vector3> 8AAAA;
    [HideInInspector]

private Vector3 9AAA1;
    [HideInInspector]

private float BAAAA;
    [HideInInspector]

private float CAAA1;
    [HideInInspector]

private float 00AAA;
    [HideInInspector]

private float 10AA1;
    [HideInInspector]

private int 20AAA;
    [HideInInspector]

private int 30AA1;
    [HideInInspector]

public List`1<Vector3> treeVecs;
    [HideInInspector]

public List`1<Vector3> detailVecs;
    public static void OOOCDQDQDC(List`1<ERMarkerExt> markers, List`1<OQQCCQCDQQ> exitRoads, List`1& splinePoints, List`1& tValues);
    public static void ODOCDDDDDO(List`1<ERMarkerExt> markers, OQQCCQCDQQ exitRoad, List`1& splinePoints, List`1& tValues, int currentInt);
    public static void OQCCQOQDDO(ERModularBase baseScript, ERModularRoad road, List`1<OQQCCQCDQQ> exitRoads, List`1<ERMarkerExt> markers, List`1& soSplinePointsLeft, List`1& soSplinePointsRight, Boolean& hasExits, List`1<float> leftIndentFloats, List`1<float> rightIndentFloats, List`1<float> leftSurroundingFloats, List`1<float> rightSurroundingFloats, List`1& surfaceVecs);
    public static void OCCCOOCCQC(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, List`1& soSplinePointsLeft, List`1& soSplinePointsRight, List`1<float> leftIndentFloats, List`1<float> rightIndentFloats, List`1<float> leftSurroundingFloats, List`1<float> rightSurroundingFloats, List`1& roadSurfaceVecs);
    public void BuildMeshInit(OQQCCQCDQQ exitRoad, List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<int> tris, List`1<Color> colors, Material mat, ERModularRoad road);
    public void OQDDCODQCD();
    public void SpawnSplitObjects();
    public void OQDDCCQOOO(Int32& curGo, Vector3 v);
    public static void OOOOOCODQO(OQQCCQCDQQ exitRoad, int vecCount, List`1<Vector3> vecs, List`1<Vector2> uvsArray, List`1<int> tris);
    public static void ODQCODOCDO(OQQCCQCDQQ exitRoad, int vecCount, List`1<Vector3> vecs, List`1<Vector2> uvsArray, List`1<int> tris, int decalIndex);
    public static void OQCCDDDOQQ(int i, int j, Vector3 prevPos, List`1<Vector3> edgeVecs, List`1<Vector3> soSplinePointsRight, float angleThreshold, List`1& tmpvecs);
    private static void OOOQCQDCDD(int curLeft, int endLeft, int curRight, int endRight, List`1<int> rightInts, List`1<Vector3> vecs, List`1& tris);
    public static void ODCDCQCOCQ(List`1<Vector3> vecs, List`1& tris);
    public static void ODQDQDCOQD(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, List`1& soSplinePointsLeft, List`1& soSplinePointsRight);
    public static void ODDDDDDQQD(ERModularBase baseScript, ERModularRoad road, ERMarkerExt marker, List`1& soSplinePointsLeft, List`1& soSplinePointsRight);
    public static void OQDOQDDCDD(ERModularBase baseScript, ERModularRoad road, OQQCCQCDQQ exitRoad, List`1<ERMarkerExt> markers, List`1<List`1<Vector3>> exitOuterVerticesExtrusion, List`1<List`1<Vector3>> exitOuterVerticesFixed, List`1<List`1<Vector3>> exitOuterVerticesCurve, List`1<Vector3> exitInnerVertices);
    public static void OCDQCQDDOQ(ERModularBase baseScript, ERModularRoad road, List`1<ERMarkerExt> markers);
    public static void OCDDDOQCCO(ERModularBase baseScript, List`1<ERMarkerExt> markers, List`1& vecs, List`1& uvsArray, List`1& uvsArray2, List`1& customColors, List`1& colors, List`1& tris, Material[]& materialsList);
    public static void OCDDCCQCCD(Int32& triIndex, List`1& tris, Material[]& materialsList, Material m);
    public static float OQQDDDDDOC(Vector3 v, List`1<Vector3> soSplinePointsLeft, List`1<Vector3> soSplinePointsRight, Int32& cInt, bool flag, Int32& match);
    private static void ODDDOCDCQO(List`1<Vector3> vecs, List`1<Vector2> uvs, List`1<int> tris, List`1<Color> colors, Material mat, GameObject go, ERModularRoad road);
    private void OCCDCQQDOQ(List`1<Vector3> vecs, List`1<int> connectionInts, List`1<Vector3> surfaceVecs, Vector3 prefDirVec);
    public Vector3 ODCCQQDQQQ();
    public void OCQOQQCDOD(List`1<Vector3> surfaceVecs, List`1<Vector2> uvs, int firstSection, int secondSection);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.OQQDOCQOCO : MonoBehaviour {
    public static void OQDCOQDQDO(ERCrossings scr, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1<Material> materialList, List`1<Material> connectionMaterialList);
    public static void OCODCOCODQ(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1<List`1<Vector2>> uvArray, int frontLeft, int topBottom, List`1& meshVecs, List`1& meshUVs, List`1& triList, List`1& intArray, int startRow, int triArrayIndex, int connection, List`1& borderIntsLeft, List`1& borderIntsRight, int centerPointIndex);
    public static List`1<int> OODCODOODC(List`1<List`1<int>> intArray);
    public static List`1<int> OCCQOODCCO(List`1<int> col1, List`1<int> col2, int startRow, int type);
    public static List`1<int> OOQCQQDDQC(List`1<int> col1, List`1<int> col2, List`1<Vector3> vecs1, List`1<Vector3> vecs2, int frontLeft, int topBottom, int startRow);
    public static void InitODCOCQQDDC(ERCrossings scr);
    public static void ODCOCQQDDC(ERCrossings scr, List`1<List`1<Vector3>> vecArray, List`1& uvs, List`1& uvArray, int verthorz, float uvTiling);
}
public class EasyRoads3Dv3.PointERV3 : object {
    
public float timeCreated;
    
public Vector3 position;
    
public bool lineBreak;
    
public int curveFlag;
    
public float Time;
    
public int x;
    
public int y;
    
public int z;
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.QDDDQODDQDQDQDD : MonoBehaviour {
    
public static Vector3 testPoint;
    
public static ERCrossings cScr;
    
public static List`1<Vector3> ll1;
    
public static List`1<Vector3> ll2;
    
public static List`1<Vector3> ll3;
    
public static List`1<Vector3> ll4;
    
public static int crossingStructure;
    
public static List`1<QDQDOOQQDQODD> roadTypesDynamic;
    
public static ERModularBase baseScript;
    
public static List`1<ERConnectionSibling> siblings;
    
public static Vector3 crossPointCenter;
    
public static ERCrossingPrefabs prefabScript;
    
public static ERConnectionSibling primaryPriorityConnection;
    
public static ERConnectionSibling secondPriorityConnection;
    
private static float ᙃ;
    
private static float ᙄ;
    
public static List`1<Vector3> debugEdges;
    
public static List`1<Vector3> debugvecs;
    private static QDDDQODDQDQDQDD();
    public static List`1<QDQDOOQQDQODD> OQQCDQOQCD(List`1<QDQDOOQQDQODD> roadTypes, bool all);
    public static void OQODQQQCOC(ERCrossings scr);
    public static void ODODCOOQDO();
    public static bool OCODDQQOCQ(List`1<ERConnectionSibling> siblings, int thisSibling, int OtherSibling, int startLane);
    public static void OQCDQDQOOO(bool hasLaneControlData);
    public static ERLaneConnector OCODCDQQOQ(ERCrossings scr, int startConnectionIndex, int startLaneIndex, int endConnectionIndex, int endLaneIndex, bool stop);
    public static void OQQDCODOQD(ERCrossingPrefabs scr, ERLaneConnector& conn, int startConnectionIndex);
    public static bool OQQQQQODQD(Vector3 left, Vector3 rightStart, Vector3 rightEnd, Single& angle1, float prevAngle1, float angle2, bool flag);
    public static Vector3 OODQQDCDCD(float distance, float angle);
    public static void OQDOCDCQCD(Vector3 cp, float roadWidth, Vector3& lStart, Vector3& lEnd, Vector3& rStart, Vector3& rEnd, float largestRadius);
    public static void GetOCOCQCDDCD(Vector3 cp, float radius, int cornerSegments, Vector3 leftPoint, Vector3 rightPoint, List`1& leftpoints, List`1& rightpoints, bool flag);
    private static void OOCCQCDQQC(List`1<Vector3> rightPoints1, List`1<Vector3> leftPoints1, List`1<Vector3> leftPoints2, List`1<Vector3> rightPoints2, List`1& outerpoints, List`1& innerpoints, float dist);
    private void OOOQOQODDD(Single& uvRatio, List`1& priorityLeftPoints, List`1& priorityRightPoints, List`1& rightRoundingPoints, List`1& leftRoundingPoints, List`1& leftRoundingPointsOther, List`1& rightRoundingPointsOther);
    private static bool OOCOCOCDQD(float radius, int cornerSegments, Vector3 startPoint, Vector3 endPoint, List`1& points, List`1& priorityPoints, float curvature, bool swapflag, bool priorityIsSingleSection, Vector3 prioritySectionDir, int leftright, bool leftRightCheck, Int32& mainIndex, Boolean& insertFlag);
    private static void MatchLeftRights(List`1& leftRoundingPoints, Vector3 lStart, List`1& rightRoundingPoints, Vector3 rStart);
    public static void OOCDCOQDDO(List`1<Vector3> leftRoundingPoints, List`1<Vector3> rightRoundingPoints, List`1& roadVecs, List`1<Vector2> roadShape, int leftFixedPoint, int rightFixedPoint, int middleIndex, Vector3 cp, Vector3 cp1, List`1& priorityPointsMain, ERConnectionSibling prioritySibling, bool isSecondary);
    public static bool OOCOCCQDCQ(Vector3 v, List`1<Vector3> points, int firstIndex, int lastIndex);
    public static void OODQCOCOQD(List`1<Vector3> leftRoundingPoints, List`1<Vector3> rightRoundingPoints, List`1& roadVecs, List`1<Vector2> roadShape, int leftFixedPoint, int rightFixedPoint, int middleIndex, Vector3 cp, Vector3 cp1);
    public static void OQQDQCQCDQ(List`1<Vector3> roundingPoints, List`1& pointsIndents, float indent, Vector3 lp, Vector3 rp, bool leftSide);
    public static void OOQQOOOQOO(List`1& centerPoints, List`1<Vector3> leftRoundingPoints, List`1<Vector3> leftPointsIndents, List`1<Vector3> rightRoundingPoints, List`1<Vector3> rightPointsIndents, Vector3 cp);
    public static void OOCCDOCDDC(List`1& centerPoints, List`1<Vector3> leftRoundingPoints, List`1<Vector3> leftPointsIndents, List`1<Vector3> rightRoundingPoints, List`1<Vector3> rightPointsIndents);
    public static void MatchInnerOCOCQCDDCD(List`1& innerArray, List`1<Vector3> startVecs, List`1<Vector3> endVecs);
    public static void ODDCCDQDCO(List`1& targetArray, List`1<Vector3> otherArray);
    public static void ERODOCDOOCCC(List`1<List`1<Vector3>> roadVecs, List`1<float> shapeUVs, List`1& uvs, List`1<Vector3> priorityPointsMain, List`1& priorityPointsMainUVs, Vector2 cp, float uvRatio, ERConnectionSibling sibling, bool primarySection);
    public static void OCQODCQDOD(List`1<Vector3> leftRoundingPoints, List`1<Vector3> leftPointsIndents, List`1<Vector3> centerPoints, List`1<Vector3> rightPointsIndents, List`1<Vector3> rightRoundingPoints, List`1& leftRoundingPointsUV, List`1& leftPointsIndentsUV, List`1& centerPointsUV, List`1& rightPointsIndentsUV, List`1& rightRoundingPointsUV, Vector2& cp, float leftIndentUVX, float rightIndentUVX);
    public static void OCOQCCQCCC(List`1<Vector3> leftRoundingPoints, List`1<Vector3> rightRoundingPoints, List`1& leftRoundingPointsUV, List`1& rightRoundingPointsUV);
    public static void OOCDCQQQCD(List`1& leftRoundingPoints, List`1& rightRoundingPoints, List`1& centerPoints, Vector3& cpLeft, Vector3& cpRight, List`1<Vector3> priorityRoad, float cornerRadius, float cornerSegments, Vector3 lStart, Vector3 lEnd, Vector3 rStart, Vector3 rEnd, float leftIndent, float leftIndentUVX, float rightIndent, float rightIndentUVX);
    public static void OOOQCOOQDD(List`1<Vector3> outerPoints, Vector3 pos, Single& uvX, float indentUVX, float indentdist, int leftright);
    public static void OCOCCCCDOO(List`1& indentPoints, List`1<Vector3> outerPoints, List`1<Vector3> priorityConnectionPoints, int leftright);
    public static void OQDQCQCDQQ(List`1& centerPoints, List`1<Vector3> priorityConnectionPoints);
    public static void ODDDOCDCQO(List`1<ERConnectionSibling> priorityRoads, List`1<ERConnectionSibling> primaryRoads);
    public static void OQOQDQDOOO(Transform tr, ERConnectionSibling sibling, int index);
    public static void ODODQCDCOD(List`1& tris, List`1& vecs, List`1& uvs, List`1<List`1<Vector3>> vecsData, List`1<List`1<Vector2>> uvsData, List`1<Vector3> priorityPointsMain, List`1<Vector2> priorityPointsMainUVs, List`1& colors, List`1<bool> originalShapeVecs, List`1& connInts, int totalVecs, List`1& secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling);
    public static void ODDCQODOCD(List`1& tris, List`1& vecs, List`1& uvs, List`1<List`1<Vector3>> vecsData, List`1<List`1<Vector2>> uvsData, List`1<Vector3> priorityPointsMain, List`1<Vector2> priorityPointsMainUVs, List`1& colors, List`1<bool> originalShapeVecs, List`1& connInts, int totalVecs, List`1& secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling);
    private static void OQCDQQOCOC(int curLeft, int endLeft, int curRight, int endRight, List`1<Vector3> vecs, List`1& tris, ERConnectionSibling sibling);
    private static void OOOQCQDCDD(int curLeft, int endLeft, int curRight, int endRight, List`1<int> rightInts, List`1<Vector3> vecs, List`1& tris, ERConnectionSibling sibling);
    public static void OCDOQDDCQC(List`1& tris, List`1& vecs, List`1& uvs, List`1<List`1<Vector3>> vecsData, List`1<List`1<Vector2>> uvsData, List`1<Vector3> priorityPointsMain, List`1<Vector2> priorityPointsMainUVs, List`1& colors, List`1<bool> originalShapeVecs, List`1& connInts, int totalVecs, List`1& secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling);
    public static void OOCCQCDDDQ(List`1& tris, List`1& vecs, List`1& uvs, List`1<List`1<Vector3>> vecsData, List`1<List`1<Vector2>> uvsData, List`1<Vector3> priorityPointsMain, List`1<Vector2> priorityPointsMainUVs, List`1& colors, List`1<bool> originalShapeVecs, List`1& connInts, int totalVecs, List`1& secondPriorityInts, bool singleSectionFlag, ERConnectionSibling sibling);
    public static void OQCQQDDDCQ(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1<Vector3> mleftPoints, List`1<Vector3> rightPoints, List`1<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List`1<Vector2> leftRoundingPointsUV, List`1<Vector2> rightRoundingPointsUV, List`1<Vector2> centerPointsUV, Vector2 cpUV, List`1<Vector3> leftPointsIndents, List`1<Vector2> leftPointsIndentsUV, List`1<Vector3> rightPointsIndents, List`1<Vector2> rightPointsIndentsUV);
    public static void OCDCQDDDCC(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1<Vector3> mleftPoints, List`1<Vector3> rightPoints, List`1<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List`1<Vector2> leftRoundingPointsUV, List`1<Vector2> rightRoundingPointsUV, List`1<Vector2> centerPointsUV, Vector2 cpUV, List`1<Vector3> leftPointsIndents, List`1<Vector2> leftPointsIndentsUV, List`1<Vector3> rightPointsIndents, List`1<Vector2> rightPointsIndentsUV);
    public static void ForkPriorityOCODCOCODQ(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1<Vector3> mleftPoints, List`1<Vector3> rightPoints, List`1<Vector3> centerPoints, Vector3 leftPoint, Vector3 rightPoint, List`1<Vector2> leftRoundingPointsUV, List`1<Vector2> rightRoundingPointsUV, List`1<Vector2> centerPointsUV, Vector2 cpUV, List`1<Vector3> leftPointsIndents, List`1<Vector2> leftPointsIndentsUV, List`1<Vector3> rightPointsIndents, List`1<Vector2> rightPointsIndentsUV, List`1<Vector3> mainPoints, List`1<Vector2> mainPointsUV);
    private void OCOQOCDCCQ(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs);
    private static void MergeMeshDataExt(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs, Material mat, List`1& mats);
    private void OCQODCOQDO(List`1& tris, List`1& vecs, List`1& uvs, List`1& uvs1, List`1& uvs2, List`1& colors, List`1& trisTmp, List`1& vecsTmp, List`1& uvsTmp, List`1& uvsTmp1, List`1& uvsTmp2, List`1& colorsTmp, bool skipMiddles, bool weldVecs);
    public static List`1<int> Triangulate(List`1<Vector3> vecs, List`1<Vector3> edges);
    public static void OCQDDOQCOQ(QDOODOQQDQODD connection, ERConnectionSibling sibling, int index, int total);
    public static void OOCQCOOOOO(List`1<ERConnectionSibling> siblings, int index);
    public static bool OQQQQQQQCD(QDQDOOQQDQODD roadType);
    public static Vector3 OOQCQDQCOO(int index, Vector3 p0, Vector3 p1, Vector3 p2);
    public static void Clear();
    public static void OOODDOCOOO();
    public static void OOOQQDDCCQ(ERTexture roadERTexture, Single& roadWidth, Single& leftIndent, Single& rightIndent, Single& leftUVX, Single& rightUVX, Single& leftIndentInner, Single& rightIndentInner, Single& roadOuterUVXInner, float cornerRadius);
    public static void OQOCODDDDC(int connection, QDQDOOQQDQODD roadType);
    public static float OOCDQCOCQO(Vector3 v1, Vector3 v2, Vector3 n);
    public static Vector3 OQOQODOOCD(Vector3 dirPos1, Vector3 dirPos2, Vector3 currentPos, List`1<Vector3> vecs, int startend);
    public static Vector3 ODQQOCDCOC(Vector3 currentPos, List`1<Vector3> vecs, Int32& index, int startend);
    public static bool OQQOCCCOCD(Vector3 p1, Vector3 p2, Vector3 v);
}
public class EasyRoads3Dv3.QDOODOQQDQODD : object {
    
public Vector3 centerPoint;
    
public Vector3 tmpCenterPoint;
    
public Vector3 stageCenterPoint;
    
public Vector3 tmpStageCenterPoint;
    
public List`1<ERBlendVecs> blendData;
    
public Vector3 controlPointV3;
    
public Vector2 controlPoint;
    
public float blendDistance;
    
public float extendBounds;
    
public List`1<Vector3> blendCornerPoints;
    
public List`1<int> blendCornerPointInts;
    
public List`1<float> blendCornerPointWeights;
    
public List`1<Vector3> blendCornerPointsTransformed;
    
public float blendRatio;
    
public float curveStrength;
    
public List`1<Vector2> roadShapeVecs;
    
public string roadShapeVecsString;
    
public int roadShapeMatchCount;
    
public List`1<float> roadShapeUVY;
    
public List`1<float> roadShapeUVY2;
    
public List`1<bool> hardEdge;
    
public List`1<int> roadShapeMaterialInts;
    
public List`1<Vector2> sidewalkLeftVecs;
    
public List`1<float> sidewalkLeftUVY;
    
public List`1<int> sidewalkLeftMaterialInts;
    
public List`1<Vector2> sidewalkRightVecs;
    
public List`1<float> sidewalkRightUVY;
    
public List`1<int> sidewalkRightMaterialInts;
    
public List`1<ERConnectionVecs> connectionVecs;
    
public List`1<int> connectionVecInts;
    
public List`1<int> fullConnectionVecInts;
    
public List`1<int> sidewalkLeftConnectionVecInts;
    
public List`1<int> sidewalkRightConnectionVecInts;
    
public List`1<bool> doConnectionTri;
    
public List`1<int> outerVecInts;
    
public bool rotationPriority;
    
public float centerPointAngle;
    
public ERModularRoad connectedRoad;
    
public int connectedMarker;
    
public GameObject connectedRoadGO;
    
public bool includeLeftSidewalk;
    
public bool includeRightSidewalk;
    
public Material roadMaterial;
    
public Material[] roadMaterials;
    
public float centerPointPercentage;
    
private float ᙃ;
    
public int leftIndent;
    
public int rightIndent;
    
public int leftSurrounding;
    
public int rightSurrounding;
    
public Vector3 leftIndentV3;
    
public Vector3 leftSurroundingV3;
    
public Vector3 rightIndentV3;
    
public Vector3 rightSurroundingV3;
    
public Vector3 leftRoadpoint;
    
public Vector3 rightRoadpoint;
    
public int leftCornerInt;
    
public int rightCornerInt;
    
public int leftIndentInt;
    
public int rightIndentInt;
    
public int leftInt;
    
public int rightInt;
    
public int leftIntFull;
    
public int rightIntFull;
    
public Vector3 alignmentHandleVec;
    
public float additionalIndentDistance;
    
public float connectionAngle;
    
public Vector3 alignmentHandleVecRotationGizmo;
    
public bool inwards;
    
public double roadType;
    
public double roadTypeTimestamp;
}
public class EasyRoads3Dv3.QDOQDSQOOQDDD : object {
    
public int crossingElementLeftIndex;
    
public int crossingElementRightIndex;
    
public Vector3 centerHandleV3;
    
public Vector3 centerHandleV3_2;
    
public Vector3 leftHandleV3;
    
public Vector3 rightHandleV3;
    
public bool renderFlag;
    
public bool leftConnectionHandle;
    
public bool rightConnectionHandle;
    
public float sidewalkWidth1;
    
public float sidewalkWidth2;
    
public float curbHeight;
    
public float curbDepth;
    
public bool beveledCurb;
    
public float beveledHeight;
    
public float beveledDepth;
    
public bool outerCurb;
    
public bool roadSideCurbUVControl;
    
public bool outerSideCurbUVControl;
    
public Material sidewalkMaterial;
    
public List`1<float> sidewalkUVs;
    
public List`1<float> curbUVs;
    
public bool lockUVs;
    
public float cornerRadius;
    
public int cornerSegments;
    
public float innerSegmentDistance;
    
public float startAngle;
    public QDOQDSQOOQDDD(ERModularBase scr);
    public void CopyFromSidewalk(ERSideWalk sw);
    public static bool ERSidewalkMatch(QDOQDSQOOQDDD sw1, QDOQDSQOOQDDD sw2);
}
public class EasyRoads3Dv3.QDQDOOQQDQODD : object {
    
public string roadTypeName;
    
public double id;
    
public double timestamp;
    
public float roadWidth;
    
public float faceDistance;
    
public float angleTreshold;
    
public float uvTiling;
    
public int uv4Type;
    
public ERRoadWayType type;
    
public float detailDistance;
    
public bool planarUVs;
    
public float outerIndent;
    
public bool roadShapeDataActive;
    
public ERRoadShape roadShapeData;
    
public float minSpeed;
    
public float maxSpeed;
    
public float speedLimit;
    
public List`1<Vector2> roadShape;
    
public List`1<Vector2> roadShapeExt;
    
public List`1<Vector2> roadShapeExt2;
    
public List`1<bool> doConnectionTri;
    
public List`1<bool> doConnectionTriExt;
    
public List`1<float> roadShapeUVs;
    
public List`1<float> roadShapeExtUVs;
    
public List`1<float> roadShapeExtUVs2;
    
public List`1<float> roadShapeUVs2;
    
public bool preserveUVs;
    
public List`1<bool> hardEdge;
    
public string roadShapeVecsString;
    
public double defaultSidewalk;
    
public bool sidewalks;
    
public float sidewalkHeight;
    
public float sidewalkWidth;
    
public Material roadMaterial;
    
public Material[] roadMaterials;
    
public PhysicMaterial roadPhysicsMaterial;
    
public PhysicMaterial[] roadPhysicsMaterials;
    
public Material connectionMaterial;
    
public bool isSideObject;
    
public bool isCustomRoad;
    
public int subSegments;
    
public List`1<ERSORoad> soData;
    
public List`1<ERSORoadExt> soDataExt;
    
public List`1<ERSORoadLog> soDataLog;
    
public int layer;
    
public bool isStatic;
    
public string tag;
    
public bool splatMapActive;
    
public int splatIndex;
    
public int expandLevel;
    
public int smoothLevel;
    
public float splatOpacity;
    
public bool followTerrainContours;
    
public float terrainContoursOffset;
    
public bool terrainDeformation;
    
public float defaultIndent;
    
public float defaultSurrounding;
    
public bool castShadow;
    
public bool randomnessFlag;
    
public float randomYPosition;
    
public float randomMinYPosition;
    
public float randomMaxYPosition;
    
public float minRandomYPositionDistance;
    
public float maxRandomYPositionDistance;
    
public float randomMinRotation;
    
public float randomMaxRotation;
    
public float minRandomRotationDistance;
    
public float maxRandomRotationDistance;
    
public bool vegetationStudioMaskLineActive;
    
public float vegetationStudioGrassPerimeter;
    
public float vegetationStudioPlantPerimeter;
    
public float vegetationStudioTreePerimeter;
    
public float vegetationStudioObjectPerimeter;
    
public float vegetationStudioLargeObjectPerimeter;
    
public bool vegetationStudioBiomeMaskActive;
    
public float vegetationStudioBiomeMaskDistance;
    
public float vegetationStudioBiomeMaskBlendDistance;
    
public float vegetationStudioBiomeMaskNoiseScale;
    
public List`1<ERDecal> decalPresets;
    
public List`1<ERDecalClass> decalClassPresets;
    
public double defaultRamp;
    
public int extrusionType;
    
public float extrusionDistance;
    
public float fixedDistance;
    
public float connectionAngle;
    
public float connectionRadius;
    
public int isRoadShape;
    
public int controlType;
    public QDQDOOQQDQODD(int count);
    public void RoadTypeUpgrade();
    public int GetTagIndex(String[] tags);
    public static int GetTagIndex(String[] tags, string tag);
    public void OQQOCCODOD();
    public void UpdateTimestamp();
    public static bool ODQDDOCDDC(ERModularBase scr);
    public static String[] RoadNames(List`1<QDQDOOQQDQODD> roadTypes);
    public static String[] Nodes(ERRoadShape data);
    public static String[] LaneNodes(ERRoadShape data);
    public static GUIContent[] LaneNodesContents(ERRoadShape data);
    public void ODQQQODOQD();
    public static int SetRoadType(List`1<QDQDOOQQDQODD> roadTypes, double roadType);
    public void UpdateUVs();
    public static QDQDOOQQDQODD GetRoadTypeElByID(List`1<QDQDOOQQDQODD> roadTypes, double id);
    public static int ODDQDCOODD(List`1<QDQDOOQQDQODD> roadTypes, double id, String[]& ramps, QDQDOOQQDQODD[]& rampTypes);
    public static int GetRoadTypeByID(List`1<QDQDOOQQDQODD> roadTypes, double id);
    public static bool OOQDCODDCO(List`1<QDQDOOQQDQODD> roadTypes, double id, QDQDOOQQDQODD& motorwayLink);
    public static String[] ODODCOQODO(List`1<QDQDOOQQDQODD> roadTypes);
    public static bool GetTerrainDeformationByID(List`1<QDQDOOQQDQODD> roadTypes, double id, Int32& element);
    public static void UpdateUVTiling(List`1<QDQDOOQQDQODD> roadTypes, double id, float tiling);
    public static void UpdateResolution(List`1<QDQDOOQQDQODD> roadTypes, double id, Single& resolution, Single& threshold);
    public void OCDOCDQQQO(QDQDOOQQDQODD sourcePreset, List`1<SideObject> sceneSideObjects, List`1<SideObjectLog> projectSideObjects, bool copyShapeData);
    public static void OOOCDCQQCO(QDQDOOQQDQODD sourcePreset, ERModularRoad road, bool update, int customShapeHandling, bool checkRoadWidth);
    public static void AssignSideObjects(ERModularBase scr, int roadTypeInt, ERModularRoad OCCQOOOQQO);
    public static void HasActiveSideObjects(List`1<ERSORoadExt> sos1, List`1<ERSORoadExt> sos2, Boolean& flag1, Boolean& flag2);
    public int OOOOCQCDDC(int index, ERLaneDirection direction);
    public static bool ODCDDDQCQQ(QDQDOOQQDQODD rt1, QDQDOOQQDQODD rt2);
}
[AddComponentMenu("")]
public class EasyRoads3Dv3.QDQDOOQQOOQDD : MonoBehaviour {
    
private List`1<Vector3> ᙃ;
    
private Single[0...,0...] ᙄ;
    
private Single[] ᙅ;
    
private TerrainData 4AAAA;
    
public static float minx;
    
public static float minz;
    
public static float maxx;
    
public static float maxz;
    
public static Vector2 splatMapScale;
    
public static List`1<GameObject> surfaceObjects;
    
public static List`1<GameObject> tunnelObjects;
    
public static int crossingSurfacesStart;
    
public static int sideObjectSurfacesStart;
    
public static List`1<GameObject> treeObjects;
    
public static List`1<GameObject> detailObjects;
    private static QDQDOOQQOOQDD();
    public static void ODDCCODOOC(ERModularBase scr, Terrain terrain);
    public static void ODCQDDOQCD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float m_minx, float m_maxx, float m_minz, float m_maxz);
    public static void OOCQDQCDOD(int triangleIndex, Collider collider, Vector3 hitPos, Single& perc, Boolean& critical, Single& outerHeight, Vector3& outerPoint, RaycastHit hit);
    public static void GetHitPointInfoOld(int triangleIndex, Collider collider, Vector3 hitPos, Single& perc, Boolean& critical, Single& outerHeight, Vector3& outerPoint);
    public static void OQOQCCCODC(ERModularBase scr, Single& minx, Single& minz, Single& maxx, Single& maxz, float splatmapScale);
    public static void ODQODCQQCQ(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz);
    public static void OOCDDQCCDD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz);
    public static void OOCDDOOCQC(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz);
    public static void OCCDDODDDD(Boolean[0...,0...]& holes, Single[0...,0...] heights, float height, List`1& terrainScrHoles, Vector3 lp, Vector3 rp, Vector3 terrainPos, float stepx, float stepy, float tHeight, float size);
    public static bool ODQODDQCCD(Single[0...,0...] heights, float height, int x, int y, float rHeight, float tHeight, float size, float terrainY);
    public static void ODQCOCOQQD(ERModularBase scr, ERTerrain terrainScr, Terrain terrain, float minx, float maxx, float minz, float maxz);
    public static Single[0...,0...,0...] OCCODCQOCO(List`1<ERSplatmap> mapData, Single[0...,0...,0...] trmap, int layers);
    public static void ODODDDDCOQ(ERModularBase scr, ERTerrain terrainScr, Terrain terrain);
    public static void OQQOQOQQQC(ERTerrain terrainScr, Terrain terrain);
    public static void ODCOOQCCCD(ERTerrain terrainScr, Terrain terrain);
    public static void OOQDOQDCOO(TerrainData terrainInfo, int layer, List`1<tPoint> points);
    public static List`1<tPoint> OQODQCQCCQ(ERModularBase scr, Terrain terrain, TerrainData terrainInfo, float minx, float maxx, float minz, float maxz);
    public static void OQCQDDOOCQ(ERTerrain tr, Terrain terrain);
    public static void OOODOOOQCC(ERTerrain tr, Terrain terrain, float perc);
    public static void OOOCCDQODO(GameObject go, int x, int y, List`1& instances, Single[0...,0...,0...] trmap, int layers, Vector2 uvy);
    public static void OOQQQQDCCO(ERModularBase baseScript, ERModularRoad scr);
    public static GameObject CreateMesh(Transform parent, List`1<Vector3> vecs, List`1<int> tris, int layer, ERModularRoad scr, string name);
    public static void OCCQODOQDD(ERTerrain terrain, string folder);
    public static void OQCOQDDCCC(ERTerrain terrain, string folder);
    public static void OOQQOOOQOO(ERTerrain terrain, string folder);
    public static void ODCOQQQCCO(ERTerrain terrain, string folder);
    public static void OCCOODODOQ(ERTerrain terrain, string folder);
    public static void OCCDQQCODQ(ERTerrain terrain, string folder);
    public static void OOOOCQCDQQ(ERTerrain terrain, string folder);
    public static void OOQOCCCCDD(ERTerrain terrain, string folder);
}
public class EasyRoads3Dv3.SelectedObject : ScriptableObject {
    
public ERModularRoad roadScr;
    
public ERCrossingPrefabs prefabScr;
    
public List`1<int> markers;
    
public int startEnd;
    
public ERCrossingPrefabs prefab;
    public void Init(ERModularRoad rScr, ERCrossingPrefabs pScr, int marker);
    public static SelectedObject CreateInstance(ERModularRoad rScr, ERCrossingPrefabs pScr, int marker);
}
public class EasyRoads3Dv3.SideObject : ScriptableObject {
    
public string version;
    
public string name;
    
public double id;
    
public double timestamp;
    
public int objectType;
    
public string gameobjectGUID;
    
public string textureGUID;
    
public float m_distance;
    
public float uvx;
    
public float uvy;
    
public int position;
    
public float splinePosition;
    
public int selectedRotation;
    
public float randomYAxisMinRotation;
    
public float randomYAxisMaxRotation;
    
public List`1<Vector2> nodeList;
    
public List`1<float> uvs;
    
public List`1<float> uvDistances;
    
public bool clampUVs;
    
public bool clampUVY;
    
public float clampUVYValue;
    
public float totalDistance;
    
public bool reverseUVs;
    
public bool terrainUVs;
    
public List`1<bool> snapList;
    
public List`1<float> snapWeightList;
    
public List`1<Color> colorList;
    
public string gameobjectStartGUID;
    
public string gameobjectEndGUID;
    
public int align;
    
public int alignPoint;
    
public bool weld;
    
public bool combine;
    
public bool combineInstantiated;
    
public bool markerActive;
    
public int uvType;
    
public float uv;
    
public bool randomObjects;
    
public float forwardStartOffset;
    
public float sidewaysOffset;
    
public float density;
    
public string goPath;
    
public string startPath;
    
public string endPath;
    
public string texturePath;
    
public int terrainTree;
    
public float minScale;
    
public float maxScale;
    
public bool childOrderActive;
    
public int childOrder;
    
public bool meshBoundsAlignment;
    
public float xPosition;
    
public float xPosition2;
    
public int relativeTo;
    
public float yPosition;
    
public float yRotation;
    
public float oldSidwaysDistance;
    
public int sidewaysDistanceUpdate;
    
public float uvYRound;
    
public bool adjustUV;
    
public bool collider;
    
public bool boxcollider;
    
public bool tangents;
    
public GameObject sourceObject;
    
public bool flipMesh;
    
public GameObject startObject;
    
public GameObject endObject;
    
public GameObject connectionObject;
    
public Material material;
    
public List`1<ERMesh> meshObjects;
    
public Vector2 boxSize;
    
public Vector2 boxOffset;
    
public bool includeStartSegment;
    
public float startSegmentOffset;
    
public bool includeStartEdgeTris;
    
public bool includeEndSegment;
    
public float endSegmentOffset;
    
public bool includeEndEdgeTris;
    
public bool adjustToRoadWidth;
    
public float xOffset;
    
public float startOffset;
    
public float endOffset;
    
public float defaultStartOffset;
    
public float defaultEndOffset;
    
public float totalZDistance;
    
public float middleZDistance;
    
public float startZDistance;
    
public float endZDistance;
    
public float minStartZ;
    
public float maxStartZ;
    
public float minMiddleZ;
    
public float maxMiddleZ;
    
public float minEndZ;
    
public float maxEndZ;
    
public bool smoothStart;
    
public bool smoothMiddle;
    
public bool smoothEnd;
    
public GameObject targetObject;
    
public bool bridgeObject;
    
public bool tunnelObject;
    
public bool snapToTerrain;
    
public int layer;
    
public bool deformationObject;
    
public bool isStatic;
    
public bool castShadows;
    
public bool scaleToRoad;
    
public bool splitInBatches;
    
public List`1<GameObject> instantiatedObjects;
    
public int maxVertices;
    
public bool doTestmesh;
    
public Vector3 testMeshPos;
    
public Vector3 randomRotation;
    
public float randomMinRotation;
    
public float randomMaxRotation;
    
public float minRandomRotationDistance;
    
public float maxRandomRotationDistance;
    
public float randomXPosition;
    
public float randomMinXPosition;
    
public float randomMaxXPosition;
    
public float minRandomXPositionDistance;
    
public float maxRandomXPositionDistance;
    
public Vector3 boxColliderScale;
    
public float randomYPosition;
    
public float randomMinYPosition;
    
public float randomMaxYPosition;
    
public float minRandomYPositionDistance;
    
public float maxRandomYPositionDistance;
    
public bool indentController;
    
public bool excludeTerrainSplats;
    
public float x1;
    
public float x2;
    
public float xf1;
    
public float xf2;
    
public float y1;
    
public float bridgeHeight;
    
public int markerSplineController;
    
public float bridgeLength;
    
public float deformationOffset;
    
public float markerIndent;
    
public float markerSurrounding;
    
public Vector3 scale;
    
public float indentExt;
    
public int category;
    
public Texture2D densityMap;
    
public float densitySize;
    
public float densitySize2;
    
public float densityStrength;
    
public float densityStrength2;
    
public float terrainNormal;
    
public float terrainNormal2;
    
public List`1<ERChildsSO> childObjects;
    
public bool autoGenerate;
    
public float heightThreshold;
    
public float autogenerateStartOffset;
    
public float autogenerateEndOffset;
    
public bool snapIndents;
    
public float snapIndentWidth;
    
public bool cutHoles;
    
public float innerStartOffset;
    
public float innerEndOffset;
    
public bool ignoredForRetainingWalls;
    
public float heightMaxThreshold;
    
public float heightMaxStartThreshold;
    
public float heightMaxEndThreshold;
    
public float xThresholdDistance;
    
public float angleThreshold;
    
public int connectionRatio;
    
public bool retainingWall;
    
public int surroundingControl;
    
public int indentControl;
    
public List`1<Vector2> nodeListMirrored;
    
public List`1<float> uvsMirrored;
    
public List`1<float> snapWeightListMirrored;
    
public List`1<Color> colorListMirrored;
    
public bool hasVertexColors;
    
public float deformationOffsetForward;
    
public float deformationOffsetSideways;
    
public int connectionObjectRotation;
    
public bool subMesh;
    
public bool acceptBarriers;
    
public bool activeOnBridges;
    
public bool dualSided;
    
public int mirrorType;
    
public bool snapVertexColors;
    
public float minSnapRange;
    
public float maxSnapRange;
    
public bool clampUV4;
    
public float geoStartOffset;
    
public float geoEndOffset;
    
public float startOverlapOffset;
    
public float endOverlapOffset;
    
public int lodLevels;
    
public List`1<bool> hardEdge;
    
public float hardEdgePadding;
    
public bool startEndCaps;
    
public List`1<Vector2> endCapUVs;
    
public List`1<Vector2> startCapUVs;
    
public List`1<int> startCapTris;
    
public List`1<int> startCapTrisMirrored;
    
public Vector2 startCapUVOffset;
    
public Vector2 endCapUVOffset;
    
public float startCapUVScale;
    
public float endCapUVScale;
    
public float startCapUVRotation;
    
public float endCapUVRotation;
    
public bool namedChilds;
    
public bool startSection;
    
public bool endSection;
    
public bool stepDown;
    
public bool stepUp;
    
public float stepDistance;
    
public float startDirZOffset;
    
public float endDirZOffset;
    
public bool buildOtherSideObject1;
    
public double defaultOtherSoId1;
    
public bool buildOtherSideObject2;
    
public double defaultOtherSoId2;
    
public List`1<double> buildOtherSideObjects;
    
public bool averageDistance;
    
public bool randomUVx;
    
public bool isUsedAsChild;
    public void SetSideObject(int count, int scategory);
    public void UpdateTimeStamp();
    public void OOCCDCDOQC();
    public void OQOQOQOODC();
    public void SetMaxVertices();
    public static bool CheckSOChildActive(List`1<ERSOSection> sections, SideObject so);
    public void OOOCDOQOOC(bool updateTimeStamp);
    public void OQDODCOODC();
    public void OQDDDDOOQD(Vector3 m_testMeshPos, bool updateTimeStamp);
    private void OQOODQQQQC(List`1<Vector3> vecs, float startDistance, List`1<Vector3> vecs1, float endDistance, List`1& startArray, List`1& endArray, int section);
    private float OQQDDOCDDQ(List`1<GameObject> goObjects, bool rotate180);
    private bool HasMissingData(ERMesh meshData, ERMesh meshData2, int ignore);
    public void OODOOOQQCO(SideObject so);
    public void OCDOCDQQQO(SideObjectLog so);
    public void Clear();
}
public class EasyRoads3Dv3.SideObjectLog : object {
    
public string version;
    
public string name;
    
public double id;
    
public double timestamp;
    
public int objectType;
    
public string gameobjectGUID;
    
public string textureGUID;
    
public float m_distance;
    
public float uvx;
    
public float uvy;
    
public int position;
    
public float splinePosition;
    
public int selectedRotation;
    
public float randomYAxisMinRotation;
    
public float randomYAxisMaxRotation;
    
public List`1<Vector2> nodeList;
    
public List`1<float> uvs;
    
public List`1<float> uvDistances;
    
public bool clampUVs;
    
public bool clampUVY;
    
public float clampUVYValue;
    
public bool terrainUVs;
    
public bool reverseUVs;
    
public float totalDistance;
    
public List`1<bool> snapList;
    
public List`1<float> snapWeightList;
    
public List`1<Color> colorList;
    
public string gameobjectStartGUID;
    
public string gameobjectEndGUID;
    
public int align;
    
public int alignPoint;
    
public bool weld;
    
public bool combine;
    
public bool combineInstantiated;
    
public bool markerActive;
    
public int uvType;
    
public float uv;
    
public bool randomObjects;
    
public float forwardStartOffset;
    
public float sidewaysOffset;
    
public float density;
    
public string goPath;
    
public string startPath;
    
public string endPath;
    
public string texturePath;
    
public int terrainTree;
    
public float minScale;
    
public float maxScale;
    
public bool childOrderActive;
    
public int childOrder;
    
public bool meshBoundsAlignment;
    
public float xPosition;
    
public float xPosition2;
    
public int relativeTo;
    
public float yPosition;
    
public float yRotation;
    
public float oldSidwaysDistance;
    
public int sidewaysDistanceUpdate;
    
public float uvYRound;
    
public bool adjustUV;
    
public bool collider;
    
public bool boxcollider;
    
public bool tangents;
    
public GameObject sourceObject;
    
public bool flipMesh;
    
public GameObject startObject;
    
public GameObject endObject;
    
public GameObject connectionObject;
    
public Material material;
    
public List`1<ERMesh> meshObjects;
    
public Vector2 boxSize;
    
public Vector2 boxOffset;
    
public bool includeStartSegment;
    
public float startSegmentOffset;
    
public bool includeStartEdgeTris;
    
public bool includeEndSegment;
    
public float endSegmentOffset;
    
public bool includeEndEdgeTris;
    
public bool adjustToRoadWidth;
    
public float xOffset;
    
public float startOffset;
    
public float endOffset;
    
public float defaultStartOffset;
    
public float defaultEndOffset;
    
public float totalZDistance;
    
public float middleZDistance;
    
public float startZDistance;
    
public float endZDistance;
    
public float minStartZ;
    
public float maxStartZ;
    
public float minMiddleZ;
    
public float maxMiddleZ;
    
public float minEndZ;
    
public float maxEndZ;
    
public bool smoothStart;
    
public bool smoothMiddle;
    
public bool smoothEnd;
    
public GameObject targetObject;
    
public bool bridgeObject;
    
public bool tunnelObject;
    
public bool snapToTerrain;
    
public int layer;
    
public bool deformationObject;
    
public bool isStatic;
    
public bool castShadows;
    
public bool scaleToRoad;
    
public bool splitInBatches;
    
public Vector3 randomRotation;
    
public float randomMinRotation;
    
public float randomMaxRotation;
    
public float minRandomRotationDistance;
    
public float maxRandomRotationDistance;
    
public float randomXPosition;
    
public float randomMinXPosition;
    
public float randomMaxXPosition;
    
public float minRandomXPositionDistance;
    
public float maxRandomXPositionDistance;
    
public Vector3 boxColliderScale;
    
public float randomYPosition;
    
public float randomMinYPosition;
    
public float randomMaxYPosition;
    
public float minRandomYPositionDistance;
    
public float maxRandomYPositionDistance;
    
public float bridgeHeight;
    
public int markerSplineController;
    
public float bridgeLength;
    
public float deformationOffset;
    
public float markerIndent;
    
public float markerSurrounding;
    
public bool indentController;
    
public bool excludeTerrainSplats;
    
public Vector3 scale;
    
public float indentExt;
    
public int category;
    
public Texture2D densityMap;
    
public float densitySize;
    
public float densitySize2;
    
public float densityStrength;
    
public float densityStrength2;
    
public float terrainNormal;
    
public float terrainNormal2;
    
public List`1<ERChildsSO> childObjects;
    
public bool autoGenerate;
    
public float heightThreshold;
    
public float autogenerateStartOffset;
    
public float autogenerateEndOffset;
    
public bool snapIndents;
    
public float snapIndentWidth;
    
public bool cutHoles;
    
public float innerStartOffset;
    
public float innerEndOffset;
    
public bool ignoredForRetainingWalls;
    
public float heightMaxThreshold;
    
public float heightMaxStartThreshold;
    
public float heightMaxEndThreshold;
    
public float xThresholdDistance;
    
public float angleThreshold;
    
public int connectionRatio;
    
public bool retainingWall;
    
public int surroundingControl;
    
public int indentControl;
    
public List`1<Vector2> nodeListMirrored;
    
public List`1<float> uvsMirrored;
    
public List`1<float> snapWeightListMirrored;
    
public List`1<Color> colorListMirrored;
    
public bool hasVertexColors;
    
public float deformationOffsetForward;
    
public float deformationOffsetSideways;
    
public int connectionObjectRotation;
    
public bool subMesh;
    
public bool acceptBarriers;
    
public bool activeOnBridges;
    
public bool dualSided;
    
public int mirrorType;
    
public bool snapVertexColors;
    
public float minSnapRange;
    
public float maxSnapRange;
    
public bool clampUV4;
    
public float geoStartOffset;
    
public float geoEndOffset;
    
public float startOverlapOffset;
    
public float endOverlapOffset;
    
public int lodLevels;
    
public List`1<bool> hardEdge;
    
public float hardEdgePadding;
    
public bool startEndCaps;
    
public List`1<Vector2> endCapUVs;
    
public List`1<Vector2> startCapUVs;
    
public List`1<int> startCapTris;
    
public List`1<int> startCapTrisMirrored;
    
public Vector2 startCapUVOffset;
    
public Vector2 endCapUVOffset;
    
public float startCapUVScale;
    
public float endCapUVScale;
    
public float startCapUVRotation;
    
public float endCapUVRotation;
    
public bool namedChilds;
    
public bool startSection;
    
public bool endSection;
    
public bool stepDown;
    
public bool stepUp;
    
public float stepDistance;
    
public float startDirZOffset;
    
public float endDirZOffset;
    
public bool buildOtherSideObject1;
    
public double defaultOtherSoId1;
    
public bool buildOtherSideObject2;
    
public double defaultOtherSoId2;
    
public List`1<double> buildOtherSideObjects;
    
public bool averageDistance;
    
public bool randomUVx;
    
public bool isUsedAsChild;
    public void OODOOOQQCO(SideObject so);
}
public class EasyRoads3Dv3.SideObjectParams : object {
    
public Boolean[] soActive;
    
public Single[] soDistanceSideWays;
    
public Boolean[] soSplineActive;
}
public class EasyRoads3Dv3.SidewalkPresetClass : object {
    
public string presetName;
    
public double id;
    
public double timestamp;
    
public float sidewalkWidth1;
    
public float sidewalkWidth2;
    
public float curbHeight;
    
public float curbDepth;
    
public bool beveledCurb;
    
public float beveledHeight;
    
public float beveledDepth;
    
public bool outerCurb;
    
public bool roadSideCurbUVControl;
    
public bool outerSideCurbUVControl;
    
public Material sidewalkMaterial;
    
public List`1<Vector2> shape;
    
public List`1<float> sidewalkUVs;
    
public List`1<float> curbUVs;
    
public bool lockUVs;
    public SidewalkPresetClass(QDOQDSQOOQDDD corner, string name);
}
public class EasyRoads3Dv3.TerrainsV3 : object {
    
public Terrain terrain;
    
public string id;
}
public class EasyRoads3Dv3.tPoint : object {
    
public int x;
    
public int z;
    
public bool done;
    
public float dist;
    
public int v;
}
public class EasyRoads3Dv3.ZIndexArray : object {
    
public List`1<int> index;
}
[AddComponentMenu("")]
public class ERSurfaceScript : MonoBehaviour {
    private void Start();
}
