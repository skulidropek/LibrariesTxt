[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonArray : BsonToken {
    
private List`1<BsonToken> _children;
    
public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonBinary : BsonValue {
    [CompilerGeneratedAttribute]

private BsonBinaryType <BinaryType>k__BackingField;
    
public BsonBinaryType BinaryType { get; public set; }
    public BsonBinary(Byte[] value, BsonBinaryType binaryType);
    [CompilerGeneratedAttribute]
public BsonBinaryType get_BinaryType();
    [CompilerGeneratedAttribute]
public void set_BinaryType(BsonBinaryType value);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Bson.BsonBinaryType : Enum {
    
public byte value__;
    
public static BsonBinaryType Binary;
    
public static BsonBinaryType Function;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Binary instead.")]

public static BsonBinaryType BinaryOld;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Uuid instead.")]

public static BsonBinaryType UuidOld;
    
public static BsonBinaryType Uuid;
    
public static BsonBinaryType Md5;
    
public static BsonBinaryType UserDefined;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonBinaryWriter : object {
    
private static Encoding Encoding;
    
private BinaryWriter _writer;
    
private Byte[] _largeByteBuffer;
    [CompilerGeneratedAttribute]

private DateTimeKind <DateTimeKindHandling>k__BackingField;
    
public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(BinaryWriter writer);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void Close();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    public void WriteUtf8Bytes(string s, int byteCount);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonObject : BsonToken {
    
private List`1<BsonProperty> _children;
    
public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[PreserveAttribute]
public class Newtonsoft.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]

private Byte[] <Value>k__BackingField;
    
public Byte[] Value { get; private set; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(Byte[] value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]

private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]

private BsonToken <Value>k__BackingField;
    
public BsonString Name { get; public set; }
    
public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Bson.BsonReader : JsonReader {
    
private static int MaxCharBytesSize;
    
private static Byte[] SeqRange1;
    
private static Byte[] SeqRange2;
    
private static Byte[] SeqRange3;
    
private static Byte[] SeqRange4;
    
private BinaryReader _reader;
    
private List`1<ContainerContext> _stack;
    
private Byte[] _byteBuffer;
    
private Char[] _charBuffer;
    
private BsonType _currentElementType;
    
private BsonReaderState _bsonReaderState;
    
private ContainerContext _currentContext;
    
private bool _readRootValueAsArray;
    
private bool _jsonNet35BinaryCompatibility;
    
private DateTimeKind _dateTimeKindHandling;
    [ObsoleteAttribute("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]

public bool JsonNet35BinaryCompatibility { get; public set; }
    
public bool ReadRootValueAsArray { get; public set; }
    
public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(BinaryReader reader);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_JsonNet35BinaryCompatibility();
    public void set_JsonNet35BinaryCompatibility(bool value);
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual bool Read();
    public virtual void Close();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary(BsonBinaryType& binaryType);
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]

private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]

private BsonString <Options>k__BackingField;
    
public BsonString Pattern { get; public set; }
    
public BsonString Options { get; public set; }
    
public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]

private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <IncludeLength>k__BackingField;
    
public int ByteCount { get; public set; }
    
public bool IncludeLength { get; public set; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
    [CompilerGeneratedAttribute]
public void set_IncludeLength(bool value);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]

private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]

private int <CalculatedSize>k__BackingField;
    
public BsonType Type { get; }
    
public BsonToken Parent { get; public set; }
    
public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Bson.BsonType : Enum {
    
public sbyte value__;
    
public static BsonType Number;
    
public static BsonType String;
    
public static BsonType Object;
    
public static BsonType Array;
    
public static BsonType Binary;
    
public static BsonType Undefined;
    
public static BsonType Oid;
    
public static BsonType Boolean;
    
public static BsonType Date;
    
public static BsonType Null;
    
public static BsonType Regex;
    
public static BsonType Reference;
    
public static BsonType Code;
    
public static BsonType Symbol;
    
public static BsonType CodeWScope;
    
public static BsonType Integer;
    
public static BsonType TimeStamp;
    
public static BsonType Long;
    
public static BsonType MinKey;
    
public static BsonType MaxKey;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Bson.BsonValue : BsonToken {
    
private object _value;
    
private BsonType _type;
    
public object Value { get; }
    
public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
[PreserveAttribute]
public class Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
    
private BsonBinaryWriter _writer;
    
private BsonToken _root;
    
private BsonToken _parent;
    
private string _propertyName;
    
public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public BsonWriter(BinaryWriter writer);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    public virtual void Close();
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
[PreserveAttribute]
public enum Newtonsoft.Json.ConstructorHandling : Enum {
    
public int value__;
    
public static ConstructorHandling Default;
    
public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
    
private static string BinaryTypeName;
    
private static string BinaryToArrayName;
    
private ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    private void EnsureReflectionObject(Type t);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private Byte[] ReadByteArray(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.ColorConverter : JsonConverter {
    
public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    
public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.EnumerableVectorConverter`1 : JsonConverter {
    
private static VectorConverter VectorConverter;
    
public bool CanRead { get; }
    private static EnumerableVectorConverter`1();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
}
public class Newtonsoft.Json.Converters.HashSetConverter : JsonConverter {
    
public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    
private static string DefaultDateTimeFormat;
    
private DateTimeStyles _dateTimeStyles;
    
private string _dateTimeFormat;
    
private CultureInfo _culture;
    
public DateTimeStyles DateTimeStyles { get; public set; }
    
public string DateTimeFormat { get; public set; }
    
public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    public string get_DateTimeFormat();
    public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal interface Newtonsoft.Json.Converters.IXmlDeclaration {
    
public string Version { get; }
    
public string Encoding { get; public set; }
    
public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
internal interface Newtonsoft.Json.Converters.IXmlDocument {
    
public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public abstract virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public abstract virtual IXmlElement get_DocumentElement();
}
internal interface Newtonsoft.Json.Converters.IXmlDocumentType {
    
public string Name { get; }
    
public string System { get; }
    
public string Public { get; }
    
public string InternalSubset { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_System();
    public abstract virtual string get_Public();
    public abstract virtual string get_InternalSubset();
}
internal interface Newtonsoft.Json.Converters.IXmlElement {
    
public bool IsEmpty { get; }
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
    public abstract virtual string GetPrefixOfNamespace(string namespaceUri);
    public abstract virtual bool get_IsEmpty();
}
internal interface Newtonsoft.Json.Converters.IXmlNode {
    
public XmlNodeType NodeType { get; }
    
public string LocalName { get; }
    
public List`1<IXmlNode> ChildNodes { get; }
    
public List`1<IXmlNode> Attributes { get; }
    
public IXmlNode ParentNode { get; }
    
public string Value { get; public set; }
    
public string NamespaceUri { get; }
    
public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    public abstract virtual List`1<IXmlNode> get_ChildNodes();
    public abstract virtual List`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceUri();
    public abstract virtual object get_WrappedNode();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
    
private static string KeyName;
    
private static string ValueName;
    
private static ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType;
    private static KeyValuePairConverter();
    private static ReflectionObject InitializeReflectionObject(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.Matrix4x4Converter : JsonConverter {
    
public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.QuaternionConverter : JsonConverter {
    
public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
    
private static string PatternName;
    
private static string OptionsName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadRegexString(JsonReader reader);
    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.ResolutionConverter : JsonConverter {
    
public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool get_CanRead();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
    [CompilerGeneratedAttribute]

private bool <CamelCaseText>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <AllowIntegerValues>k__BackingField;
    
public bool CamelCaseText { get; public set; }
    
public bool AllowIntegerValues { get; public set; }
    public StringEnumConverter(bool camelCaseText);
    [CompilerGeneratedAttribute]
public bool get_CamelCaseText();
    [CompilerGeneratedAttribute]
public void set_CamelCaseText(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowIntegerValues();
    [CompilerGeneratedAttribute]
public void set_AllowIntegerValues(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.UriConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.VectorConverter : JsonConverter {
    
private static Type V2;
    
private static Type V3;
    
private static Type V4;
    [CompilerGeneratedAttribute]

private bool <EnableVector2>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <EnableVector3>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <EnableVector4>k__BackingField;
    
public bool EnableVector2 { get; public set; }
    
public bool EnableVector3 { get; public set; }
    
public bool EnableVector4 { get; public set; }
    public VectorConverter(bool enableVector2, bool enableVector3, bool enableVector4);
    private static VectorConverter();
    [CompilerGeneratedAttribute]
public bool get_EnableVector2();
    [CompilerGeneratedAttribute]
public void set_EnableVector2(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableVector3();
    [CompilerGeneratedAttribute]
public void set_EnableVector3(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableVector4();
    [CompilerGeneratedAttribute]
public void set_EnableVector4(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static void WriteVector(JsonWriter writer, float x, float y, Nullable`1<float> z, Nullable`1<float> w);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private static Vector2 PopulateVector2(JsonReader reader);
    private static Vector3 PopulateVector3(JsonReader reader);
    private static Vector4 PopulateVector4(JsonReader reader);
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
    
private XAttribute Attribute { get; }
    
public string Value { get; public set; }
    
public string LocalName { get; }
    
public string NamespaceUri { get; }
    
public IXmlNode ParentNode { get; }
    public XAttributeWrapper(XAttribute attribute);
    private XAttribute get_Attribute();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual IXmlNode get_ParentNode();
}
internal class Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
    
private XComment Text { get; }
    
public string Value { get; public set; }
    
public IXmlNode ParentNode { get; }
    public XCommentWrapper(XComment text);
    private XComment get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
internal class Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
    
private List`1<IXmlNode> _childNodes;
    
private XContainer Container { get; }
    
public List`1<IXmlNode> ChildNodes { get; }
    
public IXmlNode ParentNode { get; }
    public XContainerWrapper(XContainer container);
    private XContainer get_Container();
    public virtual List`1<IXmlNode> get_ChildNodes();
    public virtual IXmlNode get_ParentNode();
    internal static IXmlNode WrapNode(XObject node);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
    [CompilerGeneratedAttribute]

private XDeclaration <Declaration>k__BackingField;
    
internal XDeclaration Declaration { get; private set; }
    
public XmlNodeType NodeType { get; }
    
public string Version { get; }
    
public string Encoding { get; public set; }
    
public string Standalone { get; public set; }
    public XDeclarationWrapper(XDeclaration declaration);
    [CompilerGeneratedAttribute]
internal XDeclaration get_Declaration();
    [CompilerGeneratedAttribute]
private void set_Declaration(XDeclaration value);
    public virtual XmlNodeType get_NodeType();
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Newtonsoft.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
    
private XDocumentType _documentType;
    
public string Name { get; }
    
public string System { get; }
    
public string Public { get; }
    
public string InternalSubset { get; }
    
public string LocalName { get; }
    public XDocumentTypeWrapper(XDocumentType documentType);
    public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
internal class Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
    
private XDocument Document { get; }
    
public List`1<IXmlNode> ChildNodes { get; }
    
public IXmlElement DocumentElement { get; }
    public XDocumentWrapper(XDocument document);
    private XDocument get_Document();
    public virtual List`1<IXmlNode> get_ChildNodes();
    public sealed virtual IXmlNode CreateComment(string text);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public sealed virtual IXmlElement get_DocumentElement();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
    
private List`1<IXmlNode> _attributes;
    
private XElement Element { get; }
    
public List`1<IXmlNode> Attributes { get; }
    
public string Value { get; public set; }
    
public string LocalName { get; }
    
public string NamespaceUri { get; }
    
public bool IsEmpty { get; }
    public XElementWrapper(XElement element);
    private XElement get_Element();
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public virtual List`1<IXmlNode> get_Attributes();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
internal class Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    
private XmlDeclaration _declaration;
    
public string Version { get; }
    
public string Encoding { get; public set; }
    
public string Standalone { get; public set; }
    public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Newtonsoft.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
    
private XmlDocumentType _documentType;
    
public string Name { get; }
    
public string System { get; }
    
public string Public { get; }
    
public string InternalSubset { get; }
    
public string LocalName { get; }
    public XmlDocumentTypeWrapper(XmlDocumentType documentType);
    public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
internal class Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    
private XmlDocument _document;
    
public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public sealed virtual IXmlElement get_DocumentElement();
}
internal class Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    
private XmlElement _element;
    
public bool IsEmpty { get; }
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
[PreserveAttribute]
public class Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
    
private static string TextName;
    
private static string CommentName;
    
private static string CDataName;
    
private static string WhitespaceName;
    
private static string SignificantWhitespaceName;
    
private static string DeclarationName;
    
private static string JsonNamespaceUri;
    [CompilerGeneratedAttribute]

private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <WriteArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <OmitRootObject>k__BackingField;
    
public string DeserializeRootElementName { get; public set; }
    
public bool WriteArrayAttribute { get; public set; }
    
public bool OmitRootObject { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteArrayAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteArrayAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitRootObject();
    [CompilerGeneratedAttribute]
public void set_OmitRootObject(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private IXmlNode WrapXml(object value);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private bool IsArray(IXmlNode node);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private static bool AllSameName(IXmlNode node);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary`2<string, string> attributeNameValues);
    private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string attributeName, XmlNamespaceManager manager, string attributePrefix);
    private string ConvertTokenToXmlValue(JsonReader reader);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private bool ValueAttributes(List`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
}
internal class Newtonsoft.Json.Converters.XmlNodeWrapper : object {
    
private XmlNode _node;
    
private List`1<IXmlNode> _childNodes;
    
private List`1<IXmlNode> _attributes;
    
public object WrappedNode { get; }
    
public XmlNodeType NodeType { get; }
    
public string LocalName { get; }
    
public List`1<IXmlNode> ChildNodes { get; }
    
public List`1<IXmlNode> Attributes { get; }
    
public IXmlNode ParentNode { get; }
    
public string Value { get; public set; }
    
public string NamespaceUri { get; }
    public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public sealed virtual List`1<IXmlNode> get_ChildNodes();
    internal static IXmlNode WrapNode(XmlNode node);
    public sealed virtual List`1<IXmlNode> get_Attributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public sealed virtual string get_NamespaceUri();
}
internal class Newtonsoft.Json.Converters.XObjectWrapper : object {
    
private static List`1<IXmlNode> EmptyChildNodes;
    
private XObject _xmlObject;
    
public object WrappedNode { get; }
    
public XmlNodeType NodeType { get; }
    
public string LocalName { get; }
    
public List`1<IXmlNode> ChildNodes { get; }
    
public List`1<IXmlNode> Attributes { get; }
    
public IXmlNode ParentNode { get; }
    
public string Value { get; public set; }
    
public string NamespaceUri { get; }
    public XObjectWrapper(XObject xmlObject);
    private static XObjectWrapper();
    public sealed virtual object get_WrappedNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual List`1<IXmlNode> get_ChildNodes();
    public virtual List`1<IXmlNode> get_Attributes();
    public virtual IXmlNode get_ParentNode();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_NamespaceUri();
}
internal class Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
    
private XProcessingInstruction ProcessingInstruction { get; }
    
public string LocalName { get; }
    
public string Value { get; public set; }
    public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction);
    private XProcessingInstruction get_ProcessingInstruction();
    public virtual string get_LocalName();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
internal class Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
    
private XText Text { get; }
    
public string Value { get; public set; }
    
public IXmlNode ParentNode { get; }
    public XTextWrapper(XText text);
    private XText get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
[PreserveAttribute]
public enum Newtonsoft.Json.DateFormatHandling : Enum {
    
public int value__;
    
public static DateFormatHandling IsoDateFormat;
    
public static DateFormatHandling MicrosoftDateFormat;
}
[PreserveAttribute]
public enum Newtonsoft.Json.DateParseHandling : Enum {
    
public int value__;
    
public static DateParseHandling None;
    
public static DateParseHandling DateTime;
    
public static DateParseHandling DateTimeOffset;
}
[PreserveAttribute]
public enum Newtonsoft.Json.DateTimeZoneHandling : Enum {
    
public int value__;
    
public static DateTimeZoneHandling Local;
    
public static DateTimeZoneHandling Utc;
    
public static DateTimeZoneHandling Unspecified;
    
public static DateTimeZoneHandling RoundtripKind;
}
[FlagsAttribute]
[PreserveAttribute]
public enum Newtonsoft.Json.DefaultValueHandling : Enum {
    
public int value__;
    
public static DefaultValueHandling Include;
    
public static DefaultValueHandling Ignore;
    
public static DefaultValueHandling Populate;
    
public static DefaultValueHandling IgnoreAndPopulate;
}
[PreserveAttribute]
public enum Newtonsoft.Json.FloatFormatHandling : Enum {
    
public int value__;
    
public static FloatFormatHandling String;
    
public static FloatFormatHandling Symbol;
    
public static FloatFormatHandling DefaultValue;
}
[PreserveAttribute]
public enum Newtonsoft.Json.FloatParseHandling : Enum {
    
public int value__;
    
public static FloatParseHandling Double;
    
public static FloatParseHandling Decimal;
}
[PreserveAttribute]
public enum Newtonsoft.Json.Formatting : Enum {
    
public int value__;
    
public static Formatting None;
    
public static Formatting Indented;
}
[PreserveAttribute]
public interface Newtonsoft.Json.IArrayPool`1 {
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array);
}
[PreserveAttribute]
public interface Newtonsoft.Json.IJsonLineInfo {
    
public int LineNumber { get; }
    
public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[AttributeUsageAttribute("1028")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
    
private bool _allowNullItems;
    
public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[AttributeUsageAttribute("32")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
[PreserveAttribute]
public abstract class Newtonsoft.Json.JsonContainerAttribute : Attribute {
    [CompilerGeneratedAttribute]

private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]

private Type <ItemConverterType>k__BackingField;
    [CompilerGeneratedAttribute]

private Object[] <ItemConverterParameters>k__BackingField;
    
internal Nullable`1<bool> _isReference;
    
internal Nullable`1<bool> _itemIsReference;
    
internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    
internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    
public string Id { get; public set; }
    
public string Title { get; public set; }
    
public string Description { get; public set; }
    
public Type ItemConverterType { get; public set; }
    
public Object[] ItemConverterParameters { get; public set; }
    
public bool IsReference { get; public set; }
    
public bool ItemIsReference { get; public set; }
    
public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    
public TypeNameHandling ItemTypeNameHandling { get; public set; }
    protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.JsonContainerType : Enum {
    
public int value__;
    
public static JsonContainerType None;
    
public static JsonContainerType Object;
    
public static JsonContainerType Array;
    
public static JsonContainerType Constructor;
}
[PreserveAttribute]
public static class Newtonsoft.Json.JsonConvert : object {
    [CompilerGeneratedAttribute]

private static Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField;
    
public static string True;
    
public static string False;
    
public static string Null;
    
public static string Undefined;
    
public static string PositiveInfinity;
    
public static string NegativeInfinity;
    
public static string NaN;
    
private static JsonSerializerSettings InitialSerializerSettings;
    
public static Func`1<JsonSerializerSettings> DefaultSettings { get; public set; }
    private static JsonConvert();
    [CompilerGeneratedAttribute]
public static Func`1<JsonSerializerSettings> get_DefaultSettings();
    [CompilerGeneratedAttribute]
public static void set_DefaultSettings(Func`1<JsonSerializerSettings> value);
    internal static JsonSerializerSettings GetDefaultSettings();
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, DateFormatHandling format);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    public static string ToString(double value);
    internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    internal static string ToString(Guid value, char quoteChar);
    public static string ToString(TimeSpan value);
    internal static string ToString(TimeSpan value, char quoteChar);
    public static string ToString(Uri value);
    internal static string ToString(Uri value, char quoteChar);
    public static string ToString(string value);
    public static string ToString(string value, char delimiter);
    public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling);
    public static string ToString(object value);
    public static string SerializeObject(object value);
    public static string SerializeObject(object value, Formatting formatting);
    public static string SerializeObject(object value, JsonConverter[] converters);
    public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    public static string SerializeObject(object value, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Type type, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings);
    private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer);
    public static object DeserializeObject(string value);
    public static object DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type);
    public static T DeserializeObject(string value);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings);
    public static T DeserializeObject(string value, JsonConverter[] converters);
    public static T DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject);
    public static XmlDocument DeserializeXmlNode(string value);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    public static string SerializeXNode(XObject node);
    public static string SerializeXNode(XObject node, Formatting formatting);
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject);
    public static XDocument DeserializeXNode(string value);
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName);
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.JsonConverter : object {
    
public bool CanRead { get; }
    
public bool CanWrite { get; }
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
[AttributeUsageAttribute("3484")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonConverterAttribute : Attribute {
    
private Type _converterType;
    [CompilerGeneratedAttribute]

private Object[] <ConverterParameters>k__BackingField;
    
public Type ConverterType { get; }
    
public Object[] ConverterParameters { get; private set; }
    public JsonConverterAttribute(Type converterType);
    public JsonConverterAttribute(Type converterType, Object[] converterParameters);
    public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public Object[] get_ConverterParameters();
    [CompilerGeneratedAttribute]
private void set_ConverterParameters(Object[] value);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonConverterCollection : Collection`1<JsonConverter> {
}
[AttributeUsageAttribute("1028")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
    public JsonDictionaryAttribute(string id);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonException : Exception {
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    public JsonException(SerializationInfo info, StreamingContext context);
    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("384")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
    [CompilerGeneratedAttribute]

private bool <WriteData>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <ReadData>k__BackingField;
    
public bool WriteData { get; public set; }
    
public bool ReadData { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WriteData();
    [CompilerGeneratedAttribute]
public void set_WriteData(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadData();
    [CompilerGeneratedAttribute]
public void set_ReadData(bool value);
}
[AttributeUsageAttribute("384")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
    
private MemberSerialization _memberSerialization;
    
internal Nullable`1<Required> _itemRequired;
    
public MemberSerialization MemberSerialization { get; public set; }
    
public Required ItemRequired { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
    public Required get_ItemRequired();
    public void set_ItemRequired(Required value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.JsonPosition : ValueType {
    
private static Char[] SpecialCharacters;
    
internal JsonContainerType Type;
    
internal int Position;
    
internal string PropertyName;
    
internal bool HasIndex;
    public JsonPosition(JsonContainerType type);
    private static JsonPosition();
    internal int CalculateLength();
    internal void WriteTo(StringBuilder sb);
    internal static bool TypeHasIndex(JsonContainerType type);
    internal static string BuildPath(List`1<JsonPosition> positions, Nullable`1<JsonPosition> currentPosition);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("2432")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonPropertyAttribute : Attribute {
    
internal Nullable`1<NullValueHandling> _nullValueHandling;
    
internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    
internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    
internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    
internal Nullable`1<TypeNameHandling> _typeNameHandling;
    
internal Nullable`1<bool> _isReference;
    
internal Nullable`1<int> _order;
    
internal Nullable`1<Required> _required;
    
internal Nullable`1<bool> _itemIsReference;
    
internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    
internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]

private Type <ItemConverterType>k__BackingField;
    [CompilerGeneratedAttribute]

private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]

private string <PropertyName>k__BackingField;
    
public Type ItemConverterType { get; public set; }
    
public Object[] ItemConverterParameters { get; public set; }
    
public NullValueHandling NullValueHandling { get; public set; }
    
public DefaultValueHandling DefaultValueHandling { get; public set; }
    
public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    
public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    
public TypeNameHandling TypeNameHandling { get; public set; }
    
public bool IsReference { get; public set; }
    
public int Order { get; public set; }
    
public Required Required { get; public set; }
    
public string PropertyName { get; public set; }
    
public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    
public TypeNameHandling ItemTypeNameHandling { get; public set; }
    
public bool ItemIsReference { get; public set; }
    public JsonPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public int get_Order();
    public void set_Order(int value);
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.JsonReader : object {
    
private JsonToken _tokenType;
    
private object _value;
    
internal char _quoteChar;
    
internal State _currentState;
    
private JsonPosition _currentPosition;
    
private CultureInfo _culture;
    
private DateTimeZoneHandling _dateTimeZoneHandling;
    
private Nullable`1<int> _maxDepth;
    
private bool _hasExceededMaxDepth;
    
internal DateParseHandling _dateParseHandling;
    
internal FloatParseHandling _floatParseHandling;
    
private string _dateFormatString;
    
private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]

private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <SupportMultipleContent>k__BackingField;
    
protected State CurrentState { get; }
    
public bool CloseInput { get; public set; }
    
public bool SupportMultipleContent { get; public set; }
    
public char QuoteChar { get; protected internal set; }
    
public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    
public DateParseHandling DateParseHandling { get; public set; }
    
public FloatParseHandling FloatParseHandling { get; public set; }
    
public string DateFormatString { get; public set; }
    
public Nullable`1<int> MaxDepth { get; public set; }
    
public JsonToken TokenType { get; }
    
public object Value { get; }
    
public Type ValueType { get; }
    
public int Depth { get; }
    
public string Path { get; }
    
public CultureInfo Culture { get; public set; }
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    public virtual string get_Path();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    internal Nullable`1<int> ReadInt32String(string s);
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    internal Byte[] ReadArrayIntoByteArray();
    public virtual Nullable`1<double> ReadAsDouble();
    internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    internal Nullable`1<decimal> ReadDecimalString(string s);
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    internal Nullable`1<DateTime> ReadDateTimeString(string s);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal Nullable`1<DateTimeOffset> ReadDateTimeOffsetString(string s);
    internal void ReaderReadAndAssert();
    internal JsonReaderException CreateUnexpectedEndException();
    internal void ReadIntoWrappedTypeObject();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    internal void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonReaderException : JsonException {
    [CompilerGeneratedAttribute]

private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]

private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Path>k__BackingField;
    
public int LineNumber { get; private set; }
    
public int LinePosition { get; private set; }
    
public string Path { get; private set; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    public JsonReaderException(SerializationInfo info, StreamingContext context);
    internal JsonReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    internal static JsonReaderException Create(JsonReader reader, string message);
    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex);
    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[AttributeUsageAttribute("384")]
[PreserveAttribute]
public class Newtonsoft.Json.JsonRequiredAttribute : Attribute {
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonSerializationException : JsonException {
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
    public JsonSerializationException(SerializationInfo info, StreamingContext context);
    internal static JsonSerializationException Create(JsonReader reader, string message);
    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex);
    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonSerializer : object {
    
internal TypeNameHandling _typeNameHandling;
    
internal FormatterAssemblyStyle _typeNameAssemblyFormat;
    
internal PreserveReferencesHandling _preserveReferencesHandling;
    
internal ReferenceLoopHandling _referenceLoopHandling;
    
internal MissingMemberHandling _missingMemberHandling;
    
internal ObjectCreationHandling _objectCreationHandling;
    
internal NullValueHandling _nullValueHandling;
    
internal DefaultValueHandling _defaultValueHandling;
    
internal ConstructorHandling _constructorHandling;
    
internal MetadataPropertyHandling _metadataPropertyHandling;
    
internal JsonConverterCollection _converters;
    
internal IContractResolver _contractResolver;
    
internal ITraceWriter _traceWriter;
    
internal IEqualityComparer _equalityComparer;
    
internal SerializationBinder _binder;
    
internal StreamingContext _context;
    
private IReferenceResolver _referenceResolver;
    
private Nullable`1<Formatting> _formatting;
    
private Nullable`1<DateFormatHandling> _dateFormatHandling;
    
private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    
private Nullable`1<DateParseHandling> _dateParseHandling;
    
private Nullable`1<FloatFormatHandling> _floatFormatHandling;
    
private Nullable`1<FloatParseHandling> _floatParseHandling;
    
private Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    
private CultureInfo _culture;
    
private Nullable`1<int> _maxDepth;
    
private bool _maxDepthSet;
    
private Nullable`1<bool> _checkAdditionalContent;
    
private string _dateFormatString;
    
private bool _dateFormatStringSet;
    [CompilerGeneratedAttribute]

private EventHandler`1<ErrorEventArgs> Error;
    
public IReferenceResolver ReferenceResolver { get; public set; }
    
public SerializationBinder Binder { get; public set; }
    
public ITraceWriter TraceWriter { get; public set; }
    
public IEqualityComparer EqualityComparer { get; public set; }
    
public TypeNameHandling TypeNameHandling { get; public set; }
    
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    
public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    
public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    
public MissingMemberHandling MissingMemberHandling { get; public set; }
    
public NullValueHandling NullValueHandling { get; public set; }
    
public DefaultValueHandling DefaultValueHandling { get; public set; }
    
public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    
public ConstructorHandling ConstructorHandling { get; public set; }
    
public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    
public JsonConverterCollection Converters { get; }
    
public IContractResolver ContractResolver { get; public set; }
    
public StreamingContext Context { get; public set; }
    
public Formatting Formatting { get; public set; }
    
public DateFormatHandling DateFormatHandling { get; public set; }
    
public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    
public DateParseHandling DateParseHandling { get; public set; }
    
public FloatParseHandling FloatParseHandling { get; public set; }
    
public FloatFormatHandling FloatFormatHandling { get; public set; }
    
public StringEscapeHandling StringEscapeHandling { get; public set; }
    
public string DateFormatString { get; public set; }
    
public CultureInfo Culture { get; public set; }
    
public Nullable`1<int> MaxDepth { get; public set; }
    
public bool CheckAdditionalContent { get; public set; }
    [CompilerGeneratedAttribute]
public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ITraceWriter get_TraceWriter();
    public virtual void set_TraceWriter(ITraceWriter value);
    public virtual IEqualityComparer get_EqualityComparer();
    public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal bool IsCheckAdditionalContentSet();
    public static JsonSerializer Create();
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public static JsonSerializer CreateDefault();
    public static JsonSerializer CreateDefault(JsonSerializerSettings settings);
    private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings);
    public void Populate(TextReader reader, object target);
    public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    public object Deserialize(JsonReader reader);
    public object Deserialize(TextReader reader, Type objectType);
    public T Deserialize(JsonReader reader);
    public object Deserialize(JsonReader reader, Type objectType);
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    private void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString);
    private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString);
    public void Serialize(TextWriter textWriter, object value);
    public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    public void Serialize(TextWriter textWriter, object value, Type objectType);
    public void Serialize(JsonWriter jsonWriter, object value);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType);
    internal IReferenceResolver GetReferenceResolver();
    internal JsonConverter GetMatchingConverter(Type type);
    internal static JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType);
    internal void OnError(ErrorEventArgs e);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonSerializerSettings : object {
    
internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    
internal static MissingMemberHandling DefaultMissingMemberHandling;
    
internal static NullValueHandling DefaultNullValueHandling;
    
internal static DefaultValueHandling DefaultDefaultValueHandling;
    
internal static ObjectCreationHandling DefaultObjectCreationHandling;
    
internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    
internal static ConstructorHandling DefaultConstructorHandling;
    
internal static TypeNameHandling DefaultTypeNameHandling;
    
internal static MetadataPropertyHandling DefaultMetadataPropertyHandling;
    
internal static FormatterAssemblyStyle DefaultTypeNameAssemblyFormat;
    
internal static StreamingContext DefaultContext;
    
internal static Formatting DefaultFormatting;
    
internal static DateFormatHandling DefaultDateFormatHandling;
    
internal static DateTimeZoneHandling DefaultDateTimeZoneHandling;
    
internal static DateParseHandling DefaultDateParseHandling;
    
internal static FloatParseHandling DefaultFloatParseHandling;
    
internal static FloatFormatHandling DefaultFloatFormatHandling;
    
internal static StringEscapeHandling DefaultStringEscapeHandling;
    
internal static FormatterAssemblyStyle DefaultFormatterAssemblyStyle;
    
internal static CultureInfo DefaultCulture;
    
internal static bool DefaultCheckAdditionalContent;
    
internal static string DefaultDateFormatString;
    
internal Nullable`1<Formatting> _formatting;
    
internal Nullable`1<DateFormatHandling> _dateFormatHandling;
    
internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    
internal Nullable`1<DateParseHandling> _dateParseHandling;
    
internal Nullable`1<FloatFormatHandling> _floatFormatHandling;
    
internal Nullable`1<FloatParseHandling> _floatParseHandling;
    
internal Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    
internal CultureInfo _culture;
    
internal Nullable`1<bool> _checkAdditionalContent;
    
internal Nullable`1<int> _maxDepth;
    
internal bool _maxDepthSet;
    
internal string _dateFormatString;
    
internal bool _dateFormatStringSet;
    
internal Nullable`1<FormatterAssemblyStyle> _typeNameAssemblyFormat;
    
internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    
internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling;
    
internal Nullable`1<NullValueHandling> _nullValueHandling;
    
internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    
internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    
internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    
internal Nullable`1<StreamingContext> _context;
    
internal Nullable`1<ConstructorHandling> _constructorHandling;
    
internal Nullable`1<TypeNameHandling> _typeNameHandling;
    
internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling;
    [CompilerGeneratedAttribute]

private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]

private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]

private IEqualityComparer <EqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]

private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField;
    [CompilerGeneratedAttribute]

private ITraceWriter <TraceWriter>k__BackingField;
    [CompilerGeneratedAttribute]

private SerializationBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]

private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    
public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    
public MissingMemberHandling MissingMemberHandling { get; public set; }
    
public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    
public NullValueHandling NullValueHandling { get; public set; }
    
public DefaultValueHandling DefaultValueHandling { get; public set; }
    
public IList`1<JsonConverter> Converters { get; public set; }
    
public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    
public TypeNameHandling TypeNameHandling { get; public set; }
    
public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    
public ConstructorHandling ConstructorHandling { get; public set; }
    
public IContractResolver ContractResolver { get; public set; }
    
public IEqualityComparer EqualityComparer { get; public set; }
    [ObsoleteAttribute("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]

public IReferenceResolver ReferenceResolver { get; public set; }
    
public Func`1<IReferenceResolver> ReferenceResolverProvider { get; public set; }
    
public ITraceWriter TraceWriter { get; public set; }
    
public SerializationBinder Binder { get; public set; }
    
public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    
public StreamingContext Context { get; public set; }
    
public string DateFormatString { get; public set; }
    
public Nullable`1<int> MaxDepth { get; public set; }
    
public Formatting Formatting { get; public set; }
    
public DateFormatHandling DateFormatHandling { get; public set; }
    
public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    
public DateParseHandling DateParseHandling { get; public set; }
    
public FloatFormatHandling FloatFormatHandling { get; public set; }
    
public FloatParseHandling FloatParseHandling { get; public set; }
    
public StringEscapeHandling StringEscapeHandling { get; public set; }
    
public CultureInfo Culture { get; public set; }
    
public bool CheckAdditionalContent { get; public set; }
    private static JsonSerializerSettings();
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    [CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    public PreserveReferencesHandling get_PreserveReferencesHandling();
    public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public MetadataPropertyHandling get_MetadataPropertyHandling();
    public void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public ConstructorHandling get_ConstructorHandling();
    public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public IEqualityComparer get_EqualityComparer();
    [CompilerGeneratedAttribute]
public void set_EqualityComparer(IEqualityComparer value);
    public IReferenceResolver get_ReferenceResolver();
    public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public Func`1<IReferenceResolver> get_ReferenceResolverProvider();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    [CompilerGeneratedAttribute]
public SerializationBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    public StreamingContext get_Context();
    public void set_Context(StreamingContext value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public bool get_CheckAdditionalContent();
    public void set_CheckAdditionalContent(bool value);
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonTextReader : JsonReader {
    
private static char UnicodeReplacementChar;
    
private static int MaximumJavascriptIntegerCharacterLength;
    
private TextReader _reader;
    
private Char[] _chars;
    
private int _charsUsed;
    
private int _charPos;
    
private int _lineStartPos;
    
private int _lineNumber;
    
private bool _isEndOfFile;
    
private StringBuffer _stringBuffer;
    
private StringReference _stringReference;
    
private IArrayPool`1<char> _arrayPool;
    
internal PropertyNameTable NameTable;
    
public IArrayPool`1<char> ArrayPool { get; public set; }
    
public int LineNumber { get; }
    
public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    public IArrayPool`1<char> get_ArrayPool();
    public void set_ArrayPool(IArrayPool`1<char> value);
    private void EnsureBufferNotEmpty();
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    private object ReadStringValue(ReadType readType);
    private JsonReaderException CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    private object ReadNumberValue(ReadType readType);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private void ClearRecentString();
    private bool ParsePostValue();
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private bool EatWhitespace(bool oneOrMore);
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberNaN(ReadType readType);
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonTextWriter : JsonWriter {
    
private TextWriter _writer;
    
private Base64Encoder _base64Encoder;
    
private char _indentChar;
    
private int _indentation;
    
private char _quoteChar;
    
private bool _quoteName;
    
private Boolean[] _charEscapeFlags;
    
private Char[] _writeBuffer;
    
private IArrayPool`1<char> _arrayPool;
    
private Char[] _indentChars;
    
private Base64Encoder Base64Encoder { get; }
    
public IArrayPool`1<char> ArrayPool { get; public set; }
    
public int Indentation { get; public set; }
    
public char QuoteChar { get; public set; }
    
public char IndentChar { get; public set; }
    
public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    private Base64Encoder get_Base64Encoder();
    public IArrayPool`1<char> get_ArrayPool();
    public void set_ArrayPool(IArrayPool`1<char> value);
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    internal virtual void OnStringEscapeHandlingChanged();
    private void UpdateCharEscapeFlags();
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteValue(string value);
    private void WriteEscapedString(string value, bool quote);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void EnsureWriteBuffer();
    private void WriteIntegerValue(long value);
    private void WriteIntegerValue(ulong uvalue);
}
[PreserveAttribute]
public enum Newtonsoft.Json.JsonToken : Enum {
    
public int value__;
    
public static JsonToken None;
    
public static JsonToken StartObject;
    
public static JsonToken StartArray;
    
public static JsonToken StartConstructor;
    
public static JsonToken PropertyName;
    
public static JsonToken Comment;
    
public static JsonToken Raw;
    
public static JsonToken Integer;
    
public static JsonToken Float;
    
public static JsonToken String;
    
public static JsonToken Boolean;
    
public static JsonToken Null;
    
public static JsonToken Undefined;
    
public static JsonToken EndObject;
    
public static JsonToken EndArray;
    
public static JsonToken EndConstructor;
    
public static JsonToken Date;
    
public static JsonToken Bytes;
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.JsonWriter : object {
    
private static State[][] StateArray;
    
internal static State[][] StateArrayTempate;
    
private List`1<JsonPosition> _stack;
    
private JsonPosition _currentPosition;
    
private State _currentState;
    
private Formatting _formatting;
    [CompilerGeneratedAttribute]

private bool <CloseOutput>k__BackingField;
    
private DateFormatHandling _dateFormatHandling;
    
private DateTimeZoneHandling _dateTimeZoneHandling;
    
private StringEscapeHandling _stringEscapeHandling;
    
private FloatFormatHandling _floatFormatHandling;
    
private string _dateFormatString;
    
private CultureInfo _culture;
    
public bool CloseOutput { get; public set; }
    
protected internal int Top { get; }
    
public WriteState WriteState { get; }
    
internal string ContainerPath { get; }
    
public string Path { get; }
    
public Formatting Formatting { get; public set; }
    
public DateFormatHandling DateFormatHandling { get; public set; }
    
public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    
public StringEscapeHandling StringEscapeHandling { get; public set; }
    
public FloatFormatHandling FloatFormatHandling { get; public set; }
    
public string DateFormatString { get; public set; }
    
public CultureInfo Culture { get; public set; }
    private static JsonWriter();
    internal static State[][] BuildStateArray();
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    protected internal int get_Top();
    public WriteState get_WriteState();
    internal string get_ContainerPath();
    public string get_Path();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    internal virtual void OnStringEscapeHandlingChanged();
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal void UpdateScopeWithFinishedValue();
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteEnd();
    public void WriteToken(JsonReader reader);
    public void WriteToken(JsonReader reader, bool writeChildren);
    public void WriteToken(JsonToken token, object value);
    public void WriteToken(JsonToken token);
    internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
    private void WriteConstructorDate(JsonReader reader);
    private void WriteEnd(JsonContainerType type);
    private void AutoCompleteAll();
    private JsonToken GetCloseTokenForType(JsonContainerType type);
    private void AutoCompleteClose(JsonContainerType type);
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(object value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value);
    private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value);
    protected void SetWriteState(JsonToken token, object value);
    internal void InternalWriteEnd(JsonContainerType container);
    internal void InternalWritePropertyName(string name);
    internal void InternalWriteRaw();
    internal void InternalWriteStart(JsonToken token, JsonContainerType container);
    internal void InternalWriteValue(JsonToken token);
    internal void InternalWriteWhitespace(string ws);
    internal void InternalWriteComment();
}
[PreserveAttribute]
public class Newtonsoft.Json.JsonWriterException : JsonException {
    [CompilerGeneratedAttribute]

private string <Path>k__BackingField;
    
public string Path { get; private set; }
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
    public JsonWriterException(SerializationInfo info, StreamingContext context);
    internal JsonWriterException(string message, Exception innerException, string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex);
    internal static JsonWriterException Create(string path, string message, Exception ex);
}
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.CommentHandling : Enum {
    
public int value__;
    
public static CommentHandling Ignore;
    
public static CommentHandling Load;
}
[ExtensionAttribute]
[PreserveAttribute]
public static class Newtonsoft.Json.Linq.Extensions : object {
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public interface Newtonsoft.Json.Linq.IJEnumerable`1 {
    
public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JArray : JContainer {
    
private List`1<JToken> _values;
    
protected IList`1<JToken> ChildrenTokens { get; }
    
public JTokenType Type { get; }
    
public JToken Item { get; public set; }
    
public JToken Item { get; public set; }
    
public bool IsReadOnly { get; }
    public JArray(JArray other);
    public JArray(Object[] content);
    public JArray(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public static JArray Load(JsonReader reader);
    public static JArray Load(JsonReader reader, JsonLoadSettings settings);
    public static JArray Parse(string json);
    public static JArray Parse(string json, JsonLoadSettings settings);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JConstructor : JContainer {
    
private string _name;
    
private List`1<JToken> _values;
    
protected IList`1<JToken> ChildrenTokens { get; }
    
public string Name { get; public set; }
    
public JTokenType Type { get; }
    
public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public string get_Name();
    public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
    public static JConstructor Load(JsonReader reader, JsonLoadSettings settings);
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.Linq.JContainer : JToken {
    
internal ListChangedEventHandler _listChanged;
    
internal AddingNewEventHandler _addingNew;
    
private object _syncRoot;
    
private bool _busy;
    
protected IList`1<JToken> ChildrenTokens { get; }
    
public bool HasValues { get; }
    
public JToken First { get; }
    
public JToken Last { get; }
    
private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item { get; private set; }
    
private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    
private bool System.Collections.IList.IsFixedSize { get; }
    
private bool System.Collections.IList.IsReadOnly { get; }
    
private object System.Collections.IList.Item { get; private set; }
    
public int Count { get; }
    
private bool System.Collections.ICollection.IsSynchronized { get; }
    
private object System.Collections.ICollection.SyncRoot { get; }
    
private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    
private bool System.ComponentModel.IBindingList.AllowNew { get; }
    
private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    
private bool System.ComponentModel.IBindingList.IsSorted { get; }
    
private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    
private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    
private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    
private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    internal JContainer(JContainer other);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    internal void CheckReentrancy();
    internal virtual IList`1<JToken> CreateChildrenCollection();
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    public IEnumerable`1<JToken> DescendantsAndSelf();
    internal IEnumerable`1<JToken> GetDescendants(bool self);
    internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck);
    internal abstract virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void RemoveItemAt(int index);
    internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    public virtual void Add(object content);
    internal void AddAndSkipParentCheck(JToken token);
    public void AddFirst(object content);
    internal void AddInternal(int index, object content, bool skipParentCheck);
    internal static JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal abstract virtual void MergeItem(object content, JsonMergeSettings settings);
    public void Merge(object content);
    public void Merge(object content, JsonMergeSettings settings);
    internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options);
    internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings);
    internal int ContentsHashCode();
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings);
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
    
public static JEnumerable`1<T> Empty;
    
private IEnumerable`1<T> _enumerable;
    
public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public bool Equals(JEnumerable`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JObject : JContainer {
    
private JPropertyKeyedCollection _properties;
    [CompilerGeneratedAttribute]

private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]

private PropertyChangingEventHandler PropertyChanging;
    
protected IList`1<JToken> ChildrenTokens { get; }
    
public JTokenType Type { get; }
    
public JToken Item { get; public set; }
    
public JToken Item { get; public set; }
    
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys { get; }
    
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values { get; }
    
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    public JObject(Object[] content);
    public JObject(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken();
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Load(JsonReader reader, JsonLoadSettings settings);
    public static JObject Parse(string json);
    public static JObject Parse(string json, JsonLoadSettings settings);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public JToken GetValue(string propertyName);
    public JToken GetValue(string propertyName, StringComparison comparison);
    public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value);
    public sealed virtual void Add(string propertyName, JToken value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.ContainsKey(string key);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanging(string propertyName);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JProperty : JContainer {
    
private JPropertyList _content;
    
private string _name;
    
protected IList`1<JToken> ChildrenTokens { get; }
    
public string Name { get; }
    
public JToken Value { get; public set; }
    
public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal virtual void ClearItems();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
    public static JProperty Load(JsonReader reader, JsonLoadSettings settings);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
    
public Type ComponentType { get; }
    
public bool IsReadOnly { get; }
    
public Type PropertyType { get; }
    
protected int NameHashCode { get; }
    public JPropertyDescriptor(string name);
    private static JObject CastInstance(object instance);
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    protected virtual int get_NameHashCode();
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
    
private static IEqualityComparer`1<string> Comparer;
    
private Dictionary`2<string, JToken> _dictionary;
    
public JToken Item { get; }
    
public ICollection`1<string> Keys { get; }
    
public ICollection`1<JToken> Values { get; }
    private static JPropertyKeyedCollection();
    private void AddKey(string key, JToken item);
    protected void ChangeItemKey(JToken item, string newKey);
    protected virtual void ClearItems();
    public bool Contains(string key);
    private bool ContainsItem(JToken item);
    private void EnsureDictionary();
    private string GetKeyForItem(JToken item);
    protected virtual void InsertItem(int index, JToken item);
    public bool Remove(string key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(string key);
    protected virtual void SetItem(int index, JToken item);
    public JToken get_Item(string key);
    public bool TryGetValue(string key, JToken& value);
    public ICollection`1<string> get_Keys();
    public ICollection`1<JToken> get_Values();
    public int IndexOfReference(JToken t);
    public bool Compare(JPropertyKeyedCollection other);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    public JRaw(object rawJson);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken();
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JsonLoadSettings : object {
    
private CommentHandling _commentHandling;
    
private LineInfoHandling _lineInfoHandling;
    
public CommentHandling CommentHandling { get; public set; }
    
public LineInfoHandling LineInfoHandling { get; public set; }
    public CommentHandling get_CommentHandling();
    public void set_CommentHandling(CommentHandling value);
    public LineInfoHandling get_LineInfoHandling();
    public void set_LineInfoHandling(LineInfoHandling value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JsonMergeSettings : object {
    
private MergeArrayHandling _mergeArrayHandling;
    
private MergeNullValueHandling _mergeNullValueHandling;
    
public MergeArrayHandling MergeArrayHandling { get; public set; }
    
public MergeNullValueHandling MergeNullValueHandling { get; public set; }
    public MergeArrayHandling get_MergeArrayHandling();
    public void set_MergeArrayHandling(MergeArrayHandling value);
    public MergeNullValueHandling get_MergeNullValueHandling();
    public void set_MergeNullValueHandling(MergeNullValueHandling value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]

private Nullable`1<int> <Index>k__BackingField;
    
public Nullable`1<int> Index { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]

private List`1<int> <Indexes>k__BackingField;
    
public List`1<int> Indexes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<int> get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(List`1<int> value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
    [CompilerGeneratedAttribute]

private Nullable`1<int> <Start>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<int> <End>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<int> <Step>k__BackingField;
    
public Nullable`1<int> Start { get; public set; }
    
public Nullable`1<int> End { get; public set; }
    
public Nullable`1<int> Step { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(Nullable`1<int> value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
    private bool IsValid(int index, int stopIndex, bool positiveStep);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
    [CompilerGeneratedAttribute]

private List`1<PathFilter> <Path>k__BackingField;
    [CompilerGeneratedAttribute]

private JValue <Value>k__BackingField;
    
public List`1<PathFilter> Path { get; public set; }
    
public JValue Value { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(List`1<PathFilter> value);
    [CompilerGeneratedAttribute]
public JValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(JValue value);
    public virtual bool IsMatch(JToken t);
    private bool EqualsWithStringCoercion(JValue value, JValue queryValue);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
    [CompilerGeneratedAttribute]

private List`1<QueryExpression> <Expressions>k__BackingField;
    
public List`1<QueryExpression> Expressions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<QueryExpression> get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(List`1<QueryExpression> value);
    public virtual bool IsMatch(JToken t);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.FieldFilter : PathFilter {
    [CompilerGeneratedAttribute]

private string <Name>k__BackingField;
    
public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
    [CompilerGeneratedAttribute]

private List`1<string> <Names>k__BackingField;
    
public List`1<string> Names { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Names();
    [CompilerGeneratedAttribute]
public void set_Names(List`1<string> value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.JPath : object {
    
private string _expression;
    [CompilerGeneratedAttribute]

private List`1<PathFilter> <Filters>k__BackingField;
    
private int _currentIndex;
    
public List`1<PathFilter> Filters { get; private set; }
    public JPath(string expression);
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Filters();
    [CompilerGeneratedAttribute]
private void set_Filters(List`1<PathFilter> value);
    private void ParseMain();
    private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query);
    private PathFilter ParseIndexer(char indexerOpenChar);
    private PathFilter ParseArrayIndexer(char indexerCloseChar);
    private void EatWhitespace();
    private PathFilter ParseQuery(char indexerCloseChar);
    private QueryExpression ParseExpression();
    private object ParseValue();
    private string ReadQuotedString();
    private bool Match(string s);
    private QueryOperator ParseOperator();
    private PathFilter ParseQuotedField(char indexerCloseChar);
    private void EnsureLength(string message);
    internal IEnumerable`1<JToken> Evaluate(JToken t, bool errorWhenNoMatch);
    internal static IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken t, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Linq.JsonPath.PathFilter : object {
    public abstract virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
    protected static JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Linq.JsonPath.QueryExpression : object {
    [CompilerGeneratedAttribute]

private QueryOperator <Operator>k__BackingField;
    
public QueryOperator Operator { get; public set; }
    [CompilerGeneratedAttribute]
public QueryOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(QueryOperator value);
    public abstract virtual bool IsMatch(JToken t);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.QueryFilter : PathFilter {
    [CompilerGeneratedAttribute]

private QueryExpression <Expression>k__BackingField;
    
public QueryExpression Expression { get; public set; }
    [CompilerGeneratedAttribute]
public QueryExpression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(QueryExpression value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Linq.JsonPath.QueryOperator : Enum {
    
public int value__;
    
public static QueryOperator None;
    
public static QueryOperator Equals;
    
public static QueryOperator NotEquals;
    
public static QueryOperator Exists;
    
public static QueryOperator LessThan;
    
public static QueryOperator LessThanOrEquals;
    
public static QueryOperator GreaterThan;
    
public static QueryOperator GreaterThanOrEquals;
    
public static QueryOperator And;
    
public static QueryOperator Or;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Linq.JsonPath.ScanFilter : PathFilter {
    [CompilerGeneratedAttribute]

private string <Name>k__BackingField;
    
public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
public abstract class Newtonsoft.Json.Linq.JToken : object {
    
private static JTokenEqualityComparer _equalityComparer;
    
private JContainer _parent;
    
private JToken _previous;
    
private JToken _next;
    
private object _annotations;
    
private static JTokenType[] BooleanTypes;
    
private static JTokenType[] NumberTypes;
    
private static JTokenType[] StringTypes;
    
private static JTokenType[] GuidTypes;
    
private static JTokenType[] TimeSpanTypes;
    
private static JTokenType[] UriTypes;
    
private static JTokenType[] CharTypes;
    
private static JTokenType[] DateTimeTypes;
    
private static JTokenType[] BytesTypes;
    
public static JTokenEqualityComparer EqualityComparer { get; }
    
public JContainer Parent { get; internal set; }
    
public JToken Root { get; }
    
public JTokenType Type { get; }
    
public bool HasValues { get; }
    
public JToken Next { get; internal set; }
    
public JToken Previous { get; internal set; }
    
public string Path { get; }
    
public JToken Item { get; public set; }
    
public JToken First { get; }
    
public JToken Last { get; }
    
private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item { get; }
    
private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    
private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    private static JToken();
    public static JTokenEqualityComparer get_EqualityComparer();
    [DebuggerStepThroughAttribute]
public JContainer get_Parent();
    internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken();
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    public static bool DeepEquals(JToken t1, JToken t2);
    public JToken get_Next();
    internal void set_Next(JToken value);
    public JToken get_Previous();
    internal void set_Previous(JToken value);
    public string get_Path();
    public void AddAfterSelf(object content);
    public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AncestorsAndSelf();
    internal IEnumerable`1<JToken> GetAncestors(bool self);
    public IEnumerable`1<JToken> AfterSelf();
    public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual T Value(object key);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public JEnumerable`1<T> Children();
    public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable);
    public static bool op_Explicit(JToken value);
    public static DateTimeOffset op_Explicit(JToken value);
    public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    public static Nullable`1<DateTime> op_Explicit(JToken value);
    public static Nullable`1<DateTimeOffset> op_Explicit(JToken value);
    public static Nullable`1<decimal> op_Explicit(JToken value);
    public static Nullable`1<double> op_Explicit(JToken value);
    public static Nullable`1<char> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static short op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static char op_Explicit(JToken value);
    public static byte op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JToken value);
    public static Nullable`1<int> op_Explicit(JToken value);
    public static Nullable`1<short> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JToken value);
    public static Nullable`1<byte> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    public static Nullable`1<long> op_Explicit(JToken value);
    public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    public static Byte[] op_Explicit(JToken value);
    public static Guid op_Explicit(JToken value);
    public static Nullable`1<Guid> op_Explicit(JToken value);
    public static TimeSpan op_Explicit(JToken value);
    public static Nullable`1<TimeSpan> op_Explicit(JToken value);
    public static Uri op_Explicit(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(DateTimeOffset value);
    public static JToken op_Implicit(byte value);
    public static JToken op_Implicit(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<sbyte> value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    public static JToken op_Implicit(Uri value);
    public static JToken op_Implicit(TimeSpan value);
    public static JToken op_Implicit(Nullable`1<TimeSpan> value);
    public static JToken op_Implicit(Guid value);
    public static JToken op_Implicit(Nullable`1<Guid> value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    public T ToObject();
    public object ToObject(Type objectType);
    public T ToObject(JsonSerializer jsonSerializer);
    public object ToObject(Type objectType, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings);
    public static JToken Parse(string json);
    public static JToken Parse(string json, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader);
    internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
    public IEnumerable`1<JToken> SelectTokens(string path);
    public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch);
    private sealed virtual override object System.ICloneable.Clone();
    public JToken DeepClone();
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    public IEnumerable`1<T> Annotations();
    public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
    public sealed virtual bool Equals(JToken x, JToken y);
    public sealed virtual int GetHashCode(JToken obj);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JTokenReader : JsonReader {
    
private JToken _root;
    
private string _initialPath;
    
private JToken _parent;
    
private JToken _current;
    
public JToken CurrentToken { get; }
    
private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    
private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    
public string Path { get; }
    public JTokenReader(JToken token);
    internal JTokenReader(JToken token, string initialPath);
    public JToken get_CurrentToken();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    private string SafeToString(object value);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public virtual string get_Path();
}
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.JTokenType : Enum {
    
public int value__;
    
public static JTokenType None;
    
public static JTokenType Object;
    
public static JTokenType Array;
    
public static JTokenType Constructor;
    
public static JTokenType Property;
    
public static JTokenType Comment;
    
public static JTokenType Integer;
    
public static JTokenType Float;
    
public static JTokenType String;
    
public static JTokenType Boolean;
    
public static JTokenType Null;
    
public static JTokenType Undefined;
    
public static JTokenType Date;
    
public static JTokenType Raw;
    
public static JTokenType Bytes;
    
public static JTokenType Guid;
    
public static JTokenType Uri;
    
public static JTokenType TimeSpan;
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
    
private JContainer _token;
    
private JContainer _parent;
    
private JValue _value;
    
private JToken _current;
    
public JToken CurrentToken { get; }
    
public JToken Token { get; }
    public JTokenWriter(JContainer container);
    public JToken get_CurrentToken();
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    private void AddValue(object value, JsonToken token);
    internal void AddValue(JValue value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Uri value);
    internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
}
[PreserveAttribute]
public class Newtonsoft.Json.Linq.JValue : JToken {
    
private JTokenType _valueType;
    
private object _value;
    
public bool HasValues { get; }
    
public JTokenType Type { get; }
    
public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    public JValue(JValue other);
    public JValue(long value);
    public JValue(decimal value);
    public JValue(char value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(float value);
    public JValue(DateTime value);
    public JValue(DateTimeOffset value);
    public JValue(bool value);
    public JValue(string value);
    public JValue(Guid value);
    public JValue(Uri value);
    public JValue(TimeSpan value);
    public JValue(object value);
    internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    internal static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    internal virtual JToken CloneToken();
    public static JValue CreateComment(string value);
    public static JValue CreateString(string value);
    public static JValue CreateNull();
    public static JValue CreateUndefined();
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    private static bool ValuesEquals(JValue v1, JValue v2);
    public bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public int CompareTo(JValue obj);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
}
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.LineInfoHandling : Enum {
    
public int value__;
    
public static LineInfoHandling Ignore;
    
public static LineInfoHandling Load;
}
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.MergeArrayHandling : Enum {
    
public int value__;
    
public static MergeArrayHandling Concat;
    
public static MergeArrayHandling Union;
    
public static MergeArrayHandling Replace;
    
public static MergeArrayHandling Merge;
}
[FlagsAttribute]
[PreserveAttribute]
public enum Newtonsoft.Json.Linq.MergeNullValueHandling : Enum {
    
public int value__;
    
public static MergeNullValueHandling Ignore;
    
public static MergeNullValueHandling Merge;
}
[PreserveAttribute]
public enum Newtonsoft.Json.MemberSerialization : Enum {
    
public int value__;
    
public static MemberSerialization OptOut;
    
public static MemberSerialization OptIn;
    
public static MemberSerialization Fields;
}
[PreserveAttribute]
public enum Newtonsoft.Json.MetadataPropertyHandling : Enum {
    
public int value__;
    
public static MetadataPropertyHandling Default;
    
public static MetadataPropertyHandling ReadAhead;
    
public static MetadataPropertyHandling Ignore;
}
[PreserveAttribute]
public enum Newtonsoft.Json.MissingMemberHandling : Enum {
    
public int value__;
    
public static MissingMemberHandling Ignore;
    
public static MissingMemberHandling Error;
}
[PreserveAttribute]
public enum Newtonsoft.Json.NullValueHandling : Enum {
    
public int value__;
    
public static NullValueHandling Include;
    
public static NullValueHandling Ignore;
}
[PreserveAttribute]
public enum Newtonsoft.Json.ObjectCreationHandling : Enum {
    
public int value__;
    
public static ObjectCreationHandling Auto;
    
public static ObjectCreationHandling Reuse;
    
public static ObjectCreationHandling Replace;
}
[FlagsAttribute]
[PreserveAttribute]
public enum Newtonsoft.Json.PreserveReferencesHandling : Enum {
    
public int value__;
    
public static PreserveReferencesHandling None;
    
public static PreserveReferencesHandling Objects;
    
public static PreserveReferencesHandling Arrays;
    
public static PreserveReferencesHandling All;
}
[PreserveAttribute]
internal enum Newtonsoft.Json.ReadType : Enum {
    
public int value__;
    
public static ReadType Read;
    
public static ReadType ReadAsInt32;
    
public static ReadType ReadAsBytes;
    
public static ReadType ReadAsString;
    
public static ReadType ReadAsDecimal;
    
public static ReadType ReadAsDateTime;
    
public static ReadType ReadAsDateTimeOffset;
    
public static ReadType ReadAsDouble;
    
public static ReadType ReadAsBoolean;
}
[PreserveAttribute]
public enum Newtonsoft.Json.ReferenceLoopHandling : Enum {
    
public int value__;
    
public static ReferenceLoopHandling Error;
    
public static ReferenceLoopHandling Ignore;
    
public static ReferenceLoopHandling Serialize;
}
[PreserveAttribute]
public enum Newtonsoft.Json.Required : Enum {
    
public int value__;
    
public static Required Default;
    
public static Required AllowNull;
    
public static Required Always;
    
public static Required DisallowNull;
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
    
private static ThreadSafeStore`2<object, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    public static T GetAttribute(object type);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    protected virtual string ResolvePropertyName(string propertyName);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.DefaultContractResolver : object {
    
private static IContractResolver _instance;
    
private static JsonConverter[] BuiltInConverters;
    
private static object TypeContractCacheLock;
    
private static DefaultContractResolverState _sharedState;
    
private DefaultContractResolverState _instanceState;
    
private bool _sharedCache;
    [CompilerGeneratedAttribute]

private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <IgnoreSerializableInterface>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <IgnoreSerializableAttribute>k__BackingField;
    
internal static IContractResolver Instance { get; }
    
public bool DynamicCodeGeneration { get; }
    [ObsoleteAttribute("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]

public BindingFlags DefaultMembersSearchFlags { get; public set; }
    
public bool SerializeCompilerGeneratedMembers { get; public set; }
    
public bool IgnoreSerializableInterface { get; public set; }
    
public bool IgnoreSerializableAttribute { get; public set; }
    [ObsoleteAttribute("DefaultContractResolver(bool) is obsolete. Use the parameterless constructor and cache instances of the contract resolver within your application for optimal performance.")]
public DefaultContractResolver(bool shareCache);
    private static DefaultContractResolver();
    internal static IContractResolver get_Instance();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableInterface();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableAttribute();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableAttribute(bool value);
    internal DefaultContractResolverState GetState();
    public virtual JsonContract ResolveContract(Type type);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private MemberInfo GetExtensionDataMemberForType(Type type);
    private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member);
    private ConstructorInfo GetAttributeConstructor(Type objectType);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    protected virtual IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    private void InitializeContract(JsonContract contract);
    private void ResolveCallbackMethods(JsonContract contract, Type t);
    private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError);
    private static bool ShouldSkipDeserialized(Type t);
    private static bool ShouldSkipSerializing(Type t);
    private List`1<Type> GetClassHierarchyForType(Type type);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool IsJsonPrimitiveType(Type t);
    internal static bool IsIConvertible(Type t);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess);
    protected virtual string ResolvePropertyName(string propertyName);
    protected virtual string ResolveDictionaryKey(string dictionaryKey);
    public string GetResolvedPropertyName(string propertyName);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.DefaultContractResolverState : object {
    
public Dictionary`2<ResolverContractKey, JsonContract> ContractCache;
    
public PropertyNameTable NameTable;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
    
private int _referenceCount;
    private BidirectionalDictionary`2<string, object> GetMappings(object context);
    public sealed virtual object ResolveReference(object context, string reference);
    public sealed virtual string GetReference(object context, object value);
    public sealed virtual void AddReference(object context, string reference, object value);
    public sealed virtual bool IsReferenced(object context, object value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    
internal static DefaultSerializationBinder Instance;
    
private ThreadSafeStore`2<TypeNameKey, Type> _typeCache;
    private static DefaultSerializationBinder();
    private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey);
    public virtual Type BindToType(string assemblyName, string typeName);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
    [CompilerGeneratedAttribute]

private TraceLevel <LevelFilter>k__BackingField;
    
public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    private TraceEventType GetTraceEventType(TraceLevel level);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]

private bool <Traced>k__BackingField;
    [CompilerGeneratedAttribute]

private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]

private object <OriginalObject>k__BackingField;
    [CompilerGeneratedAttribute]

private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]

private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <Handled>k__BackingField;
    
internal bool Traced { get; internal set; }
    
public Exception Error { get; private set; }
    
public object OriginalObject { get; private set; }
    
public object Member { get; private set; }
    
public string Path { get; private set; }
    
public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, string path, Exception error);
    [CompilerGeneratedAttribute]
internal bool get_Traced();
    [CompilerGeneratedAttribute]
internal void set_Traced(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public object get_OriginalObject();
    [CompilerGeneratedAttribute]
private void set_OriginalObject(object value);
    [CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(object value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]

private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]

private ErrorContext <ErrorContext>k__BackingField;
    
public object CurrentObject { get; private set; }
    
public ErrorContext ErrorContext { get; private set; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
private void set_CurrentObject(object value);
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
    [CompilerGeneratedAttribute]
private void set_ErrorContext(ErrorContext value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
    public ExtensionDataGetter(object object, IntPtr method);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
    public ExtensionDataSetter(object object, IntPtr method);
    public virtual void Invoke(object o, string key, object value);
    public virtual IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.IAttributeProvider {
    public abstract virtual IList`1<Attribute> GetAttributes(bool inherit);
    public abstract virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(object context, string reference);
    public abstract virtual string GetReference(object context, object value);
    public abstract virtual bool IsReferenced(object context, object value);
    public abstract virtual void AddReference(object context, string reference, object value);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.ITraceWriter {
    
public TraceLevel LevelFilter { get; }
    public abstract virtual TraceLevel get_LevelFilter();
    public abstract virtual void Trace(TraceLevel level, string message, Exception ex);
}
[PreserveAttribute]
public interface Newtonsoft.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
    [CompilerGeneratedAttribute]

private Type <CollectionItemType>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <IsMultidimensionalArray>k__BackingField;
    
private Type _genericCollectionDefinitionType;
    
private Type _genericWrapperType;
    
private ObjectConstructor`1<object> _genericWrapperCreator;
    
private Func`1<object> _genericTemporaryCollectionCreator;
    [CompilerGeneratedAttribute]

private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <CanDeserialize>k__BackingField;
    
private ConstructorInfo _parameterizedConstructor;
    
private ObjectConstructor`1<object> _parameterizedCreator;
    
private ObjectConstructor`1<object> _overrideCreator;
    [CompilerGeneratedAttribute]

private bool <HasParameterizedCreator>k__BackingField;
    
public Type CollectionItemType { get; private set; }
    
public bool IsMultidimensionalArray { get; private set; }
    
internal bool IsArray { get; private set; }
    
internal bool ShouldCreateWrapper { get; private set; }
    
internal bool CanDeserialize { get; private set; }
    
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    
public bool HasParameterizedCreator { get; public set; }
    
internal bool HasParameterizedCreatorInternal { get; }
    public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
private void set_CollectionItemType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensionalArray();
    [CompilerGeneratedAttribute]
private void set_IsMultidimensionalArray(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateWrapper(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    internal IWrappedCollection CreateWrapper(object list);
    internal IList CreateTemporaryCollection();
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
    
private JsonContract _itemContract;
    
private JsonContract _finalItemContract;
    [CompilerGeneratedAttribute]

private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    
internal JsonContract ItemContract { get; internal set; }
    
internal JsonContract FinalItemContract { get; }
    
public JsonConverter ItemConverter { get; public set; }
    
public Nullable`1<bool> ItemIsReference { get; public set; }
    
public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    
public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
    internal JsonContract get_FinalItemContract();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
}
[PreserveAttribute]
public abstract class Newtonsoft.Json.Serialization.JsonContract : object {
    
internal bool IsNullable;
    
internal bool IsConvertable;
    
internal bool IsEnum;
    
internal Type NonNullableUnderlyingType;
    
internal ReadType InternalReadType;
    
internal JsonContractType ContractType;
    
internal bool IsReadOnlyOrFixedSize;
    
internal bool IsSealed;
    
internal bool IsInstantiable;
    
private List`1<SerializationCallback> _onDeserializedCallbacks;
    
private IList`1<SerializationCallback> _onDeserializingCallbacks;
    
private IList`1<SerializationCallback> _onSerializedCallbacks;
    
private IList`1<SerializationCallback> _onSerializingCallbacks;
    
private IList`1<SerializationErrorCallback> _onErrorCallbacks;
    
private Type _createdType;
    [CompilerGeneratedAttribute]

private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]

private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]

private JsonConverter <InternalConverter>k__BackingField;
    [CompilerGeneratedAttribute]

private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <DefaultCreatorNonPublic>k__BackingField;
    
public Type UnderlyingType { get; private set; }
    
public Type CreatedType { get; public set; }
    
public Nullable`1<bool> IsReference { get; public set; }
    
public JsonConverter Converter { get; public set; }
    
internal JsonConverter InternalConverter { get; internal set; }
    
public IList`1<SerializationCallback> OnDeserializedCallbacks { get; }
    
public IList`1<SerializationCallback> OnDeserializingCallbacks { get; }
    
public IList`1<SerializationCallback> OnSerializedCallbacks { get; }
    
public IList`1<SerializationCallback> OnSerializingCallbacks { get; }
    
public IList`1<SerializationErrorCallback> OnErrorCallbacks { get; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnDeserializedCallbacks collection.")]

public MethodInfo OnDeserialized { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnDeserializingCallbacks collection.")]

public MethodInfo OnDeserializing { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnSerializedCallbacks collection.")]

public MethodInfo OnSerialized { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnSerializingCallbacks collection.")]

public MethodInfo OnSerializing { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnErrorCallbacks collection.")]

public MethodInfo OnError { get; public set; }
    
public Func`1<object> DefaultCreator { get; public set; }
    
public bool DefaultCreatorNonPublic { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
private void set_UnderlyingType(Type value);
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
internal JsonConverter get_InternalConverter();
    [CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    public IList`1<SerializationCallback> get_OnDeserializedCallbacks();
    public IList`1<SerializationCallback> get_OnDeserializingCallbacks();
    public IList`1<SerializationCallback> get_OnSerializedCallbacks();
    public IList`1<SerializationCallback> get_OnSerializingCallbacks();
    public IList`1<SerializationErrorCallback> get_OnErrorCallbacks();
    public MethodInfo get_OnDeserialized();
    public void set_OnDeserialized(MethodInfo value);
    public MethodInfo get_OnDeserializing();
    public void set_OnDeserializing(MethodInfo value);
    public MethodInfo get_OnSerialized();
    public void set_OnSerialized(MethodInfo value);
    public MethodInfo get_OnSerializing();
    public void set_OnSerializing(MethodInfo value);
    public MethodInfo get_OnError();
    public void set_OnError(MethodInfo value);
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo);
    internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Serialization.JsonContractType : Enum {
    
public int value__;
    
public static JsonContractType None;
    
public static JsonContractType Object;
    
public static JsonContractType Array;
    
public static JsonContractType Primitive;
    
public static JsonContractType String;
    
public static JsonContractType Dictionary;
    
public static JsonContractType Dynamic;
    
public static JsonContractType Serializable;
    
public static JsonContractType Linq;
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
    [CompilerGeneratedAttribute]

private Func`2<string, string> <DictionaryKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]

private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]

private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]

private JsonContract <KeyContract>k__BackingField;
    
private Type _genericCollectionDefinitionType;
    
private Type _genericWrapperType;
    
private ObjectConstructor`1<object> _genericWrapperCreator;
    
private Func`1<object> _genericTemporaryDictionaryCreator;
    [CompilerGeneratedAttribute]

private bool <ShouldCreateWrapper>k__BackingField;
    
private ConstructorInfo _parameterizedConstructor;
    
private ObjectConstructor`1<object> _overrideCreator;
    
private ObjectConstructor`1<object> _parameterizedCreator;
    [CompilerGeneratedAttribute]

private bool <HasParameterizedCreator>k__BackingField;
    [ObsoleteAttribute("PropertyNameResolver is obsolete. Use DictionaryKeyResolver instead.")]

public Func`2<string, string> PropertyNameResolver { get; public set; }
    
public Func`2<string, string> DictionaryKeyResolver { get; public set; }
    
public Type DictionaryKeyType { get; private set; }
    
public Type DictionaryValueType { get; private set; }
    
internal JsonContract KeyContract { get; internal set; }
    
internal bool ShouldCreateWrapper { get; private set; }
    
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    
public bool HasParameterizedCreator { get; public set; }
    
internal bool HasParameterizedCreatorInternal { get; }
    public JsonDictionaryContract(Type underlyingType);
    public Func`2<string, string> get_PropertyNameResolver();
    public void set_PropertyNameResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_DictionaryKeyResolver();
    [CompilerGeneratedAttribute]
public void set_DictionaryKeyResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
private void set_DictionaryKeyType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
private void set_DictionaryValueType(Type value);
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateWrapper(bool value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    internal IWrappedDictionary CreateWrapper(object dictionary);
    internal IDictionary CreateTemporaryDictionary();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
    
private JsonSerializerInternalReader _reader;
    
private JsonISerializableContract _contract;
    
private JsonProperty _member;
    public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
    [CompilerGeneratedAttribute]

private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    
public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
    public JsonLinqContract(Type underlyingType);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
    [CompilerGeneratedAttribute]

private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<Required> <ItemRequired>k__BackingField;
    [CompilerGeneratedAttribute]

private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]

private ExtensionDataSetter <ExtensionDataSetter>k__BackingField;
    [CompilerGeneratedAttribute]

private ExtensionDataGetter <ExtensionDataGetter>k__BackingField;
    
internal bool ExtensionDataIsJToken;
    
private Nullable`1<bool> _hasRequiredOrDefaultValueProperties;
    
private ConstructorInfo _parametrizedConstructor;
    
private ConstructorInfo _overrideConstructor;
    
private ObjectConstructor`1<object> _overrideCreator;
    
private ObjectConstructor`1<object> _parameterizedCreator;
    
private JsonPropertyCollection _creatorParameters;
    
private Type _extensionDataValueType;
    
public MemberSerialization MemberSerialization { get; public set; }
    
public Nullable`1<Required> ItemRequired { get; public set; }
    
public JsonPropertyCollection Properties { get; private set; }
    [ObsoleteAttribute("ConstructorParameters is obsolete. Use CreatorParameters instead.")]

public JsonPropertyCollection ConstructorParameters { get; }
    
public JsonPropertyCollection CreatorParameters { get; }
    [ObsoleteAttribute("OverrideConstructor is obsolete. Use OverrideCreator instead.")]

public ConstructorInfo OverrideConstructor { get; public set; }
    [ObsoleteAttribute("ParametrizedConstructor is obsolete. Use OverrideCreator instead.")]

public ConstructorInfo ParametrizedConstructor { get; public set; }
    
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    
public ExtensionDataSetter ExtensionDataSetter { get; public set; }
    
public ExtensionDataGetter ExtensionDataGetter { get; public set; }
    
public Type ExtensionDataValueType { get; public set; }
    
internal bool HasRequiredOrDefaultValueProperties { get; }
    public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public Nullable`1<Required> get_ItemRequired();
    [CompilerGeneratedAttribute]
public void set_ItemRequired(Nullable`1<Required> value);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(JsonPropertyCollection value);
    public JsonPropertyCollection get_ConstructorParameters();
    public JsonPropertyCollection get_CreatorParameters();
    public ConstructorInfo get_OverrideConstructor();
    public void set_OverrideConstructor(ConstructorInfo value);
    public ConstructorInfo get_ParametrizedConstructor();
    public void set_ParametrizedConstructor(ConstructorInfo value);
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    [CompilerGeneratedAttribute]
public ExtensionDataSetter get_ExtensionDataSetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataSetter(ExtensionDataSetter value);
    [CompilerGeneratedAttribute]
public ExtensionDataGetter get_ExtensionDataGetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataGetter(ExtensionDataGetter value);
    public Type get_ExtensionDataValueType();
    public void set_ExtensionDataValueType(Type value);
    internal bool get_HasRequiredOrDefaultValueProperties();
    internal object GetUninitializedObject();
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]

private PrimitiveTypeCode <TypeCode>k__BackingField;
    
private static Dictionary`2<Type, ReadType> ReadTypeMap;
    
internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonProperty : object {
    
internal Nullable`1<Required> _required;
    
internal bool _hasExplicitDefaultValue;
    
private object _defaultValue;
    
private bool _hasGeneratedDefaultValue;
    
private string _propertyName;
    
internal bool _skipPropertyNameEscape;
    
private Type _propertyType;
    [CompilerGeneratedAttribute]

private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]

private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]

private string <UnderlyingName>k__BackingField;
    [CompilerGeneratedAttribute]

private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]

private IAttributeProvider <AttributeProvider>k__BackingField;
    [CompilerGeneratedAttribute]

private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]

private JsonConverter <MemberConverter>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <HasMemberAttribute>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]

private Predicate`1<object> <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]

private Predicate`1<object> <ShouldDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]

private Predicate`1<object> <GetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]

private Action`2<object, object> <SetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]

private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]

private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    
internal JsonContract PropertyContract { get; internal set; }
    
public string PropertyName { get; public set; }
    
public Type DeclaringType { get; public set; }
    
public Nullable`1<int> Order { get; public set; }
    
public string UnderlyingName { get; public set; }
    
public IValueProvider ValueProvider { get; public set; }
    
public IAttributeProvider AttributeProvider { get; public set; }
    
public Type PropertyType { get; public set; }
    
public JsonConverter Converter { get; public set; }
    
public JsonConverter MemberConverter { get; public set; }
    
public bool Ignored { get; public set; }
    
public bool Readable { get; public set; }
    
public bool Writable { get; public set; }
    
public bool HasMemberAttribute { get; public set; }
    
public object DefaultValue { get; public set; }
    
public Required Required { get; public set; }
    
public Nullable`1<bool> IsReference { get; public set; }
    
public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    
public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    
public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    
public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    
public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    
public Predicate`1<object> ShouldSerialize { get; public set; }
    
public Predicate`1<object> ShouldDeserialize { get; public set; }
    
public Predicate`1<object> GetIsSpecified { get; public set; }
    
public Action`2<object, object> SetIsSpecified { get; public set; }
    
public JsonConverter ItemConverter { get; public set; }
    
public Nullable`1<bool> ItemIsReference { get; public set; }
    
public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    
public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UnderlyingName();
    [CompilerGeneratedAttribute]
public void set_UnderlyingName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public IAttributeProvider get_AttributeProvider();
    [CompilerGeneratedAttribute]
public void set_AttributeProvider(IAttributeProvider value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
public JsonConverter get_MemberConverter();
    [CompilerGeneratedAttribute]
public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetResolvedDefaultValue();
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
public void set_ShouldDeserialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_GetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_GetIsSpecified(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_SetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_SetIsSpecified(Action`2<object, object> value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    internal void WritePropertyName(JsonWriter writer);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    
private Type _type;
    
private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetValue(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
    
private ErrorContext _currentErrorContext;
    
private BidirectionalDictionary`2<string, object> _mappings;
    
internal JsonSerializer Serializer;
    
internal ITraceWriter TraceWriter;
    
protected JsonSerializerProxy InternalSerializer;
    
internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings { get; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings();
    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error);
    protected void ClearErrorContext();
    protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    private JsonContract GetContractSafe(Type type);
    public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent);
    private JsonSerializerProxy GetInternalSerializer();
    private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName);
    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract);
    private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id);
    private bool HasNoDefinedType(JsonContract contract);
    private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target);
    private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue);
    private void AddReference(JsonReader reader, string id, object value);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool ShouldSetPropertyValue(JsonProperty property, object value);
    private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator);
    private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator);
    private void OnDeserializing(JsonReader reader, JsonContract contract, object value);
    private void OnDeserialized(JsonReader reader, JsonContract contract, object value);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id);
    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message);
    private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id);
    internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id);
    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue);
    private List`1<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id);
    private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target);
    private bool CheckPropertyName(JsonReader reader, string memberName);
    private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o);
    private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader);
    private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue);
    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties);
    private void HandleError(JsonReader reader, bool readPastError, int initialDepth);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    
private Type _rootType;
    
private int _rootLevel;
    
private List`1<object> _serializeStack;
    public JsonSerializerInternalWriter(JsonSerializer serializer);
    public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    private JsonContract GetContractSafe(object value);
    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteProperty(object memberValue, JsonProperty property);
    private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void WriteReference(JsonWriter writer, object value);
    private string GetReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void OnSerializing(JsonWriter writer, JsonContract contract, object value);
    private void OnSerialized(JsonWriter writer, JsonContract contract, object value);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue);
    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices);
    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteDynamicProperty(object memberValue);
    private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target);
    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    
private JsonSerializerInternalReader _serializerReader;
    
private JsonSerializerInternalWriter _serializerWriter;
    
private JsonSerializer _serializer;
    
public IReferenceResolver ReferenceResolver { get; public set; }
    
public ITraceWriter TraceWriter { get; public set; }
    
public IEqualityComparer EqualityComparer { get; public set; }
    
public JsonConverterCollection Converters { get; }
    
public DefaultValueHandling DefaultValueHandling { get; public set; }
    
public IContractResolver ContractResolver { get; public set; }
    
public MissingMemberHandling MissingMemberHandling { get; public set; }
    
public NullValueHandling NullValueHandling { get; public set; }
    
public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    
public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    
public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    
public TypeNameHandling TypeNameHandling { get; public set; }
    
public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    
public ConstructorHandling ConstructorHandling { get; public set; }
    
public SerializationBinder Binder { get; public set; }
    
public StreamingContext Context { get; public set; }
    
public Formatting Formatting { get; public set; }
    
public DateFormatHandling DateFormatHandling { get; public set; }
    
public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    
public DateParseHandling DateParseHandling { get; public set; }
    
public FloatFormatHandling FloatFormatHandling { get; public set; }
    
public FloatParseHandling FloatParseHandling { get; public set; }
    
public StringEscapeHandling StringEscapeHandling { get; public set; }
    
public string DateFormatString { get; public set; }
    
public CultureInfo Culture { get; public set; }
    
public Nullable`1<int> MaxDepth { get; public set; }
    
public bool CheckAdditionalContent { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual ITraceWriter get_TraceWriter();
    public virtual void set_TraceWriter(ITraceWriter value);
    public virtual IEqualityComparer get_EqualityComparer();
    public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal JsonSerializerInternalBase GetInternalSerializer();
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
    public JsonStringContract(Type underlyingType);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Serialization.JsonTypeReflector : object {
    
private static Nullable`1<bool> _dynamicCodeGeneration;
    
private static Nullable`1<bool> _fullyTrusted;
    
public static string IdPropertyName;
    
public static string RefPropertyName;
    
public static string TypePropertyName;
    
public static string ValuePropertyName;
    
public static string ArrayValuesPropertyName;
    
public static string ShouldSerializePrefix;
    
public static string SpecifiedPostfix;
    
private static ThreadSafeStore`2<Type, Func`2<Object[], JsonConverter>> JsonConverterCreatorCache;
    
private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    
private static ReflectionObject _metadataTypeAttributeReflectionObject;
    
public static bool DynamicCodeGeneration { get; }
    
public static bool FullyTrusted { get; }
    
public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static T GetCachedAttribute(object attributeProvider);
    public static DataContractAttribute GetDataContractAttribute(Type type);
    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute);
    public static JsonConverter GetJsonConverter(object attributeProvider);
    public static JsonConverter CreateJsonConverterInstance(Type converterType, Object[] converterArgs);
    private static Func`2<Object[], JsonConverter> GetJsonConverterCreator(Type converterType);
    public static TypeConverter GetTypeConverter(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    private static T GetAttribute(Type type);
    private static T GetAttribute(MemberInfo memberInfo);
    public static T GetAttribute(object provider);
    public static bool get_DynamicCodeGeneration();
    public static bool get_FullyTrusted();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
    
private Queue`1<string> _traceMessages;
    [CompilerGeneratedAttribute]

private TraceLevel <LevelFilter>k__BackingField;
    
public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    public IEnumerable`1<string> GetTraceMessages();
    public virtual string ToString();
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.OnErrorAttribute : Attribute {
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ReflectionAttributeProvider : object {
    
private object _attributeProvider;
    public ReflectionAttributeProvider(object attributeProvider);
    public sealed virtual IList`1<Attribute> GetAttributes(bool inherit);
    public sealed virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
    
private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.ResolverContractKey : ValueType {
    
private Type _resolverType;
    
private Type _contractType;
    public ResolverContractKey(Type resolverType, Type contractType);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ResolverContractKey other);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
    public SerializationCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public class Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
    public SerializationErrorCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context, ErrorContext errorContext);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
    
private JsonReader _innerReader;
    
private JsonTextWriter _textWriter;
    
private StringWriter _sw;
    
public int Depth { get; }
    
public string Path { get; }
    
public char QuoteChar { get; protected internal set; }
    
public JsonToken TokenType { get; }
    
public object Value { get; }
    
public Type ValueType { get; }
    
private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    
private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public TraceJsonReader(JsonReader innerReader);
    public string GetDeserializedJsonMessage();
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual void Close();
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
[PreserveAttribute]
internal class Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
    
private JsonWriter _innerWriter;
    
private JsonTextWriter _textWriter;
    
private StringWriter _sw;
    public TraceJsonWriter(JsonWriter innerWriter);
    public string GetSerializedJsonMessage();
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(double value);
    public virtual void WriteUndefined();
    public virtual void WriteNull();
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteComment(string text);
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteRawValue(string json);
    public virtual void WriteRaw(string json);
    public virtual void Close();
    public virtual void Flush();
}
[PreserveAttribute]
public class Newtonsoft.Json.Shims.PreserveAttribute : Attribute {
}
[PreserveAttribute]
public enum Newtonsoft.Json.StringEscapeHandling : Enum {
    
public int value__;
    
public static StringEscapeHandling Default;
    
public static StringEscapeHandling EscapeNonAscii;
    
public static StringEscapeHandling EscapeHtml;
}
[FlagsAttribute]
[PreserveAttribute]
public enum Newtonsoft.Json.TypeNameHandling : Enum {
    
public int value__;
    
public static TypeNameHandling None;
    
public static TypeNameHandling Objects;
    
public static TypeNameHandling Arrays;
    
public static TypeNameHandling All;
    
public static TypeNameHandling Auto;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.Base64Encoder : object {
    
private static int Base64LineSize;
    
private static int LineSizeInBytes;
    
private Char[] _charsLine;
    
private TextWriter _writer;
    
private Byte[] _leftOverBytes;
    
private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    public void Encode(Byte[] buffer, int index, int count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
    
private IDictionary`2<TFirst, TSecond> _firstToSecond;
    
private IDictionary`2<TSecond, TFirst> _secondToFirst;
    
private string _duplicateFirstErrorMessage;
    
private string _duplicateSecondErrorMessage;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage);
    public void Set(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.BufferUtils : object {
    public static Char[] RentBuffer(IArrayPool`1<char> bufferPool, int minSize);
    public static void ReturnBuffer(IArrayPool`1<char> bufferPool, Char[] buffer);
    public static Char[] EnsureBufferSize(IArrayPool`1<char> bufferPool, int size, Char[] buffer);
}
[ExtensionAttribute]
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.CollectionUtils : object {
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable collection);
    public static bool IsDictionaryType(Type type);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(List`1<T> list, T value, IEqualityComparer comparer);
    [ExtensionAttribute]
public static int IndexOfReference(List`1<T> list, T item);
    private static IList`1<int> GetDimensions(IList values, int dimensionsCount);
    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices);
    private static object JaggedArrayGetValue(IList values, Int32[] indices);
    public static Array ToMultidimensionalArray(IList values, Type type, int rank);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
    
private IList _list;
    
private ICollection`1<T> _genericCollection;
    
private object _syncRoot;
    
public int Count { get; }
    
public bool IsReadOnly { get; }
    
private bool System.Collections.IList.IsFixedSize { get; }
    
private object System.Collections.IList.Item { get; private set; }
    
private bool System.Collections.ICollection.IsSynchronized { get; }
    
private object System.Collections.ICollection.SyncRoot { get; }
    
public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void VerifyValueType(object value);
    private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.ConvertUtils : object {
    
private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    
private static TypeInformation[] PrimitiveTypeCodes;
    
private static ThreadSafeStore`2<TypeConvertKey, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static TypeInformation GetTypeInformation(IConvertible convertable);
    public static bool IsConvertible(Type t);
    public static TimeSpan ParseTimeSpan(string input);
    private static Func`2<object, object> CreateCastConverter(TypeConvertKey t);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value);
    private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    internal static TypeConverter GetConverter(Type t);
    public static bool VersionTryParse(string input, Version& result);
    public static bool IsInteger(object value);
    public static ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value);
    public static ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value);
    public static bool TryConvertGuid(string s, Guid& g);
    public static int HexTextToInt(Char[] text, int start, int end);
    private static int HexCharToInt(char ch);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
    
public int Year;
    
public int Month;
    
public int Day;
    
public int Hour;
    
public int Minute;
    
public int Second;
    
public int Fraction;
    
public int ZoneHour;
    
public int ZoneMinute;
    
public ParserTimeZone Zone;
    
private Char[] _text;
    
private int _end;
    
private static Int32[] Power10;
    
private static int Lzyyyy;
    
private static int Lzyyyy_;
    
private static int Lzyyyy_MM;
    
private static int Lzyyyy_MM_;
    
private static int Lzyyyy_MM_dd;
    
private static int Lzyyyy_MM_ddT;
    
private static int LzHH;
    
private static int LzHH_;
    
private static int LzHH_mm;
    
private static int LzHH_mm_;
    
private static int LzHH_mm_ss;
    
private static int Lz_;
    
private static int Lz_zz;
    
private static short MaxFractionDigits;
    private static DateTimeParser();
    public bool Parse(Char[] text, int startIndex, int length);
    private bool ParseDate(int start);
    private bool ParseTimeAndZoneAndWhitespace(int start);
    private bool ParseTime(Int32& start);
    private bool ParseZone(int start);
    private bool Parse4Digit(int start, Int32& num);
    private bool Parse2Digit(int start, Int32& num);
    private bool ParseChar(int start, char ch);
}
[ExtensionAttribute]
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.DateTimeUtils : object {
    
internal static long InitialJavaScriptDateTicks;
    
private static string IsoDateFormat;
    
private static int DaysPer100Years;
    
private static int DaysPer400Years;
    
private static int DaysPer4Years;
    
private static int DaysPerYear;
    
private static long TicksPerDay;
    
private static Int32[] DaysToMonth365;
    
private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversialTicksToJavaScriptTicks(long universialTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    internal static bool TryParseDateTimeOffsetIso(StringReference text, DateTimeOffset& dt);
    private static DateTime CreateDateTime(DateTimeParser dateTimeParser);
    internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    internal static bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryParseMicrosoftDate(StringReference text, Int64& ticks, TimeSpan& offset, DateTimeKind& kind);
    private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, DateTimeOffset& dt);
    private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryReadOffset(StringReference offsetText, int startIndex, TimeSpan& offset);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
    
private IDictionary _dictionary;
    
private IDictionary`2<TKey, TValue> _genericDictionary;
    
private object _syncRoot;
    
public ICollection`1<TKey> Keys { get; }
    
public ICollection`1<TValue> Values { get; }
    
public TValue Item { get; public set; }
    
public int Count { get; }
    
public bool IsReadOnly { get; }
    
private object System.Collections.IDictionary.Item { get; private set; }
    
private bool System.Collections.IDictionary.IsFixedSize { get; }
    
private ICollection System.Collections.IDictionary.Keys { get; }
    
private ICollection System.Collections.IDictionary.Values { get; }
    
private bool System.Collections.ICollection.IsSynchronized { get; }
    
private object System.Collections.ICollection.SyncRoot { get; }
    
public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.EnumUtils : object {
    
private static ThreadSafeStore`2<Type, BidirectionalDictionary`2<string, string>> EnumMemberNamesPerType;
    private static EnumUtils();
    private static BidirectionalDictionary`2<string, string> InitializeEnumType(Type type);
    public static IList`1<T> GetFlagsValues(T value);
    public static IList`1<EnumValue`1<ulong>> GetNamesAndValues();
    public static IList`1<EnumValue`1<TUnderlyingType>> GetNamesAndValues(Type enumType);
    public static IList`1<object> GetValues(Type enumType);
    public static IList`1<string> GetNames(Type enumType);
    public static object ParseEnumName(string enumText, bool isNullable, Type t);
    public static string ToEnumName(Type enumType, string enumText, bool camelCaseText);
    private static string ResolvedEnumName(BidirectionalDictionary`2<string, string> map, string enumText);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.EnumValue`1 : object {
    
private string _name;
    
private T _value;
    
public string Name { get; }
    
public T Value { get; }
    public EnumValue`1(string name, T value);
    public string get_Name();
    public T get_Value();
}
[PreserveAttribute]
internal interface Newtonsoft.Json.Utilities.IWrappedCollection {
    
public object UnderlyingCollection { get; }
    public abstract virtual object get_UnderlyingCollection();
}
[PreserveAttribute]
internal interface Newtonsoft.Json.Utilities.IWrappedDictionary {
    
public object UnderlyingDictionary { get; }
    public abstract virtual object get_UnderlyingDictionary();
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.JavaScriptUtils : object {
    
internal static Boolean[] SingleQuoteCharEscapeFlags;
    
internal static Boolean[] DoubleQuoteCharEscapeFlags;
    
internal static Boolean[] HtmlCharEscapeFlags;
    
private static int UnicodeTextLength;
    
private static string EscapedUnicodeText;
    private static JavaScriptUtils();
    public static Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar);
    public static bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags);
    public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool`1<char> bufferPool, Char[]& writeBuffer);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.JsonTokenUtils : object {
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    
private static LateBoundReflectionDelegateFactory _instance;
    
internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.MathUtils : object {
    public static int IntLength(ulong i);
    public static char IntToHex(int n);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
    public static bool ApproxEquals(double d1, double d2);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
    public static bool ValueEquals(object objA, object objB);
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
    internal static string FormatValueForPrint(object value);
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Utilities.ParseResult : Enum {
    
public int value__;
    
public static ParseResult None;
    
public static ParseResult Success;
    
public static ParseResult Overflow;
    
public static ParseResult Invalid;
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
    
public int value__;
    
public static ParserTimeZone Unspecified;
    
public static ParserTimeZone Utc;
    
public static ParserTimeZone LocalWestOfUtc;
    
public static ParserTimeZone LocalEastOfUtc;
}
[PreserveAttribute]
internal enum Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
    
public int value__;
    
public static PrimitiveTypeCode Empty;
    
public static PrimitiveTypeCode Object;
    
public static PrimitiveTypeCode Char;
    
public static PrimitiveTypeCode CharNullable;
    
public static PrimitiveTypeCode Boolean;
    
public static PrimitiveTypeCode BooleanNullable;
    
public static PrimitiveTypeCode SByte;
    
public static PrimitiveTypeCode SByteNullable;
    
public static PrimitiveTypeCode Int16;
    
public static PrimitiveTypeCode Int16Nullable;
    
public static PrimitiveTypeCode UInt16;
    
public static PrimitiveTypeCode UInt16Nullable;
    
public static PrimitiveTypeCode Int32;
    
public static PrimitiveTypeCode Int32Nullable;
    
public static PrimitiveTypeCode Byte;
    
public static PrimitiveTypeCode ByteNullable;
    
public static PrimitiveTypeCode UInt32;
    
public static PrimitiveTypeCode UInt32Nullable;
    
public static PrimitiveTypeCode Int64;
    
public static PrimitiveTypeCode Int64Nullable;
    
public static PrimitiveTypeCode UInt64;
    
public static PrimitiveTypeCode UInt64Nullable;
    
public static PrimitiveTypeCode Single;
    
public static PrimitiveTypeCode SingleNullable;
    
public static PrimitiveTypeCode Double;
    
public static PrimitiveTypeCode DoubleNullable;
    
public static PrimitiveTypeCode DateTime;
    
public static PrimitiveTypeCode DateTimeNullable;
    
public static PrimitiveTypeCode DateTimeOffset;
    
public static PrimitiveTypeCode DateTimeOffsetNullable;
    
public static PrimitiveTypeCode Decimal;
    
public static PrimitiveTypeCode DecimalNullable;
    
public static PrimitiveTypeCode Guid;
    
public static PrimitiveTypeCode GuidNullable;
    
public static PrimitiveTypeCode TimeSpan;
    
public static PrimitiveTypeCode TimeSpanNullable;
    
public static PrimitiveTypeCode BigInteger;
    
public static PrimitiveTypeCode BigIntegerNullable;
    
public static PrimitiveTypeCode Uri;
    
public static PrimitiveTypeCode String;
    
public static PrimitiveTypeCode Bytes;
    
public static PrimitiveTypeCode DBNull;
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.PropertyNameTable : object {
    
private static int HashCodeRandomizer;
    
private int _count;
    
private Entry[] _entries;
    
private int _mask;
    private static PropertyNameTable();
    public string Get(Char[] key, int start, int length);
    public string Add(string key);
    private string AddEntry(string str, int hashCode);
    private void Grow();
    private static bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length);
}
[PreserveAttribute]
internal abstract class Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.ReflectionMember : object {
    [CompilerGeneratedAttribute]

private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]

private Func`2<object, object> <Getter>k__BackingField;
    [CompilerGeneratedAttribute]

private Action`2<object, object> <Setter>k__BackingField;
    
public Type MemberType { get; public set; }
    
public Func`2<object, object> Getter { get; public set; }
    
public Action`2<object, object> Setter { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Action`2<object, object> value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.ReflectionObject : object {
    [CompilerGeneratedAttribute]

private ObjectConstructor`1<object> <Creator>k__BackingField;
    [CompilerGeneratedAttribute]

private IDictionary`2<string, ReflectionMember> <Members>k__BackingField;
    
public ObjectConstructor`1<object> Creator { get; private set; }
    
public IDictionary`2<string, ReflectionMember> Members { get; private set; }
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_Creator();
    [CompilerGeneratedAttribute]
private void set_Creator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ReflectionMember> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(IDictionary`2<string, ReflectionMember> value);
    public object GetValue(object target, string member);
    public void SetValue(object target, string member, object value);
    public Type GetType(string member);
    public static ReflectionObject Create(Type t, String[] memberNames);
    public static ReflectionObject Create(Type t, MethodBase creator, String[] memberNames);
}
[ExtensionAttribute]
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.ReflectionUtils : object {
    
public static Type[] EmptyTypes;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetBaseDefinition(PropertyInfo propertyInfo);
    public static bool IsPublic(PropertyInfo property);
    public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static Type EnsureNotNullableType(Type t);
    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsIndexedProperty(MemberInfo member);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit);
    public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, String& typeName, String& assemblyName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr);
    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method);
    public static object GetDefaultValue(Type type);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.StringBuffer : ValueType {
    
private Char[] _buffer;
    
private int _position;
    
public int Position { get; public set; }
    
public bool IsEmpty { get; }
    
public Char[] InternalBuffer { get; }
    public StringBuffer(IArrayPool`1<char> bufferPool, int initalSize);
    private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(IArrayPool`1<char> bufferPool, char value);
    public void Append(IArrayPool`1<char> bufferPool, Char[] buffer, int startIndex, int count);
    public void Clear(IArrayPool`1<char> bufferPool);
    private void EnsureSize(IArrayPool`1<char> bufferPool, int appendLength);
    public virtual string ToString();
    public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[DefaultMemberAttribute("Item")]
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.StringReference : ValueType {
    
private Char[] _chars;
    
private int _startIndex;
    
private int _length;
    
public char Item { get; }
    
public Char[] Chars { get; }
    
public int StartIndex { get; }
    
public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public char get_Item(int i);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
[ExtensionAttribute]
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.StringReferenceExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(StringReference s, char c, int startIndex, int length);
    [ExtensionAttribute]
public static bool StartsWith(StringReference s, string text);
    [ExtensionAttribute]
public static bool EndsWith(StringReference s, string text);
}
[ExtensionAttribute]
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.StringUtils : object {
    
public static string CarriageReturnLineFeed;
    
public static string Empty;
    
public static char CarriageReturn;
    
public static char LineFeed;
    
public static char Tab;
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
private static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool IsWhiteSpace(string s);
    public static string NullEmptyString(string s);
    public static StringWriter CreateStringWriter(int capacity);
    public static Nullable`1<int> GetLength(string value);
    public static void ToCharAsUnicode(char c, Char[] buffer);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
    public static string ToCamelCase(string s);
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
    [ExtensionAttribute]
public static bool StartsWith(string source, char value);
    [ExtensionAttribute]
public static bool EndsWith(string source, char value);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
    
private object _lock;
    
private Dictionary`2<TKey, TValue> _store;
    
private Func`2<TKey, TValue> _creator;
    [PreserveAttribute]
public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    [PreserveAttribute]
public TValue Get(TKey key);
    [PreserveAttribute]
private TValue AddValue(TKey key);
}
[ExtensionAttribute]
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.TypeExtensions : object {
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName);
    [ExtensionAttribute]
public static bool ImplementInterface(Type type, Type interfaceType);
}
[PreserveAttribute]
internal class Newtonsoft.Json.Utilities.TypeInformation : object {
    [CompilerGeneratedAttribute]

private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]

private PrimitiveTypeCode <TypeCode>k__BackingField;
    
public Type Type { get; public set; }
    
public PrimitiveTypeCode TypeCode { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
public void set_TypeCode(PrimitiveTypeCode value);
}
[PreserveAttribute]
internal static class Newtonsoft.Json.Utilities.ValidationUtils : object {
    public static void ArgumentNotNull(object value, string parameterName);
}
[PreserveAttribute]
public enum Newtonsoft.Json.WriteState : Enum {
    
public int value__;
    
public static WriteState Error;
    
public static WriteState Closed;
    
public static WriteState Object;
    
public static WriteState Array;
    
public static WriteState Constructor;
    
public static WriteState Property;
    
public static WriteState Start;
}
[PreserveAttribute]
public class System.ComponentModel.AddingNewEventArgs : object {
    [CompilerGeneratedAttribute]

private object <NewObject>k__BackingField;
    
public object NewObject { get; public set; }
    public AddingNewEventArgs(object newObject);
    [CompilerGeneratedAttribute]
public object get_NewObject();
    [CompilerGeneratedAttribute]
public void set_NewObject(object value);
}
[PreserveAttribute]
public class System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
    public AddingNewEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AddingNewEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public interface System.ComponentModel.INotifyCollectionChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
[PreserveAttribute]
public interface System.ComponentModel.INotifyPropertyChanging {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
}
[PreserveAttribute]
public enum System.ComponentModel.NotifyCollectionChangedAction : Enum {
    
public int value__;
    
public static NotifyCollectionChangedAction Add;
    
public static NotifyCollectionChangedAction Remove;
    
public static NotifyCollectionChangedAction Replace;
    
public static NotifyCollectionChangedAction Move;
    
public static NotifyCollectionChangedAction Reset;
}
[PreserveAttribute]
public class System.ComponentModel.NotifyCollectionChangedEventArgs : object {
    [CompilerGeneratedAttribute]

private NotifyCollectionChangedAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]

private IList <NewItems>k__BackingField;
    [CompilerGeneratedAttribute]

private int <NewStartingIndex>k__BackingField;
    [CompilerGeneratedAttribute]

private IList <OldItems>k__BackingField;
    [CompilerGeneratedAttribute]

private int <OldStartingIndex>k__BackingField;
    
internal NotifyCollectionChangedAction Action { get; internal set; }
    
internal IList NewItems { get; internal set; }
    
internal int NewStartingIndex { get; internal set; }
    
internal IList OldItems { get; internal set; }
    
internal int OldStartingIndex { get; internal set; }
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index);
    [CompilerGeneratedAttribute]
internal NotifyCollectionChangedAction get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(NotifyCollectionChangedAction value);
    [CompilerGeneratedAttribute]
internal IList get_NewItems();
    [CompilerGeneratedAttribute]
internal void set_NewItems(IList value);
    [CompilerGeneratedAttribute]
internal int get_NewStartingIndex();
    [CompilerGeneratedAttribute]
internal void set_NewStartingIndex(int value);
    [CompilerGeneratedAttribute]
internal IList get_OldItems();
    [CompilerGeneratedAttribute]
internal void set_OldItems(IList value);
    [CompilerGeneratedAttribute]
internal int get_OldStartingIndex();
    [CompilerGeneratedAttribute]
internal void set_OldStartingIndex(int value);
}
[PreserveAttribute]
public class System.ComponentModel.NotifyCollectionChangedEventHandler : MulticastDelegate {
    public NotifyCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PreserveAttribute]
public class System.ComponentModel.PropertyChangingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]

private string <PropertyName>k__BackingField;
    
public string PropertyName { get; public set; }
    public PropertyChangingEventArgs(string propertyName);
    [CompilerGeneratedAttribute]
public virtual string get_PropertyName();
    [CompilerGeneratedAttribute]
public virtual void set_PropertyName(string value);
}
[PreserveAttribute]
public class System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
    public PropertyChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
