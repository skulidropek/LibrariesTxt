internal static class Consts : object {
    
public static string MonoVersion;
    
public static string MonoCompany;
    
public static string MonoProduct;
    
public static string MonoCopyright;
    
public static int MonoCorlibVersion;
    
public static string FxVersion;
    
public static string FxFileVersion;
    
public static string EnvironmentVersion;
    
public static string VsVersion;
    
public static string VsFileVersion;
    
private static string PublicKeyToken;
    
public static string AssemblyI18N;
    
public static string AssemblyMicrosoft_JScript;
    
public static string AssemblyMicrosoft_VisualStudio;
    
public static string AssemblyMicrosoft_VisualStudio_Web;
    
public static string AssemblyMicrosoft_VSDesigner;
    
public static string AssemblyMono_Http;
    
public static string AssemblyMono_Posix;
    
public static string AssemblyMono_Security;
    
public static string AssemblyMono_Messaging_RabbitMQ;
    
public static string AssemblyCorlib;
    
public static string AssemblySystem;
    
public static string AssemblySystem_Data;
    
public static string AssemblySystem_Design;
    
public static string AssemblySystem_DirectoryServices;
    
public static string AssemblySystem_Drawing;
    
public static string AssemblySystem_Drawing_Design;
    
public static string AssemblySystem_Messaging;
    
public static string AssemblySystem_Security;
    
public static string AssemblySystem_ServiceProcess;
    
public static string AssemblySystem_Web;
    
public static string AssemblySystem_Windows_Forms;
    
public static string AssemblySystem_2_0;
    
public static string AssemblySystemCore_3_5;
    
public static string AssemblySystem_Core;
    
public static string WindowsBase_3_0;
    
public static string AssemblyWindowsBase;
    
public static string AssemblyPresentationCore_3_5;
    
public static string AssemblyPresentationCore_4_0;
    
public static string AssemblyPresentationFramework_3_5;
    
public static string AssemblySystemServiceModel_3_0;
}
internal class Locale : object {
    public static string GetText(string msg);
    public static string GetText(string fmt, Object[] args);
}
internal class SR : object {
    
public static string CantTellPrinterName;
    
public static string CantChangeImmutableObjects;
    
public static string CantMakeIconTransparent;
    
public static string ColorNotSystemColor;
    
public static string DotNET_ComponentType;
    
public static string GdiplusAborted;
    
public static string GdiplusAccessDenied;
    
public static string GdiplusCannotCreateGraphicsFromIndexedPixelFormat;
    
public static string GdiplusCannotSetPixelFromIndexedPixelFormat;
    
public static string GdiplusDestPointsInvalidParallelogram;
    
public static string GdiplusDestPointsInvalidLength;
    
public static string GdiplusFileNotFound;
    
public static string GdiplusFontFamilyNotFound;
    
public static string GdiplusFontStyleNotFound;
    
public static string GdiplusGenericError;
    
public static string GdiplusInsufficientBuffer;
    
public static string GdiplusInvalidParameter;
    
public static string GdiplusInvalidRectangle;
    
public static string GdiplusInvalidSize;
    
public static string GdiplusOutOfMemory;
    
public static string GdiplusNotImplemented;
    
public static string GdiplusNotInitialized;
    
public static string GdiplusNotTrueTypeFont;
    
public static string GdiplusNotTrueTypeFont_NoName;
    
public static string GdiplusObjectBusy;
    
public static string GdiplusOverflow;
    
public static string GdiplusPropertyNotFoundError;
    
public static string GdiplusPropertyNotSupportedError;
    
public static string GdiplusUnknown;
    
public static string GdiplusUnknownImageFormat;
    
public static string GdiplusUnsupportedGdiplusVersion;
    
public static string GdiplusWrongState;
    
public static string GlobalAssemblyCache;
    
public static string GraphicsBufferCurrentlyBusy;
    
public static string GraphicsBufferQueryFail;
    
public static string ToolboxItemLocked;
    
public static string ToolboxItemInvalidPropertyType;
    
public static string ToolboxItemValueNotSerializable;
    
public static string ToolboxItemInvalidKey;
    
public static string IllegalState;
    
public static string InterpolationColorsColorBlendNotSet;
    
public static string InterpolationColorsCommon;
    
public static string InterpolationColorsInvalidColorBlendObject;
    
public static string InterpolationColorsInvalidStartPosition;
    
public static string InterpolationColorsInvalidEndPosition;
    
public static string InterpolationColorsLength;
    
public static string InterpolationColorsLengthsDiffer;
    
public static string InvalidArgument;
    
public static string InvalidBoundArgument;
    
public static string InvalidClassName;
    
public static string InvalidColor;
    
public static string InvalidDashPattern;
    
public static string InvalidEx2BoundArgument;
    
public static string InvalidFrame;
    
public static string InvalidGDIHandle;
    
public static string InvalidImage;
    
public static string InvalidLowBoundArgumentEx;
    
public static string InvalidPermissionLevel;
    
public static string InvalidPermissionState;
    
public static string InvalidPictureType;
    
public static string InvalidPrinterException_InvalidPrinter;
    
public static string InvalidPrinterException_NoDefaultPrinter;
    
public static string InvalidPrinterHandle;
    
public static string ValidRangeX;
    
public static string ValidRangeY;
    
public static string NativeHandle0;
    
public static string NoDefaultPrinter;
    
public static string NotImplemented;
    
public static string PDOCbeginPrintDescr;
    
public static string PDOCdocumentNameDescr;
    
public static string PDOCdocumentPageSettingsDescr;
    
public static string PDOCendPrintDescr;
    
public static string PDOCoriginAtMarginsDescr;
    
public static string PDOCprintControllerDescr;
    
public static string PDOCprintPageDescr;
    
public static string PDOCprinterSettingsDescr;
    
public static string PDOCqueryPageSettingsDescr;
    
public static string PrintDocumentDesc;
    
public static string PrintingPermissionBadXml;
    
public static string PrintingPermissionAttributeInvalidPermissionLevel;
    
public static string PropertyValueInvalidEntry;
    
public static string PSizeNotCustom;
    
public static string ResourceNotFound;
    
public static string TargetNotPrintingPermission;
    
public static string TextParseFailedFormat;
    
public static string TriStateCompareError;
    
public static string toStringIcon;
    
public static string toStringNone;
    
public static string DCTypeInvalid;
    
public static string InvalidEnumArgument;
    
public static string ConvertInvalidPrimitive;
    
public static string LibgdiplusNotFound;
    public static string Format(string format, Object[] args);
}
internal class System.Drawing.AnimateEventArgs : EventArgs {
    
private int frameCount;
    
private int activeFrame;
    
private Thread thread;
    
public Thread RunThread { get; public set; }
    public AnimateEventArgs(Image image);
    public Thread get_RunThread();
    public void set_RunThread(Thread value);
    public int GetNextFrame();
}
internal static class System.Drawing.AssemblyRef : object {
    
public static string SystemDrawingDesign;
    
public static string SystemDesign;
    
public static string SystemWindowsForms;
}
[ComVisibleAttribute("True")]
[EditorAttribute("System.Drawing.Design.BitmapEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
public class System.Drawing.Bitmap : Image {
    internal Bitmap(IntPtr ptr);
    internal Bitmap(IntPtr ptr, Stream stream);
    public Bitmap(int width, int height);
    public Bitmap(int width, int height, Graphics g);
    public Bitmap(int width, int height, PixelFormat format);
    public Bitmap(Image original);
    public Bitmap(Stream stream);
    public Bitmap(string filename);
    public Bitmap(Image original, Size newSize);
    public Bitmap(Stream stream, bool useIcm);
    public Bitmap(string filename, bool useIcm);
    public Bitmap(Type type, string resource);
    public Bitmap(Image original, int width, int height);
    public Bitmap(int width, int height, int stride, PixelFormat format, IntPtr scan0);
    private Bitmap(SerializationInfo info, StreamingContext context);
    public Color GetPixel(int x, int y);
    public void SetPixel(int x, int y, Color color);
    public Bitmap Clone(Rectangle rect, PixelFormat format);
    public Bitmap Clone(RectangleF rect, PixelFormat format);
    public static Bitmap FromHicon(IntPtr hicon);
    public static Bitmap FromResource(IntPtr hinstance, string bitmapName);
    [EditorBrowsableAttribute("2")]
public IntPtr GetHbitmap();
    [EditorBrowsableAttribute("2")]
public IntPtr GetHbitmap(Color background);
    [EditorBrowsableAttribute("2")]
public IntPtr GetHicon();
    public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format);
    public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format, BitmapData bitmapData);
    public void MakeTransparent();
    public void MakeTransparent(Color transparentColor);
    public void SetResolution(float xDpi, float yDpi);
    public void UnlockBits(BitmapData bitmapdata);
}
[AttributeUsageAttribute("1")]
public class System.Drawing.BitmapSuffixInSameAssemblyAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Drawing.BitmapSuffixInSatelliteAssemblyAttribute : Attribute {
}
public abstract class System.Drawing.Brush : MarshalByRefObject {
    
private IntPtr _nativeBrush;
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]

internal IntPtr NativeBrush { get; }
    public abstract virtual object Clone();
    protected internal void SetNativeBrush(IntPtr brush);
    internal void SetNativeBrushInternal(IntPtr brush);
    internal IntPtr get_NativeBrush();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public class System.Drawing.Brushes : object {
    
private static SolidBrush aliceBlue;
    
private static SolidBrush antiqueWhite;
    
private static SolidBrush aqua;
    
private static SolidBrush aquamarine;
    
private static SolidBrush azure;
    
private static SolidBrush beige;
    
private static SolidBrush bisque;
    
private static SolidBrush black;
    
private static SolidBrush blanchedAlmond;
    
private static SolidBrush blue;
    
private static SolidBrush blueViolet;
    
private static SolidBrush brown;
    
private static SolidBrush burlyWood;
    
private static SolidBrush cadetBlue;
    
private static SolidBrush chartreuse;
    
private static SolidBrush chocolate;
    
private static SolidBrush coral;
    
private static SolidBrush cornflowerBlue;
    
private static SolidBrush cornsilk;
    
private static SolidBrush crimson;
    
private static SolidBrush cyan;
    
private static SolidBrush darkBlue;
    
private static SolidBrush darkCyan;
    
private static SolidBrush darkGoldenrod;
    
private static SolidBrush darkGray;
    
private static SolidBrush darkGreen;
    
private static SolidBrush darkKhaki;
    
private static SolidBrush darkMagenta;
    
private static SolidBrush darkOliveGreen;
    
private static SolidBrush darkOrange;
    
private static SolidBrush darkOrchid;
    
private static SolidBrush darkRed;
    
private static SolidBrush darkSalmon;
    
private static SolidBrush darkSeaGreen;
    
private static SolidBrush darkSlateBlue;
    
private static SolidBrush darkSlateGray;
    
private static SolidBrush darkTurquoise;
    
private static SolidBrush darkViolet;
    
private static SolidBrush deepPink;
    
private static SolidBrush deepSkyBlue;
    
private static SolidBrush dimGray;
    
private static SolidBrush dodgerBlue;
    
private static SolidBrush firebrick;
    
private static SolidBrush floralWhite;
    
private static SolidBrush forestGreen;
    
private static SolidBrush fuchsia;
    
private static SolidBrush gainsboro;
    
private static SolidBrush ghostWhite;
    
private static SolidBrush gold;
    
private static SolidBrush goldenrod;
    
private static SolidBrush gray;
    
private static SolidBrush green;
    
private static SolidBrush greenYellow;
    
private static SolidBrush honeydew;
    
private static SolidBrush hotPink;
    
private static SolidBrush indianRed;
    
private static SolidBrush indigo;
    
private static SolidBrush ivory;
    
private static SolidBrush khaki;
    
private static SolidBrush lavender;
    
private static SolidBrush lavenderBlush;
    
private static SolidBrush lawnGreen;
    
private static SolidBrush lemonChiffon;
    
private static SolidBrush lightBlue;
    
private static SolidBrush lightCoral;
    
private static SolidBrush lightCyan;
    
private static SolidBrush lightGoldenrodYellow;
    
private static SolidBrush lightGray;
    
private static SolidBrush lightGreen;
    
private static SolidBrush lightPink;
    
private static SolidBrush lightSalmon;
    
private static SolidBrush lightSeaGreen;
    
private static SolidBrush lightSkyBlue;
    
private static SolidBrush lightSlateGray;
    
private static SolidBrush lightSteelBlue;
    
private static SolidBrush lightYellow;
    
private static SolidBrush lime;
    
private static SolidBrush limeGreen;
    
private static SolidBrush linen;
    
private static SolidBrush magenta;
    
private static SolidBrush maroon;
    
private static SolidBrush mediumAquamarine;
    
private static SolidBrush mediumBlue;
    
private static SolidBrush mediumOrchid;
    
private static SolidBrush mediumPurple;
    
private static SolidBrush mediumSeaGreen;
    
private static SolidBrush mediumSlateBlue;
    
private static SolidBrush mediumSpringGreen;
    
private static SolidBrush mediumTurquoise;
    
private static SolidBrush mediumVioletRed;
    
private static SolidBrush midnightBlue;
    
private static SolidBrush mintCream;
    
private static SolidBrush mistyRose;
    
private static SolidBrush moccasin;
    
private static SolidBrush navajoWhite;
    
private static SolidBrush navy;
    
private static SolidBrush oldLace;
    
private static SolidBrush olive;
    
private static SolidBrush oliveDrab;
    
private static SolidBrush orange;
    
private static SolidBrush orangeRed;
    
private static SolidBrush orchid;
    
private static SolidBrush paleGoldenrod;
    
private static SolidBrush paleGreen;
    
private static SolidBrush paleTurquoise;
    
private static SolidBrush paleVioletRed;
    
private static SolidBrush papayaWhip;
    
private static SolidBrush peachPuff;
    
private static SolidBrush peru;
    
private static SolidBrush pink;
    
private static SolidBrush plum;
    
private static SolidBrush powderBlue;
    
private static SolidBrush purple;
    
private static SolidBrush red;
    
private static SolidBrush rosyBrown;
    
private static SolidBrush royalBlue;
    
private static SolidBrush saddleBrown;
    
private static SolidBrush salmon;
    
private static SolidBrush sandyBrown;
    
private static SolidBrush seaGreen;
    
private static SolidBrush seaShell;
    
private static SolidBrush sienna;
    
private static SolidBrush silver;
    
private static SolidBrush skyBlue;
    
private static SolidBrush slateBlue;
    
private static SolidBrush slateGray;
    
private static SolidBrush snow;
    
private static SolidBrush springGreen;
    
private static SolidBrush steelBlue;
    
private static SolidBrush tan;
    
private static SolidBrush teal;
    
private static SolidBrush thistle;
    
private static SolidBrush tomato;
    
private static SolidBrush transparent;
    
private static SolidBrush turquoise;
    
private static SolidBrush violet;
    
private static SolidBrush wheat;
    
private static SolidBrush white;
    
private static SolidBrush whiteSmoke;
    
private static SolidBrush yellow;
    
private static SolidBrush yellowGreen;
    
public static Brush AliceBlue { get; }
    
public static Brush AntiqueWhite { get; }
    
public static Brush Aqua { get; }
    
public static Brush Aquamarine { get; }
    
public static Brush Azure { get; }
    
public static Brush Beige { get; }
    
public static Brush Bisque { get; }
    
public static Brush Black { get; }
    
public static Brush BlanchedAlmond { get; }
    
public static Brush Blue { get; }
    
public static Brush BlueViolet { get; }
    
public static Brush Brown { get; }
    
public static Brush BurlyWood { get; }
    
public static Brush CadetBlue { get; }
    
public static Brush Chartreuse { get; }
    
public static Brush Chocolate { get; }
    
public static Brush Coral { get; }
    
public static Brush CornflowerBlue { get; }
    
public static Brush Cornsilk { get; }
    
public static Brush Crimson { get; }
    
public static Brush Cyan { get; }
    
public static Brush DarkBlue { get; }
    
public static Brush DarkCyan { get; }
    
public static Brush DarkGoldenrod { get; }
    
public static Brush DarkGray { get; }
    
public static Brush DarkGreen { get; }
    
public static Brush DarkKhaki { get; }
    
public static Brush DarkMagenta { get; }
    
public static Brush DarkOliveGreen { get; }
    
public static Brush DarkOrange { get; }
    
public static Brush DarkOrchid { get; }
    
public static Brush DarkRed { get; }
    
public static Brush DarkSalmon { get; }
    
public static Brush DarkSeaGreen { get; }
    
public static Brush DarkSlateBlue { get; }
    
public static Brush DarkSlateGray { get; }
    
public static Brush DarkTurquoise { get; }
    
public static Brush DarkViolet { get; }
    
public static Brush DeepPink { get; }
    
public static Brush DeepSkyBlue { get; }
    
public static Brush DimGray { get; }
    
public static Brush DodgerBlue { get; }
    
public static Brush Firebrick { get; }
    
public static Brush FloralWhite { get; }
    
public static Brush ForestGreen { get; }
    
public static Brush Fuchsia { get; }
    
public static Brush Gainsboro { get; }
    
public static Brush GhostWhite { get; }
    
public static Brush Gold { get; }
    
public static Brush Goldenrod { get; }
    
public static Brush Gray { get; }
    
public static Brush Green { get; }
    
public static Brush GreenYellow { get; }
    
public static Brush Honeydew { get; }
    
public static Brush HotPink { get; }
    
public static Brush IndianRed { get; }
    
public static Brush Indigo { get; }
    
public static Brush Ivory { get; }
    
public static Brush Khaki { get; }
    
public static Brush Lavender { get; }
    
public static Brush LavenderBlush { get; }
    
public static Brush LawnGreen { get; }
    
public static Brush LemonChiffon { get; }
    
public static Brush LightBlue { get; }
    
public static Brush LightCoral { get; }
    
public static Brush LightCyan { get; }
    
public static Brush LightGoldenrodYellow { get; }
    
public static Brush LightGray { get; }
    
public static Brush LightGreen { get; }
    
public static Brush LightPink { get; }
    
public static Brush LightSalmon { get; }
    
public static Brush LightSeaGreen { get; }
    
public static Brush LightSkyBlue { get; }
    
public static Brush LightSlateGray { get; }
    
public static Brush LightSteelBlue { get; }
    
public static Brush LightYellow { get; }
    
public static Brush Lime { get; }
    
public static Brush LimeGreen { get; }
    
public static Brush Linen { get; }
    
public static Brush Magenta { get; }
    
public static Brush Maroon { get; }
    
public static Brush MediumAquamarine { get; }
    
public static Brush MediumBlue { get; }
    
public static Brush MediumOrchid { get; }
    
public static Brush MediumPurple { get; }
    
public static Brush MediumSeaGreen { get; }
    
public static Brush MediumSlateBlue { get; }
    
public static Brush MediumSpringGreen { get; }
    
public static Brush MediumTurquoise { get; }
    
public static Brush MediumVioletRed { get; }
    
public static Brush MidnightBlue { get; }
    
public static Brush MintCream { get; }
    
public static Brush MistyRose { get; }
    
public static Brush Moccasin { get; }
    
public static Brush NavajoWhite { get; }
    
public static Brush Navy { get; }
    
public static Brush OldLace { get; }
    
public static Brush Olive { get; }
    
public static Brush OliveDrab { get; }
    
public static Brush Orange { get; }
    
public static Brush OrangeRed { get; }
    
public static Brush Orchid { get; }
    
public static Brush PaleGoldenrod { get; }
    
public static Brush PaleGreen { get; }
    
public static Brush PaleTurquoise { get; }
    
public static Brush PaleVioletRed { get; }
    
public static Brush PapayaWhip { get; }
    
public static Brush PeachPuff { get; }
    
public static Brush Peru { get; }
    
public static Brush Pink { get; }
    
public static Brush Plum { get; }
    
public static Brush PowderBlue { get; }
    
public static Brush Purple { get; }
    
public static Brush Red { get; }
    
public static Brush RosyBrown { get; }
    
public static Brush RoyalBlue { get; }
    
public static Brush SaddleBrown { get; }
    
public static Brush Salmon { get; }
    
public static Brush SandyBrown { get; }
    
public static Brush SeaGreen { get; }
    
public static Brush SeaShell { get; }
    
public static Brush Sienna { get; }
    
public static Brush Silver { get; }
    
public static Brush SkyBlue { get; }
    
public static Brush SlateBlue { get; }
    
public static Brush SlateGray { get; }
    
public static Brush Snow { get; }
    
public static Brush SpringGreen { get; }
    
public static Brush SteelBlue { get; }
    
public static Brush Tan { get; }
    
public static Brush Teal { get; }
    
public static Brush Thistle { get; }
    
public static Brush Tomato { get; }
    
public static Brush Transparent { get; }
    
public static Brush Turquoise { get; }
    
public static Brush Violet { get; }
    
public static Brush Wheat { get; }
    
public static Brush White { get; }
    
public static Brush WhiteSmoke { get; }
    
public static Brush Yellow { get; }
    
public static Brush YellowGreen { get; }
    public static Brush get_AliceBlue();
    public static Brush get_AntiqueWhite();
    public static Brush get_Aqua();
    public static Brush get_Aquamarine();
    public static Brush get_Azure();
    public static Brush get_Beige();
    public static Brush get_Bisque();
    public static Brush get_Black();
    public static Brush get_BlanchedAlmond();
    public static Brush get_Blue();
    public static Brush get_BlueViolet();
    public static Brush get_Brown();
    public static Brush get_BurlyWood();
    public static Brush get_CadetBlue();
    public static Brush get_Chartreuse();
    public static Brush get_Chocolate();
    public static Brush get_Coral();
    public static Brush get_CornflowerBlue();
    public static Brush get_Cornsilk();
    public static Brush get_Crimson();
    public static Brush get_Cyan();
    public static Brush get_DarkBlue();
    public static Brush get_DarkCyan();
    public static Brush get_DarkGoldenrod();
    public static Brush get_DarkGray();
    public static Brush get_DarkGreen();
    public static Brush get_DarkKhaki();
    public static Brush get_DarkMagenta();
    public static Brush get_DarkOliveGreen();
    public static Brush get_DarkOrange();
    public static Brush get_DarkOrchid();
    public static Brush get_DarkRed();
    public static Brush get_DarkSalmon();
    public static Brush get_DarkSeaGreen();
    public static Brush get_DarkSlateBlue();
    public static Brush get_DarkSlateGray();
    public static Brush get_DarkTurquoise();
    public static Brush get_DarkViolet();
    public static Brush get_DeepPink();
    public static Brush get_DeepSkyBlue();
    public static Brush get_DimGray();
    public static Brush get_DodgerBlue();
    public static Brush get_Firebrick();
    public static Brush get_FloralWhite();
    public static Brush get_ForestGreen();
    public static Brush get_Fuchsia();
    public static Brush get_Gainsboro();
    public static Brush get_GhostWhite();
    public static Brush get_Gold();
    public static Brush get_Goldenrod();
    public static Brush get_Gray();
    public static Brush get_Green();
    public static Brush get_GreenYellow();
    public static Brush get_Honeydew();
    public static Brush get_HotPink();
    public static Brush get_IndianRed();
    public static Brush get_Indigo();
    public static Brush get_Ivory();
    public static Brush get_Khaki();
    public static Brush get_Lavender();
    public static Brush get_LavenderBlush();
    public static Brush get_LawnGreen();
    public static Brush get_LemonChiffon();
    public static Brush get_LightBlue();
    public static Brush get_LightCoral();
    public static Brush get_LightCyan();
    public static Brush get_LightGoldenrodYellow();
    public static Brush get_LightGray();
    public static Brush get_LightGreen();
    public static Brush get_LightPink();
    public static Brush get_LightSalmon();
    public static Brush get_LightSeaGreen();
    public static Brush get_LightSkyBlue();
    public static Brush get_LightSlateGray();
    public static Brush get_LightSteelBlue();
    public static Brush get_LightYellow();
    public static Brush get_Lime();
    public static Brush get_LimeGreen();
    public static Brush get_Linen();
    public static Brush get_Magenta();
    public static Brush get_Maroon();
    public static Brush get_MediumAquamarine();
    public static Brush get_MediumBlue();
    public static Brush get_MediumOrchid();
    public static Brush get_MediumPurple();
    public static Brush get_MediumSeaGreen();
    public static Brush get_MediumSlateBlue();
    public static Brush get_MediumSpringGreen();
    public static Brush get_MediumTurquoise();
    public static Brush get_MediumVioletRed();
    public static Brush get_MidnightBlue();
    public static Brush get_MintCream();
    public static Brush get_MistyRose();
    public static Brush get_Moccasin();
    public static Brush get_NavajoWhite();
    public static Brush get_Navy();
    public static Brush get_OldLace();
    public static Brush get_Olive();
    public static Brush get_OliveDrab();
    public static Brush get_Orange();
    public static Brush get_OrangeRed();
    public static Brush get_Orchid();
    public static Brush get_PaleGoldenrod();
    public static Brush get_PaleGreen();
    public static Brush get_PaleTurquoise();
    public static Brush get_PaleVioletRed();
    public static Brush get_PapayaWhip();
    public static Brush get_PeachPuff();
    public static Brush get_Peru();
    public static Brush get_Pink();
    public static Brush get_Plum();
    public static Brush get_PowderBlue();
    public static Brush get_Purple();
    public static Brush get_Red();
    public static Brush get_RosyBrown();
    public static Brush get_RoyalBlue();
    public static Brush get_SaddleBrown();
    public static Brush get_Salmon();
    public static Brush get_SandyBrown();
    public static Brush get_SeaGreen();
    public static Brush get_SeaShell();
    public static Brush get_Sienna();
    public static Brush get_Silver();
    public static Brush get_SkyBlue();
    public static Brush get_SlateBlue();
    public static Brush get_SlateGray();
    public static Brush get_Snow();
    public static Brush get_SpringGreen();
    public static Brush get_SteelBlue();
    public static Brush get_Tan();
    public static Brush get_Teal();
    public static Brush get_Thistle();
    public static Brush get_Tomato();
    public static Brush get_Transparent();
    public static Brush get_Turquoise();
    public static Brush get_Violet();
    public static Brush get_Wheat();
    public static Brush get_White();
    public static Brush get_WhiteSmoke();
    public static Brush get_Yellow();
    public static Brush get_YellowGreen();
}
internal enum System.Drawing.BrushType : Enum {
    
public int value__;
    
public static BrushType BrushTypeSolidColor;
    
public static BrushType BrushTypeHatchFill;
    
public static BrushType BrushTypeTextureFill;
    
public static BrushType BrushTypePathGradient;
    
public static BrushType BrushTypeLinearGradient;
}
public class System.Drawing.BufferedGraphics : object {
    
private Rectangle size;
    
private Bitmap membmp;
    
private Graphics target;
    
private Graphics source;
    
public Graphics Graphics { get; }
    internal BufferedGraphics(Graphics targetGraphics, Rectangle targetRectangle);
    protected virtual override void Finalize();
    public Graphics get_Graphics();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public void Render();
    public void Render(Graphics target);
    [MonoTODOAttribute("The targetDC parameter has no equivalent in libgdiplus.")]
public void Render(IntPtr targetDC);
}
public class System.Drawing.BufferedGraphicsContext : object {
    
private Size max_buffer;
    
public Size MaximumBuffer { get; public set; }
    protected virtual override void Finalize();
    public BufferedGraphics Allocate(Graphics targetGraphics, Rectangle targetRectangle);
    [MonoTODOAttribute("The targetDC parameter has no equivalent in libgdiplus.")]
public BufferedGraphics Allocate(IntPtr targetDC, Rectangle targetRectangle);
    public sealed virtual void Dispose();
    public void Invalidate();
    public Size get_MaximumBuffer();
    public void set_MaximumBuffer(Size value);
}
public class System.Drawing.BufferedGraphicsManager : object {
    
private static BufferedGraphicsContext graphics_context;
    
public static BufferedGraphicsContext Current { get; }
    private static BufferedGraphicsManager();
    public static BufferedGraphicsContext get_Current();
}
internal class System.Drawing.CarbonContext : ValueType {
    
public IntPtr port;
    
public IntPtr ctx;
    
public int width;
    
public int height;
    public CarbonContext(IntPtr port, IntPtr ctx, int width, int height);
    public sealed virtual void Synchronize();
    public sealed virtual void Release();
}
internal class System.Drawing.CGPoint : ValueType {
    
public float x;
    
public float y;
}
internal class System.Drawing.CGSize : ValueType {
    
public float width;
    
public float height;
}
public class System.Drawing.CharacterRange : ValueType {
    
private int first;
    
private int length;
    
public int First { get; public set; }
    
public int Length { get; public set; }
    public CharacterRange(int First, int Length);
    public int get_First();
    public void set_First(int value);
    public int get_Length();
    public void set_Length(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CharacterRange cr1, CharacterRange cr2);
    public static bool op_Inequality(CharacterRange cr1, CharacterRange cr2);
}
internal static class System.Drawing.ClientUtils : object {
    public static bool IsCriticalException(Exception ex);
    public static bool IsSecurityOrCriticalException(Exception ex);
}
internal class System.Drawing.CocoaContext : ValueType {
    
public IntPtr ctx;
    
public int width;
    
public int height;
    public CocoaContext(IntPtr ctx, int width, int height);
    public sealed virtual void Synchronize();
    public sealed virtual void Release();
}
[TypeConverterAttribute("System.Drawing.ColorConverter")]
[EditorAttribute("System.Drawing.Design.ColorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
public class System.Drawing.Color : ValueType {
    
private long value;
    
internal short state;
    
internal short knownColor;
    
internal string name;
    
public static Color Empty;
    
public string Name { get; }
    
public bool IsKnownColor { get; }
    
public bool IsSystemColor { get; }
    
public bool IsNamedColor { get; }
    
internal long Value { get; internal set; }
    
public bool IsEmpty { get; }
    
public byte A { get; }
    
public byte R { get; }
    
public byte G { get; }
    
public byte B { get; }
    
public static Color Transparent { get; }
    
public static Color AliceBlue { get; }
    
public static Color AntiqueWhite { get; }
    
public static Color Aqua { get; }
    
public static Color Aquamarine { get; }
    
public static Color Azure { get; }
    
public static Color Beige { get; }
    
public static Color Bisque { get; }
    
public static Color Black { get; }
    
public static Color BlanchedAlmond { get; }
    
public static Color Blue { get; }
    
public static Color BlueViolet { get; }
    
public static Color Brown { get; }
    
public static Color BurlyWood { get; }
    
public static Color CadetBlue { get; }
    
public static Color Chartreuse { get; }
    
public static Color Chocolate { get; }
    
public static Color Coral { get; }
    
public static Color CornflowerBlue { get; }
    
public static Color Cornsilk { get; }
    
public static Color Crimson { get; }
    
public static Color Cyan { get; }
    
public static Color DarkBlue { get; }
    
public static Color DarkCyan { get; }
    
public static Color DarkGoldenrod { get; }
    
public static Color DarkGray { get; }
    
public static Color DarkGreen { get; }
    
public static Color DarkKhaki { get; }
    
public static Color DarkMagenta { get; }
    
public static Color DarkOliveGreen { get; }
    
public static Color DarkOrange { get; }
    
public static Color DarkOrchid { get; }
    
public static Color DarkRed { get; }
    
public static Color DarkSalmon { get; }
    
public static Color DarkSeaGreen { get; }
    
public static Color DarkSlateBlue { get; }
    
public static Color DarkSlateGray { get; }
    
public static Color DarkTurquoise { get; }
    
public static Color DarkViolet { get; }
    
public static Color DeepPink { get; }
    
public static Color DeepSkyBlue { get; }
    
public static Color DimGray { get; }
    
public static Color DodgerBlue { get; }
    
public static Color Firebrick { get; }
    
public static Color FloralWhite { get; }
    
public static Color ForestGreen { get; }
    
public static Color Fuchsia { get; }
    
public static Color Gainsboro { get; }
    
public static Color GhostWhite { get; }
    
public static Color Gold { get; }
    
public static Color Goldenrod { get; }
    
public static Color Gray { get; }
    
public static Color Green { get; }
    
public static Color GreenYellow { get; }
    
public static Color Honeydew { get; }
    
public static Color HotPink { get; }
    
public static Color IndianRed { get; }
    
public static Color Indigo { get; }
    
public static Color Ivory { get; }
    
public static Color Khaki { get; }
    
public static Color Lavender { get; }
    
public static Color LavenderBlush { get; }
    
public static Color LawnGreen { get; }
    
public static Color LemonChiffon { get; }
    
public static Color LightBlue { get; }
    
public static Color LightCoral { get; }
    
public static Color LightCyan { get; }
    
public static Color LightGoldenrodYellow { get; }
    
public static Color LightGreen { get; }
    
public static Color LightGray { get; }
    
public static Color LightPink { get; }
    
public static Color LightSalmon { get; }
    
public static Color LightSeaGreen { get; }
    
public static Color LightSkyBlue { get; }
    
public static Color LightSlateGray { get; }
    
public static Color LightSteelBlue { get; }
    
public static Color LightYellow { get; }
    
public static Color Lime { get; }
    
public static Color LimeGreen { get; }
    
public static Color Linen { get; }
    
public static Color Magenta { get; }
    
public static Color Maroon { get; }
    
public static Color MediumAquamarine { get; }
    
public static Color MediumBlue { get; }
    
public static Color MediumOrchid { get; }
    
public static Color MediumPurple { get; }
    
public static Color MediumSeaGreen { get; }
    
public static Color MediumSlateBlue { get; }
    
public static Color MediumSpringGreen { get; }
    
public static Color MediumTurquoise { get; }
    
public static Color MediumVioletRed { get; }
    
public static Color MidnightBlue { get; }
    
public static Color MintCream { get; }
    
public static Color MistyRose { get; }
    
public static Color Moccasin { get; }
    
public static Color NavajoWhite { get; }
    
public static Color Navy { get; }
    
public static Color OldLace { get; }
    
public static Color Olive { get; }
    
public static Color OliveDrab { get; }
    
public static Color Orange { get; }
    
public static Color OrangeRed { get; }
    
public static Color Orchid { get; }
    
public static Color PaleGoldenrod { get; }
    
public static Color PaleGreen { get; }
    
public static Color PaleTurquoise { get; }
    
public static Color PaleVioletRed { get; }
    
public static Color PapayaWhip { get; }
    
public static Color PeachPuff { get; }
    
public static Color Peru { get; }
    
public static Color Pink { get; }
    
public static Color Plum { get; }
    
public static Color PowderBlue { get; }
    
public static Color Purple { get; }
    
public static Color Red { get; }
    
public static Color RosyBrown { get; }
    
public static Color RoyalBlue { get; }
    
public static Color SaddleBrown { get; }
    
public static Color Salmon { get; }
    
public static Color SandyBrown { get; }
    
public static Color SeaGreen { get; }
    
public static Color SeaShell { get; }
    
public static Color Sienna { get; }
    
public static Color Silver { get; }
    
public static Color SkyBlue { get; }
    
public static Color SlateBlue { get; }
    
public static Color SlateGray { get; }
    
public static Color Snow { get; }
    
public static Color SpringGreen { get; }
    
public static Color SteelBlue { get; }
    
public static Color Tan { get; }
    
public static Color Teal { get; }
    
public static Color Thistle { get; }
    
public static Color Tomato { get; }
    
public static Color Turquoise { get; }
    
public static Color Violet { get; }
    
public static Color Wheat { get; }
    
public static Color White { get; }
    
public static Color WhiteSmoke { get; }
    
public static Color Yellow { get; }
    
public static Color YellowGreen { get; }
    public string get_Name();
    public bool get_IsKnownColor();
    public bool get_IsSystemColor();
    public bool get_IsNamedColor();
    internal long get_Value();
    internal void set_Value(long value);
    public static Color FromArgb(int red, int green, int blue);
    public static Color FromArgb(int alpha, int red, int green, int blue);
    public int ToArgb();
    public static Color FromArgb(int alpha, Color baseColor);
    public static Color FromArgb(int argb);
    public static Color FromKnownColor(KnownColor color);
    public static Color FromName(string name);
    public static bool op_Equality(Color left, Color right);
    public static bool op_Inequality(Color left, Color right);
    public float GetBrightness();
    public float GetSaturation();
    public float GetHue();
    public KnownColor ToKnownColor();
    public bool get_IsEmpty();
    public byte get_A();
    public byte get_R();
    public byte get_G();
    public byte get_B();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static void CheckRGBValues(int red, int green, int blue);
    private static ArgumentException CreateColorArgumentException(int value, string color);
    private static void CheckARGBValues(int alpha, int red, int green, int blue);
    public static Color get_Transparent();
    public static Color get_AliceBlue();
    public static Color get_AntiqueWhite();
    public static Color get_Aqua();
    public static Color get_Aquamarine();
    public static Color get_Azure();
    public static Color get_Beige();
    public static Color get_Bisque();
    public static Color get_Black();
    public static Color get_BlanchedAlmond();
    public static Color get_Blue();
    public static Color get_BlueViolet();
    public static Color get_Brown();
    public static Color get_BurlyWood();
    public static Color get_CadetBlue();
    public static Color get_Chartreuse();
    public static Color get_Chocolate();
    public static Color get_Coral();
    public static Color get_CornflowerBlue();
    public static Color get_Cornsilk();
    public static Color get_Crimson();
    public static Color get_Cyan();
    public static Color get_DarkBlue();
    public static Color get_DarkCyan();
    public static Color get_DarkGoldenrod();
    public static Color get_DarkGray();
    public static Color get_DarkGreen();
    public static Color get_DarkKhaki();
    public static Color get_DarkMagenta();
    public static Color get_DarkOliveGreen();
    public static Color get_DarkOrange();
    public static Color get_DarkOrchid();
    public static Color get_DarkRed();
    public static Color get_DarkSalmon();
    public static Color get_DarkSeaGreen();
    public static Color get_DarkSlateBlue();
    public static Color get_DarkSlateGray();
    public static Color get_DarkTurquoise();
    public static Color get_DarkViolet();
    public static Color get_DeepPink();
    public static Color get_DeepSkyBlue();
    public static Color get_DimGray();
    public static Color get_DodgerBlue();
    public static Color get_Firebrick();
    public static Color get_FloralWhite();
    public static Color get_ForestGreen();
    public static Color get_Fuchsia();
    public static Color get_Gainsboro();
    public static Color get_GhostWhite();
    public static Color get_Gold();
    public static Color get_Goldenrod();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_GreenYellow();
    public static Color get_Honeydew();
    public static Color get_HotPink();
    public static Color get_IndianRed();
    public static Color get_Indigo();
    public static Color get_Ivory();
    public static Color get_Khaki();
    public static Color get_Lavender();
    public static Color get_LavenderBlush();
    public static Color get_LawnGreen();
    public static Color get_LemonChiffon();
    public static Color get_LightBlue();
    public static Color get_LightCoral();
    public static Color get_LightCyan();
    public static Color get_LightGoldenrodYellow();
    public static Color get_LightGreen();
    public static Color get_LightGray();
    public static Color get_LightPink();
    public static Color get_LightSalmon();
    public static Color get_LightSeaGreen();
    public static Color get_LightSkyBlue();
    public static Color get_LightSlateGray();
    public static Color get_LightSteelBlue();
    public static Color get_LightYellow();
    public static Color get_Lime();
    public static Color get_LimeGreen();
    public static Color get_Linen();
    public static Color get_Magenta();
    public static Color get_Maroon();
    public static Color get_MediumAquamarine();
    public static Color get_MediumBlue();
    public static Color get_MediumOrchid();
    public static Color get_MediumPurple();
    public static Color get_MediumSeaGreen();
    public static Color get_MediumSlateBlue();
    public static Color get_MediumSpringGreen();
    public static Color get_MediumTurquoise();
    public static Color get_MediumVioletRed();
    public static Color get_MidnightBlue();
    public static Color get_MintCream();
    public static Color get_MistyRose();
    public static Color get_Moccasin();
    public static Color get_NavajoWhite();
    public static Color get_Navy();
    public static Color get_OldLace();
    public static Color get_Olive();
    public static Color get_OliveDrab();
    public static Color get_Orange();
    public static Color get_OrangeRed();
    public static Color get_Orchid();
    public static Color get_PaleGoldenrod();
    public static Color get_PaleGreen();
    public static Color get_PaleTurquoise();
    public static Color get_PaleVioletRed();
    public static Color get_PapayaWhip();
    public static Color get_PeachPuff();
    public static Color get_Peru();
    public static Color get_Pink();
    public static Color get_Plum();
    public static Color get_PowderBlue();
    public static Color get_Purple();
    public static Color get_Red();
    public static Color get_RosyBrown();
    public static Color get_RoyalBlue();
    public static Color get_SaddleBrown();
    public static Color get_Salmon();
    public static Color get_SandyBrown();
    public static Color get_SeaGreen();
    public static Color get_SeaShell();
    public static Color get_Sienna();
    public static Color get_Silver();
    public static Color get_SkyBlue();
    public static Color get_SlateBlue();
    public static Color get_SlateGray();
    public static Color get_Snow();
    public static Color get_SpringGreen();
    public static Color get_SteelBlue();
    public static Color get_Tan();
    public static Color get_Teal();
    public static Color get_Thistle();
    public static Color get_Tomato();
    public static Color get_Turquoise();
    public static Color get_Violet();
    public static Color get_Wheat();
    public static Color get_White();
    public static Color get_WhiteSmoke();
    public static Color get_Yellow();
    public static Color get_YellowGreen();
}
public class System.Drawing.ColorConverter : TypeConverter {
    
private static StandardValuesCollection cached;
    
private static object creatingCached;
    private static ColorConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    internal static Color StaticConvertFromString(ITypeDescriptorContext context, string s, CultureInfo culture);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
internal static class System.Drawing.ColorTable : object {
    
private static Lazy`1<Dictionary`2<string, Color>> s_colorConstants;
    
internal static Dictionary`2<string, Color> Colors { get; }
    private static ColorTable();
    private static Dictionary`2<string, Color> GetColors();
    internal static Dictionary`2<string, Color> get_Colors();
    private static void FillConstants(Dictionary`2<string, Color> colors, Type enumType);
    internal static bool TryGetNamedColor(string name, Color& result);
    internal static bool IsKnownNamedColor(string name);
}
public class System.Drawing.ColorTranslator : object {
    public static Color FromHtml(string htmlColor);
    internal static Color FromBGR(int bgr);
    public static Color FromOle(int oleColor);
    public static Color FromWin32(int win32Color);
    public static string ToHtml(Color c);
    private static char GetHexNumber(int b);
    private static string FormatHtml(int r, int g, int b);
    public static int ToOle(Color c);
    public static int ToWin32(Color c);
}
[ExtensionAttribute]
internal static class System.Drawing.ColorUtil : object {
    public static Color FromKnownColor(KnownColor color);
    [ExtensionAttribute]
public static bool IsSystemColor(Color color);
}
internal class System.Drawing.ComIStreamMarshaler : object {
    
private static int S_OK;
    
private static int E_NOINTERFACE;
    
private static ComIStreamMarshaler defaultInstance;
    private static ComIStreamMarshaler();
    private static ICustomMarshaler GetInstance(string cookie);
    public sealed virtual IntPtr MarshalManagedToNative(object managedObj);
    public sealed virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public sealed virtual void CleanUpManagedData(object managedObj);
    public sealed virtual int GetNativeDataSize();
}
internal class System.Drawing.ComIStreamWrapper : object {
    
private static int STG_E_INVALIDFUNCTION;
    
private Stream baseStream;
    
private long position;
    internal ComIStreamWrapper(Stream stream);
    private void SetSizeToPosition();
    public sealed virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public sealed virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public sealed virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public sealed virtual void SetSize(long libNewSize);
    public sealed virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public sealed virtual void Commit(int grfCommitFlags);
    public sealed virtual void Revert();
    public sealed virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public sealed virtual void Clone(IStream& ppstm);
}
[EditorAttribute("System.Drawing.Design.ContentAlignmentEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
public enum System.Drawing.ContentAlignment : Enum {
    
public int value__;
    
public static ContentAlignment TopLeft;
    
public static ContentAlignment TopCenter;
    
public static ContentAlignment TopRight;
    
public static ContentAlignment MiddleLeft;
    
public static ContentAlignment MiddleCenter;
    
public static ContentAlignment MiddleRight;
    
public static ContentAlignment BottomLeft;
    
public static ContentAlignment BottomCenter;
    
public static ContentAlignment BottomRight;
}
[ComVisibleAttribute("True")]
public enum System.Drawing.CopyPixelOperation : Enum {
    
public int value__;
    
public static CopyPixelOperation Blackness;
    
public static CopyPixelOperation CaptureBlt;
    
public static CopyPixelOperation DestinationInvert;
    
public static CopyPixelOperation MergeCopy;
    
public static CopyPixelOperation MergePaint;
    
public static CopyPixelOperation NoMirrorBitmap;
    
public static CopyPixelOperation NotSourceCopy;
    
public static CopyPixelOperation NotSourceErase;
    
public static CopyPixelOperation PatCopy;
    
public static CopyPixelOperation PatInvert;
    
public static CopyPixelOperation PatPaint;
    
public static CopyPixelOperation SourceAnd;
    
public static CopyPixelOperation SourceCopy;
    
public static CopyPixelOperation SourceErase;
    
public static CopyPixelOperation SourceInvert;
    
public static CopyPixelOperation SourcePaint;
    
public static CopyPixelOperation Whiteness;
}
[DefaultMemberAttribute("Item")]
public class System.Drawing.Design.CategoryNameCollection : ReadOnlyCollectionBase {
    
public string Item { get; }
    public CategoryNameCollection(CategoryNameCollection value);
    public CategoryNameCollection(String[] value);
    public string get_Item(int index);
    public bool Contains(string value);
    public void CopyTo(String[] array, int index);
    public int IndexOf(string value);
}
public interface System.Drawing.Design.IPropertyValueUIService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyUIValueItemsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyUIValueItemsChanged(EventHandler value);
    public abstract virtual void AddPropertyValueUIHandler(PropertyValueUIHandler newHandler);
    public abstract virtual PropertyValueUIItem[] GetPropertyUIValueItems(ITypeDescriptorContext context, PropertyDescriptor propDesc);
    public abstract virtual void NotifyPropertyValueUIItemsChanged();
    public abstract virtual void RemovePropertyValueUIHandler(PropertyValueUIHandler newHandler);
}
public interface System.Drawing.Design.IToolboxItemProvider {
    
public ToolboxItemCollection Items { get; }
    public abstract virtual ToolboxItemCollection get_Items();
}
[GuidAttribute("4BACD258-DE64-4048-BC4E-FEDBEF9ACB76")]
[InterfaceTypeAttribute("1")]
public interface System.Drawing.Design.IToolboxService {
    
public CategoryNameCollection CategoryNames { get; }
    
public string SelectedCategory { get; public set; }
    public abstract virtual CategoryNameCollection get_CategoryNames();
    public abstract virtual string get_SelectedCategory();
    public abstract virtual void set_SelectedCategory(string value);
    public abstract virtual void AddCreator(ToolboxItemCreatorCallback creator, string format);
    public abstract virtual void AddCreator(ToolboxItemCreatorCallback creator, string format, IDesignerHost host);
    public abstract virtual void AddLinkedToolboxItem(ToolboxItem toolboxItem, IDesignerHost host);
    public abstract virtual void AddLinkedToolboxItem(ToolboxItem toolboxItem, string category, IDesignerHost host);
    public abstract virtual void AddToolboxItem(ToolboxItem toolboxItem);
    public abstract virtual void AddToolboxItem(ToolboxItem toolboxItem, string category);
    public abstract virtual ToolboxItem DeserializeToolboxItem(object serializedObject);
    public abstract virtual ToolboxItem DeserializeToolboxItem(object serializedObject, IDesignerHost host);
    public abstract virtual ToolboxItem GetSelectedToolboxItem();
    public abstract virtual ToolboxItem GetSelectedToolboxItem(IDesignerHost host);
    public abstract virtual ToolboxItemCollection GetToolboxItems();
    public abstract virtual ToolboxItemCollection GetToolboxItems(IDesignerHost host);
    public abstract virtual ToolboxItemCollection GetToolboxItems(string category);
    public abstract virtual ToolboxItemCollection GetToolboxItems(string category, IDesignerHost host);
    public abstract virtual bool IsSupported(object serializedObject, IDesignerHost host);
    public abstract virtual bool IsSupported(object serializedObject, ICollection filterAttributes);
    public abstract virtual bool IsToolboxItem(object serializedObject);
    public abstract virtual bool IsToolboxItem(object serializedObject, IDesignerHost host);
    public abstract virtual void Refresh();
    public abstract virtual void RemoveCreator(string format);
    public abstract virtual void RemoveCreator(string format, IDesignerHost host);
    public abstract virtual void RemoveToolboxItem(ToolboxItem toolboxItem);
    public abstract virtual void RemoveToolboxItem(ToolboxItem toolboxItem, string category);
    public abstract virtual void SelectedToolboxItemUsed();
    public abstract virtual object SerializeToolboxItem(ToolboxItem toolboxItem);
    public abstract virtual bool SetCursor();
    public abstract virtual void SetSelectedToolboxItem(ToolboxItem toolboxItem);
}
public interface System.Drawing.Design.IToolboxUser {
    public abstract virtual bool GetToolSupported(ToolboxItem tool);
    public abstract virtual void ToolPicked(ToolboxItem tool);
}
public class System.Drawing.Design.PaintValueEventArgs : EventArgs {
    
private ITypeDescriptorContext context;
    
private object valueToPaint;
    
private Graphics graphics;
    
private Rectangle bounds;
    
public Rectangle Bounds { get; }
    
public ITypeDescriptorContext Context { get; }
    
public Graphics Graphics { get; }
    
public object Value { get; }
    public PaintValueEventArgs(ITypeDescriptorContext context, object value, Graphics graphics, Rectangle bounds);
    public Rectangle get_Bounds();
    public ITypeDescriptorContext get_Context();
    public Graphics get_Graphics();
    public object get_Value();
}
public class System.Drawing.Design.PropertyValueUIHandler : MulticastDelegate {
    public PropertyValueUIHandler(object object, IntPtr method);
    public virtual void Invoke(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList);
    public virtual IAsyncResult BeginInvoke(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.PropertyValueUIItem : object {
    
private Image itemImage;
    
private PropertyValueUIItemInvokeHandler handler;
    
private string tooltip;
    
public Image Image { get; }
    
public PropertyValueUIItemInvokeHandler InvokeHandler { get; }
    
public string ToolTip { get; }
    public PropertyValueUIItem(Image uiItemImage, PropertyValueUIItemInvokeHandler handler, string tooltip);
    public virtual Image get_Image();
    public virtual PropertyValueUIItemInvokeHandler get_InvokeHandler();
    public virtual string get_ToolTip();
    public virtual void Reset();
}
public class System.Drawing.Design.PropertyValueUIItemInvokeHandler : MulticastDelegate {
    public PropertyValueUIItemInvokeHandler(object object, IntPtr method);
    public virtual void Invoke(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem);
    public virtual IAsyncResult BeginInvoke(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.ToolboxComponentsCreatedEventArgs : EventArgs {
    
private IComponent[] comps;
    
public IComponent[] Components { get; }
    public ToolboxComponentsCreatedEventArgs(IComponent[] components);
    public IComponent[] get_Components();
}
public class System.Drawing.Design.ToolboxComponentsCreatedEventHandler : MulticastDelegate {
    public ToolboxComponentsCreatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ToolboxComponentsCreatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ToolboxComponentsCreatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.ToolboxComponentsCreatingEventArgs : EventArgs {
    
private IDesignerHost host;
    
public IDesignerHost DesignerHost { get; }
    public ToolboxComponentsCreatingEventArgs(IDesignerHost host);
    public IDesignerHost get_DesignerHost();
}
public class System.Drawing.Design.ToolboxComponentsCreatingEventHandler : MulticastDelegate {
    public ToolboxComponentsCreatingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ToolboxComponentsCreatingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ToolboxComponentsCreatingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[MonoTODOAttribute("Implementation is incomplete.")]
public class System.Drawing.Design.ToolboxItem : object {
    
private bool locked;
    
private Hashtable properties;
    [CompilerGeneratedAttribute]

private ToolboxComponentsCreatedEventHandler ComponentsCreated;
    [CompilerGeneratedAttribute]

private ToolboxComponentsCreatingEventHandler ComponentsCreating;
    
public AssemblyName AssemblyName { get; public set; }
    
public Bitmap Bitmap { get; public set; }
    
public string DisplayName { get; public set; }
    
public ICollection Filter { get; public set; }
    
public bool Locked { get; }
    
public string TypeName { get; public set; }
    
public string Company { get; public set; }
    
public string ComponentType { get; }
    
public AssemblyName[] DependentAssemblies { get; public set; }
    
public string Description { get; public set; }
    
public bool IsTransient { get; public set; }
    
public IDictionary Properties { get; }
    
public string Version { get; }
    
public Bitmap OriginalBitmap { get; public set; }
    public ToolboxItem(Type toolType);
    public AssemblyName get_AssemblyName();
    public void set_AssemblyName(AssemblyName value);
    public Bitmap get_Bitmap();
    public void set_Bitmap(Bitmap value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public ICollection get_Filter();
    public void set_Filter(ICollection value);
    public virtual bool get_Locked();
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_Company();
    public void set_Company(string value);
    public virtual string get_ComponentType();
    public AssemblyName[] get_DependentAssemblies();
    public void set_DependentAssemblies(AssemblyName[] value);
    public string get_Description();
    public void set_Description(string value);
    public bool get_IsTransient();
    public void set_IsTransient(bool value);
    public IDictionary get_Properties();
    public virtual string get_Version();
    protected void CheckUnlocked();
    public IComponent[] CreateComponents();
    public IComponent[] CreateComponents(IDesignerHost host);
    protected virtual IComponent[] CreateComponentsCore(IDesignerHost host);
    protected virtual IComponent[] CreateComponentsCore(IDesignerHost host, IDictionary defaultValues);
    public IComponent[] CreateComponents(IDesignerHost host, IDictionary defaultValues);
    protected virtual object FilterPropertyValue(string propertyName, object value);
    protected virtual void Deserialize(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Type GetType(IDesignerHost host);
    protected virtual Type GetType(IDesignerHost host, AssemblyName assemblyName, string typeName, bool reference);
    public virtual void Initialize(Type type);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Lock();
    protected virtual void OnComponentsCreated(ToolboxComponentsCreatedEventArgs args);
    protected virtual void OnComponentsCreating(ToolboxComponentsCreatingEventArgs args);
    protected virtual void Serialize(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    protected void ValidatePropertyType(string propertyName, object value, Type expectedType, bool allowNull);
    protected virtual object ValidatePropertyValue(string propertyName, object value);
    private void SetValue(string propertyName, object value);
    private string GetValue(string propertyName);
    [CompilerGeneratedAttribute]
public void add_ComponentsCreated(ToolboxComponentsCreatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ComponentsCreated(ToolboxComponentsCreatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ComponentsCreating(ToolboxComponentsCreatingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ComponentsCreating(ToolboxComponentsCreatingEventHandler value);
    public Bitmap get_OriginalBitmap();
    public void set_OriginalBitmap(Bitmap value);
}
[DefaultMemberAttribute("Item")]
public class System.Drawing.Design.ToolboxItemCollection : ReadOnlyCollectionBase {
    
public ToolboxItem Item { get; }
    public ToolboxItemCollection(ToolboxItemCollection value);
    public ToolboxItemCollection(ToolboxItem[] value);
    public ToolboxItem get_Item(int index);
    public bool Contains(ToolboxItem value);
    public void CopyTo(ToolboxItem[] array, int index);
    public int IndexOf(ToolboxItem value);
}
public class System.Drawing.Design.ToolboxItemCreatorCallback : MulticastDelegate {
    public ToolboxItemCreatorCallback(object object, IntPtr method);
    public virtual ToolboxItem Invoke(object serializedObject, string format);
    public virtual IAsyncResult BeginInvoke(object serializedObject, string format, AsyncCallback callback, object object);
    public virtual ToolboxItem EndInvoke(IAsyncResult result);
}
public class System.Drawing.Design.UITypeEditor : object {
    
public bool IsDropDownResizable { get; }
    private static UITypeEditor();
    public virtual bool get_IsDropDownResizable();
    public object EditValue(IServiceProvider provider, object value);
    public virtual object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value);
    public UITypeEditorEditStyle GetEditStyle();
    public bool GetPaintValueSupported();
    public virtual bool GetPaintValueSupported(ITypeDescriptorContext context);
    public virtual UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context);
    public void PaintValue(object value, Graphics canvas, Rectangle rectangle);
    public virtual void PaintValue(PaintValueEventArgs e);
}
public enum System.Drawing.Design.UITypeEditorEditStyle : Enum {
    
public int value__;
    
public static UITypeEditorEditStyle None;
    
public static UITypeEditorEditStyle Modal;
    
public static UITypeEditorEditStyle DropDown;
}
public class System.Drawing.Drawing2D.AdjustableArrowCap : CustomLineCap {
    
public float Height { get; public set; }
    
public float Width { get; public set; }
    
public float MiddleInset { get; public set; }
    
public bool Filled { get; public set; }
    internal AdjustableArrowCap(IntPtr nativeCap);
    public AdjustableArrowCap(float width, float height);
    public AdjustableArrowCap(float width, float height, bool isFilled);
    public float get_Height();
    public void set_Height(float value);
    public float get_Width();
    public void set_Width(float value);
    public float get_MiddleInset();
    public void set_MiddleInset(float value);
    public bool get_Filled();
    public void set_Filled(bool value);
}
public class System.Drawing.Drawing2D.Blend : object {
    [CompilerGeneratedAttribute]

private Single[] <Factors>k__BackingField;
    [CompilerGeneratedAttribute]

private Single[] <Positions>k__BackingField;
    
public Single[] Factors { get; public set; }
    
public Single[] Positions { get; public set; }
    public Blend(int count);
    [CompilerGeneratedAttribute]
public Single[] get_Factors();
    [CompilerGeneratedAttribute]
public void set_Factors(Single[] value);
    [CompilerGeneratedAttribute]
public Single[] get_Positions();
    [CompilerGeneratedAttribute]
public void set_Positions(Single[] value);
}
internal enum System.Drawing.Drawing2D.BrushType : Enum {
    
public int value__;
    
public static BrushType SolidColor;
    
public static BrushType HatchFill;
    
public static BrushType TextureFill;
    
public static BrushType PathGradient;
    
public static BrushType LinearGradient;
}
public class System.Drawing.Drawing2D.ColorBlend : object {
    [CompilerGeneratedAttribute]

private Color[] <Colors>k__BackingField;
    [CompilerGeneratedAttribute]

private Single[] <Positions>k__BackingField;
    
public Color[] Colors { get; public set; }
    
public Single[] Positions { get; public set; }
    public ColorBlend(int count);
    [CompilerGeneratedAttribute]
public Color[] get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(Color[] value);
    [CompilerGeneratedAttribute]
public Single[] get_Positions();
    [CompilerGeneratedAttribute]
public void set_Positions(Single[] value);
}
public enum System.Drawing.Drawing2D.CombineMode : Enum {
    
public int value__;
    
public static CombineMode Replace;
    
public static CombineMode Intersect;
    
public static CombineMode Union;
    
public static CombineMode Xor;
    
public static CombineMode Exclude;
    
public static CombineMode Complement;
}
public enum System.Drawing.Drawing2D.CompositingMode : Enum {
    
public int value__;
    
public static CompositingMode SourceOver;
    
public static CompositingMode SourceCopy;
}
public enum System.Drawing.Drawing2D.CompositingQuality : Enum {
    
public int value__;
    
public static CompositingQuality Invalid;
    
public static CompositingQuality Default;
    
public static CompositingQuality HighSpeed;
    
public static CompositingQuality HighQuality;
    
public static CompositingQuality GammaCorrected;
    
public static CompositingQuality AssumeLinear;
}
public enum System.Drawing.Drawing2D.CoordinateSpace : Enum {
    
public int value__;
    
public static CoordinateSpace World;
    
public static CoordinateSpace Page;
    
public static CoordinateSpace Device;
}
public class System.Drawing.Drawing2D.CustomLineCap : MarshalByRefObject {
    
internal SafeCustomLineCapHandle nativeCap;
    
private bool _disposed;
    
public LineJoin StrokeJoin { get; public set; }
    
public LineCap BaseCap { get; public set; }
    
public float BaseInset { get; public set; }
    
public float WidthScale { get; public set; }
    public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath);
    public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap);
    public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap, float baseInset);
    internal CustomLineCap(IntPtr nativeLineCap);
    internal static CustomLineCap CreateCustomLineCapObject(IntPtr cap);
    internal void SetNativeLineCap(IntPtr handle);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public virtual object Clone();
    public void SetStrokeCaps(LineCap startCap, LineCap endCap);
    public void GetStrokeCaps(LineCap& startCap, LineCap& endCap);
    public LineJoin get_StrokeJoin();
    public void set_StrokeJoin(LineJoin value);
    public LineCap get_BaseCap();
    public void set_BaseCap(LineCap value);
    public float get_BaseInset();
    public void set_BaseInset(float value);
    public float get_WidthScale();
    public void set_WidthScale(float value);
}
internal enum System.Drawing.Drawing2D.CustomLineCapType : Enum {
    
public int value__;
    
public static CustomLineCapType Default;
    
public static CustomLineCapType AdjustableArrowCap;
}
public enum System.Drawing.Drawing2D.DashCap : Enum {
    
public int value__;
    
public static DashCap Flat;
    
public static DashCap Round;
    
public static DashCap Triangle;
}
public enum System.Drawing.Drawing2D.DashStyle : Enum {
    
public int value__;
    
public static DashStyle Solid;
    
public static DashStyle Dash;
    
public static DashStyle Dot;
    
public static DashStyle DashDot;
    
public static DashStyle DashDotDot;
    
public static DashStyle Custom;
}
public enum System.Drawing.Drawing2D.FillMode : Enum {
    
public int value__;
    
public static FillMode Alternate;
    
public static FillMode Winding;
}
public enum System.Drawing.Drawing2D.FlushIntention : Enum {
    
public int value__;
    
public static FlushIntention Flush;
    
public static FlushIntention Sync;
}
public class System.Drawing.Drawing2D.GraphicsContainer : MarshalByRefObject {
    
private UInt32 nativeState;
    
internal UInt32 NativeObject { get; }
    internal GraphicsContainer(UInt32 state);
    internal UInt32 get_NativeObject();
}
public class System.Drawing.Drawing2D.GraphicsPath : MarshalByRefObject {
    
private static float FlatnessDefault;
    
internal IntPtr nativePath;
    
public FillMode FillMode { get; public set; }
    
public PathData PathData { get; }
    
public PointF[] PathPoints { get; }
    
public Byte[] PathTypes { get; }
    
public int PointCount { get; }
    
internal IntPtr NativeObject { get; internal set; }
    private GraphicsPath(IntPtr ptr);
    public GraphicsPath(FillMode fillMode);
    public GraphicsPath(Point[] pts, Byte[] types);
    public GraphicsPath(PointF[] pts, Byte[] types);
    public GraphicsPath(Point[] pts, Byte[] types, FillMode fillMode);
    public GraphicsPath(PointF[] pts, Byte[] types, FillMode fillMode);
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Dispose(bool disposing);
    public FillMode get_FillMode();
    public void set_FillMode(FillMode value);
    public PathData get_PathData();
    public PointF[] get_PathPoints();
    public Byte[] get_PathTypes();
    public int get_PointCount();
    internal IntPtr get_NativeObject();
    internal void set_NativeObject(IntPtr value);
    public void AddArc(Rectangle rect, float startAngle, float sweepAngle);
    public void AddArc(RectangleF rect, float startAngle, float sweepAngle);
    public void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);
    public void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void AddBezier(Point pt1, Point pt2, Point pt3, Point pt4);
    public void AddBezier(PointF pt1, PointF pt2, PointF pt3, PointF pt4);
    public void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    public void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
    public void AddBeziers(Point[] points);
    public void AddBeziers(PointF[] points);
    public void AddEllipse(RectangleF rect);
    public void AddEllipse(float x, float y, float width, float height);
    public void AddEllipse(Rectangle rect);
    public void AddEllipse(int x, int y, int width, int height);
    public void AddLine(Point pt1, Point pt2);
    public void AddLine(PointF pt1, PointF pt2);
    public void AddLine(int x1, int y1, int x2, int y2);
    public void AddLine(float x1, float y1, float x2, float y2);
    public void AddLines(Point[] points);
    public void AddLines(PointF[] points);
    public void AddPie(Rectangle rect, float startAngle, float sweepAngle);
    public void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);
    public void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void AddPolygon(Point[] points);
    public void AddPolygon(PointF[] points);
    public void AddRectangle(Rectangle rect);
    public void AddRectangle(RectangleF rect);
    public void AddRectangles(Rectangle[] rects);
    public void AddRectangles(RectangleF[] rects);
    public void AddPath(GraphicsPath addingPath, bool connect);
    public PointF GetLastPoint();
    public void AddClosedCurve(Point[] points);
    public void AddClosedCurve(PointF[] points);
    public void AddClosedCurve(Point[] points, float tension);
    public void AddClosedCurve(PointF[] points, float tension);
    public void AddCurve(Point[] points);
    public void AddCurve(PointF[] points);
    public void AddCurve(Point[] points, float tension);
    public void AddCurve(PointF[] points, float tension);
    public void AddCurve(Point[] points, int offset, int numberOfSegments, float tension);
    public void AddCurve(PointF[] points, int offset, int numberOfSegments, float tension);
    public void Reset();
    public void Reverse();
    public void Transform(Matrix matrix);
    [MonoTODOAttribute("The StringFormat parameter is ignored when using libgdiplus.")]
public void AddString(string s, FontFamily family, int style, float emSize, Point origin, StringFormat format);
    [MonoTODOAttribute("The StringFormat parameter is ignored when using libgdiplus.")]
public void AddString(string s, FontFamily family, int style, float emSize, PointF origin, StringFormat format);
    [MonoTODOAttribute("The layoutRect and StringFormat parameters are ignored when using libgdiplus.")]
public void AddString(string s, FontFamily family, int style, float emSize, Rectangle layoutRect, StringFormat format);
    [MonoTODOAttribute("The layoutRect and StringFormat parameters are ignored when using libgdiplus.")]
public void AddString(string s, FontFamily family, int style, float emSize, RectangleF layoutRect, StringFormat format);
    public void ClearMarkers();
    public void CloseAllFigures();
    public void CloseFigure();
    public void Flatten();
    public void Flatten(Matrix matrix);
    public void Flatten(Matrix matrix, float flatness);
    public RectangleF GetBounds();
    public RectangleF GetBounds(Matrix matrix);
    public RectangleF GetBounds(Matrix matrix, Pen pen);
    public bool IsOutlineVisible(Point point, Pen pen);
    public bool IsOutlineVisible(PointF point, Pen pen);
    public bool IsOutlineVisible(int x, int y, Pen pen);
    public bool IsOutlineVisible(float x, float y, Pen pen);
    public bool IsOutlineVisible(Point pt, Pen pen, Graphics graphics);
    public bool IsOutlineVisible(PointF pt, Pen pen, Graphics graphics);
    public bool IsOutlineVisible(int x, int y, Pen pen, Graphics graphics);
    public bool IsOutlineVisible(float x, float y, Pen pen, Graphics graphics);
    public bool IsVisible(Point point);
    public bool IsVisible(PointF point);
    public bool IsVisible(int x, int y);
    public bool IsVisible(float x, float y);
    public bool IsVisible(Point pt, Graphics graphics);
    public bool IsVisible(PointF pt, Graphics graphics);
    public bool IsVisible(int x, int y, Graphics graphics);
    public bool IsVisible(float x, float y, Graphics graphics);
    public void SetMarkers();
    public void StartFigure();
    [MonoTODOAttribute("GdipWarpPath isn't implemented in libgdiplus")]
public void Warp(PointF[] destPoints, RectangleF srcRect);
    [MonoTODOAttribute("GdipWarpPath isn't implemented in libgdiplus")]
public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix);
    [MonoTODOAttribute("GdipWarpPath isn't implemented in libgdiplus")]
public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode);
    [MonoTODOAttribute("GdipWarpPath isn't implemented in libgdiplus")]
public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode, float flatness);
    [MonoTODOAttribute("GdipWidenPath isn't implemented in libgdiplus")]
public void Widen(Pen pen);
    [MonoTODOAttribute("GdipWidenPath isn't implemented in libgdiplus")]
public void Widen(Pen pen, Matrix matrix);
    [MonoTODOAttribute("GdipWidenPath isn't implemented in libgdiplus")]
public void Widen(Pen pen, Matrix matrix, float flatness);
}
public class System.Drawing.Drawing2D.GraphicsPathIterator : MarshalByRefObject {
    
internal IntPtr nativeIter;
    
public int Count { get; }
    
public int SubpathCount { get; }
    public GraphicsPathIterator(GraphicsPath path);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public int NextSubpath(Int32& startIndex, Int32& endIndex, Boolean& isClosed);
    public int NextSubpath(GraphicsPath path, Boolean& isClosed);
    public int NextPathType(Byte& pathType, Int32& startIndex, Int32& endIndex);
    public int NextMarker(Int32& startIndex, Int32& endIndex);
    public int NextMarker(GraphicsPath path);
    public int get_Count();
    public int get_SubpathCount();
    public bool HasCurve();
    public void Rewind();
    public int Enumerate(PointF[]& points, Byte[]& types);
    public int CopyData(PointF[]& points, Byte[]& types, int startIndex, int endIndex);
}
public class System.Drawing.Drawing2D.GraphicsState : MarshalByRefObject {
    
internal int nativeState;
    internal GraphicsState(int nativeState);
}
public class System.Drawing.Drawing2D.HatchBrush : Brush {
    
public HatchStyle HatchStyle { get; }
    
public Color ForegroundColor { get; }
    
public Color BackgroundColor { get; }
    public HatchBrush(HatchStyle hatchstyle, Color foreColor);
    public HatchBrush(HatchStyle hatchstyle, Color foreColor, Color backColor);
    internal HatchBrush(IntPtr nativeBrush);
    public virtual object Clone();
    public HatchStyle get_HatchStyle();
    public Color get_ForegroundColor();
    public Color get_BackgroundColor();
}
public enum System.Drawing.Drawing2D.HatchStyle : Enum {
    
public int value__;
    
public static HatchStyle Horizontal;
    
public static HatchStyle Vertical;
    
public static HatchStyle ForwardDiagonal;
    
public static HatchStyle BackwardDiagonal;
    
public static HatchStyle Cross;
    
public static HatchStyle DiagonalCross;
    
public static HatchStyle Percent05;
    
public static HatchStyle Percent10;
    
public static HatchStyle Percent20;
    
public static HatchStyle Percent25;
    
public static HatchStyle Percent30;
    
public static HatchStyle Percent40;
    
public static HatchStyle Percent50;
    
public static HatchStyle Percent60;
    
public static HatchStyle Percent70;
    
public static HatchStyle Percent75;
    
public static HatchStyle Percent80;
    
public static HatchStyle Percent90;
    
public static HatchStyle LightDownwardDiagonal;
    
public static HatchStyle LightUpwardDiagonal;
    
public static HatchStyle DarkDownwardDiagonal;
    
public static HatchStyle DarkUpwardDiagonal;
    
public static HatchStyle WideDownwardDiagonal;
    
public static HatchStyle WideUpwardDiagonal;
    
public static HatchStyle LightVertical;
    
public static HatchStyle LightHorizontal;
    
public static HatchStyle NarrowVertical;
    
public static HatchStyle NarrowHorizontal;
    
public static HatchStyle DarkVertical;
    
public static HatchStyle DarkHorizontal;
    
public static HatchStyle DashedDownwardDiagonal;
    
public static HatchStyle DashedUpwardDiagonal;
    
public static HatchStyle DashedHorizontal;
    
public static HatchStyle DashedVertical;
    
public static HatchStyle SmallConfetti;
    
public static HatchStyle LargeConfetti;
    
public static HatchStyle ZigZag;
    
public static HatchStyle Wave;
    
public static HatchStyle DiagonalBrick;
    
public static HatchStyle HorizontalBrick;
    
public static HatchStyle Weave;
    
public static HatchStyle Plaid;
    
public static HatchStyle Divot;
    
public static HatchStyle DottedGrid;
    
public static HatchStyle DottedDiamond;
    
public static HatchStyle Shingle;
    
public static HatchStyle Trellis;
    
public static HatchStyle Sphere;
    
public static HatchStyle SmallGrid;
    
public static HatchStyle SmallCheckerBoard;
    
public static HatchStyle LargeCheckerBoard;
    
public static HatchStyle OutlinedDiamond;
    
public static HatchStyle SolidDiamond;
    
public static HatchStyle LargeGrid;
    
public static HatchStyle Min;
    
public static HatchStyle Max;
}
public enum System.Drawing.Drawing2D.InterpolationMode : Enum {
    
public int value__;
    
public static InterpolationMode Invalid;
    
public static InterpolationMode Default;
    
public static InterpolationMode Low;
    
public static InterpolationMode High;
    
public static InterpolationMode Bilinear;
    
public static InterpolationMode Bicubic;
    
public static InterpolationMode NearestNeighbor;
    
public static InterpolationMode HighQualityBilinear;
    
public static InterpolationMode HighQualityBicubic;
}
public class System.Drawing.Drawing2D.LinearGradientBrush : Brush {
    
private RectangleF rectangle;
    
public Blend Blend { get; public set; }
    [MonoTODOAttribute("The GammaCorrection value is ignored when using libgdiplus.")]

public bool GammaCorrection { get; public set; }
    
public ColorBlend InterpolationColors { get; public set; }
    
public Color[] LinearColors { get; public set; }
    
public RectangleF Rectangle { get; }
    
public Matrix Transform { get; public set; }
    
public WrapMode WrapMode { get; public set; }
    internal LinearGradientBrush(IntPtr native);
    public LinearGradientBrush(Point point1, Point point2, Color color1, Color color2);
    public LinearGradientBrush(PointF point1, PointF point2, Color color1, Color color2);
    public LinearGradientBrush(Rectangle rect, Color color1, Color color2, LinearGradientMode linearGradientMode);
    public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle);
    public LinearGradientBrush(RectangleF rect, Color color1, Color color2, LinearGradientMode linearGradientMode);
    public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle);
    public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle, bool isAngleScaleable);
    public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle, bool isAngleScaleable);
    public Blend get_Blend();
    public void set_Blend(Blend value);
    public bool get_GammaCorrection();
    public void set_GammaCorrection(bool value);
    public ColorBlend get_InterpolationColors();
    public void set_InterpolationColors(ColorBlend value);
    public Color[] get_LinearColors();
    public void set_LinearColors(Color[] value);
    public RectangleF get_Rectangle();
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public WrapMode get_WrapMode();
    public void set_WrapMode(WrapMode value);
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void ResetTransform();
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void SetBlendTriangularShape(float focus);
    public void SetBlendTriangularShape(float focus, float scale);
    public void SetSigmaBellShape(float focus);
    public void SetSigmaBellShape(float focus, float scale);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public virtual object Clone();
}
public enum System.Drawing.Drawing2D.LinearGradientMode : Enum {
    
public int value__;
    
public static LinearGradientMode Horizontal;
    
public static LinearGradientMode Vertical;
    
public static LinearGradientMode ForwardDiagonal;
    
public static LinearGradientMode BackwardDiagonal;
}
public enum System.Drawing.Drawing2D.LineCap : Enum {
    
public int value__;
    
public static LineCap Flat;
    
public static LineCap Square;
    
public static LineCap Round;
    
public static LineCap Triangle;
    
public static LineCap NoAnchor;
    
public static LineCap SquareAnchor;
    
public static LineCap RoundAnchor;
    
public static LineCap DiamondAnchor;
    
public static LineCap ArrowAnchor;
    
public static LineCap Custom;
    
public static LineCap AnchorMask;
}
public enum System.Drawing.Drawing2D.LineJoin : Enum {
    
public int value__;
    
public static LineJoin Miter;
    
public static LineJoin Bevel;
    
public static LineJoin Round;
    
public static LineJoin MiterClipped;
}
public class System.Drawing.Drawing2D.Matrix : MarshalByRefObject {
    
internal IntPtr nativeMatrix;
    
public Single[] Elements { get; }
    
public bool IsIdentity { get; }
    
public bool IsInvertible { get; }
    
public float OffsetX { get; }
    
public float OffsetY { get; }
    
internal IntPtr NativeObject { get; internal set; }
    internal Matrix(IntPtr ptr);
    public Matrix(Rectangle rect, Point[] plgpts);
    public Matrix(RectangleF rect, PointF[] plgpts);
    public Matrix(float m11, float m12, float m21, float m22, float dx, float dy);
    public Single[] get_Elements();
    public bool get_IsIdentity();
    public bool get_IsInvertible();
    public float get_OffsetX();
    public float get_OffsetY();
    public Matrix Clone();
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    protected virtual override void Finalize();
    public virtual int GetHashCode();
    public void Invert();
    public void Multiply(Matrix matrix);
    public void Multiply(Matrix matrix, MatrixOrder order);
    public void Reset();
    public void Rotate(float angle);
    public void Rotate(float angle, MatrixOrder order);
    public void RotateAt(float angle, PointF point);
    public void RotateAt(float angle, PointF point, MatrixOrder order);
    public void Scale(float scaleX, float scaleY);
    public void Scale(float scaleX, float scaleY, MatrixOrder order);
    public void Shear(float shearX, float shearY);
    public void Shear(float shearX, float shearY, MatrixOrder order);
    public void TransformPoints(Point[] pts);
    public void TransformPoints(PointF[] pts);
    public void TransformVectors(Point[] pts);
    public void TransformVectors(PointF[] pts);
    public void Translate(float offsetX, float offsetY);
    public void Translate(float offsetX, float offsetY, MatrixOrder order);
    public void VectorTransformPoints(Point[] pts);
    internal IntPtr get_NativeObject();
    internal void set_NativeObject(IntPtr value);
}
public enum System.Drawing.Drawing2D.MatrixOrder : Enum {
    
public int value__;
    
public static MatrixOrder Prepend;
    
public static MatrixOrder Append;
}
public class System.Drawing.Drawing2D.PathData : object {
    [CompilerGeneratedAttribute]

private PointF[] <Points>k__BackingField;
    [CompilerGeneratedAttribute]

private Byte[] <Types>k__BackingField;
    
public PointF[] Points { get; public set; }
    
public Byte[] Types { get; public set; }
    [CompilerGeneratedAttribute]
public PointF[] get_Points();
    [CompilerGeneratedAttribute]
public void set_Points(PointF[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(Byte[] value);
}
[MonoTODOAttribute("libgdiplus/cairo doesn't support path gradients - unless it can be mapped to a radial gradient")]
public class System.Drawing.Drawing2D.PathGradientBrush : Brush {
    
public Blend Blend { get; public set; }
    
public Color CenterColor { get; public set; }
    
public PointF CenterPoint { get; public set; }
    
public PointF FocusScales { get; public set; }
    
public ColorBlend InterpolationColors { get; public set; }
    
public RectangleF Rectangle { get; }
    
public Color[] SurroundColors { get; public set; }
    
public Matrix Transform { get; public set; }
    
public WrapMode WrapMode { get; public set; }
    internal PathGradientBrush(IntPtr native);
    public PathGradientBrush(GraphicsPath path);
    public PathGradientBrush(Point[] points);
    public PathGradientBrush(PointF[] points);
    public PathGradientBrush(Point[] points, WrapMode wrapMode);
    public PathGradientBrush(PointF[] points, WrapMode wrapMode);
    public Blend get_Blend();
    public void set_Blend(Blend value);
    public Color get_CenterColor();
    public void set_CenterColor(Color value);
    public PointF get_CenterPoint();
    public void set_CenterPoint(PointF value);
    public PointF get_FocusScales();
    public void set_FocusScales(PointF value);
    public ColorBlend get_InterpolationColors();
    public void set_InterpolationColors(ColorBlend value);
    public RectangleF get_Rectangle();
    public Color[] get_SurroundColors();
    public void set_SurroundColors(Color[] value);
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public WrapMode get_WrapMode();
    public void set_WrapMode(WrapMode value);
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void ResetTransform();
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void SetBlendTriangularShape(float focus);
    public void SetBlendTriangularShape(float focus, float scale);
    public void SetSigmaBellShape(float focus);
    public void SetSigmaBellShape(float focus, float scale);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public virtual object Clone();
}
public enum System.Drawing.Drawing2D.PathPointType : Enum {
    
public int value__;
    
public static PathPointType Start;
    
public static PathPointType Line;
    
public static PathPointType Bezier;
    
public static PathPointType PathTypeMask;
    
public static PathPointType DashMode;
    
public static PathPointType PathMarker;
    
public static PathPointType CloseSubpath;
    
public static PathPointType Bezier3;
}
public enum System.Drawing.Drawing2D.PenAlignment : Enum {
    
public int value__;
    
public static PenAlignment Center;
    
public static PenAlignment Inset;
    
public static PenAlignment Outset;
    
public static PenAlignment Left;
    
public static PenAlignment Right;
}
public enum System.Drawing.Drawing2D.PenType : Enum {
    
public int value__;
    
public static PenType SolidColor;
    
public static PenType HatchFill;
    
public static PenType TextureFill;
    
public static PenType PathGradient;
    
public static PenType LinearGradient;
}
public enum System.Drawing.Drawing2D.PixelOffsetMode : Enum {
    
public int value__;
    
public static PixelOffsetMode Invalid;
    
public static PixelOffsetMode Default;
    
public static PixelOffsetMode HighSpeed;
    
public static PixelOffsetMode HighQuality;
    
public static PixelOffsetMode None;
    
public static PixelOffsetMode Half;
}
public enum System.Drawing.Drawing2D.QualityMode : Enum {
    
public int value__;
    
public static QualityMode Invalid;
    
public static QualityMode Default;
    
public static QualityMode Low;
    
public static QualityMode High;
}
public class System.Drawing.Drawing2D.RegionData : object {
    [CompilerGeneratedAttribute]

private Byte[] <Data>k__BackingField;
    
public Byte[] Data { get; public set; }
    internal RegionData(Byte[] data);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
}
[SecurityCriticalAttribute]
internal class System.Drawing.Drawing2D.SafeCustomLineCapHandle : SafeHandle {
    
public bool IsInvalid { get; }
    internal SafeCustomLineCapHandle(IntPtr h);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    public static IntPtr op_Implicit(SafeCustomLineCapHandle handle);
    public static SafeCustomLineCapHandle op_Explicit(IntPtr handle);
}
public enum System.Drawing.Drawing2D.SmoothingMode : Enum {
    
public int value__;
    
public static SmoothingMode Invalid;
    
public static SmoothingMode Default;
    
public static SmoothingMode HighSpeed;
    
public static SmoothingMode HighQuality;
    
public static SmoothingMode None;
    
public static SmoothingMode AntiAlias;
}
public enum System.Drawing.Drawing2D.WarpMode : Enum {
    
public int value__;
    
public static WarpMode Perspective;
    
public static WarpMode Bilinear;
}
public enum System.Drawing.Drawing2D.WrapMode : Enum {
    
public int value__;
    
public static WrapMode Tile;
    
public static WrapMode TileFlipX;
    
public static WrapMode TileFlipY;
    
public static WrapMode TileFlipXY;
    
public static WrapMode Clamp;
}
internal class System.Drawing.ExternDll : object {
    
public static string Gdiplus;
    
public static string User32;
    
public static string Gdi32;
    
public static string Kernel32;
    
public static string Winspool;
    
public static string Comdlg32;
    
public static string Comctl32;
    
public static string Shell32;
    
public static string Oleaut32;
}
[EditorAttribute("System.Drawing.Design.FontEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
[ComVisibleAttribute("True")]
[TypeConverterAttribute("System.Drawing.FontConverter")]
public class System.Drawing.Font : MarshalByRefObject {
    
private IntPtr fontObject;
    
private string systemFontName;
    
private string originalFontName;
    
private float _size;
    
private object olf;
    
private static byte DefaultCharSet;
    
private static int CharSetOffset;
    
private bool _bold;
    
private FontFamily _fontFamily;
    
private byte _gdiCharSet;
    
private bool _gdiVerticalFont;
    
private bool _italic;
    
private string _name;
    
private float _sizeInPoints;
    
private bool _strikeout;
    
private FontStyle _style;
    
private bool _underline;
    
private GraphicsUnit _unit;
    
private int _hashCode;
    
internal IntPtr NativeObject { get; }
    [DesignerSerializationVisibilityAttribute("0")]

public bool Bold { get; }
    [BrowsableAttribute("False")]

public FontFamily FontFamily { get; }
    [DesignerSerializationVisibilityAttribute("0")]

public byte GdiCharSet { get; }
    [DesignerSerializationVisibilityAttribute("0")]

public bool GdiVerticalFont { get; }
    [BrowsableAttribute("False")]

public int Height { get; }
    [BrowsableAttribute("False")]

public bool IsSystemFont { get; }
    [DesignerSerializationVisibilityAttribute("0")]

public bool Italic { get; }
    [TypeConverterAttribute("System.Drawing.FontConverter/FontNameConverter")]
[EditorAttribute("System.Drawing.Design.FontNameEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
[DesignerSerializationVisibilityAttribute("0")]

public string Name { get; }
    
public float Size { get; }
    [BrowsableAttribute("False")]

public float SizeInPoints { get; }
    [DesignerSerializationVisibilityAttribute("0")]

public bool Strikeout { get; }
    [BrowsableAttribute("False")]

public FontStyle Style { get; }
    [BrowsableAttribute("False")]

public string SystemFontName { get; }
    [BrowsableAttribute("False")]

public string OriginalFontName { get; }
    [DesignerSerializationVisibilityAttribute("0")]

public bool Underline { get; }
    [TypeConverterAttribute("System.Drawing.FontConverter/FontUnitConverter")]

public GraphicsUnit Unit { get; }
    private Font(SerializationInfo info, StreamingContext context);
    internal Font(IntPtr newFontObject, string familyName, FontStyle style, float size);
    public Font(Font prototype, FontStyle newStyle);
    public Font(FontFamily family, float emSize, GraphicsUnit unit);
    public Font(string familyName, float emSize, GraphicsUnit unit);
    public Font(FontFamily family, float emSize);
    public Font(FontFamily family, float emSize, FontStyle style);
    public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit);
    public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet);
    public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont);
    public Font(string familyName, float emSize);
    public Font(string familyName, float emSize, FontStyle style);
    public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit);
    public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet);
    public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont);
    internal Font(string familyName, float emSize, string systemName);
    private static Font();
    private void CreateFont(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte charSet, bool isVertical);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal void SetSystemFontName(string newSystemFontName);
    internal void unitConversion(GraphicsUnit fromUnit, GraphicsUnit toUnit, float nSrc, Single& nTrg);
    private void setProperties(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte charSet, bool isVertical);
    public static Font FromHfont(IntPtr hfont);
    public IntPtr ToHfont();
    public sealed virtual object Clone();
    internal IntPtr get_NativeObject();
    public bool get_Bold();
    public FontFamily get_FontFamily();
    public byte get_GdiCharSet();
    public bool get_GdiVerticalFont();
    public int get_Height();
    public bool get_IsSystemFont();
    public bool get_Italic();
    public string get_Name();
    public float get_Size();
    public float get_SizeInPoints();
    public bool get_Strikeout();
    public FontStyle get_Style();
    public string get_SystemFontName();
    public string get_OriginalFontName();
    public bool get_Underline();
    public GraphicsUnit get_Unit();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [MonoTODOAttribute("The hdc parameter has no direct equivalent in libgdiplus.")]
public static Font FromHdc(IntPtr hdc);
    [MonoTODOAttribute("The returned font may not have all it's properties initialized correctly.")]
public static Font FromLogFont(object lf, IntPtr hdc);
    public float GetHeight();
    public static Font FromLogFont(object lf);
    public void ToLogFont(object logFont);
    public void ToLogFont(object logFont, Graphics graphics);
    public float GetHeight(Graphics graphics);
    public float GetHeight(float dpi);
    public virtual string ToString();
}
public class System.Drawing.FontConverter : TypeConverter {
    protected virtual override void Finalize();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.FontFamily : MarshalByRefObject {
    
private string name;
    
private IntPtr nativeFontFamily;
    
internal IntPtr NativeObject { get; }
    
internal IntPtr NativeFamily { get; }
    
public string Name { get; }
    
public static FontFamily GenericMonospace { get; }
    
public static FontFamily GenericSansSerif { get; }
    
public static FontFamily GenericSerif { get; }
    
public static FontFamily[] Families { get; }
    internal FontFamily(IntPtr fntfamily);
    public FontFamily(GenericFontFamilies genericFamily);
    public FontFamily(string name);
    public FontFamily(string name, FontCollection fontCollection);
    internal void refreshName();
    protected virtual override void Finalize();
    internal IntPtr get_NativeObject();
    internal IntPtr get_NativeFamily();
    public string get_Name();
    public static FontFamily get_GenericMonospace();
    public static FontFamily get_GenericSansSerif();
    public static FontFamily get_GenericSerif();
    public int GetCellAscent(FontStyle style);
    public int GetCellDescent(FontStyle style);
    public int GetEmHeight(FontStyle style);
    public int GetLineSpacing(FontStyle style);
    [MonoDocumentationNoteAttribute("When used with libgdiplus this method always return true (styles are created on demand).")]
public bool IsStyleAvailable(FontStyle style);
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static FontFamily[] get_Families();
    public static FontFamily[] GetFamilies(Graphics graphics);
    [MonoLimitationAttribute("The language parameter is ignored. We always return the name using the default system language.")]
public string GetName(int language);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Drawing.FontStyle : Enum {
    
public int value__;
    
public static FontStyle Regular;
    
public static FontStyle Bold;
    
public static FontStyle Italic;
    
public static FontStyle Underline;
    
public static FontStyle Strikeout;
}
internal class System.Drawing.GdiColorMap : ValueType {
    
internal int from;
    
internal int to;
}
internal class System.Drawing.GdiColorPalette : ValueType {
    
internal int Flags;
    
internal int Count;
}
internal class System.Drawing.GdipEncoderParameter : ValueType {
    
internal Guid guid;
    
internal UInt32 numberOfValues;
    
internal EncoderParameterValueType type;
    
internal IntPtr value;
}
internal class System.Drawing.GdipImageCodecInfo : ValueType {
    
internal Guid Clsid;
    
internal Guid FormatID;
    
internal IntPtr CodecName;
    
internal IntPtr DllName;
    
internal IntPtr FormatDescription;
    
internal IntPtr FilenameExtension;
    
internal IntPtr MimeType;
    
internal ImageCodecFlags Flags;
    
internal int Version;
    
internal int SigCount;
    
internal int SigSize;
    
private IntPtr SigPattern;
    
private IntPtr SigMask;
    internal static void MarshalTo(GdipImageCodecInfo gdipcodec, ImageCodecInfo codec);
}
internal class System.Drawing.GDIPlus : object {
    
public static int FACESIZE;
    
public static int LANG_NEUTRAL;
    
public static IntPtr Display;
    
public static bool UseX11Drawable;
    
public static bool UseCarbonDrawable;
    
public static bool UseCocoaDrawable;
    
private static string GdiPlus;
    
internal static ulong GdiPlusToken;
    private static GDIPlus();
    internal static Status GdiplusStartup(UInt64& token, GdiplusStartupInput& input, GdiplusStartupOutput& output);
    internal static void GdiplusShutdown(UInt64& token);
    private static void ProcessExit(object sender, EventArgs e);
    public static bool RunningOnWindows();
    public static bool RunningOnUnix();
    public static void FromUnManagedMemoryToPointI(IntPtr prt, Point[] pts);
    public static void FromUnManagedMemoryToPoint(IntPtr prt, PointF[] pts);
    public static IntPtr FromPointToUnManagedMemoryI(Point[] pts);
    public static void FromUnManagedMemoryToRectangles(IntPtr prt, RectangleF[] pts);
    public static IntPtr FromPointToUnManagedMemory(PointF[] pts);
    internal static void CheckStatus(Status status);
    internal static IntPtr GdipAlloc(int size);
    internal static void GdipFree(IntPtr ptr);
    internal static int GdipCloneBrush(HandleRef brush, IntPtr& clonedBrush);
    internal static int GdipDeleteBrush(HandleRef brush);
    internal static int GdipGetBrushType(HandleRef brush, BrushType& type);
    internal static Status GdipCreateRegion(IntPtr& region);
    internal static Status GdipCreateRegionRgnData(Byte[] data, int size, IntPtr& region);
    internal static Status GdipDeleteRegion(IntPtr region);
    internal static Status GdipCloneRegion(IntPtr region, IntPtr& cloned);
    internal static Status GdipCreateRegionRect(RectangleF& rect, IntPtr& region);
    internal static Status GdipCreateRegionRectI(Rectangle& rect, IntPtr& region);
    internal static Status GdipCreateRegionPath(IntPtr path, IntPtr& region);
    internal static Status GdipTranslateRegion(IntPtr region, float dx, float dy);
    internal static Status GdipTranslateRegionI(IntPtr region, int dx, int dy);
    internal static Status GdipIsVisibleRegionPoint(IntPtr region, float x, float y, IntPtr graphics, Boolean& result);
    internal static Status GdipIsVisibleRegionPointI(IntPtr region, int x, int y, IntPtr graphics, Boolean& result);
    internal static Status GdipIsVisibleRegionRect(IntPtr region, float x, float y, float width, float height, IntPtr graphics, Boolean& result);
    internal static Status GdipIsVisibleRegionRectI(IntPtr region, int x, int y, int width, int height, IntPtr graphics, Boolean& result);
    internal static Status GdipCombineRegionRect(IntPtr region, RectangleF& rect, CombineMode combineMode);
    internal static Status GdipCombineRegionRectI(IntPtr region, Rectangle& rect, CombineMode combineMode);
    internal static Status GdipCombineRegionPath(IntPtr region, IntPtr path, CombineMode combineMode);
    internal static Status GdipGetRegionBounds(IntPtr region, IntPtr graphics, RectangleF& rect);
    internal static Status GdipSetInfinite(IntPtr region);
    internal static Status GdipSetEmpty(IntPtr region);
    internal static Status GdipIsEmptyRegion(IntPtr region, IntPtr graphics, Boolean& result);
    internal static Status GdipIsInfiniteRegion(IntPtr region, IntPtr graphics, Boolean& result);
    internal static Status GdipCombineRegionRegion(IntPtr region, IntPtr region2, CombineMode combineMode);
    internal static Status GdipIsEqualRegion(IntPtr region, IntPtr region2, IntPtr graphics, Boolean& result);
    internal static Status GdipGetRegionDataSize(IntPtr region, Int32& bufferSize);
    internal static Status GdipGetRegionData(IntPtr region, Byte[] buffer, int bufferSize, Int32& sizeFilled);
    internal static Status GdipGetRegionScansCount(IntPtr region, Int32& count, IntPtr matrix);
    internal static Status GdipGetRegionScans(IntPtr region, IntPtr rects, Int32& count, IntPtr matrix);
    internal static Status GdipTransformRegion(IntPtr region, IntPtr matrix);
    internal static Status GdipFillRegion(IntPtr graphics, IntPtr brush, IntPtr region);
    internal static Status GdipGetRegionHRgn(IntPtr region, IntPtr graphics, IntPtr& hRgn);
    internal static Status GdipCreateRegionHrgn(IntPtr hRgn, IntPtr& region);
    internal static int GdipCreateSolidFill(int color, IntPtr& brush);
    internal static int GdipGetSolidFillColor(HandleRef brush, Int32& color);
    internal static int GdipSetSolidFillColor(HandleRef brush, int color);
    internal static int GdipCreateHatchBrush(int hatchstyle, int foreColor, int backColor, IntPtr& brush);
    internal static int GdipGetHatchStyle(HandleRef brush, Int32& hatchstyle);
    internal static int GdipGetHatchForegroundColor(HandleRef brush, Int32& foreColor);
    internal static int GdipGetHatchBackgroundColor(HandleRef brush, Int32& backColor);
    internal static int GdipGetTextureImage(HandleRef texture, IntPtr& image);
    internal static int GdipCreateTexture(HandleRef image, int wrapMode, IntPtr& texture);
    internal static int GdipCreateTextureIAI(HandleRef image, HandleRef imageAttributes, int x, int y, int width, int height, IntPtr& texture);
    internal static int GdipCreateTextureIA(HandleRef image, HandleRef imageAttributes, float x, float y, float width, float height, IntPtr& texture);
    internal static int GdipCreateTexture2I(HandleRef image, int wrapMode, int x, int y, int width, int height, IntPtr& texture);
    internal static int GdipCreateTexture2(HandleRef image, int wrapMode, float x, float y, float width, float height, IntPtr& texture);
    internal static int GdipGetTextureTransform(HandleRef texture, HandleRef matrix);
    internal static int GdipSetTextureTransform(HandleRef texture, HandleRef matrix);
    internal static int GdipGetTextureWrapMode(HandleRef texture, Int32& wrapMode);
    internal static int GdipSetTextureWrapMode(HandleRef texture, int wrapMode);
    internal static int GdipMultiplyTextureTransform(HandleRef texture, HandleRef matrix, MatrixOrder order);
    internal static int GdipResetTextureTransform(HandleRef texture);
    internal static int GdipRotateTextureTransform(HandleRef texture, float angle, MatrixOrder order);
    internal static int GdipScaleTextureTransform(HandleRef texture, float sx, float sy, MatrixOrder order);
    internal static int GdipTranslateTextureTransform(HandleRef texture, float dx, float dy, MatrixOrder order);
    internal static Status GdipCreatePathGradientFromPath(IntPtr path, IntPtr& brush);
    internal static Status GdipCreatePathGradientI(Point[] points, int count, WrapMode wrapMode, IntPtr& brush);
    internal static Status GdipCreatePathGradient(PointF[] points, int count, WrapMode wrapMode, IntPtr& brush);
    internal static Status GdipGetPathGradientBlendCount(IntPtr brush, Int32& count);
    internal static Status GdipGetPathGradientBlend(IntPtr brush, Single[] blend, Single[] positions, int count);
    internal static Status GdipSetPathGradientBlend(IntPtr brush, Single[] blend, Single[] positions, int count);
    internal static Status GdipGetPathGradientCenterColor(IntPtr brush, Int32& color);
    internal static Status GdipSetPathGradientCenterColor(IntPtr brush, int color);
    internal static Status GdipGetPathGradientCenterPoint(IntPtr brush, PointF& point);
    internal static Status GdipSetPathGradientCenterPoint(IntPtr brush, PointF& point);
    internal static Status GdipGetPathGradientFocusScales(IntPtr brush, Single& xScale, Single& yScale);
    internal static Status GdipSetPathGradientFocusScales(IntPtr brush, float xScale, float yScale);
    internal static Status GdipGetPathGradientPresetBlendCount(IntPtr brush, Int32& count);
    internal static Status GdipGetPathGradientPresetBlend(IntPtr brush, Int32[] blend, Single[] positions, int count);
    internal static Status GdipSetPathGradientPresetBlend(IntPtr brush, Int32[] blend, Single[] positions, int count);
    internal static Status GdipGetPathGradientRect(IntPtr brush, RectangleF& rect);
    internal static Status GdipGetPathGradientSurroundColorCount(IntPtr brush, Int32& count);
    internal static Status GdipGetPathGradientSurroundColorsWithCount(IntPtr brush, Int32[] color, Int32& count);
    internal static Status GdipSetPathGradientSurroundColorsWithCount(IntPtr brush, Int32[] color, Int32& count);
    internal static Status GdipGetPathGradientTransform(IntPtr brush, IntPtr matrix);
    internal static Status GdipSetPathGradientTransform(IntPtr brush, IntPtr matrix);
    internal static Status GdipGetPathGradientWrapMode(IntPtr brush, WrapMode& wrapMode);
    internal static Status GdipSetPathGradientWrapMode(IntPtr brush, WrapMode wrapMode);
    internal static Status GdipSetPathGradientLinearBlend(IntPtr brush, float focus, float scale);
    internal static Status GdipSetPathGradientSigmaBlend(IntPtr brush, float focus, float scale);
    internal static Status GdipMultiplyPathGradientTransform(IntPtr texture, IntPtr matrix, MatrixOrder order);
    internal static Status GdipResetPathGradientTransform(IntPtr brush);
    internal static Status GdipRotatePathGradientTransform(IntPtr brush, float angle, MatrixOrder order);
    internal static Status GdipScalePathGradientTransform(IntPtr brush, float sx, float sy, MatrixOrder order);
    internal static Status GdipTranslatePathGradientTransform(IntPtr brush, float dx, float dy, MatrixOrder order);
    internal static Status GdipCreateLineBrushI(Point& point1, Point& point2, int color1, int color2, WrapMode wrapMode, IntPtr& brush);
    internal static Status GdipCreateLineBrush(PointF& point1, PointF& point2, int color1, int color2, WrapMode wrapMode, IntPtr& brush);
    internal static Status GdipCreateLineBrushFromRectI(Rectangle& rect, int color1, int color2, LinearGradientMode linearGradientMode, WrapMode wrapMode, IntPtr& brush);
    internal static Status GdipCreateLineBrushFromRect(RectangleF& rect, int color1, int color2, LinearGradientMode linearGradientMode, WrapMode wrapMode, IntPtr& brush);
    internal static Status GdipCreateLineBrushFromRectWithAngleI(Rectangle& rect, int color1, int color2, float angle, bool isAngleScaleable, WrapMode wrapMode, IntPtr& brush);
    internal static Status GdipCreateLineBrushFromRectWithAngle(RectangleF& rect, int color1, int color2, float angle, bool isAngleScaleable, WrapMode wrapMode, IntPtr& brush);
    internal static Status GdipGetLineBlendCount(IntPtr brush, Int32& count);
    internal static Status GdipSetLineBlend(IntPtr brush, Single[] blend, Single[] positions, int count);
    internal static Status GdipGetLineBlend(IntPtr brush, Single[] blend, Single[] positions, int count);
    internal static Status GdipSetLineGammaCorrection(IntPtr brush, bool useGammaCorrection);
    internal static Status GdipGetLineGammaCorrection(IntPtr brush, Boolean& useGammaCorrection);
    internal static Status GdipGetLinePresetBlendCount(IntPtr brush, Int32& count);
    internal static Status GdipSetLinePresetBlend(IntPtr brush, Int32[] blend, Single[] positions, int count);
    internal static Status GdipGetLinePresetBlend(IntPtr brush, Int32[] blend, Single[] positions, int count);
    internal static Status GdipSetLineColors(IntPtr brush, int color1, int color2);
    internal static Status GdipGetLineColors(IntPtr brush, Int32[] colors);
    internal static Status GdipGetLineRectI(IntPtr brush, Rectangle& rect);
    internal static Status GdipGetLineRect(IntPtr brush, RectangleF& rect);
    internal static Status GdipSetLineTransform(IntPtr brush, IntPtr matrix);
    internal static Status GdipGetLineTransform(IntPtr brush, IntPtr matrix);
    internal static Status GdipSetLineWrapMode(IntPtr brush, WrapMode wrapMode);
    internal static Status GdipGetLineWrapMode(IntPtr brush, WrapMode& wrapMode);
    internal static Status GdipSetLineLinearBlend(IntPtr brush, float focus, float scale);
    internal static Status GdipSetLineSigmaBlend(IntPtr brush, float focus, float scale);
    internal static Status GdipMultiplyLineTransform(IntPtr brush, IntPtr matrix, MatrixOrder order);
    internal static Status GdipResetLineTransform(IntPtr brush);
    internal static Status GdipRotateLineTransform(IntPtr brush, float angle, MatrixOrder order);
    internal static Status GdipScaleLineTransform(IntPtr brush, float sx, float sy, MatrixOrder order);
    internal static Status GdipTranslateLineTransform(IntPtr brush, float dx, float dy, MatrixOrder order);
    internal static Status GdipCreateFromHDC(IntPtr hDC, IntPtr& graphics);
    internal static Status GdipDeleteGraphics(IntPtr graphics);
    internal static Status GdipRestoreGraphics(IntPtr graphics, UInt32 graphicsState);
    internal static Status GdipSaveGraphics(IntPtr graphics, UInt32& state);
    internal static Status GdipMultiplyWorldTransform(IntPtr graphics, IntPtr matrix, MatrixOrder order);
    internal static Status GdipRotateWorldTransform(IntPtr graphics, float angle, MatrixOrder order);
    internal static Status GdipTranslateWorldTransform(IntPtr graphics, float dx, float dy, MatrixOrder order);
    internal static Status GdipDrawArc(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    internal static Status GdipDrawArcI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle);
    internal static Status GdipDrawBezier(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
    internal static Status GdipDrawBezierI(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    internal static Status GdipDrawEllipseI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);
    internal static Status GdipDrawEllipse(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);
    internal static Status GdipDrawLine(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2);
    internal static Status GdipDrawLineI(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2);
    internal static Status GdipDrawLines(IntPtr graphics, IntPtr pen, PointF[] points, int count);
    internal static Status GdipDrawLinesI(IntPtr graphics, IntPtr pen, Point[] points, int count);
    internal static Status GdipDrawPath(IntPtr graphics, IntPtr pen, IntPtr path);
    internal static Status GdipDrawPie(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    internal static Status GdipDrawPieI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle);
    internal static Status GdipDrawPolygon(IntPtr graphics, IntPtr pen, PointF[] points, int count);
    internal static Status GdipDrawPolygonI(IntPtr graphics, IntPtr pen, Point[] points, int count);
    internal static Status GdipDrawRectangle(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);
    internal static Status GdipDrawRectangleI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);
    internal static Status GdipDrawRectangles(IntPtr graphics, IntPtr pen, RectangleF[] rects, int count);
    internal static Status GdipDrawRectanglesI(IntPtr graphics, IntPtr pen, Rectangle[] rects, int count);
    internal static Status GdipFillEllipseI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);
    internal static Status GdipFillEllipse(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);
    internal static Status GdipFillPolygon(IntPtr graphics, IntPtr brush, PointF[] points, int count, FillMode fillMode);
    internal static Status GdipFillPolygonI(IntPtr graphics, IntPtr brush, Point[] points, int count, FillMode fillMode);
    internal static Status GdipFillPolygon2(IntPtr graphics, IntPtr brush, PointF[] points, int count);
    internal static Status GdipFillPolygon2I(IntPtr graphics, IntPtr brush, Point[] points, int count);
    internal static Status GdipFillRectangle(IntPtr graphics, IntPtr brush, float x1, float y1, float x2, float y2);
    internal static Status GdipFillRectangleI(IntPtr graphics, IntPtr brush, int x1, int y1, int x2, int y2);
    internal static Status GdipFillRectangles(IntPtr graphics, IntPtr brush, RectangleF[] rects, int count);
    internal static Status GdipFillRectanglesI(IntPtr graphics, IntPtr brush, Rectangle[] rects, int count);
    internal static Status GdipDrawString(IntPtr graphics, string text, int len, IntPtr font, RectangleF& rc, IntPtr format, IntPtr brush);
    internal static Status GdipGetDC(IntPtr graphics, IntPtr& hdc);
    internal static Status GdipReleaseDC(IntPtr graphics, IntPtr hdc);
    internal static Status GdipDrawImageRectI(IntPtr graphics, IntPtr image, int x, int y, int width, int height);
    internal static Status GdipGetRenderingOrigin(IntPtr graphics, Int32& x, Int32& y);
    internal static Status GdipSetRenderingOrigin(IntPtr graphics, int x, int y);
    internal static Status GdipCloneBitmapArea(float x, float y, float width, float height, PixelFormat format, IntPtr original, IntPtr& bitmap);
    internal static Status GdipCloneBitmapAreaI(int x, int y, int width, int height, PixelFormat format, IntPtr original, IntPtr& bitmap);
    internal static Status GdipResetWorldTransform(IntPtr graphics);
    internal static Status GdipSetWorldTransform(IntPtr graphics, IntPtr matrix);
    internal static Status GdipGetWorldTransform(IntPtr graphics, IntPtr matrix);
    internal static Status GdipScaleWorldTransform(IntPtr graphics, float sx, float sy, MatrixOrder order);
    internal static Status GdipGraphicsClear(IntPtr graphics, int argb);
    internal static Status GdipDrawClosedCurve(IntPtr graphics, IntPtr pen, PointF[] points, int count);
    internal static Status GdipDrawClosedCurveI(IntPtr graphics, IntPtr pen, Point[] points, int count);
    internal static Status GdipDrawClosedCurve2(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension);
    internal static Status GdipDrawClosedCurve2I(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension);
    internal static Status GdipDrawCurve(IntPtr graphics, IntPtr pen, PointF[] points, int count);
    internal static Status GdipDrawCurveI(IntPtr graphics, IntPtr pen, Point[] points, int count);
    internal static Status GdipDrawCurve2(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension);
    internal static Status GdipDrawCurve2I(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension);
    internal static Status GdipDrawCurve3(IntPtr graphics, IntPtr pen, PointF[] points, int count, int offset, int numberOfSegments, float tension);
    internal static Status GdipDrawCurve3I(IntPtr graphics, IntPtr pen, Point[] points, int count, int offset, int numberOfSegments, float tension);
    internal static Status GdipSetClipRect(IntPtr graphics, float x, float y, float width, float height, CombineMode combineMode);
    internal static Status GdipSetClipRectI(IntPtr graphics, int x, int y, int width, int height, CombineMode combineMode);
    internal static Status GdipSetClipPath(IntPtr graphics, IntPtr path, CombineMode combineMode);
    internal static Status GdipSetClipRegion(IntPtr graphics, IntPtr region, CombineMode combineMode);
    internal static Status GdipSetClipGraphics(IntPtr graphics, IntPtr srcgraphics, CombineMode combineMode);
    internal static Status GdipResetClip(IntPtr graphics);
    internal static Status GdipEndContainer(IntPtr graphics, UInt32 state);
    internal static Status GdipGetClip(IntPtr graphics, IntPtr region);
    internal static Status GdipFillClosedCurve(IntPtr graphics, IntPtr brush, PointF[] points, int count);
    internal static Status GdipFillClosedCurveI(IntPtr graphics, IntPtr brush, Point[] points, int count);
    internal static Status GdipFillClosedCurve2(IntPtr graphics, IntPtr brush, PointF[] points, int count, float tension, FillMode fillMode);
    internal static Status GdipFillClosedCurve2I(IntPtr graphics, IntPtr brush, Point[] points, int count, float tension, FillMode fillMode);
    internal static Status GdipFillPie(IntPtr graphics, IntPtr brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
    internal static Status GdipFillPieI(IntPtr graphics, IntPtr brush, int x, int y, int width, int height, float startAngle, float sweepAngle);
    internal static Status GdipFillPath(IntPtr graphics, IntPtr brush, IntPtr path);
    internal static Status GdipGetNearestColor(IntPtr graphics, Int32& argb);
    internal static Status GdipIsVisiblePoint(IntPtr graphics, float x, float y, Boolean& result);
    internal static Status GdipIsVisiblePointI(IntPtr graphics, int x, int y, Boolean& result);
    internal static Status GdipIsVisibleRect(IntPtr graphics, float x, float y, float width, float height, Boolean& result);
    internal static Status GdipIsVisibleRectI(IntPtr graphics, int x, int y, int width, int height, Boolean& result);
    internal static Status GdipTransformPoints(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count);
    internal static Status GdipTransformPointsI(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count);
    internal static Status GdipTranslateClip(IntPtr graphics, float dx, float dy);
    internal static Status GdipTranslateClipI(IntPtr graphics, int dx, int dy);
    internal static Status GdipGetClipBounds(IntPtr graphics, RectangleF& rect);
    internal static Status GdipSetCompositingMode(IntPtr graphics, CompositingMode compositingMode);
    internal static Status GdipGetCompositingMode(IntPtr graphics, CompositingMode& compositingMode);
    internal static Status GdipSetCompositingQuality(IntPtr graphics, CompositingQuality compositingQuality);
    internal static Status GdipGetCompositingQuality(IntPtr graphics, CompositingQuality& compositingQuality);
    internal static Status GdipSetInterpolationMode(IntPtr graphics, InterpolationMode interpolationMode);
    internal static Status GdipGetInterpolationMode(IntPtr graphics, InterpolationMode& interpolationMode);
    internal static Status GdipGetDpiX(IntPtr graphics, Single& dpi);
    internal static Status GdipGetDpiY(IntPtr graphics, Single& dpi);
    internal static Status GdipIsClipEmpty(IntPtr graphics, Boolean& result);
    internal static Status GdipIsVisibleClipEmpty(IntPtr graphics, Boolean& result);
    internal static Status GdipGetPageUnit(IntPtr graphics, GraphicsUnit& unit);
    internal static Status GdipGetPageScale(IntPtr graphics, Single& scale);
    internal static Status GdipSetPageUnit(IntPtr graphics, GraphicsUnit unit);
    internal static Status GdipSetPageScale(IntPtr graphics, float scale);
    internal static Status GdipSetPixelOffsetMode(IntPtr graphics, PixelOffsetMode pixelOffsetMode);
    internal static Status GdipGetPixelOffsetMode(IntPtr graphics, PixelOffsetMode& pixelOffsetMode);
    internal static Status GdipSetSmoothingMode(IntPtr graphics, SmoothingMode smoothingMode);
    internal static Status GdipGetSmoothingMode(IntPtr graphics, SmoothingMode& smoothingMode);
    internal static Status GdipSetTextContrast(IntPtr graphics, int contrast);
    internal static Status GdipGetTextContrast(IntPtr graphics, Int32& contrast);
    internal static Status GdipSetTextRenderingHint(IntPtr graphics, TextRenderingHint mode);
    internal static Status GdipGetTextRenderingHint(IntPtr graphics, TextRenderingHint& mode);
    internal static Status GdipGetVisibleClipBounds(IntPtr graphics, RectangleF& rect);
    internal static Status GdipFlush(IntPtr graphics, FlushIntention intention);
    internal static Status GdipAddPathString(IntPtr path, string s, int lenght, IntPtr family, int style, float emSize, RectangleF& layoutRect, IntPtr format);
    internal static Status GdipAddPathStringI(IntPtr path, string s, int lenght, IntPtr family, int style, float emSize, Rectangle& layoutRect, IntPtr format);
    internal static Status GdipCreatePen1(int argb, float width, GraphicsUnit unit, IntPtr& pen);
    internal static Status GdipCreatePen2(IntPtr brush, float width, GraphicsUnit unit, IntPtr& pen);
    internal static Status GdipClonePen(IntPtr pen, IntPtr& clonepen);
    internal static Status GdipDeletePen(IntPtr pen);
    internal static Status GdipSetPenBrushFill(IntPtr pen, IntPtr brush);
    internal static Status GdipGetPenBrushFill(IntPtr pen, IntPtr& brush);
    internal static Status GdipGetPenFillType(IntPtr pen, PenType& type);
    internal static Status GdipSetPenColor(IntPtr pen, int color);
    internal static Status GdipGetPenColor(IntPtr pen, Int32& color);
    internal static Status GdipSetPenCompoundArray(IntPtr pen, Single[] dash, int count);
    internal static Status GdipGetPenCompoundArray(IntPtr pen, Single[] dash, int count);
    internal static Status GdipGetPenCompoundCount(IntPtr pen, Int32& count);
    internal static Status GdipSetPenDashCap197819(IntPtr pen, DashCap dashCap);
    internal static Status GdipGetPenDashCap197819(IntPtr pen, DashCap& dashCap);
    internal static Status GdipSetPenDashStyle(IntPtr pen, DashStyle dashStyle);
    internal static Status GdipGetPenDashStyle(IntPtr pen, DashStyle& dashStyle);
    internal static Status GdipSetPenDashOffset(IntPtr pen, float offset);
    internal static Status GdipGetPenDashOffset(IntPtr pen, Single& offset);
    internal static Status GdipGetPenDashCount(IntPtr pen, Int32& count);
    internal static Status GdipSetPenDashArray(IntPtr pen, Single[] dash, int count);
    internal static Status GdipGetPenDashArray(IntPtr pen, Single[] dash, int count);
    internal static Status GdipSetPenMiterLimit(IntPtr pen, float miterLimit);
    internal static Status GdipGetPenMiterLimit(IntPtr pen, Single& miterLimit);
    internal static Status GdipSetPenLineJoin(IntPtr pen, LineJoin lineJoin);
    internal static Status GdipGetPenLineJoin(IntPtr pen, LineJoin& lineJoin);
    internal static Status GdipSetPenLineCap197819(IntPtr pen, LineCap startCap, LineCap endCap, DashCap dashCap);
    internal static Status GdipSetPenMode(IntPtr pen, PenAlignment alignment);
    internal static Status GdipGetPenMode(IntPtr pen, PenAlignment& alignment);
    internal static Status GdipSetPenStartCap(IntPtr pen, LineCap startCap);
    internal static Status GdipGetPenStartCap(IntPtr pen, LineCap& startCap);
    internal static Status GdipSetPenEndCap(IntPtr pen, LineCap endCap);
    internal static Status GdipGetPenEndCap(IntPtr pen, LineCap& endCap);
    internal static Status GdipSetPenCustomStartCap(IntPtr pen, IntPtr customCap);
    internal static Status GdipGetPenCustomStartCap(IntPtr pen, IntPtr& customCap);
    internal static Status GdipSetPenCustomEndCap(IntPtr pen, IntPtr customCap);
    internal static Status GdipGetPenCustomEndCap(IntPtr pen, IntPtr& customCap);
    internal static Status GdipSetPenTransform(IntPtr pen, IntPtr matrix);
    internal static Status GdipGetPenTransform(IntPtr pen, IntPtr matrix);
    internal static Status GdipSetPenWidth(IntPtr pen, float width);
    internal static Status GdipGetPenWidth(IntPtr pen, Single& width);
    internal static Status GdipResetPenTransform(IntPtr pen);
    internal static Status GdipMultiplyPenTransform(IntPtr pen, IntPtr matrix, MatrixOrder order);
    internal static Status GdipRotatePenTransform(IntPtr pen, float angle, MatrixOrder order);
    internal static Status GdipScalePenTransform(IntPtr pen, float sx, float sy, MatrixOrder order);
    internal static Status GdipTranslatePenTransform(IntPtr pen, float dx, float dy, MatrixOrder order);
    internal static int GdipCreateCustomLineCap(HandleRef fillPath, HandleRef strokePath, LineCap baseCap, float baseInset, IntPtr& customCap);
    internal static int GdipDeleteCustomLineCap(HandleRef customCap);
    internal static int GdipCloneCustomLineCap(HandleRef customCap, IntPtr& clonedCap);
    internal static int GdipSetCustomLineCapStrokeCaps(HandleRef customCap, LineCap startCap, LineCap endCap);
    internal static int GdipGetCustomLineCapStrokeCaps(HandleRef customCap, LineCap& startCap, LineCap& endCap);
    internal static int GdipSetCustomLineCapStrokeJoin(HandleRef customCap, LineJoin lineJoin);
    internal static int GdipGetCustomLineCapStrokeJoin(HandleRef customCap, LineJoin& lineJoin);
    internal static int GdipSetCustomLineCapBaseCap(HandleRef customCap, LineCap baseCap);
    internal static int GdipGetCustomLineCapBaseCap(HandleRef customCap, LineCap& baseCap);
    internal static int GdipSetCustomLineCapBaseInset(HandleRef customCap, float inset);
    internal static int GdipGetCustomLineCapBaseInset(HandleRef customCap, Single& inset);
    internal static int GdipSetCustomLineCapWidthScale(HandleRef customCap, float widthScale);
    internal static int GdipGetCustomLineCapWidthScale(HandleRef customCap, Single& widthScale);
    internal static int GdipCreateAdjustableArrowCap(float height, float width, bool isFilled, IntPtr& arrowCap);
    internal static int GdipSetAdjustableArrowCapHeight(HandleRef arrowCap, float height);
    internal static int GdipGetAdjustableArrowCapHeight(HandleRef arrowCap, Single& height);
    internal static int GdipSetAdjustableArrowCapWidth(HandleRef arrowCap, float width);
    internal static int GdipGetAdjustableArrowCapWidth(HandleRef arrowCap, Single& width);
    internal static int GdipSetAdjustableArrowCapMiddleInset(HandleRef arrowCap, float middleInset);
    internal static int GdipGetAdjustableArrowCapMiddleInset(HandleRef arrowCap, Single& middleInset);
    internal static int GdipSetAdjustableArrowCapFillState(HandleRef arrowCap, bool isFilled);
    internal static int GdipGetAdjustableArrowCapFillState(HandleRef arrowCap, Boolean& isFilled);
    internal static Status GdipCreateFromHWND(IntPtr hwnd, IntPtr& graphics);
    internal static Status GdipMeasureString(IntPtr graphics, string str, int length, IntPtr font, RectangleF& layoutRect, IntPtr stringFormat, RectangleF& boundingBox, Int32* codepointsFitted, Int32* linesFilled);
    internal static Status GdipMeasureCharacterRanges(IntPtr graphics, string str, int length, IntPtr font, RectangleF& layoutRect, IntPtr stringFormat, int regcount, IntPtr& regions);
    internal static Status GdipSetStringFormatMeasurableCharacterRanges(IntPtr native, int cnt, CharacterRange[] range);
    internal static Status GdipGetStringFormatMeasurableCharacterRangeCount(IntPtr native, Int32& cnt);
    internal static Status GdipCreateBitmapFromScan0(int width, int height, int stride, PixelFormat format, IntPtr scan0, IntPtr& bmp);
    internal static Status GdipCreateBitmapFromGraphics(int width, int height, IntPtr target, IntPtr& bitmap);
    internal static Status GdipBitmapLockBits(IntPtr bmp, Rectangle& rc, ImageLockMode flags, PixelFormat format, BitmapData bmpData);
    internal static Status GdipBitmapSetResolution(IntPtr bmp, float xdpi, float ydpi);
    internal static Status GdipBitmapUnlockBits(IntPtr bmp, BitmapData bmpData);
    internal static Status GdipBitmapGetPixel(IntPtr bmp, int x, int y, Int32& argb);
    internal static Status GdipBitmapSetPixel(IntPtr bmp, int x, int y, int argb);
    internal static Status GdipLoadImageFromFile(string filename, IntPtr& image);
    internal static Status GdipLoadImageFromStream(IStream stream, IntPtr& image);
    internal static Status GdipSaveImageToStream(HandleRef image, IStream stream, Guid& clsidEncoder, HandleRef encoderParams);
    internal static Status GdipCloneImage(IntPtr image, IntPtr& imageclone);
    internal static Status GdipLoadImageFromFileICM(string filename, IntPtr& image);
    internal static Status GdipCreateBitmapFromHBITMAP(IntPtr hBitMap, IntPtr gdiPalette, IntPtr& image);
    internal static Status GdipDisposeImage(IntPtr image);
    internal static Status GdipGetImageFlags(IntPtr image, Int32& flag);
    internal static Status GdipGetImageType(IntPtr image, ImageType& type);
    internal static Status GdipImageGetFrameDimensionsCount(IntPtr image, UInt32& count);
    internal static Status GdipImageGetFrameDimensionsList(IntPtr image, Guid[] dimensionIDs, UInt32 count);
    internal static Status GdipGetImageHeight(IntPtr image, UInt32& height);
    internal static Status GdipGetImageHorizontalResolution(IntPtr image, Single& resolution);
    internal static Status GdipGetImagePaletteSize(IntPtr image, Int32& size);
    internal static Status GdipGetImagePalette(IntPtr image, IntPtr palette, int size);
    internal static Status GdipSetImagePalette(IntPtr image, IntPtr palette);
    internal static Status GdipGetImageDimension(IntPtr image, Single& width, Single& height);
    internal static Status GdipGetImagePixelFormat(IntPtr image, PixelFormat& format);
    internal static Status GdipGetPropertyCount(IntPtr image, UInt32& propNumbers);
    internal static Status GdipGetPropertyIdList(IntPtr image, UInt32 propNumbers, Int32[] list);
    internal static Status GdipGetPropertySize(IntPtr image, Int32& bufferSize, Int32& propNumbers);
    internal static Status GdipGetAllPropertyItems(IntPtr image, int bufferSize, int propNumbers, IntPtr items);
    internal static Status GdipGetImageRawFormat(IntPtr image, Guid& format);
    internal static Status GdipGetImageVerticalResolution(IntPtr image, Single& resolution);
    internal static Status GdipGetImageWidth(IntPtr image, UInt32& width);
    internal static Status GdipGetImageBounds(IntPtr image, RectangleF& source, GraphicsUnit& unit);
    internal static Status GdipGetEncoderParameterListSize(IntPtr image, Guid& encoder, UInt32& size);
    internal static Status GdipGetEncoderParameterList(IntPtr image, Guid& encoder, UInt32 size, IntPtr buffer);
    internal static Status GdipImageGetFrameCount(IntPtr image, Guid& guidDimension, UInt32& count);
    internal static Status GdipImageSelectActiveFrame(IntPtr image, Guid& guidDimension, int frameIndex);
    internal static Status GdipGetPropertyItemSize(IntPtr image, int propertyID, Int32& propertySize);
    internal static Status GdipGetPropertyItem(IntPtr image, int propertyID, int propertySize, IntPtr buffer);
    internal static Status GdipRemovePropertyItem(IntPtr image, int propertyId);
    internal static Status GdipSetPropertyItem(IntPtr image, GdipPropertyItem* propertyItem);
    internal static Status GdipGetImageThumbnail(IntPtr image, UInt32 width, UInt32 height, IntPtr& thumbImage, IntPtr callback, IntPtr callBackData);
    internal static Status GdipImageRotateFlip(IntPtr image, RotateFlipType rotateFlipType);
    internal static Status GdipSaveImageToFile(IntPtr image, string filename, Guid& encoderClsID, IntPtr encoderParameters);
    internal static Status GdipSaveAdd(IntPtr image, IntPtr encoderParameters);
    internal static Status GdipSaveAddImage(IntPtr image, IntPtr imagenew, IntPtr encoderParameters);
    internal static Status GdipDrawImageI(IntPtr graphics, IntPtr image, int x, int y);
    internal static Status GdipGetImageGraphicsContext(IntPtr image, IntPtr& graphics);
    internal static Status GdipDrawImage(IntPtr graphics, IntPtr image, float x, float y);
    internal static Status GdipBeginContainer(IntPtr graphics, RectangleF& dstrect, RectangleF& srcrect, GraphicsUnit unit, UInt32& state);
    internal static Status GdipBeginContainerI(IntPtr graphics, Rectangle& dstrect, Rectangle& srcrect, GraphicsUnit unit, UInt32& state);
    internal static Status GdipBeginContainer2(IntPtr graphics, UInt32& state);
    internal static Status GdipDrawImagePoints(IntPtr graphics, IntPtr image, PointF[] destPoints, int count);
    internal static Status GdipDrawImagePointsI(IntPtr graphics, IntPtr image, Point[] destPoints, int count);
    internal static Status GdipDrawImageRectRectI(IntPtr graphics, IntPtr image, int dstx, int dsty, int dstwidth, int dstheight, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, DrawImageAbort callback, IntPtr callbackData);
    internal static Status GdipDrawImageRectRect(IntPtr graphics, IntPtr image, float dstx, float dsty, float dstwidth, float dstheight, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, DrawImageAbort callback, IntPtr callbackData);
    internal static Status GdipDrawImagePointsRectI(IntPtr graphics, IntPtr image, Point[] destPoints, int count, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, DrawImageAbort callback, IntPtr callbackData);
    internal static Status GdipDrawImagePointsRect(IntPtr graphics, IntPtr image, PointF[] destPoints, int count, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, DrawImageAbort callback, IntPtr callbackData);
    internal static Status GdipDrawImageRect(IntPtr graphics, IntPtr image, float x, float y, float width, float height);
    internal static Status GdipDrawImagePointRect(IntPtr graphics, IntPtr image, float x, float y, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit);
    internal static Status GdipDrawImagePointRectI(IntPtr graphics, IntPtr image, int x, int y, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit);
    internal static Status GdipCreateStringFormat(StringFormatFlags formatAttributes, int language, IntPtr& native);
    internal static Status GdipCreateHBITMAPFromBitmap(IntPtr bmp, IntPtr& HandleBmp, int clrbackground);
    internal static Status GdipCreateBitmapFromFile(string filename, IntPtr& bitmap);
    internal static Status GdipCreateBitmapFromFileICM(string filename, IntPtr& bitmap);
    internal static Status GdipCreateHICONFromBitmap(IntPtr bmp, IntPtr& HandleIcon);
    internal static Status GdipCreateBitmapFromHICON(IntPtr hicon, IntPtr& bitmap);
    internal static Status GdipCreateBitmapFromResource(IntPtr hInstance, string lpBitmapName, IntPtr& bitmap);
    internal static Status GdipCreateMatrix(IntPtr& matrix);
    internal static Status GdipCreateMatrix2(float m11, float m12, float m21, float m22, float dx, float dy, IntPtr& matrix);
    internal static Status GdipCreateMatrix3(RectangleF& rect, PointF[] dstplg, IntPtr& matrix);
    internal static Status GdipCreateMatrix3I(Rectangle& rect, Point[] dstplg, IntPtr& matrix);
    internal static Status GdipDeleteMatrix(IntPtr matrix);
    internal static Status GdipCloneMatrix(IntPtr matrix, IntPtr& cloneMatrix);
    internal static Status GdipSetMatrixElements(IntPtr matrix, float m11, float m12, float m21, float m22, float dx, float dy);
    internal static Status GdipGetMatrixElements(IntPtr matrix, IntPtr matrixOut);
    internal static Status GdipMultiplyMatrix(IntPtr matrix, IntPtr matrix2, MatrixOrder order);
    internal static Status GdipTranslateMatrix(IntPtr matrix, float offsetX, float offsetY, MatrixOrder order);
    internal static Status GdipScaleMatrix(IntPtr matrix, float scaleX, float scaleY, MatrixOrder order);
    internal static Status GdipRotateMatrix(IntPtr matrix, float angle, MatrixOrder order);
    internal static Status GdipShearMatrix(IntPtr matrix, float shearX, float shearY, MatrixOrder order);
    internal static Status GdipInvertMatrix(IntPtr matrix);
    internal static Status GdipTransformMatrixPoints(IntPtr matrix, PointF[] pts, int count);
    internal static Status GdipTransformMatrixPointsI(IntPtr matrix, Point[] pts, int count);
    internal static Status GdipVectorTransformMatrixPoints(IntPtr matrix, PointF[] pts, int count);
    internal static Status GdipVectorTransformMatrixPointsI(IntPtr matrix, Point[] pts, int count);
    internal static Status GdipIsMatrixInvertible(IntPtr matrix, Boolean& result);
    internal static Status GdipIsMatrixIdentity(IntPtr matrix, Boolean& result);
    internal static Status GdipIsMatrixEqual(IntPtr matrix, IntPtr matrix2, Boolean& result);
    internal static Status GdipCreatePath(FillMode brushMode, IntPtr& path);
    internal static Status GdipCreatePath2(PointF[] points, Byte[] types, int count, FillMode brushMode, IntPtr& path);
    internal static Status GdipCreatePath2I(Point[] points, Byte[] types, int count, FillMode brushMode, IntPtr& path);
    internal static Status GdipClonePath(IntPtr path, IntPtr& clonePath);
    internal static Status GdipDeletePath(IntPtr path);
    internal static Status GdipResetPath(IntPtr path);
    internal static Status GdipGetPointCount(IntPtr path, Int32& count);
    internal static Status GdipGetPathTypes(IntPtr path, Byte[] types, int count);
    internal static Status GdipGetPathPoints(IntPtr path, PointF[] points, int count);
    internal static Status GdipGetPathPointsI(IntPtr path, Point[] points, int count);
    internal static Status GdipGetPathFillMode(IntPtr path, FillMode& fillMode);
    internal static Status GdipSetPathFillMode(IntPtr path, FillMode fillMode);
    internal static Status GdipStartPathFigure(IntPtr path);
    internal static Status GdipClosePathFigure(IntPtr path);
    internal static Status GdipClosePathFigures(IntPtr path);
    internal static Status GdipSetPathMarker(IntPtr path);
    internal static Status GdipClearPathMarkers(IntPtr path);
    internal static Status GdipReversePath(IntPtr path);
    internal static Status GdipGetPathLastPoint(IntPtr path, PointF& lastPoint);
    internal static Status GdipAddPathLine(IntPtr path, float x1, float y1, float x2, float y2);
    internal static Status GdipAddPathLine2(IntPtr path, PointF[] points, int count);
    internal static Status GdipAddPathLine2I(IntPtr path, Point[] points, int count);
    internal static Status GdipAddPathArc(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle);
    internal static Status GdipAddPathBezier(IntPtr path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
    internal static Status GdipAddPathBeziers(IntPtr path, PointF[] points, int count);
    internal static Status GdipAddPathCurve(IntPtr path, PointF[] points, int count);
    internal static Status GdipAddPathCurveI(IntPtr path, Point[] points, int count);
    internal static Status GdipAddPathCurve2(IntPtr path, PointF[] points, int count, float tension);
    internal static Status GdipAddPathCurve2I(IntPtr path, Point[] points, int count, float tension);
    internal static Status GdipAddPathCurve3(IntPtr path, PointF[] points, int count, int offset, int numberOfSegments, float tension);
    internal static Status GdipAddPathCurve3I(IntPtr path, Point[] points, int count, int offset, int numberOfSegments, float tension);
    internal static Status GdipAddPathClosedCurve(IntPtr path, PointF[] points, int count);
    internal static Status GdipAddPathClosedCurveI(IntPtr path, Point[] points, int count);
    internal static Status GdipAddPathClosedCurve2(IntPtr path, PointF[] points, int count, float tension);
    internal static Status GdipAddPathClosedCurve2I(IntPtr path, Point[] points, int count, float tension);
    internal static Status GdipAddPathRectangle(IntPtr path, float x, float y, float width, float height);
    internal static Status GdipAddPathRectangles(IntPtr path, RectangleF[] rects, int count);
    internal static Status GdipAddPathEllipse(IntPtr path, float x, float y, float width, float height);
    internal static Status GdipAddPathEllipseI(IntPtr path, int x, int y, int width, int height);
    internal static Status GdipAddPathPie(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle);
    internal static Status GdipAddPathPieI(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle);
    internal static Status GdipAddPathPolygon(IntPtr path, PointF[] points, int count);
    internal static Status GdipAddPathPath(IntPtr path, IntPtr addingPath, bool connect);
    internal static Status GdipAddPathLineI(IntPtr path, int x1, int y1, int x2, int y2);
    internal static Status GdipAddPathArcI(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle);
    internal static Status GdipAddPathBezierI(IntPtr path, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    internal static Status GdipAddPathBeziersI(IntPtr path, Point[] points, int count);
    internal static Status GdipAddPathPolygonI(IntPtr path, Point[] points, int count);
    internal static Status GdipAddPathRectangleI(IntPtr path, int x, int y, int width, int height);
    internal static Status GdipAddPathRectanglesI(IntPtr path, Rectangle[] rects, int count);
    internal static Status GdipFlattenPath(IntPtr path, IntPtr matrix, float floatness);
    internal static Status GdipTransformPath(IntPtr path, IntPtr matrix);
    internal static Status GdipWarpPath(IntPtr path, IntPtr matrix, PointF[] points, int count, float srcx, float srcy, float srcwidth, float srcheight, WarpMode mode, float flatness);
    internal static Status GdipWidenPath(IntPtr path, IntPtr pen, IntPtr matrix, float flatness);
    internal static Status GdipGetPathWorldBounds(IntPtr path, RectangleF& bounds, IntPtr matrix, IntPtr pen);
    internal static Status GdipGetPathWorldBoundsI(IntPtr path, Rectangle& bounds, IntPtr matrix, IntPtr pen);
    internal static Status GdipIsVisiblePathPoint(IntPtr path, float x, float y, IntPtr graphics, Boolean& result);
    internal static Status GdipIsVisiblePathPointI(IntPtr path, int x, int y, IntPtr graphics, Boolean& result);
    internal static Status GdipIsOutlineVisiblePathPoint(IntPtr path, float x, float y, IntPtr pen, IntPtr graphics, Boolean& result);
    internal static Status GdipIsOutlineVisiblePathPointI(IntPtr path, int x, int y, IntPtr pen, IntPtr graphics, Boolean& result);
    internal static int GdipCreatePathIter(IntPtr& iterator, HandleRef path);
    internal static int GdipPathIterGetCount(HandleRef iterator, Int32& count);
    internal static int GdipPathIterGetSubpathCount(HandleRef iterator, Int32& count);
    internal static int GdipDeletePathIter(HandleRef iterator);
    internal static int GdipPathIterCopyData(HandleRef iterator, Int32& resultCount, IntPtr points, Byte[] types, int startIndex, int endIndex);
    internal static int GdipPathIterEnumerate(HandleRef iterator, Int32& resultCount, IntPtr points, Byte[] types, int count);
    internal static int GdipPathIterHasCurve(HandleRef iterator, Boolean& curve);
    internal static int GdipPathIterNextMarkerPath(HandleRef iterator, Int32& resultCount, HandleRef path);
    internal static int GdipPathIterNextMarker(HandleRef iterator, Int32& resultCount, Int32& startIndex, Int32& endIndex);
    internal static int GdipPathIterNextPathType(HandleRef iterator, Int32& resultCount, Byte& pathType, Int32& startIndex, Int32& endIndex);
    internal static int GdipPathIterNextSubpathPath(HandleRef iterator, Int32& resultCount, HandleRef path, Boolean& isClosed);
    internal static int GdipPathIterNextSubpath(HandleRef iterator, Int32& resultCount, Int32& startIndex, Int32& endIndex, Boolean& isClosed);
    internal static int GdipPathIterRewind(HandleRef iterator);
    internal static int GdipCreateImageAttributes(IntPtr& imageattr);
    internal static int GdipSetImageAttributesColorKeys(HandleRef imageattr, ColorAdjustType type, bool enableFlag, int colorLow, int colorHigh);
    internal static int GdipDisposeImageAttributes(HandleRef imageattr);
    internal static int GdipSetImageAttributesColorMatrix(HandleRef imageattr, ColorAdjustType type, bool enableFlag, ColorMatrix colorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags);
    internal static int GdipSetImageAttributesGamma(HandleRef imageattr, ColorAdjustType type, bool enableFlag, float gamma);
    internal static int GdipSetImageAttributesNoOp(HandleRef imageattr, ColorAdjustType type, bool enableFlag);
    internal static int GdipSetImageAttributesOutputChannel(HandleRef imageattr, ColorAdjustType type, bool enableFlag, ColorChannelFlag channelFlags);
    internal static int GdipSetImageAttributesOutputChannelColorProfile(HandleRef imageattr, ColorAdjustType type, bool enableFlag, string profileName);
    internal static int GdipSetImageAttributesRemapTable(HandleRef imageattr, ColorAdjustType type, bool enableFlag, int mapSize, HandleRef colorMap);
    internal static int GdipSetImageAttributesThreshold(HandleRef imageattr, ColorAdjustType type, bool enableFlag, float thresHold);
    internal static int GdipCloneImageAttributes(HandleRef imageattr, IntPtr& cloneImageattr);
    internal static int GdipGetImageAttributesAdjustedPalette(HandleRef imageattr, HandleRef colorPalette, ColorAdjustType colorAdjustType);
    internal static int GdipSetImageAttributesWrapMode(HandleRef imageattr, int wrap, int argb, bool clamp);
    internal static Status GdipCreateFont(IntPtr fontFamily, float emSize, FontStyle style, GraphicsUnit unit, IntPtr& font);
    internal static Status GdipDeleteFont(IntPtr font);
    internal static Status GdipGetLogFont(IntPtr font, IntPtr graphics, object logfontA);
    internal static Status GdipCreateFontFromDC(IntPtr hdc, IntPtr& font);
    internal static Status GdipCreateFontFromLogfont(IntPtr hdc, LOGFONT& lf, IntPtr& ptr);
    internal static Status GdipCreateFontFromHfont(IntPtr hdc, IntPtr& font, LOGFONT& lf);
    internal static IntPtr CreateFontIndirect(LOGFONT& logfont);
    internal static IntPtr GetDC(IntPtr hwnd);
    internal static int ReleaseDC(IntPtr hWnd, IntPtr hDC);
    internal static IntPtr SelectObject(IntPtr hdc, IntPtr obj);
    internal static bool GetIconInfo(IntPtr hIcon, IconInfo& iconinfo);
    internal static IntPtr CreateIconIndirect(IconInfo& piconinfo);
    internal static bool DestroyIcon(IntPtr hIcon);
    internal static bool DeleteObject(IntPtr hObject);
    internal static IntPtr GetDesktopWindow();
    public static int BitBlt(IntPtr hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, int dwRop);
    public static UInt32 Win32GetSysColor(GetSysColorIndex index);
    internal static IntPtr XOpenDisplay(IntPtr display);
    internal static int XCloseDisplay(IntPtr display);
    internal static IntPtr XRootWindow(IntPtr display, int screen);
    internal static int XDefaultScreen(IntPtr display);
    internal static UInt32 XDefaultDepth(IntPtr display, int screen);
    internal static IntPtr XGetImage(IntPtr display, IntPtr drawable, int src_x, int src_y, int width, int height, int pane, int format);
    internal static int XGetPixel(IntPtr image, int x, int y);
    internal static int XDestroyImage(IntPtr image);
    internal static IntPtr XDefaultVisual(IntPtr display, int screen);
    internal static IntPtr XGetVisualInfo(IntPtr display, int vinfo_mask, XVisualInfo& vinfo_template, Int32& nitems);
    internal static IntPtr XVisualIDFromVisual(IntPtr visual);
    internal static void XFree(IntPtr data);
    internal static int GdipGetFontCollectionFamilyCount(HandleRef collection, Int32& found);
    internal static int GdipGetFontCollectionFamilyList(HandleRef collection, int getCount, IntPtr[] dest, Int32& retCount);
    internal static int GdipNewInstalledFontCollection(IntPtr& collection);
    internal static Status GdipNewPrivateFontCollection(IntPtr& collection);
    internal static Status GdipDeletePrivateFontCollection(IntPtr& collection);
    internal static Status GdipPrivateAddFontFile(IntPtr collection, string fileName);
    internal static Status GdipPrivateAddMemoryFont(IntPtr collection, IntPtr mem, int length);
    internal static Status GdipCreateFontFamilyFromName(string fName, IntPtr collection, IntPtr& fontFamily);
    internal static Status GdipGetFamilyName(IntPtr family, StringBuilder name, int language);
    internal static Status GdipGetGenericFontFamilySansSerif(IntPtr& fontFamily);
    internal static Status GdipGetGenericFontFamilySerif(IntPtr& fontFamily);
    internal static Status GdipGetGenericFontFamilyMonospace(IntPtr& fontFamily);
    internal static Status GdipGetCellAscent(IntPtr fontFamily, int style, Int16& ascent);
    internal static Status GdipGetCellDescent(IntPtr fontFamily, int style, Int16& descent);
    internal static Status GdipGetLineSpacing(IntPtr fontFamily, int style, Int16& spacing);
    internal static Status GdipGetEmHeight(IntPtr fontFamily, int style, Int16& emHeight);
    internal static Status GdipIsStyleAvailable(IntPtr fontFamily, int style, Boolean& styleAvailable);
    internal static Status GdipDeleteFontFamily(IntPtr fontFamily);
    internal static Status GdipGetFontSize(IntPtr font, Single& size);
    internal static Status GdipGetFontHeight(IntPtr font, IntPtr graphics, Single& height);
    internal static Status GdipGetFontHeightGivenDPI(IntPtr font, float dpi, Single& height);
    internal static int GdipCloneFontFamily(HandleRef fontFamily, IntPtr& clone);
    internal static Status GdipCreateStringFormat(int formatAttributes, int language, IntPtr& format);
    internal static Status GdipStringFormatGetGenericDefault(IntPtr& format);
    internal static Status GdipStringFormatGetGenericTypographic(IntPtr& format);
    internal static Status GdipDeleteStringFormat(IntPtr format);
    internal static Status GdipCloneStringFormat(IntPtr srcformat, IntPtr& format);
    internal static Status GdipSetStringFormatFlags(IntPtr format, StringFormatFlags flags);
    internal static Status GdipGetStringFormatFlags(IntPtr format, StringFormatFlags& flags);
    internal static Status GdipSetStringFormatAlign(IntPtr format, StringAlignment align);
    internal static Status GdipGetStringFormatAlign(IntPtr format, StringAlignment& align);
    internal static Status GdipSetStringFormatLineAlign(IntPtr format, StringAlignment align);
    internal static Status GdipGetStringFormatLineAlign(IntPtr format, StringAlignment& align);
    internal static Status GdipSetStringFormatTrimming(IntPtr format, StringTrimming trimming);
    internal static Status GdipGetStringFormatTrimming(IntPtr format, StringTrimming& trimming);
    internal static Status GdipSetStringFormatHotkeyPrefix(IntPtr format, HotkeyPrefix hotkeyPrefix);
    internal static Status GdipGetStringFormatHotkeyPrefix(IntPtr format, HotkeyPrefix& hotkeyPrefix);
    internal static Status GdipSetStringFormatTabStops(IntPtr format, float firstTabOffset, int count, Single[] tabStops);
    internal static Status GdipGetStringFormatDigitSubstitution(IntPtr format, int language, StringDigitSubstitute& substitute);
    internal static Status GdipSetStringFormatDigitSubstitution(IntPtr format, int language, StringDigitSubstitute substitute);
    internal static Status GdipGetStringFormatTabStopCount(IntPtr format, Int32& count);
    internal static Status GdipGetStringFormatTabStops(IntPtr format, int count, Single& firstTabOffset, Single[] tabStops);
    internal static Status GdipCreateMetafileFromFile(string filename, IntPtr& metafile);
    internal static Status GdipCreateMetafileFromEmf(IntPtr hEmf, bool deleteEmf, IntPtr& metafile);
    internal static Status GdipCreateMetafileFromWmf(IntPtr hWmf, bool deleteWmf, WmfPlaceableFileHeader wmfPlaceableFileHeader, IntPtr& metafile);
    internal static Status GdipGetMetafileHeaderFromFile(string filename, IntPtr header);
    internal static Status GdipGetMetafileHeaderFromMetafile(IntPtr metafile, IntPtr header);
    internal static Status GdipGetMetafileHeaderFromEmf(IntPtr hEmf, IntPtr header);
    internal static Status GdipGetMetafileHeaderFromWmf(IntPtr hWmf, IntPtr wmfPlaceableFileHeader, IntPtr header);
    internal static Status GdipGetHemfFromMetafile(IntPtr metafile, IntPtr& hEmf);
    internal static Status GdipGetMetafileDownLevelRasterizationLimit(IntPtr metafile, UInt32& metafileRasterizationLimitDpi);
    internal static Status GdipSetMetafileDownLevelRasterizationLimit(IntPtr metafile, UInt32 metafileRasterizationLimitDpi);
    internal static Status GdipPlayMetafileRecord(IntPtr metafile, EmfPlusRecordType recordType, int flags, int dataSize, Byte[] data);
    internal static Status GdipRecordMetafile(IntPtr hdc, EmfType type, RectangleF& frameRect, MetafileFrameUnit frameUnit, string description, IntPtr& metafile);
    internal static Status GdipRecordMetafileI(IntPtr hdc, EmfType type, Rectangle& frameRect, MetafileFrameUnit frameUnit, string description, IntPtr& metafile);
    internal static Status GdipRecordMetafileFileName(string filename, IntPtr hdc, EmfType type, RectangleF& frameRect, MetafileFrameUnit frameUnit, string description, IntPtr& metafile);
    internal static Status GdipRecordMetafileFileNameI(string filename, IntPtr hdc, EmfType type, Rectangle& frameRect, MetafileFrameUnit frameUnit, string description, IntPtr& metafile);
    internal static Status GdipCreateMetafileFromStream(IStream stream, IntPtr& metafile);
    internal static Status GdipGetMetafileHeaderFromStream(IStream stream, IntPtr header);
    internal static Status GdipRecordMetafileStream(IStream stream, IntPtr hdc, EmfType type, RectangleF& frameRect, MetafileFrameUnit frameUnit, string description, IntPtr& metafile);
    internal static Status GdipRecordMetafileStreamI(IStream stream, IntPtr hdc, EmfType type, Rectangle& frameRect, MetafileFrameUnit frameUnit, string description, IntPtr& metafile);
    internal static int GdipGetImageDecodersSize(Int32& decoderNums, Int32& arraySize);
    internal static int GdipGetImageDecoders(int decoderNums, int arraySize, IntPtr decoders);
    internal static int GdipGetImageEncodersSize(Int32& encoderNums, Int32& arraySize);
    internal static int GdipGetImageEncoders(int encoderNums, int arraySize, IntPtr encoders);
    internal static Status GdipCreateFromContext_macosx(IntPtr cgref, int width, int height, IntPtr& graphics);
    internal static Status GdipSetVisibleClip_linux(IntPtr graphics, Rectangle& rect);
    internal static Status GdipCreateFromXDrawable_linux(IntPtr drawable, IntPtr display, IntPtr& graphics);
    internal static Status GdipLoadImageFromDelegate_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, IntPtr& image);
    internal static Status GdipSaveImageToDelegate_linux(IntPtr image, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, Guid& encoderClsID, IntPtr encoderParameters);
    internal static Status GdipCreateMetafileFromDelegate_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, IntPtr& metafile);
    internal static Status GdipGetMetafileHeaderFromDelegate_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, IntPtr header);
    internal static Status GdipRecordMetafileFromDelegate_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, RectangleF& frameRect, MetafileFrameUnit frameUnit, string description, IntPtr& metafile);
    internal static Status GdipRecordMetafileFromDelegateI_linux(StreamGetHeaderDelegate getHeader, StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, Rectangle& frameRect, MetafileFrameUnit frameUnit, string description, IntPtr& metafile);
    private static int uname(IntPtr buf);
}
internal class System.Drawing.GdiplusStartupInput : ValueType {
    
internal UInt32 GdiplusVersion;
    
internal IntPtr DebugEventCallback;
    
internal int SuppressBackgroundThread;
    
internal int SuppressExternalCodecs;
    internal static GdiplusStartupInput MakeGdiplusStartupInput();
}
internal class System.Drawing.GdiplusStartupOutput : ValueType {
    
internal IntPtr NotificationHook;
    
internal IntPtr NotificationUnhook;
    internal static GdiplusStartupOutput MakeGdiplusStartupOutput();
}
internal class System.Drawing.GdipPropertyItem : ValueType {
    
internal int id;
    
internal int len;
    
internal short type;
    
internal IntPtr value;
    internal static void MarshalTo(GdipPropertyItem gdipProp, PropertyItem prop);
}
internal enum System.Drawing.GetSysColorIndex : Enum {
    
public int value__;
    
public static GetSysColorIndex COLOR_SCROLLBAR;
    
public static GetSysColorIndex COLOR_BACKGROUND;
    
public static GetSysColorIndex COLOR_ACTIVECAPTION;
    
public static GetSysColorIndex COLOR_INACTIVECAPTION;
    
public static GetSysColorIndex COLOR_MENU;
    
public static GetSysColorIndex COLOR_WINDOW;
    
public static GetSysColorIndex COLOR_WINDOWFRAME;
    
public static GetSysColorIndex COLOR_MENUTEXT;
    
public static GetSysColorIndex COLOR_WINDOWTEXT;
    
public static GetSysColorIndex COLOR_CAPTIONTEXT;
    
public static GetSysColorIndex COLOR_ACTIVEBORDER;
    
public static GetSysColorIndex COLOR_INACTIVEBORDER;
    
public static GetSysColorIndex COLOR_APPWORKSPACE;
    
public static GetSysColorIndex COLOR_HIGHLIGHT;
    
public static GetSysColorIndex COLOR_HIGHLIGHTTEXT;
    
public static GetSysColorIndex COLOR_BTNFACE;
    
public static GetSysColorIndex COLOR_BTNSHADOW;
    
public static GetSysColorIndex COLOR_GRAYTEXT;
    
public static GetSysColorIndex COLOR_BTNTEXT;
    
public static GetSysColorIndex COLOR_INACTIVECAPTIONTEXT;
    
public static GetSysColorIndex COLOR_BTNHIGHLIGHT;
    
public static GetSysColorIndex COLOR_3DDKSHADOW;
    
public static GetSysColorIndex COLOR_3DLIGHT;
    
public static GetSysColorIndex COLOR_INFOTEXT;
    
public static GetSysColorIndex COLOR_INFOBK;
    
public static GetSysColorIndex COLOR_HOTLIGHT;
    
public static GetSysColorIndex COLOR_GRADIENTACTIVECAPTION;
    
public static GetSysColorIndex COLOR_GRADIENTINACTIVECAPTION;
    
public static GetSysColorIndex COLOR_MENUHIGHLIGHT;
    
public static GetSysColorIndex COLOR_MENUBAR;
    
public static GetSysColorIndex COLOR_DESKTOP;
    
public static GetSysColorIndex COLOR_3DFACE;
    
public static GetSysColorIndex COLOR_3DSHADOW;
    
public static GetSysColorIndex COLOR_3DHIGHLIGHT;
    
public static GetSysColorIndex COLOR_3DHILIGHT;
    
public static GetSysColorIndex COLOR_BTNHILIGHT;
    
public static GetSysColorIndex COLOR_MAXVALUE;
}
public class System.Drawing.Graphics : MarshalByRefObject {
    
internal IntPtr nativeObject;
    
internal IMacContext maccontext;
    
private bool disposed;
    
private static float defDpiX;
    
private static float defDpiY;
    
private IntPtr deviceContextHdc;
    
private static string MetafileEnumeration;
    
internal static float systemDpiX { get; }
    
internal static float systemDpiY { get; }
    
internal IntPtr NativeGraphics { get; }
    
internal IntPtr NativeObject { get; internal set; }
    
public Region Clip { get; public set; }
    
public RectangleF ClipBounds { get; }
    
public CompositingMode CompositingMode { get; public set; }
    
public CompositingQuality CompositingQuality { get; public set; }
    
public float DpiX { get; }
    
public float DpiY { get; }
    
public InterpolationMode InterpolationMode { get; public set; }
    
public bool IsClipEmpty { get; }
    
public bool IsVisibleClipEmpty { get; }
    
public float PageScale { get; public set; }
    
public GraphicsUnit PageUnit { get; public set; }
    [MonoTODOAttribute("This property does not do anything when used with libgdiplus.")]

public PixelOffsetMode PixelOffsetMode { get; public set; }
    
public Point RenderingOrigin { get; public set; }
    
public SmoothingMode SmoothingMode { get; public set; }
    [MonoTODOAttribute("This property does not do anything when used with libgdiplus.")]

public int TextContrast { get; public set; }
    
public TextRenderingHint TextRenderingHint { get; public set; }
    
public Matrix Transform { get; public set; }
    
public RectangleF VisibleClipBounds { get; }
    internal Graphics(IntPtr nativeGraphics);
    private static Graphics();
    protected virtual override void Finalize();
    internal static float get_systemDpiX();
    internal static float get_systemDpiY();
    internal IntPtr get_NativeGraphics();
    internal IntPtr get_NativeObject();
    internal void set_NativeObject(IntPtr value);
    [MonoTODOAttribute("Metafiles, both WMF and EMF formats, aren't supported.")]
public void AddMetafileComment(Byte[] data);
    public GraphicsContainer BeginContainer();
    [MonoTODOAttribute("The rectangles and unit parameters aren't supported in libgdiplus")]
public GraphicsContainer BeginContainer(Rectangle dstrect, Rectangle srcrect, GraphicsUnit unit);
    [MonoTODOAttribute("The rectangles and unit parameters aren't supported in libgdiplus")]
public GraphicsContainer BeginContainer(RectangleF dstrect, RectangleF srcrect, GraphicsUnit unit);
    public void Clear(Color color);
    [MonoLimitationAttribute("Works on Win32 and on X11 (but not on Cocoa and Quartz)")]
public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize);
    [MonoLimitationAttribute("Works on Win32 and (for CopyPixelOperation.SourceCopy only) on X11 but not on Cocoa and Quartz")]
public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
    [MonoLimitationAttribute("Works on Win32 and on X11 (but not on Cocoa and Quartz)")]
public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize);
    [MonoLimitationAttribute("Works on Win32 and (for CopyPixelOperation.SourceCopy only) on X11 but not on Cocoa and Quartz")]
public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
    private void CopyFromScreenWin32(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
    private void CopyFromScreenMac(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
    private void CopyFromScreenX11(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
    public sealed virtual void Dispose();
    public void DrawArc(Pen pen, Rectangle rect, float startAngle, float sweepAngle);
    public void DrawArc(Pen pen, RectangleF rect, float startAngle, float sweepAngle);
    public void DrawArc(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void DrawArc(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);
    public void DrawBezier(Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4);
    public void DrawBezier(Pen pen, Point pt1, Point pt2, Point pt3, Point pt4);
    public void DrawBezier(Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
    public void DrawBeziers(Pen pen, Point[] points);
    public void DrawBeziers(Pen pen, PointF[] points);
    public void DrawClosedCurve(Pen pen, PointF[] points);
    public void DrawClosedCurve(Pen pen, Point[] points);
    public void DrawClosedCurve(Pen pen, Point[] points, float tension, FillMode fillmode);
    public void DrawClosedCurve(Pen pen, PointF[] points, float tension, FillMode fillmode);
    public void DrawCurve(Pen pen, Point[] points);
    public void DrawCurve(Pen pen, PointF[] points);
    public void DrawCurve(Pen pen, PointF[] points, float tension);
    public void DrawCurve(Pen pen, Point[] points, float tension);
    public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments);
    public void DrawCurve(Pen pen, Point[] points, int offset, int numberOfSegments, float tension);
    public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments, float tension);
    public void DrawEllipse(Pen pen, Rectangle rect);
    public void DrawEllipse(Pen pen, RectangleF rect);
    public void DrawEllipse(Pen pen, int x, int y, int width, int height);
    public void DrawEllipse(Pen pen, float x, float y, float width, float height);
    public void DrawIcon(Icon icon, Rectangle targetRect);
    public void DrawIcon(Icon icon, int x, int y);
    public void DrawIconUnstretched(Icon icon, Rectangle targetRect);
    public void DrawImage(Image image, RectangleF rect);
    public void DrawImage(Image image, PointF point);
    public void DrawImage(Image image, Point[] destPoints);
    public void DrawImage(Image image, Point point);
    public void DrawImage(Image image, Rectangle rect);
    public void DrawImage(Image image, PointF[] destPoints);
    public void DrawImage(Image image, int x, int y);
    public void DrawImage(Image image, float x, float y);
    public void DrawImage(Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr);
    public void DrawImage(Image image, float x, float y, float width, float height);
    public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr);
    public void DrawImage(Image image, int x, int y, Rectangle srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, int x, int y, int width, int height);
    public void DrawImage(Image image, float x, float y, RectangleF srcRect, GraphicsUnit srcUnit);
    public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback);
    public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback);
    public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData);
    public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit);
    public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback, int callbackData);
    public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit);
    public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs);
    public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr);
    public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr, DrawImageAbort callback);
    public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback);
    public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData);
    public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, DrawImageAbort callback, IntPtr callbackData);
    public void DrawImageUnscaled(Image image, Point point);
    public void DrawImageUnscaled(Image image, Rectangle rect);
    public void DrawImageUnscaled(Image image, int x, int y);
    public void DrawImageUnscaled(Image image, int x, int y, int width, int height);
    public void DrawImageUnscaledAndClipped(Image image, Rectangle rect);
    public void DrawLine(Pen pen, PointF pt1, PointF pt2);
    public void DrawLine(Pen pen, Point pt1, Point pt2);
    public void DrawLine(Pen pen, int x1, int y1, int x2, int y2);
    public void DrawLine(Pen pen, float x1, float y1, float x2, float y2);
    public void DrawLines(Pen pen, PointF[] points);
    public void DrawLines(Pen pen, Point[] points);
    public void DrawPath(Pen pen, GraphicsPath path);
    public void DrawPie(Pen pen, Rectangle rect, float startAngle, float sweepAngle);
    public void DrawPie(Pen pen, RectangleF rect, float startAngle, float sweepAngle);
    public void DrawPie(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void DrawPie(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);
    public void DrawPolygon(Pen pen, Point[] points);
    public void DrawPolygon(Pen pen, PointF[] points);
    public void DrawRectangle(Pen pen, Rectangle rect);
    public void DrawRectangle(Pen pen, float x, float y, float width, float height);
    public void DrawRectangle(Pen pen, int x, int y, int width, int height);
    public void DrawRectangles(Pen pen, RectangleF[] rects);
    public void DrawRectangles(Pen pen, Rectangle[] rects);
    public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle);
    public void DrawString(string s, Font font, Brush brush, PointF point);
    public void DrawString(string s, Font font, Brush brush, PointF point, StringFormat format);
    public void DrawString(string s, Font font, Brush brush, float x, float y);
    public void DrawString(string s, Font font, Brush brush, float x, float y, StringFormat format);
    public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format);
    public void EndContainer(GraphicsContainer container);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, RectangleF destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF destPoint, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Rectangle destRect, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, EnumerateMetafileProc callback, IntPtr callbackData);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    [MonoTODOAttribute("Metafiles enumeration, for both WMF and EMF formats, isn't supported.")]
public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit unit, EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
    public void ExcludeClip(Rectangle rect);
    public void ExcludeClip(Region region);
    public void FillClosedCurve(Brush brush, PointF[] points);
    public void FillClosedCurve(Brush brush, Point[] points);
    public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode);
    public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode);
    public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode, float tension);
    public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode, float tension);
    public void FillEllipse(Brush brush, Rectangle rect);
    public void FillEllipse(Brush brush, RectangleF rect);
    public void FillEllipse(Brush brush, float x, float y, float width, float height);
    public void FillEllipse(Brush brush, int x, int y, int width, int height);
    public void FillPath(Brush brush, GraphicsPath path);
    public void FillPie(Brush brush, Rectangle rect, float startAngle, float sweepAngle);
    public void FillPie(Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle);
    public void FillPie(Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void FillPolygon(Brush brush, PointF[] points);
    public void FillPolygon(Brush brush, Point[] points);
    public void FillPolygon(Brush brush, Point[] points, FillMode fillMode);
    public void FillPolygon(Brush brush, PointF[] points, FillMode fillMode);
    public void FillRectangle(Brush brush, RectangleF rect);
    public void FillRectangle(Brush brush, Rectangle rect);
    public void FillRectangle(Brush brush, int x, int y, int width, int height);
    public void FillRectangle(Brush brush, float x, float y, float width, float height);
    public void FillRectangles(Brush brush, Rectangle[] rects);
    public void FillRectangles(Brush brush, RectangleF[] rects);
    public void FillRegion(Brush brush, Region region);
    public void Flush();
    public void Flush(FlushIntention intention);
    [EditorBrowsableAttribute("2")]
public static Graphics FromHdc(IntPtr hdc);
    [EditorBrowsableAttribute("2")]
[MonoTODOAttribute]
public static Graphics FromHdc(IntPtr hdc, IntPtr hdevice);
    [EditorBrowsableAttribute("2")]
public static Graphics FromHdcInternal(IntPtr hdc);
    [EditorBrowsableAttribute("2")]
public static Graphics FromHwnd(IntPtr hwnd);
    [EditorBrowsableAttribute("2")]
public static Graphics FromHwndInternal(IntPtr hwnd);
    public static Graphics FromImage(Image image);
    internal static Graphics FromXDrawable(IntPtr drawable, IntPtr display);
    [MonoTODOAttribute]
public static IntPtr GetHalftonePalette();
    public sealed virtual IntPtr GetHdc();
    public Color GetNearestColor(Color color);
    public void IntersectClip(Region region);
    public void IntersectClip(RectangleF rect);
    public void IntersectClip(Rectangle rect);
    public bool IsVisible(Point point);
    public bool IsVisible(RectangleF rect);
    public bool IsVisible(PointF point);
    public bool IsVisible(Rectangle rect);
    public bool IsVisible(float x, float y);
    public bool IsVisible(int x, int y);
    public bool IsVisible(float x, float y, float width, float height);
    public bool IsVisible(int x, int y, int width, int height);
    public Region[] MeasureCharacterRanges(string text, Font font, RectangleF layoutRect, StringFormat stringFormat);
    private SizeF GdipMeasureString(IntPtr graphics, string text, Font font, RectangleF& layoutRect, IntPtr stringFormat);
    public SizeF MeasureString(string text, Font font);
    public SizeF MeasureString(string text, Font font, SizeF layoutArea);
    public SizeF MeasureString(string text, Font font, int width);
    public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat);
    public SizeF MeasureString(string text, Font font, int width, StringFormat format);
    public SizeF MeasureString(string text, Font font, PointF origin, StringFormat stringFormat);
    public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat, Int32& charactersFitted, Int32& linesFilled);
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    [EditorBrowsableAttribute("2")]
public void ReleaseHdc(IntPtr hdc);
    public sealed virtual void ReleaseHdc();
    [MonoLimitationAttribute("Can only be used when hdc was provided by Graphics.GetHdc() method")]
[EditorBrowsableAttribute("1")]
public void ReleaseHdcInternal(IntPtr hdc);
    public void ResetClip();
    public void ResetTransform();
    public void Restore(GraphicsState gstate);
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
    public GraphicsState Save();
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void SetClip(RectangleF rect);
    public void SetClip(GraphicsPath path);
    public void SetClip(Rectangle rect);
    public void SetClip(Graphics g);
    public void SetClip(Graphics g, CombineMode combineMode);
    public void SetClip(Rectangle rect, CombineMode combineMode);
    public void SetClip(RectangleF rect, CombineMode combineMode);
    public void SetClip(Region region, CombineMode combineMode);
    public void SetClip(GraphicsPath path, CombineMode combineMode);
    public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, PointF[] pts);
    public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, Point[] pts);
    public void TranslateClip(int dx, int dy);
    public void TranslateClip(float dx, float dy);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public Region get_Clip();
    public void set_Clip(Region value);
    public RectangleF get_ClipBounds();
    public CompositingMode get_CompositingMode();
    public void set_CompositingMode(CompositingMode value);
    public CompositingQuality get_CompositingQuality();
    public void set_CompositingQuality(CompositingQuality value);
    public float get_DpiX();
    public float get_DpiY();
    public InterpolationMode get_InterpolationMode();
    public void set_InterpolationMode(InterpolationMode value);
    public bool get_IsClipEmpty();
    public bool get_IsVisibleClipEmpty();
    public float get_PageScale();
    public void set_PageScale(float value);
    public GraphicsUnit get_PageUnit();
    public void set_PageUnit(GraphicsUnit value);
    public PixelOffsetMode get_PixelOffsetMode();
    public void set_PixelOffsetMode(PixelOffsetMode value);
    public Point get_RenderingOrigin();
    public void set_RenderingOrigin(Point value);
    public SmoothingMode get_SmoothingMode();
    public void set_SmoothingMode(SmoothingMode value);
    public int get_TextContrast();
    public void set_TextContrast(int value);
    public TextRenderingHint get_TextRenderingHint();
    public void set_TextRenderingHint(TextRenderingHint value);
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public RectangleF get_VisibleClipBounds();
    [EditorBrowsableAttribute("1")]
[MonoTODOAttribute]
public object GetContextInfo();
}
public enum System.Drawing.GraphicsUnit : Enum {
    
public int value__;
    
public static GraphicsUnit World;
    
public static GraphicsUnit Display;
    
public static GraphicsUnit Pixel;
    
public static GraphicsUnit Point;
    
public static GraphicsUnit Inch;
    
public static GraphicsUnit Document;
    
public static GraphicsUnit Millimeter;
}
[TypeConverterAttribute("System.Drawing.IconConverter")]
[EditorAttribute("System.Drawing.Design.IconEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
public class System.Drawing.Icon : MarshalByRefObject {
    
private Size iconSize;
    
private IntPtr handle;
    
private IconDir iconDir;
    
private ushort id;
    
private ImageData[] imageData;
    
private bool undisposable;
    
private bool disposed;
    
private Bitmap bitmap;
    [BrowsableAttribute("False")]

public IntPtr Handle { get; }
    [BrowsableAttribute("False")]

public int Height { get; }
    
public Size Size { get; }
    [BrowsableAttribute("False")]

public int Width { get; }
    private Icon(IntPtr handle);
    public Icon(Icon original, int width, int height);
    public Icon(Icon original, Size size);
    public Icon(Stream stream);
    public Icon(Stream stream, int width, int height);
    public Icon(string fileName);
    public Icon(Type type, string resource);
    private Icon(SerializationInfo info, StreamingContext context);
    internal Icon(string resourceName, bool undisposable);
    public Icon(Stream stream, Size size);
    public Icon(string fileName, int width, int height);
    public Icon(string fileName, Size size);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    [MonoLimitationAttribute("The same icon, SystemIcons.WinLogo, is returned for all file types.")]
public static Icon ExtractAssociatedIcon(string filePath);
    public sealed virtual void Dispose();
    public sealed virtual object Clone();
    public static Icon FromHandle(IntPtr handle);
    private void SaveIconImage(BinaryWriter writer, IconImage ii);
    private void SaveIconDump(BinaryWriter writer, IconDump id);
    private void SaveIconDirEntry(BinaryWriter writer, IconDirEntry ide, UInt32 offset);
    private void SaveAll(BinaryWriter writer);
    private void SaveBestSingleIcon(BinaryWriter writer, int width, int height);
    private void SaveBitmapAsIcon(BinaryWriter writer);
    private void Save(Stream outputStream, int width, int height);
    public void Save(Stream outputStream);
    internal Bitmap BuildBitmapOnWin32();
    internal Bitmap GetInternalBitmap();
    public Bitmap ToBitmap();
    public virtual string ToString();
    public IntPtr get_Handle();
    public int get_Height();
    public Size get_Size();
    public int get_Width();
    protected virtual override void Finalize();
    private void InitFromStreamWithSize(Stream stream, int width, int height);
}
public class System.Drawing.IconConverter : ExpandableObjectConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Drawing.IconInfo : ValueType {
    
private int fIcon;
    
public int xHotspot;
    
public int yHotspot;
    
public IntPtr hbmMask;
    
public IntPtr hbmColor;
    
public bool IsIcon { get; public set; }
    public bool get_IsIcon();
    public void set_IsIcon(bool value);
}
public interface System.Drawing.IDeviceContext {
    public abstract virtual IntPtr GetHdc();
    public abstract virtual void ReleaseHdc();
}
internal interface System.Drawing.IMacContext {
    public abstract virtual void Synchronize();
    public abstract virtual void Release();
}
[ImmutableObjectAttribute("True")]
[TypeConverterAttribute("System.Drawing.ImageConverter")]
[ComVisibleAttribute("True")]
[EditorAttribute("System.Drawing.Design.ImageEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
public abstract class System.Drawing.Image : MarshalByRefObject {
    
private object tag;
    
internal IntPtr nativeObject;
    
internal Stream stream;
    [BrowsableAttribute("False")]

public int Flags { get; }
    [BrowsableAttribute("False")]

public Guid[] FrameDimensionsList { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[DefaultValueAttribute("False")]

public int Height { get; }
    
public float HorizontalResolution { get; }
    [BrowsableAttribute("False")]

public ColorPalette Palette { get; public set; }
    
public SizeF PhysicalDimension { get; }
    
public PixelFormat PixelFormat { get; }
    [BrowsableAttribute("False")]

public Int32[] PropertyIdList { get; }
    [BrowsableAttribute("False")]

public PropertyItem[] PropertyItems { get; }
    
public ImageFormat RawFormat { get; }
    
public Size Size { get; }
    [DefaultValueAttribute("")]
[LocalizableAttribute("False")]
[BindableAttribute("True")]
[TypeConverterAttribute("System.ComponentModel.StringConverter")]

public object Tag { get; public set; }
    
public float VerticalResolution { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[DefaultValueAttribute("False")]

public int Width { get; }
    
internal IntPtr NativeObject { get; internal set; }
    
internal IntPtr nativeImage { get; }
    internal Image(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    public static Image FromFile(string filename);
    public static Image FromFile(string filename, bool useEmbeddedColorManagement);
    public static Bitmap FromHbitmap(IntPtr hbitmap);
    public static Bitmap FromHbitmap(IntPtr hbitmap, IntPtr hpalette);
    public static Image FromStream(Stream stream);
    [MonoLimitationAttribute("useEmbeddedColorManagement  isn't supported.")]
public static Image FromStream(Stream stream, bool useEmbeddedColorManagement);
    [MonoLimitationAttribute("useEmbeddedColorManagement  and validateImageData aren't supported.")]
public static Image FromStream(Stream stream, bool useEmbeddedColorManagement, bool validateImageData);
    internal static Image LoadFromStream(Stream stream, bool keepAlive);
    internal static Image CreateImageObject(IntPtr nativeImage);
    internal static Image CreateFromHandle(IntPtr handle);
    public static int GetPixelFormatSize(PixelFormat pixfmt);
    public static bool IsAlphaPixelFormat(PixelFormat pixfmt);
    public static bool IsCanonicalPixelFormat(PixelFormat pixfmt);
    public static bool IsExtendedPixelFormat(PixelFormat pixfmt);
    internal static IntPtr InitFromStream(Stream stream);
    public RectangleF GetBounds(GraphicsUnit& pageUnit);
    public EncoderParameters GetEncoderParameterList(Guid encoder);
    public int GetFrameCount(FrameDimension dimension);
    public PropertyItem GetPropertyItem(int propid);
    public Image GetThumbnailImage(int thumbWidth, int thumbHeight, GetThumbnailImageAbort callback, IntPtr callbackData);
    public void RemovePropertyItem(int propid);
    public void RotateFlip(RotateFlipType rotateFlipType);
    internal ImageCodecInfo findEncoderForFormat(ImageFormat format);
    public void Save(string filename);
    public void Save(string filename, ImageFormat format);
    public void Save(string filename, ImageCodecInfo encoder, EncoderParameters encoderParams);
    public void Save(Stream stream, ImageFormat format);
    public void Save(Stream stream, ImageCodecInfo encoder, EncoderParameters encoderParams);
    public void SaveAdd(EncoderParameters encoderParams);
    public void SaveAdd(Image image, EncoderParameters encoderParams);
    public int SelectActiveFrame(FrameDimension dimension, int frameIndex);
    public void SetPropertyItem(PropertyItem propitem);
    public int get_Flags();
    public Guid[] get_FrameDimensionsList();
    public int get_Height();
    public float get_HorizontalResolution();
    public ColorPalette get_Palette();
    public void set_Palette(ColorPalette value);
    internal ColorPalette retrieveGDIPalette();
    internal void storeGDIPalette(ColorPalette palette);
    public SizeF get_PhysicalDimension();
    public PixelFormat get_PixelFormat();
    public Int32[] get_PropertyIdList();
    public PropertyItem[] get_PropertyItems();
    public ImageFormat get_RawFormat();
    public Size get_Size();
    public object get_Tag();
    public void set_Tag(object value);
    public float get_VerticalResolution();
    public int get_Width();
    internal IntPtr get_NativeObject();
    internal void set_NativeObject(IntPtr value);
    internal IntPtr get_nativeImage();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public sealed virtual object Clone();
    private object CloneFromStream();
}
public class System.Drawing.ImageAnimator : object {
    
private static Hashtable ht;
    private static ImageAnimator();
    public static void Animate(Image image, EventHandler onFrameChangedHandler);
    public static bool CanAnimate(Image image);
    public static void StopAnimate(Image image, EventHandler onFrameChangedHandler);
    public static void UpdateFrames();
    public static void UpdateFrames(Image image);
    private static void UpdateImageFrame(Image image);
}
public class System.Drawing.ImageConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.ImageFormatConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
internal enum System.Drawing.ImageType : Enum {
    
public int value__;
    
public static ImageType Unknown;
    
public static ImageType Bitmap;
    
public static ImageType Metafile;
}
public class System.Drawing.Imaging.BitmapData : object {
    
private int width;
    
private int height;
    
private int stride;
    
private PixelFormat pixel_format;
    
private IntPtr scan0;
    
private int reserved;
    
private IntPtr palette;
    
private int property_count;
    
private IntPtr property;
    
private float dpi_horz;
    
private float dpi_vert;
    
private int image_flags;
    
private int left;
    
private int top;
    
private int x;
    
private int y;
    
private int transparent;
    
public int Height { get; public set; }
    
public int Width { get; public set; }
    
public PixelFormat PixelFormat { get; public set; }
    
public int Reserved { get; public set; }
    
public IntPtr Scan0 { get; public set; }
    
public int Stride { get; public set; }
    public int get_Height();
    public void set_Height(int value);
    public int get_Width();
    public void set_Width(int value);
    public PixelFormat get_PixelFormat();
    public void set_PixelFormat(PixelFormat value);
    public int get_Reserved();
    public void set_Reserved(int value);
    public IntPtr get_Scan0();
    public void set_Scan0(IntPtr value);
    public int get_Stride();
    public void set_Stride(int value);
}
public enum System.Drawing.Imaging.ColorAdjustType : Enum {
    
public int value__;
    
public static ColorAdjustType Default;
    
public static ColorAdjustType Bitmap;
    
public static ColorAdjustType Brush;
    
public static ColorAdjustType Pen;
    
public static ColorAdjustType Text;
    
public static ColorAdjustType Count;
    
public static ColorAdjustType Any;
}
public enum System.Drawing.Imaging.ColorChannelFlag : Enum {
    
public int value__;
    
public static ColorChannelFlag ColorChannelC;
    
public static ColorChannelFlag ColorChannelM;
    
public static ColorChannelFlag ColorChannelY;
    
public static ColorChannelFlag ColorChannelK;
    
public static ColorChannelFlag ColorChannelLast;
}
public class System.Drawing.Imaging.ColorMap : object {
    
private Color _oldColor;
    
private Color _newColor;
    
public Color OldColor { get; public set; }
    
public Color NewColor { get; public set; }
    public Color get_OldColor();
    public void set_OldColor(Color value);
    public Color get_NewColor();
    public void set_NewColor(Color value);
}
public enum System.Drawing.Imaging.ColorMapType : Enum {
    
public int value__;
    
public static ColorMapType Default;
    
public static ColorMapType Brush;
}
[DefaultMemberAttribute("Item")]
public class System.Drawing.Imaging.ColorMatrix : object {
    
private float _matrix00;
    
private float _matrix01;
    
private float _matrix02;
    
private float _matrix03;
    
private float _matrix04;
    
private float _matrix10;
    
private float _matrix11;
    
private float _matrix12;
    
private float _matrix13;
    
private float _matrix14;
    
private float _matrix20;
    
private float _matrix21;
    
private float _matrix22;
    
private float _matrix23;
    
private float _matrix24;
    
private float _matrix30;
    
private float _matrix31;
    
private float _matrix32;
    
private float _matrix33;
    
private float _matrix34;
    
private float _matrix40;
    
private float _matrix41;
    
private float _matrix42;
    
private float _matrix43;
    
private float _matrix44;
    
public float Matrix00 { get; public set; }
    
public float Matrix01 { get; public set; }
    
public float Matrix02 { get; public set; }
    
public float Matrix03 { get; public set; }
    
public float Matrix04 { get; public set; }
    
public float Matrix10 { get; public set; }
    
public float Matrix11 { get; public set; }
    
public float Matrix12 { get; public set; }
    
public float Matrix13 { get; public set; }
    
public float Matrix14 { get; public set; }
    
public float Matrix20 { get; public set; }
    
public float Matrix21 { get; public set; }
    
public float Matrix22 { get; public set; }
    
public float Matrix23 { get; public set; }
    
public float Matrix24 { get; public set; }
    
public float Matrix30 { get; public set; }
    
public float Matrix31 { get; public set; }
    
public float Matrix32 { get; public set; }
    
public float Matrix33 { get; public set; }
    
public float Matrix34 { get; public set; }
    
public float Matrix40 { get; public set; }
    
public float Matrix41 { get; public set; }
    
public float Matrix42 { get; public set; }
    
public float Matrix43 { get; public set; }
    
public float Matrix44 { get; public set; }
    
public float Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ColorMatrix(Single[][] newColorMatrix);
    public float get_Matrix00();
    public void set_Matrix00(float value);
    public float get_Matrix01();
    public void set_Matrix01(float value);
    public float get_Matrix02();
    public void set_Matrix02(float value);
    public float get_Matrix03();
    public void set_Matrix03(float value);
    public float get_Matrix04();
    public void set_Matrix04(float value);
    public float get_Matrix10();
    public void set_Matrix10(float value);
    public float get_Matrix11();
    public void set_Matrix11(float value);
    public float get_Matrix12();
    public void set_Matrix12(float value);
    public float get_Matrix13();
    public void set_Matrix13(float value);
    public float get_Matrix14();
    public void set_Matrix14(float value);
    public float get_Matrix20();
    public void set_Matrix20(float value);
    public float get_Matrix21();
    public void set_Matrix21(float value);
    public float get_Matrix22();
    public void set_Matrix22(float value);
    public float get_Matrix23();
    public void set_Matrix23(float value);
    public float get_Matrix24();
    public void set_Matrix24(float value);
    public float get_Matrix30();
    public void set_Matrix30(float value);
    public float get_Matrix31();
    public void set_Matrix31(float value);
    public float get_Matrix32();
    public void set_Matrix32(float value);
    public float get_Matrix33();
    public void set_Matrix33(float value);
    public float get_Matrix34();
    public void set_Matrix34(float value);
    public float get_Matrix40();
    public void set_Matrix40(float value);
    public float get_Matrix41();
    public void set_Matrix41(float value);
    public float get_Matrix42();
    public void set_Matrix42(float value);
    public float get_Matrix43();
    public void set_Matrix43(float value);
    public float get_Matrix44();
    public void set_Matrix44(float value);
    internal void SetMatrix(Single[][] newColorMatrix);
    internal Single[][] GetMatrix();
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
}
public enum System.Drawing.Imaging.ColorMatrixFlag : Enum {
    
public int value__;
    
public static ColorMatrixFlag Default;
    
public static ColorMatrixFlag SkipGrays;
    
public static ColorMatrixFlag AltGrays;
}
public enum System.Drawing.Imaging.ColorMode : Enum {
    
public int value__;
    
public static ColorMode Argb32Mode;
    
public static ColorMode Argb64Mode;
}
public class System.Drawing.Imaging.ColorPalette : object {
    
private int _flags;
    
private Color[] _entries;
    
public int Flags { get; }
    
public Color[] Entries { get; }
    internal ColorPalette(int count);
    public int get_Flags();
    public Color[] get_Entries();
    internal void ConvertFromMemory(IntPtr memory);
    internal IntPtr ConvertToMemory();
}
internal enum System.Drawing.Imaging.EmfPlusFlags : Enum {
    
public int value__;
    
public static EmfPlusFlags Display;
    
public static EmfPlusFlags NonDualGdi;
}
public enum System.Drawing.Imaging.EmfPlusRecordType : Enum {
    
public int value__;
    
public static EmfPlusRecordType WmfRecordBase;
    
public static EmfPlusRecordType WmfSetBkColor;
    
public static EmfPlusRecordType WmfSetBkMode;
    
public static EmfPlusRecordType WmfSetMapMode;
    
public static EmfPlusRecordType WmfSetROP2;
    
public static EmfPlusRecordType WmfSetRelAbs;
    
public static EmfPlusRecordType WmfSetPolyFillMode;
    
public static EmfPlusRecordType WmfSetStretchBltMode;
    
public static EmfPlusRecordType WmfSetTextCharExtra;
    
public static EmfPlusRecordType WmfSetTextColor;
    
public static EmfPlusRecordType WmfSetTextJustification;
    
public static EmfPlusRecordType WmfSetWindowOrg;
    
public static EmfPlusRecordType WmfSetWindowExt;
    
public static EmfPlusRecordType WmfSetViewportOrg;
    
public static EmfPlusRecordType WmfSetViewportExt;
    
public static EmfPlusRecordType WmfOffsetWindowOrg;
    
public static EmfPlusRecordType WmfScaleWindowExt;
    
public static EmfPlusRecordType WmfOffsetViewportOrg;
    
public static EmfPlusRecordType WmfScaleViewportExt;
    
public static EmfPlusRecordType WmfLineTo;
    
public static EmfPlusRecordType WmfMoveTo;
    
public static EmfPlusRecordType WmfExcludeClipRect;
    
public static EmfPlusRecordType WmfIntersectClipRect;
    
public static EmfPlusRecordType WmfArc;
    
public static EmfPlusRecordType WmfEllipse;
    
public static EmfPlusRecordType WmfFloodFill;
    
public static EmfPlusRecordType WmfPie;
    
public static EmfPlusRecordType WmfRectangle;
    
public static EmfPlusRecordType WmfRoundRect;
    
public static EmfPlusRecordType WmfPatBlt;
    
public static EmfPlusRecordType WmfSaveDC;
    
public static EmfPlusRecordType WmfSetPixel;
    
public static EmfPlusRecordType WmfOffsetCilpRgn;
    
public static EmfPlusRecordType WmfTextOut;
    
public static EmfPlusRecordType WmfBitBlt;
    
public static EmfPlusRecordType WmfStretchBlt;
    
public static EmfPlusRecordType WmfPolygon;
    
public static EmfPlusRecordType WmfPolyline;
    
public static EmfPlusRecordType WmfEscape;
    
public static EmfPlusRecordType WmfRestoreDC;
    
public static EmfPlusRecordType WmfFillRegion;
    
public static EmfPlusRecordType WmfFrameRegion;
    
public static EmfPlusRecordType WmfInvertRegion;
    
public static EmfPlusRecordType WmfPaintRegion;
    
public static EmfPlusRecordType WmfSelectClipRegion;
    
public static EmfPlusRecordType WmfSelectObject;
    
public static EmfPlusRecordType WmfSetTextAlign;
    
public static EmfPlusRecordType WmfChord;
    
public static EmfPlusRecordType WmfSetMapperFlags;
    
public static EmfPlusRecordType WmfExtTextOut;
    
public static EmfPlusRecordType WmfSetDibToDev;
    
public static EmfPlusRecordType WmfSelectPalette;
    
public static EmfPlusRecordType WmfRealizePalette;
    
public static EmfPlusRecordType WmfAnimatePalette;
    
public static EmfPlusRecordType WmfSetPalEntries;
    
public static EmfPlusRecordType WmfPolyPolygon;
    
public static EmfPlusRecordType WmfResizePalette;
    
public static EmfPlusRecordType WmfDibBitBlt;
    
public static EmfPlusRecordType WmfDibStretchBlt;
    
public static EmfPlusRecordType WmfDibCreatePatternBrush;
    
public static EmfPlusRecordType WmfStretchDib;
    
public static EmfPlusRecordType WmfExtFloodFill;
    
public static EmfPlusRecordType WmfSetLayout;
    
public static EmfPlusRecordType WmfDeleteObject;
    
public static EmfPlusRecordType WmfCreatePalette;
    
public static EmfPlusRecordType WmfCreatePatternBrush;
    
public static EmfPlusRecordType WmfCreatePenIndirect;
    
public static EmfPlusRecordType WmfCreateFontIndirect;
    
public static EmfPlusRecordType WmfCreateBrushIndirect;
    
public static EmfPlusRecordType WmfCreateRegion;
    
public static EmfPlusRecordType EmfHeader;
    
public static EmfPlusRecordType EmfPolyBezier;
    
public static EmfPlusRecordType EmfPolygon;
    
public static EmfPlusRecordType EmfPolyline;
    
public static EmfPlusRecordType EmfPolyBezierTo;
    
public static EmfPlusRecordType EmfPolyLineTo;
    
public static EmfPlusRecordType EmfPolyPolyline;
    
public static EmfPlusRecordType EmfPolyPolygon;
    
public static EmfPlusRecordType EmfSetWindowExtEx;
    
public static EmfPlusRecordType EmfSetWindowOrgEx;
    
public static EmfPlusRecordType EmfSetViewportExtEx;
    
public static EmfPlusRecordType EmfSetViewportOrgEx;
    
public static EmfPlusRecordType EmfSetBrushOrgEx;
    
public static EmfPlusRecordType EmfEof;
    
public static EmfPlusRecordType EmfSetPixelV;
    
public static EmfPlusRecordType EmfSetMapperFlags;
    
public static EmfPlusRecordType EmfSetMapMode;
    
public static EmfPlusRecordType EmfSetBkMode;
    
public static EmfPlusRecordType EmfSetPolyFillMode;
    
public static EmfPlusRecordType EmfSetROP2;
    
public static EmfPlusRecordType EmfSetStretchBltMode;
    
public static EmfPlusRecordType EmfSetTextAlign;
    
public static EmfPlusRecordType EmfSetColorAdjustment;
    
public static EmfPlusRecordType EmfSetTextColor;
    
public static EmfPlusRecordType EmfSetBkColor;
    
public static EmfPlusRecordType EmfOffsetClipRgn;
    
public static EmfPlusRecordType EmfMoveToEx;
    
public static EmfPlusRecordType EmfSetMetaRgn;
    
public static EmfPlusRecordType EmfExcludeClipRect;
    
public static EmfPlusRecordType EmfIntersectClipRect;
    
public static EmfPlusRecordType EmfScaleViewportExtEx;
    
public static EmfPlusRecordType EmfScaleWindowExtEx;
    
public static EmfPlusRecordType EmfSaveDC;
    
public static EmfPlusRecordType EmfRestoreDC;
    
public static EmfPlusRecordType EmfSetWorldTransform;
    
public static EmfPlusRecordType EmfModifyWorldTransform;
    
public static EmfPlusRecordType EmfSelectObject;
    
public static EmfPlusRecordType EmfCreatePen;
    
public static EmfPlusRecordType EmfCreateBrushIndirect;
    
public static EmfPlusRecordType EmfDeleteObject;
    
public static EmfPlusRecordType EmfAngleArc;
    
public static EmfPlusRecordType EmfEllipse;
    
public static EmfPlusRecordType EmfRectangle;
    
public static EmfPlusRecordType EmfRoundRect;
    
public static EmfPlusRecordType EmfRoundArc;
    
public static EmfPlusRecordType EmfChord;
    
public static EmfPlusRecordType EmfPie;
    
public static EmfPlusRecordType EmfSelectPalette;
    
public static EmfPlusRecordType EmfCreatePalette;
    
public static EmfPlusRecordType EmfSetPaletteEntries;
    
public static EmfPlusRecordType EmfResizePalette;
    
public static EmfPlusRecordType EmfRealizePalette;
    
public static EmfPlusRecordType EmfExtFloodFill;
    
public static EmfPlusRecordType EmfLineTo;
    
public static EmfPlusRecordType EmfArcTo;
    
public static EmfPlusRecordType EmfPolyDraw;
    
public static EmfPlusRecordType EmfSetArcDirection;
    
public static EmfPlusRecordType EmfSetMiterLimit;
    
public static EmfPlusRecordType EmfBeginPath;
    
public static EmfPlusRecordType EmfEndPath;
    
public static EmfPlusRecordType EmfCloseFigure;
    
public static EmfPlusRecordType EmfFillPath;
    
public static EmfPlusRecordType EmfStrokeAndFillPath;
    
public static EmfPlusRecordType EmfStrokePath;
    
public static EmfPlusRecordType EmfFlattenPath;
    
public static EmfPlusRecordType EmfWidenPath;
    
public static EmfPlusRecordType EmfSelectClipPath;
    
public static EmfPlusRecordType EmfAbortPath;
    
public static EmfPlusRecordType EmfReserved069;
    
public static EmfPlusRecordType EmfGdiComment;
    
public static EmfPlusRecordType EmfFillRgn;
    
public static EmfPlusRecordType EmfFrameRgn;
    
public static EmfPlusRecordType EmfInvertRgn;
    
public static EmfPlusRecordType EmfPaintRgn;
    
public static EmfPlusRecordType EmfExtSelectClipRgn;
    
public static EmfPlusRecordType EmfBitBlt;
    
public static EmfPlusRecordType EmfStretchBlt;
    
public static EmfPlusRecordType EmfMaskBlt;
    
public static EmfPlusRecordType EmfPlgBlt;
    
public static EmfPlusRecordType EmfSetDIBitsToDevice;
    
public static EmfPlusRecordType EmfStretchDIBits;
    
public static EmfPlusRecordType EmfExtCreateFontIndirect;
    
public static EmfPlusRecordType EmfExtTextOutA;
    
public static EmfPlusRecordType EmfExtTextOutW;
    
public static EmfPlusRecordType EmfPolyBezier16;
    
public static EmfPlusRecordType EmfPolygon16;
    
public static EmfPlusRecordType EmfPolyline16;
    
public static EmfPlusRecordType EmfPolyBezierTo16;
    
public static EmfPlusRecordType EmfPolylineTo16;
    
public static EmfPlusRecordType EmfPolyPolyline16;
    
public static EmfPlusRecordType EmfPolyPolygon16;
    
public static EmfPlusRecordType EmfPolyDraw16;
    
public static EmfPlusRecordType EmfCreateMonoBrush;
    
public static EmfPlusRecordType EmfCreateDibPatternBrushPt;
    
public static EmfPlusRecordType EmfExtCreatePen;
    
public static EmfPlusRecordType EmfPolyTextOutA;
    
public static EmfPlusRecordType EmfPolyTextOutW;
    
public static EmfPlusRecordType EmfSetIcmMode;
    
public static EmfPlusRecordType EmfCreateColorSpace;
    
public static EmfPlusRecordType EmfSetColorSpace;
    
public static EmfPlusRecordType EmfDeleteColorSpace;
    
public static EmfPlusRecordType EmfGlsRecord;
    
public static EmfPlusRecordType EmfGlsBoundedRecord;
    
public static EmfPlusRecordType EmfPixelFormat;
    
public static EmfPlusRecordType EmfDrawEscape;
    
public static EmfPlusRecordType EmfExtEscape;
    
public static EmfPlusRecordType EmfStartDoc;
    
public static EmfPlusRecordType EmfSmallTextOut;
    
public static EmfPlusRecordType EmfForceUfiMapping;
    
public static EmfPlusRecordType EmfNamedEscpae;
    
public static EmfPlusRecordType EmfColorCorrectPalette;
    
public static EmfPlusRecordType EmfSetIcmProfileA;
    
public static EmfPlusRecordType EmfSetIcmProfileW;
    
public static EmfPlusRecordType EmfAlphaBlend;
    
public static EmfPlusRecordType EmfSetLayout;
    
public static EmfPlusRecordType EmfTransparentBlt;
    
public static EmfPlusRecordType EmfReserved117;
    
public static EmfPlusRecordType EmfGradientFill;
    
public static EmfPlusRecordType EmfSetLinkedUfis;
    
public static EmfPlusRecordType EmfSetTextJustification;
    
public static EmfPlusRecordType EmfColorMatchToTargetW;
    
public static EmfPlusRecordType EmfCreateColorSpaceW;
    
public static EmfPlusRecordType EmfMax;
    
public static EmfPlusRecordType EmfMin;
    
public static EmfPlusRecordType EmfPlusRecordBase;
    
public static EmfPlusRecordType Invalid;
    
public static EmfPlusRecordType Header;
    
public static EmfPlusRecordType EndOfFile;
    
public static EmfPlusRecordType Comment;
    
public static EmfPlusRecordType GetDC;
    
public static EmfPlusRecordType MultiFormatStart;
    
public static EmfPlusRecordType MultiFormatSection;
    
public static EmfPlusRecordType MultiFormatEnd;
    
public static EmfPlusRecordType Object;
    
public static EmfPlusRecordType Clear;
    
public static EmfPlusRecordType FillRects;
    
public static EmfPlusRecordType DrawRects;
    
public static EmfPlusRecordType FillPolygon;
    
public static EmfPlusRecordType DrawLines;
    
public static EmfPlusRecordType FillEllipse;
    
public static EmfPlusRecordType DrawEllipse;
    
public static EmfPlusRecordType FillPie;
    
public static EmfPlusRecordType DrawPie;
    
public static EmfPlusRecordType DrawArc;
    
public static EmfPlusRecordType FillRegion;
    
public static EmfPlusRecordType FillPath;
    
public static EmfPlusRecordType DrawPath;
    
public static EmfPlusRecordType FillClosedCurve;
    
public static EmfPlusRecordType DrawClosedCurve;
    
public static EmfPlusRecordType DrawCurve;
    
public static EmfPlusRecordType DrawBeziers;
    
public static EmfPlusRecordType DrawImage;
    
public static EmfPlusRecordType DrawImagePoints;
    
public static EmfPlusRecordType DrawString;
    
public static EmfPlusRecordType SetRenderingOrigin;
    
public static EmfPlusRecordType SetAntiAliasMode;
    
public static EmfPlusRecordType SetTextRenderingHint;
    
public static EmfPlusRecordType SetTextContrast;
    
public static EmfPlusRecordType SetInterpolationMode;
    
public static EmfPlusRecordType SetPixelOffsetMode;
    
public static EmfPlusRecordType SetCompositingMode;
    
public static EmfPlusRecordType SetCompositingQuality;
    
public static EmfPlusRecordType Save;
    
public static EmfPlusRecordType Restore;
    
public static EmfPlusRecordType BeginContainer;
    
public static EmfPlusRecordType BeginContainerNoParams;
    
public static EmfPlusRecordType EndContainer;
    
public static EmfPlusRecordType SetWorldTransform;
    
public static EmfPlusRecordType ResetWorldTransform;
    
public static EmfPlusRecordType MultiplyWorldTransform;
    
public static EmfPlusRecordType TranslateWorldTransform;
    
public static EmfPlusRecordType ScaleWorldTransform;
    
public static EmfPlusRecordType RotateWorldTransform;
    
public static EmfPlusRecordType SetPageTransform;
    
public static EmfPlusRecordType ResetClip;
    
public static EmfPlusRecordType SetClipRect;
    
public static EmfPlusRecordType SetClipPath;
    
public static EmfPlusRecordType SetClipRegion;
    
public static EmfPlusRecordType OffsetClip;
    
public static EmfPlusRecordType DrawDriverString;
    
public static EmfPlusRecordType Total;
    
public static EmfPlusRecordType Max;
    
public static EmfPlusRecordType Min;
}
public enum System.Drawing.Imaging.EmfType : Enum {
    
public int value__;
    
public static EmfType EmfOnly;
    
public static EmfType EmfPlusOnly;
    
public static EmfType EmfPlusDual;
}
public class System.Drawing.Imaging.Encoder : object {
    
public static Encoder Compression;
    
public static Encoder ColorDepth;
    
public static Encoder ScanMethod;
    
public static Encoder Version;
    
public static Encoder RenderMethod;
    
public static Encoder Quality;
    
public static Encoder Transformation;
    
public static Encoder LuminanceTable;
    
public static Encoder ChrominanceTable;
    
public static Encoder SaveFlag;
    
private Guid _guid;
    
public Guid Guid { get; }
    public Encoder(Guid guid);
    private static Encoder();
    public Guid get_Guid();
}
public class System.Drawing.Imaging.EncoderParameter : object {
    
private Guid _parameterGuid;
    
private int _numberOfValues;
    
private EncoderParameterValueType _parameterValueType;
    
private IntPtr _parameterValue;
    
public Encoder Encoder { get; public set; }
    
public EncoderParameterValueType Type { get; }
    
public EncoderParameterValueType ValueType { get; }
    
public int NumberOfValues { get; }
    public EncoderParameter(Encoder encoder, byte value);
    public EncoderParameter(Encoder encoder, byte value, bool undefined);
    public EncoderParameter(Encoder encoder, short value);
    public EncoderParameter(Encoder encoder, long value);
    public EncoderParameter(Encoder encoder, int numerator, int denominator);
    public EncoderParameter(Encoder encoder, long rangebegin, long rangeend);
    public EncoderParameter(Encoder encoder, int numerator1, int demoninator1, int numerator2, int demoninator2);
    public EncoderParameter(Encoder encoder, string value);
    public EncoderParameter(Encoder encoder, Byte[] value);
    public EncoderParameter(Encoder encoder, Byte[] value, bool undefined);
    public EncoderParameter(Encoder encoder, Int16[] value);
    public EncoderParameter(Encoder encoder, Int64[] value);
    public EncoderParameter(Encoder encoder, Int32[] numerator, Int32[] denominator);
    public EncoderParameter(Encoder encoder, Int64[] rangebegin, Int64[] rangeend);
    public EncoderParameter(Encoder encoder, Int32[] numerator1, Int32[] denominator1, Int32[] numerator2, Int32[] denominator2);
    [ObsoleteAttribute("This constructor has been deprecated. Use EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public EncoderParameter(Encoder encoder, int NumberOfValues, int Type, int Value);
    public EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value);
    protected virtual override void Finalize();
    public Encoder get_Encoder();
    public void set_Encoder(Encoder value);
    public EncoderParameterValueType get_Type();
    public EncoderParameterValueType get_ValueType();
    public int get_NumberOfValues();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private static IntPtr Add(IntPtr a, int b);
    private static IntPtr Add(int a, IntPtr b);
}
public class System.Drawing.Imaging.EncoderParameters : object {
    
private EncoderParameter[] _param;
    
public EncoderParameter[] Param { get; public set; }
    public EncoderParameters(int count);
    public EncoderParameter[] get_Param();
    public void set_Param(EncoderParameter[] value);
    internal IntPtr ConvertToMemory();
    internal static EncoderParameters ConvertFromMemory(IntPtr memory);
    public sealed virtual void Dispose();
}
public enum System.Drawing.Imaging.EncoderParameterValueType : Enum {
    
public int value__;
    
public static EncoderParameterValueType ValueTypeByte;
    
public static EncoderParameterValueType ValueTypeAscii;
    
public static EncoderParameterValueType ValueTypeShort;
    
public static EncoderParameterValueType ValueTypeLong;
    
public static EncoderParameterValueType ValueTypeRational;
    
public static EncoderParameterValueType ValueTypeLongRange;
    
public static EncoderParameterValueType ValueTypeUndefined;
    
public static EncoderParameterValueType ValueTypeRationalRange;
}
public enum System.Drawing.Imaging.EncoderValue : Enum {
    
public int value__;
    
public static EncoderValue ColorTypeCMYK;
    
public static EncoderValue ColorTypeYCCK;
    
public static EncoderValue CompressionLZW;
    
public static EncoderValue CompressionCCITT3;
    
public static EncoderValue CompressionCCITT4;
    
public static EncoderValue CompressionRle;
    
public static EncoderValue CompressionNone;
    
public static EncoderValue ScanMethodInterlaced;
    
public static EncoderValue ScanMethodNonInterlaced;
    
public static EncoderValue VersionGif87;
    
public static EncoderValue VersionGif89;
    
public static EncoderValue RenderProgressive;
    
public static EncoderValue RenderNonProgressive;
    
public static EncoderValue TransformRotate90;
    
public static EncoderValue TransformRotate180;
    
public static EncoderValue TransformRotate270;
    
public static EncoderValue TransformFlipHorizontal;
    
public static EncoderValue TransformFlipVertical;
    
public static EncoderValue MultiFrame;
    
public static EncoderValue LastFrame;
    
public static EncoderValue Flush;
    
public static EncoderValue FrameDimensionTime;
    
public static EncoderValue FrameDimensionResolution;
    
public static EncoderValue FrameDimensionPage;
}
internal class System.Drawing.Imaging.EnhMetafileHeader : ValueType {
    
public int type;
    
public int size;
    
public Rectangle bounds;
    
public Rectangle frame;
    
public int signature;
    
public int version;
    
public int bytes;
    
public int records;
    
public short handles;
    
public short reserved;
    
public int description;
    
public int off_description;
    
public int palette_entires;
    
public Size device;
    
public Size millimeters;
}
public class System.Drawing.Imaging.FrameDimension : object {
    
private static FrameDimension s_time;
    
private static FrameDimension s_resolution;
    
private static FrameDimension s_page;
    
private Guid _guid;
    
public Guid Guid { get; }
    
public static FrameDimension Time { get; }
    
public static FrameDimension Resolution { get; }
    
public static FrameDimension Page { get; }
    public FrameDimension(Guid guid);
    private static FrameDimension();
    public Guid get_Guid();
    public static FrameDimension get_Time();
    public static FrameDimension get_Resolution();
    public static FrameDimension get_Page();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Drawing.Imaging.ImageAttributes : object {
    
internal IntPtr nativeImageAttributes;
    internal ImageAttributes(IntPtr newNativeImageAttributes);
    internal void SetNativeImageAttributes(IntPtr handle);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual object Clone();
    public void SetColorMatrix(ColorMatrix newColorMatrix);
    public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag flags);
    public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag mode, ColorAdjustType type);
    public void ClearColorMatrix();
    public void ClearColorMatrix(ColorAdjustType type);
    public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix);
    public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags);
    public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag mode, ColorAdjustType type);
    public void SetThreshold(float threshold);
    public void SetThreshold(float threshold, ColorAdjustType type);
    public void ClearThreshold();
    public void ClearThreshold(ColorAdjustType type);
    public void SetGamma(float gamma);
    public void SetGamma(float gamma, ColorAdjustType type);
    public void ClearGamma();
    public void ClearGamma(ColorAdjustType type);
    public void SetNoOp();
    public void SetNoOp(ColorAdjustType type);
    public void ClearNoOp();
    public void ClearNoOp(ColorAdjustType type);
    public void SetColorKey(Color colorLow, Color colorHigh);
    public void SetColorKey(Color colorLow, Color colorHigh, ColorAdjustType type);
    public void ClearColorKey();
    public void ClearColorKey(ColorAdjustType type);
    public void SetOutputChannel(ColorChannelFlag flags);
    public void SetOutputChannel(ColorChannelFlag flags, ColorAdjustType type);
    public void ClearOutputChannel();
    public void ClearOutputChannel(ColorAdjustType type);
    public void SetOutputChannelColorProfile(string colorProfileFilename);
    public void SetOutputChannelColorProfile(string colorProfileFilename, ColorAdjustType type);
    public void ClearOutputChannelColorProfile();
    public void ClearOutputChannelColorProfile(ColorAdjustType type);
    public void SetRemapTable(ColorMap[] map);
    public void SetRemapTable(ColorMap[] map, ColorAdjustType type);
    public void ClearRemapTable();
    public void ClearRemapTable(ColorAdjustType type);
    public void SetBrushRemapTable(ColorMap[] map);
    public void ClearBrushRemapTable();
    public void SetWrapMode(WrapMode mode);
    public void SetWrapMode(WrapMode mode, Color color);
    public void SetWrapMode(WrapMode mode, Color color, bool clamp);
    public void GetAdjustedPalette(ColorPalette palette, ColorAdjustType type);
}
[FlagsAttribute]
public enum System.Drawing.Imaging.ImageCodecFlags : Enum {
    
public int value__;
    
public static ImageCodecFlags Encoder;
    
public static ImageCodecFlags Decoder;
    
public static ImageCodecFlags SupportBitmap;
    
public static ImageCodecFlags SupportVector;
    
public static ImageCodecFlags SeekableEncode;
    
public static ImageCodecFlags BlockingDecode;
    
public static ImageCodecFlags Builtin;
    
public static ImageCodecFlags System;
    
public static ImageCodecFlags User;
}
public class System.Drawing.Imaging.ImageCodecInfo : object {
    
private Guid _clsid;
    
private Guid _formatID;
    
private string _codecName;
    
private string _dllName;
    
private string _formatDescription;
    
private string _filenameExtension;
    
private string _mimeType;
    
private ImageCodecFlags _flags;
    
private int _version;
    
private Byte[][] _signaturePatterns;
    
private Byte[][] _signatureMasks;
    
public Guid Clsid { get; public set; }
    
public Guid FormatID { get; public set; }
    
public string CodecName { get; public set; }
    
public string DllName { get; public set; }
    
public string FormatDescription { get; public set; }
    
public string FilenameExtension { get; public set; }
    
public string MimeType { get; public set; }
    
public ImageCodecFlags Flags { get; public set; }
    
public int Version { get; public set; }
    [CLSCompliantAttribute("False")]

public Byte[][] SignaturePatterns { get; public set; }
    [CLSCompliantAttribute("False")]

public Byte[][] SignatureMasks { get; public set; }
    public Guid get_Clsid();
    public void set_Clsid(Guid value);
    public Guid get_FormatID();
    public void set_FormatID(Guid value);
    public string get_CodecName();
    public void set_CodecName(string value);
    public string get_DllName();
    public void set_DllName(string value);
    public string get_FormatDescription();
    public void set_FormatDescription(string value);
    public string get_FilenameExtension();
    public void set_FilenameExtension(string value);
    public string get_MimeType();
    public void set_MimeType(string value);
    public ImageCodecFlags get_Flags();
    public void set_Flags(ImageCodecFlags value);
    public int get_Version();
    public void set_Version(int value);
    public Byte[][] get_SignaturePatterns();
    public void set_SignaturePatterns(Byte[][] value);
    public Byte[][] get_SignatureMasks();
    public void set_SignatureMasks(Byte[][] value);
    public static ImageCodecInfo[] GetImageDecoders();
    public static ImageCodecInfo[] GetImageEncoders();
    private static ImageCodecInfo[] ConvertFromMemory(IntPtr memoryStart, int numCodecs);
}
internal class System.Drawing.Imaging.ImageCodecInfoPrivate : object {
    
public Guid Clsid;
    
public Guid FormatID;
    
public IntPtr CodecName;
    
public IntPtr DllName;
    
public IntPtr FormatDescription;
    
public IntPtr FilenameExtension;
    
public IntPtr MimeType;
    
public int Flags;
    
public int Version;
    
public int SigCount;
    
public int SigSize;
    
public IntPtr SigPattern;
    
public IntPtr SigMask;
}
[FlagsAttribute]
public enum System.Drawing.Imaging.ImageFlags : Enum {
    
public int value__;
    
public static ImageFlags None;
    
public static ImageFlags Scalable;
    
public static ImageFlags HasAlpha;
    
public static ImageFlags HasTranslucent;
    
public static ImageFlags PartiallyScalable;
    
public static ImageFlags ColorSpaceRgb;
    
public static ImageFlags ColorSpaceCmyk;
    
public static ImageFlags ColorSpaceGray;
    
public static ImageFlags ColorSpaceYcbcr;
    
public static ImageFlags ColorSpaceYcck;
    
public static ImageFlags HasRealDpi;
    
public static ImageFlags HasRealPixelSize;
    
public static ImageFlags ReadOnly;
    
public static ImageFlags Caching;
}
[TypeConverterAttribute("System.Drawing.ImageFormatConverter")]
public class System.Drawing.Imaging.ImageFormat : object {
    
private Guid guid;
    
private string name;
    
private static string BmpGuid;
    
private static string EmfGuid;
    
private static string ExifGuid;
    
private static string GifGuid;
    
private static string TiffGuid;
    
private static string PngGuid;
    
private static string MemoryBmpGuid;
    
private static string IconGuid;
    
private static string JpegGuid;
    
private static string WmfGuid;
    
private static object locker;
    
private static ImageFormat BmpImageFormat;
    
private static ImageFormat EmfImageFormat;
    
private static ImageFormat ExifImageFormat;
    
private static ImageFormat GifImageFormat;
    
private static ImageFormat TiffImageFormat;
    
private static ImageFormat PngImageFormat;
    
private static ImageFormat MemoryBmpImageFormat;
    
private static ImageFormat IconImageFormat;
    
private static ImageFormat JpegImageFormat;
    
private static ImageFormat WmfImageFormat;
    
public Guid Guid { get; }
    
public static ImageFormat Bmp { get; }
    
public static ImageFormat Emf { get; }
    
public static ImageFormat Exif { get; }
    
public static ImageFormat Gif { get; }
    
public static ImageFormat Icon { get; }
    
public static ImageFormat Jpeg { get; }
    
public static ImageFormat MemoryBmp { get; }
    
public static ImageFormat Png { get; }
    
public static ImageFormat Tiff { get; }
    
public static ImageFormat Wmf { get; }
    public ImageFormat(Guid guid);
    private ImageFormat(string name, string guid);
    private static ImageFormat();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public Guid get_Guid();
    public static ImageFormat get_Bmp();
    public static ImageFormat get_Emf();
    public static ImageFormat get_Exif();
    public static ImageFormat get_Gif();
    public static ImageFormat get_Icon();
    public static ImageFormat get_Jpeg();
    public static ImageFormat get_MemoryBmp();
    public static ImageFormat get_Png();
    public static ImageFormat get_Tiff();
    public static ImageFormat get_Wmf();
}
public enum System.Drawing.Imaging.ImageLockMode : Enum {
    
public int value__;
    
public static ImageLockMode ReadOnly;
    
public static ImageLockMode WriteOnly;
    
public static ImageLockMode ReadWrite;
    
public static ImageLockMode UserInputBuffer;
}
[MonoTODOAttribute("Metafiles, both WMF and EMF formats, are only partially supported.")]
[EditorAttribute("System.Drawing.Design.MetafileEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor")]
public class System.Drawing.Imaging.Metafile : Image {
    internal Metafile(IntPtr ptr);
    internal Metafile(IntPtr ptr, Stream stream);
    public Metafile(Stream stream);
    public Metafile(string filename);
    public Metafile(IntPtr henhmetafile, bool deleteEmf);
    public Metafile(IntPtr referenceHdc, EmfType emfType);
    public Metafile(IntPtr referenceHdc, Rectangle frameRect);
    public Metafile(IntPtr referenceHdc, RectangleF frameRect);
    public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader);
    public Metafile(Stream stream, IntPtr referenceHdc);
    public Metafile(string fileName, IntPtr referenceHdc);
    public Metafile(IntPtr referenceHdc, EmfType emfType, string description);
    public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
    public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
    public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader, bool deleteWmf);
    public Metafile(Stream stream, IntPtr referenceHdc, EmfType type);
    public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect);
    public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect);
    public Metafile(string fileName, IntPtr referenceHdc, EmfType type);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect);
    public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(Stream stream, IntPtr referenceHdc, EmfType type, string description);
    public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
    public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
    public Metafile(string fileName, IntPtr referenceHdc, EmfType type, string description);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
    public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string desc);
    public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, string description);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, string desc);
    public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
    public IntPtr GetHenhmetafile();
    [MonoLimitationAttribute("Metafiles aren't only partially supported by libgdiplus.")]
public MetafileHeader GetMetafileHeader();
    [MonoLimitationAttribute("Metafiles aren't only partially supported by libgdiplus.")]
public static MetafileHeader GetMetafileHeader(IntPtr henhmetafile);
    [MonoLimitationAttribute("Metafiles aren't only partially supported by libgdiplus.")]
public static MetafileHeader GetMetafileHeader(Stream stream);
    [MonoLimitationAttribute("Metafiles aren't only partially supported by libgdiplus.")]
public static MetafileHeader GetMetafileHeader(string fileName);
    [MonoLimitationAttribute("Metafiles aren't only partially supported by libgdiplus.")]
public static MetafileHeader GetMetafileHeader(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader);
    [MonoLimitationAttribute("Metafiles aren't only partially supported by libgdiplus.")]
public void PlayRecord(EmfPlusRecordType recordType, int flags, int dataSize, Byte[] data);
}
public enum System.Drawing.Imaging.MetafileFrameUnit : Enum {
    
public int value__;
    
public static MetafileFrameUnit Pixel;
    
public static MetafileFrameUnit Point;
    
public static MetafileFrameUnit Inch;
    
public static MetafileFrameUnit Document;
    
public static MetafileFrameUnit Millimeter;
    
public static MetafileFrameUnit GdiCompatible;
}
[MonoTODOAttribute("Metafiles, both WMF and EMF formats, aren't supported.")]
public class System.Drawing.Imaging.MetafileHeader : object {
    
private MonoMetafileHeader header;
    
public Rectangle Bounds { get; }
    
public float DpiX { get; }
    
public float DpiY { get; }
    
public int EmfPlusHeaderSize { get; }
    
public int LogicalDpiX { get; }
    
public int LogicalDpiY { get; }
    
public int MetafileSize { get; }
    
public MetafileType Type { get; }
    
public int Version { get; }
    
public MetaHeader WmfHeader { get; }
    internal MetafileHeader(IntPtr henhmetafile);
    [MonoTODOAttribute("always returns false")]
public bool IsDisplay();
    public bool IsEmf();
    public bool IsEmfOrEmfPlus();
    public bool IsEmfPlus();
    public bool IsEmfPlusDual();
    public bool IsEmfPlusOnly();
    public bool IsWmf();
    public bool IsWmfPlaceable();
    public Rectangle get_Bounds();
    public float get_DpiX();
    public float get_DpiY();
    public int get_EmfPlusHeaderSize();
    public int get_LogicalDpiX();
    public int get_LogicalDpiY();
    public int get_MetafileSize();
    public MetafileType get_Type();
    public int get_Version();
    public MetaHeader get_WmfHeader();
}
internal class System.Drawing.Imaging.MetafileHeaderEmf : object {
    
public MetafileType type;
    
public int size;
    
public int version;
    
public EmfPlusFlags emfPlusFlags;
    
public float dpiX;
    
public float dpiY;
    
public int X;
    
public int Y;
    
public int Width;
    
public int Height;
    
public ENHMETAHEADER EmfHeader;
    
public int EmfPlusHeaderSize;
    
public int LogicalDpiX;
    
public int LogicalDpiY;
}
internal class System.Drawing.Imaging.MetafileHeaderWmf : object {
    
public MetafileType type;
    
public int size;
    
public int version;
    
public EmfPlusFlags emfPlusFlags;
    
public float dpiX;
    
public float dpiY;
    
public int X;
    
public int Y;
    
public int Width;
    
public int Height;
    
public MetaHeader WmfHeader;
    
public int dummy1;
    
public int dummy2;
    
public int dummy3;
    
public int dummy4;
    
public int dummy5;
    
public int dummy6;
    
public int dummy7;
    
public int dummy8;
    
public int dummy9;
    
public int dummy10;
    
public int dummy11;
    
public int dummy12;
    
public int dummy13;
    
public int dummy14;
    
public int dummy15;
    
public int dummy16;
    
public int EmfPlusHeaderSize;
    
public int LogicalDpiX;
    
public int LogicalDpiY;
}
public enum System.Drawing.Imaging.MetafileType : Enum {
    
public int value__;
    
public static MetafileType Invalid;
    
public static MetafileType Wmf;
    
public static MetafileType WmfPlaceable;
    
public static MetafileType Emf;
    
public static MetafileType EmfPlusOnly;
    
public static MetafileType EmfPlusDual;
}
public class System.Drawing.Imaging.MetaHeader : object {
    
private WmfMetaHeader wmf;
    
public short HeaderSize { get; public set; }
    
public int MaxRecord { get; public set; }
    
public short NoObjects { get; public set; }
    
public short NoParameters { get; public set; }
    
public int Size { get; public set; }
    
public short Type { get; public set; }
    
public short Version { get; public set; }
    internal MetaHeader(WmfMetaHeader header);
    public short get_HeaderSize();
    public void set_HeaderSize(short value);
    public int get_MaxRecord();
    public void set_MaxRecord(int value);
    public short get_NoObjects();
    public void set_NoObjects(short value);
    public short get_NoParameters();
    public void set_NoParameters(short value);
    public int get_Size();
    public void set_Size(int value);
    public short get_Type();
    public void set_Type(short value);
    public short get_Version();
    public void set_Version(short value);
}
internal class System.Drawing.Imaging.MonoMetafileHeader : ValueType {
    
public MetafileType type;
    
public int size;
    
public int version;
    
public int emf_plus_flags;
    
public float dpi_x;
    
public float dpi_y;
    
public int x;
    
public int y;
    
public int width;
    
public int height;
    
public WmfMetaHeader wmf_header;
    
public EnhMetafileHeader emf_header;
    
public int emfplus_header_size;
    
public int logical_dpi_x;
    
public int logical_dpi_y;
}
[FlagsAttribute]
public enum System.Drawing.Imaging.PaletteFlags : Enum {
    
public int value__;
    
public static PaletteFlags HasAlpha;
    
public static PaletteFlags GrayScale;
    
public static PaletteFlags Halftone;
}
public enum System.Drawing.Imaging.PixelFormat : Enum {
    
public int value__;
    
public static PixelFormat Indexed;
    
public static PixelFormat Gdi;
    
public static PixelFormat Alpha;
    
public static PixelFormat PAlpha;
    
public static PixelFormat Extended;
    
public static PixelFormat Canonical;
    
public static PixelFormat Undefined;
    
public static PixelFormat DontCare;
    
public static PixelFormat Format1bppIndexed;
    
public static PixelFormat Format4bppIndexed;
    
public static PixelFormat Format8bppIndexed;
    
public static PixelFormat Format16bppGrayScale;
    
public static PixelFormat Format16bppRgb555;
    
public static PixelFormat Format16bppRgb565;
    
public static PixelFormat Format16bppArgb1555;
    
public static PixelFormat Format24bppRgb;
    
public static PixelFormat Format32bppRgb;
    
public static PixelFormat Format32bppArgb;
    
public static PixelFormat Format32bppPArgb;
    
public static PixelFormat Format48bppRgb;
    
public static PixelFormat Format64bppArgb;
    
public static PixelFormat Format64bppPArgb;
    
public static PixelFormat Max;
}
public class System.Drawing.Imaging.PlayRecordCallback : MulticastDelegate {
    public PlayRecordCallback(object object, IntPtr method);
    public virtual void Invoke(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData);
    public virtual IAsyncResult BeginInvoke(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Imaging.PropertyItem : object {
    
private int _id;
    
private int _len;
    
private short _type;
    
private Byte[] _value;
    
public int Id { get; public set; }
    
public int Len { get; public set; }
    
public short Type { get; public set; }
    
public Byte[] Value { get; public set; }
    public int get_Id();
    public void set_Id(int value);
    public int get_Len();
    public void set_Len(int value);
    public short get_Type();
    public void set_Type(short value);
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
}
internal class System.Drawing.Imaging.PropertyItemInternal : object {
    
public int id;
    
public int len;
    
public short type;
    
public IntPtr value;
    
public Byte[] Value { get; }
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal static PropertyItemInternal ConvertFromPropertyItem(PropertyItem propItem);
    internal static PropertyItem[] ConvertFromMemory(IntPtr propdata, int count);
    public Byte[] get_Value();
}
internal class System.Drawing.Imaging.WmfMetaHeader : ValueType {
    
public short file_type;
    
public short header_size;
    
public short version;
    
public ushort file_size_low;
    
public ushort file_size_high;
    
public short num_of_objects;
    
public int max_record_size;
    
public short num_of_params;
}
public class System.Drawing.Imaging.WmfPlaceableFileHeader : object {
    
private int _key;
    
private short _hmf;
    
private short _bboxLeft;
    
private short _bboxTop;
    
private short _bboxRight;
    
private short _bboxBottom;
    
private short _inch;
    
private int _reserved;
    
private short _checksum;
    
public int Key { get; public set; }
    
public short Hmf { get; public set; }
    
public short BboxLeft { get; public set; }
    
public short BboxTop { get; public set; }
    
public short BboxRight { get; public set; }
    
public short BboxBottom { get; public set; }
    
public short Inch { get; public set; }
    
public int Reserved { get; public set; }
    
public short Checksum { get; public set; }
    public int get_Key();
    public void set_Key(int value);
    public short get_Hmf();
    public void set_Hmf(short value);
    public short get_BboxLeft();
    public void set_BboxLeft(short value);
    public short get_BboxTop();
    public void set_BboxTop(short value);
    public short get_BboxRight();
    public void set_BboxRight(short value);
    public short get_BboxBottom();
    public void set_BboxBottom(short value);
    public short get_Inch();
    public void set_Inch(short value);
    public int get_Reserved();
    public void set_Reserved(int value);
    public short get_Checksum();
    public void set_Checksum(short value);
}
internal class System.Drawing.Internal.GPPOINT : object {
    
internal int X;
    
internal int Y;
    internal GPPOINT(Point pt);
}
internal class System.Drawing.Internal.GPPOINTF : object {
    
internal float X;
    
internal float Y;
    internal GPPOINTF(PointF pt);
    internal PointF ToPoint();
}
internal class System.Drawing.Internal.GPRECT : ValueType {
    
internal int X;
    
internal int Y;
    
internal int Width;
    
internal int Height;
    internal GPRECT(int x, int y, int width, int height);
    internal GPRECT(Rectangle rect);
}
internal class System.Drawing.Internal.GPRECTF : ValueType {
    
internal float X;
    
internal float Y;
    
internal float Width;
    
internal float Height;
    
internal SizeF SizeF { get; }
    internal GPRECTF(float x, float y, float width, float height);
    internal GPRECTF(RectangleF rect);
    internal SizeF get_SizeF();
    internal RectangleF ToRectangleF();
}
public enum System.Drawing.KnownColor : Enum {
    
public int value__;
    
public static KnownColor ActiveBorder;
    
public static KnownColor ActiveCaption;
    
public static KnownColor ActiveCaptionText;
    
public static KnownColor AppWorkspace;
    
public static KnownColor Control;
    
public static KnownColor ControlDark;
    
public static KnownColor ControlDarkDark;
    
public static KnownColor ControlLight;
    
public static KnownColor ControlLightLight;
    
public static KnownColor ControlText;
    
public static KnownColor Desktop;
    
public static KnownColor GrayText;
    
public static KnownColor Highlight;
    
public static KnownColor HighlightText;
    
public static KnownColor HotTrack;
    
public static KnownColor InactiveBorder;
    
public static KnownColor InactiveCaption;
    
public static KnownColor InactiveCaptionText;
    
public static KnownColor Info;
    
public static KnownColor InfoText;
    
public static KnownColor Menu;
    
public static KnownColor MenuText;
    
public static KnownColor ScrollBar;
    
public static KnownColor Window;
    
public static KnownColor WindowFrame;
    
public static KnownColor WindowText;
    
public static KnownColor Transparent;
    
public static KnownColor AliceBlue;
    
public static KnownColor AntiqueWhite;
    
public static KnownColor Aqua;
    
public static KnownColor Aquamarine;
    
public static KnownColor Azure;
    
public static KnownColor Beige;
    
public static KnownColor Bisque;
    
public static KnownColor Black;
    
public static KnownColor BlanchedAlmond;
    
public static KnownColor Blue;
    
public static KnownColor BlueViolet;
    
public static KnownColor Brown;
    
public static KnownColor BurlyWood;
    
public static KnownColor CadetBlue;
    
public static KnownColor Chartreuse;
    
public static KnownColor Chocolate;
    
public static KnownColor Coral;
    
public static KnownColor CornflowerBlue;
    
public static KnownColor Cornsilk;
    
public static KnownColor Crimson;
    
public static KnownColor Cyan;
    
public static KnownColor DarkBlue;
    
public static KnownColor DarkCyan;
    
public static KnownColor DarkGoldenrod;
    
public static KnownColor DarkGray;
    
public static KnownColor DarkGreen;
    
public static KnownColor DarkKhaki;
    
public static KnownColor DarkMagenta;
    
public static KnownColor DarkOliveGreen;
    
public static KnownColor DarkOrange;
    
public static KnownColor DarkOrchid;
    
public static KnownColor DarkRed;
    
public static KnownColor DarkSalmon;
    
public static KnownColor DarkSeaGreen;
    
public static KnownColor DarkSlateBlue;
    
public static KnownColor DarkSlateGray;
    
public static KnownColor DarkTurquoise;
    
public static KnownColor DarkViolet;
    
public static KnownColor DeepPink;
    
public static KnownColor DeepSkyBlue;
    
public static KnownColor DimGray;
    
public static KnownColor DodgerBlue;
    
public static KnownColor Firebrick;
    
public static KnownColor FloralWhite;
    
public static KnownColor ForestGreen;
    
public static KnownColor Fuchsia;
    
public static KnownColor Gainsboro;
    
public static KnownColor GhostWhite;
    
public static KnownColor Gold;
    
public static KnownColor Goldenrod;
    
public static KnownColor Gray;
    
public static KnownColor Green;
    
public static KnownColor GreenYellow;
    
public static KnownColor Honeydew;
    
public static KnownColor HotPink;
    
public static KnownColor IndianRed;
    
public static KnownColor Indigo;
    
public static KnownColor Ivory;
    
public static KnownColor Khaki;
    
public static KnownColor Lavender;
    
public static KnownColor LavenderBlush;
    
public static KnownColor LawnGreen;
    
public static KnownColor LemonChiffon;
    
public static KnownColor LightBlue;
    
public static KnownColor LightCoral;
    
public static KnownColor LightCyan;
    
public static KnownColor LightGoldenrodYellow;
    
public static KnownColor LightGray;
    
public static KnownColor LightGreen;
    
public static KnownColor LightPink;
    
public static KnownColor LightSalmon;
    
public static KnownColor LightSeaGreen;
    
public static KnownColor LightSkyBlue;
    
public static KnownColor LightSlateGray;
    
public static KnownColor LightSteelBlue;
    
public static KnownColor LightYellow;
    
public static KnownColor Lime;
    
public static KnownColor LimeGreen;
    
public static KnownColor Linen;
    
public static KnownColor Magenta;
    
public static KnownColor Maroon;
    
public static KnownColor MediumAquamarine;
    
public static KnownColor MediumBlue;
    
public static KnownColor MediumOrchid;
    
public static KnownColor MediumPurple;
    
public static KnownColor MediumSeaGreen;
    
public static KnownColor MediumSlateBlue;
    
public static KnownColor MediumSpringGreen;
    
public static KnownColor MediumTurquoise;
    
public static KnownColor MediumVioletRed;
    
public static KnownColor MidnightBlue;
    
public static KnownColor MintCream;
    
public static KnownColor MistyRose;
    
public static KnownColor Moccasin;
    
public static KnownColor NavajoWhite;
    
public static KnownColor Navy;
    
public static KnownColor OldLace;
    
public static KnownColor Olive;
    
public static KnownColor OliveDrab;
    
public static KnownColor Orange;
    
public static KnownColor OrangeRed;
    
public static KnownColor Orchid;
    
public static KnownColor PaleGoldenrod;
    
public static KnownColor PaleGreen;
    
public static KnownColor PaleTurquoise;
    
public static KnownColor PaleVioletRed;
    
public static KnownColor PapayaWhip;
    
public static KnownColor PeachPuff;
    
public static KnownColor Peru;
    
public static KnownColor Pink;
    
public static KnownColor Plum;
    
public static KnownColor PowderBlue;
    
public static KnownColor Purple;
    
public static KnownColor Red;
    
public static KnownColor RosyBrown;
    
public static KnownColor RoyalBlue;
    
public static KnownColor SaddleBrown;
    
public static KnownColor Salmon;
    
public static KnownColor SandyBrown;
    
public static KnownColor SeaGreen;
    
public static KnownColor SeaShell;
    
public static KnownColor Sienna;
    
public static KnownColor Silver;
    
public static KnownColor SkyBlue;
    
public static KnownColor SlateBlue;
    
public static KnownColor SlateGray;
    
public static KnownColor Snow;
    
public static KnownColor SpringGreen;
    
public static KnownColor SteelBlue;
    
public static KnownColor Tan;
    
public static KnownColor Teal;
    
public static KnownColor Thistle;
    
public static KnownColor Tomato;
    
public static KnownColor Turquoise;
    
public static KnownColor Violet;
    
public static KnownColor Wheat;
    
public static KnownColor White;
    
public static KnownColor WhiteSmoke;
    
public static KnownColor Yellow;
    
public static KnownColor YellowGreen;
    
public static KnownColor ButtonFace;
    
public static KnownColor ButtonHighlight;
    
public static KnownColor ButtonShadow;
    
public static KnownColor GradientActiveCaption;
    
public static KnownColor GradientInactiveCaption;
    
public static KnownColor MenuBar;
    
public static KnownColor MenuHighlight;
}
internal static class System.Drawing.KnownColors : object {
    
internal static UInt32[] ArgbValues;
    private static KnownColors();
    private static UInt32 GetSysColor(GetSysColorIndex index);
    private static void RetrieveWindowsSystemColors();
    public static Color FromKnownColor(KnownColor kc);
    public static string GetName(short kc);
    public static string GetName(KnownColor kc);
    public static Color FindColorMatch(Color c);
    public static void Update(int knownColor, int color);
}
internal class System.Drawing.LOGFONT : ValueType {
    
internal int lfHeight;
    
internal UInt32 lfWidth;
    
internal UInt32 lfEscapement;
    
internal UInt32 lfOrientation;
    
internal UInt32 lfWeight;
    
internal byte lfItalic;
    
internal byte lfUnderline;
    
internal byte lfStrikeOut;
    
internal byte lfCharSet;
    
internal byte lfOutPrecision;
    
internal byte lfClipPrecision;
    
internal byte lfQuality;
    
internal byte lfPitchAndFamily;
    
internal string lfFaceName;
}
internal static class System.Drawing.MacSupport : object {
    
internal static Hashtable contextReference;
    
internal static object lockobj;
    
internal static Delegate hwnd_delegate;
    private static MacSupport();
    internal static CocoaContext GetCGContextForNSView(IntPtr handle);
    internal static CarbonContext GetCGContextForView(IntPtr handle);
    internal static IntPtr GetContext(IntPtr port);
    internal static void ReleaseContext(IntPtr port, IntPtr context);
    public static IntPtr objc_getClass(string className);
    public static IntPtr objc_msgSend(IntPtr basePtr, IntPtr selector, string argument);
    public static IntPtr objc_msgSend(IntPtr basePtr, IntPtr selector);
    public static void objc_msgSend_stret(Rect& arect, IntPtr basePtr, IntPtr selector);
    public static bool bool_objc_msgSend(IntPtr handle, IntPtr selector);
    public static IntPtr sel_registerName(string selectorName);
    internal static IntPtr CGMainDisplayID();
    internal static Rect CGDisplayBounds(IntPtr display);
    internal static int HIViewGetBounds(IntPtr vHnd, Rect& r);
    internal static int HIViewConvertRect(Rect& r, IntPtr a, IntPtr b);
    internal static IntPtr GetControlOwner(IntPtr aView);
    internal static int GetWindowBounds(IntPtr wHnd, UInt32 reg, QDRect& rect);
    internal static IntPtr GetWindowPort(IntPtr hWnd);
    internal static IntPtr GetQDGlobalsThePort();
    internal static void CreateCGContextForPort(IntPtr port, IntPtr& context);
    internal static void CFRelease(IntPtr context);
    internal static void QDBeginCGContext(IntPtr port, IntPtr& context);
    internal static void QDEndCGContext(IntPtr port, IntPtr& context);
    internal static int CGContextClipToRect(IntPtr context, Rect clip);
    internal static int CGContextClipToRects(IntPtr context, Rect[] clip_rects, int count);
    internal static void CGContextTranslateCTM(IntPtr context, float tx, float ty);
    internal static void CGContextScaleCTM(IntPtr context, float x, float y);
    internal static void CGContextFlush(IntPtr context);
    internal static void CGContextSynchronize(IntPtr context);
    internal static IntPtr CGPathCreateMutable();
    internal static void CGPathAddRects(IntPtr path, IntPtr _void, Rect[] rects, int count);
    internal static void CGPathAddRect(IntPtr path, IntPtr _void, Rect rect);
    internal static void CGContextAddRects(IntPtr context, Rect[] rects, int count);
    internal static void CGContextAddRect(IntPtr context, Rect rect);
    internal static void CGContextBeginPath(IntPtr context);
    internal static void CGContextClosePath(IntPtr context);
    internal static void CGContextAddPath(IntPtr context, IntPtr path);
    internal static void CGContextClip(IntPtr context);
    internal static void CGContextEOClip(IntPtr context);
    internal static void CGContextEOFillPath(IntPtr context);
    internal static void CGContextSaveGState(IntPtr context);
    internal static void CGContextRestoreGState(IntPtr context);
}
internal class System.Drawing.NativeMethods : object {
    
internal static HandleRef NullHandleRef;
    
public static int MAX_PATH;
    
internal static int SM_REMOTESESSION;
    
internal static int OBJ_DC;
    
internal static int OBJ_METADC;
    
internal static int OBJ_MEMDC;
    
internal static int OBJ_ENHMETADC;
    
internal static int DIB_RGB_COLORS;
    
internal static int BI_BITFIELDS;
    
internal static int BI_RGB;
    
internal static int BITMAPINFO_MAX_COLORSIZE;
    
internal static int SPI_GETICONTITLELOGFONT;
    
internal static int SPI_GETNONCLIENTMETRICS;
    
internal static int DEFAULT_GUI_FONT;
    private static NativeMethods();
}
public class System.Drawing.Pen : MarshalByRefObject {
    
internal IntPtr nativeObject;
    
internal bool isModifiable;
    
private Color color;
    
private CustomLineCap startCap;
    
private CustomLineCap endCap;
    [MonoLimitationAttribute("Libgdiplus doesn't use this property for rendering")]

public PenAlignment Alignment { get; public set; }
    
public Brush Brush { get; public set; }
    
public Color Color { get; public set; }
    
public Single[] CompoundArray { get; public set; }
    
public CustomLineCap CustomEndCap { get; public set; }
    
public CustomLineCap CustomStartCap { get; public set; }
    
public DashCap DashCap { get; public set; }
    
public float DashOffset { get; public set; }
    
public Single[] DashPattern { get; public set; }
    
public DashStyle DashStyle { get; public set; }
    
public LineCap StartCap { get; public set; }
    
public LineCap EndCap { get; public set; }
    
public LineJoin LineJoin { get; public set; }
    
public float MiterLimit { get; public set; }
    
public PenType PenType { get; }
    
public Matrix Transform { get; public set; }
    
public float Width { get; public set; }
    
internal IntPtr NativePen { get; }
    internal Pen(IntPtr p);
    public Pen(Brush brush);
    public Pen(Color color);
    public Pen(Brush brush, float width);
    public Pen(Color color, float width);
    public PenAlignment get_Alignment();
    public void set_Alignment(PenAlignment value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public Color get_Color();
    public void set_Color(Color value);
    public Single[] get_CompoundArray();
    public void set_CompoundArray(Single[] value);
    public CustomLineCap get_CustomEndCap();
    public void set_CustomEndCap(CustomLineCap value);
    public CustomLineCap get_CustomStartCap();
    public void set_CustomStartCap(CustomLineCap value);
    public DashCap get_DashCap();
    public void set_DashCap(DashCap value);
    public float get_DashOffset();
    public void set_DashOffset(float value);
    public Single[] get_DashPattern();
    public void set_DashPattern(Single[] value);
    public DashStyle get_DashStyle();
    public void set_DashStyle(DashStyle value);
    public LineCap get_StartCap();
    public void set_StartCap(LineCap value);
    public LineCap get_EndCap();
    public void set_EndCap(LineCap value);
    public LineJoin get_LineJoin();
    public void set_LineJoin(LineJoin value);
    public float get_MiterLimit();
    public void set_MiterLimit(float value);
    public PenType get_PenType();
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public float get_Width();
    public void set_Width(float value);
    internal IntPtr get_NativePen();
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void ResetTransform();
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void SetLineCap(LineCap startCap, LineCap endCap, DashCap dashCap);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
}
public class System.Drawing.Pens : object {
    
private static Pen aliceblue;
    
private static Pen antiquewhite;
    
private static Pen aqua;
    
private static Pen aquamarine;
    
private static Pen azure;
    
private static Pen beige;
    
private static Pen bisque;
    
private static Pen black;
    
private static Pen blanchedalmond;
    
private static Pen blue;
    
private static Pen blueviolet;
    
private static Pen brown;
    
private static Pen burlywood;
    
private static Pen cadetblue;
    
private static Pen chartreuse;
    
private static Pen chocolate;
    
private static Pen coral;
    
private static Pen cornflowerblue;
    
private static Pen cornsilk;
    
private static Pen crimson;
    
private static Pen cyan;
    
private static Pen darkblue;
    
private static Pen darkcyan;
    
private static Pen darkgoldenrod;
    
private static Pen darkgray;
    
private static Pen darkgreen;
    
private static Pen darkkhaki;
    
private static Pen darkmagenta;
    
private static Pen darkolivegreen;
    
private static Pen darkorange;
    
private static Pen darkorchid;
    
private static Pen darkred;
    
private static Pen darksalmon;
    
private static Pen darkseagreen;
    
private static Pen darkslateblue;
    
private static Pen darkslategray;
    
private static Pen darkturquoise;
    
private static Pen darkviolet;
    
private static Pen deeppink;
    
private static Pen deepskyblue;
    
private static Pen dimgray;
    
private static Pen dodgerblue;
    
private static Pen firebrick;
    
private static Pen floralwhite;
    
private static Pen forestgreen;
    
private static Pen fuchsia;
    
private static Pen gainsboro;
    
private static Pen ghostwhite;
    
private static Pen gold;
    
private static Pen goldenrod;
    
private static Pen gray;
    
private static Pen green;
    
private static Pen greenyellow;
    
private static Pen honeydew;
    
private static Pen hotpink;
    
private static Pen indianred;
    
private static Pen indigo;
    
private static Pen ivory;
    
private static Pen khaki;
    
private static Pen lavender;
    
private static Pen lavenderblush;
    
private static Pen lawngreen;
    
private static Pen lemonchiffon;
    
private static Pen lightblue;
    
private static Pen lightcoral;
    
private static Pen lightcyan;
    
private static Pen lightgoldenrodyellow;
    
private static Pen lightgray;
    
private static Pen lightgreen;
    
private static Pen lightpink;
    
private static Pen lightsalmon;
    
private static Pen lightseagreen;
    
private static Pen lightskyblue;
    
private static Pen lightslategray;
    
private static Pen lightsteelblue;
    
private static Pen lightyellow;
    
private static Pen lime;
    
private static Pen limegreen;
    
private static Pen linen;
    
private static Pen magenta;
    
private static Pen maroon;
    
private static Pen mediumaquamarine;
    
private static Pen mediumblue;
    
private static Pen mediumorchid;
    
private static Pen mediumpurple;
    
private static Pen mediumseagreen;
    
private static Pen mediumslateblue;
    
private static Pen mediumspringgreen;
    
private static Pen mediumturquoise;
    
private static Pen mediumvioletred;
    
private static Pen midnightblue;
    
private static Pen mintcream;
    
private static Pen mistyrose;
    
private static Pen moccasin;
    
private static Pen navajowhite;
    
private static Pen navy;
    
private static Pen oldlace;
    
private static Pen olive;
    
private static Pen olivedrab;
    
private static Pen orange;
    
private static Pen orangered;
    
private static Pen orchid;
    
private static Pen palegoldenrod;
    
private static Pen palegreen;
    
private static Pen paleturquoise;
    
private static Pen palevioletred;
    
private static Pen papayawhip;
    
private static Pen peachpuff;
    
private static Pen peru;
    
private static Pen pink;
    
private static Pen plum;
    
private static Pen powderblue;
    
private static Pen purple;
    
private static Pen red;
    
private static Pen rosybrown;
    
private static Pen royalblue;
    
private static Pen saddlebrown;
    
private static Pen salmon;
    
private static Pen sandybrown;
    
private static Pen seagreen;
    
private static Pen seashell;
    
private static Pen sienna;
    
private static Pen silver;
    
private static Pen skyblue;
    
private static Pen slateblue;
    
private static Pen slategray;
    
private static Pen snow;
    
private static Pen springgreen;
    
private static Pen steelblue;
    
private static Pen tan;
    
private static Pen teal;
    
private static Pen thistle;
    
private static Pen tomato;
    
private static Pen transparent;
    
private static Pen turquoise;
    
private static Pen violet;
    
private static Pen wheat;
    
private static Pen white;
    
private static Pen whitesmoke;
    
private static Pen yellow;
    
private static Pen yellowgreen;
    
public static Pen AliceBlue { get; }
    
public static Pen AntiqueWhite { get; }
    
public static Pen Aqua { get; }
    
public static Pen Aquamarine { get; }
    
public static Pen Azure { get; }
    
public static Pen Beige { get; }
    
public static Pen Bisque { get; }
    
public static Pen Black { get; }
    
public static Pen BlanchedAlmond { get; }
    
public static Pen Blue { get; }
    
public static Pen BlueViolet { get; }
    
public static Pen Brown { get; }
    
public static Pen BurlyWood { get; }
    
public static Pen CadetBlue { get; }
    
public static Pen Chartreuse { get; }
    
public static Pen Chocolate { get; }
    
public static Pen Coral { get; }
    
public static Pen CornflowerBlue { get; }
    
public static Pen Cornsilk { get; }
    
public static Pen Crimson { get; }
    
public static Pen Cyan { get; }
    
public static Pen DarkBlue { get; }
    
public static Pen DarkCyan { get; }
    
public static Pen DarkGoldenrod { get; }
    
public static Pen DarkGray { get; }
    
public static Pen DarkGreen { get; }
    
public static Pen DarkKhaki { get; }
    
public static Pen DarkMagenta { get; }
    
public static Pen DarkOliveGreen { get; }
    
public static Pen DarkOrange { get; }
    
public static Pen DarkOrchid { get; }
    
public static Pen DarkRed { get; }
    
public static Pen DarkSalmon { get; }
    
public static Pen DarkSeaGreen { get; }
    
public static Pen DarkSlateBlue { get; }
    
public static Pen DarkSlateGray { get; }
    
public static Pen DarkTurquoise { get; }
    
public static Pen DarkViolet { get; }
    
public static Pen DeepPink { get; }
    
public static Pen DeepSkyBlue { get; }
    
public static Pen DimGray { get; }
    
public static Pen DodgerBlue { get; }
    
public static Pen Firebrick { get; }
    
public static Pen FloralWhite { get; }
    
public static Pen ForestGreen { get; }
    
public static Pen Fuchsia { get; }
    
public static Pen Gainsboro { get; }
    
public static Pen GhostWhite { get; }
    
public static Pen Gold { get; }
    
public static Pen Goldenrod { get; }
    
public static Pen Gray { get; }
    
public static Pen Green { get; }
    
public static Pen GreenYellow { get; }
    
public static Pen Honeydew { get; }
    
public static Pen HotPink { get; }
    
public static Pen IndianRed { get; }
    
public static Pen Indigo { get; }
    
public static Pen Ivory { get; }
    
public static Pen Khaki { get; }
    
public static Pen Lavender { get; }
    
public static Pen LavenderBlush { get; }
    
public static Pen LawnGreen { get; }
    
public static Pen LemonChiffon { get; }
    
public static Pen LightBlue { get; }
    
public static Pen LightCoral { get; }
    
public static Pen LightCyan { get; }
    
public static Pen LightGoldenrodYellow { get; }
    
public static Pen LightGray { get; }
    
public static Pen LightGreen { get; }
    
public static Pen LightPink { get; }
    
public static Pen LightSalmon { get; }
    
public static Pen LightSeaGreen { get; }
    
public static Pen LightSkyBlue { get; }
    
public static Pen LightSlateGray { get; }
    
public static Pen LightSteelBlue { get; }
    
public static Pen LightYellow { get; }
    
public static Pen Lime { get; }
    
public static Pen LimeGreen { get; }
    
public static Pen Linen { get; }
    
public static Pen Magenta { get; }
    
public static Pen Maroon { get; }
    
public static Pen MediumAquamarine { get; }
    
public static Pen MediumBlue { get; }
    
public static Pen MediumOrchid { get; }
    
public static Pen MediumPurple { get; }
    
public static Pen MediumSeaGreen { get; }
    
public static Pen MediumSlateBlue { get; }
    
public static Pen MediumSpringGreen { get; }
    
public static Pen MediumTurquoise { get; }
    
public static Pen MediumVioletRed { get; }
    
public static Pen MidnightBlue { get; }
    
public static Pen MintCream { get; }
    
public static Pen MistyRose { get; }
    
public static Pen Moccasin { get; }
    
public static Pen NavajoWhite { get; }
    
public static Pen Navy { get; }
    
public static Pen OldLace { get; }
    
public static Pen Olive { get; }
    
public static Pen OliveDrab { get; }
    
public static Pen Orange { get; }
    
public static Pen OrangeRed { get; }
    
public static Pen Orchid { get; }
    
public static Pen PaleGoldenrod { get; }
    
public static Pen PaleGreen { get; }
    
public static Pen PaleTurquoise { get; }
    
public static Pen PaleVioletRed { get; }
    
public static Pen PapayaWhip { get; }
    
public static Pen PeachPuff { get; }
    
public static Pen Peru { get; }
    
public static Pen Pink { get; }
    
public static Pen Plum { get; }
    
public static Pen PowderBlue { get; }
    
public static Pen Purple { get; }
    
public static Pen Red { get; }
    
public static Pen RosyBrown { get; }
    
public static Pen RoyalBlue { get; }
    
public static Pen SaddleBrown { get; }
    
public static Pen Salmon { get; }
    
public static Pen SandyBrown { get; }
    
public static Pen SeaGreen { get; }
    
public static Pen SeaShell { get; }
    
public static Pen Sienna { get; }
    
public static Pen Silver { get; }
    
public static Pen SkyBlue { get; }
    
public static Pen SlateBlue { get; }
    
public static Pen SlateGray { get; }
    
public static Pen Snow { get; }
    
public static Pen SpringGreen { get; }
    
public static Pen SteelBlue { get; }
    
public static Pen Tan { get; }
    
public static Pen Teal { get; }
    
public static Pen Thistle { get; }
    
public static Pen Tomato { get; }
    
public static Pen Transparent { get; }
    
public static Pen Turquoise { get; }
    
public static Pen Violet { get; }
    
public static Pen Wheat { get; }
    
public static Pen White { get; }
    
public static Pen WhiteSmoke { get; }
    
public static Pen Yellow { get; }
    
public static Pen YellowGreen { get; }
    public static Pen get_AliceBlue();
    public static Pen get_AntiqueWhite();
    public static Pen get_Aqua();
    public static Pen get_Aquamarine();
    public static Pen get_Azure();
    public static Pen get_Beige();
    public static Pen get_Bisque();
    public static Pen get_Black();
    public static Pen get_BlanchedAlmond();
    public static Pen get_Blue();
    public static Pen get_BlueViolet();
    public static Pen get_Brown();
    public static Pen get_BurlyWood();
    public static Pen get_CadetBlue();
    public static Pen get_Chartreuse();
    public static Pen get_Chocolate();
    public static Pen get_Coral();
    public static Pen get_CornflowerBlue();
    public static Pen get_Cornsilk();
    public static Pen get_Crimson();
    public static Pen get_Cyan();
    public static Pen get_DarkBlue();
    public static Pen get_DarkCyan();
    public static Pen get_DarkGoldenrod();
    public static Pen get_DarkGray();
    public static Pen get_DarkGreen();
    public static Pen get_DarkKhaki();
    public static Pen get_DarkMagenta();
    public static Pen get_DarkOliveGreen();
    public static Pen get_DarkOrange();
    public static Pen get_DarkOrchid();
    public static Pen get_DarkRed();
    public static Pen get_DarkSalmon();
    public static Pen get_DarkSeaGreen();
    public static Pen get_DarkSlateBlue();
    public static Pen get_DarkSlateGray();
    public static Pen get_DarkTurquoise();
    public static Pen get_DarkViolet();
    public static Pen get_DeepPink();
    public static Pen get_DeepSkyBlue();
    public static Pen get_DimGray();
    public static Pen get_DodgerBlue();
    public static Pen get_Firebrick();
    public static Pen get_FloralWhite();
    public static Pen get_ForestGreen();
    public static Pen get_Fuchsia();
    public static Pen get_Gainsboro();
    public static Pen get_GhostWhite();
    public static Pen get_Gold();
    public static Pen get_Goldenrod();
    public static Pen get_Gray();
    public static Pen get_Green();
    public static Pen get_GreenYellow();
    public static Pen get_Honeydew();
    public static Pen get_HotPink();
    public static Pen get_IndianRed();
    public static Pen get_Indigo();
    public static Pen get_Ivory();
    public static Pen get_Khaki();
    public static Pen get_Lavender();
    public static Pen get_LavenderBlush();
    public static Pen get_LawnGreen();
    public static Pen get_LemonChiffon();
    public static Pen get_LightBlue();
    public static Pen get_LightCoral();
    public static Pen get_LightCyan();
    public static Pen get_LightGoldenrodYellow();
    public static Pen get_LightGray();
    public static Pen get_LightGreen();
    public static Pen get_LightPink();
    public static Pen get_LightSalmon();
    public static Pen get_LightSeaGreen();
    public static Pen get_LightSkyBlue();
    public static Pen get_LightSlateGray();
    public static Pen get_LightSteelBlue();
    public static Pen get_LightYellow();
    public static Pen get_Lime();
    public static Pen get_LimeGreen();
    public static Pen get_Linen();
    public static Pen get_Magenta();
    public static Pen get_Maroon();
    public static Pen get_MediumAquamarine();
    public static Pen get_MediumBlue();
    public static Pen get_MediumOrchid();
    public static Pen get_MediumPurple();
    public static Pen get_MediumSeaGreen();
    public static Pen get_MediumSlateBlue();
    public static Pen get_MediumSpringGreen();
    public static Pen get_MediumTurquoise();
    public static Pen get_MediumVioletRed();
    public static Pen get_MidnightBlue();
    public static Pen get_MintCream();
    public static Pen get_MistyRose();
    public static Pen get_Moccasin();
    public static Pen get_NavajoWhite();
    public static Pen get_Navy();
    public static Pen get_OldLace();
    public static Pen get_Olive();
    public static Pen get_OliveDrab();
    public static Pen get_Orange();
    public static Pen get_OrangeRed();
    public static Pen get_Orchid();
    public static Pen get_PaleGoldenrod();
    public static Pen get_PaleGreen();
    public static Pen get_PaleTurquoise();
    public static Pen get_PaleVioletRed();
    public static Pen get_PapayaWhip();
    public static Pen get_PeachPuff();
    public static Pen get_Peru();
    public static Pen get_Pink();
    public static Pen get_Plum();
    public static Pen get_PowderBlue();
    public static Pen get_Purple();
    public static Pen get_Red();
    public static Pen get_RosyBrown();
    public static Pen get_RoyalBlue();
    public static Pen get_SaddleBrown();
    public static Pen get_Salmon();
    public static Pen get_SandyBrown();
    public static Pen get_SeaGreen();
    public static Pen get_SeaShell();
    public static Pen get_Sienna();
    public static Pen get_Silver();
    public static Pen get_SkyBlue();
    public static Pen get_SlateBlue();
    public static Pen get_SlateGray();
    public static Pen get_Snow();
    public static Pen get_SpringGreen();
    public static Pen get_SteelBlue();
    public static Pen get_Tan();
    public static Pen get_Teal();
    public static Pen get_Thistle();
    public static Pen get_Tomato();
    public static Pen get_Transparent();
    public static Pen get_Turquoise();
    public static Pen get_Violet();
    public static Pen get_Wheat();
    public static Pen get_White();
    public static Pen get_WhiteSmoke();
    public static Pen get_Yellow();
    public static Pen get_YellowGreen();
}
[ComVisibleAttribute("True")]
[TypeConverterAttribute("System.Drawing.PointConverter")]
public class System.Drawing.Point : ValueType {
    
private int x;
    
private int y;
    
public static Point Empty;
    [BrowsableAttribute("False")]

public bool IsEmpty { get; }
    
public int X { get; public set; }
    
public int Y { get; public set; }
    public Point(int dw);
    public Point(Size sz);
    public Point(int x, int y);
    public static Point Ceiling(PointF value);
    public static Point Round(PointF value);
    public static Point Truncate(PointF value);
    public static Point op_Addition(Point pt, Size sz);
    public static bool op_Equality(Point left, Point right);
    public static bool op_Inequality(Point left, Point right);
    public static Point op_Subtraction(Point pt, Size sz);
    public static Size op_Explicit(Point p);
    public static PointF op_Implicit(Point p);
    public bool get_IsEmpty();
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Offset(int dx, int dy);
    public virtual string ToString();
    public static Point Add(Point pt, Size sz);
    public void Offset(Point p);
    public static Point Subtract(Point pt, Size sz);
}
public class System.Drawing.PointConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
[ComVisibleAttribute("True")]
public class System.Drawing.PointF : ValueType {
    
private float x;
    
private float y;
    
public static PointF Empty;
    [BrowsableAttribute("False")]

public bool IsEmpty { get; }
    
public float X { get; public set; }
    
public float Y { get; public set; }
    public PointF(float x, float y);
    public static PointF op_Addition(PointF pt, Size sz);
    public static PointF op_Addition(PointF pt, SizeF sz);
    public static bool op_Equality(PointF left, PointF right);
    public static bool op_Inequality(PointF left, PointF right);
    public static PointF op_Subtraction(PointF pt, Size sz);
    public static PointF op_Subtraction(PointF pt, SizeF sz);
    public bool get_IsEmpty();
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static PointF Add(PointF pt, Size sz);
    public static PointF Add(PointF pt, SizeF sz);
    public static PointF Subtract(PointF pt, Size sz);
    public static PointF Subtract(PointF pt, SizeF sz);
}
public enum System.Drawing.Printing.Duplex : Enum {
    
public int value__;
    
public static Duplex Default;
    
public static Duplex Simplex;
    
public static Duplex Horizontal;
    
public static Duplex Vertical;
}
internal abstract class System.Drawing.Printing.GlobalPrintingServices : object {
    
internal StringCollection InstalledPrinters { get; }
    internal abstract virtual StringCollection get_InstalledPrinters();
    internal abstract virtual IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings page_settings);
    internal abstract virtual bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file);
    internal abstract virtual bool StartPage(GraphicsPrinter gr);
    internal abstract virtual bool EndPage(GraphicsPrinter gr);
    internal abstract virtual bool EndDoc(GraphicsPrinter gr);
}
internal class System.Drawing.Printing.GlobalPrintingServicesUnix : GlobalPrintingServices {
    
internal StringCollection InstalledPrinters { get; }
    internal virtual StringCollection get_InstalledPrinters();
    internal virtual IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings default_page_settings);
    internal virtual bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file);
    internal virtual bool EndDoc(GraphicsPrinter gr);
    internal virtual bool StartPage(GraphicsPrinter gr);
    internal virtual bool EndPage(GraphicsPrinter gr);
}
internal class System.Drawing.Printing.GlobalPrintingServicesWin32 : GlobalPrintingServices {
    
internal StringCollection InstalledPrinters { get; }
    internal virtual StringCollection get_InstalledPrinters();
    internal virtual IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings default_page_settings);
    internal virtual bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file);
    internal virtual bool EndDoc(GraphicsPrinter gr);
    internal virtual bool StartPage(GraphicsPrinter gr);
    internal virtual bool EndPage(GraphicsPrinter gr);
}
internal class System.Drawing.Printing.GraphicsPrinter : object {
    
private Graphics graphics;
    
private IntPtr hDC;
    
internal Graphics Graphics { get; internal set; }
    
internal IntPtr Hdc { get; }
    internal GraphicsPrinter(Graphics gr, IntPtr dc);
    internal Graphics get_Graphics();
    internal void set_Graphics(Graphics value);
    internal IntPtr get_Hdc();
}
public class System.Drawing.Printing.InvalidPrinterException : SystemException {
    
private PrinterSettings _settings;
    protected InvalidPrinterException(SerializationInfo info, StreamingContext context);
    public InvalidPrinterException(PrinterSettings settings);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static string GenerateMessage(PrinterSettings settings);
}
[TypeConverterAttribute("System.Drawing.Printing.MarginsConverter")]
public class System.Drawing.Printing.Margins : object {
    
private int _left;
    
private int _right;
    
private int _bottom;
    
private int _top;
    [OptionalFieldAttribute]

private double _doubleLeft;
    [OptionalFieldAttribute]

private double _doubleRight;
    [OptionalFieldAttribute]

private double _doubleTop;
    [OptionalFieldAttribute]

private double _doubleBottom;
    
public int Left { get; public set; }
    
public int Right { get; public set; }
    
public int Top { get; public set; }
    
public int Bottom { get; public set; }
    
internal double DoubleLeft { get; internal set; }
    
internal double DoubleRight { get; internal set; }
    
internal double DoubleTop { get; internal set; }
    
internal double DoubleBottom { get; internal set; }
    public Margins(int left, int right, int top, int bottom);
    [OnDeserializedAttribute]
private void OnDeserializedMethod(StreamingContext context);
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    internal double get_DoubleLeft();
    internal void set_DoubleLeft(double value);
    internal double get_DoubleRight();
    internal void set_DoubleRight(double value);
    internal double get_DoubleTop();
    internal void set_DoubleTop(double value);
    internal double get_DoubleBottom();
    internal void set_DoubleBottom(double value);
    private void CheckMargin(int margin, string name);
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Margins m1, Margins m2);
    public static bool op_Inequality(Margins m1, Margins m2);
    public virtual string ToString();
}
public class System.Drawing.Printing.MarginsConverter : ExpandableObjectConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
}
public class System.Drawing.Printing.PageSettings : object {
    
internal bool color;
    
internal bool landscape;
    
internal PaperSize paperSize;
    
internal PaperSource paperSource;
    
internal PrinterResolution printerResolution;
    
private Margins margins;
    
private float hardMarginX;
    
private float hardMarginY;
    
private RectangleF printableArea;
    
private PrinterSettings printerSettings;
    
public Rectangle Bounds { get; }
    
public bool Color { get; public set; }
    
public bool Landscape { get; public set; }
    
public Margins Margins { get; public set; }
    
public PaperSize PaperSize { get; public set; }
    
public PaperSource PaperSource { get; public set; }
    
public PrinterResolution PrinterResolution { get; public set; }
    
public PrinterSettings PrinterSettings { get; public set; }
    
public float HardMarginX { get; }
    
public float HardMarginY { get; }
    
public RectangleF PrintableArea { get; }
    public PageSettings(PrinterSettings printerSettings);
    internal PageSettings(PrinterSettings printerSettings, bool color, bool landscape, PaperSize paperSize, PaperSource paperSource, PrinterResolution printerResolution);
    public Rectangle get_Bounds();
    public bool get_Color();
    public void set_Color(bool value);
    public bool get_Landscape();
    public void set_Landscape(bool value);
    public Margins get_Margins();
    public void set_Margins(Margins value);
    public PaperSize get_PaperSize();
    public void set_PaperSize(PaperSize value);
    public PaperSource get_PaperSource();
    public void set_PaperSource(PaperSource value);
    public PrinterResolution get_PrinterResolution();
    public void set_PrinterResolution(PrinterResolution value);
    public PrinterSettings get_PrinterSettings();
    public void set_PrinterSettings(PrinterSettings value);
    public float get_HardMarginX();
    public float get_HardMarginY();
    public RectangleF get_PrintableArea();
    public sealed virtual object Clone();
    [MonoTODOAttribute("PageSettings.CopyToHdevmode")]
public void CopyToHdevmode(IntPtr hdevmode);
    [MonoTODOAttribute("PageSettings.SetHdevmode")]
public void SetHdevmode(IntPtr hdevmode);
    public virtual string ToString();
}
public enum System.Drawing.Printing.PaperKind : Enum {
    
public int value__;
    
public static PaperKind Custom;
    
public static PaperKind Letter;
    
public static PaperKind Legal;
    
public static PaperKind A4;
    
public static PaperKind CSheet;
    
public static PaperKind DSheet;
    
public static PaperKind ESheet;
    
public static PaperKind LetterSmall;
    
public static PaperKind Tabloid;
    
public static PaperKind Ledger;
    
public static PaperKind Statement;
    
public static PaperKind Executive;
    
public static PaperKind A3;
    
public static PaperKind A4Small;
    
public static PaperKind A5;
    
public static PaperKind B4;
    
public static PaperKind B5;
    
public static PaperKind Folio;
    
public static PaperKind Quarto;
    
public static PaperKind Standard10x14;
    
public static PaperKind Standard11x17;
    
public static PaperKind Note;
    
public static PaperKind Number9Envelope;
    
public static PaperKind Number10Envelope;
    
public static PaperKind Number11Envelope;
    
public static PaperKind Number12Envelope;
    
public static PaperKind Number14Envelope;
    
public static PaperKind DLEnvelope;
    
public static PaperKind C5Envelope;
    
public static PaperKind C3Envelope;
    
public static PaperKind C4Envelope;
    
public static PaperKind C6Envelope;
    
public static PaperKind C65Envelope;
    
public static PaperKind B4Envelope;
    
public static PaperKind B5Envelope;
    
public static PaperKind B6Envelope;
    
public static PaperKind ItalyEnvelope;
    
public static PaperKind MonarchEnvelope;
    
public static PaperKind PersonalEnvelope;
    
public static PaperKind USStandardFanfold;
    
public static PaperKind GermanStandardFanfold;
    
public static PaperKind GermanLegalFanfold;
    
public static PaperKind IsoB4;
    
public static PaperKind JapanesePostcard;
    
public static PaperKind Standard9x11;
    
public static PaperKind Standard10x11;
    
public static PaperKind Standard15x11;
    
public static PaperKind InviteEnvelope;
    
public static PaperKind LetterExtra;
    
public static PaperKind LegalExtra;
    
public static PaperKind TabloidExtra;
    
public static PaperKind A4Extra;
    
public static PaperKind LetterTransverse;
    
public static PaperKind A4Transverse;
    
public static PaperKind LetterExtraTransverse;
    
public static PaperKind APlus;
    
public static PaperKind BPlus;
    
public static PaperKind LetterPlus;
    
public static PaperKind A4Plus;
    
public static PaperKind A5Transverse;
    
public static PaperKind B5Transverse;
    
public static PaperKind A3Extra;
    
public static PaperKind A5Extra;
    
public static PaperKind B5Extra;
    
public static PaperKind A2;
    
public static PaperKind A3Transverse;
    
public static PaperKind A3ExtraTransverse;
    
public static PaperKind JapaneseDoublePostcard;
    
public static PaperKind A6;
    
public static PaperKind JapaneseEnvelopeKakuNumber2;
    
public static PaperKind JapaneseEnvelopeKakuNumber3;
    
public static PaperKind JapaneseEnvelopeChouNumber3;
    
public static PaperKind JapaneseEnvelopeChouNumber4;
    
public static PaperKind LetterRotated;
    
public static PaperKind A3Rotated;
    
public static PaperKind A4Rotated;
    
public static PaperKind A5Rotated;
    
public static PaperKind B4JisRotated;
    
public static PaperKind B5JisRotated;
    
public static PaperKind JapanesePostcardRotated;
    
public static PaperKind JapaneseDoublePostcardRotated;
    
public static PaperKind A6Rotated;
    
public static PaperKind JapaneseEnvelopeKakuNumber2Rotated;
    
public static PaperKind JapaneseEnvelopeKakuNumber3Rotated;
    
public static PaperKind JapaneseEnvelopeChouNumber3Rotated;
    
public static PaperKind JapaneseEnvelopeChouNumber4Rotated;
    
public static PaperKind B6Jis;
    
public static PaperKind B6JisRotated;
    
public static PaperKind Standard12x11;
    
public static PaperKind JapaneseEnvelopeYouNumber4;
    
public static PaperKind JapaneseEnvelopeYouNumber4Rotated;
    
public static PaperKind Prc16K;
    
public static PaperKind Prc32K;
    
public static PaperKind Prc32KBig;
    
public static PaperKind PrcEnvelopeNumber1;
    
public static PaperKind PrcEnvelopeNumber2;
    
public static PaperKind PrcEnvelopeNumber3;
    
public static PaperKind PrcEnvelopeNumber4;
    
public static PaperKind PrcEnvelopeNumber5;
    
public static PaperKind PrcEnvelopeNumber6;
    
public static PaperKind PrcEnvelopeNumber7;
    
public static PaperKind PrcEnvelopeNumber8;
    
public static PaperKind PrcEnvelopeNumber9;
    
public static PaperKind PrcEnvelopeNumber10;
    
public static PaperKind Prc16KRotated;
    
public static PaperKind Prc32KRotated;
    
public static PaperKind Prc32KBigRotated;
    
public static PaperKind PrcEnvelopeNumber1Rotated;
    
public static PaperKind PrcEnvelopeNumber2Rotated;
    
public static PaperKind PrcEnvelopeNumber3Rotated;
    
public static PaperKind PrcEnvelopeNumber4Rotated;
    
public static PaperKind PrcEnvelopeNumber5Rotated;
    
public static PaperKind PrcEnvelopeNumber6Rotated;
    
public static PaperKind PrcEnvelopeNumber7Rotated;
    
public static PaperKind PrcEnvelopeNumber8Rotated;
    
public static PaperKind PrcEnvelopeNumber9Rotated;
    
public static PaperKind PrcEnvelopeNumber10Rotated;
}
public class System.Drawing.Printing.PaperSize : object {
    
private PaperKind _kind;
    
private string _name;
    
private int _width;
    
private int _height;
    
private bool _createdByDefaultConstructor;
    
public int Height { get; public set; }
    
public PaperKind Kind { get; }
    
public string PaperName { get; public set; }
    
public int RawKind { get; public set; }
    
public int Width { get; public set; }
    internal PaperSize(PaperKind kind, string name, int width, int height);
    public PaperSize(string name, int width, int height);
    public int get_Height();
    public void set_Height(int value);
    public PaperKind get_Kind();
    public string get_PaperName();
    public void set_PaperName(string value);
    public int get_RawKind();
    public void set_RawKind(int value);
    public int get_Width();
    public void set_Width(int value);
    public virtual string ToString();
}
public class System.Drawing.Printing.PaperSource : object {
    
private string _name;
    
private PaperSourceKind _kind;
    
public PaperSourceKind Kind { get; }
    
public int RawKind { get; public set; }
    
public string SourceName { get; public set; }
    internal PaperSource(PaperSourceKind kind, string name);
    public PaperSourceKind get_Kind();
    public int get_RawKind();
    public void set_RawKind(int value);
    public string get_SourceName();
    public void set_SourceName(string value);
    public virtual string ToString();
}
public enum System.Drawing.Printing.PaperSourceKind : Enum {
    
public int value__;
    
public static PaperSourceKind Upper;
    
public static PaperSourceKind Lower;
    
public static PaperSourceKind Middle;
    
public static PaperSourceKind Manual;
    
public static PaperSourceKind Envelope;
    
public static PaperSourceKind ManualFeed;
    
public static PaperSourceKind AutomaticFeed;
    
public static PaperSourceKind TractorFeed;
    
public static PaperSourceKind SmallFormat;
    
public static PaperSourceKind LargeFormat;
    
public static PaperSourceKind LargeCapacity;
    
public static PaperSourceKind Cassette;
    
public static PaperSourceKind FormSource;
    
public static PaperSourceKind Custom;
}
public class System.Drawing.Printing.PreviewPageInfo : object {
    
private Image _image;
    
private Size _physicalSize;
    
public Image Image { get; }
    
public Size PhysicalSize { get; }
    public PreviewPageInfo(Image image, Size physicalSize);
    public Image get_Image();
    public Size get_PhysicalSize();
}
public class System.Drawing.Printing.PreviewPrintController : PrintController {
    
private bool useantialias;
    
private ArrayList pageInfoList;
    
public bool IsPreview { get; }
    
public bool UseAntiAlias { get; public set; }
    public virtual bool get_IsPreview();
    [MonoTODOAttribute]
public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e);
    [MonoTODOAttribute]
public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e);
    [MonoTODOAttribute]
public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e);
    [MonoTODOAttribute]
public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
    public virtual bool get_UseAntiAlias();
    public virtual void set_UseAntiAlias(bool value);
    public PreviewPageInfo[] GetPreviewPageInfo();
}
public enum System.Drawing.Printing.PrintAction : Enum {
    
public int value__;
    
public static PrintAction PrintToFile;
    
public static PrintAction PrintToPreview;
    
public static PrintAction PrintToPrinter;
}
public abstract class System.Drawing.Printing.PrintController : object {
    
public bool IsPreview { get; }
    public virtual bool get_IsPreview();
    public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e);
    public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e);
    public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e);
    public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
}
[DefaultEventAttribute("PrintPage")]
[DefaultPropertyAttribute("DocumentName")]
[ToolboxItemFilterAttribute("System.Drawing.Printing", "0")]
public class System.Drawing.Printing.PrintDocument : Component {
    
private PageSettings defaultpagesettings;
    
private PrinterSettings printersettings;
    
private PrintController printcontroller;
    
private string documentname;
    
private bool originAtMargins;
    [CompilerGeneratedAttribute]

private PrintEventHandler BeginPrint;
    [CompilerGeneratedAttribute]

private PrintEventHandler EndPrint;
    [CompilerGeneratedAttribute]

private PrintPageEventHandler PrintPage;
    [CompilerGeneratedAttribute]

private QueryPageSettingsEventHandler QueryPageSettings;
    [SRDescriptionAttribute("The settings for the current page.")]
[BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]

public PageSettings DefaultPageSettings { get; public set; }
    [SRDescriptionAttribute("The name of the document.")]
[DefaultValueAttribute("document")]

public string DocumentName { get; public set; }
    [SRDescriptionAttribute("The print controller object.")]
[BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]

public PrintController PrintController { get; public set; }
    [BrowsableAttribute("False")]
[SRDescriptionAttribute("The current settings for the active printer.")]
[DesignerSerializationVisibilityAttribute("0")]

public PrinterSettings PrinterSettings { get; public set; }
    [DefaultValueAttribute("False")]
[SRDescriptionAttribute("Determines if the origin is set at the specified margins.")]

public bool OriginAtMargins { get; public set; }
    public PageSettings get_DefaultPageSettings();
    public void set_DefaultPageSettings(PageSettings value);
    public string get_DocumentName();
    public void set_DocumentName(string value);
    public PrintController get_PrintController();
    public void set_PrintController(PrintController value);
    public PrinterSettings get_PrinterSettings();
    public void set_PrinterSettings(PrinterSettings value);
    public bool get_OriginAtMargins();
    public void set_OriginAtMargins(bool value);
    public void Print();
    public virtual string ToString();
    protected virtual void OnBeginPrint(PrintEventArgs e);
    protected virtual void OnEndPrint(PrintEventArgs e);
    protected virtual void OnPrintPage(PrintPageEventArgs e);
    protected virtual void OnQueryPageSettings(QueryPageSettingsEventArgs e);
    [CompilerGeneratedAttribute]
public void add_BeginPrint(PrintEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginPrint(PrintEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndPrint(PrintEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndPrint(PrintEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PrintPage(PrintPageEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PrintPage(PrintPageEventHandler value);
    [CompilerGeneratedAttribute]
public void add_QueryPageSettings(QueryPageSettingsEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_QueryPageSettings(QueryPageSettingsEventHandler value);
}
public class System.Drawing.Printing.PrinterResolution : object {
    
private int _x;
    
private int _y;
    
private PrinterResolutionKind _kind;
    
public PrinterResolutionKind Kind { get; public set; }
    
public int X { get; public set; }
    
public int Y { get; public set; }
    internal PrinterResolution(PrinterResolutionKind kind, int x, int y);
    public PrinterResolutionKind get_Kind();
    public void set_Kind(PrinterResolutionKind value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public virtual string ToString();
}
public enum System.Drawing.Printing.PrinterResolutionKind : Enum {
    
public int value__;
    
public static PrinterResolutionKind High;
    
public static PrinterResolutionKind Medium;
    
public static PrinterResolutionKind Low;
    
public static PrinterResolutionKind Draft;
    
public static PrinterResolutionKind Custom;
}
public class System.Drawing.Printing.PrinterSettings : object {
    
private string printer_name;
    
private string print_filename;
    
private short copies;
    
private int maximum_page;
    
private int minimum_page;
    
private int from_page;
    
private int to_page;
    
private bool collate;
    
private PrintRange print_range;
    
internal int maximum_copies;
    
internal bool can_duplex;
    
internal bool supports_color;
    
internal int landscape_angle;
    
private bool print_tofile;
    
internal PrinterResolutionCollection printer_resolutions;
    
internal PaperSizeCollection paper_sizes;
    
internal PaperSourceCollection paper_sources;
    
private PageSettings default_pagesettings;
    
private Duplex duplex;
    
internal bool is_plotter;
    
private PrintingServices printing_services;
    
internal NameValueCollection printer_capabilities;
    
public bool CanDuplex { get; }
    
public bool Collate { get; public set; }
    
public short Copies { get; public set; }
    
public PageSettings DefaultPageSettings { get; }
    
public Duplex Duplex { get; public set; }
    
public int FromPage { get; public set; }
    
public static StringCollection InstalledPrinters { get; }
    
public bool IsDefaultPrinter { get; }
    
public bool IsPlotter { get; }
    
public bool IsValid { get; }
    
public int LandscapeAngle { get; }
    
public int MaximumCopies { get; }
    
public int MaximumPage { get; public set; }
    
public int MinimumPage { get; public set; }
    
public PaperSizeCollection PaperSizes { get; }
    
public PaperSourceCollection PaperSources { get; }
    
public string PrintFileName { get; public set; }
    
public string PrinterName { get; public set; }
    
public PrinterResolutionCollection PrinterResolutions { get; }
    
public PrintRange PrintRange { get; public set; }
    
public bool PrintToFile { get; public set; }
    
public bool SupportsColor { get; }
    
public int ToPage { get; public set; }
    
internal NameValueCollection PrinterCapabilities { get; }
    internal PrinterSettings(PrintingServices printing_services);
    private void ResetToDefaults();
    public bool get_CanDuplex();
    public bool get_Collate();
    public void set_Collate(bool value);
    public short get_Copies();
    public void set_Copies(short value);
    public PageSettings get_DefaultPageSettings();
    public Duplex get_Duplex();
    public void set_Duplex(Duplex value);
    public int get_FromPage();
    public void set_FromPage(int value);
    public static StringCollection get_InstalledPrinters();
    public bool get_IsDefaultPrinter();
    public bool get_IsPlotter();
    public bool get_IsValid();
    public int get_LandscapeAngle();
    public int get_MaximumCopies();
    public int get_MaximumPage();
    public void set_MaximumPage(int value);
    public int get_MinimumPage();
    public void set_MinimumPage(int value);
    public PaperSizeCollection get_PaperSizes();
    public PaperSourceCollection get_PaperSources();
    public string get_PrintFileName();
    public void set_PrintFileName(string value);
    public string get_PrinterName();
    public void set_PrinterName(string value);
    public PrinterResolutionCollection get_PrinterResolutions();
    public PrintRange get_PrintRange();
    public void set_PrintRange(PrintRange value);
    public bool get_PrintToFile();
    public void set_PrintToFile(bool value);
    public bool get_SupportsColor();
    public int get_ToPage();
    public void set_ToPage(int value);
    internal NameValueCollection get_PrinterCapabilities();
    public sealed virtual object Clone();
    [MonoTODOAttribute("PrinterSettings.CreateMeasurementGraphics")]
public Graphics CreateMeasurementGraphics();
    [MonoTODOAttribute("PrinterSettings.CreateMeasurementGraphics")]
public Graphics CreateMeasurementGraphics(bool honorOriginAtMargins);
    [MonoTODOAttribute("PrinterSettings.CreateMeasurementGraphics")]
public Graphics CreateMeasurementGraphics(PageSettings pageSettings);
    [MonoTODOAttribute("PrinterSettings.CreateMeasurementGraphics")]
public Graphics CreateMeasurementGraphics(PageSettings pageSettings, bool honorOriginAtMargins);
    [MonoTODOAttribute("PrinterSettings.GetHdevmode")]
public IntPtr GetHdevmode();
    [MonoTODOAttribute("PrinterSettings.GetHdevmode")]
public IntPtr GetHdevmode(PageSettings pageSettings);
    [MonoTODOAttribute("PrinterSettings.GetHdevname")]
public IntPtr GetHdevnames();
    [MonoTODOAttribute("IsDirectPrintingSupported")]
public bool IsDirectPrintingSupported(Image image);
    [MonoTODOAttribute("IsDirectPrintingSupported")]
public bool IsDirectPrintingSupported(ImageFormat imageFormat);
    [MonoTODOAttribute("PrinterSettings.SetHdevmode")]
public void SetHdevmode(IntPtr hdevmode);
    [MonoTODOAttribute("PrinterSettings.SetHdevnames")]
public void SetHdevnames(IntPtr hdevnames);
    public virtual string ToString();
}
public enum System.Drawing.Printing.PrinterUnit : Enum {
    
public int value__;
    
public static PrinterUnit Display;
    
public static PrinterUnit ThousandthsOfAnInch;
    
public static PrinterUnit HundredthsOfAMillimeter;
    
public static PrinterUnit TenthsOfAMillimeter;
}
public class System.Drawing.Printing.PrinterUnitConvert : object {
    public static double Convert(double value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static int Convert(int value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static Point Convert(Point value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static Size Convert(Size value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static Rectangle Convert(Rectangle value, PrinterUnit fromUnit, PrinterUnit toUnit);
    public static Margins Convert(Margins value, PrinterUnit fromUnit, PrinterUnit toUnit);
    private static double UnitsPerDisplay(PrinterUnit unit);
}
public class System.Drawing.Printing.PrintEventArgs : CancelEventArgs {
    
private GraphicsPrinter graphics_context;
    
private PrintAction action;
    
public PrintAction PrintAction { get; }
    
internal GraphicsPrinter GraphicsContext { get; internal set; }
    internal PrintEventArgs(PrintAction action);
    public PrintAction get_PrintAction();
    internal GraphicsPrinter get_GraphicsContext();
    internal void set_GraphicsContext(GraphicsPrinter value);
}
public class System.Drawing.Printing.PrintEventHandler : MulticastDelegate {
    public PrintEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PrintEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PrintEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Printing.PrintingPermission : CodeAccessPermission {
    
private PrintingPermissionLevel printingLevel;
    
public PrintingPermissionLevel Level { get; public set; }
    public PrintingPermission(PermissionState state);
    public PrintingPermission(PrintingPermissionLevel printingLevel);
    public PrintingPermissionLevel get_Level();
    public void set_Level(PrintingPermissionLevel value);
    private static void VerifyPrintingLevel(PrintingPermissionLevel level);
    public sealed virtual bool IsUnrestricted();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
}
[AttributeUsageAttribute("32767")]
public class System.Drawing.Printing.PrintingPermissionAttribute : CodeAccessSecurityAttribute {
    
private PrintingPermissionLevel level;
    
public PrintingPermissionLevel Level { get; public set; }
    public PrintingPermissionAttribute(SecurityAction action);
    public PrintingPermissionLevel get_Level();
    public void set_Level(PrintingPermissionLevel value);
    public virtual IPermission CreatePermission();
}
public enum System.Drawing.Printing.PrintingPermissionLevel : Enum {
    
public int value__;
    
public static PrintingPermissionLevel NoPrinting;
    
public static PrintingPermissionLevel SafePrinting;
    
public static PrintingPermissionLevel DefaultPrinting;
    
public static PrintingPermissionLevel AllPrinting;
}
internal abstract class System.Drawing.Printing.PrintingServices : object {
    
internal string DefaultPrinter { get; }
    internal abstract virtual string get_DefaultPrinter();
    internal abstract virtual bool IsPrinterValid(string printer);
    internal abstract virtual void LoadPrinterSettings(string printer, PrinterSettings settings);
    internal abstract virtual void LoadPrinterResolutions(string printer, PrinterSettings settings);
    internal abstract virtual void GetPrintDialogInfo(string printer, String& port, String& type, String& status, String& comment);
    internal void LoadDefaultResolutions(PrinterResolutionCollection col);
}
internal class System.Drawing.Printing.PrintingServicesUnix : PrintingServices {
    
private static Hashtable doc_info;
    
private static bool cups_installed;
    
private static Hashtable installed_printers;
    
private static string default_printer;
    
private static string tmpfile;
    
internal static StringCollection InstalledPrinters { get; }
    
internal string DefaultPrinter { get; }
    private static PrintingServicesUnix();
    internal static StringCollection get_InstalledPrinters();
    internal virtual string get_DefaultPrinter();
    private static void CheckCupsInstalled();
    private IntPtr OpenPrinter(string printer);
    private void ClosePrinter(IntPtr& handle);
    private static int OpenDests(IntPtr& ptr);
    private static void CloseDests(IntPtr& ptr, int count);
    internal virtual bool IsPrinterValid(string printer);
    internal virtual void LoadPrinterSettings(string printer, PrinterSettings settings);
    private static void LoadPrinterOptions(IntPtr options, int numOptions, IntPtr ppd, NameValueCollection list, NameValueCollection paper_names, String& defsize, NameValueCollection paper_sources, String& defsource);
    private static NameValueCollection LoadPrinterOptions(IntPtr options, int numOptions);
    private static void LoadOptionList(IntPtr ppd, string option_name, NameValueCollection list, String& defoption);
    internal virtual void LoadPrinterResolutions(string printer, PrinterSettings settings);
    private PrinterResolution ParseResolution(string resolution);
    private PaperSize LoadPrinterPaperSizes(IntPtr ppd_handle, PrinterSettings settings, string def_size, NameValueCollection paper_names);
    private PaperSource LoadPrinterPaperSources(PrinterSettings settings, string def_source, NameValueCollection paper_sources);
    private void LoadPrinterResolutionsAndDefault(string printer, PrinterSettings settings, IntPtr ppd_handle);
    private static void LoadPrinters();
    internal virtual void GetPrintDialogInfo(string printer, String& port, String& type, String& status, String& comment);
    private PaperKind GetPaperKind(int width, int height);
    internal static int GetCupsOptions(PrinterSettings printer_settings, PageSettings page_settings, IntPtr& options);
    internal static bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file);
    internal static bool EndDoc(GraphicsPrinter gr);
    internal static bool StartPage(GraphicsPrinter gr);
    internal static bool EndPage(GraphicsPrinter gr);
    internal static IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings default_page_settings);
    private static int cupsGetDests(IntPtr& dests);
    private static void cupsFreeDests(int num_dests, IntPtr dests);
    private static IntPtr cupsTempFd(StringBuilder sb, int len);
    private static IntPtr cupsGetDefault();
    private static int cupsPrintFile(string printer, string filename, string title, int num_options, IntPtr options);
    private static IntPtr cupsGetPPD(string printer);
    private static IntPtr ppdOpenFile(string filename);
    private static IntPtr ppdFindOption(IntPtr ppd_file, string keyword);
    private static void ppdClose(IntPtr ppd);
    private static int cupsParseOptions(string arg, int number_of_options, IntPtr& options);
    private static void cupsFreeOptions(int number_options, IntPtr options);
    private static int GdipGetPostScriptGraphicsContext(string filename, int with, int height, double dpix, double dpiy, IntPtr& graphics);
    private static int GdipGetPostScriptSavePage(IntPtr graphics);
}
internal class System.Drawing.Printing.PrintingServicesWin32 : PrintingServices {
    
private bool is_printer_valid;
    
internal string DefaultPrinter { get; }
    
internal static StringCollection InstalledPrinters { get; }
    internal virtual bool IsPrinterValid(string printer);
    internal virtual void LoadPrinterSettings(string printer, PrinterSettings settings);
    internal virtual void LoadPrinterResolutions(string printer, PrinterSettings settings);
    private void LoadPrinterPaperSizes(string printer, PrinterSettings settings);
    internal static bool StartDoc(GraphicsPrinter gr, string doc_name, string output_file);
    private void LoadPrinterPaperSources(string printer, PrinterSettings settings);
    internal static bool StartPage(GraphicsPrinter gr);
    internal static bool EndPage(GraphicsPrinter gr);
    internal static bool EndDoc(GraphicsPrinter gr);
    internal static IntPtr CreateGraphicsContext(PrinterSettings settings, PageSettings default_page_settings);
    internal virtual string get_DefaultPrinter();
    internal static StringCollection get_InstalledPrinters();
    internal virtual void GetPrintDialogInfo(string printer, String& port, String& type, String& status, String& comment);
    private string GetPrinterStatusMsg(UInt32 status);
    private static int Win32OpenPrinter(string pPrinterName, IntPtr& phPrinter, IntPtr pDefault);
    private static int Win32GetPrinter(IntPtr hPrinter, int level, IntPtr dwBuf, int size, Int32& dwNeeded);
    private static int Win32ClosePrinter(IntPtr hPrinter);
    private static int Win32DeviceCapabilities(string device, string port, DCCapabilities cap, IntPtr outputBuffer, IntPtr deviceMode);
    private static int Win32EnumPrinters(int Flags, string Name, UInt32 Level, IntPtr pPrinterEnum, UInt32 cbBuf, UInt32& pcbNeeded, UInt32& pcReturned);
    private static int Win32GetDefaultPrinter(StringBuilder buffer, Int32& bufferSize);
    private static int Win32DocumentProperties(IntPtr hwnd, IntPtr hPrinter, string pDeviceName, IntPtr pDevModeOutput, IntPtr pDevModeInput, int fMode);
    private static IntPtr Win32CreateDC(string lpszDriver, string lpszDevice, string lpszOutput, IntPtr lpInitData);
    private static IntPtr Win32CreateIC(string lpszDriver, string lpszDevice, string lpszOutput, IntPtr lpInitData);
    private static int Win32StartDoc(IntPtr hdc, DOCINFO& lpdi);
    private static int Win32StartPage(IntPtr hDC);
    private static int Win32EndPage(IntPtr hdc);
    private static int Win32EndDoc(IntPtr hdc);
    public static IntPtr Win32DeleteDC(IntPtr hDc);
    public static int Win32GetDeviceCaps(IntPtr hDc, int index);
}
public class System.Drawing.Printing.PrintPageEventArgs : EventArgs {
    
private bool cancel;
    
private Graphics graphics;
    
private bool hasmorePages;
    
private Rectangle marginBounds;
    
private Rectangle pageBounds;
    
private PageSettings pageSettings;
    
private GraphicsPrinter graphics_context;
    
public bool Cancel { get; public set; }
    
public Graphics Graphics { get; }
    
public bool HasMorePages { get; public set; }
    
public Rectangle MarginBounds { get; }
    
public Rectangle PageBounds { get; }
    
public PageSettings PageSettings { get; }
    
internal GraphicsPrinter GraphicsContext { get; internal set; }
    public PrintPageEventArgs(Graphics graphics, Rectangle marginBounds, Rectangle pageBounds, PageSettings pageSettings);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Graphics get_Graphics();
    public bool get_HasMorePages();
    public void set_HasMorePages(bool value);
    public Rectangle get_MarginBounds();
    public Rectangle get_PageBounds();
    public PageSettings get_PageSettings();
    internal void SetGraphics(Graphics g);
    internal GraphicsPrinter get_GraphicsContext();
    internal void set_GraphicsContext(GraphicsPrinter value);
}
public class System.Drawing.Printing.PrintPageEventHandler : MulticastDelegate {
    public PrintPageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PrintPageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PrintPageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Drawing.Printing.PrintRange : Enum {
    
public int value__;
    
public static PrintRange AllPages;
    
public static PrintRange SomePages;
    
public static PrintRange Selection;
    
public static PrintRange CurrentPage;
}
public class System.Drawing.Printing.QueryPageSettingsEventArgs : PrintEventArgs {
    
private PageSettings _pageSettings;
    
internal bool PageSettingsChanged;
    
public PageSettings PageSettings { get; public set; }
    public QueryPageSettingsEventArgs(PageSettings pageSettings);
    public PageSettings get_PageSettings();
    public void set_PageSettings(PageSettings value);
}
public class System.Drawing.Printing.QueryPageSettingsEventHandler : MulticastDelegate {
    public QueryPageSettingsEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryPageSettingsEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryPageSettingsEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Drawing.Printing.StandardPrintController : PrintController {
    public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e);
    public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e);
    public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e);
    public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
}
internal class System.Drawing.Printing.SysPrn : object {
    
private static GlobalPrintingServices global_printing_services;
    
private static bool is_unix;
    
internal static GlobalPrintingServices GlobalService { get; }
    private static SysPrn();
    internal static PrintingServices CreatePrintingService();
    internal static GlobalPrintingServices get_GlobalService();
    internal static void GetPrintDialogInfo(string printer, String& port, String& type, String& status, String& comment);
}
internal class System.Drawing.QDRect : ValueType {
    
public short top;
    
public short left;
    
public short bottom;
    
public short right;
}
internal class System.Drawing.Rect : ValueType {
    
public CGPoint origin;
    
public CGSize size;
    public Rect(float x, float y, float width, float height);
}
[TypeConverterAttribute("System.Drawing.RectangleConverter")]
[ComVisibleAttribute("True")]
public class System.Drawing.Rectangle : ValueType {
    
private int x;
    
private int y;
    
private int width;
    
private int height;
    
public static Rectangle Empty;
    [BrowsableAttribute("False")]

public int Bottom { get; }
    
public int Height { get; public set; }
    [BrowsableAttribute("False")]

public bool IsEmpty { get; }
    [BrowsableAttribute("False")]

public int Left { get; }
    [BrowsableAttribute("False")]

public Point Location { get; public set; }
    [BrowsableAttribute("False")]

public int Right { get; }
    [BrowsableAttribute("False")]

public Size Size { get; public set; }
    [BrowsableAttribute("False")]

public int Top { get; }
    
public int Width { get; public set; }
    
public int X { get; public set; }
    
public int Y { get; public set; }
    public Rectangle(Point location, Size size);
    public Rectangle(int x, int y, int width, int height);
    public static Rectangle Ceiling(RectangleF value);
    public static Rectangle FromLTRB(int left, int top, int right, int bottom);
    public static Rectangle Inflate(Rectangle rect, int x, int y);
    public void Inflate(int width, int height);
    public void Inflate(Size size);
    public static Rectangle Intersect(Rectangle a, Rectangle b);
    public void Intersect(Rectangle rect);
    public static Rectangle Round(RectangleF value);
    public static Rectangle Truncate(RectangleF value);
    public static Rectangle Union(Rectangle a, Rectangle b);
    public static bool op_Equality(Rectangle left, Rectangle right);
    public static bool op_Inequality(Rectangle left, Rectangle right);
    public int get_Bottom();
    public int get_Height();
    public void set_Height(int value);
    public bool get_IsEmpty();
    public int get_Left();
    public Point get_Location();
    public void set_Location(Point value);
    public int get_Right();
    public Size get_Size();
    public void set_Size(Size value);
    public int get_Top();
    public int get_Width();
    public void set_Width(int value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public bool Contains(int x, int y);
    public bool Contains(Point pt);
    public bool Contains(Rectangle rect);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IntersectsWith(Rectangle rect);
    private bool IntersectsWithInclusive(Rectangle r);
    public void Offset(int x, int y);
    public void Offset(Point pos);
    public virtual string ToString();
}
public class System.Drawing.RectangleConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.RectangleF : ValueType {
    
private float x;
    
private float y;
    
private float width;
    
private float height;
    
public static RectangleF Empty;
    [BrowsableAttribute("False")]

public float Bottom { get; }
    
public float Height { get; public set; }
    [BrowsableAttribute("False")]

public bool IsEmpty { get; }
    [BrowsableAttribute("False")]

public float Left { get; }
    [BrowsableAttribute("False")]

public PointF Location { get; public set; }
    [BrowsableAttribute("False")]

public float Right { get; }
    [BrowsableAttribute("False")]

public SizeF Size { get; public set; }
    [BrowsableAttribute("False")]

public float Top { get; }
    
public float Width { get; public set; }
    
public float X { get; public set; }
    
public float Y { get; public set; }
    public RectangleF(PointF location, SizeF size);
    public RectangleF(float x, float y, float width, float height);
    public static RectangleF FromLTRB(float left, float top, float right, float bottom);
    public static RectangleF Inflate(RectangleF rect, float x, float y);
    public void Inflate(float x, float y);
    public void Inflate(SizeF size);
    public static RectangleF Intersect(RectangleF a, RectangleF b);
    public void Intersect(RectangleF rect);
    public static RectangleF Union(RectangleF a, RectangleF b);
    public static bool op_Equality(RectangleF left, RectangleF right);
    public static bool op_Inequality(RectangleF left, RectangleF right);
    public static RectangleF op_Implicit(Rectangle r);
    public float get_Bottom();
    public float get_Height();
    public void set_Height(float value);
    public bool get_IsEmpty();
    public float get_Left();
    public PointF get_Location();
    public void set_Location(PointF value);
    public float get_Right();
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public float get_Top();
    public float get_Width();
    public void set_Width(float value);
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public bool Contains(float x, float y);
    public bool Contains(PointF pt);
    public bool Contains(RectangleF rect);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IntersectsWith(RectangleF rect);
    private bool IntersectsWithInclusive(RectangleF r);
    public void Offset(float x, float y);
    public void Offset(PointF pos);
    public virtual string ToString();
}
public class System.Drawing.Region : MarshalByRefObject {
    
private IntPtr nativeRegion;
    
internal IntPtr NativeObject { get; internal set; }
    internal Region(IntPtr native);
    public Region(GraphicsPath path);
    public Region(Rectangle rect);
    public Region(RectangleF rect);
    public Region(RegionData rgnData);
    public void Union(GraphicsPath path);
    public void Union(Rectangle rect);
    public void Union(RectangleF rect);
    public void Union(Region region);
    public void Intersect(GraphicsPath path);
    public void Intersect(Rectangle rect);
    public void Intersect(RectangleF rect);
    public void Intersect(Region region);
    public void Complement(GraphicsPath path);
    public void Complement(Rectangle rect);
    public void Complement(RectangleF rect);
    public void Complement(Region region);
    public void Exclude(GraphicsPath path);
    public void Exclude(Rectangle rect);
    public void Exclude(RectangleF rect);
    public void Exclude(Region region);
    public void Xor(GraphicsPath path);
    public void Xor(Rectangle rect);
    public void Xor(RectangleF rect);
    public void Xor(Region region);
    public RectangleF GetBounds(Graphics g);
    public void Translate(int dx, int dy);
    public void Translate(float dx, float dy);
    public bool IsVisible(int x, int y, Graphics g);
    public bool IsVisible(int x, int y, int width, int height);
    public bool IsVisible(int x, int y, int width, int height, Graphics g);
    public bool IsVisible(Point point);
    public bool IsVisible(PointF point);
    public bool IsVisible(Point point, Graphics g);
    public bool IsVisible(PointF point, Graphics g);
    public bool IsVisible(Rectangle rect);
    public bool IsVisible(RectangleF rect);
    public bool IsVisible(Rectangle rect, Graphics g);
    public bool IsVisible(RectangleF rect, Graphics g);
    public bool IsVisible(float x, float y);
    public bool IsVisible(float x, float y, Graphics g);
    public bool IsVisible(float x, float y, float width, float height);
    public bool IsVisible(float x, float y, float width, float height, Graphics g);
    public bool IsEmpty(Graphics g);
    public bool IsInfinite(Graphics g);
    public void MakeEmpty();
    public void MakeInfinite();
    public bool Equals(Region region, Graphics g);
    public static Region FromHrgn(IntPtr hrgn);
    public IntPtr GetHrgn(Graphics g);
    public RegionData GetRegionData();
    public RectangleF[] GetRegionScans(Matrix matrix);
    public void Transform(Matrix matrix);
    public Region Clone();
    public sealed virtual void Dispose();
    private void DisposeHandle();
    protected virtual override void Finalize();
    internal IntPtr get_NativeObject();
    internal void set_NativeObject(IntPtr value);
    public void ReleaseHrgn(IntPtr regionHandle);
}
public enum System.Drawing.RotateFlipType : Enum {
    
public int value__;
    
public static RotateFlipType RotateNoneFlipNone;
    
public static RotateFlipType Rotate90FlipNone;
    
public static RotateFlipType Rotate180FlipNone;
    
public static RotateFlipType Rotate270FlipNone;
    
public static RotateFlipType RotateNoneFlipX;
    
public static RotateFlipType Rotate90FlipX;
    
public static RotateFlipType Rotate180FlipX;
    
public static RotateFlipType Rotate270FlipX;
    
public static RotateFlipType RotateNoneFlipY;
    
public static RotateFlipType Rotate90FlipY;
    
public static RotateFlipType Rotate180FlipY;
    
public static RotateFlipType Rotate270FlipY;
    
public static RotateFlipType RotateNoneFlipXY;
    
public static RotateFlipType Rotate90FlipXY;
    
public static RotateFlipType Rotate180FlipXY;
    
public static RotateFlipType Rotate270FlipXY;
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Drawing.SafeNativeMethods : object {
    
public static int ERROR_CANCELLED;
    
public static int E_UNEXPECTED;
    
public static int E_NOTIMPL;
    
public static int E_ABORT;
    
public static int E_FAIL;
    
public static int E_ACCESSDENIED;
    
public static int GMEM_MOVEABLE;
    
public static int GMEM_ZEROINIT;
    
public static int DM_IN_BUFFER;
    
public static int DM_OUT_BUFFER;
    
public static int DT_PLOTTER;
    
public static int DT_RASPRINTER;
    
public static int TECHNOLOGY;
    
public static int DC_PAPERS;
    
public static int DC_PAPERSIZE;
    
public static int DC_BINS;
    
public static int DC_DUPLEX;
    
public static int DC_BINNAMES;
    
public static int DC_ENUMRESOLUTIONS;
    
public static int DC_PAPERNAMES;
    
public static int DC_ORIENTATION;
    
public static int DC_COPIES;
    
public static int PD_ALLPAGES;
    
public static int PD_SELECTION;
    
public static int PD_PAGENUMS;
    
public static int PD_CURRENTPAGE;
    
public static int PD_RETURNDEFAULT;
    
public static int DI_NORMAL;
    
public static int IMAGE_ICON;
    
public static int IDI_APPLICATION;
    
public static int IDI_HAND;
    
public static int IDI_QUESTION;
    
public static int IDI_EXCLAMATION;
    
public static int IDI_ASTERISK;
    
public static int IDI_WINLOGO;
    
public static int IDI_WARNING;
    
public static int IDI_ERROR;
    
public static int IDI_INFORMATION;
    
public static int SRCCOPY;
    
public static int PLANES;
    
public static int BITSPIXEL;
    
public static int LOGPIXELSX;
    
public static int LOGPIXELSY;
    
public static int PHYSICALWIDTH;
    
public static int PHYSICALHEIGHT;
    
public static int PHYSICALOFFSETX;
    
public static int PHYSICALOFFSETY;
    
public static int VERTRES;
    
public static int HORZRES;
    
public static int DM_ORIENTATION;
    
public static int DM_PAPERSIZE;
    
public static int DM_PAPERLENGTH;
    
public static int DM_PAPERWIDTH;
    
public static int DM_COPIES;
    
public static int DM_DEFAULTSOURCE;
    
public static int DM_PRINTQUALITY;
    
public static int DM_COLOR;
    
public static int DM_DUPLEX;
    
public static int DM_YRESOLUTION;
    
public static int DM_COLLATE;
    
public static int DMORIENT_PORTRAIT;
    
public static int DMORIENT_LANDSCAPE;
    
public static int DMPAPER_LETTER;
    
public static int DMPAPER_LETTERSMALL;
    
public static int DMPAPER_TABLOID;
    
public static int DMPAPER_LEDGER;
    
public static int DMPAPER_LEGAL;
    
public static int DMPAPER_STATEMENT;
    
public static int DMPAPER_EXECUTIVE;
    
public static int DMPAPER_A3;
    
public static int DMPAPER_A4;
    
public static int DMPAPER_A4SMALL;
    
public static int DMPAPER_A5;
    
public static int DMPAPER_B4;
    
public static int DMPAPER_B5;
    
public static int DMPAPER_FOLIO;
    
public static int DMPAPER_QUARTO;
    
public static int DMPAPER_10X14;
    
public static int DMPAPER_11X17;
    
public static int DMPAPER_NOTE;
    
public static int DMPAPER_ENV_9;
    
public static int DMPAPER_ENV_10;
    
public static int DMPAPER_ENV_11;
    
public static int DMPAPER_ENV_12;
    
public static int DMPAPER_ENV_14;
    
public static int DMPAPER_CSHEET;
    
public static int DMPAPER_DSHEET;
    
public static int DMPAPER_ESHEET;
    
public static int DMPAPER_ENV_DL;
    
public static int DMPAPER_ENV_C5;
    
public static int DMPAPER_ENV_C3;
    
public static int DMPAPER_ENV_C4;
    
public static int DMPAPER_ENV_C6;
    
public static int DMPAPER_ENV_C65;
    
public static int DMPAPER_ENV_B4;
    
public static int DMPAPER_ENV_B5;
    
public static int DMPAPER_ENV_B6;
    
public static int DMPAPER_ENV_ITALY;
    
public static int DMPAPER_ENV_MONARCH;
    
public static int DMPAPER_ENV_PERSONAL;
    
public static int DMPAPER_FANFOLD_US;
    
public static int DMPAPER_FANFOLD_STD_GERMAN;
    
public static int DMPAPER_FANFOLD_LGL_GERMAN;
    
public static int DMPAPER_ISO_B4;
    
public static int DMPAPER_JAPANESE_POSTCARD;
    
public static int DMPAPER_9X11;
    
public static int DMPAPER_10X11;
    
public static int DMPAPER_15X11;
    
public static int DMPAPER_ENV_INVITE;
    
public static int DMPAPER_RESERVED_48;
    
public static int DMPAPER_RESERVED_49;
    
public static int DMPAPER_LETTER_EXTRA;
    
public static int DMPAPER_LEGAL_EXTRA;
    
public static int DMPAPER_TABLOID_EXTRA;
    
public static int DMPAPER_A4_EXTRA;
    
public static int DMPAPER_LETTER_TRANSVERSE;
    
public static int DMPAPER_A4_TRANSVERSE;
    
public static int DMPAPER_LETTER_EXTRA_TRANSVERSE;
    
public static int DMPAPER_A_PLUS;
    
public static int DMPAPER_B_PLUS;
    
public static int DMPAPER_LETTER_PLUS;
    
public static int DMPAPER_A4_PLUS;
    
public static int DMPAPER_A5_TRANSVERSE;
    
public static int DMPAPER_B5_TRANSVERSE;
    
public static int DMPAPER_A3_EXTRA;
    
public static int DMPAPER_A5_EXTRA;
    
public static int DMPAPER_B5_EXTRA;
    
public static int DMPAPER_A2;
    
public static int DMPAPER_A3_TRANSVERSE;
    
public static int DMPAPER_A3_EXTRA_TRANSVERSE;
    
public static int DMPAPER_DBL_JAPANESE_POSTCARD;
    
public static int DMPAPER_A6;
    
public static int DMPAPER_JENV_KAKU2;
    
public static int DMPAPER_JENV_KAKU3;
    
public static int DMPAPER_JENV_CHOU3;
    
public static int DMPAPER_JENV_CHOU4;
    
public static int DMPAPER_LETTER_ROTATED;
    
public static int DMPAPER_A3_ROTATED;
    
public static int DMPAPER_A4_ROTATED;
    
public static int DMPAPER_A5_ROTATED;
    
public static int DMPAPER_B4_JIS_ROTATED;
    
public static int DMPAPER_B5_JIS_ROTATED;
    
public static int DMPAPER_JAPANESE_POSTCARD_ROTATED;
    
public static int DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED;
    
public static int DMPAPER_A6_ROTATED;
    
public static int DMPAPER_JENV_KAKU2_ROTATED;
    
public static int DMPAPER_JENV_KAKU3_ROTATED;
    
public static int DMPAPER_JENV_CHOU3_ROTATED;
    
public static int DMPAPER_JENV_CHOU4_ROTATED;
    
public static int DMPAPER_B6_JIS;
    
public static int DMPAPER_B6_JIS_ROTATED;
    
public static int DMPAPER_12X11;
    
public static int DMPAPER_JENV_YOU4;
    
public static int DMPAPER_JENV_YOU4_ROTATED;
    
public static int DMPAPER_P16K;
    
public static int DMPAPER_P32K;
    
public static int DMPAPER_P32KBIG;
    
public static int DMPAPER_PENV_1;
    
public static int DMPAPER_PENV_2;
    
public static int DMPAPER_PENV_3;
    
public static int DMPAPER_PENV_4;
    
public static int DMPAPER_PENV_5;
    
public static int DMPAPER_PENV_6;
    
public static int DMPAPER_PENV_7;
    
public static int DMPAPER_PENV_8;
    
public static int DMPAPER_PENV_9;
    
public static int DMPAPER_PENV_10;
    
public static int DMPAPER_P16K_ROTATED;
    
public static int DMPAPER_P32K_ROTATED;
    
public static int DMPAPER_P32KBIG_ROTATED;
    
public static int DMPAPER_PENV_1_ROTATED;
    
public static int DMPAPER_PENV_2_ROTATED;
    
public static int DMPAPER_PENV_3_ROTATED;
    
public static int DMPAPER_PENV_4_ROTATED;
    
public static int DMPAPER_PENV_5_ROTATED;
    
public static int DMPAPER_PENV_6_ROTATED;
    
public static int DMPAPER_PENV_7_ROTATED;
    
public static int DMPAPER_PENV_8_ROTATED;
    
public static int DMPAPER_PENV_9_ROTATED;
    
public static int DMPAPER_PENV_10_ROTATED;
    
public static int DMPAPER_LAST;
    
public static int DMBIN_UPPER;
    
public static int DMBIN_LOWER;
    
public static int DMBIN_MIDDLE;
    
public static int DMBIN_MANUAL;
    
public static int DMBIN_ENVELOPE;
    
public static int DMBIN_ENVMANUAL;
    
public static int DMBIN_AUTO;
    
public static int DMBIN_TRACTOR;
    
public static int DMBIN_SMALLFMT;
    
public static int DMBIN_LARGEFMT;
    
public static int DMBIN_LARGECAPACITY;
    
public static int DMBIN_CASSETTE;
    
public static int DMBIN_FORMSOURCE;
    
public static int DMBIN_LAST;
    
public static int DMBIN_USER;
    
public static int DMRES_DRAFT;
    
public static int DMRES_LOW;
    
public static int DMRES_MEDIUM;
    
public static int DMRES_HIGH;
    
public static int DMCOLOR_MONOCHROME;
    
public static int DMCOLOR_COLOR;
    
public static int DMDUP_SIMPLEX;
    
public static int DMDUP_VERTICAL;
    
public static int DMDUP_HORIZONTAL;
    
public static int DMCOLLATE_FALSE;
    
public static int DMCOLLATE_TRUE;
    
public static int PRINTER_ENUM_LOCAL;
    
public static int PRINTER_ENUM_CONNECTIONS;
    
public static int SRCPAINT;
    
public static int SRCAND;
    
public static int SRCINVERT;
    
public static int SRCERASE;
    
public static int NOTSRCCOPY;
    
public static int NOTSRCERASE;
    
public static int MERGECOPY;
    
public static int MERGEPAINT;
    
public static int PATCOPY;
    
public static int PATPAINT;
    
public static int PATINVERT;
    
public static int DSTINVERT;
    
public static int BLACKNESS;
    
public static int WHITENESS;
    
public static int CAPTUREBLT;
    
public static int SM_CXICON;
    
public static int SM_CYICON;
    
public static int DEFAULT_CHARSET;
    
public static int NOMIRRORBITMAP;
    
public static int QUERYESCSUPPORT;
    
public static int CHECKJPEGFORMAT;
    
public static int CHECKPNGFORMAT;
    
public static int ERROR_ACCESS_DENIED;
    
public static int ERROR_INVALID_PARAMETER;
    
public static int ERROR_PROC_NOT_FOUND;
    public static IntPtr IntCreateCompatibleBitmap(HandleRef hDC, int width, int height);
    public static IntPtr CreateCompatibleBitmap(HandleRef hDC, int width, int height);
    public static int BitBlt(HandleRef hDC, int x, int y, int nWidth, int nHeight, HandleRef hSrcDC, int xSrc, int ySrc, int dwRop);
    public static int GetDIBits(HandleRef hdc, HandleRef hbm, int arg1, int arg2, IntPtr arg3, BITMAPINFO_FLAT& bmi, int arg5);
    public static UInt32 GetPaletteEntries(HandleRef hpal, int iStartIndex, int nEntries, Byte[] lppe);
    public static IntPtr IntCreateDIBSection(HandleRef hdc, BITMAPINFO_FLAT& bmi, int iUsage, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    public static IntPtr CreateDIBSection(HandleRef hdc, BITMAPINFO_FLAT& bmi, int iUsage, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    public static IntPtr GlobalFree(HandleRef handle);
    public static int StartDoc(HandleRef hDC, DOCINFO lpDocInfo);
    public static int StartPage(HandleRef hDC);
    public static int EndPage(HandleRef hDC);
    public static int AbortDoc(HandleRef hDC);
    public static int EndDoc(HandleRef hDC);
    public static bool PrintDlg(PRINTDLG lppd);
    public static bool PrintDlg(PRINTDLGX86 lppd);
    public static int DeviceCapabilities(string pDevice, string pPort, short fwCapabilities, IntPtr pOutput, IntPtr pDevMode);
    public static int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr pDevModeOutput, HandleRef pDevModeInput, int fMode);
    public static int DocumentProperties(HandleRef hwnd, HandleRef hPrinter, string pDeviceName, IntPtr pDevModeOutput, IntPtr pDevModeInput, int fMode);
    public static int EnumPrinters(int flags, string name, int level, IntPtr pPrinterEnum, int cbBuf, Int32& pcbNeeded, Int32& pcReturned);
    public static IntPtr GlobalLock(HandleRef handle);
    public static IntPtr ResetDC(HandleRef hDC, HandleRef lpDevMode);
    public static bool GlobalUnlock(HandleRef handle);
    private static IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);
    public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2);
    public static int GetClipRgn(HandleRef hDC, HandleRef hRgn);
    public static int SelectClipRgn(HandleRef hDC, HandleRef hRgn);
    public static int AddFontResourceEx(string lpszFilename, int fl, IntPtr pdv);
    public static int AddFontFile(string fileName);
    internal static IntPtr SaveClipRgn(IntPtr hDC);
    internal static void RestoreClipRgn(IntPtr hDC, IntPtr hRgn);
    public static int ExtEscape(HandleRef hDC, int nEscape, int cbInput, Int32& inData, int cbOutput, Int32& outData);
    public static int ExtEscape(HandleRef hDC, int nEscape, int cbInput, Byte[] inData, int cbOutput, Int32& outData);
    public static int IntersectClipRect(HandleRef hDC, int x1, int y1, int x2, int y2);
    public static IntPtr IntGlobalAlloc(int uFlags, UIntPtr dwBytes);
    public static IntPtr GlobalAlloc(int uFlags, UInt32 dwBytes);
    internal static void ZeroMemory(Byte* ptr, ulong length);
    internal static int IntDeleteObject(HandleRef hObject);
    public static int DeleteObject(HandleRef hObject);
    public static IntPtr SelectObject(HandleRef hdc, HandleRef obj);
    private static IntPtr IntCreateIconFromResourceEx(Byte* pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags);
    public static IntPtr CreateIconFromResourceEx(Byte* pbIconBits, int cbIconBits, bool fIcon, int dwVersion, int csDesired, int cyDesired, int flags);
    public static IntPtr IntExtractAssociatedIcon(HandleRef hInst, StringBuilder iconPath, Int32& index);
    public static IntPtr ExtractAssociatedIcon(HandleRef hInst, StringBuilder iconPath, Int32& index);
    private static IntPtr IntLoadIcon(HandleRef hInst, IntPtr iconId);
    public static IntPtr LoadIcon(HandleRef hInst, int iconId);
    private static bool IntDestroyIcon(HandleRef hIcon);
    public static bool DestroyIcon(HandleRef hIcon);
    private static IntPtr IntCopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags);
    public static IntPtr CopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags);
    public static int GetObject(HandleRef hObject, int nSize, BITMAP bm);
    public static int GetObject(HandleRef hObject, int nSize, LOGFONT lf);
    public static int GetObject(HandleRef hObject, LOGFONT lp);
    public static bool GetIconInfo(HandleRef hIcon, ICONINFO info);
    public static bool DrawIconEx(HandleRef hDC, int x, int y, HandleRef hIcon, int width, int height, int iStepIfAniCursor, HandleRef hBrushFlickerFree, int diFlags);
    public static IPicture OleCreatePictureIndirect(PICTDESC pictdesc, Guid& refiid, bool fOwn);
}
[ComVisibleAttribute("True")]
[TypeConverterAttribute("System.Drawing.SizeConverter")]
public class System.Drawing.Size : ValueType {
    
private int width;
    
private int height;
    
public static Size Empty;
    [BrowsableAttribute("False")]

public bool IsEmpty { get; }
    
public int Width { get; public set; }
    
public int Height { get; public set; }
    public Size(Point pt);
    public Size(int width, int height);
    public static Size Ceiling(SizeF value);
    public static Size Round(SizeF value);
    public static Size Truncate(SizeF value);
    public static Size op_Addition(Size sz1, Size sz2);
    public static bool op_Equality(Size sz1, Size sz2);
    public static bool op_Inequality(Size sz1, Size sz2);
    public static Size op_Subtraction(Size sz1, Size sz2);
    public static Point op_Explicit(Size size);
    public static SizeF op_Implicit(Size p);
    public bool get_IsEmpty();
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static Size Add(Size sz1, Size sz2);
    public static Size Subtract(Size sz1, Size sz2);
}
public class System.Drawing.SizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
[ComVisibleAttribute("True")]
[TypeConverterAttribute("System.Drawing.SizeFConverter")]
public class System.Drawing.SizeF : ValueType {
    
private float width;
    
private float height;
    
public static SizeF Empty;
    [BrowsableAttribute("False")]

public bool IsEmpty { get; }
    
public float Width { get; public set; }
    
public float Height { get; public set; }
    public SizeF(PointF pt);
    public SizeF(SizeF size);
    public SizeF(float width, float height);
    public static SizeF op_Addition(SizeF sz1, SizeF sz2);
    public static bool op_Equality(SizeF sz1, SizeF sz2);
    public static bool op_Inequality(SizeF sz1, SizeF sz2);
    public static SizeF op_Subtraction(SizeF sz1, SizeF sz2);
    public static PointF op_Explicit(SizeF size);
    public bool get_IsEmpty();
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public PointF ToPointF();
    public Size ToSize();
    public virtual string ToString();
    public static SizeF Add(SizeF sz1, SizeF sz2);
    public static SizeF Subtract(SizeF sz1, SizeF sz2);
}
public class System.Drawing.SizeFConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.Drawing.SolidBrush : Brush {
    
private Color _color;
    
private bool _immutable;
    
public Color Color { get; public set; }
    public SolidBrush(Color color);
    internal SolidBrush(Color color, bool immutable);
    internal SolidBrush(IntPtr nativeBrush);
    public virtual object Clone();
    protected virtual void Dispose(bool disposing);
    public Color get_Color();
    public void set_Color(Color value);
    private void InternalSetColor(Color value);
}
[AttributeUsageAttribute("32767")]
internal class System.Drawing.SRDescriptionAttribute : DescriptionAttribute {
    
private bool isReplaced;
    
public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal enum System.Drawing.Status : Enum {
    
public int value__;
    
public static Status Ok;
    
public static Status GenericError;
    
public static Status InvalidParameter;
    
public static Status OutOfMemory;
    
public static Status ObjectBusy;
    
public static Status InsufficientBuffer;
    
public static Status NotImplemented;
    
public static Status Win32Error;
    
public static Status WrongState;
    
public static Status Aborted;
    
public static Status FileNotFound;
    
public static Status ValueOverflow;
    
public static Status AccessDenied;
    
public static Status UnknownImageFormat;
    
public static Status FontFamilyNotFound;
    
public static Status FontStyleNotFound;
    
public static Status NotTrueTypeFont;
    
public static Status UnsupportedGdiplusVersion;
    
public static Status GdiplusNotInitialized;
    
public static Status PropertyNotFound;
    
public static Status PropertyNotSupported;
    
public static Status ProfileNotFound;
}
public enum System.Drawing.StringAlignment : Enum {
    
public int value__;
    
public static StringAlignment Near;
    
public static StringAlignment Center;
    
public static StringAlignment Far;
}
public enum System.Drawing.StringDigitSubstitute : Enum {
    
public int value__;
    
public static StringDigitSubstitute User;
    
public static StringDigitSubstitute None;
    
public static StringDigitSubstitute National;
    
public static StringDigitSubstitute Traditional;
}
public class System.Drawing.StringFormat : MarshalByRefObject {
    
private IntPtr nativeStrFmt;
    
private int language;
    
public StringAlignment Alignment { get; public set; }
    
public StringAlignment LineAlignment { get; public set; }
    
public StringFormatFlags FormatFlags { get; public set; }
    
public HotkeyPrefix HotkeyPrefix { get; public set; }
    
public StringTrimming Trimming { get; public set; }
    
public static StringFormat GenericDefault { get; }
    
public int DigitSubstitutionLanguage { get; }
    
public static StringFormat GenericTypographic { get; }
    
public StringDigitSubstitute DigitSubstitutionMethod { get; }
    
internal IntPtr NativeObject { get; internal set; }
    
internal IntPtr nativeFormat { get; }
    public StringFormat(StringFormatFlags options, int language);
    internal StringFormat(IntPtr native);
    public StringFormat(StringFormat format);
    public StringFormat(StringFormatFlags options);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public StringAlignment get_Alignment();
    public void set_Alignment(StringAlignment value);
    public StringAlignment get_LineAlignment();
    public void set_LineAlignment(StringAlignment value);
    public StringFormatFlags get_FormatFlags();
    public void set_FormatFlags(StringFormatFlags value);
    public HotkeyPrefix get_HotkeyPrefix();
    public void set_HotkeyPrefix(HotkeyPrefix value);
    public StringTrimming get_Trimming();
    public void set_Trimming(StringTrimming value);
    public static StringFormat get_GenericDefault();
    public int get_DigitSubstitutionLanguage();
    public static StringFormat get_GenericTypographic();
    public StringDigitSubstitute get_DigitSubstitutionMethod();
    public void SetMeasurableCharacterRanges(CharacterRange[] ranges);
    internal int GetMeasurableCharacterRangeCount();
    public sealed virtual object Clone();
    public virtual string ToString();
    internal IntPtr get_NativeObject();
    internal void set_NativeObject(IntPtr value);
    internal IntPtr get_nativeFormat();
    public void SetTabStops(float firstTabOffset, Single[] tabStops);
    public void SetDigitSubstitution(int language, StringDigitSubstitute substitute);
    public Single[] GetTabStops(Single& firstTabOffset);
}
[FlagsAttribute]
public enum System.Drawing.StringFormatFlags : Enum {
    
public int value__;
    
public static StringFormatFlags DirectionRightToLeft;
    
public static StringFormatFlags DirectionVertical;
    
public static StringFormatFlags FitBlackBox;
    
public static StringFormatFlags DisplayFormatControl;
    
public static StringFormatFlags NoFontFallback;
    
public static StringFormatFlags MeasureTrailingSpaces;
    
public static StringFormatFlags NoWrap;
    
public static StringFormatFlags LineLimit;
    
public static StringFormatFlags NoClip;
}
public enum System.Drawing.StringTrimming : Enum {
    
public int value__;
    
public static StringTrimming None;
    
public static StringTrimming Character;
    
public static StringTrimming Word;
    
public static StringTrimming EllipsisCharacter;
    
public static StringTrimming EllipsisWord;
    
public static StringTrimming EllipsisPath;
}
public enum System.Drawing.StringUnit : Enum {
    
public int value__;
    
public static StringUnit World;
    
public static StringUnit Display;
    
public static StringUnit Pixel;
    
public static StringUnit Point;
    
public static StringUnit Inch;
    
public static StringUnit Document;
    
public static StringUnit Millimeter;
    
public static StringUnit Em;
}
public static class System.Drawing.SystemBrushes : object {
    
private static object s_systemBrushesKey;
    
public static Brush ActiveBorder { get; }
    
public static Brush ActiveCaption { get; }
    
public static Brush ActiveCaptionText { get; }
    
public static Brush AppWorkspace { get; }
    
public static Brush ButtonFace { get; }
    
public static Brush ButtonHighlight { get; }
    
public static Brush ButtonShadow { get; }
    
public static Brush Control { get; }
    
public static Brush ControlLightLight { get; }
    
public static Brush ControlLight { get; }
    
public static Brush ControlDark { get; }
    
public static Brush ControlDarkDark { get; }
    
public static Brush ControlText { get; }
    
public static Brush Desktop { get; }
    
public static Brush GradientActiveCaption { get; }
    
public static Brush GradientInactiveCaption { get; }
    
public static Brush GrayText { get; }
    
public static Brush Highlight { get; }
    
public static Brush HighlightText { get; }
    
public static Brush HotTrack { get; }
    
public static Brush InactiveCaption { get; }
    
public static Brush InactiveBorder { get; }
    
public static Brush InactiveCaptionText { get; }
    
public static Brush Info { get; }
    
public static Brush InfoText { get; }
    
public static Brush Menu { get; }
    
public static Brush MenuBar { get; }
    
public static Brush MenuHighlight { get; }
    
public static Brush MenuText { get; }
    
public static Brush ScrollBar { get; }
    
public static Brush Window { get; }
    
public static Brush WindowFrame { get; }
    
public static Brush WindowText { get; }
    private static SystemBrushes();
    public static Brush get_ActiveBorder();
    public static Brush get_ActiveCaption();
    public static Brush get_ActiveCaptionText();
    public static Brush get_AppWorkspace();
    public static Brush get_ButtonFace();
    public static Brush get_ButtonHighlight();
    public static Brush get_ButtonShadow();
    public static Brush get_Control();
    public static Brush get_ControlLightLight();
    public static Brush get_ControlLight();
    public static Brush get_ControlDark();
    public static Brush get_ControlDarkDark();
    public static Brush get_ControlText();
    public static Brush get_Desktop();
    public static Brush get_GradientActiveCaption();
    public static Brush get_GradientInactiveCaption();
    public static Brush get_GrayText();
    public static Brush get_Highlight();
    public static Brush get_HighlightText();
    public static Brush get_HotTrack();
    public static Brush get_InactiveCaption();
    public static Brush get_InactiveBorder();
    public static Brush get_InactiveCaptionText();
    public static Brush get_Info();
    public static Brush get_InfoText();
    public static Brush get_Menu();
    public static Brush get_MenuBar();
    public static Brush get_MenuHighlight();
    public static Brush get_MenuText();
    public static Brush get_ScrollBar();
    public static Brush get_Window();
    public static Brush get_WindowFrame();
    public static Brush get_WindowText();
    public static Brush FromSystemColor(Color c);
}
public class System.Drawing.SystemColors : object {
    
public static Color ActiveBorder { get; }
    
public static Color ActiveCaption { get; }
    
public static Color ActiveCaptionText { get; }
    
public static Color AppWorkspace { get; }
    
public static Color Control { get; }
    
public static Color ControlDark { get; }
    
public static Color ControlDarkDark { get; }
    
public static Color ControlLight { get; }
    
public static Color ControlLightLight { get; }
    
public static Color ControlText { get; }
    
public static Color Desktop { get; }
    
public static Color GrayText { get; }
    
public static Color Highlight { get; }
    
public static Color HighlightText { get; }
    
public static Color HotTrack { get; }
    
public static Color InactiveBorder { get; }
    
public static Color InactiveCaption { get; }
    
public static Color InactiveCaptionText { get; }
    
public static Color Info { get; }
    
public static Color InfoText { get; }
    
public static Color Menu { get; }
    
public static Color MenuText { get; }
    
public static Color ScrollBar { get; }
    
public static Color Window { get; }
    
public static Color WindowFrame { get; }
    
public static Color WindowText { get; }
    
public static Color ButtonFace { get; }
    
public static Color ButtonHighlight { get; }
    
public static Color ButtonShadow { get; }
    
public static Color GradientActiveCaption { get; }
    
public static Color GradientInactiveCaption { get; }
    
public static Color MenuBar { get; }
    
public static Color MenuHighlight { get; }
    public static Color get_ActiveBorder();
    public static Color get_ActiveCaption();
    public static Color get_ActiveCaptionText();
    public static Color get_AppWorkspace();
    public static Color get_Control();
    public static Color get_ControlDark();
    public static Color get_ControlDarkDark();
    public static Color get_ControlLight();
    public static Color get_ControlLightLight();
    public static Color get_ControlText();
    public static Color get_Desktop();
    public static Color get_GrayText();
    public static Color get_Highlight();
    public static Color get_HighlightText();
    public static Color get_HotTrack();
    public static Color get_InactiveBorder();
    public static Color get_InactiveCaption();
    public static Color get_InactiveCaptionText();
    public static Color get_Info();
    public static Color get_InfoText();
    public static Color get_Menu();
    public static Color get_MenuText();
    public static Color get_ScrollBar();
    public static Color get_Window();
    public static Color get_WindowFrame();
    public static Color get_WindowText();
    public static Color get_ButtonFace();
    public static Color get_ButtonHighlight();
    public static Color get_ButtonShadow();
    public static Color get_GradientActiveCaption();
    public static Color get_GradientInactiveCaption();
    public static Color get_MenuBar();
    public static Color get_MenuHighlight();
}
public class System.Drawing.SystemFonts : object {
    
public static Font CaptionFont { get; }
    
public static Font DefaultFont { get; }
    
public static Font DialogFont { get; }
    
public static Font IconTitleFont { get; }
    
public static Font MenuFont { get; }
    
public static Font MessageBoxFont { get; }
    
public static Font SmallCaptionFont { get; }
    
public static Font StatusFont { get; }
    private static SystemFonts();
    public static Font GetFontByName(string systemFontName);
    public static Font get_CaptionFont();
    public static Font get_DefaultFont();
    public static Font get_DialogFont();
    public static Font get_IconTitleFont();
    public static Font get_MenuFont();
    public static Font get_MessageBoxFont();
    public static Font get_SmallCaptionFont();
    public static Font get_StatusFont();
}
public class System.Drawing.SystemIcons : object {
    
private static Icon[] icons;
    
private static int Application_Winlogo;
    
private static int Asterisk_Information;
    
private static int Error_Hand;
    
private static int Exclamation_Warning;
    
private static int Question_;
    
private static int Shield_;
    
public static Icon Application { get; }
    
public static Icon Asterisk { get; }
    
public static Icon Error { get; }
    
public static Icon Exclamation { get; }
    
public static Icon Hand { get; }
    
public static Icon Information { get; }
    
public static Icon Question { get; }
    
public static Icon Warning { get; }
    
public static Icon WinLogo { get; }
    
public static Icon Shield { get; }
    private static SystemIcons();
    public static Icon get_Application();
    public static Icon get_Asterisk();
    public static Icon get_Error();
    public static Icon get_Exclamation();
    public static Icon get_Hand();
    public static Icon get_Information();
    public static Icon get_Question();
    public static Icon get_Warning();
    public static Icon get_WinLogo();
    public static Icon get_Shield();
}
public class System.Drawing.SystemPens : object {
    
private static Pen active_caption_text;
    
private static Pen control;
    
private static Pen control_dark;
    
private static Pen control_dark_dark;
    
private static Pen control_light;
    
private static Pen control_light_light;
    
private static Pen control_text;
    
private static Pen gray_text;
    
private static Pen highlight;
    
private static Pen highlight_text;
    
private static Pen inactive_caption_text;
    
private static Pen info_text;
    
private static Pen menu_text;
    
private static Pen window_frame;
    
private static Pen window_text;
    
private static Pen active_border;
    
private static Pen active_caption;
    
private static Pen app_workspace;
    
private static Pen button_face;
    
private static Pen button_highlight;
    
private static Pen button_shadow;
    
private static Pen desktop;
    
private static Pen gradient_activecaption;
    
private static Pen gradient_inactivecaption;
    
private static Pen hot_track;
    
private static Pen inactive_border;
    
private static Pen inactive_caption;
    
private static Pen info;
    
private static Pen menu;
    
private static Pen menu_bar;
    
private static Pen menu_highlight;
    
private static Pen scroll_bar;
    
private static Pen window;
    
public static Pen ActiveCaptionText { get; }
    
public static Pen Control { get; }
    
public static Pen ControlDark { get; }
    
public static Pen ControlDarkDark { get; }
    
public static Pen ControlLight { get; }
    
public static Pen ControlLightLight { get; }
    
public static Pen ControlText { get; }
    
public static Pen GrayText { get; }
    
public static Pen Highlight { get; }
    
public static Pen HighlightText { get; }
    
public static Pen InactiveCaptionText { get; }
    
public static Pen InfoText { get; }
    
public static Pen MenuText { get; }
    
public static Pen WindowFrame { get; }
    
public static Pen WindowText { get; }
    
public static Pen ActiveBorder { get; }
    
public static Pen ActiveCaption { get; }
    
public static Pen AppWorkspace { get; }
    
public static Pen ButtonFace { get; }
    
public static Pen ButtonHighlight { get; }
    
public static Pen ButtonShadow { get; }
    
public static Pen Desktop { get; }
    
public static Pen GradientActiveCaption { get; }
    
public static Pen GradientInactiveCaption { get; }
    
public static Pen HotTrack { get; }
    
public static Pen InactiveBorder { get; }
    
public static Pen InactiveCaption { get; }
    
public static Pen Info { get; }
    
public static Pen Menu { get; }
    
public static Pen MenuBar { get; }
    
public static Pen MenuHighlight { get; }
    
public static Pen ScrollBar { get; }
    
public static Pen Window { get; }
    public static Pen get_ActiveCaptionText();
    public static Pen get_Control();
    public static Pen get_ControlDark();
    public static Pen get_ControlDarkDark();
    public static Pen get_ControlLight();
    public static Pen get_ControlLightLight();
    public static Pen get_ControlText();
    public static Pen get_GrayText();
    public static Pen get_Highlight();
    public static Pen get_HighlightText();
    public static Pen get_InactiveCaptionText();
    public static Pen get_InfoText();
    public static Pen get_MenuText();
    public static Pen get_WindowFrame();
    public static Pen get_WindowText();
    public static Pen FromSystemColor(Color c);
    public static Pen get_ActiveBorder();
    public static Pen get_ActiveCaption();
    public static Pen get_AppWorkspace();
    public static Pen get_ButtonFace();
    public static Pen get_ButtonHighlight();
    public static Pen get_ButtonShadow();
    public static Pen get_Desktop();
    public static Pen get_GradientActiveCaption();
    public static Pen get_GradientInactiveCaption();
    public static Pen get_HotTrack();
    public static Pen get_InactiveBorder();
    public static Pen get_InactiveCaption();
    public static Pen get_Info();
    public static Pen get_Menu();
    public static Pen get_MenuBar();
    public static Pen get_MenuHighlight();
    public static Pen get_ScrollBar();
    public static Pen get_Window();
}
public abstract class System.Drawing.Text.FontCollection : object {
    
internal IntPtr _nativeFontCollection;
    
public FontFamily[] Families { get; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public FontFamily[] get_Families();
    protected virtual override void Finalize();
}
public enum System.Drawing.Text.GenericFontFamilies : Enum {
    
public int value__;
    
public static GenericFontFamilies Serif;
    
public static GenericFontFamilies SansSerif;
    
public static GenericFontFamilies Monospace;
}
public enum System.Drawing.Text.HotkeyPrefix : Enum {
    
public int value__;
    
public static HotkeyPrefix None;
    
public static HotkeyPrefix Show;
    
public static HotkeyPrefix Hide;
}
public class System.Drawing.Text.InstalledFontCollection : FontCollection {
}
public class System.Drawing.Text.PrivateFontCollection : FontCollection {
    public void AddFontFile(string filename);
    public void AddMemoryFont(IntPtr memory, int length);
    protected virtual void Dispose(bool disposing);
}
public enum System.Drawing.Text.TextRenderingHint : Enum {
    
public int value__;
    
public static TextRenderingHint SystemDefault;
    
public static TextRenderingHint SingleBitPerPixelGridFit;
    
public static TextRenderingHint SingleBitPerPixel;
    
public static TextRenderingHint AntiAliasGridFit;
    
public static TextRenderingHint AntiAlias;
    
public static TextRenderingHint ClearTypeGridFit;
}
public class System.Drawing.TextureBrush : Brush {
    
public Matrix Transform { get; public set; }
    
public WrapMode WrapMode { get; public set; }
    
public Image Image { get; }
    public TextureBrush(Image bitmap);
    public TextureBrush(Image image, WrapMode wrapMode);
    public TextureBrush(Image image, WrapMode wrapMode, RectangleF dstRect);
    public TextureBrush(Image image, WrapMode wrapMode, Rectangle dstRect);
    public TextureBrush(Image image, RectangleF dstRect);
    public TextureBrush(Image image, RectangleF dstRect, ImageAttributes imageAttr);
    public TextureBrush(Image image, Rectangle dstRect);
    public TextureBrush(Image image, Rectangle dstRect, ImageAttributes imageAttr);
    internal TextureBrush(IntPtr nativeBrush);
    public virtual object Clone();
    public Matrix get_Transform();
    public void set_Transform(Matrix value);
    public WrapMode get_WrapMode();
    public void set_WrapMode(WrapMode value);
    public Image get_Image();
    public void ResetTransform();
    public void MultiplyTransform(Matrix matrix);
    public void MultiplyTransform(Matrix matrix, MatrixOrder order);
    public void TranslateTransform(float dx, float dy);
    public void TranslateTransform(float dx, float dy, MatrixOrder order);
    public void ScaleTransform(float sx, float sy);
    public void ScaleTransform(float sx, float sy, MatrixOrder order);
    public void RotateTransform(float angle);
    public void RotateTransform(float angle, MatrixOrder order);
}
[AttributeUsageAttribute("4")]
public class System.Drawing.ToolboxBitmapAttribute : Attribute {
    
private Image smallImage;
    
private Image bigImage;
    
public static ToolboxBitmapAttribute Default;
    public ToolboxBitmapAttribute(string imageFile);
    public ToolboxBitmapAttribute(Type t);
    public ToolboxBitmapAttribute(Type t, string name);
    private static ToolboxBitmapAttribute();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public Image GetImage(object component);
    public Image GetImage(object component, bool large);
    public Image GetImage(Type type);
    public Image GetImage(Type type, bool large);
    public Image GetImage(Type type, string imgName, bool large);
    public static Image GetImageFromResource(Type t, string imageName, bool large);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Drawing.UnsafeNativeMethods : object {
    public static void CopyMemory(HandleRef destData, HandleRef srcData, int size);
    private static IntPtr IntGetDC(HandleRef hWnd);
    public static IntPtr GetDC(HandleRef hWnd);
    private static bool IntDeleteDC(HandleRef hDC);
    public static bool DeleteDC(HandleRef hDC);
    private static int IntReleaseDC(HandleRef hWnd, HandleRef hDC);
    public static int ReleaseDC(HandleRef hWnd, HandleRef hDC);
    private static IntPtr IntCreateCompatibleDC(HandleRef hDC);
    public static IntPtr CreateCompatibleDC(HandleRef hDC);
    public static IntPtr GetStockObject(int nIndex);
    public static int GetSystemDefaultLCID();
    public static int GetSystemMetrics(int nIndex);
    public static bool SystemParametersInfo(int uiAction, int uiParam, NONCLIENTMETRICS pvParam, int fWinIni);
    public static bool SystemParametersInfo(int uiAction, int uiParam, LOGFONT pvParam, int fWinIni);
    public static int GetDeviceCaps(HandleRef hDC, int nIndex);
    public static int GetObjectType(HandleRef hObject);
}
internal class System.Drawing.WorkerThread : object {
    
private EventHandler frameChangeHandler;
    
private AnimateEventArgs animateEventArgs;
    
private Int32[] delay;
    public WorkerThread(EventHandler frmChgHandler, AnimateEventArgs aniEvtArgs, Int32[] delay);
    public void LoopHandler();
}
internal class System.Drawing.XColor : ValueType {
    
public int pixel;
    
public ushort red;
    
public ushort green;
    
public ushort blue;
    
public sbyte flags;
    
public sbyte pad;
}
internal class System.Drawing.XVisualInfo : ValueType {
    
internal IntPtr visual;
    
internal IntPtr visualid;
    
internal int screen;
    
internal UInt32 depth;
    
internal int klass;
    
internal IntPtr red_mask;
    
internal IntPtr green_mask;
    
internal IntPtr blue_mask;
    
internal int colormap_size;
    
internal int bits_per_rgb;
}
internal class System.Internal.HandleChangeEventHandler : MulticastDelegate {
    public HandleChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(string handleType, IntPtr handleValue, int currentHandleCount);
    public virtual IAsyncResult BeginInvoke(string handleType, IntPtr handleValue, int currentHandleCount, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Internal.HandleCollector : object {
    
private static HandleType[] s_handleTypes;
    
private static int s_handleTypeCount;
    [CompilerGeneratedAttribute]

private static HandleChangeEventHandler HandleAdded;
    [CompilerGeneratedAttribute]

private static HandleChangeEventHandler HandleRemoved;
    
private static object s_internalSyncObject;
    private static HandleCollector();
    [CompilerGeneratedAttribute]
internal static void add_HandleAdded(HandleChangeEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_HandleAdded(HandleChangeEventHandler value);
    [CompilerGeneratedAttribute]
internal static void add_HandleRemoved(HandleChangeEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_HandleRemoved(HandleChangeEventHandler value);
    internal static IntPtr Add(IntPtr handle, int type);
    internal static int RegisterType(string typeName, int expense, int initialThreshold);
    internal static IntPtr Remove(IntPtr handle, int type);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
    public MonoDocumentationNoteAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoExtensionAttribute : MonoTODOAttribute {
    public MonoExtensionAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoInternalNoteAttribute : MonoTODOAttribute {
    public MonoInternalNoteAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoLimitationAttribute : MonoTODOAttribute {
    public MonoLimitationAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoNotSupportedAttribute : MonoTODOAttribute {
    public MonoNotSupportedAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoTODOAttribute : Attribute {
    
private string comment;
    
public string Comment { get; }
    public MonoTODOAttribute(string comment);
    public string get_Comment();
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
