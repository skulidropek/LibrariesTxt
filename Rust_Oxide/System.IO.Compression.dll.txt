internal static class Consts : object {
    
public static string MonoCorlibVersion;
    
public static string MonoVersion;
    
public static string MonoCompany;
    
public static string MonoProduct;
    
public static string MonoCopyright;
    
public static string FxVersion;
    
public static string FxFileVersion;
    
public static string EnvironmentVersion;
    
public static string VsVersion;
    
public static string VsFileVersion;
    
private static string PublicKeyToken;
    
public static string AssemblyI18N;
    
public static string AssemblyMicrosoft_JScript;
    
public static string AssemblyMicrosoft_VisualStudio;
    
public static string AssemblyMicrosoft_VisualStudio_Web;
    
public static string AssemblyMicrosoft_VSDesigner;
    
public static string AssemblyMono_Http;
    
public static string AssemblyMono_Posix;
    
public static string AssemblyMono_Security;
    
public static string AssemblyMono_Messaging_RabbitMQ;
    
public static string AssemblyCorlib;
    
public static string AssemblySystem;
    
public static string AssemblySystem_Data;
    
public static string AssemblySystem_Design;
    
public static string AssemblySystem_DirectoryServices;
    
public static string AssemblySystem_Drawing;
    
public static string AssemblySystem_Drawing_Design;
    
public static string AssemblySystem_Messaging;
    
public static string AssemblySystem_Security;
    
public static string AssemblySystem_ServiceProcess;
    
public static string AssemblySystem_Web;
    
public static string AssemblySystem_Windows_Forms;
    
public static string AssemblySystem_2_0;
    
public static string AssemblySystemCore_3_5;
    
public static string AssemblySystem_Core;
    
public static string WindowsBase_3_0;
    
public static string AssemblyWindowsBase;
    
public static string AssemblyPresentationCore_3_5;
    
public static string AssemblyPresentationCore_4_0;
    
public static string AssemblyPresentationFramework_3_5;
    
public static string AssemblySystemServiceModel_3_0;
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeBrotliDecoderHandle : SafeHandle {
    
public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeBrotliEncoderHandle : SafeHandle {
    
public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal static class SR : object {
    
public static string ArgumentOutOfRange_Enum;
    
public static string ArgumentOutOfRange_NeedPosNum;
    
public static string CannotReadFromDeflateStream;
    
public static string CannotWriteToDeflateStream;
    
public static string GenericInvalidData;
    
public static string InvalidArgumentOffsetCount;
    
public static string InvalidBeginCall;
    
public static string InvalidBlockLength;
    
public static string InvalidHuffmanData;
    
public static string NotSupported;
    
public static string NotSupported_UnreadableStream;
    
public static string NotSupported_UnwritableStream;
    
public static string ObjectDisposed_StreamClosed;
    
public static string UnknownBlockType;
    
public static string UnknownState;
    
public static string ZLibErrorDLLLoadError;
    
public static string ZLibErrorInconsistentStream;
    
public static string ZLibErrorIncorrectInitParameters;
    
public static string ZLibErrorNotEnoughMemory;
    
public static string ZLibErrorVersionMismatch;
    
public static string ZLibErrorUnexpected;
    
public static string ArgumentNeedNonNegative;
    
public static string CannotBeEmpty;
    
public static string CDCorrupt;
    
public static string CentralDirectoryInvalid;
    
public static string CreateInReadMode;
    
public static string CreateModeCapabilities;
    
public static string CreateModeCreateEntryWhileOpen;
    
public static string CreateModeWriteOnceAndOneEntryAtATime;
    
public static string DateTimeOutOfRange;
    
public static string DeletedEntry;
    
public static string DeleteOnlyInUpdate;
    
public static string DeleteOpenEntry;
    
public static string EntriesInCreateMode;
    
public static string EntryNameEncodingNotSupported;
    
public static string EntryNamesTooLong;
    
public static string EntryTooLarge;
    
public static string EOCDNotFound;
    
public static string FieldTooBigCompressedSize;
    
public static string FieldTooBigLocalHeaderOffset;
    
public static string FieldTooBigNumEntries;
    
public static string FieldTooBigOffsetToCD;
    
public static string FieldTooBigOffsetToZip64EOCD;
    
public static string FieldTooBigStartDiskNumber;
    
public static string FieldTooBigUncompressedSize;
    
public static string FrozenAfterWrite;
    
public static string HiddenStreamName;
    
public static string LengthAfterWrite;
    
public static string LocalFileHeaderCorrupt;
    
public static string NumEntriesWrong;
    
public static string OffsetLengthInvalid;
    
public static string ReadingNotSupported;
    
public static string ReadModeCapabilities;
    
public static string ReadOnlyArchive;
    
public static string SeekingNotSupported;
    
public static string SetLengthRequiresSeekingAndWriting;
    
public static string SplitSpanned;
    
public static string UnexpectedEndOfStream;
    
public static string UnsupportedCompression;
    
public static string UnsupportedCompressionMethod;
    
public static string UpdateModeCapabilities;
    
public static string UpdateModeOneStream;
    
public static string WritingNotSupported;
    
public static string Zip64EOCDNotWhereExpected;
    
public static string Argument_InvalidPathChars;
    
public static string Stream_FalseCanRead;
    
public static string Stream_FalseCanWrite;
    
public static string BrotliEncoder_Create;
    
public static string BrotliEncoder_Disposed;
    
public static string BrotliEncoder_Quality;
    
public static string BrotliEncoder_Window;
    
public static string BrotliEncoder_InvalidSetParameter;
    
public static string BrotliDecoder_Create;
    
public static string BrotliDecoder_Error;
    
public static string BrotliDecoder_Disposed;
    
public static string BrotliStream_Compress_UnsupportedOperation;
    
public static string BrotliStream_Compress_InvalidData;
    
public static string BrotliStream_Decompress_UnsupportedOperation;
    
public static string BrotliStream_Decompress_InvalidData;
    
public static string BrotliStream_Decompress_InvalidStream;
    internal static string GetString(string name, Object[] args);
    internal static string GetString(CultureInfo culture, string name, Object[] args);
    internal static string GetString(string name);
    internal static string GetString(CultureInfo culture, string name);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(CultureInfo ci, string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string GetResourceString(string str);
}
internal enum System.IO.Compression.BlockType : Enum {
    
public int value__;
    
public static BlockType Uncompressed;
    
public static BlockType Static;
    
public static BlockType Dynamic;
}
public class System.IO.Compression.BrotliDecoder : ValueType {
    
private SafeBrotliDecoderHandle _state;
    
private bool _disposed;
    internal void InitializeDecoder();
    internal void EnsureInitialized();
    public sealed virtual void Dispose();
    private void EnsureNotDisposed();
    public OperationStatus Decompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten);
    public static bool TryDecompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
public class System.IO.Compression.BrotliEncoder : ValueType {
    
internal SafeBrotliEncoderHandle _state;
    
private bool _disposed;
    public BrotliEncoder(int quality, int window);
    internal void InitializeEncoder();
    internal void EnsureInitialized();
    public sealed virtual void Dispose();
    private void EnsureNotDisposed();
    internal void SetQuality(int quality);
    internal void SetWindow(int window);
    public static int GetMaxCompressedLength(int length);
    internal OperationStatus Flush(Memory`1<byte> destination, Int32& bytesWritten);
    public OperationStatus Flush(Span`1<byte> destination, Int32& bytesWritten);
    internal OperationStatus Compress(ReadOnlyMemory`1<byte> source, Memory`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public OperationStatus Compress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    internal OperationStatus Compress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten, BrotliEncoderOperation operation);
    public static bool TryCompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryCompress(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten, int quality, int window);
}
internal enum System.IO.Compression.BrotliEncoderOperation : Enum {
    
public int value__;
    
public static BrotliEncoderOperation Process;
    
public static BrotliEncoderOperation Flush;
    
public static BrotliEncoderOperation Finish;
    
public static BrotliEncoderOperation EmitMetadata;
}
internal enum System.IO.Compression.BrotliEncoderParameter : Enum {
    
public int value__;
    
public static BrotliEncoderParameter Mode;
    
public static BrotliEncoderParameter Quality;
    
public static BrotliEncoderParameter LGWin;
    
public static BrotliEncoderParameter LGBlock;
    
public static BrotliEncoderParameter LCModeling;
    
public static BrotliEncoderParameter SizeHint;
}
public class System.IO.Compression.BrotliStream : Stream {
    
private static int DefaultInternalBufferSize;
    
private Stream _stream;
    
private Byte[] _buffer;
    
private bool _leaveOpen;
    
private CompressionMode _mode;
    
private int _activeAsyncOperation;
    
private BrotliDecoder _decoder;
    
private int _bufferOffset;
    
private int _bufferCount;
    
private BrotliEncoder _encoder;
    
public Stream BaseStream { get; }
    
public bool CanRead { get; }
    
public bool CanWrite { get; }
    
public bool CanSeek { get; }
    
public long Length { get; }
    
public long Position { get; public set; }
    
private bool AsyncOperationIsActive { get; }
    public BrotliStream(Stream stream, CompressionMode mode);
    public BrotliStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public BrotliStream(Stream stream, CompressionLevel compressionLevel);
    public BrotliStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    private void EnsureNotDisposed();
    protected virtual void Dispose(bool disposing);
    private static void ValidateParameters(Byte[] array, int offset, int count);
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    private bool get_AsyncOperationIsActive();
    private void EnsureNoActiveAsyncOperation();
    private void AsyncOperationStarting();
    private void AsyncOperationCompleting();
    private static void ThrowInvalidBeginCall();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.BrotliStream/<FinishReadAsyncMemory>d__41")]
private ValueTask`1<int> FinishReadAsyncMemory(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    internal void WriteCore(ReadOnlySpan`1<byte> buffer, bool isFinalBlock);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.BrotliStream/<WriteAsyncMemoryCore>d__52")]
private Task WriteAsyncMemoryCore(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.BrotliStream/<FlushAsyncCore>d__55")]
private Task FlushAsyncCore(CancellationToken cancellationToken);
}
internal static class System.IO.Compression.BrotliUtils : object {
    
public static int WindowBits_Min;
    
public static int WindowBits_Default;
    
public static int WindowBits_Max;
    
public static int Quality_Min;
    
public static int Quality_Default;
    
public static int Quality_Max;
    
public static int MaxInputSize;
    internal static int GetQualityFromCompressionLevel(CompressionLevel level);
}
internal class System.IO.Compression.CheckSumAndSizeWriteStream : Stream {
    
private Stream _baseStream;
    
private Stream _baseBaseStream;
    
private long _position;
    
private UInt32 _checksum;
    
private bool _leaveOpenOnClose;
    
private bool _canWrite;
    
private bool _isDisposed;
    
private bool _everWritten;
    
private long _initialPosition;
    
private ZipArchiveEntry _zipArchiveEntry;
    
private EventHandler _onClose;
    
private Action`6<long, long, UInt32, Stream, ZipArchiveEntry, EventHandler> _saveCrcAndSizes;
    
public long Length { get; }
    
public long Position { get; public set; }
    
public bool CanRead { get; }
    
public bool CanSeek { get; }
    
public bool CanWrite { get; }
    public CheckSumAndSizeWriteStream(Stream baseStream, Stream baseBaseStream, bool leaveOpenOnClose, ZipArchiveEntry entry, EventHandler onClose, Action`6<long, long, UInt32, Stream, ZipArchiveEntry, EventHandler> saveCrcAndSizes);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class System.IO.Compression.CopyEncoder : object {
    
private static int PaddingSize;
    
private static int MaxUncompressedBlockSize;
    public void GetBlock(DeflateInput input, OutputBuffer output, bool isFinal);
    private void WriteLenNLen(ushort len, OutputBuffer output);
}
internal static class System.IO.Compression.Crc32Helper : object {
    
private static UInt32[] s_crcTable_0;
    
private static UInt32[] s_crcTable_1;
    
private static UInt32[] s_crcTable_2;
    
private static UInt32[] s_crcTable_3;
    
private static UInt32[] s_crcTable_4;
    
private static UInt32[] s_crcTable_5;
    
private static UInt32[] s_crcTable_6;
    
private static UInt32[] s_crcTable_7;
    private static Crc32Helper();
    public static UInt32 UpdateCrc32(UInt32 crc32, Byte[] buffer, int offset, int length);
    private static UInt32 ManagedCrc32(UInt32 crc32, Byte[] buffer, int offset, int length);
}
internal class System.IO.Compression.DeflateInput : object {
    [CompilerGeneratedAttribute]

private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]

private int <StartIndex>k__BackingField;
    
internal Byte[] Buffer { get; internal set; }
    
internal int Count { get; internal set; }
    
internal int StartIndex { get; internal set; }
    [CompilerGeneratedAttribute]
internal Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
internal void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
    [CompilerGeneratedAttribute]
internal int get_StartIndex();
    [CompilerGeneratedAttribute]
internal void set_StartIndex(int value);
    internal void ConsumeBytes(int n);
    internal InputState DumpState();
    internal void RestoreState(InputState state);
}
internal class System.IO.Compression.DeflateManagedStream : Stream {
    
internal static int DefaultBufferSize;
    
private Stream _stream;
    
private CompressionMode _mode;
    
private bool _leaveOpen;
    
private InflaterManaged _inflater;
    
private DeflaterManaged _deflater;
    
private Byte[] _buffer;
    
private int _asyncOperations;
    
private IFileFormatWriter _formatWriter;
    
private bool _wroteHeader;
    
private bool _wroteBytes;
    
public bool CanRead { get; }
    
public bool CanWrite { get; }
    
public bool CanSeek { get; }
    
public long Length { get; }
    
public long Position { get; public set; }
    internal DeflateManagedStream(Stream stream, CompressionMethodValues method);
    internal void InitializeInflater(Stream stream, bool leaveOpen, IFileFormatReader reader, CompressionMethodValues method);
    internal void SetFileFormatWriter(IFileFormatWriter writer);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] array, int offset, int count);
    private void ValidateParameters(Byte[] array, int offset, int count);
    private void EnsureNotDisposed();
    private static void ThrowStreamClosedException();
    private void EnsureDecompressionMode();
    private static void ThrowCannotReadFromDeflateManagedStreamException();
    private void EnsureCompressionMode();
    private static void ThrowCannotWriteToDeflateManagedStreamException();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateManagedStream/<ReadAsyncCore>d__40")]
private Task`1<int> ReadAsyncCore(Task`1<int> readTask, Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] array, int offset, int count);
    private void WriteDeflaterOutput();
    private void DoMaintenance(Byte[] array, int offset, int count);
    private void PurgeBuffers(bool disposing);
    protected virtual void Dispose(bool disposing);
    public virtual Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateManagedStream/<WriteAsyncCore>d__47")]
private Task WriteAsyncCore(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.IO.Compression.DeflaterManaged : object {
    
private static int MinBlockSize;
    
private static int MaxHeaderFooterGoo;
    
private static int CleanCopySize;
    
private static double BadCompressionThreshold;
    
private FastEncoder _deflateEncoder;
    
private CopyEncoder _copyEncoder;
    
private DeflateInput _input;
    
private OutputBuffer _output;
    
private DeflaterState _processingState;
    
private DeflateInput _inputFromHistory;
    internal bool NeedsInput();
    internal void SetInput(Byte[] inputBuffer, int startIndex, int count);
    internal int GetDeflateOutput(Byte[] outputBuffer);
    internal bool Finish(Byte[] outputBuffer, Int32& bytesRead);
    private bool UseCompressed(double ratio);
    private void FlushInputWindows();
    private void WriteFinal();
    public sealed virtual void Dispose();
}
internal class System.IO.Compression.FastEncoder : object {
    
private FastEncoderWindow _inputWindow;
    
private Match _currentMatch;
    
private double _lastCompressionRatio;
    
internal int BytesInHistory { get; }
    
internal DeflateInput UnprocessedInput { get; }
    
internal double LastCompressionRatio { get; }
    internal int get_BytesInHistory();
    internal DeflateInput get_UnprocessedInput();
    internal void FlushInput();
    internal double get_LastCompressionRatio();
    internal void GetBlock(DeflateInput input, OutputBuffer output, int maxBytesToCopy);
    internal void GetCompressedData(DeflateInput input, OutputBuffer output);
    internal void GetBlockHeader(OutputBuffer output);
    internal void GetBlockFooter(OutputBuffer output);
    private void GetCompressedOutput(DeflateInput input, OutputBuffer output, int maxBytesToCopy);
    private void GetCompressedOutput(OutputBuffer output);
    private bool InputAvailable(DeflateInput input);
    private bool SafeToWriteTo(OutputBuffer output);
    private void WriteEndOfBlock(OutputBuffer output);
    internal static void WriteMatch(int matchLen, int matchPos, OutputBuffer output);
    internal static void WriteChar(byte b, OutputBuffer output);
    internal static void WriteDeflatePreamble(OutputBuffer output);
}
internal static class System.IO.Compression.FastEncoderStatics : object {
    
internal static Byte[] FastEncoderTreeStructureData;
    
internal static Byte[] BFinalFastEncoderTreeStructureData;
    
internal static UInt32[] FastEncoderLiteralCodeInfo;
    
internal static UInt32[] FastEncoderDistanceCodeInfo;
    
internal static UInt32[] BitMask;
    
internal static Byte[] ExtraLengthBits;
    
internal static Byte[] ExtraDistanceBits;
    
internal static int NumChars;
    
internal static int NumLengthBaseCodes;
    
internal static int NumDistBaseCodes;
    
internal static UInt32 FastEncoderPostTreeBitBuf;
    
internal static int FastEncoderPostTreeBitCount;
    
internal static UInt32 NoCompressionHeader;
    
internal static int NoCompressionHeaderBitCount;
    
internal static UInt32 BFinalNoCompressionHeader;
    
internal static int BFinalNoCompressionHeaderBitCount;
    
internal static int MaxCodeLen;
    
private static Byte[] s_distLookup;
    private static FastEncoderStatics();
    private static Byte[] CreateDistanceLookup();
    internal static int GetSlot(int pos);
    public static UInt32 BitReverse(UInt32 code, int length);
}
internal class System.IO.Compression.FastEncoderWindow : object {
    
private Byte[] _window;
    
private int _bufPos;
    
private int _bufEnd;
    
private static int FastEncoderHashShift;
    
private static int FastEncoderHashtableSize;
    
private static int FastEncoderHashMask;
    
private static int FastEncoderWindowSize;
    
private static int FastEncoderWindowMask;
    
private static int FastEncoderMatch3DistThreshold;
    
internal static int MaxMatch;
    
internal static int MinMatch;
    
private static int SearchDepth;
    
private static int GoodLength;
    
private static int NiceLength;
    
private static int LazyMatchThreshold;
    
private UInt16[] _prev;
    
private UInt16[] _lookup;
    
public int BytesAvailable { get; }
    
public DeflateInput UnprocessedInput { get; }
    
public int FreeWindowSpace { get; }
    public int get_BytesAvailable();
    public DeflateInput get_UnprocessedInput();
    public void FlushWindow();
    private void ResetWindow();
    public int get_FreeWindowSpace();
    public void CopyBytes(Byte[] inputBuffer, int startIndex, int count);
    public void MoveWindows();
    private UInt32 HashValue(UInt32 hash, byte b);
    private UInt32 InsertString(UInt32& hash);
    private void InsertStrings(UInt32& hash, int matchLen);
    internal bool GetNextSymbolOrMatch(Match match);
    private int FindMatch(int search, Int32& matchPos, int searchDepth, int niceLength);
    [ConditionalAttribute("DEBUG")]
private void DebugAssertVerifyHashes();
    [ConditionalAttribute("DEBUG")]
private void DebugAssertRecalculatedHashesAreEqual(int position1, int position2, string message);
}
internal class System.IO.Compression.HuffmanTree : object {
    
internal static int MaxLiteralTreeElements;
    
internal static int MaxDistTreeElements;
    
internal static int EndOfBlockCode;
    
internal static int NumberOfCodeLengthTreeElements;
    
private int _tableBits;
    
private Int16[] _table;
    
private Int16[] _left;
    
private Int16[] _right;
    
private Byte[] _codeLengthArray;
    
private int _tableMask;
    [CompilerGeneratedAttribute]

private static HuffmanTree <StaticLiteralLengthTree>k__BackingField;
    [CompilerGeneratedAttribute]

private static HuffmanTree <StaticDistanceTree>k__BackingField;
    
public static HuffmanTree StaticLiteralLengthTree { get; }
    
public static HuffmanTree StaticDistanceTree { get; }
    public HuffmanTree(Byte[] codeLengths);
    private static HuffmanTree();
    [CompilerGeneratedAttribute]
public static HuffmanTree get_StaticLiteralLengthTree();
    [CompilerGeneratedAttribute]
public static HuffmanTree get_StaticDistanceTree();
    private static Byte[] GetStaticLiteralTreeLength();
    private static Byte[] GetStaticDistanceTreeLength();
    private UInt32[] CalculateHuffmanCode();
    private void CreateTable();
    public int GetNextSymbol(InputBuffer input);
}
internal interface System.IO.Compression.IFileFormatReader {
    public abstract virtual bool ReadHeader(InputBuffer input);
    public abstract virtual bool ReadFooter(InputBuffer input);
    public abstract virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy);
    public abstract virtual void Validate();
}
internal interface System.IO.Compression.IFileFormatWriter {
    public abstract virtual Byte[] GetHeader();
    public abstract virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy);
    public abstract virtual Byte[] GetFooter();
}
internal class System.IO.Compression.InflaterManaged : object {
    
private static Byte[] s_extraLengthBits;
    
private static Int32[] s_lengthBase;
    
private static Int32[] s_distanceBasePosition;
    
private static Byte[] s_codeOrder;
    
private static Byte[] s_staticDistanceTreeTable;
    
private OutputWindow _output;
    
private InputBuffer _input;
    
private HuffmanTree _literalLengthTree;
    
private HuffmanTree _distanceTree;
    
private InflaterState _state;
    
private bool _hasFormatReader;
    
private int _bfinal;
    
private BlockType _blockType;
    
private Byte[] _blockLengthBuffer;
    
private int _blockLength;
    
private int _length;
    
private int _distanceCode;
    
private int _extraBits;
    
private int _loopCounter;
    
private int _literalLengthCodeCount;
    
private int _distanceCodeCount;
    
private int _codeLengthCodeCount;
    
private int _codeArraySize;
    
private int _lengthCode;
    
private Byte[] _codeList;
    
private Byte[] _codeLengthTreeCodeLength;
    
private bool _deflate64;
    
private HuffmanTree _codeLengthTree;
    
private IFileFormatReader _formatReader;
    
public int AvailableOutput { get; }
    internal InflaterManaged(IFileFormatReader reader, bool deflate64);
    private static InflaterManaged();
    private void Reset();
    public void SetInput(Byte[] inputBytes, int offset, int length);
    public bool Finished();
    public int get_AvailableOutput();
    public int Inflate(Byte[] bytes, int offset, int length);
    private bool Decode();
    private bool DecodeUncompressedBlock(Boolean& end_of_block);
    private bool DecodeBlock(Boolean& end_of_block_code_seen);
    private bool DecodeDynamicBlockHeader();
    public void Dispose();
}
internal enum System.IO.Compression.InflaterState : Enum {
    
public int value__;
    
public static InflaterState ReadingHeader;
    
public static InflaterState ReadingBFinal;
    
public static InflaterState ReadingBType;
    
public static InflaterState ReadingNumLitCodes;
    
public static InflaterState ReadingNumDistCodes;
    
public static InflaterState ReadingNumCodeLengthCodes;
    
public static InflaterState ReadingCodeLengthCodes;
    
public static InflaterState ReadingTreeCodesBefore;
    
public static InflaterState ReadingTreeCodesAfter;
    
public static InflaterState DecodeTop;
    
public static InflaterState HaveInitialLength;
    
public static InflaterState HaveFullLength;
    
public static InflaterState HaveDistCode;
    
public static InflaterState UncompressedAligning;
    
public static InflaterState UncompressedByte1;
    
public static InflaterState UncompressedByte2;
    
public static InflaterState UncompressedByte3;
    
public static InflaterState UncompressedByte4;
    
public static InflaterState DecodingUncompressed;
    
public static InflaterState StartReadingFooter;
    
public static InflaterState ReadingFooter;
    
public static InflaterState VerifyingFooter;
    
public static InflaterState Done;
}
internal class System.IO.Compression.InputBuffer : object {
    
private Byte[] _buffer;
    
private int _start;
    
private int _end;
    
private UInt32 _bitBuffer;
    
private int _bitsInBuffer;
    
public int AvailableBits { get; }
    
public int AvailableBytes { get; }
    public int get_AvailableBits();
    public int get_AvailableBytes();
    public bool EnsureBitsAvailable(int count);
    public UInt32 TryLoad16Bits();
    private UInt32 GetBitMask(int count);
    public int GetBits(int count);
    public int CopyTo(Byte[] output, int offset, int length);
    public bool NeedsInput();
    public void SetInput(Byte[] buffer, int offset, int length);
    public void SkipBits(int n);
    public void SkipToByteBoundary();
}
internal class System.IO.Compression.Match : object {
    [CompilerGeneratedAttribute]

private MatchState <State>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]

private byte <Symbol>k__BackingField;
    
internal MatchState State { get; internal set; }
    
internal int Position { get; internal set; }
    
internal int Length { get; internal set; }
    
internal byte Symbol { get; internal set; }
    [CompilerGeneratedAttribute]
internal MatchState get_State();
    [CompilerGeneratedAttribute]
internal void set_State(MatchState value);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(int value);
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(int value);
    [CompilerGeneratedAttribute]
internal byte get_Symbol();
    [CompilerGeneratedAttribute]
internal void set_Symbol(byte value);
}
internal enum System.IO.Compression.MatchState : Enum {
    
public int value__;
    
public static MatchState HasSymbol;
    
public static MatchState HasMatch;
    
public static MatchState HasSymbolAndMatch;
}
internal class System.IO.Compression.OutputBuffer : object {
    
private Byte[] _byteBuffer;
    
private int _pos;
    
private UInt32 _bitBuf;
    
private int _bitCount;
    
internal int BytesWritten { get; }
    
internal int FreeBytes { get; }
    
internal int BitsInBuffer { get; }
    internal void UpdateBuffer(Byte[] output);
    internal int get_BytesWritten();
    internal int get_FreeBytes();
    internal void WriteUInt16(ushort value);
    internal void WriteBits(int n, UInt32 bits);
    internal void FlushBits();
    internal void WriteBytes(Byte[] byteArray, int offset, int count);
    private void WriteBytesUnaligned(Byte[] byteArray, int offset, int count);
    private void WriteByteUnaligned(byte b);
    internal int get_BitsInBuffer();
    internal BufferState DumpState();
    internal void RestoreState(BufferState state);
}
internal class System.IO.Compression.OutputWindow : object {
    
private static int WindowSize;
    
private static int WindowMask;
    
private Byte[] _window;
    
private int _end;
    
private int _bytesUsed;
    
public int FreeBytes { get; }
    
public int AvailableBytes { get; }
    public void Write(byte b);
    public void WriteLengthDistance(int length, int distance);
    public int CopyFrom(InputBuffer input, int length);
    public int get_FreeBytes();
    public int get_AvailableBytes();
    public int CopyTo(Byte[] output, int offset, int length);
}
internal class System.IO.Compression.PositionPreservingWriteOnlyStreamWrapper : Stream {
    
private Stream _stream;
    
private long _position;
    
public bool CanRead { get; }
    
public bool CanSeek { get; }
    
public bool CanWrite { get; }
    
public long Position { get; public set; }
    
public bool CanTimeout { get; }
    
public int ReadTimeout { get; public set; }
    
public int WriteTimeout { get; public set; }
    
public long Length { get; }
    public PositionPreservingWriteOnlyStreamWrapper(Stream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual long get_Length();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
internal class System.IO.Compression.SubReadStream : Stream {
    
private long _startInSuperStream;
    
private long _positionInSuperStream;
    
private long _endInSuperStream;
    
private Stream _superStream;
    
private bool _canRead;
    
private bool _isDisposed;
    
public long Length { get; }
    
public long Position { get; public set; }
    
public bool CanRead { get; }
    
public bool CanSeek { get; }
    
public bool CanWrite { get; }
    public SubReadStream(Stream superStream, long startPosition, long maxLength);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    private void ThrowIfCantRead();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class System.IO.Compression.WrappedStream : Stream {
    
private Stream _baseStream;
    
private bool _closeBaseStream;
    
private Action`1<ZipArchiveEntry> _onClosed;
    
private ZipArchiveEntry _zipArchiveEntry;
    
private bool _isDisposed;
    
public long Length { get; }
    
public long Position { get; public set; }
    
public bool CanRead { get; }
    
public bool CanSeek { get; }
    
public bool CanWrite { get; }
    internal WrappedStream(Stream baseStream, bool closeBaseStream);
    private WrappedStream(Stream baseStream, bool closeBaseStream, ZipArchiveEntry entry, Action`1<ZipArchiveEntry> onClosed);
    internal WrappedStream(Stream baseStream, ZipArchiveEntry entry, Action`1<ZipArchiveEntry> onClosed);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    private void ThrowIfCantRead();
    private void ThrowIfCantWrite();
    private void ThrowIfCantSeek();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
internal class System.IO.Compression.Zip64EndOfCentralDirectoryLocator : ValueType {
    
public static UInt32 SignatureConstant;
    
public static int SizeOfBlockWithoutSignature;
    
public UInt32 NumberOfDiskWithZip64EOCD;
    
public ulong OffsetOfZip64EOCD;
    
public UInt32 TotalNumberOfDisks;
    public static bool TryReadBlock(BinaryReader reader, Zip64EndOfCentralDirectoryLocator& zip64EOCDLocator);
    public static void WriteBlock(Stream stream, long zip64EOCDRecordStart);
}
internal class System.IO.Compression.Zip64EndOfCentralDirectoryRecord : ValueType {
    
private static UInt32 SignatureConstant;
    
private static ulong NormalSize;
    
public ulong SizeOfThisRecord;
    
public ushort VersionMadeBy;
    
public ushort VersionNeededToExtract;
    
public UInt32 NumberOfThisDisk;
    
public UInt32 NumberOfDiskWithStartOfCD;
    
public ulong NumberOfEntriesOnThisDisk;
    
public ulong NumberOfEntriesTotal;
    
public ulong SizeOfCentralDirectory;
    
public ulong OffsetOfCentralDirectory;
    public static bool TryReadBlock(BinaryReader reader, Zip64EndOfCentralDirectoryRecord& zip64EOCDRecord);
    public static void WriteBlock(Stream stream, long numberOfEntries, long startOfCentralDirectory, long sizeOfCentralDirectory);
}
internal class System.IO.Compression.Zip64ExtraField : ValueType {
    
public static int OffsetToFirstField;
    
private static ushort TagConstant;
    
private ushort _size;
    
private Nullable`1<long> _uncompressedSize;
    
private Nullable`1<long> _compressedSize;
    
private Nullable`1<long> _localHeaderOffset;
    
private Nullable`1<int> _startDiskNumber;
    
public ushort TotalSize { get; }
    
public Nullable`1<long> UncompressedSize { get; public set; }
    
public Nullable`1<long> CompressedSize { get; public set; }
    
public Nullable`1<long> LocalHeaderOffset { get; public set; }
    
public Nullable`1<int> StartDiskNumber { get; }
    public ushort get_TotalSize();
    public Nullable`1<long> get_UncompressedSize();
    public void set_UncompressedSize(Nullable`1<long> value);
    public Nullable`1<long> get_CompressedSize();
    public void set_CompressedSize(Nullable`1<long> value);
    public Nullable`1<long> get_LocalHeaderOffset();
    public void set_LocalHeaderOffset(Nullable`1<long> value);
    public Nullable`1<int> get_StartDiskNumber();
    private void UpdateSize();
    public static Zip64ExtraField GetJustZip64Block(Stream extraFieldStream, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber);
    private static bool TryGetZip64BlockFromGenericExtraField(ZipGenericExtraField extraField, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber, Zip64ExtraField& zip64Block);
    public static Zip64ExtraField GetAndRemoveZip64Block(List`1<ZipGenericExtraField> extraFields, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber);
    public static void RemoveZip64Blocks(List`1<ZipGenericExtraField> extraFields);
    public void WriteBlock(Stream stream);
}
public class System.IO.Compression.ZipArchive : object {
    
private Stream _archiveStream;
    
private ZipArchiveEntry _archiveStreamOwner;
    
private BinaryReader _archiveReader;
    
private ZipArchiveMode _mode;
    
private List`1<ZipArchiveEntry> _entries;
    
private ReadOnlyCollection`1<ZipArchiveEntry> _entriesCollection;
    
private Dictionary`2<string, ZipArchiveEntry> _entriesDictionary;
    
private bool _readEntries;
    
private bool _leaveOpen;
    
private long _centralDirectoryStart;
    
private bool _isDisposed;
    
private UInt32 _numberOfThisDisk;
    
private long _expectedNumberOfEntries;
    
private Stream _backingStream;
    
private Byte[] _archiveComment;
    
private Encoding _entryNameEncoding;
    
public ReadOnlyCollection`1<ZipArchiveEntry> Entries { get; }
    
public ZipArchiveMode Mode { get; }
    
internal BinaryReader ArchiveReader { get; }
    
internal Stream ArchiveStream { get; }
    
internal UInt32 NumberOfThisDisk { get; }
    
internal Encoding EntryNameEncoding { get; private set; }
    public ZipArchive(Stream stream);
    public ZipArchive(Stream stream, ZipArchiveMode mode);
    public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen);
    public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen, Encoding entryNameEncoding);
    public ReadOnlyCollection`1<ZipArchiveEntry> get_Entries();
    public ZipArchiveMode get_Mode();
    public ZipArchiveEntry CreateEntry(string entryName);
    public ZipArchiveEntry CreateEntry(string entryName, CompressionLevel compressionLevel);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public ZipArchiveEntry GetEntry(string entryName);
    internal BinaryReader get_ArchiveReader();
    internal Stream get_ArchiveStream();
    internal UInt32 get_NumberOfThisDisk();
    internal Encoding get_EntryNameEncoding();
    private void set_EntryNameEncoding(Encoding value);
    private ZipArchiveEntry DoCreateEntry(string entryName, Nullable`1<CompressionLevel> compressionLevel);
    internal void AcquireArchiveStream(ZipArchiveEntry entry);
    private void AddEntry(ZipArchiveEntry entry);
    [ConditionalAttribute("DEBUG")]
internal void DebugAssertIsStillArchiveStreamOwner(ZipArchiveEntry entry);
    internal void ReleaseArchiveStream(ZipArchiveEntry entry);
    internal void RemoveEntry(ZipArchiveEntry entry);
    internal void ThrowIfDisposed();
    private void CloseStreams();
    private void EnsureCentralDirectoryRead();
    private void Init(Stream stream, ZipArchiveMode mode, bool leaveOpen);
    private void ReadCentralDirectory();
    private void ReadEndOfCentralDirectory();
    private void WriteFile();
    private void WriteArchiveEpilogue(long startOfCentralDirectory, long sizeOfCentralDirectory);
}
public class System.IO.Compression.ZipArchiveEntry : object {
    
private static ushort DefaultVersionToExtract;
    
private static int MaxSingleBufferSize;
    
private ZipArchive _archive;
    
private bool _originallyInArchive;
    
private int _diskNumberStart;
    
private ZipVersionMadeByPlatform _versionMadeByPlatform;
    
private ZipVersionNeededValues _versionMadeBySpecification;
    
private ZipVersionNeededValues _versionToExtract;
    
private BitFlagValues _generalPurposeBitFlag;
    
private CompressionMethodValues _storedCompressionMethod;
    
private DateTimeOffset _lastModified;
    
private long _compressedSize;
    
private long _uncompressedSize;
    
private long _offsetOfLocalHeader;
    
private Nullable`1<long> _storedOffsetOfCompressedData;
    
private UInt32 _crc32;
    
private Byte[][] _compressedBytes;
    
private MemoryStream _storedUncompressedData;
    
private bool _currentlyOpenForWrite;
    
private bool _everOpenedForWrite;
    
private Stream _outstandingWriteStream;
    
private UInt32 _externalFileAttr;
    
private string _storedEntryName;
    
private Byte[] _storedEntryNameBytes;
    
private List`1<ZipGenericExtraField> _cdUnknownExtraFields;
    
private List`1<ZipGenericExtraField> _lhUnknownExtraFields;
    
private Byte[] _fileComment;
    
private Nullable`1<CompressionLevel> _compressionLevel;
    
private static bool s_allowLargeZipArchiveEntriesInUpdateMode;
    
internal static ZipVersionMadeByPlatform CurrentZipPlatform;
    
public ZipArchive Archive { get; }
    [CLSCompliantAttribute("False")]

public UInt32 Crc32 { get; }
    
public long CompressedLength { get; }
    
public int ExternalAttributes { get; public set; }
    
public string FullName { get; private set; }
    
public DateTimeOffset LastWriteTime { get; public set; }
    
public long Length { get; }
    
public string Name { get; }
    
internal bool EverOpenedForWrite { get; }
    
private long OffsetOfCompressedData { get; }
    
private MemoryStream UncompressedData { get; }
    
private CompressionMethodValues CompressionMethod { get; private set; }
    internal ZipArchiveEntry(ZipArchive archive, ZipCentralDirectoryFileHeader cd);
    internal ZipArchiveEntry(ZipArchive archive, string entryName, CompressionLevel compressionLevel);
    internal ZipArchiveEntry(ZipArchive archive, string entryName);
    private static ZipArchiveEntry();
    public ZipArchive get_Archive();
    public UInt32 get_Crc32();
    public long get_CompressedLength();
    public int get_ExternalAttributes();
    public void set_ExternalAttributes(int value);
    public string get_FullName();
    private void set_FullName(string value);
    public DateTimeOffset get_LastWriteTime();
    public void set_LastWriteTime(DateTimeOffset value);
    public long get_Length();
    public string get_Name();
    public void Delete();
    public Stream Open();
    public virtual string ToString();
    internal bool get_EverOpenedForWrite();
    private long get_OffsetOfCompressedData();
    private MemoryStream get_UncompressedData();
    private CompressionMethodValues get_CompressionMethod();
    private void set_CompressionMethod(CompressionMethodValues value);
    private string DecodeEntryName(Byte[] entryNameBytes);
    private Byte[] EncodeEntryName(string entryName, Boolean& isUTF8);
    internal void WriteAndFinishLocalEntry();
    internal void WriteCentralDirectoryFileHeader();
    internal bool LoadLocalHeaderExtraFieldAndCompressedBytesIfNeeded();
    internal void ThrowIfNotOpenable(bool needToUncompress, bool needToLoadIntoMemory);
    private CheckSumAndSizeWriteStream GetDataCompressor(Stream backingStream, bool leaveBackingStreamOpen, EventHandler onClose);
    private Stream GetDataDecompressor(Stream compressedStreamToRead);
    private Stream OpenInReadMode(bool checkOpenable);
    private Stream OpenInWriteMode();
    private Stream OpenInUpdateMode();
    private bool IsOpenable(bool needToUncompress, bool needToLoadIntoMemory, String& message);
    private bool SizesTooLarge();
    private bool WriteLocalFileHeader(bool isEmptyFile);
    private void WriteLocalFileHeaderAndDataIfNeeded();
    private void WriteCrcAndSizesInLocalHeader(bool zip64HeaderUsed);
    private void WriteDataDescriptor();
    private void UnloadStreams();
    private void CloseStreams();
    private void VersionToExtractAtLeast(ZipVersionNeededValues value);
    private void ThrowIfInvalidArchive();
    private static string GetFileName_Windows(string path);
    private static string GetFileName_Unix(string path);
    internal static string ParseFileName(string path, ZipVersionMadeByPlatform madeByPlatform);
}
public enum System.IO.Compression.ZipArchiveMode : Enum {
    
public int value__;
    
public static ZipArchiveMode Read;
    
public static ZipArchiveMode Create;
    
public static ZipArchiveMode Update;
}
internal class System.IO.Compression.ZipCentralDirectoryFileHeader : ValueType {
    
public static UInt32 SignatureConstant;
    
public byte VersionMadeByCompatibility;
    
public byte VersionMadeBySpecification;
    
public ushort VersionNeededToExtract;
    
public ushort GeneralPurposeBitFlag;
    
public ushort CompressionMethod;
    
public UInt32 LastModified;
    
public UInt32 Crc32;
    
public long CompressedSize;
    
public long UncompressedSize;
    
public ushort FilenameLength;
    
public ushort ExtraFieldLength;
    
public ushort FileCommentLength;
    
public int DiskNumberStart;
    
public ushort InternalFileAttributes;
    
public UInt32 ExternalFileAttributes;
    
public long RelativeOffsetOfLocalHeader;
    
public Byte[] Filename;
    
public Byte[] FileComment;
    
public List`1<ZipGenericExtraField> ExtraFields;
    public static bool TryReadBlock(BinaryReader reader, bool saveExtraFieldsAndComments, ZipCentralDirectoryFileHeader& header);
}
internal class System.IO.Compression.ZipEndOfCentralDirectoryBlock : ValueType {
    
public static UInt32 SignatureConstant;
    
public static int SizeOfBlockWithoutSignature;
    
public UInt32 Signature;
    
public ushort NumberOfThisDisk;
    
public ushort NumberOfTheDiskWithTheStartOfTheCentralDirectory;
    
public ushort NumberOfEntriesInTheCentralDirectoryOnThisDisk;
    
public ushort NumberOfEntriesInTheCentralDirectory;
    
public UInt32 SizeOfCentralDirectory;
    
public UInt32 OffsetOfStartOfCentralDirectoryWithRespectToTheStartingDiskNumber;
    
public Byte[] ArchiveComment;
    public static void WriteBlock(Stream stream, long numberOfEntries, long startOfCentralDirectory, long sizeOfCentralDirectory, Byte[] archiveComment);
    public static bool TryReadBlock(BinaryReader reader, ZipEndOfCentralDirectoryBlock& eocdBlock);
}
internal class System.IO.Compression.ZipGenericExtraField : ValueType {
    
private static int SizeOfHeader;
    
private ushort _tag;
    
private ushort _size;
    
private Byte[] _data;
    
public ushort Tag { get; }
    
public ushort Size { get; }
    
public Byte[] Data { get; }
    public ushort get_Tag();
    public ushort get_Size();
    public Byte[] get_Data();
    public void WriteBlock(Stream stream);
    public static bool TryReadBlock(BinaryReader reader, long endExtraField, ZipGenericExtraField& field);
    public static List`1<ZipGenericExtraField> ParseExtraField(Stream extraFieldData);
    public static int TotalSize(List`1<ZipGenericExtraField> fields);
    public static void WriteAllBlocks(List`1<ZipGenericExtraField> fields, Stream stream);
}
[ExtensionAttribute]
internal static class System.IO.Compression.ZipHelper : object {
    
internal static UInt32 Mask32Bit;
    
internal static ushort Mask16Bit;
    
private static int BackwardsSeekingBufferSize;
    
internal static int ValidZipDate_YearMin;
    
internal static int ValidZipDate_YearMax;
    
private static DateTime s_invalidDateIndicator;
    private static ZipHelper();
    internal static bool RequiresUnicode(string test);
    internal static void ReadBytes(Stream stream, Byte[] buffer, int bytesToRead);
    internal static DateTime DosTimeToDateTime(UInt32 dateTime);
    internal static UInt32 DateTimeToDosTime(DateTime dateTime);
    internal static bool SeekBackwardsToSignature(Stream stream, UInt32 signatureToFind);
    [ExtensionAttribute]
internal static void AdvanceToPosition(Stream stream, long position);
    private static bool SeekBackwardsAndRead(Stream stream, Byte[] buffer, Int32& bufferPointer);
}
[IsReadOnlyAttribute]
internal class System.IO.Compression.ZipLocalFileHeader : ValueType {
    
public static UInt32 DataDescriptorSignature;
    
public static UInt32 SignatureConstant;
    
public static int OffsetToCrcFromHeaderStart;
    
public static int OffsetToBitFlagFromHeaderStart;
    
public static int SizeOfLocalHeader;
    public static List`1<ZipGenericExtraField> GetExtraFields(BinaryReader reader);
    public static bool TrySkipBlock(BinaryReader reader);
}
internal enum System.IO.Compression.ZipVersionMadeByPlatform : Enum {
    
public byte value__;
    
public static ZipVersionMadeByPlatform Windows;
    
public static ZipVersionMadeByPlatform Unix;
}
internal enum System.IO.Compression.ZipVersionNeededValues : Enum {
    
public ushort value__;
    
public static ZipVersionNeededValues Default;
    
public static ZipVersionNeededValues ExplicitDirectory;
    
public static ZipVersionNeededValues Deflate;
    
public static ZipVersionNeededValues Deflate64;
    
public static ZipVersionNeededValues Zip64;
}
internal class System.Runtime.CompilerServices.FriendAccessAllowedAttribute : Attribute {
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
