internal static class SR : object {
    internal static string GetString(string name, Object[] args);
    internal static string GetString(CultureInfo culture, string name, Object[] args);
    internal static string GetString(string name);
    internal static string GetString(CultureInfo culture, string name);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
}
internal static class System.LocalAppContextSwitches : object {
    
public static bool DoNotUseTimeZoneInfo;
    
public static bool DoNotUseEcmaScriptV6EscapeControlCharacter;
    private static LocalAppContextSwitches();
}
internal class System.Runtime.CompilerServices.FriendAccessAllowedAttribute : Attribute {
}
internal static class System.Runtime.Serialization.AppSettings : object {
    
internal static string MaxMimePartsAppSettingsString;
    
private static int DefaultMaxMimeParts;
    
private static int maxMimeParts;
    
private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) settingsInitalized;
    
private static object appSettingsLock;
    
internal static int MaxMimeParts { get; }
    private static AppSettings();
    internal static int get_MaxMimeParts();
    private static void EnsureSettingsLoaded();
}
internal class System.Runtime.Serialization.AsmxCharDataContract : CharDataContract {
}
internal class System.Runtime.Serialization.AsmxGuidDataContract : GuidDataContract {
}
internal class System.Runtime.Serialization.AttributeData : object {
    
public string prefix;
    
public string ns;
    
public string localName;
    
public string value;
}
internal class System.Runtime.Serialization.Attributes : object {
    [SecurityCriticalAttribute]

private static XmlDictionaryString[] serializationLocalNames;
    [SecurityCriticalAttribute]

private static XmlDictionaryString[] schemaInstanceLocalNames;
    
internal string Id;
    
internal string Ref;
    
internal string XsiTypeName;
    
internal string XsiTypeNamespace;
    
internal string XsiTypePrefix;
    
internal bool XsiNil;
    
internal string ClrAssembly;
    
internal string ClrType;
    
internal int ArraySZSize;
    
internal string FactoryTypeName;
    
internal string FactoryTypeNamespace;
    
internal string FactoryTypePrefix;
    
internal bool UnrecognizedAttributesFound;
    [SecuritySafeCriticalAttribute]
private static Attributes();
    [SecuritySafeCriticalAttribute]
internal void Read(XmlReaderDelegator reader);
    internal void Reset();
    private void ReadId(XmlReaderDelegator reader);
    private void ReadRef(XmlReaderDelegator reader);
    private void ReadXsiNil(XmlReaderDelegator reader);
    private void ReadArraySize(XmlReaderDelegator reader);
    private void ReadXsiType(XmlReaderDelegator reader);
    private void ReadFactoryType(XmlReaderDelegator reader);
}
internal class System.Runtime.Serialization.BitFlagsGenerator : object {
    
private int bitCount;
    
private Byte[] locals;
    public BitFlagsGenerator(int bitCount);
    public void Store(int bitIndex, bool value);
    public bool Load(int bitIndex);
    public Byte[] LoadArray();
    public int GetLocalCount();
    public int GetBitCount();
    public byte GetLocal(int i);
    public static bool IsBitSet(Byte[] bytes, int bitIndex);
    public static void SetBit(Byte[] bytes, int bitIndex);
    private static int GetByteIndex(int bitIndex);
    private static byte GetBitValue(int bitIndex);
}
internal class System.Runtime.Serialization.BooleanDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.ByteArrayDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.CharDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal CharDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.ClassDataContract : DataContract {
    
public XmlDictionaryString[] ContractNamespaces;
    
public XmlDictionaryString[] MemberNames;
    
public XmlDictionaryString[] MemberNamespaces;
    [SecurityCriticalAttribute]

private XmlDictionaryString[] childElementNamespaces;
    [SecurityCriticalAttribute]

private ClassDataContractCriticalHelper helper;
    
internal ClassDataContract BaseContract { get; internal set; }
    
internal List`1<DataMember> Members { get; internal set; }
    
public XmlDictionaryString[] ChildElementNamespaces { get; }
    
internal MethodInfo OnSerializing { get; }
    
internal MethodInfo OnSerialized { get; }
    
internal MethodInfo OnDeserializing { get; }
    
internal MethodInfo OnDeserialized { get; }
    
internal MethodInfo ExtensionDataSetMethod { get; }
    
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    
internal bool IsISerializable { get; internal set; }
    
internal bool IsNonAttributedType { get; }
    
internal bool HasDataContract { get; }
    
internal bool HasExtensionData { get; }
    
internal string SerializationExceptionMessage { get; }
    
internal string DeserializationExceptionMessage { get; }
    
internal bool IsReadOnlyContract { get; }
    
internal XmlFormatClassWriterDelegate XmlFormatWriterDelegate { get; }
    
internal XmlFormatClassReaderDelegate XmlFormatReaderDelegate { get; }
    [SecuritySafeCriticalAttribute]
internal ClassDataContract(Type type);
    [SecuritySafeCriticalAttribute]
private ClassDataContract(Type type, XmlDictionaryString ns, String[] memberNames);
    [SecurityCriticalAttribute]
private void InitClassDataContract();
    [SecuritySafeCriticalAttribute]
internal ClassDataContract get_BaseContract();
    [SecurityCriticalAttribute]
internal void set_BaseContract(ClassDataContract value);
    [SecuritySafeCriticalAttribute]
internal List`1<DataMember> get_Members();
    [SecurityCriticalAttribute]
internal void set_Members(List`1<DataMember> value);
    [SecuritySafeCriticalAttribute]
public XmlDictionaryString[] get_ChildElementNamespaces();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_OnSerializing();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_OnSerialized();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_OnDeserializing();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_OnDeserialized();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_ExtensionDataSetMethod();
    [SecuritySafeCriticalAttribute]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecurityCriticalAttribute]
internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    [SecuritySafeCriticalAttribute]
internal virtual bool get_IsISerializable();
    [SecurityCriticalAttribute]
internal virtual void set_IsISerializable(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsNonAttributedType();
    [SecuritySafeCriticalAttribute]
internal bool get_HasDataContract();
    [SecuritySafeCriticalAttribute]
internal bool get_HasExtensionData();
    [SecuritySafeCriticalAttribute]
internal string get_SerializationExceptionMessage();
    [SecuritySafeCriticalAttribute]
internal string get_DeserializationExceptionMessage();
    internal bool get_IsReadOnlyContract();
    [SecuritySafeCriticalAttribute]
internal ConstructorInfo GetISerializableConstructor();
    [SecuritySafeCriticalAttribute]
internal ConstructorInfo GetNonAttributedTypeConstructor();
    [SecuritySafeCriticalAttribute]
internal XmlFormatClassWriterDelegate get_XmlFormatWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal XmlFormatClassReaderDelegate get_XmlFormatReaderDelegate();
    internal static ClassDataContract CreateClassDataContractForKeyValue(Type type, XmlDictionaryString ns, String[] memberNames);
    internal static void CheckAndAddMember(List`1<DataMember> members, DataMember memberContract, Dictionary`2<string, DataMember> memberNamesTable);
    internal static XmlDictionaryString GetChildNamespaceToDeclare(DataContract dataContract, Type childType, XmlDictionary dictionary);
    internal static bool IsNonAttributedTypeValidForSerialization(Type type);
    private XmlDictionaryString[] CreateChildElementNamespaces();
    [SecuritySafeCriticalAttribute]
private void EnsureMethodsImported();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    [SecuritySafeCriticalAttribute]
internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    private bool IsEveryDataMemberOptional(IEnumerable`1<DataMember> dataMembers);
    public virtual int GetHashCode();
}
internal class System.Runtime.Serialization.ClassDataNode : DataNode`1<object> {
    
private IList`1<ExtensionDataMember> members;
    
internal IList`1<ExtensionDataMember> Members { get; internal set; }
    internal IList`1<ExtensionDataMember> get_Members();
    internal void set_Members(IList`1<ExtensionDataMember> value);
    public virtual void Clear();
}
internal class System.Runtime.Serialization.CodeExporter : object {
    
private DataContractSet dataContractSet;
    
private CodeCompileUnit codeCompileUnit;
    
private ImportOptions options;
    
private Dictionary`2<string, string> namespaces;
    
private Dictionary`2<string, string> clrNamespaces;
    
private static string wildcardNamespaceMapping;
    
private static string typeNameFieldName;
    
private static object codeUserDataActualTypeKey;
    
private static object surrogateDataKey;
    
private static int MaxIdentifierLength;
    
private bool GenerateSerializableTypes { get; }
    
private bool GenerateInternalTypes { get; }
    
private bool EnableDataBinding { get; }
    
private CodeDomProvider CodeProvider { get; }
    
private bool SupportsDeclareEvents { get; }
    
private bool SupportsDeclareValueTypes { get; }
    
private bool SupportsGenericTypeReference { get; }
    
private bool SupportsAssemblyAttributes { get; }
    
private bool SupportsPartialTypes { get; }
    
private bool SupportsNestedTypes { get; }
    
private string FileExtension { get; }
    
private Dictionary`2<string, string> Namespaces { get; }
    
private Dictionary`2<string, string> ClrNamespaces { get; }
    
private XmlQualifiedName GenericListName { get; }
    
private CollectionDataContract GenericListContract { get; }
    
private XmlQualifiedName GenericDictionaryName { get; }
    
private CollectionDataContract GenericDictionaryContract { get; }
    
private CodeTypeReference CodeTypeIPropertyChange { get; }
    
private CodeThisReferenceExpression ThisReference { get; }
    
private CodePrimitiveExpression NullReference { get; }
    
private CodeParameterDeclarationExpression SerializationInfoParameter { get; }
    
private CodeParameterDeclarationExpression StreamingContextParameter { get; }
    
private CodeAttributeDeclaration SerializableAttribute { get; }
    
private CodeMemberProperty NodeArrayProperty { get; }
    
private CodeMemberField NodeArrayField { get; }
    
private CodeMemberMethod ReadXmlMethod { get; }
    
private CodeMemberMethod WriteXmlMethod { get; }
    
private CodeMemberMethod GetSchemaMethod { get; }
    
private CodeMemberMethod GetSchemaStaticMethod { get; }
    
private CodeConstructor ISerializableBaseConstructor { get; }
    
private CodeConstructor ISerializableDerivedConstructor { get; }
    
private CodeMemberField SerializationInfoField { get; }
    
private CodeMemberProperty SerializationInfoProperty { get; }
    
private CodeMemberMethod GetObjectDataMethod { get; }
    
private CodeMemberField ExtensionDataObjectField { get; }
    
private CodeMemberProperty ExtensionDataObjectProperty { get; }
    
private CodeMemberMethod RaisePropertyChangedEventMethod { get; }
    
private CodeMemberEvent PropertyChangedEvent { get; }
    internal CodeExporter(DataContractSet dataContractSet, ImportOptions options, CodeCompileUnit codeCompileUnit);
    private static CodeExporter();
    private void AddReferencedAssembly(Assembly assembly);
    private bool get_GenerateSerializableTypes();
    private bool get_GenerateInternalTypes();
    private bool get_EnableDataBinding();
    private CodeDomProvider get_CodeProvider();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsDeclareEvents();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsDeclareValueTypes();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsGenericTypeReference();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsAssemblyAttributes();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsPartialTypes();
    [SecuritySafeCriticalAttribute]
private bool get_SupportsNestedTypes();
    [SecuritySafeCriticalAttribute]
private string get_FileExtension();
    private Dictionary`2<string, string> get_Namespaces();
    private Dictionary`2<string, string> get_ClrNamespaces();
    private bool TryGetReferencedType(XmlQualifiedName stableName, DataContract dataContract, Type& type);
    [SecurityCriticalAttribute]
internal void Export();
    private void ExportClassDataContractHierarchy(XmlQualifiedName typeName, ClassDataContract classContract, ContractCodeDomInfo contractCodeDomInfo, Dictionary`2<XmlQualifiedName, object> contractNamesInHierarchy);
    private void InvokeProcessImportedType(CollectionBase collection);
    internal CodeTypeReference GetCodeTypeReference(DataContract dataContract);
    private CodeTypeReference GetCodeTypeReference(Type type);
    internal CodeTypeReference GetElementTypeReference(DataContract dataContract, bool isElementTypeNullable);
    private XmlQualifiedName get_GenericListName();
    private CollectionDataContract get_GenericListContract();
    private XmlQualifiedName get_GenericDictionaryName();
    private CollectionDataContract get_GenericDictionaryContract();
    private ContractCodeDomInfo GetContractCodeDomInfo(DataContract dataContract);
    private void GenerateType(DataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private CodeTypeDeclaration GetNestedType(DataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private static CodeTypeDeclaration CreateTypeDeclaration(string typeName, DataContract dataContract);
    [SecuritySafeCriticalAttribute]
private CodeTypeReference GetReferencedType(DataContract dataContract);
    private CodeTypeReference GetReferencedCollectionType(CollectionDataContract collectionContract);
    private bool HasDefaultCollectionNames(CollectionDataContract collectionContract);
    private bool TryGetReferencedDictionaryType(CollectionDataContract collectionContract, CodeTypeReference& typeReference);
    private bool TryGetReferencedListType(DataContract itemContract, bool isItemTypeNullable, CodeTypeReference& typeReference);
    private CodeTypeReference GetSurrogatedTypeReference(DataContract dataContract);
    private CodeTypeReference GetReferencedGenericType(GenericInfo genInfo, DataContract& dataContract);
    private bool NamespaceContainsType(CodeNamespace ns, string typeName);
    private bool GlobalTypeNameConflicts(string clrNamespace, string typeName);
    private void AddGlobalTypeName(string typeName);
    private bool TypeContainsNestedType(CodeTypeDeclaration containingType, string typeName);
    private string GetNameForAttribute(string name);
    private void AddSerializableAttribute(bool generateSerializable, CodeTypeDeclaration type, ContractCodeDomInfo contractCodeDomInfo);
    private void ExportClassDataContract(ClassDataContract classDataContract, ContractCodeDomInfo contractCodeDomInfo);
    private bool CanDeclareAssemblyAttribute(ContractCodeDomInfo contractCodeDomInfo);
    private bool NeedsExplicitNamespace(string dataContractNamespace, string clrNamespace);
    internal ICollection`1<CodeTypeReference> GetKnownTypeReferences(DataContract dataContract);
    private Dictionary`2<XmlQualifiedName, DataContract> GetKnownTypeContracts(DataContract dataContract);
    private Dictionary`2<XmlQualifiedName, DataContract> GetKnownTypeContracts(ClassDataContract dataContract, Dictionary`2<DataContract, object> handledContracts);
    [SecuritySafeCriticalAttribute]
private void AddKnownTypeContracts(ClassDataContract dataContract, Dictionary`2<XmlQualifiedName, DataContract> knownContracts);
    private void AddKnownTypes(ClassDataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private CodeTypeReference WrapNullable(CodeTypeReference memberType);
    private void AddExtensionData(ContractCodeDomInfo contractCodeDomInfo);
    private void AddPropertyChangedNotifier(ContractCodeDomInfo contractCodeDomInfo, bool isValueType);
    private void ThrowIfReferencedBaseTypeSealed(Type baseType, DataContract dataContract);
    private void ExportEnumDataContract(EnumDataContract enumDataContract, ContractCodeDomInfo contractCodeDomInfo);
    private void ExportISerializableDataContract(ClassDataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private void GenerateKeyValueType(ClassDataContract keyValueContract);
    private void ExportCollectionDataContract(CollectionDataContract collectionContract, ContractCodeDomInfo contractCodeDomInfo);
    private void ExportXmlDataContract(XmlDataContract xmlDataContract, ContractCodeDomInfo contractCodeDomInfo);
    private CodeNamespace GetCodeNamespace(string clrNamespace, string dataContractNamespace, ContractCodeDomInfo contractCodeDomInfo);
    private string GetMemberName(string memberName, ContractCodeDomInfo contractCodeDomInfo);
    private void AddBaseMemberNames(ContractCodeDomInfo baseContractCodeDomInfo, ContractCodeDomInfo contractCodeDomInfo);
    [SecuritySafeCriticalAttribute]
private static string GetClrIdentifier(string identifier, string defaultIdentifier);
    private static string AppendToValidClrIdentifier(string identifier, string appendString);
    private string GetClrNamespace(DataContract dataContract, ContractCodeDomInfo contractCodeDomInfo);
    private void AddNamespacePair(string dataContractNamespace, string clrNamespace);
    private void AddImportStatement(string clrNamespace, CodeNamespace codeNamespace);
    private static string GetClrNamespace(string dataContractNamespace);
    private static void AddToNamespace(StringBuilder builder, string fragment, Dictionary`2<string, object> fragments);
    private static void AddNamespaceFragment(StringBuilder builder, int fragmentOffset, int fragmentLength, Dictionary`2<string, object> fragments);
    private static bool IsValidStart(char c);
    private static bool IsValid(char c);
    private CodeTypeReference get_CodeTypeIPropertyChange();
    private CodeThisReferenceExpression get_ThisReference();
    private CodePrimitiveExpression get_NullReference();
    private CodeParameterDeclarationExpression get_SerializationInfoParameter();
    private CodeParameterDeclarationExpression get_StreamingContextParameter();
    private CodeAttributeDeclaration get_SerializableAttribute();
    private CodeMemberProperty get_NodeArrayProperty();
    private CodeMemberField get_NodeArrayField();
    private CodeMemberMethod get_ReadXmlMethod();
    private CodeMemberMethod get_WriteXmlMethod();
    private CodeMemberMethod get_GetSchemaMethod();
    private CodeMemberMethod get_GetSchemaStaticMethod();
    private CodeConstructor get_ISerializableBaseConstructor();
    private CodeConstructor get_ISerializableDerivedConstructor();
    private CodeMemberField get_SerializationInfoField();
    private CodeMemberProperty get_SerializationInfoProperty();
    private CodeMemberMethod get_GetObjectDataMethod();
    private CodeMemberField get_ExtensionDataObjectField();
    private CodeMemberProperty get_ExtensionDataObjectProperty();
    private CodeMemberMethod get_RaisePropertyChangedEventMethod();
    private CodeMemberEvent get_PropertyChangedEvent();
    private CodeMemberProperty CreateProperty(CodeTypeReference type, string propertyName, string fieldName, bool isValueType);
    private CodeMemberProperty CreateProperty(CodeTypeReference type, string propertyName, string fieldName, bool isValueType, bool raisePropertyChanged);
}
internal static class System.Runtime.Serialization.CodeInterpreter : object {
    internal static object ConvertValue(object arg, Type source, Type target);
    private static bool CanConvert(TypeCode typeCode);
    private static object InternalConvert(object arg, Type source, Type target, bool isAddress);
    public static object GetMember(MemberInfo memberInfo, object instance);
    public static void SetMember(MemberInfo memberInfo, object instance, object value);
}
internal class System.Runtime.Serialization.CollectionDataContract : DataContract {
    [SecurityCriticalAttribute]

private XmlDictionaryString collectionItemName;
    [SecurityCriticalAttribute]

private XmlDictionaryString childElementNamespace;
    [SecurityCriticalAttribute]

private DataContract itemContract;
    [SecurityCriticalAttribute]

private CollectionDataContractCriticalHelper helper;
    
private static Type[] KnownInterfaces { get; }
    
internal CollectionKind Kind { get; }
    
internal Type ItemType { get; }
    
public DataContract ItemContract { get; public set; }
    
internal DataContract SharedTypeContract { get; }
    
internal string ItemName { get; internal set; }
    
public XmlDictionaryString CollectionItemName { get; }
    
internal string KeyName { get; internal set; }
    
internal string ValueName { get; internal set; }
    
internal bool IsDictionary { get; }
    
public XmlDictionaryString ChildElementNamespace { get; }
    
internal bool IsItemTypeNullable { get; internal set; }
    
internal bool IsConstructorCheckRequired { get; internal set; }
    
internal MethodInfo GetEnumeratorMethod { get; }
    
internal MethodInfo AddMethod { get; }
    
internal ConstructorInfo Constructor { get; }
    
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    
internal string InvalidCollectionInSharedContractMessage { get; }
    
internal string SerializationExceptionMessage { get; }
    
internal string DeserializationExceptionMessage { get; }
    
internal bool IsReadOnlyContract { get; }
    
private bool ItemNameSetExplicit { get; }
    
internal XmlFormatCollectionWriterDelegate XmlFormatWriterDelegate { get; }
    
internal XmlFormatCollectionReaderDelegate XmlFormatReaderDelegate { get; }
    
internal XmlFormatGetOnlyCollectionReaderDelegate XmlFormatGetOnlyCollectionReaderDelegate { get; }
    [SecuritySafeCriticalAttribute]
internal CollectionDataContract(CollectionKind kind);
    [SecuritySafeCriticalAttribute]
internal CollectionDataContract(Type type);
    [SecuritySafeCriticalAttribute]
internal CollectionDataContract(Type type, DataContract itemContract);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, string serializationExceptionMessage, string deserializationExceptionMessage);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, MethodInfo addMethod, ConstructorInfo constructor);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract(Type type, CollectionKind kind, Type itemType, MethodInfo getEnumeratorMethod, MethodInfo addMethod, ConstructorInfo constructor, bool isConstructorCheckRequired);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract(Type type, string invalidCollectionInSharedContractMessage);
    [SecurityCriticalAttribute]
private void InitCollectionDataContract(DataContract sharedTypeContract);
    private void InitSharedTypeContract();
    [SecuritySafeCriticalAttribute]
private static Type[] get_KnownInterfaces();
    [SecuritySafeCriticalAttribute]
internal CollectionKind get_Kind();
    [SecuritySafeCriticalAttribute]
internal Type get_ItemType();
    [SecuritySafeCriticalAttribute]
public DataContract get_ItemContract();
    [SecurityCriticalAttribute]
public void set_ItemContract(DataContract value);
    [SecuritySafeCriticalAttribute]
internal DataContract get_SharedTypeContract();
    [SecuritySafeCriticalAttribute]
internal string get_ItemName();
    [SecurityCriticalAttribute]
internal void set_ItemName(string value);
    [SecuritySafeCriticalAttribute]
public XmlDictionaryString get_CollectionItemName();
    [SecuritySafeCriticalAttribute]
internal string get_KeyName();
    [SecurityCriticalAttribute]
internal void set_KeyName(string value);
    [SecuritySafeCriticalAttribute]
internal string get_ValueName();
    [SecurityCriticalAttribute]
internal void set_ValueName(string value);
    internal bool get_IsDictionary();
    [SecuritySafeCriticalAttribute]
public XmlDictionaryString get_ChildElementNamespace();
    [SecuritySafeCriticalAttribute]
internal bool get_IsItemTypeNullable();
    [SecurityCriticalAttribute]
internal void set_IsItemTypeNullable(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsConstructorCheckRequired();
    [SecurityCriticalAttribute]
internal void set_IsConstructorCheckRequired(bool value);
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_GetEnumeratorMethod();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_AddMethod();
    [SecuritySafeCriticalAttribute]
internal ConstructorInfo get_Constructor();
    [SecuritySafeCriticalAttribute]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecurityCriticalAttribute]
internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    [SecuritySafeCriticalAttribute]
internal string get_InvalidCollectionInSharedContractMessage();
    [SecuritySafeCriticalAttribute]
internal string get_SerializationExceptionMessage();
    [SecuritySafeCriticalAttribute]
internal string get_DeserializationExceptionMessage();
    internal bool get_IsReadOnlyContract();
    [SecuritySafeCriticalAttribute]
private bool get_ItemNameSetExplicit();
    [SecuritySafeCriticalAttribute]
internal XmlFormatCollectionWriterDelegate get_XmlFormatWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal XmlFormatCollectionReaderDelegate get_XmlFormatReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal XmlFormatGetOnlyCollectionReaderDelegate get_XmlFormatGetOnlyCollectionReaderDelegate();
    private DataContract GetSharedTypeContract(Type type);
    internal static bool IsCollectionInterface(Type type);
    internal static bool IsCollection(Type type);
    internal static bool IsCollection(Type type, Type& itemType);
    internal static bool IsCollection(Type type, bool constructorRequired, bool skipIfReadOnlyContract);
    private static bool IsCollectionHelper(Type type, Type& itemType, bool constructorRequired, bool skipIfReadOnlyContract);
    internal static bool TryCreate(Type type, DataContract& dataContract);
    internal static bool TryCreateGetOnlyCollectionDataContract(Type type, DataContract& dataContract);
    internal static MethodInfo GetTargetMethodWithName(string name, Type type, Type interfaceType);
    private static bool IsArraySegment(Type t);
    private static bool IsCollectionOrTryCreate(Type type, bool tryCreate, DataContract& dataContract, Type& itemType, bool constructorRequired, bool skipIfReadOnlyContract);
    internal static bool IsCollectionDataContract(Type type);
    private static bool HandleIfInvalidCollection(Type type, bool tryCreate, bool hasCollectionDataContract, bool createContractWithException, string message, string param, DataContract& dataContract);
    private static void GetReadOnlyCollectionExceptionMessages(Type type, bool hasCollectionDataContract, string message, string param, String& serializationExceptionMessage, String& deserializationExceptionMessage);
    private static string GetInvalidCollectionMessage(string message, string nestedMessage, string param);
    private static void FindCollectionMethodsOnInterface(Type type, Type interfaceType, MethodInfo& addMethod, MethodInfo& getEnumeratorMethod);
    private static void GetCollectionMethods(Type type, Type interfaceType, Type[] addMethodTypeArray, bool addMethodOnInterface, MethodInfo& getEnumeratorMethod, MethodInfo& addMethod);
    private static bool IsKnownInterface(Type type);
    [SecuritySafeCriticalAttribute]
internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal virtual DataContract GetValidContract(SerializationMode mode);
    private void ThrowIfInvalid();
    internal virtual DataContract GetValidContract();
    [SecuritySafeCriticalAttribute]
private void CheckConstructor();
    internal virtual bool IsValidContract(SerializationMode mode);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.Serialization.CollectionDataContractAttribute : Attribute {
    
private string name;
    
private string ns;
    
private string itemName;
    
private string keyName;
    
private string valueName;
    
private bool isReference;
    
private bool isNameSetExplicitly;
    
private bool isNamespaceSetExplicitly;
    
private bool isReferenceSetExplicitly;
    
private bool isItemNameSetExplicitly;
    
private bool isKeyNameSetExplicitly;
    
private bool isValueNameSetExplicitly;
    
public string Namespace { get; public set; }
    
public bool IsNamespaceSetExplicitly { get; }
    
public string Name { get; public set; }
    
public bool IsNameSetExplicitly { get; }
    
public string ItemName { get; public set; }
    
public bool IsItemNameSetExplicitly { get; }
    
public string KeyName { get; public set; }
    
public bool IsReference { get; public set; }
    
public bool IsReferenceSetExplicitly { get; }
    
public bool IsKeyNameSetExplicitly { get; }
    
public string ValueName { get; public set; }
    
public bool IsValueNameSetExplicitly { get; }
    public string get_Namespace();
    public void set_Namespace(string value);
    public bool get_IsNamespaceSetExplicitly();
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsNameSetExplicitly();
    public string get_ItemName();
    public void set_ItemName(string value);
    public bool get_IsItemNameSetExplicitly();
    public string get_KeyName();
    public void set_KeyName(string value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_IsReferenceSetExplicitly();
    public bool get_IsKeyNameSetExplicitly();
    public string get_ValueName();
    public void set_ValueName(string value);
    public bool get_IsValueNameSetExplicitly();
}
internal class System.Runtime.Serialization.CollectionDataNode : DataNode`1<Array> {
    
private IList`1<IDataNode> items;
    
private string itemName;
    
private string itemNamespace;
    
private int size;
    
internal IList`1<IDataNode> Items { get; internal set; }
    
internal string ItemName { get; internal set; }
    
internal string ItemNamespace { get; internal set; }
    
internal int Size { get; internal set; }
    internal IList`1<IDataNode> get_Items();
    internal void set_Items(IList`1<IDataNode> value);
    internal string get_ItemName();
    internal void set_ItemName(string value);
    internal string get_ItemNamespace();
    internal void set_ItemNamespace(string value);
    internal int get_Size();
    internal void set_Size(int value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
}
internal enum System.Runtime.Serialization.CollectionKind : Enum {
    
public byte value__;
    
public static CollectionKind None;
    
public static CollectionKind GenericDictionary;
    
public static CollectionKind Dictionary;
    
public static CollectionKind GenericList;
    
public static CollectionKind GenericCollection;
    
public static CollectionKind List;
    
public static CollectionKind GenericEnumerable;
    
public static CollectionKind Collection;
    
public static CollectionKind Enumerable;
    
public static CollectionKind Array;
}
internal static class System.Runtime.Serialization.Configuration.ConfigurationStrings : object {
    
internal static string SectionGroupName;
    
internal static string DefaultCollectionName;
    
internal static string DeclaredTypes;
    
internal static string Index;
    
internal static string Parameter;
    
internal static string Type;
    
internal static string EnableUnsafeTypeForwarding;
    
internal static string DataContractSerializerSectionName;
    
internal static string NetDataContractSerializerSectionName;
    
internal static string DataContractSerializerSectionPath { get; }
    
internal static string NetDataContractSerializerSectionPath { get; }
    private static string GetSectionPath(string sectionName);
    internal static string get_DataContractSerializerSectionPath();
    internal static string get_NetDataContractSerializerSectionPath();
}
public class System.Runtime.Serialization.Configuration.DataContractSerializerSection : ConfigurationSection {
    
private ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("declaredTypes")]

public DeclaredTypeElementCollection DeclaredTypes { get; }
    
protected ConfigurationPropertyCollection Properties { get; }
    [SecurityCriticalAttribute]
internal static DataContractSerializerSection UnsafeGetSection();
    public DeclaredTypeElementCollection get_DeclaredTypes();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Runtime.Serialization.Configuration.DeclaredTypeElement : ConfigurationElement {
    
private ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("")]

public TypeElementCollection KnownTypes { get; }
    [ConfigurationPropertyAttribute("type")]
[DeclaredTypeValidatorAttribute]

public string Type { get; public set; }
    
protected ConfigurationPropertyCollection Properties { get; }
    public DeclaredTypeElement(string typeName);
    public TypeElementCollection get_KnownTypes();
    public string get_Type();
    public void set_Type(string value);
    [SecuritySafeCriticalAttribute]
protected virtual void PostDeserialize();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Runtime.Serialization.Configuration.DeclaredTypeElement")]
public class System.Runtime.Serialization.Configuration.DeclaredTypeElementCollection : ConfigurationElementCollection {
    
public DeclaredTypeElement Item { get; public set; }
    
public DeclaredTypeElement Item { get; public set; }
    public DeclaredTypeElement get_Item(int index);
    public void set_Item(int index, DeclaredTypeElement value);
    public DeclaredTypeElement get_Item(string typeName);
    public void set_Item(string typeName, DeclaredTypeElement value);
    public void Add(DeclaredTypeElement element);
    public void Clear();
    public bool Contains(string typeName);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(DeclaredTypeElement element);
    public void Remove(DeclaredTypeElement element);
    public void Remove(string typeName);
    public void RemoveAt(int index);
}
internal class System.Runtime.Serialization.Configuration.DeclaredTypeValidator : ConfigurationValidatorBase {
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
[AttributeUsageAttribute("128")]
internal class System.Runtime.Serialization.Configuration.DeclaredTypeValidatorAttribute : ConfigurationValidatorAttribute {
    
public ConfigurationValidatorBase ValidatorInstance { get; }
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
}
public class System.Runtime.Serialization.Configuration.NetDataContractSerializerSection : ConfigurationSection {
    
private ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("enableUnsafeTypeForwarding")]

public bool EnableUnsafeTypeForwarding { get; }
    
protected ConfigurationPropertyCollection Properties { get; }
    [SecurityCriticalAttribute]
internal static bool TryUnsafeGetSection(NetDataContractSerializerSection& section);
    public bool get_EnableUnsafeTypeForwarding();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Runtime.Serialization.Configuration.ParameterElement : ConfigurationElement {
    
internal Guid identity;
    
private ConfigurationPropertyCollection properties;
    [ConfigurationPropertyAttribute("index")]
[IntegerValidatorAttribute]

public int Index { get; public set; }
    [ConfigurationPropertyAttribute("")]

public ParameterElementCollection Parameters { get; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]

public string Type { get; public set; }
    
protected ConfigurationPropertyCollection Properties { get; }
    public ParameterElement(string typeName);
    public ParameterElement(int index);
    public int get_Index();
    public void set_Index(int value);
    public ParameterElementCollection get_Parameters();
    protected virtual void PostDeserialize();
    protected virtual void PreSerialize(XmlWriter writer);
    public string get_Type();
    public void set_Type(string value);
    private void Validate();
    internal Type GetType(string rootType, Type[] typeArgs);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Runtime.Serialization.Configuration.ParameterElement")]
public class System.Runtime.Serialization.Configuration.ParameterElementCollection : ConfigurationElementCollection {
    
public ParameterElement Item { get; public set; }
    
public ConfigurationElementCollectionType CollectionType { get; }
    
protected string ElementName { get; }
    public ParameterElement get_Item(int index);
    public void set_Item(int index, ParameterElement value);
    public void Add(ParameterElement element);
    public void Clear();
    public virtual ConfigurationElementCollectionType get_CollectionType();
    public bool Contains(string typeName);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual string get_ElementName();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(ParameterElement element);
    public void Remove(ParameterElement element);
    public void RemoveAt(int index);
}
public class System.Runtime.Serialization.Configuration.SerializationSectionGroup : ConfigurationSectionGroup {
    
public DataContractSerializerSection DataContractSerializer { get; }
    
public NetDataContractSerializerSection NetDataContractSerializer { get; }
    public static SerializationSectionGroup GetSectionGroup(Configuration config);
    public DataContractSerializerSection get_DataContractSerializer();
    public NetDataContractSerializerSection get_NetDataContractSerializer();
}
public class System.Runtime.Serialization.Configuration.TypeElement : ConfigurationElement {
    
private ConfigurationPropertyCollection properties;
    
private string key;
    
protected ConfigurationPropertyCollection Properties { get; }
    
internal string Key { get; }
    [ConfigurationPropertyAttribute("")]

public ParameterElementCollection Parameters { get; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]

public string Type { get; public set; }
    [ConfigurationPropertyAttribute("index")]
[IntegerValidatorAttribute]

public int Index { get; public set; }
    public TypeElement(string typeName);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Key();
    public ParameterElementCollection get_Parameters();
    protected virtual void Reset(ConfigurationElement parentElement);
    public string get_Type();
    public void set_Type(string value);
    public int get_Index();
    public void set_Index(int value);
    internal Type GetType(string rootType, Type[] typeArgs);
    internal static Type GetType(string rootType, Type[] typeArgs, string type, int index, ParameterElementCollection parameters);
}
[ConfigurationCollectionAttribute("System.Runtime.Serialization.Configuration.TypeElement")]
[DefaultMemberAttribute("Item")]
public class System.Runtime.Serialization.Configuration.TypeElementCollection : ConfigurationElementCollection {
    
private static string KnownTypeConfig;
    
public TypeElement Item { get; public set; }
    
public ConfigurationElementCollectionType CollectionType { get; }
    
protected string ElementName { get; }
    public TypeElement get_Item(int index);
    public void set_Item(int index, TypeElement value);
    public void Add(TypeElement element);
    public void Clear();
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual string get_ElementName();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(TypeElement element);
    public void Remove(TypeElement element);
    public void RemoveAt(int index);
}
internal class System.Runtime.Serialization.ContractCodeDomInfo : object {
    
internal bool IsProcessed;
    
internal CodeTypeDeclaration TypeDeclaration;
    
internal CodeTypeReference TypeReference;
    
internal CodeNamespace CodeNamespace;
    
internal bool ReferencedTypeExists;
    
internal bool UsesWildcardNamespace;
    
private string clrNamespace;
    
private Dictionary`2<string, object> memberNames;
    
internal string ClrNamespace { get; internal set; }
    internal string get_ClrNamespace();
    internal void set_ClrNamespace(string value);
    internal Dictionary`2<string, object> GetMemberNames();
}
[AttributeUsageAttribute("3")]
public class System.Runtime.Serialization.ContractNamespaceAttribute : Attribute {
    
private string clrNamespace;
    
private string contractNamespace;
    
public string ClrNamespace { get; public set; }
    
public string ContractNamespace { get; }
    public ContractNamespaceAttribute(string contractNamespace);
    public string get_ClrNamespace();
    public void set_ClrNamespace(string value);
    public string get_ContractNamespace();
}
internal class System.Runtime.Serialization.CreateXmlSerializableDelegate : MulticastDelegate {
    public CreateXmlSerializableDelegate(object object, IntPtr method);
    public virtual IXmlSerializable Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IXmlSerializable EndInvoke(IAsyncResult result);
}
internal abstract class System.Runtime.Serialization.DataContract : object {
    [SecurityCriticalAttribute]

private XmlDictionaryString name;
    [SecurityCriticalAttribute]

private XmlDictionaryString ns;
    [SecurityCriticalAttribute]

private DataContractCriticalHelper helper;
    [SecurityCriticalAttribute]

private static DataContractSerializerSection configSection;
    
protected DataContractCriticalHelper Helper { get; }
    
internal Type UnderlyingType { get; }
    
internal Type OriginalUnderlyingType { get; }
    
internal bool IsBuiltInDataContract { get; }
    
internal Type TypeForInitialization { get; }
    
internal bool IsValueType { get; internal set; }
    
internal bool IsReference { get; internal set; }
    
internal XmlQualifiedName StableName { get; internal set; }
    
internal GenericInfo GenericInfo { get; internal set; }
    
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    
internal bool IsISerializable { get; internal set; }
    
internal XmlDictionaryString Name { get; }
    
public XmlDictionaryString Namespace { get; }
    
internal bool HasRoot { get; internal set; }
    
internal XmlDictionaryString TopLevelElementName { get; internal set; }
    
internal XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    
internal bool CanContainReferences { get; }
    
internal bool IsPrimitive { get; }
    
internal MethodInfo ParseMethod { get; }
    
private static DataContractSerializerSection ConfigSection { get; }
    [SecuritySafeCriticalAttribute]
protected DataContract(DataContractCriticalHelper helper);
    internal static DataContract GetDataContract(Type type);
    internal static DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type, SerializationMode mode);
    internal static DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle, SerializationMode mode);
    [SecuritySafeCriticalAttribute]
internal static DataContract GetDataContractSkipValidation(int id, RuntimeTypeHandle typeHandle, Type type);
    internal static DataContract GetGetOnlyCollectionDataContract(int id, RuntimeTypeHandle typeHandle, Type type, SerializationMode mode);
    [SecuritySafeCriticalAttribute]
internal static DataContract GetGetOnlyCollectionDataContractSkipValidation(int id, RuntimeTypeHandle typeHandle, Type type);
    [SecuritySafeCriticalAttribute]
internal static DataContract GetDataContractForInitialization(int id);
    [SecuritySafeCriticalAttribute]
internal static int GetIdForInitialization(ClassDataContract classContract);
    [SecuritySafeCriticalAttribute]
internal static int GetId(RuntimeTypeHandle typeHandle);
    [SecuritySafeCriticalAttribute]
public static DataContract GetBuiltInDataContract(Type type);
    [SecuritySafeCriticalAttribute]
public static DataContract GetBuiltInDataContract(string name, string ns);
    [SecuritySafeCriticalAttribute]
public static DataContract GetBuiltInDataContract(string typeName);
    [SecuritySafeCriticalAttribute]
internal static string GetNamespace(string key);
    [SecuritySafeCriticalAttribute]
internal static XmlDictionaryString GetClrTypeString(string key);
    [SecuritySafeCriticalAttribute]
internal static void ThrowInvalidDataContractException(string message, Type type);
    [SecurityCriticalAttribute]
protected DataContractCriticalHelper get_Helper();
    [SecuritySafeCriticalAttribute]
internal Type get_UnderlyingType();
    [SecuritySafeCriticalAttribute]
internal Type get_OriginalUnderlyingType();
    [SecuritySafeCriticalAttribute]
internal virtual bool get_IsBuiltInDataContract();
    [SecuritySafeCriticalAttribute]
internal Type get_TypeForInitialization();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    [SecuritySafeCriticalAttribute]
internal bool get_IsValueType();
    [SecurityCriticalAttribute]
internal void set_IsValueType(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsReference();
    [SecurityCriticalAttribute]
internal void set_IsReference(bool value);
    [SecuritySafeCriticalAttribute]
internal XmlQualifiedName get_StableName();
    [SecurityCriticalAttribute]
internal void set_StableName(XmlQualifiedName value);
    [SecuritySafeCriticalAttribute]
internal GenericInfo get_GenericInfo();
    [SecurityCriticalAttribute]
internal void set_GenericInfo(GenericInfo value);
    [SecuritySafeCriticalAttribute]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecurityCriticalAttribute]
internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    [SecuritySafeCriticalAttribute]
internal virtual bool get_IsISerializable();
    [SecurityCriticalAttribute]
internal virtual void set_IsISerializable(bool value);
    [SecuritySafeCriticalAttribute]
internal XmlDictionaryString get_Name();
    [SecuritySafeCriticalAttribute]
public virtual XmlDictionaryString get_Namespace();
    internal virtual bool get_HasRoot();
    internal virtual void set_HasRoot(bool value);
    [SecuritySafeCriticalAttribute]
internal virtual XmlDictionaryString get_TopLevelElementName();
    [SecurityCriticalAttribute]
internal virtual void set_TopLevelElementName(XmlDictionaryString value);
    [SecuritySafeCriticalAttribute]
internal virtual XmlDictionaryString get_TopLevelElementNamespace();
    [SecurityCriticalAttribute]
internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
    internal virtual void WriteRootElement(XmlWriterDelegator writer, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal virtual DataContract GetValidContract(SerializationMode mode);
    internal virtual DataContract GetValidContract();
    internal virtual bool IsValidContract(SerializationMode mode);
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_ParseMethod();
    internal static bool IsTypeSerializable(Type type);
    private static bool IsTypeSerializable(Type type, Dictionary`2<Type, object> previousCollectionTypes);
    private static void ValidatePreviousCollectionTypes(Type collectionType, Type itemType, Dictionary`2<Type, object> previousCollectionTypes);
    internal static Type UnwrapRedundantNullableType(Type type);
    internal static Type UnwrapNullableType(Type type);
    private static bool IsAlpha(char ch);
    private static bool IsDigit(char ch);
    private static bool IsAsciiLocalName(string localName);
    internal static string EncodeLocalName(string localName);
    internal static bool IsValidNCName(string name);
    internal static XmlQualifiedName GetStableName(Type type);
    internal static XmlQualifiedName GetStableName(Type type, Boolean& hasDataContract);
    private static XmlQualifiedName GetStableName(Type type, Dictionary`2<Type, object> previousCollectionTypes, Boolean& hasDataContract);
    private static XmlQualifiedName GetDCTypeStableName(Type type, DataContractAttribute dataContractAttribute);
    private static XmlQualifiedName GetNonDCTypeStableName(Type type, Dictionary`2<Type, object> previousCollectionTypes);
    private static bool TryGetBuiltInXmlAndArrayTypeStableName(Type type, Dictionary`2<Type, object> previousCollectionTypes, XmlQualifiedName& stableName);
    [SecuritySafeCriticalAttribute]
internal static bool TryGetDCAttribute(Type type, DataContractAttribute& dataContractAttribute);
    internal static XmlQualifiedName GetCollectionStableName(Type type, Type itemType, CollectionDataContractAttribute& collectionContractAttribute);
    private static XmlQualifiedName GetCollectionStableName(Type type, Type itemType, Dictionary`2<Type, object> previousCollectionTypes, CollectionDataContractAttribute& collectionContractAttribute);
    private static string GetArrayPrefix(Type& itemType);
    internal XmlQualifiedName GetArrayTypeName(bool isNullable);
    internal static string GetCollectionNamespace(string elementNs);
    internal static XmlQualifiedName GetDefaultStableName(Type type);
    private static string GetDefaultStableLocalName(Type type);
    private static string GetDefaultDataContractNamespace(Type type);
    internal static IList`1<int> GetDataContractNameForGenericName(string typeName, StringBuilder localName);
    internal static bool IsBuiltInNamespace(string ns);
    internal static string GetDefaultStableNamespace(Type type);
    internal static XmlQualifiedName CreateQualifiedName(string localName, string ns);
    internal static string GetDefaultStableNamespace(string clrNs);
    private static void CheckExplicitDataContractNamespaceUri(string dataContractNs, Type type);
    internal static string GetClrTypeFullName(Type type);
    internal static string GetClrAssemblyName(Type type, Boolean& hasTypeForwardedFrom);
    internal static string GetClrTypeFullNameUsingTypeForwardedFromAttribute(Type type);
    private static string GetClrTypeFullNameForArray(Type type);
    private static string GetClrTypeFullNameForNonArrayTypes(Type type);
    internal static void GetClrNameAndNamespace(string fullTypeName, String& localName, String& ns);
    internal static void GetDefaultStableName(string fullTypeName, String& localName, String& ns);
    private static void GetDefaultStableName(CodeTypeReference typeReference, String& localName, String& ns);
    internal static string GetDataContractNamespaceFromUri(string uriString);
    private static string GetGlobalDataContractNamespace(string clrNs, ICustomAttributeProvider customAttribuetProvider);
    private static string GetNamespacesDigest(string namespaces);
    private static string ExpandGenericParameters(string format, Type type);
    internal static string ExpandGenericParameters(string format, IGenericNameProvider genericNameProvider);
    internal static bool IsTypeNullable(Type type);
    public static void ThrowTypeNotSerializable(Type type);
    [SecurityCriticalAttribute]
private static DataContractSerializerSection get_ConfigSection();
    internal static Dictionary`2<XmlQualifiedName, DataContract> ImportKnownTypeAttributes(Type type);
    private static void ImportKnownTypeAttributes(Type type, Dictionary`2<Type, Type> typesChecked, Dictionary`2& knownDataContracts);
    [SecuritySafeCriticalAttribute]
private static void LoadKnownTypesFromConfig(Type type, Dictionary`2<Type, Type> typesChecked, Dictionary`2& knownDataContracts);
    private static void CheckRootTypeInConfigIsGeneric(Type type, Type& rootType, Type[]& genArgs);
    private static bool IsElemTypeNullOrNotEqualToRootType(string elemTypeName, Type rootType);
    private static bool IsCollectionElementTypeEqualToRootType(string collectionElementTypeName, Type rootType);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void CheckAndAdd(Type type, Dictionary`2<Type, Type> typesChecked, Dictionary`2& nameToDataContractTable);
    private static bool IsOpenGenericType(Type t);
    public sealed virtual bool Equals(object other);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    internal bool IsEqualOrChecked(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
    internal void ThrowInvalidDataContractException(string message);
    internal static bool IsTypeVisible(Type t);
}
[AttributeUsageAttribute("28")]
public class System.Runtime.Serialization.DataContractAttribute : Attribute {
    
private string name;
    
private string ns;
    
private bool isNameSetExplicitly;
    
private bool isNamespaceSetExplicitly;
    
private bool isReference;
    
private bool isReferenceSetExplicitly;
    
public bool IsReference { get; public set; }
    
public bool IsReferenceSetExplicitly { get; }
    
public string Namespace { get; public set; }
    
public bool IsNamespaceSetExplicitly { get; }
    
public string Name { get; public set; }
    
public bool IsNameSetExplicitly { get; }
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_IsReferenceSetExplicitly();
    public string get_Namespace();
    public void set_Namespace(string value);
    public bool get_IsNamespaceSetExplicitly();
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsNameSetExplicitly();
}
internal class System.Runtime.Serialization.DataContractPairKey : object {
    
private object object1;
    
private object object2;
    public DataContractPairKey(object object1, object object2);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public abstract class System.Runtime.Serialization.DataContractResolver : object {
    public abstract virtual bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    public abstract virtual Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
}
public class System.Runtime.Serialization.DataContractSerializer : XmlObjectSerializer {
    
private Type rootType;
    
private DataContract rootContract;
    
private bool needsContractNsAtRoot;
    
private XmlDictionaryString rootName;
    
private XmlDictionaryString rootNamespace;
    
private int maxItemsInObjectGraph;
    
private bool ignoreExtensionDataObject;
    
private bool preserveObjectReferences;
    
private IDataContractSurrogate dataContractSurrogate;
    
private ReadOnlyCollection`1<Type> knownTypeCollection;
    
internal IList`1<Type> knownTypeList;
    
internal Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts;
    
private DataContractResolver dataContractResolver;
    
private bool serializeReadOnlyTypes;
    
public ReadOnlyCollection`1<Type> KnownTypes { get; }
    
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    
public int MaxItemsInObjectGraph { get; }
    
public IDataContractSurrogate DataContractSurrogate { get; }
    
public bool PreserveObjectReferences { get; }
    
public bool IgnoreExtensionDataObject { get; }
    
public DataContractResolver DataContractResolver { get; }
    
public bool SerializeReadOnlyTypes { get; }
    
private DataContract RootContract { get; }
    public DataContractSerializer(Type type);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver);
    public DataContractSerializer(Type type, string rootName, string rootNamespace);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver);
    public DataContractSerializer(Type type, DataContractSerializerSettings settings);
    private void Initialize(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver, bool serializeReadOnlyTypes);
    private void Initialize(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, IDataContractSurrogate dataContractSurrogate, DataContractResolver dataContractResolver, bool serializeReadOnlyTypes);
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    public int get_MaxItemsInObjectGraph();
    public IDataContractSurrogate get_DataContractSurrogate();
    public bool get_PreserveObjectReferences();
    public bool get_IgnoreExtensionDataObject();
    public DataContractResolver get_DataContractResolver();
    public bool get_SerializeReadOnlyTypes();
    private DataContract get_RootContract();
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public void WriteObject(XmlDictionaryWriter writer, object graph, DataContractResolver dataContractResolver);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    public object ReadObject(XmlDictionaryReader reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    internal void InternalWriteObjectContent(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    internal static DataContract GetDataContract(DataContract declaredTypeContract, Type declaredType, Type objectType);
    internal void SetDataContractSurrogate(IDataContractSurrogate adapter);
    internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName);
    internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName, DataContractResolver dataContractResolver);
    internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal virtual Type GetSerializeType(object graph);
    internal virtual Type GetDeserializeType();
    internal static object SurrogateToDataContractType(IDataContractSurrogate dataContractSurrogate, object oldObj, Type surrogatedDeclaredType, Type& objType);
    internal static Type GetSurrogatedType(IDataContractSurrogate dataContractSurrogate, Type type);
}
[EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static class System.Runtime.Serialization.DataContractSerializerExtensions : object {
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static ISerializationSurrogateProvider GetSerializationSurrogateProvider(DataContractSerializer serializer);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void SetSerializationSurrogateProvider(DataContractSerializer serializer, ISerializationSurrogateProvider provider);
}
public class System.Runtime.Serialization.DataContractSerializerSettings : object {
    
private int maxItemsInObjectGraph;
    [CompilerGeneratedAttribute]

private XmlDictionaryString <RootName>k__BackingField;
    [CompilerGeneratedAttribute]

private XmlDictionaryString <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]

private IEnumerable`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <IgnoreExtensionDataObject>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <PreserveObjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]

private IDataContractSurrogate <DataContractSurrogate>k__BackingField;
    [CompilerGeneratedAttribute]

private DataContractResolver <DataContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <SerializeReadOnlyTypes>k__BackingField;
    
public XmlDictionaryString RootName { get; public set; }
    
public XmlDictionaryString RootNamespace { get; public set; }
    
public IEnumerable`1<Type> KnownTypes { get; public set; }
    
public int MaxItemsInObjectGraph { get; public set; }
    
public bool IgnoreExtensionDataObject { get; public set; }
    
public bool PreserveObjectReferences { get; public set; }
    
public IDataContractSurrogate DataContractSurrogate { get; public set; }
    
public DataContractResolver DataContractResolver { get; public set; }
    
public bool SerializeReadOnlyTypes { get; public set; }
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_RootName();
    [CompilerGeneratedAttribute]
public void set_RootName(XmlDictionaryString value);
    [CompilerGeneratedAttribute]
public XmlDictionaryString get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(XmlDictionaryString value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExtensionDataObject();
    [CompilerGeneratedAttribute]
public void set_IgnoreExtensionDataObject(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveObjectReferences();
    [CompilerGeneratedAttribute]
public void set_PreserveObjectReferences(bool value);
    [CompilerGeneratedAttribute]
public IDataContractSurrogate get_DataContractSurrogate();
    [CompilerGeneratedAttribute]
public void set_DataContractSurrogate(IDataContractSurrogate value);
    [CompilerGeneratedAttribute]
public DataContractResolver get_DataContractResolver();
    [CompilerGeneratedAttribute]
public void set_DataContractResolver(DataContractResolver value);
    [CompilerGeneratedAttribute]
public bool get_SerializeReadOnlyTypes();
    [CompilerGeneratedAttribute]
public void set_SerializeReadOnlyTypes(bool value);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.DataContractSet : object {
    
private Dictionary`2<XmlQualifiedName, DataContract> contracts;
    
private Dictionary`2<DataContract, object> processedContracts;
    
private IDataContractSurrogate dataContractSurrogate;
    
private Hashtable surrogateDataTable;
    
private Dictionary`2<XmlQualifiedName, DataContract> knownTypesForObject;
    
private ICollection`1<Type> referencedTypes;
    
private ICollection`1<Type> referencedCollectionTypes;
    
private Dictionary`2<XmlQualifiedName, object> referencedTypesDictionary;
    
private Dictionary`2<XmlQualifiedName, object> referencedCollectionTypesDictionary;
    
private Dictionary`2<XmlQualifiedName, DataContract> Contracts { get; }
    
private Dictionary`2<DataContract, object> ProcessedContracts { get; }
    
private Hashtable SurrogateDataTable { get; }
    
internal Dictionary`2<XmlQualifiedName, DataContract> KnownTypesForObject { get; internal set; }
    
public DataContract Item { get; }
    
public IDataContractSurrogate DataContractSurrogate { get; }
    internal DataContractSet(IDataContractSurrogate dataContractSurrogate);
    internal DataContractSet(IDataContractSurrogate dataContractSurrogate, ICollection`1<Type> referencedTypes, ICollection`1<Type> referencedCollectionTypes);
    internal DataContractSet(DataContractSet dataContractSet);
    private Dictionary`2<XmlQualifiedName, DataContract> get_Contracts();
    private Dictionary`2<DataContract, object> get_ProcessedContracts();
    private Hashtable get_SurrogateDataTable();
    internal Dictionary`2<XmlQualifiedName, DataContract> get_KnownTypesForObject();
    internal void set_KnownTypesForObject(Dictionary`2<XmlQualifiedName, DataContract> value);
    internal void Add(Type type);
    internal static void EnsureTypeNotGeneric(Type type);
    private void Add(DataContract dataContract);
    public void Add(XmlQualifiedName name, DataContract dataContract);
    internal void InternalAdd(XmlQualifiedName name, DataContract dataContract);
    private void AddClassDataContract(ClassDataContract classDataContract);
    private void AddCollectionDataContract(CollectionDataContract collectionDataContract);
    private void AddXmlDataContract(XmlDataContract xmlDataContract);
    private void AddKnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts);
    internal XmlQualifiedName GetStableName(Type clrType);
    internal DataContract GetDataContract(Type clrType);
    internal DataContract GetMemberTypeDataContract(DataMember dataMember);
    internal DataContract GetItemTypeDataContract(CollectionDataContract collectionContract);
    internal object GetSurrogateData(object key);
    internal void SetSurrogateData(object key, object surrogateData);
    public DataContract get_Item(XmlQualifiedName key);
    public IDataContractSurrogate get_DataContractSurrogate();
    public bool Remove(XmlQualifiedName key);
    public IEnumerator`1<KeyValuePair`2<XmlQualifiedName, DataContract>> GetEnumerator();
    internal bool IsContractProcessed(DataContract dataContract);
    internal void SetContractProcessed(DataContract dataContract);
    internal ContractCodeDomInfo GetContractCodeDomInfo(DataContract dataContract);
    internal void SetContractCodeDomInfo(DataContract dataContract, ContractCodeDomInfo info);
    private Dictionary`2<XmlQualifiedName, object> GetReferencedTypes();
    private Dictionary`2<XmlQualifiedName, object> GetReferencedCollectionTypes();
    private void AddReferencedType(Dictionary`2<XmlQualifiedName, object> referencedTypes, Type type);
    internal bool TryGetReferencedType(XmlQualifiedName stableName, DataContract dataContract, Type& type);
    internal bool TryGetReferencedCollectionType(XmlQualifiedName stableName, DataContract dataContract, Type& type);
    private bool TryGetReferencedType(XmlQualifiedName stableName, DataContract dataContract, bool useReferencedCollectionTypes, Type& type);
    private static bool IsTypeReferenceable(Type type);
}
internal static class System.Runtime.Serialization.DataContractSurrogateCaller : object {
    internal static Type GetDataContractType(IDataContractSurrogate surrogate, Type type);
    internal static object GetObjectToSerialize(IDataContractSurrogate surrogate, object obj, Type objType, Type membertype);
    internal static object GetDeserializedObject(IDataContractSurrogate surrogate, object obj, Type objType, Type memberType);
    internal static object GetCustomDataToExport(IDataContractSurrogate surrogate, MemberInfo memberInfo, Type dataContractType);
    internal static object GetCustomDataToExport(IDataContractSurrogate surrogate, Type clrType, Type dataContractType);
    internal static void GetKnownCustomDataTypes(IDataContractSurrogate surrogate, Collection`1<Type> customDataTypes);
    internal static Type GetReferencedTypeOnImport(IDataContractSurrogate surrogate, string typeName, string typeNamespace, object customData);
    internal static CodeTypeDeclaration ProcessImportedType(IDataContractSurrogate surrogate, CodeTypeDeclaration typeDeclaration, CodeCompileUnit compileUnit);
}
internal class System.Runtime.Serialization.DataMember : object {
    [SecurityCriticalAttribute]

private CriticalHelper helper;
    
internal MemberInfo MemberInfo { get; }
    
internal string Name { get; internal set; }
    
internal int Order { get; internal set; }
    
internal bool IsRequired { get; internal set; }
    
internal bool EmitDefaultValue { get; internal set; }
    
internal bool IsNullable { get; internal set; }
    
internal bool IsGetOnlyCollection { get; internal set; }
    
internal Type MemberType { get; }
    
internal DataContract MemberTypeContract { get; internal set; }
    
internal bool HasConflictingNameAndType { get; internal set; }
    
internal DataMember ConflictingMember { get; internal set; }
    [SecuritySafeCriticalAttribute]
internal DataMember(MemberInfo memberInfo);
    [SecuritySafeCriticalAttribute]
internal DataMember(string name);
    [SecuritySafeCriticalAttribute]
internal DataMember(DataContract memberTypeContract, string name, bool isNullable, bool isRequired, bool emitDefaultValue, int order);
    [SecuritySafeCriticalAttribute]
internal MemberInfo get_MemberInfo();
    [SecuritySafeCriticalAttribute]
internal string get_Name();
    [SecurityCriticalAttribute]
internal void set_Name(string value);
    [SecuritySafeCriticalAttribute]
internal int get_Order();
    [SecurityCriticalAttribute]
internal void set_Order(int value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsRequired();
    [SecurityCriticalAttribute]
internal void set_IsRequired(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_EmitDefaultValue();
    [SecurityCriticalAttribute]
internal void set_EmitDefaultValue(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsNullable();
    [SecurityCriticalAttribute]
internal void set_IsNullable(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsGetOnlyCollection();
    [SecurityCriticalAttribute]
internal void set_IsGetOnlyCollection(bool value);
    [SecuritySafeCriticalAttribute]
internal Type get_MemberType();
    [SecuritySafeCriticalAttribute]
internal DataContract get_MemberTypeContract();
    [SecurityCriticalAttribute]
internal void set_MemberTypeContract(DataContract value);
    [SecuritySafeCriticalAttribute]
internal bool get_HasConflictingNameAndType();
    [SecurityCriticalAttribute]
internal void set_HasConflictingNameAndType(bool value);
    [SecuritySafeCriticalAttribute]
internal DataMember get_ConflictingMember();
    [SecurityCriticalAttribute]
internal void set_ConflictingMember(DataMember value);
    internal DataMember BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
    internal bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("384")]
public class System.Runtime.Serialization.DataMemberAttribute : Attribute {
    
private string name;
    
private bool isNameSetExplicitly;
    
private int order;
    
private bool isRequired;
    
private bool emitDefaultValue;
    
public string Name { get; public set; }
    
public bool IsNameSetExplicitly { get; }
    
public int Order { get; public set; }
    
public bool IsRequired { get; public set; }
    
public bool EmitDefaultValue { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsNameSetExplicitly();
    public int get_Order();
    public void set_Order(int value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public bool get_EmitDefaultValue();
    public void set_EmitDefaultValue(bool value);
}
internal class System.Runtime.Serialization.DataNode`1 : object {
    
protected Type dataType;
    
private T value;
    
private string dataContractName;
    
private string dataContractNamespace;
    
private string clrTypeName;
    
private string clrAssemblyName;
    
private string id;
    
private bool isFinalValue;
    
public Type DataType { get; }
    
public object Value { get; public set; }
    
private bool System.Runtime.Serialization.IDataNode.IsFinalValue { get; private set; }
    
public string DataContractName { get; public set; }
    
public string DataContractNamespace { get; public set; }
    
public string ClrTypeName { get; public set; }
    
public string ClrAssemblyName { get; public set; }
    
public bool PreservesReferences { get; }
    
public string Id { get; public set; }
    internal DataNode`1(T value);
    public sealed virtual Type get_DataType();
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    private sealed virtual override bool System.Runtime.Serialization.IDataNode.get_IsFinalValue();
    private sealed virtual override void System.Runtime.Serialization.IDataNode.set_IsFinalValue(bool value);
    public T GetValue();
    public sealed virtual string get_DataContractName();
    public sealed virtual void set_DataContractName(string value);
    public sealed virtual string get_DataContractNamespace();
    public sealed virtual void set_DataContractNamespace(string value);
    public sealed virtual string get_ClrTypeName();
    public sealed virtual void set_ClrTypeName(string value);
    public sealed virtual string get_ClrAssemblyName();
    public sealed virtual void set_ClrAssemblyName(string value);
    public sealed virtual bool get_PreservesReferences();
    public sealed virtual string get_Id();
    public sealed virtual void set_Id(string value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
    internal void AddQualifiedNameAttribute(ElementData element, string elementPrefix, string elementName, string elementNs, string valueName, string valueNs);
}
internal class System.Runtime.Serialization.DateDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.DateTimeDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
public class System.Runtime.Serialization.DateTimeFormat : object {
    
private string formatString;
    
private IFormatProvider formatProvider;
    
private DateTimeStyles dateTimeStyles;
    
public string FormatString { get; }
    
public IFormatProvider FormatProvider { get; }
    
public DateTimeStyles DateTimeStyles { get; public set; }
    public DateTimeFormat(string formatString);
    public DateTimeFormat(string formatString, IFormatProvider formatProvider);
    public string get_FormatString();
    public IFormatProvider get_FormatProvider();
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
}
[DataContractAttribute]
internal class System.Runtime.Serialization.DateTimeOffsetAdapter : ValueType {
    
private DateTime utcDateTime;
    
private short offsetMinutes;
    [DataMemberAttribute]

public DateTime UtcDateTime { get; public set; }
    [DataMemberAttribute]

public short OffsetMinutes { get; public set; }
    public DateTimeOffsetAdapter(DateTime dateTime, short offsetMinutes);
    public DateTime get_UtcDateTime();
    public void set_UtcDateTime(DateTime value);
    public short get_OffsetMinutes();
    public void set_OffsetMinutes(short value);
    public static DateTimeOffset GetDateTimeOffset(DateTimeOffsetAdapter value);
    public static DateTimeOffsetAdapter GetDateTimeOffsetAdapter(DateTimeOffset value);
    public string ToString(IFormatProvider provider);
}
internal class System.Runtime.Serialization.DecimalDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.Diagnostics.Application.TD : object {
    
private static ResourceManager resourceManager;
    
private static CultureInfo resourceCulture;
    [SecurityCriticalAttribute]

private static EventDescriptor[] eventDescriptors;
    
private static object syncLock;
    
private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) eventDescriptorsCreated;
    
private static ResourceManager ResourceManager { get; }
    
internal static CultureInfo Culture { get; internal set; }
    private static TD();
    private static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static bool ReaderQuotaExceededIsEnabled();
    internal static void ReaderQuotaExceeded(string param0);
    internal static bool DCSerializeWithSurrogateStartIsEnabled();
    internal static void DCSerializeWithSurrogateStart(string SurrogateType);
    internal static bool DCSerializeWithSurrogateStopIsEnabled();
    internal static void DCSerializeWithSurrogateStop();
    internal static bool DCDeserializeWithSurrogateStartIsEnabled();
    internal static void DCDeserializeWithSurrogateStart(string SurrogateType);
    internal static bool DCDeserializeWithSurrogateStopIsEnabled();
    internal static void DCDeserializeWithSurrogateStop();
    internal static bool ImportKnownTypesStartIsEnabled();
    internal static void ImportKnownTypesStart();
    internal static bool ImportKnownTypesStopIsEnabled();
    internal static void ImportKnownTypesStop();
    internal static bool DCResolverResolveIsEnabled();
    internal static void DCResolverResolve(string TypeName);
    internal static bool DCGenWriterStartIsEnabled();
    internal static void DCGenWriterStart(string Kind, string TypeName);
    internal static bool DCGenWriterStopIsEnabled();
    internal static void DCGenWriterStop();
    internal static bool DCGenReaderStartIsEnabled();
    internal static void DCGenReaderStart(string Kind, string TypeName);
    internal static bool DCGenReaderStopIsEnabled();
    internal static void DCGenReaderStop();
    internal static bool DCJsonGenReaderStartIsEnabled();
    internal static void DCJsonGenReaderStart(string Kind, string TypeName);
    internal static bool DCJsonGenReaderStopIsEnabled();
    internal static void DCJsonGenReaderStop();
    internal static bool DCJsonGenWriterStartIsEnabled();
    internal static void DCJsonGenWriterStart(string Kind, string TypeName);
    internal static bool DCJsonGenWriterStopIsEnabled();
    internal static void DCJsonGenWriterStop();
    internal static bool GenXmlSerializableStartIsEnabled();
    internal static void GenXmlSerializableStart(string DCType);
    internal static bool GenXmlSerializableStopIsEnabled();
    internal static void GenXmlSerializableStop();
    [SecuritySafeCriticalAttribute]
private static void CreateEventDescriptors();
    private static void EnsureEventDescriptors();
    private static bool IsEtwEventEnabled(int eventIndex);
    [SecuritySafeCriticalAttribute]
private static bool WriteEtwEvent(int eventIndex, EventTraceActivity eventParam0, string eventParam1, string eventParam2);
    [SecuritySafeCriticalAttribute]
private static bool WriteEtwEvent(int eventIndex, EventTraceActivity eventParam0, string eventParam1);
    [SecuritySafeCriticalAttribute]
private static bool WriteEtwEvent(int eventIndex, EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3);
}
internal static class System.Runtime.Serialization.Diagnostics.TraceCode : object {
    
public static int Serialization;
    
public static int WriteObjectBegin;
    
public static int WriteObjectEnd;
    
public static int WriteObjectContentBegin;
    
public static int WriteObjectContentEnd;
    
public static int ReadObjectBegin;
    
public static int ReadObjectEnd;
    
public static int ElementIgnored;
    
public static int XsdExportBegin;
    
public static int XsdExportEnd;
    
public static int XsdImportBegin;
    
public static int XsdImportEnd;
    
public static int XsdExportError;
    
public static int XsdImportError;
    
public static int XsdExportAnnotationFailed;
    
public static int XsdImportAnnotationFailed;
    
public static int XsdExportDupItems;
    
public static int FactoryTypeNotFound;
    
public static int ObjectWithLargeDepth;
}
internal static class System.Runtime.Serialization.Diagnostics.TraceUtility : object {
    
private static Dictionary`2<int, string> traceCodes;
    private static TraceUtility();
    internal static void Trace(TraceEventType severity, int traceCode, string traceDescription);
    internal static void Trace(TraceEventType severity, int traceCode, string traceDescription, TraceRecord record);
    internal static void Trace(TraceEventType severity, int traceCode, string traceDescription, TraceRecord record, Exception exception);
}
internal static class System.Runtime.Serialization.DiagnosticUtility : object {
    
internal static bool ShouldTraceError;
    
internal static bool ShouldTraceWarning;
    
internal static bool ShouldTraceInformation;
    
internal static bool ShouldTraceVerbose;
    private static DiagnosticUtility();
}
internal static class System.Runtime.Serialization.DictionaryGlobals : object {
    
public static XmlDictionaryString EmptyString;
    
public static XmlDictionaryString SchemaInstanceNamespace;
    
public static XmlDictionaryString SchemaNamespace;
    
public static XmlDictionaryString SerializationNamespace;
    
public static XmlDictionaryString XmlnsNamespace;
    
public static XmlDictionaryString XsiTypeLocalName;
    
public static XmlDictionaryString XsiNilLocalName;
    
public static XmlDictionaryString ClrTypeLocalName;
    
public static XmlDictionaryString ClrAssemblyLocalName;
    
public static XmlDictionaryString ArraySizeLocalName;
    
public static XmlDictionaryString IdLocalName;
    
public static XmlDictionaryString RefLocalName;
    
public static XmlDictionaryString ISerializableFactoryTypeLocalName;
    
public static XmlDictionaryString CharLocalName;
    
public static XmlDictionaryString BooleanLocalName;
    
public static XmlDictionaryString SignedByteLocalName;
    
public static XmlDictionaryString UnsignedByteLocalName;
    
public static XmlDictionaryString ShortLocalName;
    
public static XmlDictionaryString UnsignedShortLocalName;
    
public static XmlDictionaryString IntLocalName;
    
public static XmlDictionaryString UnsignedIntLocalName;
    
public static XmlDictionaryString LongLocalName;
    
public static XmlDictionaryString UnsignedLongLocalName;
    
public static XmlDictionaryString FloatLocalName;
    
public static XmlDictionaryString DoubleLocalName;
    
public static XmlDictionaryString DecimalLocalName;
    
public static XmlDictionaryString DateTimeLocalName;
    
public static XmlDictionaryString StringLocalName;
    
public static XmlDictionaryString ByteArrayLocalName;
    
public static XmlDictionaryString ObjectLocalName;
    
public static XmlDictionaryString TimeSpanLocalName;
    
public static XmlDictionaryString GuidLocalName;
    
public static XmlDictionaryString UriLocalName;
    
public static XmlDictionaryString QNameLocalName;
    
public static XmlDictionaryString Space;
    
public static XmlDictionaryString timeLocalName;
    
public static XmlDictionaryString dateLocalName;
    
public static XmlDictionaryString hexBinaryLocalName;
    
public static XmlDictionaryString gYearMonthLocalName;
    
public static XmlDictionaryString gYearLocalName;
    
public static XmlDictionaryString gMonthDayLocalName;
    
public static XmlDictionaryString gDayLocalName;
    
public static XmlDictionaryString gMonthLocalName;
    
public static XmlDictionaryString integerLocalName;
    
public static XmlDictionaryString positiveIntegerLocalName;
    
public static XmlDictionaryString negativeIntegerLocalName;
    
public static XmlDictionaryString nonPositiveIntegerLocalName;
    
public static XmlDictionaryString nonNegativeIntegerLocalName;
    
public static XmlDictionaryString normalizedStringLocalName;
    
public static XmlDictionaryString tokenLocalName;
    
public static XmlDictionaryString languageLocalName;
    
public static XmlDictionaryString NameLocalName;
    
public static XmlDictionaryString NCNameLocalName;
    
public static XmlDictionaryString XSDIDLocalName;
    
public static XmlDictionaryString IDREFLocalName;
    
public static XmlDictionaryString IDREFSLocalName;
    
public static XmlDictionaryString ENTITYLocalName;
    
public static XmlDictionaryString ENTITIESLocalName;
    
public static XmlDictionaryString NMTOKENLocalName;
    
public static XmlDictionaryString NMTOKENSLocalName;
    
public static XmlDictionaryString AsmxTypesNamespace;
    private static DictionaryGlobals();
}
internal class System.Runtime.Serialization.DoubleDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.ElementData : object {
    
public string localName;
    
public string ns;
    
public string prefix;
    
public int attributeCount;
    
public AttributeData[] attributes;
    
public IDataNode dataNode;
    
public int childElementIndex;
    public void AddAttribute(string prefix, string ns, string name, string value);
    private void GrowAttributesIfNeeded();
}
public enum System.Runtime.Serialization.EmitTypeInformation : Enum {
    
public int value__;
    
public static EmitTypeInformation AsNeeded;
    
public static EmitTypeInformation Always;
    
public static EmitTypeInformation Never;
}
internal class System.Runtime.Serialization.ENTITIESDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.ENTITYDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.EnumDataContract : DataContract {
    [SecurityCriticalAttribute]

private EnumDataContractCriticalHelper helper;
    
internal XmlQualifiedName BaseContractName { get; internal set; }
    
internal List`1<DataMember> Members { get; internal set; }
    
internal List`1<long> Values { get; internal set; }
    
internal bool IsFlags { get; internal set; }
    
internal bool IsULong { get; }
    
private XmlDictionaryString[] ChildElementNames { get; }
    
internal bool CanContainReferences { get; }
    [SecuritySafeCriticalAttribute]
internal EnumDataContract(Type type);
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName GetBaseContractName(Type type);
    [SecuritySafeCriticalAttribute]
internal static Type GetBaseType(XmlQualifiedName baseContractName);
    [SecuritySafeCriticalAttribute]
internal XmlQualifiedName get_BaseContractName();
    [SecurityCriticalAttribute]
internal void set_BaseContractName(XmlQualifiedName value);
    [SecuritySafeCriticalAttribute]
internal List`1<DataMember> get_Members();
    [SecurityCriticalAttribute]
internal void set_Members(List`1<DataMember> value);
    [SecuritySafeCriticalAttribute]
internal List`1<long> get_Values();
    [SecurityCriticalAttribute]
internal void set_Values(List`1<long> value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsFlags();
    [SecurityCriticalAttribute]
internal void set_IsFlags(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsULong();
    [SecuritySafeCriticalAttribute]
private XmlDictionaryString[] get_ChildElementNames();
    internal virtual bool get_CanContainReferences();
    internal void WriteEnumValue(XmlWriterDelegator writer, object value);
    internal object ReadEnumValue(XmlReaderDelegator reader);
    private long ReadEnumValue(string value, int index, int count);
    internal string GetStringFromEnumValue(long value);
    internal long GetEnumValueFromString(string value);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.EnumMemberAttribute : Attribute {
    
private string value;
    
private bool isValueSetExplicitly;
    
public string Value { get; public set; }
    
public bool IsValueSetExplicitly { get; }
    public string get_Value();
    public void set_Value(string value);
    public bool get_IsValueSetExplicitly();
}
public class System.Runtime.Serialization.ExportOptions : object {
    
private Collection`1<Type> knownTypes;
    
private IDataContractSurrogate dataContractSurrogate;
    
public IDataContractSurrogate DataContractSurrogate { get; public set; }
    
public Collection`1<Type> KnownTypes { get; }
    public IDataContractSurrogate get_DataContractSurrogate();
    public void set_DataContractSurrogate(IDataContractSurrogate value);
    internal IDataContractSurrogate GetSurrogate();
    public Collection`1<Type> get_KnownTypes();
}
internal class System.Runtime.Serialization.ExtensionDataMember : object {
    
private string name;
    
private string ns;
    
private IDataNode value;
    
private int memberIndex;
    
public string Name { get; public set; }
    
public string Namespace { get; public set; }
    
public IDataNode Value { get; public set; }
    
public int MemberIndex { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public IDataNode get_Value();
    public void set_Value(IDataNode value);
    public int get_MemberIndex();
    public void set_MemberIndex(int value);
}
public class System.Runtime.Serialization.ExtensionDataObject : object {
    
private IList`1<ExtensionDataMember> members;
    
internal IList`1<ExtensionDataMember> Members { get; internal set; }
    internal IList`1<ExtensionDataMember> get_Members();
    internal void set_Members(IList`1<ExtensionDataMember> value);
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.ExtensionDataReader : XmlReader {
    
private Hashtable cache;
    
private ElementData[] elements;
    
private ElementData element;
    
private ElementData nextElement;
    
private ReadState readState;
    
private ExtensionDataNodeType internalNodeType;
    
private XmlNodeType nodeType;
    
private int depth;
    
private string localName;
    
private string ns;
    
private string prefix;
    
private string value;
    
private int attributeCount;
    
private int attributeIndex;
    
private XmlNodeReader xmlNodeReader;
    
private Queue`1<IDataNode> deserializedDataNodes;
    
private XmlObjectSerializerReadContext context;
    [SecurityCriticalAttribute]

private static Dictionary`2<string, string> nsToPrefixTable;
    [SecurityCriticalAttribute]

private static Dictionary`2<string, string> prefixToNsTable;
    
private bool IsXmlDataNode { get; }
    
public XmlNodeType NodeType { get; }
    
public string LocalName { get; }
    
public string NamespaceURI { get; }
    
public string Prefix { get; }
    
public string Value { get; }
    
public int Depth { get; }
    
public int AttributeCount { get; }
    
public bool EOF { get; }
    
public ReadState ReadState { get; }
    
public bool IsEmptyElement { get; }
    
public bool IsDefault { get; }
    
public char QuoteChar { get; }
    
public XmlSpace XmlSpace { get; }
    
public string XmlLang { get; }
    
public string Item { get; }
    
public string Item { get; }
    
public string Item { get; }
    
public string Name { get; }
    
public bool HasValue { get; }
    
public string BaseURI { get; }
    
public XmlNameTable NameTable { get; }
    [SecuritySafeCriticalAttribute]
private static ExtensionDataReader();
    internal ExtensionDataReader(XmlObjectSerializerReadContext context);
    internal void SetDeserializedValue(object obj);
    internal IDataNode GetCurrentNode();
    internal void SetDataNode(IDataNode dataNode, string name, string ns);
    internal void Reset();
    private bool get_IsXmlDataNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual int get_AttributeCount();
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual char get_QuoteChar();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual void MoveToAttribute(int index);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual bool MoveToAttribute(string name, string namespaceURI);
    public virtual bool MoveToElement();
    private void SetElement();
    [SecuritySafeCriticalAttribute]
public virtual string LookupNamespace(string prefix);
    public virtual void Skip();
    private bool IsElementNode(ExtensionDataNodeType nodeType);
    public virtual void Close();
    public virtual bool Read();
    public virtual string get_Name();
    public virtual bool get_HasValue();
    public virtual string get_BaseURI();
    public virtual XmlNameTable get_NameTable();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual void ResolveEntity();
    public virtual bool ReadAttributeValue();
    private void MoveNext(IDataNode dataNode);
    private void SetNextElement(IDataNode node, string name, string ns, string prefix);
    private void AddDeserializedDataNode(IDataNode node);
    private bool CheckIfNodeHandled(IDataNode node);
    private void MoveNextInClass(ClassDataNode dataNode);
    private void MoveNextInCollection(CollectionDataNode dataNode);
    private void MoveNextInISerializable(ISerializableDataNode dataNode);
    private void MoveNextInXml(XmlDataNode dataNode);
    private void MoveToDeserializedObject(IDataNode dataNode);
    private bool MoveToText(Type type, IDataNode dataNode, bool isTypedNode);
    private void PushElement();
    private void PopElement();
    private void GrowElementsIfNeeded();
    private ElementData GetNextElement();
    [SecuritySafeCriticalAttribute]
internal static string GetPrefix(string ns);
    [SecuritySafeCriticalAttribute]
private static void AddPrefix(string prefix, string ns);
}
internal class System.Runtime.Serialization.FloatDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal static class System.Runtime.Serialization.FxTrace : object {
    
public static bool ShouldTraceError;
    
public static bool ShouldTraceVerbose;
    
public static EtwDiagnosticTrace Trace { get; }
    
public static ExceptionTrace Exception { get; }
    private static FxTrace();
    public static EtwDiagnosticTrace get_Trace();
    public static ExceptionTrace get_Exception();
    public static bool IsEventEnabled(int index);
    public static void UpdateEventDefinitions(EventDescriptor[] ed, UInt16[] events);
}
internal class System.Runtime.Serialization.GDayDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.GenericInfo : object {
    
private string genericTypeName;
    
private XmlQualifiedName stableName;
    
private List`1<GenericInfo> paramGenericInfos;
    
private List`1<int> nestedParamCounts;
    
internal XmlQualifiedName StableName { get; }
    
internal IList`1<GenericInfo> Parameters { get; }
    
public bool ParametersFromBuiltInNamespaces { get; }
    internal GenericInfo(XmlQualifiedName stableName, string genericTypeName);
    internal void Add(GenericInfo actualParamInfo);
    internal void AddToLevel(int level, int count);
    internal XmlQualifiedName GetExpandedStableName();
    internal string GetStableNamespace();
    internal XmlQualifiedName get_StableName();
    internal IList`1<GenericInfo> get_Parameters();
    public sealed virtual int GetParameterCount();
    public sealed virtual IList`1<int> GetNestedParameterCounts();
    public sealed virtual string GetParameterName(int paramIndex);
    public sealed virtual string GetNamespaces();
    public sealed virtual string GetGenericTypeName();
    public sealed virtual bool get_ParametersFromBuiltInNamespaces();
}
internal class System.Runtime.Serialization.GenericNameProvider : object {
    
private string genericTypeName;
    
private Object[] genericParams;
    
private IList`1<int> nestedParamCounts;
    
public bool ParametersFromBuiltInNamespaces { get; }
    internal GenericNameProvider(Type type);
    internal GenericNameProvider(string genericTypeName, Object[] genericParams);
    public sealed virtual int GetParameterCount();
    public sealed virtual IList`1<int> GetNestedParameterCounts();
    public sealed virtual string GetParameterName(int paramIndex);
    public sealed virtual string GetNamespaces();
    public sealed virtual string GetGenericTypeName();
    public sealed virtual bool get_ParametersFromBuiltInNamespaces();
    private XmlQualifiedName GetStableName(int i);
}
internal class System.Runtime.Serialization.GenericParameterDataContract : DataContract {
    [SecurityCriticalAttribute]

private GenericParameterDataContractCriticalHelper helper;
    
internal int ParameterPosition { get; }
    
internal bool IsBuiltInDataContract { get; }
    [SecuritySafeCriticalAttribute]
internal GenericParameterDataContract(Type type);
    [SecuritySafeCriticalAttribute]
internal int get_ParameterPosition();
    internal virtual bool get_IsBuiltInDataContract();
    internal virtual DataContract BindGenericParameters(DataContract[] paramContracts, Dictionary`2<DataContract, DataContract> boundContracts);
}
internal static class System.Runtime.Serialization.Globals : object {
    
internal static BindingFlags ScanAllMembers;
    [SecurityCriticalAttribute]

private static XmlQualifiedName idQualifiedName;
    [SecurityCriticalAttribute]

private static XmlQualifiedName refQualifiedName;
    [SecurityCriticalAttribute]

private static Type typeOfObject;
    [SecurityCriticalAttribute]

private static Type typeOfValueType;
    [SecurityCriticalAttribute]

private static Type typeOfArray;
    [SecurityCriticalAttribute]

private static Type typeOfString;
    [SecurityCriticalAttribute]

private static Type typeOfInt;
    [SecurityCriticalAttribute]

private static Type typeOfULong;
    [SecurityCriticalAttribute]

private static Type typeOfVoid;
    [SecurityCriticalAttribute]

private static Type typeOfByteArray;
    [SecurityCriticalAttribute]

private static Type typeOfTimeSpan;
    [SecurityCriticalAttribute]

private static Type typeOfGuid;
    [SecurityCriticalAttribute]

private static Type typeOfDateTimeOffset;
    [SecurityCriticalAttribute]

private static Type typeOfDateTimeOffsetAdapter;
    [SecurityCriticalAttribute]

private static Type typeOfUri;
    [SecurityCriticalAttribute]

private static Type typeOfTypeEnumerable;
    [SecurityCriticalAttribute]

private static Type typeOfStreamingContext;
    [SecurityCriticalAttribute]

private static Type typeOfISerializable;
    [SecurityCriticalAttribute]

private static Type typeOfIDeserializationCallback;
    [SecurityCriticalAttribute]

private static Type typeOfIObjectReference;
    [SecurityCriticalAttribute]

private static Type typeOfXmlFormatClassWriterDelegate;
    [SecurityCriticalAttribute]

private static Type typeOfXmlFormatCollectionWriterDelegate;
    [SecurityCriticalAttribute]

private static Type typeOfXmlFormatClassReaderDelegate;
    [SecurityCriticalAttribute]

private static Type typeOfXmlFormatCollectionReaderDelegate;
    [SecurityCriticalAttribute]

private static Type typeOfXmlFormatGetOnlyCollectionReaderDelegate;
    [SecurityCriticalAttribute]

private static Type typeOfKnownTypeAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfDataContractAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfContractNamespaceAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfDataMemberAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfEnumMemberAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfCollectionDataContractAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfOptionalFieldAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfObjectArray;
    [SecurityCriticalAttribute]

private static Type typeOfOnSerializingAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfOnSerializedAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfOnDeserializingAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfOnDeserializedAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfFlagsAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfSerializableAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfNonSerializedAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfSerializationInfo;
    [SecurityCriticalAttribute]

private static Type typeOfSerializationInfoEnumerator;
    [SecurityCriticalAttribute]

private static Type typeOfSerializationEntry;
    [SecurityCriticalAttribute]

private static Type typeOfIXmlSerializable;
    [SecurityCriticalAttribute]

private static Type typeOfXmlSchemaProviderAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfXmlRootAttribute;
    [SecurityCriticalAttribute]

private static Type typeOfXmlQualifiedName;
    [SecurityCriticalAttribute]

private static Type typeOfXmlSchemaType;
    [SecurityCriticalAttribute]

private static Type typeOfXmlSerializableServices;
    [SecurityCriticalAttribute]

private static Type typeOfXmlNodeArray;
    [SecurityCriticalAttribute]

private static Type typeOfXmlSchemaSet;
    [SecurityCriticalAttribute]

private static Object[] emptyObjectArray;
    [SecurityCriticalAttribute]

private static Type[] emptyTypeArray;
    [SecurityCriticalAttribute]

private static Type typeOfIPropertyChange;
    [SecurityCriticalAttribute]

private static Type typeOfIExtensibleDataObject;
    [SecurityCriticalAttribute]

private static Type typeOfExtensionDataObject;
    [SecurityCriticalAttribute]

private static Type typeOfISerializableDataNode;
    [SecurityCriticalAttribute]

private static Type typeOfClassDataNode;
    [SecurityCriticalAttribute]

private static Type typeOfCollectionDataNode;
    [SecurityCriticalAttribute]

private static Type typeOfXmlDataNode;
    [SecurityCriticalAttribute]

private static Type typeOfNullable;
    [SecurityCriticalAttribute]

private static Type typeOfReflectionPointer;
    [SecurityCriticalAttribute]

private static Type typeOfIDictionaryGeneric;
    [SecurityCriticalAttribute]

private static Type typeOfIDictionary;
    [SecurityCriticalAttribute]

private static Type typeOfIListGeneric;
    [SecurityCriticalAttribute]

private static Type typeOfIList;
    [SecurityCriticalAttribute]

private static Type typeOfICollectionGeneric;
    [SecurityCriticalAttribute]

private static Type typeOfICollection;
    [SecurityCriticalAttribute]

private static Type typeOfIEnumerableGeneric;
    [SecurityCriticalAttribute]

private static Type typeOfIEnumerable;
    [SecurityCriticalAttribute]

private static Type typeOfIEnumeratorGeneric;
    [SecurityCriticalAttribute]

private static Type typeOfIEnumerator;
    [SecurityCriticalAttribute]

private static Type typeOfKeyValuePair;
    [SecurityCriticalAttribute]

private static Type typeOfKeyValue;
    [SecurityCriticalAttribute]

private static Type typeOfIDictionaryEnumerator;
    [SecurityCriticalAttribute]

private static Type typeOfDictionaryEnumerator;
    [SecurityCriticalAttribute]

private static Type typeOfGenericDictionaryEnumerator;
    [SecurityCriticalAttribute]

private static Type typeOfDictionaryGeneric;
    [SecurityCriticalAttribute]

private static Type typeOfHashtable;
    [SecurityCriticalAttribute]

private static Type typeOfListGeneric;
    [SecurityCriticalAttribute]

private static Type typeOfXmlElement;
    [SecurityCriticalAttribute]

private static Type typeOfDBNull;
    [SecurityCriticalAttribute]

private static Uri dataContractXsdBaseNamespaceUri;
    
public static bool DefaultIsRequired;
    
public static bool DefaultEmitDefaultValue;
    
public static int DefaultOrder;
    
public static bool DefaultIsReference;
    
public static string NewObjectId;
    
public static string SimpleSRSInternalsVisiblePattern;
    
public static string FullSRSInternalsVisiblePattern;
    
public static string NullObjectId;
    
public static string Space;
    
public static string OpenBracket;
    
public static string CloseBracket;
    
public static string Comma;
    
public static string XsiPrefix;
    
public static string XsdPrefix;
    
public static string SerPrefix;
    
public static string SerPrefixForSchema;
    
public static string ElementPrefix;
    
public static string DataContractXsdBaseNamespace;
    
public static string DataContractXmlNamespace;
    
public static string SchemaInstanceNamespace;
    
public static string SchemaNamespace;
    
public static string XsiNilLocalName;
    
public static string XsiTypeLocalName;
    
public static string TnsPrefix;
    
public static string OccursUnbounded;
    
public static string AnyTypeLocalName;
    
public static string StringLocalName;
    
public static string IntLocalName;
    
public static string True;
    
public static string False;
    
public static string ArrayPrefix;
    
public static string XmlnsNamespace;
    
public static string XmlnsPrefix;
    
public static string SchemaLocalName;
    
public static string CollectionsNamespace;
    
public static string DefaultClrNamespace;
    
public static string DefaultTypeName;
    
public static string DefaultGeneratedMember;
    
public static string DefaultFieldSuffix;
    
public static string DefaultPropertySuffix;
    
public static string DefaultMemberSuffix;
    
public static string NameProperty;
    
public static string NamespaceProperty;
    
public static string OrderProperty;
    
public static string IsReferenceProperty;
    
public static string IsRequiredProperty;
    
public static string EmitDefaultValueProperty;
    
public static string ClrNamespaceProperty;
    
public static string ItemNameProperty;
    
public static string KeyNameProperty;
    
public static string ValueNameProperty;
    
public static string SerializationInfoPropertyName;
    
public static string SerializationInfoFieldName;
    
public static string NodeArrayPropertyName;
    
public static string NodeArrayFieldName;
    
public static string ExportSchemaMethod;
    
public static string IsAnyProperty;
    
public static string ContextFieldName;
    
public static string GetObjectDataMethodName;
    
public static string GetEnumeratorMethodName;
    
public static string MoveNextMethodName;
    
public static string AddValueMethodName;
    
public static string CurrentPropertyName;
    
public static string ValueProperty;
    
public static string EnumeratorFieldName;
    
public static string SerializationEntryFieldName;
    
public static string ExtensionDataSetMethod;
    
public static string ExtensionDataSetExplicitMethod;
    
public static string ExtensionDataObjectPropertyName;
    
public static string ExtensionDataObjectFieldName;
    
public static string AddMethodName;
    
public static string ParseMethodName;
    
public static string GetCurrentMethodName;
    
public static string SerializationNamespace;
    
public static string ClrTypeLocalName;
    
public static string ClrAssemblyLocalName;
    
public static string IsValueTypeLocalName;
    
public static string EnumerationValueLocalName;
    
public static string SurrogateDataLocalName;
    
public static string GenericTypeLocalName;
    
public static string GenericParameterLocalName;
    
public static string GenericNameAttribute;
    
public static string GenericNamespaceAttribute;
    
public static string GenericParameterNestedLevelAttribute;
    
public static string IsDictionaryLocalName;
    
public static string ActualTypeLocalName;
    
public static string ActualTypeNameAttribute;
    
public static string ActualTypeNamespaceAttribute;
    
public static string DefaultValueLocalName;
    
public static string EmitDefaultValueAttribute;
    
public static string ISerializableFactoryTypeLocalName;
    
public static string IdLocalName;
    
public static string RefLocalName;
    
public static string ArraySizeLocalName;
    
public static string KeyLocalName;
    
public static string ValueLocalName;
    
public static string MscorlibAssemblyName;
    
public static string MscorlibAssemblySimpleName;
    
public static string MscorlibFileName;
    
public static string SerializationSchema;
    
internal static XmlQualifiedName IdQualifiedName { get; }
    
internal static XmlQualifiedName RefQualifiedName { get; }
    
internal static Type TypeOfObject { get; }
    
internal static Type TypeOfValueType { get; }
    
internal static Type TypeOfArray { get; }
    
internal static Type TypeOfString { get; }
    
internal static Type TypeOfInt { get; }
    
internal static Type TypeOfULong { get; }
    
internal static Type TypeOfVoid { get; }
    
internal static Type TypeOfByteArray { get; }
    
internal static Type TypeOfTimeSpan { get; }
    
internal static Type TypeOfGuid { get; }
    
internal static Type TypeOfDateTimeOffset { get; }
    
internal static Type TypeOfDateTimeOffsetAdapter { get; }
    
internal static Type TypeOfUri { get; }
    
internal static Type TypeOfTypeEnumerable { get; }
    
internal static Type TypeOfStreamingContext { get; }
    
internal static Type TypeOfISerializable { get; }
    
internal static Type TypeOfIDeserializationCallback { get; }
    
internal static Type TypeOfIObjectReference { get; }
    
internal static Type TypeOfXmlFormatClassWriterDelegate { get; }
    
internal static Type TypeOfXmlFormatCollectionWriterDelegate { get; }
    
internal static Type TypeOfXmlFormatClassReaderDelegate { get; }
    
internal static Type TypeOfXmlFormatCollectionReaderDelegate { get; }
    
internal static Type TypeOfXmlFormatGetOnlyCollectionReaderDelegate { get; }
    
internal static Type TypeOfKnownTypeAttribute { get; }
    
internal static Type TypeOfDataContractAttribute { get; }
    
internal static Type TypeOfContractNamespaceAttribute { get; }
    
internal static Type TypeOfDataMemberAttribute { get; }
    
internal static Type TypeOfEnumMemberAttribute { get; }
    
internal static Type TypeOfCollectionDataContractAttribute { get; }
    
internal static Type TypeOfOptionalFieldAttribute { get; }
    
internal static Type TypeOfObjectArray { get; }
    
internal static Type TypeOfOnSerializingAttribute { get; }
    
internal static Type TypeOfOnSerializedAttribute { get; }
    
internal static Type TypeOfOnDeserializingAttribute { get; }
    
internal static Type TypeOfOnDeserializedAttribute { get; }
    
internal static Type TypeOfFlagsAttribute { get; }
    
internal static Type TypeOfSerializableAttribute { get; }
    
internal static Type TypeOfNonSerializedAttribute { get; }
    
internal static Type TypeOfSerializationInfo { get; }
    
internal static Type TypeOfSerializationInfoEnumerator { get; }
    
internal static Type TypeOfSerializationEntry { get; }
    
internal static Type TypeOfIXmlSerializable { get; }
    
internal static Type TypeOfXmlSchemaProviderAttribute { get; }
    
internal static Type TypeOfXmlRootAttribute { get; }
    
internal static Type TypeOfXmlQualifiedName { get; }
    
internal static Type TypeOfXmlSchemaType { get; }
    
internal static Type TypeOfXmlSerializableServices { get; }
    
internal static Type TypeOfXmlNodeArray { get; }
    
internal static Type TypeOfXmlSchemaSet { get; }
    
internal static Object[] EmptyObjectArray { get; }
    
internal static Type[] EmptyTypeArray { get; }
    
internal static Type TypeOfIPropertyChange { get; }
    
internal static Type TypeOfIExtensibleDataObject { get; }
    
internal static Type TypeOfExtensionDataObject { get; }
    
internal static Type TypeOfISerializableDataNode { get; }
    
internal static Type TypeOfClassDataNode { get; }
    
internal static Type TypeOfCollectionDataNode { get; }
    
internal static Type TypeOfXmlDataNode { get; }
    
internal static Type TypeOfNullable { get; }
    
internal static Type TypeOfReflectionPointer { get; }
    
internal static Type TypeOfIDictionaryGeneric { get; }
    
internal static Type TypeOfIDictionary { get; }
    
internal static Type TypeOfIListGeneric { get; }
    
internal static Type TypeOfIList { get; }
    
internal static Type TypeOfICollectionGeneric { get; }
    
internal static Type TypeOfICollection { get; }
    
internal static Type TypeOfIEnumerableGeneric { get; }
    
internal static Type TypeOfIEnumerable { get; }
    
internal static Type TypeOfIEnumeratorGeneric { get; }
    
internal static Type TypeOfIEnumerator { get; }
    
internal static Type TypeOfKeyValuePair { get; }
    
internal static Type TypeOfKeyValue { get; }
    
internal static Type TypeOfIDictionaryEnumerator { get; }
    
internal static Type TypeOfDictionaryEnumerator { get; }
    
internal static Type TypeOfGenericDictionaryEnumerator { get; }
    
internal static Type TypeOfDictionaryGeneric { get; }
    
internal static Type TypeOfHashtable { get; }
    
internal static Type TypeOfListGeneric { get; }
    
internal static Type TypeOfXmlElement { get; }
    
internal static Type TypeOfDBNull { get; }
    
internal static Uri DataContractXsdBaseNamespaceUri { get; }
    private static Globals();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_IdQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_RefQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfObject();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfValueType();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfString();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfInt();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfULong();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfVoid();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfByteArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfTimeSpan();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfGuid();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDateTimeOffset();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDateTimeOffsetAdapter();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfUri();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfTypeEnumerable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfStreamingContext();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfISerializable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIDeserializationCallback();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIObjectReference();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatClassWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatCollectionWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatClassReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatCollectionReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlFormatGetOnlyCollectionReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfKnownTypeAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDataContractAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfContractNamespaceAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDataMemberAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfEnumMemberAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfCollectionDataContractAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOptionalFieldAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfObjectArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOnSerializingAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOnSerializedAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOnDeserializingAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfOnDeserializedAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfFlagsAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfSerializableAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfNonSerializedAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfSerializationInfo();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfSerializationInfoEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfSerializationEntry();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIXmlSerializable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlSchemaProviderAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlRootAttribute();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlSchemaType();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlSerializableServices();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlNodeArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlSchemaSet();
    [SecuritySafeCriticalAttribute]
internal static Object[] get_EmptyObjectArray();
    [SecuritySafeCriticalAttribute]
internal static Type[] get_EmptyTypeArray();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIPropertyChange();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIExtensibleDataObject();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfExtensionDataObject();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfISerializableDataNode();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfClassDataNode();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfCollectionDataNode();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlDataNode();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfNullable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfReflectionPointer();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIDictionaryGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIDictionary();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIListGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIList();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfICollectionGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfICollection();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIEnumerableGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIEnumerable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIEnumeratorGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfKeyValuePair();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfKeyValue();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfIDictionaryEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDictionaryEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfGenericDictionaryEnumerator();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDictionaryGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfHashtable();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfListGeneric();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfXmlElement();
    [SecuritySafeCriticalAttribute]
internal static Type get_TypeOfDBNull();
    [SecuritySafeCriticalAttribute]
internal static Uri get_DataContractXsdBaseNamespaceUri();
}
internal class System.Runtime.Serialization.GMonthDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.GMonthDayDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.GuidDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal GuidDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.GYearDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.GYearMonthDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.HexBinaryDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.HybridObjectCache : object {
    
private Dictionary`2<string, object> objectDictionary;
    
private Dictionary`2<string, object> referencedObjectDictionary;
    internal void Add(string id, object obj);
    internal void Remove(string id);
    internal object GetObject(string id);
    internal bool IsObjectReferenced(string id);
}
public interface System.Runtime.Serialization.IDataContractSurrogate {
    public abstract virtual Type GetDataContractType(Type type);
    public abstract virtual object GetObjectToSerialize(object obj, Type targetType);
    public abstract virtual object GetDeserializedObject(object obj, Type targetType);
    public abstract virtual object GetCustomDataToExport(MemberInfo memberInfo, Type dataContractType);
    public abstract virtual object GetCustomDataToExport(Type clrType, Type dataContractType);
    public abstract virtual void GetKnownCustomDataTypes(Collection`1<Type> customDataTypes);
    public abstract virtual Type GetReferencedTypeOnImport(string typeName, string typeNamespace, object customData);
    public abstract virtual CodeTypeDeclaration ProcessImportedType(CodeTypeDeclaration typeDeclaration, CodeCompileUnit compileUnit);
}
internal interface System.Runtime.Serialization.IDataNode {
    
public Type DataType { get; }
    
public object Value { get; public set; }
    
public string DataContractName { get; public set; }
    
public string DataContractNamespace { get; public set; }
    
public string ClrTypeName { get; public set; }
    
public string ClrAssemblyName { get; public set; }
    
public string Id { get; public set; }
    
public bool PreservesReferences { get; }
    
public bool IsFinalValue { get; public set; }
    public abstract virtual Type get_DataType();
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    public abstract virtual string get_DataContractName();
    public abstract virtual void set_DataContractName(string value);
    public abstract virtual string get_DataContractNamespace();
    public abstract virtual void set_DataContractNamespace(string value);
    public abstract virtual string get_ClrTypeName();
    public abstract virtual void set_ClrTypeName(string value);
    public abstract virtual string get_ClrAssemblyName();
    public abstract virtual void set_ClrAssemblyName(string value);
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual bool get_PreservesReferences();
    public abstract virtual void GetData(ElementData element);
    public abstract virtual bool get_IsFinalValue();
    public abstract virtual void set_IsFinalValue(bool value);
    public abstract virtual void Clear();
}
internal class System.Runtime.Serialization.IDDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.IDREFDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.IDREFSDataContract : StringDataContract {
}
public interface System.Runtime.Serialization.IExtensibleDataObject {
    
public ExtensionDataObject ExtensionData { get; public set; }
    public abstract virtual ExtensionDataObject get_ExtensionData();
    public abstract virtual void set_ExtensionData(ExtensionDataObject value);
}
internal interface System.Runtime.Serialization.IGenericNameProvider {
    
public bool ParametersFromBuiltInNamespaces { get; }
    public abstract virtual int GetParameterCount();
    public abstract virtual IList`1<int> GetNestedParameterCounts();
    public abstract virtual string GetParameterName(int paramIndex);
    public abstract virtual string GetNamespaces();
    public abstract virtual string GetGenericTypeName();
    public abstract virtual bool get_ParametersFromBuiltInNamespaces();
}
[AttributeUsageAttribute("384")]
public class System.Runtime.Serialization.IgnoreDataMemberAttribute : Attribute {
}
public class System.Runtime.Serialization.ImportOptions : object {
    
private bool generateSerializable;
    
private bool generateInternal;
    
private bool enableDataBinding;
    
private CodeDomProvider codeProvider;
    
private ICollection`1<Type> referencedTypes;
    
private ICollection`1<Type> referencedCollectionTypes;
    
private IDictionary`2<string, string> namespaces;
    
private bool importXmlType;
    
private IDataContractSurrogate dataContractSurrogate;
    
public bool GenerateSerializable { get; public set; }
    
public bool GenerateInternal { get; public set; }
    
public bool EnableDataBinding { get; public set; }
    
public CodeDomProvider CodeProvider { get; public set; }
    
public ICollection`1<Type> ReferencedTypes { get; }
    
public ICollection`1<Type> ReferencedCollectionTypes { get; }
    
public IDictionary`2<string, string> Namespaces { get; }
    
public bool ImportXmlType { get; public set; }
    
public IDataContractSurrogate DataContractSurrogate { get; public set; }
    public bool get_GenerateSerializable();
    public void set_GenerateSerializable(bool value);
    public bool get_GenerateInternal();
    public void set_GenerateInternal(bool value);
    public bool get_EnableDataBinding();
    public void set_EnableDataBinding(bool value);
    public CodeDomProvider get_CodeProvider();
    public void set_CodeProvider(CodeDomProvider value);
    public ICollection`1<Type> get_ReferencedTypes();
    public ICollection`1<Type> get_ReferencedCollectionTypes();
    public IDictionary`2<string, string> get_Namespaces();
    public bool get_ImportXmlType();
    public void set_ImportXmlType(bool value);
    public IDataContractSurrogate get_DataContractSurrogate();
    public void set_DataContractSurrogate(IDataContractSurrogate value);
}
internal class System.Runtime.Serialization.IntDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.IntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.IntRef : object {
    
private int value;
    
public int Value { get; }
    public IntRef(int value);
    public int get_Value();
}
public class System.Runtime.Serialization.InvalidDataContractException : Exception {
    public InvalidDataContractException(string message);
    public InvalidDataContractException(string message, Exception innerException);
    protected InvalidDataContractException(SerializationInfo info, StreamingContext context);
}
internal class System.Runtime.Serialization.ISerializableDataMember : object {
    
private string name;
    
private IDataNode value;
    
internal string Name { get; internal set; }
    
internal IDataNode Value { get; internal set; }
    internal string get_Name();
    internal void set_Name(string value);
    internal IDataNode get_Value();
    internal void set_Value(IDataNode value);
}
internal class System.Runtime.Serialization.ISerializableDataNode : DataNode`1<object> {
    
private string factoryTypeName;
    
private string factoryTypeNamespace;
    
private IList`1<ISerializableDataMember> members;
    
internal string FactoryTypeName { get; internal set; }
    
internal string FactoryTypeNamespace { get; internal set; }
    
internal IList`1<ISerializableDataMember> Members { get; internal set; }
    internal string get_FactoryTypeName();
    internal void set_FactoryTypeName(string value);
    internal string get_FactoryTypeNamespace();
    internal void set_FactoryTypeNamespace(string value);
    internal IList`1<ISerializableDataMember> get_Members();
    internal void set_Members(IList`1<ISerializableDataMember> value);
    public virtual void GetData(ElementData element);
    public virtual void Clear();
}
public interface System.Runtime.Serialization.ISerializationSurrogateProvider {
    public abstract virtual Type GetSurrogateType(Type type);
    public abstract virtual object GetObjectToSerialize(object obj, Type targetType);
    public abstract virtual object GetDeserializedObject(object obj, Type targetType);
}
internal class System.Runtime.Serialization.Json.ByteArrayHelperWithString : ArrayHelper`2<string, byte> {
    
public static ByteArrayHelperWithString Instance;
    private static ByteArrayHelperWithString();
    internal void WriteArray(XmlWriter writer, Byte[] array, int offset, int count);
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Byte[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Byte[] array, int offset, int count);
    private void ThrowConversionException(string value, string type);
    private byte ToByte(int value);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Runtime.Serialization.Json.DataContractJsonSerializer : XmlObjectSerializer {
    
internal IList`1<Type> knownTypeList;
    
internal Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts;
    
private EmitTypeInformation emitTypeInformation;
    
private IDataContractSurrogate dataContractSurrogate;
    
private bool ignoreExtensionDataObject;
    
private ReadOnlyCollection`1<Type> knownTypeCollection;
    
private int maxItemsInObjectGraph;
    
private DataContract rootContract;
    
private XmlDictionaryString rootName;
    
private bool rootNameRequiresMapping;
    
private Type rootType;
    
private bool serializeReadOnlyTypes;
    
private DateTimeFormat dateTimeFormat;
    
private bool useSimpleDictionaryFormat;
    
public IDataContractSurrogate DataContractSurrogate { get; }
    
public bool IgnoreExtensionDataObject { get; }
    
public ReadOnlyCollection`1<Type> KnownTypes { get; }
    
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    
public int MaxItemsInObjectGraph { get; }
    
internal bool AlwaysEmitTypeInformation { get; }
    
public EmitTypeInformation EmitTypeInformation { get; }
    
public bool SerializeReadOnlyTypes { get; }
    
public DateTimeFormat DateTimeFormat { get; }
    
public bool UseSimpleDictionaryFormat { get; }
    
private DataContract RootContract { get; }
    
private XmlDictionaryString RootName { get; }
    public DataContractJsonSerializer(Type type);
    public DataContractJsonSerializer(Type type, string rootName);
    public DataContractJsonSerializer(Type type, XmlDictionaryString rootName);
    public DataContractJsonSerializer(Type type, IEnumerable`1<Type> knownTypes);
    public DataContractJsonSerializer(Type type, string rootName, IEnumerable`1<Type> knownTypes);
    public DataContractJsonSerializer(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes);
    public DataContractJsonSerializer(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, bool alwaysEmitTypeInformation);
    public DataContractJsonSerializer(Type type, string rootName, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, bool alwaysEmitTypeInformation);
    public DataContractJsonSerializer(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, bool alwaysEmitTypeInformation);
    public DataContractJsonSerializer(Type type, DataContractJsonSerializerSettings settings);
    public IDataContractSurrogate get_DataContractSurrogate();
    public bool get_IgnoreExtensionDataObject();
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    public int get_MaxItemsInObjectGraph();
    internal bool get_AlwaysEmitTypeInformation();
    public EmitTypeInformation get_EmitTypeInformation();
    public bool get_SerializeReadOnlyTypes();
    public DateTimeFormat get_DateTimeFormat();
    public bool get_UseSimpleDictionaryFormat();
    private DataContract get_RootContract();
    private XmlDictionaryString get_RootName();
    public virtual bool IsStartObject(XmlReader reader);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    public virtual object ReadObject(Stream stream);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public virtual object ReadObject(XmlDictionaryReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual void WriteObject(Stream stream, object graph);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    internal static bool CheckIfJsonNameRequiresMapping(string jsonName);
    internal static bool CheckIfJsonNameRequiresMapping(XmlDictionaryString jsonName);
    internal static bool CheckIfXmlNameRequiresMapping(string xmlName);
    internal static bool CheckIfXmlNameRequiresMapping(XmlDictionaryString xmlName);
    internal static string ConvertXmlNameToJsonName(string xmlName);
    internal static XmlDictionaryString ConvertXmlNameToJsonName(XmlDictionaryString xmlName);
    internal static bool IsJsonLocalName(XmlReaderDelegator reader, string elementName);
    internal static object ReadJsonValue(DataContract contract, XmlReaderDelegator reader, XmlObjectSerializerReadContextComplexJson context);
    internal static void WriteJsonNull(XmlWriterDelegator writer);
    internal static void WriteJsonValue(JsonDataContract contract, XmlWriterDelegator writer, object graph, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    internal virtual Type GetDeserializeType();
    internal virtual Type GetSerializeType(object graph);
    internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName);
    internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    private void AddCollectionItemTypeToKnownTypes(Type knownType);
    private void Initialize(Type type, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, EmitTypeInformation emitTypeInformation, bool serializeReadOnlyTypes, DateTimeFormat dateTimeFormat, bool useSimpleDictionaryFormat);
    private void Initialize(Type type, XmlDictionaryString rootName, IEnumerable`1<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, IDataContractSurrogate dataContractSurrogate, EmitTypeInformation emitTypeInformation, bool serializeReadOnlyTypes, DateTimeFormat dateTimeFormat, bool useSimpleDictionaryFormat);
    internal static void CheckIfTypeIsReference(DataContract dataContract);
    internal static DataContract GetDataContract(DataContract declaredTypeContract, Type declaredType, Type objectType);
}
public class System.Runtime.Serialization.Json.DataContractJsonSerializerSettings : object {
    
private int maxItemsInObjectGraph;
    [CompilerGeneratedAttribute]

private string <RootName>k__BackingField;
    [CompilerGeneratedAttribute]

private IEnumerable`1<Type> <KnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <IgnoreExtensionDataObject>k__BackingField;
    [CompilerGeneratedAttribute]

private IDataContractSurrogate <DataContractSurrogate>k__BackingField;
    [CompilerGeneratedAttribute]

private EmitTypeInformation <EmitTypeInformation>k__BackingField;
    [CompilerGeneratedAttribute]

private DateTimeFormat <DateTimeFormat>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <SerializeReadOnlyTypes>k__BackingField;
    [CompilerGeneratedAttribute]

private bool <UseSimpleDictionaryFormat>k__BackingField;
    
public string RootName { get; public set; }
    
public IEnumerable`1<Type> KnownTypes { get; public set; }
    
public int MaxItemsInObjectGraph { get; public set; }
    
public bool IgnoreExtensionDataObject { get; public set; }
    
public IDataContractSurrogate DataContractSurrogate { get; public set; }
    
public EmitTypeInformation EmitTypeInformation { get; public set; }
    
public DateTimeFormat DateTimeFormat { get; public set; }
    
public bool SerializeReadOnlyTypes { get; public set; }
    
public bool UseSimpleDictionaryFormat { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RootName();
    [CompilerGeneratedAttribute]
public void set_RootName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_KnownTypes();
    [CompilerGeneratedAttribute]
public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExtensionDataObject();
    [CompilerGeneratedAttribute]
public void set_IgnoreExtensionDataObject(bool value);
    [CompilerGeneratedAttribute]
public IDataContractSurrogate get_DataContractSurrogate();
    [CompilerGeneratedAttribute]
public void set_DataContractSurrogate(IDataContractSurrogate value);
    [CompilerGeneratedAttribute]
public EmitTypeInformation get_EmitTypeInformation();
    [CompilerGeneratedAttribute]
public void set_EmitTypeInformation(EmitTypeInformation value);
    [CompilerGeneratedAttribute]
public DateTimeFormat get_DateTimeFormat();
    [CompilerGeneratedAttribute]
public void set_DateTimeFormat(DateTimeFormat value);
    [CompilerGeneratedAttribute]
public bool get_SerializeReadOnlyTypes();
    [CompilerGeneratedAttribute]
public void set_SerializeReadOnlyTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseSimpleDictionaryFormat();
    [CompilerGeneratedAttribute]
public void set_UseSimpleDictionaryFormat(bool value);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Runtime.Serialization.Json.IXmlJsonReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Runtime.Serialization.Json.IXmlJsonWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
internal class System.Runtime.Serialization.Json.JsonByteArrayDataContract : JsonDataContract {
    public JsonByteArrayDataContract(ByteArrayDataContract traditionalByteArrayDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonClassDataContract : JsonDataContract {
    [SecurityCriticalAttribute]

private JsonClassDataContractCriticalHelper helper;
    
internal JsonFormatClassReaderDelegate JsonFormatReaderDelegate { get; }
    
internal JsonFormatClassWriterDelegate JsonFormatWriterDelegate { get; }
    
internal XmlDictionaryString[] MemberNames { get; }
    
internal string TypeName { get; }
    
private ClassDataContract TraditionalClassDataContract { get; }
    [SecuritySafeCriticalAttribute]
public JsonClassDataContract(ClassDataContract traditionalDataContract);
    [SecuritySafeCriticalAttribute]
internal JsonFormatClassReaderDelegate get_JsonFormatReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal JsonFormatClassWriterDelegate get_JsonFormatWriterDelegate();
    [SecuritySafeCriticalAttribute]
internal XmlDictionaryString[] get_MemberNames();
    [SecuritySafeCriticalAttribute]
internal virtual string get_TypeName();
    [SecuritySafeCriticalAttribute]
private ClassDataContract get_TraditionalClassDataContract();
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonCollectionDataContract : JsonDataContract {
    [SecurityCriticalAttribute]

private JsonCollectionDataContractCriticalHelper helper;
    
internal JsonFormatCollectionReaderDelegate JsonFormatReaderDelegate { get; }
    
internal JsonFormatGetOnlyCollectionReaderDelegate JsonFormatGetOnlyReaderDelegate { get; }
    
internal JsonFormatCollectionWriterDelegate JsonFormatWriterDelegate { get; }
    
private CollectionDataContract TraditionalCollectionDataContract { get; }
    [SecuritySafeCriticalAttribute]
public JsonCollectionDataContract(CollectionDataContract traditionalDataContract);
    [SecuritySafeCriticalAttribute]
internal JsonFormatCollectionReaderDelegate get_JsonFormatReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal JsonFormatGetOnlyCollectionReaderDelegate get_JsonFormatGetOnlyReaderDelegate();
    [SecuritySafeCriticalAttribute]
internal JsonFormatCollectionWriterDelegate get_JsonFormatWriterDelegate();
    [SecuritySafeCriticalAttribute]
private CollectionDataContract get_TraditionalCollectionDataContract();
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonDataContract : object {
    [SecurityCriticalAttribute]

private JsonDataContractCriticalHelper helper;
    
internal string TypeName { get; }
    
protected JsonDataContractCriticalHelper Helper { get; }
    
protected DataContract TraditionalDataContract { get; }
    
private Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    [SecuritySafeCriticalAttribute]
protected JsonDataContract(DataContract traditionalDataContract);
    [SecuritySafeCriticalAttribute]
protected JsonDataContract(JsonDataContractCriticalHelper helper);
    internal virtual string get_TypeName();
    [SecurityCriticalAttribute]
protected JsonDataContractCriticalHelper get_Helper();
    [SecuritySafeCriticalAttribute]
protected DataContract get_TraditionalDataContract();
    [SecuritySafeCriticalAttribute]
private Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecuritySafeCriticalAttribute]
public static JsonDataContract GetJsonDataContract(DataContract traditionalDataContract);
    public object ReadJsonValue(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public void WriteJsonValue(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    protected static object HandleReadValue(object obj, XmlObjectSerializerReadContext context);
    protected static bool TryReadNullAtTopLevel(XmlReaderDelegator reader);
    protected void PopKnownDataContracts(XmlObjectSerializerContext context);
    protected void PushKnownDataContracts(XmlObjectSerializerContext context);
}
internal class System.Runtime.Serialization.Json.JsonEncodingStreamWrapper : Stream {
    
private static UnicodeEncoding SafeBEUTF16;
    
private static UnicodeEncoding SafeUTF16;
    
private static UTF8Encoding SafeUTF8;
    
private static UnicodeEncoding ValidatingBEUTF16;
    
private static UnicodeEncoding ValidatingUTF16;
    
private static UTF8Encoding ValidatingUTF8;
    
private static int BufferLength;
    
private Byte[] byteBuffer;
    
private int byteCount;
    
private int byteOffset;
    
private Byte[] bytes;
    
private Char[] chars;
    
private Decoder dec;
    
private Encoder enc;
    
private Encoding encoding;
    
private SupportedEncoding encodingCode;
    
private bool isReading;
    
private Stream stream;
    
public bool CanRead { get; }
    
public bool CanSeek { get; }
    
public bool CanTimeout { get; }
    
public bool CanWrite { get; }
    
public long Length { get; }
    
public long Position { get; public set; }
    
public int ReadTimeout { get; public set; }
    
public int WriteTimeout { get; public set; }
    public JsonEncodingStreamWrapper(Stream stream, Encoding encoding, bool isReader);
    private static JsonEncodingStreamWrapper();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public static ArraySegment`1<byte> ProcessBuffer(Byte[] buffer, int offset, int count, Encoding encoding);
    public virtual void Close();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte b);
    private static Encoding GetEncoding(SupportedEncoding e);
    private static string GetEncodingName(SupportedEncoding enc);
    private static SupportedEncoding GetSupportedEncoding(Encoding encoding);
    private static SupportedEncoding ReadEncoding(byte b1, byte b2);
    private static void ThrowExpectedEncodingMismatch(SupportedEncoding expEnc, SupportedEncoding actualEnc);
    private void CleanupCharBreak();
    private void EnsureBuffers();
    private void EnsureByteBuffer();
    private void FillBuffer(int count);
    private void InitForReading(Stream inputStream, Encoding expectedEncoding);
    private void InitForWriting(Stream outputStream, Encoding writeEncoding);
    private SupportedEncoding ReadEncoding();
}
internal class System.Runtime.Serialization.Json.JsonEnumDataContract : JsonDataContract {
    [SecurityCriticalAttribute]

private JsonEnumDataContractCriticalHelper helper;
    
public bool IsULong { get; }
    [SecuritySafeCriticalAttribute]
public JsonEnumDataContract(EnumDataContract traditionalDataContract);
    [SecuritySafeCriticalAttribute]
public bool get_IsULong();
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
}
internal class System.Runtime.Serialization.Json.JsonFormatClassReaderDelegate : MulticastDelegate {
    public JsonFormatClassReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString[] memberNames);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString[] memberNames, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatClassWriterDelegate : MulticastDelegate {
    public JsonFormatClassWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract dataContract, XmlDictionaryString[] memberNames);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract dataContract, XmlDictionaryString[] memberNames, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatCollectionReaderDelegate : MulticastDelegate {
    public JsonFormatCollectionReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatCollectionWriterDelegate : MulticastDelegate {
    public JsonFormatCollectionWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatGetOnlyCollectionReaderDelegate : MulticastDelegate {
    public JsonFormatGetOnlyCollectionReaderDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.Json.JsonFormatReaderGenerator : object {
    [SecurityCriticalAttribute]

private CriticalHelper helper;
    [SecurityCriticalAttribute]
public JsonFormatClassReaderDelegate GenerateClassReader(ClassDataContract classContract);
    [SecurityCriticalAttribute]
public JsonFormatCollectionReaderDelegate GenerateCollectionReader(CollectionDataContract collectionContract);
    [SecurityCriticalAttribute]
public JsonFormatGetOnlyCollectionReaderDelegate GenerateGetOnlyCollectionReader(CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.Json.JsonFormatReaderInterpreter : object {
    
private bool is_get_only_collection;
    
private ClassDataContract classContract;
    
private CollectionDataContract collectionContract;
    
private object objectLocal;
    
private Type objectType;
    
private XmlReaderDelegator xmlReader;
    
private XmlObjectSerializerReadContextComplexJson context;
    
private XmlDictionaryString[] memberNames;
    
private XmlDictionaryString emptyDictionaryString;
    
private XmlDictionaryString itemName;
    
private XmlDictionaryString itemNamespace;
    public JsonFormatReaderInterpreter(ClassDataContract classContract);
    public JsonFormatReaderInterpreter(CollectionDataContract collectionContract, bool isGetOnly);
    public object ReadFromJson(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString[] memberNames);
    public object ReadCollectionFromJson(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    public void ReadGetOnlyCollectionFromJson(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContextComplexJson context, XmlDictionaryString emptyDictionaryString, XmlDictionaryString itemName, CollectionDataContract collectionContract);
    private void CreateObject(ClassDataContract classContract);
    private void InvokeOnDeserializing(ClassDataContract classContract);
    private void InvokeOnDeserialized(ClassDataContract classContract);
    private bool HasFactoryMethod(ClassDataContract classContract);
    private bool InvokeFactoryMethod(ClassDataContract classContract);
    private void ReadISerializable(ClassDataContract classContract);
    private void ReadClass(ClassDataContract classContract);
    private void ReadMembers(ClassDataContract classContract, ExtensionDataObject extensionData);
    private int ReadMembers(int index, ClassDataContract classContract, BitFlagsGenerator expectedElements, Int32& memberIndex);
    private bool CheckRequiredElements(BitFlagsGenerator expectedElements, Byte[] requiredElements);
    private int SetRequiredElements(ClassDataContract contract, Byte[] requiredElements);
    private void SetExpectedElements(BitFlagsGenerator expectedElements, int startIndex);
    private void ResetExpectedElements(BitFlagsGenerator expectedElements, int index);
    private object ReadValue(Type type, string name);
    private object InternalDeserialize(Type type, string name);
    private object WrapNullableObject(Type innerType, object innerValue, Type outerType, int nullables);
    private void ReadCollection(CollectionDataContract collectionContract);
    private void ReadSimpleDictionary(CollectionDataContract collectionContract, Type keyValueType);
    private void ReadGetOnlyCollection(CollectionDataContract collectionContract);
    private bool TryReadPrimitiveArray(Type itemType, Boolean& readResult);
    private object ReadCollectionItem(CollectionDataContract collectionContract, Type itemType);
    private void StoreCollectionValue(object collection, Type valueType, object value, CollectionDataContract collectionContract);
    private void HandleUnexpectedItemInCollection(Int32& iterator);
    private bool IsStartElement(XmlDictionaryString name, XmlDictionaryString ns);
    private bool IsStartElement();
    private bool IsEndElement();
    private void ThrowUnexpectedStateException(XmlNodeType expectedState);
    private void ThrowSerializationException(string msg, Object[] values);
}
internal class System.Runtime.Serialization.Json.JsonFormatWriterGenerator : object {
    [SecurityCriticalAttribute]

private CriticalHelper helper;
    [SecurityCriticalAttribute]
internal JsonFormatClassWriterDelegate GenerateClassWriter(ClassDataContract classContract);
    [SecurityCriticalAttribute]
internal JsonFormatCollectionWriterDelegate GenerateCollectionWriter(CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.Json.JsonFormatWriterInterpreter : object {
    
private ClassDataContract classContract;
    
private CollectionDataContract collectionContract;
    
private XmlWriterDelegator writer;
    
private object obj;
    
private XmlObjectSerializerWriteContextComplexJson context;
    
private DataContract dataContract;
    
private object objLocal;
    
private XmlDictionaryString[] memberNames;
    
private int typeIndex;
    
private int childElementIndex;
    
private ClassDataContract classDataContract { get; }
    
private CollectionDataContract collectionDataContract { get; }
    public JsonFormatWriterInterpreter(ClassDataContract classContract);
    public JsonFormatWriterInterpreter(CollectionDataContract collectionContract);
    private ClassDataContract get_classDataContract();
    private CollectionDataContract get_collectionDataContract();
    public void WriteToJson(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, ClassDataContract dataContract, XmlDictionaryString[] memberNames);
    public void WriteCollectionToJson(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, CollectionDataContract dataContract);
    private void InitArgs(Type objType);
    private void InvokeOnSerializing(ClassDataContract classContract, object objSerialized, XmlObjectSerializerWriteContext context);
    private void InvokeOnSerialized(ClassDataContract classContract, object objSerialized, XmlObjectSerializerWriteContext context);
    private void WriteClass(ClassDataContract classContract);
    private void WriteCollection(CollectionDataContract collectionContract);
    private int WriteMembers(ClassDataContract classContract, ExtensionDataObject extensionData, ClassDataContract derivedMostClassContract);
    internal bool IsDefaultValue(Type type, object value);
    internal object GetDefaultValue(Type type);
    private void WriteStartElement(object nameLocal, int nameIndex);
    private void WriteEndElement();
    private void WriteArrayAttribute();
    private void WriteObjectAttribute();
    private void WriteValue(Type memberType, object memberValue);
    private void InternalSerialize(MethodInfo methodInfo, Func`1<object> memberValue, Type memberType, bool writeXsiType);
    private object UnwrapNullableObject(Func`1<object> memberValue, Type& memberType, Boolean& isNull);
    private bool TryWritePrimitive(Type type, Func`1<object> value, MemberInfo memberInfo, Nullable`1<int> arrayItemIndex, XmlDictionaryString name, int nameIndex);
    private bool TryWritePrimitiveArray(Type type, Type itemType, Func`1<object> value, XmlDictionaryString itemName);
    private object LoadMemberValue(DataMember member);
    [CompilerGeneratedAttribute]
private object <WriteCollection>b__22_0();
}
internal static class System.Runtime.Serialization.Json.JsonGlobals : object {
    
public static int DataContractXsdBaseNamespaceLength;
    
public static XmlDictionaryString dDictionaryString;
    
public static Char[] floatingPointCharacters;
    
public static XmlDictionaryString itemDictionaryString;
    
public static XmlDictionaryString rootDictionaryString;
    
public static long unixEpochTicks;
    
public static string applicationJsonMediaType;
    
public static string arrayString;
    
public static string booleanString;
    
public static string CacheControlString;
    
public static byte CollectionByte;
    
public static char CollectionChar;
    
public static string DateTimeEndGuardReader;
    
public static string DateTimeEndGuardWriter;
    
public static string DateTimeStartGuardReader;
    
public static string DateTimeStartGuardWriter;
    
public static string dString;
    
public static byte EndCollectionByte;
    
public static char EndCollectionChar;
    
public static byte EndObjectByte;
    
public static char EndObjectChar;
    
public static string ExpiresString;
    
public static string IfModifiedSinceString;
    
public static string itemString;
    
public static string jsonerrorString;
    
public static string KeyString;
    
public static string LastModifiedString;
    
public static int maxScopeSize;
    
public static byte MemberSeparatorByte;
    
public static char MemberSeparatorChar;
    
public static byte NameValueSeparatorByte;
    
public static char NameValueSeparatorChar;
    
public static string NameValueSeparatorString;
    
public static string nullString;
    
public static string numberString;
    
public static byte ObjectByte;
    
public static char ObjectChar;
    
public static string objectString;
    
public static string publicString;
    
public static byte QuoteByte;
    
public static char QuoteChar;
    
public static string rootString;
    
public static string serverTypeString;
    
public static string stringString;
    
public static string textJsonMediaType;
    
public static string trueString;
    
public static string typeString;
    
public static string ValueString;
    
public static char WhitespaceChar;
    
public static string xmlnsPrefix;
    
public static string xmlPrefix;
    private static JsonGlobals();
}
internal enum System.Runtime.Serialization.Json.JsonNodeType : Enum {
    
public int value__;
    
public static JsonNodeType None;
    
public static JsonNodeType Object;
    
public static JsonNodeType Element;
    
public static JsonNodeType EndElement;
    
public static JsonNodeType QuotedText;
    
public static JsonNodeType StandaloneText;
    
public static JsonNodeType Collection;
}
internal class System.Runtime.Serialization.Json.JsonObjectDataContract : JsonDataContract {
    public JsonObjectDataContract(DataContract traditionalDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    internal static object ParseJsonNumber(string value, TypeCode& objectTypeCode);
    private static object ParseJsonNumber(string value);
}
internal class System.Runtime.Serialization.Json.JsonQNameDataContract : JsonDataContract {
    public JsonQNameDataContract(QNameDataContract traditionalQNameDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonReaderDelegator : XmlReaderDelegator {
    
private DateTimeFormat dateTimeFormat;
    
private DateTimeArrayJsonHelperWithString dateTimeArrayHelper;
    
internal XmlDictionaryReaderQuotas ReaderQuotas { get; }
    
private DateTimeArrayJsonHelperWithString DateTimeArrayHelper { get; }
    public JsonReaderDelegator(XmlReader reader);
    public JsonReaderDelegator(XmlReader reader, DateTimeFormat dateTimeFormat);
    internal XmlDictionaryReaderQuotas get_ReaderQuotas();
    private DateTimeArrayJsonHelperWithString get_DateTimeArrayHelper();
    internal static XmlQualifiedName ParseQualifiedName(string qname);
    internal virtual char ReadContentAsChar();
    internal virtual XmlQualifiedName ReadContentAsQName();
    internal virtual char ReadElementContentAsChar();
    internal virtual Byte[] ReadContentAsBase64();
    internal virtual Byte[] ReadElementContentAsBase64();
    internal virtual DateTime ReadContentAsDateTime();
    internal static DateTime ParseJsonDate(string originalDateTimeValue, DateTimeFormat dateTimeFormat);
    internal static DateTime ParseJsonDateInDefaultFormat(string originalDateTimeValue);
    internal virtual DateTime ReadElementContentAsDateTime();
    internal bool TryReadJsonDateTimeArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, DateTime[]& array);
    internal virtual ulong ReadContentAsUnsignedLong();
    internal virtual ulong ReadElementContentAsUnsignedLong();
}
[TypeForwardedFromAttribute("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public static class System.Runtime.Serialization.Json.JsonReaderWriterFactory : object {
    
private static string DefaultIndentChars;
    public static XmlDictionaryReader CreateJsonReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateJsonReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream, bool indent);
    public static XmlDictionaryWriter CreateJsonWriter(Stream stream, Encoding encoding, bool ownsStream, bool indent, string indentChars);
}
internal class System.Runtime.Serialization.Json.JsonStringDataContract : JsonDataContract {
    public JsonStringDataContract(StringDataContract traditionalStringDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonUriDataContract : JsonDataContract {
    public JsonUriDataContract(UriDataContract traditionalUriDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
}
internal class System.Runtime.Serialization.Json.JsonWriterDelegator : XmlWriterDelegator {
    
private DateTimeFormat dateTimeFormat;
    public JsonWriterDelegator(XmlWriter writer);
    public JsonWriterDelegator(XmlWriter writer, DateTimeFormat dateTimeFormat);
    internal virtual void WriteChar(char value);
    internal virtual void WriteBase64(Byte[] bytes);
    internal virtual void WriteQName(XmlQualifiedName value);
    internal virtual void WriteUnsignedLong(ulong value);
    internal virtual void WriteDecimal(decimal value);
    internal virtual void WriteDouble(double value);
    internal virtual void WriteFloat(float value);
    internal virtual void WriteLong(long value);
    internal virtual void WriteSignedByte(sbyte value);
    internal virtual void WriteUnsignedInt(UInt32 value);
    internal virtual void WriteUnsignedShort(ushort value);
    internal virtual void WriteUnsignedByte(byte value);
    internal virtual void WriteShort(short value);
    internal virtual void WriteBoolean(bool value);
    internal virtual void WriteInt(int value);
    internal void WriteJsonBooleanArray(Boolean[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDateTimeArray(DateTime[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDecimalArray(Decimal[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonInt32Array(Int32[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonInt64Array(Int64[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal virtual void WriteDateTime(DateTime value);
    private void WriteDateTimeInDefaultFormat(DateTime value);
    internal void WriteJsonSingleArray(Single[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal void WriteJsonDoubleArray(Double[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal virtual void WriteStartElement(string prefix, string localName, string ns);
}
internal class System.Runtime.Serialization.Json.JsonXmlDataContract : JsonDataContract {
    public JsonXmlDataContract(XmlDataContract traditionalXmlDataContract);
    public virtual object ReadJsonValueCore(XmlReaderDelegator jsonReader, XmlObjectSerializerReadContextComplexJson context);
    public virtual void WriteJsonValueCore(XmlWriterDelegator jsonWriter, object obj, XmlObjectSerializerWriteContextComplexJson context, RuntimeTypeHandle declaredTypeHandle);
    private List`1<Type> GetKnownTypesFromContext(XmlObjectSerializerContext context, IList`1<Type> serializerKnownTypeList);
}
internal class System.Runtime.Serialization.Json.XmlJsonReader : XmlBaseReader {
    
private static int MaxTextChunk;
    
private static Byte[] charType;
    
private bool buffered;
    
private Byte[] charactersToSkipOnNextRead;
    
private JsonComplexTextMode complexTextMode;
    
private bool expectingFirstElementInNonPrimitiveChild;
    
private int maxBytesPerRead;
    
private OnXmlDictionaryReaderClose onReaderClose;
    
private bool readServerTypeElement;
    
private int scopeDepth;
    
private JsonNodeType[] scopes;
    
public bool CanCanonicalize { get; }
    
public string Value { get; }
    
private bool IsAttributeValue { get; }
    
private bool IsReadingCollection { get; }
    
private bool IsReadingComplexText { get; }
    private static XmlJsonReader();
    public virtual bool get_CanCanonicalize();
    public virtual string get_Value();
    private bool get_IsAttributeValue();
    private bool get_IsReadingCollection();
    private bool get_IsReadingComplexText();
    public virtual void Close();
    public virtual void EndCanonicalization();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string localName, string namespaceUri);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool Read();
    public virtual decimal ReadContentAsDecimal();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    internal static void CheckArray(Array array, int offset, int count);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    private static int BreakText(Byte[] buffer, int offset, int length);
    private static int ComputeNumericalTextLength(Byte[] buffer, int offset, int offsetMax);
    private static int ComputeQuotedTextLengthUntilEndQuote(Byte[] buffer, int offset, int offsetMax, Boolean& escaped);
    private static bool IsWhitespace(byte ch);
    private static char ParseChar(string value, NumberStyles style);
    private static int ParseInt(string value, NumberStyles style);
    private void BufferElement();
    private void EnterJsonScope(JsonNodeType currentNodeType);
    private JsonNodeType ExitJsonScope();
    private void MoveToEndElement();
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    private void ParseAndSetLocalName();
    private void ParseStartElement();
    private void ReadAttributes();
    private void ReadEscapedCharacter(bool moveToText);
    private void ReadNonExistentElementName(StringHandleConstStringType elementName);
    private int ReadNonFFFE();
    private void ReadNumericalText();
    private void ReadQuotedText(bool moveToText);
    private void ReadServerTypeAttribute(bool consumedObjectChar);
    private void ResetState();
    private void SetJsonNameWithMapping(XmlElementNode elementNode);
    private void SkipExpectedByteInBufferReader(byte characterToSkip);
    private void SkipWhitespaceInBufferReader();
    private bool TryGetByte(Byte& ch);
    private string UnescapeJsonString(string val);
}
internal class System.Runtime.Serialization.Json.XmlJsonWriter : XmlDictionaryWriter {
    
private static char BACK_SLASH;
    
private static char FORWARD_SLASH;
    
private static char HIGH_SURROGATE_START;
    
private static char LOW_SURROGATE_END;
    
private static char MAX_CHAR;
    
private static char WHITESPACE;
    
private static char CARRIAGE_RETURN;
    
private static char NEWLINE;
    
private static char BACKSPACE;
    
private static char FORM_FEED;
    
private static char HORIZONTAL_TABULATION;
    
private static string xmlNamespace;
    
private static string xmlnsNamespace;
    [SecurityCriticalAttribute]

private static BinHexEncoding binHexEncoding;
    
private static Char[] CharacterAbbrevs;
    
private string attributeText;
    
private JsonDataType dataType;
    
private int depth;
    
private bool endElementBuffer;
    
private bool isWritingDataTypeAttribute;
    
private bool isWritingServerTypeAttribute;
    
private bool isWritingXmlnsAttribute;
    
private bool isWritingXmlnsAttributeDefaultNs;
    
private NameState nameState;
    
private JsonNodeType nodeType;
    
private JsonNodeWriter nodeWriter;
    
private JsonNodeType[] scopes;
    
private string serverTypeValue;
    
private WriteState writeState;
    
private bool wroteServerTypeAttribute;
    
private bool indent;
    
private string indentChars;
    
private int indentLevel;
    
public XmlWriterSettings Settings { get; }
    
public WriteState WriteState { get; }
    
public string XmlLang { get; }
    
public XmlSpace XmlSpace { get; }
    
private static BinHexEncoding BinHexEncoding { get; }
    
private bool HasOpenAttribute { get; }
    
private bool IsClosed { get; }
    
private bool IsWritingCollection { get; }
    
private bool IsWritingNameAttribute { get; }
    
private bool IsWritingNameWithMapping { get; }
    
private bool WrittenNameWithMapping { get; }
    public XmlJsonWriter(bool indent, string indentChars);
    private static Char[] GetCharacterAbbrevs();
    private static bool TryEscapeControlCharacter(char ch, Char& abbrev);
    public virtual XmlWriterSettings get_Settings();
    public virtual WriteState get_WriteState();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    [SecuritySafeCriticalAttribute]
private static BinHexEncoding get_BinHexEncoding();
    private bool get_HasOpenAttribute();
    private bool get_IsClosed();
    private bool get_IsWritingCollection();
    private bool get_IsWritingNameAttribute();
    private bool get_IsWritingNameWithMapping();
    private bool get_WrittenNameWithMapping();
    public virtual void Close();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartDocument();
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(object value);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
    internal static bool CharacterNeedsEscaping(char ch);
    private static void ThrowClosed();
    private void CheckText(JsonNodeType nextNodeType);
    private void EnterScope(JsonNodeType currentNodeType);
    private JsonNodeType ExitScope();
    private void InitializeWriter();
    private static bool IsUnicodeNewlineCharacter(char c);
    private void StartText();
    private void ThrowIfServerTypeWritten(string dataTypeSpecified);
    private void ThrowInvalidAttributeContent();
    private bool TrySetWritingNameWithMapping(string localName, string ns);
    private void WriteDataTypeServerType();
    [SecuritySafeCriticalAttribute]
private void WriteEscapedJsonString(string str);
    private void WriteIndent();
    private void WriteNewLine();
    private void WriteJsonElementName(string localName);
    private void WriteJsonQuote();
    private void WritePrimitiveValue(object value);
    private void WriteServerTypeAttribute();
    private void WriteValue(ulong value);
    private void WriteValue(Array array);
}
internal class System.Runtime.Serialization.Json.XmlObjectSerializerReadContextComplexJson : XmlObjectSerializerReadContextComplex {
    
private string extensionDataValueType;
    
private DateTimeFormat dateTimeFormat;
    
private bool useSimpleDictionaryFormat;
    
internal IList`1<Type> SerializerKnownTypeList { get; }
    
public bool UseSimpleDictionaryFormat { get; }
    public XmlObjectSerializerReadContextComplexJson(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal IList`1<Type> get_SerializerKnownTypeList();
    public bool get_UseSimpleDictionaryFormat();
    protected virtual void StartReadExtensionDataValue(XmlReaderDelegator xmlReader);
    protected virtual IDataNode ReadPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private IDataNode ReadNumericalPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader);
    internal static XmlObjectSerializerReadContextComplexJson CreateContext(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal virtual int GetArraySize();
    protected virtual object ReadDataContractValue(DataContract dataContract, XmlReaderDelegator reader);
    internal virtual void ReadAttributes(XmlReaderDelegator xmlReader);
    public int GetJsonMemberIndex(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, int memberIndex, ExtensionDataObject extensionData);
    internal static bool TryGetJsonLocalName(XmlReaderDelegator xmlReader, String& name);
    public static string GetJsonMemberName(XmlReaderDelegator xmlReader);
    public static void ThrowMissingRequiredMembers(object obj, XmlDictionaryString[] memberNames, Byte[] expectedElements, Byte[] requiredElements);
    public static void ThrowDuplicateMemberException(object obj, XmlDictionaryString[] memberNames, int memberIndex);
    [SecuritySafeCriticalAttribute]
private static bool IsBitSet(Byte[] bytes, int bitIndex);
    protected virtual bool IsReadingCollectionExtensionData(XmlReaderDelegator xmlReader);
    protected virtual bool IsReadingClassExtensionData(XmlReaderDelegator xmlReader);
    protected virtual XmlReaderDelegator CreateReaderDelegatorForReader(XmlReader xmlReader);
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.Json.XmlObjectSerializerWriteContextComplexJson : XmlObjectSerializerWriteContextComplex {
    
private EmitTypeInformation emitXsiType;
    
private bool perCallXsiTypeAlreadyEmitted;
    
private bool useSimpleDictionaryFormat;
    
internal IList`1<Type> SerializerKnownTypeList { get; }
    
public bool UseSimpleDictionaryFormat { get; }
    
internal XmlDictionaryString CollectionItemName { get; }
    public XmlObjectSerializerWriteContextComplexJson(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal static XmlObjectSerializerWriteContextComplexJson CreateContext(DataContractJsonSerializer serializer, DataContract rootTypeDataContract);
    internal IList`1<Type> get_SerializerKnownTypeList();
    public bool get_UseSimpleDictionaryFormat();
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, string clrTypeName, string clrAssemblyName);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, DataContract dataContract);
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, string dataContractName, string dataContractNamespace);
    internal static string TruncateDefaultDataContractNamespace(string dataContractNamespace);
    private static bool RequiresJsonTypeInfo(DataContract contract);
    private void WriteTypeInfo(XmlWriterDelegator writer, string typeInformation);
    protected virtual bool WriteTypeInfo(XmlWriterDelegator writer, DataContract contract, DataContract declaredContract);
    internal void WriteJsonISerializable(XmlWriterDelegator xmlWriter, ISerializable obj);
    internal static DataContract GetRevisedItemContract(DataContract oldItemContract);
    protected virtual void WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    protected virtual void WriteNull(XmlWriterDelegator xmlWriter);
    internal XmlDictionaryString get_CollectionItemName();
    internal static void WriteJsonNameWithMapping(XmlWriterDelegator xmlWriter, XmlDictionaryString[] memberNames, int index);
    internal virtual void WriteExtensionDataTypeInfo(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    protected virtual void SerializeWithXsiType(XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle objectTypeHandle, Type objectType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    private static void VerifyObjectCompatibilityWithInterface(DataContract contract, object graph, Type declaredType);
    private void HandleCollectionAssignedToObject(Type declaredType, DataContract& dataContract, Object& obj, Boolean& verifyKnownType);
    internal virtual void SerializeWithXsiTypeAtTopLevel(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle originalDeclaredTypeHandle, Type graphType);
    private void VerifyType(DataContract dataContract, Type declaredType);
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal static DataContract ResolveJsonDataContractFromRootDataContract(XmlObjectSerializerContext context, XmlQualifiedName typeQName, DataContract rootTypeDataContract);
    protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
}
internal static class System.Runtime.Serialization.JsonFormatGeneratorStatics : object {
    [SecurityCriticalAttribute]

private static MethodInfo boxPointer;
    [SecurityCriticalAttribute]

private static PropertyInfo collectionItemNameProperty;
    [SecurityCriticalAttribute]

private static ConstructorInfo extensionDataObjectCtor;
    [SecurityCriticalAttribute]

private static PropertyInfo extensionDataProperty;
    [SecurityCriticalAttribute]

private static MethodInfo getItemContractMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getJsonDataContractMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getJsonMemberIndexMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getRevisedItemContractMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getUninitializedObjectMethod;
    [SecurityCriticalAttribute]

private static MethodInfo ienumeratorGetCurrentMethod;
    [SecurityCriticalAttribute]

private static MethodInfo ienumeratorMoveNextMethod;
    [SecurityCriticalAttribute]

private static MethodInfo isStartElementMethod0;
    [SecurityCriticalAttribute]

private static MethodInfo isStartElementMethod2;
    [SecurityCriticalAttribute]

private static PropertyInfo localNameProperty;
    [SecurityCriticalAttribute]

private static PropertyInfo namespaceProperty;
    [SecurityCriticalAttribute]

private static MethodInfo moveToContentMethod;
    [SecurityCriticalAttribute]

private static PropertyInfo nodeTypeProperty;
    [SecurityCriticalAttribute]

private static MethodInfo onDeserializationMethod;
    [SecurityCriticalAttribute]

private static MethodInfo readJsonValueMethod;
    [SecurityCriticalAttribute]

private static ConstructorInfo serializationExceptionCtor;
    [SecurityCriticalAttribute]

private static Type[] serInfoCtorArgs;
    [SecurityCriticalAttribute]

private static MethodInfo throwDuplicateMemberExceptionMethod;
    [SecurityCriticalAttribute]

private static MethodInfo throwMissingRequiredMembersMethod;
    [SecurityCriticalAttribute]

private static PropertyInfo typeHandleProperty;
    [SecurityCriticalAttribute]

private static MethodInfo unboxPointer;
    [SecurityCriticalAttribute]

private static PropertyInfo useSimpleDictionaryFormatReadProperty;
    [SecurityCriticalAttribute]

private static PropertyInfo useSimpleDictionaryFormatWriteProperty;
    [SecurityCriticalAttribute]

private static MethodInfo writeAttributeStringMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeEndElementMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeJsonISerializableMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeJsonNameWithMappingMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeJsonValueMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeStartElementMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeStartElementStringMethod;
    [SecurityCriticalAttribute]

private static MethodInfo parseEnumMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getJsonMemberNameMethod;
    
public static MethodInfo BoxPointer { get; }
    
public static PropertyInfo CollectionItemNameProperty { get; }
    
public static ConstructorInfo ExtensionDataObjectCtor { get; }
    
public static PropertyInfo ExtensionDataProperty { get; }
    
public static MethodInfo GetCurrentMethod { get; }
    
public static MethodInfo GetItemContractMethod { get; }
    
public static MethodInfo GetJsonDataContractMethod { get; }
    
public static MethodInfo GetJsonMemberIndexMethod { get; }
    
public static MethodInfo GetRevisedItemContractMethod { get; }
    
public static MethodInfo GetUninitializedObjectMethod { get; }
    
public static MethodInfo IsStartElementMethod0 { get; }
    
public static MethodInfo IsStartElementMethod2 { get; }
    
public static PropertyInfo LocalNameProperty { get; }
    
public static PropertyInfo NamespaceProperty { get; }
    
public static MethodInfo MoveNextMethod { get; }
    
public static MethodInfo MoveToContentMethod { get; }
    
public static PropertyInfo NodeTypeProperty { get; }
    
public static MethodInfo OnDeserializationMethod { get; }
    
public static MethodInfo ReadJsonValueMethod { get; }
    
public static ConstructorInfo SerializationExceptionCtor { get; }
    
public static Type[] SerInfoCtorArgs { get; }
    
public static MethodInfo ThrowDuplicateMemberExceptionMethod { get; }
    
public static MethodInfo ThrowMissingRequiredMembersMethod { get; }
    
public static PropertyInfo TypeHandleProperty { get; }
    
public static MethodInfo UnboxPointer { get; }
    
public static PropertyInfo UseSimpleDictionaryFormatReadProperty { get; }
    
public static PropertyInfo UseSimpleDictionaryFormatWriteProperty { get; }
    
public static MethodInfo WriteAttributeStringMethod { get; }
    
public static MethodInfo WriteEndElementMethod { get; }
    
public static MethodInfo WriteJsonISerializableMethod { get; }
    
public static MethodInfo WriteJsonNameWithMappingMethod { get; }
    
public static MethodInfo WriteJsonValueMethod { get; }
    
public static MethodInfo WriteStartElementMethod { get; }
    
public static MethodInfo WriteStartElementStringMethod { get; }
    
public static MethodInfo ParseEnumMethod { get; }
    
public static MethodInfo GetJsonMemberNameMethod { get; }
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_BoxPointer();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_CollectionItemNameProperty();
    [SecuritySafeCriticalAttribute]
public static ConstructorInfo get_ExtensionDataObjectCtor();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_ExtensionDataProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetCurrentMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetItemContractMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetJsonDataContractMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetJsonMemberIndexMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetRevisedItemContractMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetUninitializedObjectMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_IsStartElementMethod0();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_IsStartElementMethod2();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_LocalNameProperty();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_NamespaceProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_MoveNextMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_MoveToContentMethod();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_NodeTypeProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_OnDeserializationMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_ReadJsonValueMethod();
    [SecuritySafeCriticalAttribute]
public static ConstructorInfo get_SerializationExceptionCtor();
    [SecuritySafeCriticalAttribute]
public static Type[] get_SerInfoCtorArgs();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_ThrowDuplicateMemberExceptionMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_ThrowMissingRequiredMembersMethod();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_TypeHandleProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_UnboxPointer();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_UseSimpleDictionaryFormatReadProperty();
    [SecuritySafeCriticalAttribute]
public static PropertyInfo get_UseSimpleDictionaryFormatWriteProperty();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteAttributeStringMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteEndElementMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteJsonISerializableMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteJsonNameWithMappingMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteJsonValueMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteStartElementMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_WriteStartElementStringMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_ParseEnumMethod();
    [SecuritySafeCriticalAttribute]
public static MethodInfo get_GetJsonMemberNameMethod();
}
[DataContractAttribute]
internal class System.Runtime.Serialization.KeyValue`2 : ValueType {
    
private K key;
    
private V value;
    [DataMemberAttribute]

public K Key { get; public set; }
    [DataMemberAttribute]

public V Value { get; public set; }
    internal KeyValue`2(K key, V value);
    public K get_Key();
    public void set_Key(K value);
    public V get_Value();
    public void set_Value(V value);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.Serialization.KnownTypeAttribute : Attribute {
    
private string methodName;
    
private Type type;
    
public string MethodName { get; }
    
public Type Type { get; }
    public KnownTypeAttribute(Type type);
    public KnownTypeAttribute(string methodName);
    public string get_MethodName();
    public Type get_Type();
}
internal class System.Runtime.Serialization.KnownTypeDataContractResolver : DataContractResolver {
    
private XmlObjectSerializerContext context;
    internal KnownTypeDataContractResolver(XmlObjectSerializerContext context);
    public virtual bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    public virtual Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
}
internal class System.Runtime.Serialization.LanguageDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.LongDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal LongDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.NameDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.NCNameDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.NegativeIntegerDataContract : LongDataContract {
}
public class System.Runtime.Serialization.NetDataContractSerializer : XmlObjectSerializer {
    
private XmlDictionaryString rootName;
    
private XmlDictionaryString rootNamespace;
    
private StreamingContext context;
    
private SerializationBinder binder;
    
private ISurrogateSelector surrogateSelector;
    
private int maxItemsInObjectGraph;
    
private bool ignoreExtensionDataObject;
    
private FormatterAssemblyStyle assemblyFormat;
    
private DataContract cachedDataContract;
    
private static Hashtable typeNameCache;
    
private static Nullable`1<bool> unsafeTypeForwardingEnabled;
    
internal static bool UnsafeTypeForwardingEnabled { get; }
    
public StreamingContext Context { get; public set; }
    
public SerializationBinder Binder { get; public set; }
    
public ISurrogateSelector SurrogateSelector { get; public set; }
    
public FormatterAssemblyStyle AssemblyFormat { get; public set; }
    
public int MaxItemsInObjectGraph { get; }
    
public bool IgnoreExtensionDataObject { get; }
    public NetDataContractSerializer(StreamingContext context);
    public NetDataContractSerializer(StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    public NetDataContractSerializer(string rootName, string rootNamespace);
    public NetDataContractSerializer(string rootName, string rootNamespace, StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    public NetDataContractSerializer(XmlDictionaryString rootName, XmlDictionaryString rootNamespace);
    public NetDataContractSerializer(XmlDictionaryString rootName, XmlDictionaryString rootNamespace, StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    private static NetDataContractSerializer();
    private void Initialize(StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    private void Initialize(XmlDictionaryString rootName, XmlDictionaryString rootNamespace, StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, FormatterAssemblyStyle assemblyFormat, ISurrogateSelector surrogateSelector);
    [SecuritySafeCriticalAttribute]
internal static bool get_UnsafeTypeForwardingEnabled();
    public sealed virtual StreamingContext get_Context();
    public sealed virtual void set_Context(StreamingContext value);
    public sealed virtual SerializationBinder get_Binder();
    public sealed virtual void set_Binder(SerializationBinder value);
    public sealed virtual ISurrogateSelector get_SurrogateSelector();
    public sealed virtual void set_SurrogateSelector(ISurrogateSelector value);
    public FormatterAssemblyStyle get_AssemblyFormat();
    public void set_AssemblyFormat(FormatterAssemblyStyle value);
    public int get_MaxItemsInObjectGraph();
    public bool get_IgnoreExtensionDataObject();
    public sealed virtual void Serialize(Stream stream, object graph);
    public sealed virtual object Deserialize(Stream stream);
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    private void InternalWriteStartObject(XmlWriterDelegator writer, object graph, DataContract contract);
    public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    private void InternalWriteObjectContent(XmlWriterDelegator writer, object graph, DataContract contract, Hashtable surrogateDataContracts);
    internal static void WriteClrTypeInfo(XmlWriterDelegator writer, DataContract dataContract, SerializationBinder binder);
    internal static void WriteClrTypeInfo(XmlWriterDelegator writer, Type dataContractType, SerializationBinder binder, string defaultClrTypeName, string defaultClrAssemblyName);
    internal static void WriteClrTypeInfo(XmlWriterDelegator writer, Type dataContractType, SerializationBinder binder, SerializationInfo serInfo);
    private static void WriteClrTypeInfo(XmlWriterDelegator writer, string clrTypeName, string clrAssemblyName);
    public virtual void WriteEndObject(XmlDictionaryWriter writer);
    internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlDictionaryReader reader);
    internal virtual object InternalReadObject(XmlReaderDelegator xmlReader, bool verifyObjectName);
    internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal DataContract GetDataContract(object obj, Hashtable& surrogateDataContracts);
    internal DataContract GetDataContract(Type type, Hashtable& surrogateDataContracts);
    internal DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type, Hashtable& surrogateDataContracts);
    [SecuritySafeCriticalAttribute]
private static ISerializationSurrogate GetSurrogate(Type type, ISurrogateSelector surrogateSelector, StreamingContext context);
    internal static DataContract GetDataContractFromSurrogateSelector(ISurrogateSelector surrogateSelector, StreamingContext context, RuntimeTypeHandle typeHandle, Type type, Hashtable& surrogateDataContracts);
    internal static TypeInformation GetTypeInformation(Type type);
    private static bool IsAssemblyNameForwardingSafe(string originalAssemblyName, string newAssemblyName);
    private static bool IsPublicKeyTokenForwardingSafe(Byte[] sourceToken, Byte[] destinationToken);
}
internal class System.Runtime.Serialization.NMTOKENDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.NMTOKENSDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.NonNegativeIntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.NonPositiveIntegerDataContract : LongDataContract {
}
internal class System.Runtime.Serialization.NormalizedStringDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.ObjectDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    
internal bool CanContainReferences { get; }
    
internal bool IsPrimitive { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
}
internal class System.Runtime.Serialization.ObjectReferenceStack : ValueType {
    
private static int MaximumArraySize;
    
private static int InitialArraySize;
    
private int count;
    
private Object[] objectArray;
    
private Boolean[] isReferenceArray;
    
private Dictionary`2<object, object> objectDictionary;
    
internal int Count { get; }
    internal void Push(object obj);
    internal void EnsureSetAsIsReference(object obj);
    internal void Pop(object obj);
    internal bool Contains(object obj);
    internal int get_Count();
}
internal class System.Runtime.Serialization.ObjectToIdCache : object {
    
internal int m_currentCount;
    
internal Int32[] m_ids;
    
internal Object[] m_objs;
    
private Boolean[] m_isWrapped;
    
internal static Int32[] primes;
    private static ObjectToIdCache();
    public int GetId(object obj, Boolean& newId);
    public int ReassignId(int oldObjId, object oldObj, object newObj);
    private int FindElement(object obj, Boolean& isEmpty, Boolean& isWrapped);
    private void RemoveAt(int position);
    private int ComputeStartPosition(object o);
    private void Rehash();
    private static int GetPrime(int min);
    private static bool IsPrime(int candidate);
}
internal class System.Runtime.Serialization.PositiveIntegerDataContract : LongDataContract {
}
internal abstract class System.Runtime.Serialization.PrimitiveDataContract : DataContract {
    [SecurityCriticalAttribute]

private PrimitiveDataContractCriticalHelper helper;
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    
internal XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    
internal bool CanContainReferences { get; }
    
internal bool IsPrimitive { get; }
    
internal bool IsBuiltInDataContract { get; }
    
internal MethodInfo XmlFormatWriterMethod { get; }
    
internal MethodInfo XmlFormatContentWriterMethod { get; }
    
internal MethodInfo XmlFormatReaderMethod { get; }
    [SecuritySafeCriticalAttribute]
protected PrimitiveDataContract(Type type, XmlDictionaryString name, XmlDictionaryString ns);
    internal static PrimitiveDataContract GetPrimitiveDataContract(Type type);
    internal static PrimitiveDataContract GetPrimitiveDataContract(string name, string ns);
    internal abstract virtual string get_WriteMethodName();
    internal abstract virtual string get_ReadMethodName();
    internal virtual XmlDictionaryString get_TopLevelElementNamespace();
    internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsPrimitive();
    internal virtual bool get_IsBuiltInDataContract();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_XmlFormatWriterMethod();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_XmlFormatContentWriterMethod();
    [SecuritySafeCriticalAttribute]
internal MethodInfo get_XmlFormatReaderMethod();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    protected object HandleReadValue(object obj, XmlObjectSerializerReadContext context);
    protected bool TryReadNullAtTopLevel(XmlReaderDelegator reader);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
}
internal class System.Runtime.Serialization.QNameDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    
internal bool IsPrimitive { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    internal virtual bool get_IsPrimitive();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
    internal virtual void WriteRootElement(XmlWriterDelegator writer, XmlDictionaryString name, XmlDictionaryString ns);
}
internal class System.Runtime.Serialization.SchemaExporter : object {
    
private XmlSchemaSet schemas;
    
private XmlDocument xmlDoc;
    
private DataContractSet dataContractSet;
    [SecurityCriticalAttribute]

private static XmlQualifiedName anytypeQualifiedName;
    [SecurityCriticalAttribute]

private static XmlQualifiedName stringQualifiedName;
    [SecurityCriticalAttribute]

private static XmlQualifiedName defaultEnumBaseTypeName;
    [SecurityCriticalAttribute]

private static XmlQualifiedName enumerationValueAnnotationName;
    [SecurityCriticalAttribute]

private static XmlQualifiedName surrogateDataAnnotationName;
    [SecurityCriticalAttribute]

private static XmlQualifiedName defaultValueAnnotation;
    [SecurityCriticalAttribute]

private static XmlQualifiedName actualTypeAnnotationName;
    [SecurityCriticalAttribute]

private static XmlQualifiedName isDictionaryAnnotationName;
    [SecurityCriticalAttribute]

private static XmlQualifiedName isValueTypeName;
    
private XmlSchemaSet Schemas { get; }
    
private XmlDocument XmlDoc { get; }
    
internal static XmlSchemaSequence ISerializableSequence { get; }
    
internal static XmlSchemaAny ISerializableWildcardElement { get; }
    
internal static XmlQualifiedName AnytypeQualifiedName { get; }
    
internal static XmlQualifiedName StringQualifiedName { get; }
    
internal static XmlQualifiedName DefaultEnumBaseTypeName { get; }
    
internal static XmlQualifiedName EnumerationValueAnnotationName { get; }
    
internal static XmlQualifiedName SurrogateDataAnnotationName { get; }
    
internal static XmlQualifiedName DefaultValueAnnotation { get; }
    
internal static XmlQualifiedName ActualTypeAnnotationName { get; }
    
internal static XmlQualifiedName IsDictionaryAnnotationName { get; }
    
internal static XmlQualifiedName IsValueTypeName { get; }
    
internal static XmlSchemaAttribute ISerializableFactoryTypeAttribute { get; }
    
internal static XmlSchemaAttribute RefAttribute { get; }
    
internal static XmlSchemaAttribute IdAttribute { get; }
    internal SchemaExporter(XmlSchemaSet schemas, DataContractSet dataContractSet);
    private XmlSchemaSet get_Schemas();
    private XmlDocument get_XmlDoc();
    internal void Export();
    private void ExportSerializationSchema();
    private void ExportDataContract(DataContract dataContract);
    private XmlSchemaElement ExportTopLevelElement(DataContract dataContract, XmlSchema schema);
    private void ExportClassDataContract(ClassDataContract classDataContract, XmlSchema schema);
    private void AddReferenceAttributes(XmlSchemaObjectCollection attributes, XmlSchema schema);
    private void SetElementType(XmlSchemaElement element, DataContract dataContract, XmlSchema schema);
    private bool CheckIfMemberHasConflict(DataMember dataMember);
    private XmlElement ExportEmitDefaultValue(DataMember dataMember);
    private XmlElement ExportActualType(XmlQualifiedName typeName);
    private static XmlElement ExportActualType(XmlQualifiedName typeName, XmlDocument xmlDoc);
    private XmlElement ExportGenericInfo(Type clrType, string elementName, string elementNs);
    private XmlElement ExportSurrogateData(object key);
    private void ExportCollectionDataContract(CollectionDataContract collectionDataContract, XmlSchema schema);
    private XmlElement ExportIsDictionary();
    private void ExportEnumDataContract(EnumDataContract enumDataContract, XmlSchema schema);
    internal static long GetDefaultEnumValue(bool isFlags, int index);
    private void ExportISerializableDataContract(ClassDataContract dataContract, XmlSchema schema);
    private XmlSchemaComplexContentExtension CreateTypeContent(XmlSchemaComplexType type, XmlQualifiedName baseTypeName, XmlSchema schema);
    private void ExportXmlDataContract(XmlDataContract dataContract);
    private static void ReprocessAll(XmlSchemaSet schemas);
    internal static void GetXmlTypeInfo(Type type, XmlQualifiedName& stableName, XmlSchemaType& xsdType, Boolean& hasRoot);
    private static bool InvokeSchemaProviderMethod(Type clrType, XmlSchemaSet schemas, XmlQualifiedName& stableName, XmlSchemaType& xsdType, Boolean& hasRoot);
    private static void InvokeGetSchemaMethod(Type clrType, XmlSchemaSet schemas, XmlQualifiedName stableName);
    internal static void AddDefaultXmlType(XmlSchemaSet schemas, string localName, string ns);
    private static XmlSchemaComplexType CreateAnyType();
    private static XmlSchemaComplexType CreateAnyElementType();
    internal static bool IsSpecialXmlType(Type type, XmlQualifiedName& typeName, XmlSchemaType& xsdType, Boolean& hasRoot);
    private static void AddDefaultDatasetType(XmlSchemaSet schemas, string localName, string ns);
    private static void AddDefaultTypedDatasetType(XmlSchemaSet schemas, XmlSchema datasetSchema, string localName, string ns);
    private XmlSchemaAnnotation GetSchemaAnnotation(XmlQualifiedName annotationQualifiedName, string innerText, XmlSchema schema);
    private static XmlSchemaAnnotation GetSchemaAnnotation(XmlNode[] nodes);
    private XmlElement GetAnnotationMarkup(XmlQualifiedName annotationQualifiedName, string innerText, XmlSchema schema);
    private XmlSchema GetSchema(string ns);
    internal static XmlSchemaSequence get_ISerializableSequence();
    internal static XmlSchemaAny get_ISerializableWildcardElement();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_AnytypeQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_StringQualifiedName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_DefaultEnumBaseTypeName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_EnumerationValueAnnotationName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_SurrogateDataAnnotationName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_DefaultValueAnnotation();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_ActualTypeAnnotationName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_IsDictionaryAnnotationName();
    [SecuritySafeCriticalAttribute]
internal static XmlQualifiedName get_IsValueTypeName();
    internal static XmlSchemaAttribute get_ISerializableFactoryTypeAttribute();
    internal static XmlSchemaAttribute get_RefAttribute();
    internal static XmlSchemaAttribute get_IdAttribute();
}
internal static class System.Runtime.Serialization.SchemaHelper : object {
    internal static bool NamespacesEqual(string ns1, string ns2);
    internal static XmlSchemaType GetSchemaType(XmlSchemaSet schemas, XmlQualifiedName typeQName, XmlSchema& outSchema);
    internal static XmlSchemaType GetSchemaType(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlQualifiedName typeName);
    internal static XmlSchema GetSchemaWithType(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlSchemaSet schemas, XmlQualifiedName typeName);
    internal static XmlSchemaElement GetSchemaElement(XmlSchemaSet schemas, XmlQualifiedName elementQName, XmlSchema& outSchema);
    internal static XmlSchemaElement GetSchemaElement(Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaInfo, XmlQualifiedName elementName);
    internal static XmlSchema GetSchema(string ns, XmlSchemaSet schemas);
    private static XmlSchema CreateSchema(string ns, XmlSchemaSet schemas);
    internal static void AddElementForm(XmlSchemaElement element, XmlSchema schema);
    internal static void AddSchemaImport(string ns, XmlSchema schema);
    internal static XmlSchema GetSchemaWithGlobalElementDeclaration(XmlSchemaElement element, XmlSchemaSet schemas);
    internal static XmlQualifiedName GetGlobalElementDeclaration(XmlSchemaSet schemas, XmlQualifiedName typeQName, Boolean& isNullable);
}
internal class System.Runtime.Serialization.SchemaImporter : object {
    
private DataContractSet dataContractSet;
    
private XmlSchemaSet schemaSet;
    
private ICollection`1<XmlQualifiedName> typeNames;
    
private ICollection`1<XmlSchemaElement> elements;
    
private XmlQualifiedName[] elementTypeNames;
    
private bool importXmlDataType;
    
private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> schemaObjects;
    
private List`1<XmlSchemaRedefine> redefineList;
    
private bool needToImportKnownTypesForObject;
    [SecurityCriticalAttribute]

private static Hashtable serializationSchemaElements;
    
private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> SchemaObjects { get; }
    
private List`1<XmlSchemaRedefine> RedefineList { get; }
    internal SchemaImporter(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames, ICollection`1<XmlSchemaElement> elements, XmlQualifiedName[] elementTypeNames, DataContractSet dataContractSet, bool importXmlDataType);
    internal void Import();
    internal static void CompileSchemaSet(XmlSchemaSet schemaSet);
    private Dictionary`2<XmlQualifiedName, SchemaObjectInfo> get_SchemaObjects();
    private List`1<XmlSchemaRedefine> get_RedefineList();
    private void ImportKnownTypes(XmlQualifiedName typeName);
    internal static bool IsObjectContract(DataContract dataContract);
    private void ImportKnownTypesForObject();
    internal Dictionary`2<XmlQualifiedName, SchemaObjectInfo> CreateSchemaObjects();
    private XmlQualifiedName GetBaseTypeName(XmlSchemaType type);
    private List`1<XmlSchemaRedefine> CreateRedefineList();
    [SecuritySafeCriticalAttribute]
private DataContract ImportAnonymousGlobalElement(XmlSchemaElement element, XmlQualifiedName typeQName, string ns);
    private DataContract ImportAnonymousElement(XmlSchemaElement element, XmlQualifiedName typeQName);
    private DataContract ImportType(XmlQualifiedName typeName);
    private DataContract ImportType(XmlSchemaType type);
    private DataContract ImportType(XmlSchemaType type, XmlQualifiedName typeName, bool isAnonymous);
    private void RemoveFailedContract(XmlQualifiedName typeName);
    private bool CheckIfEnum(XmlSchemaSimpleTypeRestriction restriction);
    private bool CheckIfCollection(XmlSchemaSequence rootSequence);
    private bool CheckIfISerializable(XmlSchemaSequence rootSequence, XmlSchemaObjectCollection attributes);
    [SecuritySafeCriticalAttribute]
private void RemoveOptionalUnknownSerializationElements(XmlSchemaObjectCollection items);
    private DataContract ImportType(XmlQualifiedName typeName, XmlSchemaParticle rootParticle, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, XmlQualifiedName baseTypeName, XmlSchemaAnnotation annotation);
    [SecuritySafeCriticalAttribute]
private ClassDataContract ImportClass(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlQualifiedName baseTypeName, XmlSchemaAnnotation annotation, bool isReference);
    [SecuritySafeCriticalAttribute]
private DataContract ImportXmlDataType(XmlQualifiedName typeName, XmlSchemaType xsdType, bool isAnonymous);
    private XmlDataContract ImportSpecialXmlDataType(XmlSchemaType xsdType, bool isAnonymous);
    private bool IsXmlAnyElementType(XmlSchemaComplexType xsdType);
    private bool IsXmlAnyType(XmlSchemaComplexType xsdType);
    private bool IsValueType(XmlQualifiedName typeName, XmlSchemaAnnotation annotation);
    [SecuritySafeCriticalAttribute]
private ClassDataContract ImportISerializable(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlQualifiedName baseTypeName, XmlSchemaObjectCollection attributes, XmlSchemaAnnotation annotation);
    private void CheckISerializableBase(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlSchemaObjectCollection attributes);
    private bool IsISerializableDerived(XmlQualifiedName typeName, XmlSchemaSequence rootSequence);
    [SecuritySafeCriticalAttribute]
private void ImportBaseContract(XmlQualifiedName baseTypeName, ClassDataContract dataContract);
    private void ImportTopLevelElement(XmlQualifiedName typeName);
    private void ImportClassMember(XmlSchemaElement element, ClassDataContract dataContract);
    private Nullable`1<bool> ImportEmitDefaultValue(XmlSchemaAnnotation annotation, XmlQualifiedName typeName);
    internal static XmlQualifiedName ImportActualType(XmlSchemaAnnotation annotation, XmlQualifiedName defaultTypeName, XmlQualifiedName typeName);
    [SecuritySafeCriticalAttribute]
private CollectionDataContract ImportCollection(XmlQualifiedName typeName, XmlSchemaSequence rootSequence, XmlSchemaObjectCollection attributes, XmlSchemaAnnotation annotation, bool isReference);
    private GenericInfo GetGenericInfoForDataMember(DataMember dataMember);
    private bool IsDictionary(XmlQualifiedName typeName, XmlSchemaAnnotation annotation);
    private EnumDataContract ImportFlagsEnum(XmlQualifiedName typeName, XmlSchemaSimpleTypeList list, XmlSchemaAnnotation annotation);
    [SecuritySafeCriticalAttribute]
private EnumDataContract ImportEnum(XmlQualifiedName typeName, XmlSchemaSimpleTypeRestriction restriction, bool isFlags, XmlSchemaAnnotation annotation);
    private DataContract ImportSimpleTypeRestriction(XmlQualifiedName typeName, XmlSchemaSimpleTypeRestriction restriction);
    private void ImportDataContractExtension(XmlSchemaType type, DataContract dataContract);
    [SecuritySafeCriticalAttribute]
private void ImportGenericInfo(XmlSchemaType type, DataContract dataContract);
    private GenericInfo ImportGenericInfo(XmlElement typeElement, XmlSchemaType type);
    private object ImportSurrogateData(XmlElement typeElement, string name, string ns);
    private void CheckComplexType(XmlQualifiedName typeName, XmlSchemaComplexType type);
    private void CheckIfElementUsesUnsupportedConstructs(XmlQualifiedName typeName, XmlSchemaElement element);
    private void ImportAttributes(XmlQualifiedName typeName, XmlSchemaObjectCollection attributes, XmlSchemaAnyAttribute anyAttribute, Boolean& isReference);
    private bool TryCheckIfAttribute(XmlQualifiedName typeName, XmlSchemaAttribute attribute, XmlQualifiedName refName, Boolean& foundAttribute);
    private void AddDataContract(DataContract dataContract);
    private string GetInnerText(XmlQualifiedName typeName, XmlElement xmlElement);
    private static XmlElement ImportAnnotation(XmlSchemaAnnotation annotation, XmlQualifiedName annotationQualifiedName);
    private static void ThrowTypeCannotBeImportedException(string name, string ns, string message);
    private static void ThrowArrayTypeCannotBeImportedException(string name, string ns, string message);
    private static void ThrowEnumTypeCannotBeImportedException(string name, string ns, string message);
    private static void ThrowISerializableTypeCannotBeImportedException(string name, string ns, string message);
    private static void ThrowTypeCannotBeImportedException(string message);
}
internal class System.Runtime.Serialization.SchemaObjectInfo : object {
    
internal XmlSchemaType type;
    
internal XmlSchemaElement element;
    
internal XmlSchema schema;
    
internal List`1<XmlSchemaType> knownTypes;
    internal SchemaObjectInfo(XmlSchemaType type, XmlSchemaElement element, XmlSchema schema, List`1<XmlSchemaType> knownTypes);
}
internal class System.Runtime.Serialization.ScopedKnownTypes : ValueType {
    
internal Dictionary`2[] dataContractDictionaries;
    
private int count;
    internal void Push(Dictionary`2<XmlQualifiedName, DataContract> dataContractDictionary);
    internal void Pop();
    internal DataContract GetDataContract(XmlQualifiedName qname);
}
internal enum System.Runtime.Serialization.SerializationMode : Enum {
    
public int value__;
    
public static SerializationMode SharedContract;
    
public static SerializationMode SharedType;
}
internal static class System.Runtime.Serialization.SerializationTrace : object {
    [SecurityCriticalAttribute]

private static TraceSource codeGen;
    
internal static SourceSwitch CodeGenerationSwitch { get; }
    
private static TraceSource CodeGenerationTraceSource { get; }
    internal static SourceSwitch get_CodeGenerationSwitch();
    internal static void WriteInstruction(int lineNumber, string instruction);
    internal static void TraceInstruction(string instruction);
    [SecuritySafeCriticalAttribute]
private static TraceSource get_CodeGenerationTraceSource();
}
internal class System.Runtime.Serialization.ShortDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.SignedByteDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.SpecialTypeDataContract : DataContract {
    [SecurityCriticalAttribute]

private SpecialTypeDataContractCriticalHelper helper;
    
internal bool IsBuiltInDataContract { get; }
    [SecuritySafeCriticalAttribute]
public SpecialTypeDataContract(Type type);
    [SecuritySafeCriticalAttribute]
public SpecialTypeDataContract(Type type, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual bool get_IsBuiltInDataContract();
}
internal static class System.Runtime.Serialization.SR : object {
    
public static string ArrayExceededSize;
    
public static string ArrayExceededSizeAttribute;
    
public static string ArrayTypeIsNotSupported;
    
public static string CannotDeserializeRefAtTopLevel;
    
public static string CannotLoadMemberType;
    
public static string CannotSerializeObjectWithCycles;
    
public static string CanOnlyStoreIntoArgOrLocGot0;
    
public static string CharIsInvalidPrimitive;
    
public static string CallbackMustReturnVoid;
    
public static string CallbackParameterInvalid;
    
public static string CallbacksCannotBeVirtualMethods;
    
public static string CollectionMustHaveAddMethod;
    
public static string CollectionMustHaveGetEnumeratorMethod;
    
public static string CollectionMustHaveItemType;
    
public static string CollectionTypeCannotBeBuiltIn;
    
public static string CollectionTypeCannotHaveDataContract;
    
public static string CollectionTypeDoesNotHaveAddMethod;
    
public static string CollectionTypeDoesNotHaveDefaultCtor;
    
public static string CollectionTypeHasMultipleDefinitionsOfInterface;
    
public static string CollectionTypeIsNotIEnumerable;
    
public static string DataContractCacheOverflow;
    
public static string DataContractNamespaceAlreadySet;
    
public static string DataContractNamespaceIsNotValid;
    
public static string DataContractNamespaceReserved;
    
public static string DataMemberOnEnumField;
    
public static string DcTypeNotFoundOnDeserialize;
    
public static string DcTypeNotFoundOnSerialize;
    
public static string DcTypeNotResolvedOnDeserialize;
    
public static string DeserializedObjectWithIdNotFound;
    
public static string DupContractInKnownTypes;
    
public static string DupKeyValueName;
    
public static string DupEnumMemberValue;
    
public static string DupMemberName;
    
public static string DuplicateAttribute;
    
public static string DuplicateCallback;
    
public static string EncounteredWithNameNamespace;
    
public static string EnumTypeCannotHaveIsReference;
    
public static string ErrorDeserializing;
    
public static string ErrorInLine;
    
public static string ErrorIsStartObject;
    
public static string ErrorSerializing;
    
public static string ErrorTypeInfo;
    
public static string ErrorWriteEndObject;
    
public static string ErrorWriteStartObject;
    
public static string ExceededMaxItemsQuota;
    
public static string ExpectingElement;
    
public static string ExpectingElementAtDeserialize;
    
public static string ExpectingEnd;
    
public static string ExpectingState;
    
public static string GenericNameBraceMismatch;
    
public static string GenericParameterNotValid;
    
public static string InconsistentIsReference;
    
public static string IndexedPropertyCannotBeSerialized;
    
public static string InterfaceTypeCannotBeCreated;
    
public static string InvalidCollectionContractItemName;
    
public static string InvalidCollectionContractKeyName;
    
public static string InvalidCollectionContractKeyNoDictionary;
    
public static string InvalidCollectionContractName;
    
public static string InvalidCollectionContractNamespace;
    
public static string InvalidCollectionContractValueName;
    
public static string InvalidCollectionContractValueNoDictionary;
    
public static string InvalidCollectionDataContract;
    
public static string InvalidCollectionType;
    
public static string InvalidDataContractName;
    
public static string InvalidDataContractNamespace;
    
public static string InvalidDataMemberName;
    
public static string InvalidEnumMemberValue;
    
public static string InvalidEnumValueOnRead;
    
public static string InvalidEnumValueOnWrite;
    
public static string InvalidGetSchemaMethod;
    
public static string InvalidGlobalDataContractNamespace;
    
public static string InvalidMember;
    
public static string InvalidNonNullReturnValueByIsAny;
    
public static string InvalidPrimitiveType;
    
public static string InvalidReturnTypeOnGetSchemaMethod;
    
public static string InvalidSizeDefinition;
    
public static string InvalidXmlDataContractName;
    
public static string InvalidXsIdDefinition;
    
public static string InvalidXsRefDefinition;
    
public static string IsAnyCannotBeNull;
    
public static string IsAnyCannotBeSerializedAsDerivedType;
    
public static string IsAnyCannotHaveXmlRoot;
    
public static string IsNotAssignableFrom;
    
public static string IsRequiredDataMemberOnIsReferenceDataContractType;
    
public static string IXmlSerializableCannotHaveCollectionDataContract;
    
public static string IXmlSerializableCannotHaveDataContract;
    
public static string IXmlSerializableIllegalOperation;
    
public static string IXmlSerializableMissingEndElements;
    
public static string IXmlSerializableMustHaveDefaultConstructor;
    
public static string IXmlSerializableWritePastSubTree;
    
public static string KnownTypeAttributeEmptyString;
    
public static string KnownTypeAttributeUnknownMethod;
    
public static string KnownTypeAttributeReturnType;
    
public static string KnownTypeAttributeOneScheme;
    
public static string KnownTypeAttributeNoType;
    
public static string KnownTypeConfigClosedGenericDeclared;
    
public static string KnownTypeAttributeValidMethodTypes;
    
public static string KnownTypeAttributeNoData;
    
public static string KnownTypeAttributeMethodNull;
    
public static string MaxArrayLengthExceeded;
    
public static string MissingGetSchemaMethod;
    
public static string MultipleIdDefinition;
    
public static string NoConversionPossibleTo;
    
public static string NoGetMethodForProperty;
    
public static string NoSetMethodForProperty;
    
public static string NullKnownType;
    
public static string NullValueReturnedForGetOnlyCollection;
    
public static string ObjectTableOverflow;
    
public static string OrderCannotBeNegative;
    
public static string ParameterCountMismatch;
    
public static string PartialTrustCollectionContractAddMethodNotPublic;
    
public static string PartialTrustCollectionContractNoPublicConstructor;
    
public static string PartialTrustCollectionContractTypeNotPublic;
    
public static string PartialTrustDataContractOnSerializingNotPublic;
    
public static string PartialTrustDataContractOnSerializedNotPublic;
    
public static string PartialTrustDataContractOnDeserializingNotPublic;
    
public static string PartialTrustDataContractOnDeserializedNotPublic;
    
public static string PartialTrustDataContractFieldGetNotPublic;
    
public static string PartialTrustDataContractFieldSetNotPublic;
    
public static string PartialTrustDataContractPropertyGetNotPublic;
    
public static string PartialTrustDataContractPropertySetNotPublic;
    
public static string PartialTrustDataContractTypeNotPublic;
    
public static string PartialTrustNonAttributedSerializableTypeNoPublicConstructor;
    
public static string PartialTrustIXmlSerializableTypeNotPublic;
    
public static string PartialTrustIXmlSerialzableNoPublicConstructor;
    
public static string NonAttributedSerializableTypesMustHaveDefaultConstructor;
    
public static string AttributedTypesCannotInheritFromNonAttributedSerializableTypes;
    
public static string GetOnlyCollectionsNotSupported;
    
public static string QuotaMustBePositive;
    
public static string QuotaIsReadOnly;
    
public static string QuotaCopyReadOnly;
    
public static string RequiredMemberMustBeEmitted;
    
public static string ResolveTypeReturnedFalse;
    
public static string ResolveTypeReturnedNull;
    
public static string SupportForMultidimensionalArraysNotPresent;
    
public static string TooManyCollectionContracts;
    
public static string TooManyDataContracts;
    
public static string TooManyDataMembers;
    
public static string TooManyEnumMembers;
    
public static string TooManyIgnoreDataMemberAttributes;
    
public static string TypeMustBeConcrete;
    
public static string TypeNotSerializable;
    
public static string UnexpectedContractType;
    
public static string UnexpectedElementExpectingElements;
    
public static string UnexpectedEndOfFile;
    
public static string UnknownConstantType;
    
public static string UnsupportedIDictionaryAsDataMemberType;
    
public static string ValueMustBeNonNegative;
    
public static string ValueTypeCannotBeNull;
    
public static string ValueTypeCannotHaveBaseType;
    
public static string ValueTypeCannotHaveId;
    
public static string ValueTypeCannotHaveIsReference;
    
public static string ValueTypeCannotHaveRef;
    
public static string XmlElementAttributes;
    
public static string XmlForObjectCannotHaveContent;
    
public static string XmlInvalidConversion;
    
public static string XmlInvalidConversionWithoutValue;
    
public static string XmlStartElementExpected;
    
public static string XmlWriterMustBeInElement;
    
public static string OffsetExceedsBufferSize;
    
public static string SizeExceedsRemainingBufferSpace;
    
public static string ValueMustBeInRange;
    
public static string XmlArrayTooSmallOutput;
    
public static string XmlInvalidBase64Length;
    
public static string XmlInvalidBase64Sequence;
    
public static string XmlInvalidBinHexLength;
    
public static string XmlInvalidBinHexSequence;
    
public static string XmlInvalidHighSurrogate;
    
public static string XmlInvalidLowSurrogate;
    
public static string XmlInvalidSurrogate;
    
public static string CombinedPrefixNSLength;
    
public static string InvalidInclusivePrefixListCollection;
    
public static string InvalidLocalNameEmpty;
    
public static string XmlArrayTooSmall;
    
public static string XmlArrayTooSmallInput;
    
public static string XmlBadBOM;
    
public static string XmlBase64DataExpected;
    
public static string XmlCDATAInvalidAtTopLevel;
    
public static string XmlCloseCData;
    
public static string XmlConversionOverflow;
    
public static string XmlDeclarationRequired;
    
public static string XmlDeclMissingVersion;
    
public static string XmlDeclMissing;
    
public static string XmlDeclNotFirst;
    
public static string XmlDictionaryStringIDRange;
    
public static string XmlDictionaryStringIDUndefinedSession;
    
public static string XmlDictionaryStringIDUndefinedStatic;
    
public static string XmlDuplicateAttribute;
    
public static string XmlEmptyNamespaceRequiresNullPrefix;
    
public static string XmlEncodingMismatch;
    
public static string XmlEncodingNotSupported;
    
public static string XmlEndElementExpected;
    
public static string XmlEndElementNoOpenNodes;
    
public static string XmlExpectedEncoding;
    
public static string XmlFoundCData;
    
public static string XmlFoundComment;
    
public static string XmlFoundElement;
    
public static string XmlFoundEndElement;
    
public static string XmlFoundEndOfFile;
    
public static string XmlFoundNodeType;
    
public static string XmlFoundText;
    
public static string XmlFullStartElementExpected;
    
public static string XmlFullStartElementLocalNameNsExpected;
    
public static string XmlFullStartElementNameExpected;
    
public static string XmlIDDefined;
    
public static string XmlKeyAlreadyExists;
    
public static string XmlIllegalOutsideRoot;
    
public static string XmlInvalidBytes;
    
public static string XmlInvalidCharRef;
    
public static string XmlInvalidCommentChars;
    
public static string XmlInvalidDeclaration;
    
public static string XmlInvalidDepth;
    
public static string XmlInvalidEncoding;
    
public static string XmlInvalidFFFE;
    
public static string XmlInvalidFormat;
    
public static string XmlInvalidID;
    
public static string XmlInvalidOperation;
    
public static string XmlInvalidPrefixState;
    
public static string XmlInvalidQualifiedName;
    
public static string XmlInvalidRootData;
    
public static string XmlInvalidStandalone;
    
public static string XmlInvalidStream;
    
public static string XmlInvalidUniqueId;
    
public static string XmlInvalidUTF8Bytes;
    
public static string XmlInvalidVersion;
    
public static string XmlInvalidWriteState;
    
public static string XmlInvalidXmlByte;
    
public static string XmlInvalidXmlSpace;
    
public static string XmlLineInfo;
    
public static string XmlMalformedDecl;
    
public static string XmlMaxArrayLengthExceeded;
    
public static string XmlMaxNameTableCharCountExceeded;
    
public static string XmlMethodNotSupported;
    
public static string XmlMissingLowSurrogate;
    
public static string XmlMultipleRootElements;
    
public static string XmlNamespaceNotFound;
    
public static string XmlNestedArraysNotSupported;
    
public static string XmlNoRootElement;
    
public static string XmlOnlyOneRoot;
    
public static string XmlOnlyWhitespace;
    
public static string XmlOnlySingleValue;
    
public static string XmlPrefixBoundToNamespace;
    
public static string XmlProcessingInstructionNotSupported;
    
public static string XmlReservedPrefix;
    
public static string XmlSpaceBetweenAttributes;
    
public static string XmlSpecificBindingNamespace;
    
public static string XmlSpecificBindingPrefix;
    
public static string XmlStartElementLocalNameNsExpected;
    
public static string XmlStartElementNameExpected;
    
public static string XmlTagMismatch;
    
public static string XmlTokenExpected;
    
public static string XmlUndefinedPrefix;
    
public static string XmlUnexpectedEndElement;
    
public static string XmlUnexpectedEndOfFile;
    
public static string XmlWriterClosed;
    
public static string Xml_InvalidNmToken;
    
public static string AbstractElementNotSupported;
    
public static string AbstractTypeNotSupported;
    
public static string AmbiguousReferencedCollectionTypes1;
    
public static string AmbiguousReferencedCollectionTypes3;
    
public static string AmbiguousReferencedTypes1;
    
public static string AmbiguousReferencedTypes3;
    
public static string AnnotationAttributeNotFound;
    
public static string AnonymousTypeNotSupported;
    
public static string AnyAttributeNotSupported;
    
public static string ArrayItemFormMustBe;
    
public static string ArraySizeAttributeIncorrect;
    
public static string ArrayTypeCannotBeImported;
    
public static string AssemblyNotFound;
    
public static string AttributeNotFound;
    
public static string BaseTypeNotISerializable;
    
public static string CannotComputeUniqueName;
    
public static string CannotDeriveFromSealedReferenceType;
    
public static string CannotDeserializeForwardedType;
    
public static string CannotExportNullAssembly;
    
public static string CannotExportNullKnownType;
    
public static string CannotExportNullType;
    
public static string CannotHaveDuplicateAttributeNames;
    
public static string CannotHaveDuplicateElementNames;
    
public static string CannotImportInvalidSchemas;
    
public static string CannotImportNullDataContractName;
    
public static string CannotImportNullSchema;
    
public static string CannotSetMembersForReferencedType;
    
public static string CannotSetNamespaceForReferencedType;
    
public static string CannotUseGenericTypeAsBase;
    
public static string ChangingFullTypeNameNotSupported;
    
public static string CircularTypeReference;
    
public static string ClassDataContractReturnedForGetOnlyCollection;
    
public static string CLRNamespaceMappedMultipleTimes;
    
public static string ClrTypeNotFound;
    
public static string CollectionAssignedToIncompatibleInterface;
    
public static string ComplexTypeRestrictionNotSupported;
    
public static string ConfigDataContractSerializerSectionLoadError;
    
public static string ConfigIndexOutOfRange;
    
public static string ConfigMustOnlyAddParamsWithType;
    
public static string ConfigMustOnlySetTypeOrIndex;
    
public static string ConfigMustSetTypeOrIndex;
    
public static string CouldNotReadSerializationSchema;
    
public static string DefaultOnElementNotSupported;
    
public static string DerivedTypeNotISerializable;
    
public static string DupContractInDataContractSet;
    
public static string DuplicateExtensionDataSetMethod;
    
public static string DupTypeContractInDataContractSet;
    
public static string ElementMaxOccursMustBe;
    
public static string ElementMinOccursMustBe;
    
public static string ElementRefOnLocalElementNotSupported;
    
public static string EnumEnumerationFacetsMustHaveValue;
    
public static string EnumListInAnonymousTypeNotSupported;
    
public static string EnumListMustContainAnonymousType;
    
public static string EnumOnlyEnumerationFacetsSupported;
    
public static string EnumRestrictionInvalid;
    
public static string EnumTypeCannotBeImported;
    
public static string EnumTypeNotSupportedByDataContractJsonSerializer;
    
public static string EnumUnionInAnonymousTypeNotSupported;
    
public static string ExtensionDataSetMustReturnVoid;
    
public static string ExtensionDataSetParameterInvalid;
    
public static string FactoryObjectContainsSelfReference;
    
public static string FactoryTypeNotISerializable;
    
public static string FixedOnElementNotSupported;
    
public static string FlushBufferAlreadyInUse;
    
public static string FormMustBeQualified;
    
public static string GenericAnnotationAttributeNotFound;
    
public static string GenericAnnotationForNestedLevelMustBeIncreasing;
    
public static string GenericAnnotationHasInvalidAttributeValue;
    
public static string GenericAnnotationHasInvalidElement;
    
public static string GenericTypeNameMismatch;
    
public static string GenericTypeNotExportable;
    
public static string GetOnlyCollectionMustHaveAddMethod;
    
public static string GetRealObjectReturnedNull;
    
public static string InvalidAnnotationExpectingText;
    
public static string InvalidAssemblyFormat;
    
public static string InvalidCharacterEncountered;
    
public static string InvalidClassDerivation;
    
public static string InvalidClrNameGeneratedForISerializable;
    
public static string InvalidClrNamespaceGeneratedForISerializable;
    
public static string InvalidDataNode;
    
public static string InvalidEmitDefaultAnnotation;
    
public static string InvalidEnumBaseType;
    
public static string InvalidISerializableDerivation;
    
public static string InvalidKeyValueType;
    
public static string InvalidKeyValueTypeNamespace;
    
public static string InvalidReturnSchemaOnGetSchemaMethod;
    
public static string InvalidStateInExtensionDataReader;
    
public static string InvalidXmlDeserializingExtensionData;
    
public static string IsAnyNotSupportedByNetDataContractSerializer;
    
public static string IsDictionaryFormattedIncorrectly;
    
public static string ISerializableAssemblyNameSetToZero;
    
public static string ISerializableCannotHaveDataContract;
    
public static string ISerializableContainsMoreThanOneItems;
    
public static string ISerializableDerivedContainsOneOrMoreItems;
    
public static string ISerializableDoesNotContainAny;
    
public static string ISerializableMustRefFactoryTypeAttribute;
    
public static string ISerializableTypeCannotBeImported;
    
public static string ISerializableWildcardMaxOccursMustBe;
    
public static string ISerializableWildcardMinOccursMustBe;
    
public static string ISerializableWildcardNamespaceInvalid;
    
public static string ISerializableWildcardProcessContentsInvalid;
    
public static string IsReferenceGetOnlyCollectionsNotSupported;
    
public static string IsValueTypeFormattedIncorrectly;
    
public static string JsonAttributeAlreadyWritten;
    
public static string JsonAttributeMustHaveElement;
    
public static string JsonCannotWriteStandaloneTextAfterQuotedText;
    
public static string JsonCannotWriteTextAfterNonTextAttribute;
    
public static string JsonDateTimeOutOfRange;
    
public static string JsonDuplicateMemberInInput;
    
public static string JsonDuplicateMemberNames;
    
public static string JsonEncodingNotSupported;
    
public static string JsonEncounteredUnexpectedCharacter;
    
public static string JsonEndElementNoOpenNodes;
    
public static string JsonExpectedEncoding;
    
public static string JsonInvalidBytes;
    
public static string JsonInvalidDataTypeSpecifiedForServerType;
    
public static string JsonInvalidDateTimeString;
    
public static string JsonInvalidFFFE;
    
public static string JsonInvalidItemNameForArrayElement;
    
public static string JsonInvalidLocalNameEmpty;
    
public static string JsonInvalidMethodBetweenStartEndAttribute;
    
public static string JsonInvalidRootElementName;
    
public static string JsonInvalidStartElementCall;
    
public static string JsonInvalidWriteState;
    
public static string JsonMethodNotSupported;
    
public static string JsonMultipleRootElementsNotAllowedOnWriter;
    
public static string JsonMustSpecifyDataType;
    
public static string JsonMustUseWriteStringForWritingAttributeValues;
    
public static string JsonNamespaceMustBeEmpty;
    
public static string JsonNestedArraysNotSupported;
    
public static string JsonNodeTypeArrayOrObjectNotSpecified;
    
public static string JsonNoMatchingStartAttribute;
    
public static string JsonOffsetExceedsBufferSize;
    
public static string JsonOneRequiredMemberNotFound;
    
public static string JsonOnlyWhitespace;
    
public static string JsonOpenAttributeMustBeClosedFirst;
    
public static string JsonPrefixMustBeNullOrEmpty;
    
public static string JsonRequiredMembersNotFound;
    
public static string JsonServerTypeSpecifiedForInvalidDataType;
    
public static string JsonSizeExceedsRemainingBufferSpace;
    
public static string JsonTypeNotSupportedByDataContractJsonSerializer;
    
public static string JsonUnexpectedAttributeLocalName;
    
public static string JsonUnexpectedAttributeValue;
    
public static string JsonUnexpectedEndOfFile;
    
public static string JsonUnsupportedForIsReference;
    
public static string JsonWriteArrayNotSupported;
    
public static string JsonWriterClosed;
    
public static string JsonXmlInvalidDeclaration;
    
public static string JsonXmlProcessingInstructionNotSupported;
    
public static string KeyTypeCannotBeParsedInSimpleDictionary;
    
public static string KnownTypeConfigGenericParamMismatch;
    
public static string KnownTypeConfigIndexOutOfBounds;
    
public static string KnownTypeConfigIndexOutOfBoundsZero;
    
public static string KnownTypeConfigObject;
    
public static string MaxMimePartsExceeded;
    
public static string MimeContentTypeHeaderInvalid;
    
public static string MimeHeaderInvalidCharacter;
    
public static string MimeMessageGetContentStreamCalledAlready;
    
public static string MimeReaderHeaderAlreadyExists;
    
public static string MimeReaderMalformedHeader;
    
public static string MimeReaderResetCalledBeforeEOF;
    
public static string MimeReaderTruncated;
    
public static string MimeVersionHeaderInvalid;
    
public static string MimeWriterInvalidStateForClose;
    
public static string MimeWriterInvalidStateForContent;
    
public static string MimeWriterInvalidStateForHeader;
    
public static string MimeWriterInvalidStateForStartPart;
    
public static string MimeWriterInvalidStateForStartPreface;
    
public static string MissingSchemaType;
    
public static string MixedContentNotSupported;
    
public static string MtomBoundaryInvalid;
    
public static string MtomBufferQuotaExceeded;
    
public static string MtomContentTransferEncodingNotPresent;
    
public static string MtomContentTransferEncodingNotSupported;
    
public static string MtomContentTypeInvalid;
    
public static string MtomDataMustNotContainXopInclude;
    
public static string MtomExceededMaxSizeInBytes;
    
public static string MtomInvalidCIDUri;
    
public static string MtomInvalidEmptyURI;
    
public static string MtomInvalidStartUri;
    
public static string MtomInvalidTransferEncodingForMimePart;
    
public static string MtomMessageContentTypeNotFound;
    
public static string MtomMessageInvalidContent;
    
public static string MtomMessageInvalidContentInMimePart;
    
public static string MtomMessageInvalidMimeVersion;
    
public static string MtomMessageNotApplicationXopXml;
    
public static string MtomMessageNotMultipart;
    
public static string MtomMessageRequiredParamNotSpecified;
    
public static string MtomMimePartReferencedMoreThanOnce;
    
public static string MtomPartNotFound;
    
public static string MtomRootContentTypeNotFound;
    
public static string MtomRootNotApplicationXopXml;
    
public static string MtomRootPartNotFound;
    
public static string MtomRootRequiredParamNotSpecified;
    
public static string MtomRootUnexpectedCharset;
    
public static string MtomRootUnexpectedType;
    
public static string MtomXopIncludeHrefNotSpecified;
    
public static string MtomXopIncludeInvalidXopAttributes;
    
public static string MtomXopIncludeInvalidXopElement;
    
public static string MustContainOnlyLocalElements;
    
public static string NoAsyncWritePending;
    
public static string NonOptionalFieldMemberOnIsReferenceSerializableType;
    
public static string OnlyDataContractTypesCanHaveExtensionData;
    
public static string PartialTrustISerializableNoPublicConstructor;
    
public static string QueryGeneratorPathToMemberNotFound;
    
public static string ReadNotSupportedOnStream;
    
public static string ReadOnlyClassDeserialization;
    
public static string ReadOnlyCollectionDeserialization;
    
public static string RecursiveCollectionType;
    
public static string RedefineNotSupported;
    
public static string ReferencedBaseTypeDoesNotExist;
    
public static string ReferencedCollectionTypesCannotContainNull;
    
public static string ReferencedTypeDoesNotMatch;
    
public static string ReferencedTypeMatchingMessage;
    
public static string ReferencedTypeNotMatchingMessage;
    
public static string ReferencedTypesCannotContainNull;
    
public static string RequiresClassDataContractToSetIsISerializable;
    
public static string RootParticleMustBeSequence;
    
public static string RootSequenceMaxOccursMustBe;
    
public static string RootSequenceMustBeRequired;
    
public static string SeekNotSupportedOnStream;
    
public static string SerializationInfo_ConstructorNotFound;
    
public static string SimpleContentNotSupported;
    
public static string SimpleTypeRestrictionDoesNotSpecifyBase;
    
public static string SimpleTypeUnionNotSupported;
    
public static string SpecifiedTypeNotFoundInSchema;
    
public static string SubstitutionGroupOnElementNotSupported;
    
public static string SurrogatesWithGetOnlyCollectionsNotSupported;
    
public static string SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser;
    
public static string TopLevelElementRepresentsDifferentType;
    
public static string TraceCodeElementIgnored;
    
public static string TraceCodeFactoryTypeNotFound;
    
public static string TraceCodeObjectWithLargeDepth;
    
public static string TraceCodeReadObjectBegin;
    
public static string TraceCodeReadObjectEnd;
    
public static string TraceCodeWriteObjectBegin;
    
public static string TraceCodeWriteObjectContentBegin;
    
public static string TraceCodeWriteObjectContentEnd;
    
public static string TraceCodeWriteObjectEnd;
    
public static string TraceCodeXsdExportAnnotationFailed;
    
public static string TraceCodeXsdExportBegin;
    
public static string TraceCodeXsdExportDupItems;
    
public static string TraceCodeXsdExportEnd;
    
public static string TraceCodeXsdExportError;
    
public static string TraceCodeXsdImportAnnotationFailed;
    
public static string TraceCodeXsdImportBegin;
    
public static string TraceCodeXsdImportEnd;
    
public static string TraceCodeXsdImportError;
    
public static string TypeCannotBeForwardedFrom;
    
public static string TypeCannotBeImported;
    
public static string TypeCannotBeImportedHowToFix;
    
public static string TypeHasNotBeenImported;
    
public static string TypeMustBeIXmlSerializable;
    
public static string TypeShouldNotContainAttributes;
    
public static string UnknownXmlType;
    
public static string WriteBufferOverflow;
    
public static string WriteNotSupportedOnStream;
    
public static string XmlCanonicalizationNotStarted;
    
public static string XmlCanonicalizationStarted;
    
public static string XmlMaxArrayLengthOrMaxItemsQuotaExceeded;
    
public static string XmlMaxBytesPerReadExceeded;
    
public static string XmlMaxDepthExceeded;
    
public static string XmlMaxStringContentLengthExceeded;
    
public static string XmlObjectAssignedToIncompatibleInterface;
    internal static string GetString(string name, Object[] args);
    internal static string GetString(CultureInfo culture, string name, Object[] args);
    internal static string GetString(string name);
    internal static string GetString(CultureInfo culture, string name);
}
internal class System.Runtime.Serialization.StringDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal StringDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.SurrogateDataContract : DataContract {
    [SecurityCriticalAttribute]

private SurrogateDataContractCriticalHelper helper;
    
internal ISerializationSurrogate SerializationSurrogate { get; }
    [SecuritySafeCriticalAttribute]
internal SurrogateDataContract(Type type, ISerializationSurrogate serializationSurrogate);
    [SecuritySafeCriticalAttribute]
internal ISerializationSurrogate get_SerializationSurrogate();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    [SecuritySafeCriticalAttribute]
private object SerializationSurrogateSetObjectData(object obj, SerializationInfo serInfo, StreamingContext context);
    [SecuritySafeCriticalAttribute]
internal static object GetRealObject(IObjectReference obj, StreamingContext context);
    [SecuritySafeCriticalAttribute]
private object GetUninitializedObject(Type objType);
    [SecuritySafeCriticalAttribute]
private void SerializationSurrogateGetObjectData(object obj, SerializationInfo serInfo, StreamingContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.TimeDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.TimeSpanDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal TimeSpanDataContract(XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.TokenDataContract : StringDataContract {
}
internal class System.Runtime.Serialization.TypeHandleRef : object {
    
private RuntimeTypeHandle value;
    
public RuntimeTypeHandle Value { get; public set; }
    public TypeHandleRef(RuntimeTypeHandle value);
    public RuntimeTypeHandle get_Value();
    public void set_Value(RuntimeTypeHandle value);
}
internal class System.Runtime.Serialization.TypeHandleRefEqualityComparer : object {
    public sealed virtual bool Equals(TypeHandleRef x, TypeHandleRef y);
    public sealed virtual int GetHashCode(TypeHandleRef obj);
}
internal class System.Runtime.Serialization.TypeInformation : object {
    
private string fullTypeName;
    
private string assemblyString;
    
private bool hasTypeForwardedFrom;
    
internal string FullTypeName { get; }
    
internal string AssemblyString { get; }
    
internal bool HasTypeForwardedFrom { get; }
    internal TypeInformation(string fullTypeName, string assemblyString, bool hasTypeForwardedFrom);
    internal string get_FullTypeName();
    internal string get_AssemblyString();
    internal bool get_HasTypeForwardedFrom();
}
internal class System.Runtime.Serialization.UnsignedByteDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.UnsignedIntDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.UnsignedLongDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.UnsignedShortDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.UriDataContract : PrimitiveDataContract {
    
internal string WriteMethodName { get; }
    
internal string ReadMethodName { get; }
    internal virtual string get_WriteMethodName();
    internal virtual string get_ReadMethodName();
    public virtual void WriteXmlValue(XmlWriterDelegator writer, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator reader, XmlObjectSerializerReadContext context);
}
internal class System.Runtime.Serialization.XmlDataContract : DataContract {
    [SecurityCriticalAttribute]

private XmlDataContractCriticalHelper helper;
    
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; internal set; }
    
internal XmlSchemaType XsdType { get; internal set; }
    
internal bool IsAnonymous { get; }
    
internal bool HasRoot { get; internal set; }
    
internal XmlDictionaryString TopLevelElementName { get; internal set; }
    
internal XmlDictionaryString TopLevelElementNamespace { get; internal set; }
    
internal bool IsTopLevelElementNullable { get; internal set; }
    
internal bool IsTypeDefinedOnImport { get; internal set; }
    
internal CreateXmlSerializableDelegate CreateXmlSerializableDelegate { get; }
    
internal bool CanContainReferences { get; }
    
internal bool IsBuiltInDataContract { get; }
    [SecuritySafeCriticalAttribute]
internal XmlDataContract(Type type);
    [SecuritySafeCriticalAttribute]
internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    [SecurityCriticalAttribute]
internal virtual void set_KnownDataContracts(Dictionary`2<XmlQualifiedName, DataContract> value);
    [SecuritySafeCriticalAttribute]
internal XmlSchemaType get_XsdType();
    [SecurityCriticalAttribute]
internal void set_XsdType(XmlSchemaType value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsAnonymous();
    [SecuritySafeCriticalAttribute]
internal virtual bool get_HasRoot();
    [SecurityCriticalAttribute]
internal virtual void set_HasRoot(bool value);
    [SecuritySafeCriticalAttribute]
internal virtual XmlDictionaryString get_TopLevelElementName();
    [SecurityCriticalAttribute]
internal virtual void set_TopLevelElementName(XmlDictionaryString value);
    [SecuritySafeCriticalAttribute]
internal virtual XmlDictionaryString get_TopLevelElementNamespace();
    [SecurityCriticalAttribute]
internal virtual void set_TopLevelElementNamespace(XmlDictionaryString value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsTopLevelElementNullable();
    [SecurityCriticalAttribute]
internal void set_IsTopLevelElementNullable(bool value);
    [SecuritySafeCriticalAttribute]
internal bool get_IsTypeDefinedOnImport();
    [SecurityCriticalAttribute]
internal void set_IsTypeDefinedOnImport(bool value);
    [SecuritySafeCriticalAttribute]
internal CreateXmlSerializableDelegate get_CreateXmlSerializableDelegate();
    internal virtual bool get_CanContainReferences();
    internal virtual bool get_IsBuiltInDataContract();
    private ConstructorInfo GetConstructor();
    [SecurityCriticalAttribute]
internal void SetTopLevelElementName(XmlQualifiedName elementName);
    internal virtual bool Equals(object other, Dictionary`2<DataContractPairKey, object> checkedContracts);
    public virtual int GetHashCode();
    public virtual void WriteXmlValue(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context);
    public virtual object ReadXmlValue(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context);
    internal CreateXmlSerializableDelegate GenerateCreateXmlSerializableDelegate();
    [CompilerGeneratedAttribute]
private IXmlSerializable <GenerateCreateXmlSerializableDelegate>b__39_0();
}
internal class System.Runtime.Serialization.XmlDataContractInterpreter : object {
    
private XmlDataContract contract;
    public XmlDataContractInterpreter(XmlDataContract contract);
    public IXmlSerializable CreateXmlSerializable();
    private ConstructorInfo GetConstructor();
}
internal class System.Runtime.Serialization.XmlDataNode : DataNode`1<object> {
    
private IList`1<XmlAttribute> xmlAttributes;
    
private IList`1<XmlNode> xmlChildNodes;
    
private XmlDocument ownerDocument;
    
internal IList`1<XmlAttribute> XmlAttributes { get; internal set; }
    
internal IList`1<XmlNode> XmlChildNodes { get; internal set; }
    
internal XmlDocument OwnerDocument { get; internal set; }
    internal IList`1<XmlAttribute> get_XmlAttributes();
    internal void set_XmlAttributes(IList`1<XmlAttribute> value);
    internal IList`1<XmlNode> get_XmlChildNodes();
    internal void set_XmlChildNodes(IList`1<XmlNode> value);
    internal XmlDocument get_OwnerDocument();
    internal void set_OwnerDocument(XmlDocument value);
    public virtual void Clear();
}
internal class System.Runtime.Serialization.XmlFormatClassReaderDelegate : MulticastDelegate {
    public XmlFormatClassReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatClassWriterDelegate : MulticastDelegate {
    public XmlFormatClassWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatCollectionReaderDelegate : MulticastDelegate {
    public XmlFormatCollectionReaderDelegate(object object, IntPtr method);
    public virtual object Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatCollectionWriterDelegate : MulticastDelegate {
    public XmlFormatCollectionWriterDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract dataContract);
    public virtual IAsyncResult BeginInvoke(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract dataContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Runtime.Serialization.XmlFormatGeneratorStatics : object {
    [SecurityCriticalAttribute]

private static MethodInfo writeStartElementMethod2;
    [SecurityCriticalAttribute]

private static MethodInfo writeStartElementMethod3;
    [SecurityCriticalAttribute]

private static MethodInfo writeEndElementMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeNamespaceDeclMethod;
    [SecurityCriticalAttribute]

private static PropertyInfo extensionDataProperty;
    [SecurityCriticalAttribute]

private static MethodInfo boxPointer;
    [SecurityCriticalAttribute]

private static ConstructorInfo dictionaryEnumeratorCtor;
    [SecurityCriticalAttribute]

private static MethodInfo ienumeratorMoveNextMethod;
    [SecurityCriticalAttribute]

private static MethodInfo ienumeratorGetCurrentMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getItemContractMethod;
    [SecurityCriticalAttribute]

private static MethodInfo isStartElementMethod2;
    [SecurityCriticalAttribute]

private static MethodInfo isStartElementMethod0;
    [SecurityCriticalAttribute]

private static MethodInfo getUninitializedObjectMethod;
    [SecurityCriticalAttribute]

private static MethodInfo onDeserializationMethod;
    [SecurityCriticalAttribute]

private static MethodInfo unboxPointer;
    [SecurityCriticalAttribute]

private static PropertyInfo nodeTypeProperty;
    [SecurityCriticalAttribute]

private static ConstructorInfo serializationExceptionCtor;
    [SecurityCriticalAttribute]

private static ConstructorInfo extensionDataObjectCtor;
    [SecurityCriticalAttribute]

private static ConstructorInfo hashtableCtor;
    [SecurityCriticalAttribute]

private static MethodInfo getStreamingContextMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getCollectionMemberMethod;
    [SecurityCriticalAttribute]

private static MethodInfo storeCollectionMemberInfoMethod;
    [SecurityCriticalAttribute]

private static MethodInfo storeIsGetOnlyCollectionMethod;
    [SecurityCriticalAttribute]

private static MethodInfo throwNullValueReturnedForGetOnlyCollectionExceptionMethod;
    
private static MethodInfo throwArrayExceededSizeExceptionMethod;
    [SecurityCriticalAttribute]

private static MethodInfo incrementItemCountMethod;
    [SecurityCriticalAttribute]

private static MethodInfo demandSerializationFormatterPermissionMethod;
    [SecurityCriticalAttribute]

private static MethodInfo demandMemberAccessPermissionMethod;
    [SecurityCriticalAttribute]

private static MethodInfo internalDeserializeMethod;
    [SecurityCriticalAttribute]

private static MethodInfo moveToNextElementMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getMemberIndexMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getMemberIndexWithRequiredMembersMethod;
    [SecurityCriticalAttribute]

private static MethodInfo throwRequiredMemberMissingExceptionMethod;
    [SecurityCriticalAttribute]

private static MethodInfo skipUnknownElementMethod;
    [SecurityCriticalAttribute]

private static MethodInfo readIfNullOrRefMethod;
    [SecurityCriticalAttribute]

private static MethodInfo readAttributesMethod;
    [SecurityCriticalAttribute]

private static MethodInfo resetAttributesMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getObjectIdMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getArraySizeMethod;
    [SecurityCriticalAttribute]

private static MethodInfo addNewObjectMethod;
    [SecurityCriticalAttribute]

private static MethodInfo addNewObjectWithIdMethod;
    [SecurityCriticalAttribute]

private static MethodInfo replaceDeserializedObjectMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getExistingObjectMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getRealObjectMethod;
    [SecurityCriticalAttribute]

private static MethodInfo readMethod;
    [SecurityCriticalAttribute]

private static MethodInfo ensureArraySizeMethod;
    [SecurityCriticalAttribute]

private static MethodInfo trimArraySizeMethod;
    [SecurityCriticalAttribute]

private static MethodInfo checkEndOfArrayMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getArrayLengthMethod;
    [SecurityCriticalAttribute]

private static MethodInfo readSerializationInfoMethod;
    [SecurityCriticalAttribute]

private static MethodInfo createUnexpectedStateExceptionMethod;
    [SecurityCriticalAttribute]

private static MethodInfo internalSerializeReferenceMethod;
    [SecurityCriticalAttribute]

private static MethodInfo internalSerializeMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeNullMethod;
    [SecurityCriticalAttribute]

private static MethodInfo incrementArrayCountMethod;
    [SecurityCriticalAttribute]

private static MethodInfo incrementCollectionCountMethod;
    [SecurityCriticalAttribute]

private static MethodInfo incrementCollectionCountGenericMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getDefaultValueMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getNullableValueMethod;
    [SecurityCriticalAttribute]

private static MethodInfo throwRequiredMemberMustBeEmittedMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getHasValueMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeISerializableMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeExtensionDataMethod;
    [SecurityCriticalAttribute]

private static MethodInfo writeXmlValueMethod;
    [SecurityCriticalAttribute]

private static MethodInfo readXmlValueMethod;
    [SecurityCriticalAttribute]

private static MethodInfo throwTypeNotSerializableMethod;
    [SecurityCriticalAttribute]

private static PropertyInfo namespaceProperty;
    [SecurityCriticalAttribute]

private static FieldInfo contractNamespacesField;
    [SecurityCriticalAttribute]

private static FieldInfo memberNamesField;
    [SecurityCriticalAttribute]

private static MethodInfo extensionDataSetExplicitMethodInfo;
    [SecurityCriticalAttribute]

private static PropertyInfo childElementNamespacesProperty;
    [SecurityCriticalAttribute]

private static PropertyInfo collectionItemNameProperty;
    [SecurityCriticalAttribute]

private static PropertyInfo childElementNamespaceProperty;
    [SecurityCriticalAttribute]

private static MethodInfo getDateTimeOffsetMethod;
    [SecurityCriticalAttribute]

private static MethodInfo getDateTimeOffsetAdapterMethod;
    [SecurityCriticalAttribute]

private static MethodInfo traceInstructionMethod;
    [SecurityCriticalAttribute]

private static MethodInfo throwInvalidDataContractExceptionMethod;
    [SecurityCriticalAttribute]

private static PropertyInfo serializeReadOnlyTypesProperty;
    [SecurityCriticalAttribute]

private static PropertyInfo classSerializationExceptionMessageProperty;
    [SecurityCriticalAttribute]

private static PropertyInfo collectionSerializationExceptionMessageProperty;
    
internal static MethodInfo WriteStartElementMethod2 { get; }
    
internal static MethodInfo WriteStartElementMethod3 { get; }
    
internal static MethodInfo WriteEndElementMethod { get; }
    
internal static MethodInfo WriteNamespaceDeclMethod { get; }
    
internal static PropertyInfo ExtensionDataProperty { get; }
    
internal static MethodInfo BoxPointer { get; }
    
internal static ConstructorInfo DictionaryEnumeratorCtor { get; }
    
internal static MethodInfo MoveNextMethod { get; }
    
internal static MethodInfo GetCurrentMethod { get; }
    
internal static MethodInfo GetItemContractMethod { get; }
    
internal static MethodInfo IsStartElementMethod2 { get; }
    
internal static MethodInfo IsStartElementMethod0 { get; }
    
internal static MethodInfo GetUninitializedObjectMethod { get; }
    
internal static MethodInfo OnDeserializationMethod { get; }
    
internal static MethodInfo UnboxPointer { get; }
    
internal static PropertyInfo NodeTypeProperty { get; }
    
internal static ConstructorInfo SerializationExceptionCtor { get; }
    
internal static ConstructorInfo ExtensionDataObjectCtor { get; }
    
internal static ConstructorInfo HashtableCtor { get; }
    
internal static MethodInfo GetStreamingContextMethod { get; }
    
internal static MethodInfo GetCollectionMemberMethod { get; }
    
internal static MethodInfo StoreCollectionMemberInfoMethod { get; }
    
internal static MethodInfo StoreIsGetOnlyCollectionMethod { get; }
    
internal static MethodInfo ThrowNullValueReturnedForGetOnlyCollectionExceptionMethod { get; }
    
internal static MethodInfo ThrowArrayExceededSizeExceptionMethod { get; }
    
internal static MethodInfo IncrementItemCountMethod { get; }
    
internal static MethodInfo DemandSerializationFormatterPermissionMethod { get; }
    
internal static MethodInfo DemandMemberAccessPermissionMethod { get; }
    
internal static MethodInfo InternalDeserializeMethod { get; }
    
internal static MethodInfo MoveToNextElementMethod { get; }
    
internal static MethodInfo GetMemberIndexMethod { get; }
    
internal static MethodInfo GetMemberIndexWithRequiredMembersMethod { get; }
    
internal static MethodInfo ThrowRequiredMemberMissingExceptionMethod { get; }
    
internal static MethodInfo SkipUnknownElementMethod { get; }
    
internal static MethodInfo ReadIfNullOrRefMethod { get; }
    
internal static MethodInfo ReadAttributesMethod { get; }
    
internal static MethodInfo ResetAttributesMethod { get; }
    
internal static MethodInfo GetObjectIdMethod { get; }
    
internal static MethodInfo GetArraySizeMethod { get; }
    
internal static MethodInfo AddNewObjectMethod { get; }
    
internal static MethodInfo AddNewObjectWithIdMethod { get; }
    
internal static MethodInfo ReplaceDeserializedObjectMethod { get; }
    
internal static MethodInfo GetExistingObjectMethod { get; }
    
internal static MethodInfo GetRealObjectMethod { get; }
    
internal static MethodInfo ReadMethod { get; }
    
internal static MethodInfo EnsureArraySizeMethod { get; }
    
internal static MethodInfo TrimArraySizeMethod { get; }
    
internal static MethodInfo CheckEndOfArrayMethod { get; }
    
internal static MethodInfo GetArrayLengthMethod { get; }
    
internal static MethodInfo ReadSerializationInfoMethod { get; }
    
internal static MethodInfo CreateUnexpectedStateExceptionMethod { get; }
    
internal static MethodInfo InternalSerializeReferenceMethod { get; }
    
internal static MethodInfo InternalSerializeMethod { get; }
    
internal static MethodInfo WriteNullMethod { get; }
    
internal static MethodInfo IncrementArrayCountMethod { get; }
    
internal static MethodInfo IncrementCollectionCountMethod { get; }
    
internal static MethodInfo IncrementCollectionCountGenericMethod { get; }
    
internal static MethodInfo GetDefaultValueMethod { get; }
    
internal static MethodInfo GetNullableValueMethod { get; }
    
internal static MethodInfo ThrowRequiredMemberMustBeEmittedMethod { get; }
    
internal static MethodInfo GetHasValueMethod { get; }
    
internal static MethodInfo WriteISerializableMethod { get; }
    
internal static MethodInfo WriteExtensionDataMethod { get; }
    
internal static MethodInfo WriteXmlValueMethod { get; }
    
internal static MethodInfo ReadXmlValueMethod { get; }
    
internal static MethodInfo ThrowTypeNotSerializableMethod { get; }
    
internal static PropertyInfo NamespaceProperty { get; }
    
internal static FieldInfo ContractNamespacesField { get; }
    
internal static FieldInfo MemberNamesField { get; }
    
internal static MethodInfo ExtensionDataSetExplicitMethodInfo { get; }
    
internal static PropertyInfo ChildElementNamespacesProperty { get; }
    
internal static PropertyInfo CollectionItemNameProperty { get; }
    
internal static PropertyInfo ChildElementNamespaceProperty { get; }
    
internal static MethodInfo GetDateTimeOffsetMethod { get; }
    
internal static MethodInfo GetDateTimeOffsetAdapterMethod { get; }
    
internal static MethodInfo TraceInstructionMethod { get; }
    
internal static MethodInfo ThrowInvalidDataContractExceptionMethod { get; }
    
internal static PropertyInfo SerializeReadOnlyTypesProperty { get; }
    
internal static PropertyInfo ClassSerializationExceptionMessageProperty { get; }
    
internal static PropertyInfo CollectionSerializationExceptionMessageProperty { get; }
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteStartElementMethod2();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteStartElementMethod3();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteEndElementMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteNamespaceDeclMethod();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_ExtensionDataProperty();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_BoxPointer();
    [SecuritySafeCriticalAttribute]
internal static ConstructorInfo get_DictionaryEnumeratorCtor();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_MoveNextMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetCurrentMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetItemContractMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IsStartElementMethod2();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IsStartElementMethod0();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetUninitializedObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_OnDeserializationMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_UnboxPointer();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_NodeTypeProperty();
    [SecuritySafeCriticalAttribute]
internal static ConstructorInfo get_SerializationExceptionCtor();
    [SecuritySafeCriticalAttribute]
internal static ConstructorInfo get_ExtensionDataObjectCtor();
    [SecuritySafeCriticalAttribute]
internal static ConstructorInfo get_HashtableCtor();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetStreamingContextMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetCollectionMemberMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_StoreCollectionMemberInfoMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_StoreIsGetOnlyCollectionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowNullValueReturnedForGetOnlyCollectionExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowArrayExceededSizeExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IncrementItemCountMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_DemandSerializationFormatterPermissionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_DemandMemberAccessPermissionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_InternalDeserializeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_MoveToNextElementMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetMemberIndexMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetMemberIndexWithRequiredMembersMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowRequiredMemberMissingExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_SkipUnknownElementMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadIfNullOrRefMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadAttributesMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ResetAttributesMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetObjectIdMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetArraySizeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_AddNewObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_AddNewObjectWithIdMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReplaceDeserializedObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetExistingObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetRealObjectMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_EnsureArraySizeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_TrimArraySizeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_CheckEndOfArrayMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetArrayLengthMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadSerializationInfoMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_CreateUnexpectedStateExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_InternalSerializeReferenceMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_InternalSerializeMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteNullMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IncrementArrayCountMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IncrementCollectionCountMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_IncrementCollectionCountGenericMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetDefaultValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetNullableValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowRequiredMemberMustBeEmittedMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetHasValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteISerializableMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteExtensionDataMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_WriteXmlValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ReadXmlValueMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowTypeNotSerializableMethod();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_NamespaceProperty();
    [SecuritySafeCriticalAttribute]
internal static FieldInfo get_ContractNamespacesField();
    [SecuritySafeCriticalAttribute]
internal static FieldInfo get_MemberNamesField();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ExtensionDataSetExplicitMethodInfo();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_ChildElementNamespacesProperty();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_CollectionItemNameProperty();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_ChildElementNamespaceProperty();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetDateTimeOffsetMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_GetDateTimeOffsetAdapterMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_TraceInstructionMethod();
    [SecuritySafeCriticalAttribute]
internal static MethodInfo get_ThrowInvalidDataContractExceptionMethod();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_SerializeReadOnlyTypesProperty();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_ClassSerializationExceptionMessageProperty();
    [SecuritySafeCriticalAttribute]
internal static PropertyInfo get_CollectionSerializationExceptionMessageProperty();
}
internal class System.Runtime.Serialization.XmlFormatGetOnlyCollectionReaderDelegate : MulticastDelegate {
    public XmlFormatGetOnlyCollectionReaderDelegate(object object, IntPtr method);
    public virtual void Invoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    public virtual IAsyncResult BeginInvoke(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.XmlFormatReaderGenerator : object {
    [SecurityCriticalAttribute]

private CriticalHelper helper;
    [SecurityCriticalAttribute]
public XmlFormatClassReaderDelegate GenerateClassReader(ClassDataContract classContract);
    [SecurityCriticalAttribute]
public XmlFormatCollectionReaderDelegate GenerateCollectionReader(CollectionDataContract collectionContract);
    [SecurityCriticalAttribute]
public XmlFormatGetOnlyCollectionReaderDelegate GenerateGetOnlyCollectionReader(CollectionDataContract collectionContract);
    [SecuritySafeCriticalAttribute]
internal static object UnsafeGetUninitializedObject(int id);
}
internal class System.Runtime.Serialization.XmlFormatReaderInterpreter : object {
    
private bool is_get_only_collection;
    
private ClassDataContract classContract;
    
private CollectionDataContract collectionContract;
    
private object objectLocal;
    
private Type objectType;
    
private XmlReaderDelegator xmlReader;
    
private XmlObjectSerializerReadContext context;
    
private XmlDictionaryString[] memberNames;
    
private XmlDictionaryString[] memberNamespaces;
    
private XmlDictionaryString itemName;
    
private XmlDictionaryString itemNamespace;
    public XmlFormatReaderInterpreter(ClassDataContract classContract);
    public XmlFormatReaderInterpreter(CollectionDataContract collectionContract, bool isGetOnly);
    public object ReadFromXml(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces);
    public object ReadCollectionFromXml(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    public void ReadGetOnlyCollectionFromXml(XmlReaderDelegator xmlReader, XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, CollectionDataContract collectionContract);
    private void CreateObject(ClassDataContract classContract);
    private void InvokeOnDeserializing(ClassDataContract classContract);
    private void InvokeOnDeserialized(ClassDataContract classContract);
    private bool HasFactoryMethod(ClassDataContract classContract);
    private bool InvokeFactoryMethod(ClassDataContract classContract, string objectId);
    private void ReadISerializable(ClassDataContract classContract);
    private void ReadClass(ClassDataContract classContract);
    private void ReadMembers(ClassDataContract classContract, ExtensionDataObject extensionData);
    private int ReadMembers(int index, ClassDataContract classContract, Boolean[] requiredMembers, Int32& memberIndex, Int32& requiredIndex);
    private Boolean[] GetRequiredMembers(ClassDataContract contract, Int32& firstRequiredMember);
    private int GetRequiredMembers(ClassDataContract contract, Boolean[] requiredMembers);
    private object ReadValue(Type type, string name, string ns);
    private object InternalDeserialize(Type type, string name, string ns);
    private object WrapNullableObject(Type innerType, object innerValue, Type outerType, int nullables);
    private void ReadCollection(CollectionDataContract collectionContract);
    private void ReadGetOnlyCollection(CollectionDataContract collectionContract);
    private bool TryReadPrimitiveArray(Type type, Type itemType, int size, Boolean& readResult);
    private object ReadCollectionItem(CollectionDataContract collectionContract, Type itemType, string itemName, string itemNs);
    private void StoreCollectionValue(object collection, Type valueType, object value, CollectionDataContract collectionContract);
    private void HandleUnexpectedItemInCollection(Int32& iterator);
    private bool IsStartElement(XmlDictionaryString name, XmlDictionaryString ns);
    private bool IsStartElement();
    private bool IsEndElement();
}
internal class System.Runtime.Serialization.XmlFormatWriterGenerator : object {
    [SecurityCriticalAttribute]

private CriticalHelper helper;
    [SecurityCriticalAttribute]
internal XmlFormatClassWriterDelegate GenerateClassWriter(ClassDataContract classContract);
    [SecurityCriticalAttribute]
internal XmlFormatCollectionWriterDelegate GenerateCollectionWriter(CollectionDataContract collectionContract);
}
internal class System.Runtime.Serialization.XmlFormatWriterInterpreter : object {
    
private ClassDataContract classContract;
    
private CollectionDataContract collectionContract;
    
private XmlWriterDelegator writer;
    
private object obj;
    
private XmlObjectSerializerWriteContext ctx;
    
private DataContract dataContract;
    
private object objLocal;
    
private XmlDictionaryString[] contractNamespaces;
    
private XmlDictionaryString[] memberNames;
    
private XmlDictionaryString[] childElementNamespaces;
    
private int typeIndex;
    
private int childElementIndex;
    
private ClassDataContract classDataContract { get; }
    
private CollectionDataContract collectionDataContract { get; }
    public XmlFormatWriterInterpreter(ClassDataContract classContract);
    public XmlFormatWriterInterpreter(CollectionDataContract collectionContract);
    private ClassDataContract get_classDataContract();
    private CollectionDataContract get_collectionDataContract();
    public void WriteToXml(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, ClassDataContract dataContract);
    public void WriteCollectionToXml(XmlWriterDelegator xmlWriter, object obj, XmlObjectSerializerWriteContext context, CollectionDataContract collectionContract);
    private void InitArgs(Type objType);
    private void InvokeOnSerializing(ClassDataContract classContract, object objSerialized, XmlObjectSerializerWriteContext ctx);
    private void InvokeOnSerialized(ClassDataContract classContract, object objSerialized, XmlObjectSerializerWriteContext ctx);
    private void WriteClass(ClassDataContract classContract);
    private void WriteCollection(CollectionDataContract collectionContract);
    private int WriteMembers(ClassDataContract classContract, ExtensionDataObject extensionData, ClassDataContract derivedMostClassContract);
    internal bool IsDefaultValue(Type type, object value);
    internal object GetDefaultValue(Type type);
    private bool CheckIfMemberHasConflict(DataMember member, ClassDataContract classContract, ClassDataContract derivedMostClassContract);
    private bool CheckIfConflictingMembersHaveDifferentTypes(DataMember member);
    private bool NeedsPrefix(Type type, XmlDictionaryString ns);
    private void WriteStartElement(Type type, XmlDictionaryString ns, XmlDictionaryString namespaceLocal, XmlDictionaryString nameLocal, int nameIndex);
    private void WriteEndElement();
    private void WriteValue(Type memberType, object memberValue, bool writeXsiType);
    private object UnwrapNullableObject(Func`1<object> memberValue, Type& memberType, Boolean& isNull);
    private bool TryWritePrimitive(Type type, Func`1<object> value, MemberInfo memberInfo, Nullable`1<int> arrayItemIndex, XmlDictionaryString ns, XmlDictionaryString name, int nameIndex);
    private bool TryWritePrimitiveArray(Type type, Type itemType, Func`1<object> value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    private object LoadMemberValue(DataMember member);
    [CompilerGeneratedAttribute]
private object <WriteCollection>b__24_0();
}
public abstract class System.Runtime.Serialization.XmlObjectSerializer : object {
    [SecurityCriticalAttribute]

private static IFormatterConverter formatterConverter;
    
internal Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    
internal static IFormatterConverter FormatterConverter { get; }
    public abstract virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    public abstract virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    public abstract virtual void WriteEndObject(XmlDictionaryWriter writer);
    public virtual void WriteObject(Stream stream, object graph);
    public virtual void WriteObject(XmlWriter writer, object graph);
    public virtual void WriteStartObject(XmlWriter writer, object graph);
    public virtual void WriteObjectContent(XmlWriter writer, object graph);
    public virtual void WriteEndObject(XmlWriter writer);
    public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    internal void WriteObjectHandleExceptions(XmlWriterDelegator writer, object graph);
    internal void WriteObjectHandleExceptions(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    internal virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObject(XmlWriterDelegator writer, object graph, DataContractResolver dataContractResolver);
    internal virtual void InternalWriteStartObject(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteObjectContent(XmlWriterDelegator writer, object graph);
    internal virtual void InternalWriteEndObject(XmlWriterDelegator writer);
    internal void WriteStartObjectHandleExceptions(XmlWriterDelegator writer, object graph);
    internal void WriteObjectContentHandleExceptions(XmlWriterDelegator writer, object graph);
    internal void WriteEndObjectHandleExceptions(XmlWriterDelegator writer);
    internal void WriteRootElement(XmlWriterDelegator writer, DataContract contract, XmlDictionaryString name, XmlDictionaryString ns, bool needsContractNsAtRoot);
    internal bool CheckIfNeedsContractNsAtRoot(XmlDictionaryString name, XmlDictionaryString ns, DataContract contract);
    internal static void WriteNull(XmlWriterDelegator writer);
    internal static bool IsContractDeclared(DataContract contract, DataContract declaredContract);
    public virtual object ReadObject(Stream stream);
    public virtual object ReadObject(XmlReader reader);
    public virtual object ReadObject(XmlDictionaryReader reader);
    public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    public abstract virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    public virtual bool IsStartObject(XmlReader reader);
    public abstract virtual bool IsStartObject(XmlDictionaryReader reader);
    internal virtual object InternalReadObject(XmlReaderDelegator reader, bool verifyObjectName);
    internal virtual object InternalReadObject(XmlReaderDelegator reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    internal virtual bool InternalIsStartObject(XmlReaderDelegator reader);
    internal object ReadObjectHandleExceptions(XmlReaderDelegator reader, bool verifyObjectName);
    internal object ReadObjectHandleExceptions(XmlReaderDelegator reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    internal bool IsStartObjectHandleExceptions(XmlReaderDelegator reader);
    internal bool IsRootXmlAny(XmlDictionaryString rootName, DataContract contract);
    internal bool IsStartElement(XmlReaderDelegator reader);
    internal bool IsRootElement(XmlReaderDelegator reader, DataContract contract, XmlDictionaryString name, XmlDictionaryString ns);
    internal static void CheckNull(object obj, string name);
    internal static string TryAddLineInfo(XmlReaderDelegator reader, string errorMessage);
    internal static Exception CreateSerializationExceptionWithReaderDetails(string errorMessage, XmlReaderDelegator reader);
    internal static SerializationException CreateSerializationException(string errorMessage);
    internal static SerializationException CreateSerializationException(string errorMessage, Exception innerException);
    private static string GetTypeInfo(Type type);
    private static string GetTypeInfoError(string errorMessage, Type type, Exception innerException);
    internal virtual Type GetSerializeType(object graph);
    internal virtual Type GetDeserializeType();
    [SecuritySafeCriticalAttribute]
internal static IFormatterConverter get_FormatterConverter();
}
internal class System.Runtime.Serialization.XmlObjectSerializerContext : object {
    
protected XmlObjectSerializer serializer;
    
protected DataContract rootTypeDataContract;
    
internal ScopedKnownTypes scopedKnownTypes;
    
protected Dictionary`2<XmlQualifiedName, DataContract> serializerKnownDataContracts;
    
private bool isSerializerKnownDataContractsSetExplicit;
    
protected IList`1<Type> serializerKnownTypeList;
    [SecurityCriticalAttribute]

private bool demandedSerializationFormatterPermission;
    [SecurityCriticalAttribute]

private bool demandedMemberAccessPermission;
    
private int itemCount;
    
private int maxItemsInObjectGraph;
    
private StreamingContext streamingContext;
    
private bool ignoreExtensionDataObject;
    
private DataContractResolver dataContractResolver;
    
private KnownTypeDataContractResolver knownTypeResolver;
    
private static MethodInfo incrementItemCountMethod;
    
internal SerializationMode Mode { get; }
    
internal bool IsGetOnlyCollection { get; internal set; }
    
internal static MethodInfo IncrementItemCountMethod { get; }
    
internal int RemainingItemCount { get; }
    
internal bool IgnoreExtensionDataObject { get; }
    
protected DataContractResolver DataContractResolver { get; }
    
protected KnownTypeDataContractResolver KnownTypeResolver { get; }
    
private Dictionary`2<XmlQualifiedName, DataContract> SerializerKnownDataContracts { get; }
    internal XmlObjectSerializerContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal XmlObjectSerializerContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerContext(NetDataContractSerializer serializer);
    internal virtual SerializationMode get_Mode();
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    [SecuritySafeCriticalAttribute]
public void DemandSerializationFormatterPermission();
    [SecuritySafeCriticalAttribute]
public void DemandMemberAccessPermission();
    public StreamingContext GetStreamingContext();
    internal static MethodInfo get_IncrementItemCountMethod();
    public void IncrementItemCount(int count);
    internal int get_RemainingItemCount();
    internal bool get_IgnoreExtensionDataObject();
    protected DataContractResolver get_DataContractResolver();
    protected KnownTypeDataContractResolver get_KnownTypeResolver();
    internal DataContract GetDataContract(Type type);
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    internal virtual Type GetSurrogatedType(Type type);
    private Dictionary`2<XmlQualifiedName, DataContract> get_SerializerKnownDataContracts();
    private DataContract GetDataContractFromSerializerKnownTypes(XmlQualifiedName qname);
    internal static Dictionary`2<XmlQualifiedName, DataContract> GetDataContractsForKnownTypes(IList`1<Type> knownTypeList);
    internal bool IsKnownType(DataContract dataContract, Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts, Type declaredType);
    internal bool IsKnownType(DataContract dataContract, Type declaredType);
    private DataContract ResolveDataContractFromKnownTypes(XmlQualifiedName typeName);
    private DataContract ResolveDataContractFromDataContractResolver(XmlQualifiedName typeName, Type declaredType);
    internal Type ResolveNameFromKnownTypes(XmlQualifiedName typeName);
    protected DataContract ResolveDataContractFromKnownTypes(string typeName, string typeNs, DataContract memberTypeContract, Type declaredType);
    protected virtual DataContract ResolveDataContractFromRootDataContract(XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.XmlObjectSerializerReadContext : XmlObjectSerializerContext {
    
internal Attributes attributes;
    
private HybridObjectCache deserializedObjects;
    
private XmlSerializableReader xmlSerializableReader;
    
private XmlDocument xmlDocument;
    
private Attributes attributesInXmlData;
    
private XmlReaderDelegator extensionDataReader;
    
private object getOnlyCollectionValue;
    
private bool isGetOnlyCollection;
    
private HybridObjectCache DeserializedObjects { get; }
    
private XmlDocument Document { get; }
    
internal bool IsGetOnlyCollection { get; internal set; }
    internal XmlObjectSerializerReadContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal XmlObjectSerializerReadContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    protected XmlObjectSerializerReadContext(NetDataContractSerializer serializer);
    private HybridObjectCache get_DeserializedObjects();
    private XmlDocument get_Document();
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    internal object GetCollectionMember();
    internal void StoreCollectionMemberInfo(object collectionMember);
    internal static void ThrowNullValueReturnedForGetOnlyCollectionException(Type type);
    internal static void ThrowArrayExceededSizeException(int arraySize, Type type);
    internal static XmlObjectSerializerReadContext CreateContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal static XmlObjectSerializerReadContext CreateContext(NetDataContractSerializer serializer);
    public virtual object InternalDeserialize(XmlReaderDelegator xmlReader, int id, RuntimeTypeHandle declaredTypeHandle, string name, string ns);
    internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, string name, string ns);
    internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, DataContract dataContract, string name, string ns);
    protected bool TryHandleNullOrRef(XmlReaderDelegator reader, Type declaredType, string name, string ns, Object& retObj);
    protected object InternalDeserialize(XmlReaderDelegator reader, string name, string ns, Type declaredType, DataContract& dataContract);
    private bool ReplaceScopedKnownTypesTop(Dictionary`2<XmlQualifiedName, DataContract> knownDataContracts, bool knownTypesAddedInCurrentScope);
    public static bool MoveToNextElement(XmlReaderDelegator xmlReader);
    public int GetMemberIndex(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, int memberIndex, ExtensionDataObject extensionData);
    public int GetMemberIndexWithRequiredMembers(XmlReaderDelegator xmlReader, XmlDictionaryString[] memberNames, XmlDictionaryString[] memberNamespaces, int memberIndex, int requiredIndex, ExtensionDataObject extensionData);
    public static void ThrowRequiredMemberMissingException(XmlReaderDelegator xmlReader, int memberIndex, int requiredIndex, XmlDictionaryString[] memberNames);
    protected void HandleMemberNotFound(XmlReaderDelegator xmlReader, ExtensionDataObject extensionData, int memberIndex);
    internal void HandleUnknownElement(XmlReaderDelegator xmlReader, ExtensionDataObject extensionData, int memberIndex);
    public void SkipUnknownElement(XmlReaderDelegator xmlReader);
    public string ReadIfNullOrRef(XmlReaderDelegator xmlReader, Type memberType, bool isMemberTypeSerializable);
    internal virtual void ReadAttributes(XmlReaderDelegator xmlReader);
    public void ResetAttributes();
    public string GetObjectId();
    internal virtual int GetArraySize();
    public void AddNewObject(object obj);
    public void AddNewObjectWithId(string id, object obj);
    public void ReplaceDeserializedObject(string id, object oldObj, object newObj);
    public object GetExistingObject(string id, Type type, string name, string ns);
    private object GetExistingObjectOrExtensionData(string id);
    public object GetRealObject(IObjectReference obj, string id);
    private object DeserializeFromExtensionData(IDataNode dataNode, Type type, string name, string ns);
    public static void Read(XmlReaderDelegator xmlReader);
    internal static void ParseQualifiedName(string qname, XmlReaderDelegator xmlReader, String& name, String& ns, String& prefix);
    public static T[] EnsureArraySize(T[] array, int index);
    public static T[] TrimArraySize(T[] array, int size);
    public void CheckEndOfArray(XmlReaderDelegator xmlReader, int arraySize, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal object ReadIXmlSerializable(XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    internal static object ReadRootIXmlSerializable(XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    internal static object ReadIXmlSerializable(XmlSerializableReader xmlSerializableReader, XmlReaderDelegator xmlReader, XmlDataContract xmlDataContract, bool isMemberType);
    public SerializationInfo ReadSerializationInfo(XmlReaderDelegator xmlReader, Type type);
    protected virtual DataContract ResolveDataContractFromTypeName();
    private ExtensionDataMember ReadExtensionDataMember(XmlReaderDelegator xmlReader, int memberIndex);
    public IDataNode ReadExtensionDataValue(XmlReaderDelegator xmlReader);
    protected virtual void StartReadExtensionDataValue(XmlReaderDelegator xmlReader);
    private IDataNode ReadExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    protected virtual IDataNode ReadPrimitiveExtensionDataValue(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    protected void InitializeExtensionDataNode(IDataNode dataNode, string dataContractName, string dataContractNamespace);
    private IDataNode ReadUnknownPrimitiveData(XmlReaderDelegator xmlReader, Type type, string dataContractName, string dataContractNamespace);
    private ClassDataNode ReadUnknownClassData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private CollectionDataNode ReadUnknownCollectionData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private ISerializableDataNode ReadUnknownISerializableData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private IDataNode ReadUnknownXmlData(XmlReaderDelegator xmlReader, string dataContractName, string dataContractNamespace);
    private IDataNode ReadAndResolveUnknownXmlData(XmlReaderDelegator xmlReader, IDictionary`2<string, string> namespaces, string dataContractName, string dataContractNamespace);
    private bool IsContentNode(XmlNodeType nodeType);
    internal XmlReaderDelegator CreateReaderOverChildNodes(IList`1<XmlAttribute> xmlAttributes, IList`1<XmlNode> xmlChildNodes);
    internal static XmlNode CreateWrapperXmlElement(XmlDocument document, IList`1<XmlAttribute> xmlAttributes, IList`1<XmlNode> xmlChildNodes, string prefix, string localName, string ns);
    private XmlAttribute AddNamespaceDeclaration(string prefix, string ns);
    public static Exception CreateUnexpectedStateException(XmlNodeType expectedState, XmlReaderDelegator xmlReader);
    protected virtual object ReadDataContractValue(DataContract dataContract, XmlReaderDelegator reader);
    protected virtual XmlReaderDelegator CreateReaderDelegatorForReader(XmlReader xmlReader);
    protected virtual bool IsReadingCollectionExtensionData(XmlReaderDelegator xmlReader);
    protected virtual bool IsReadingClassExtensionData(XmlReaderDelegator xmlReader);
}
internal class System.Runtime.Serialization.XmlObjectSerializerReadContextComplex : XmlObjectSerializerReadContext {
    
private static Hashtable dataContractTypeCache;
    
private bool preserveObjectReferences;
    
protected IDataContractSurrogate dataContractSurrogate;
    
private SerializationMode mode;
    
private SerializationBinder binder;
    
private ISurrogateSelector surrogateSelector;
    
private FormatterAssemblyStyle assemblyFormat;
    
private Hashtable surrogateDataContracts;
    
internal SerializationMode Mode { get; }
    internal XmlObjectSerializerReadContextComplex(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerReadContextComplex(NetDataContractSerializer serializer);
    internal XmlObjectSerializerReadContextComplex(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    private static XmlObjectSerializerReadContextComplex();
    internal virtual SerializationMode get_Mode();
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    public virtual object InternalDeserialize(XmlReaderDelegator xmlReader, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, string name, string ns);
    internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, string name, string ns);
    internal virtual object InternalDeserialize(XmlReaderDelegator xmlReader, Type declaredType, DataContract dataContract, string name, string ns);
    private object InternalDeserializeInSharedTypeMode(XmlReaderDelegator xmlReader, int declaredTypeID, Type declaredType, string name, string ns);
    private object InternalDeserializeWithSurrogate(XmlReaderDelegator xmlReader, Type declaredType, DataContract surrogateDataContract, string name, string ns);
    private Type ResolveDataContractTypeInSharedTypeMode(string assemblyName, string typeName, Assembly& assembly);
    private DataContract ResolveDataContractInSharedTypeMode(string assemblyName, string typeName, Assembly& assembly, Type& type);
    protected virtual DataContract ResolveDataContractFromTypeName();
    [SecuritySafeCriticalAttribute]
private bool CheckIfTypeSerializableForSharedTypeMode(Type memberType);
    internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    internal virtual Type GetSurrogatedType(Type type);
    internal virtual int GetArraySize();
    private static Assembly ResolveSimpleAssemblyName(AssemblyName assemblyName);
    private static Assembly ResolveSimpleAssemblyName(string assemblyName);
    [SecuritySafeCriticalAttribute]
private static void CheckTypeForwardedTo(Assembly sourceAssembly, Assembly destinationAssembly, Type resolvedType);
}
internal class System.Runtime.Serialization.XmlObjectSerializerWriteContext : XmlObjectSerializerContext {
    
private ObjectReferenceStack byValObjectsInScope;
    
private XmlSerializableWriter xmlSerializableWriter;
    
private static int depthToCheckCyclicReference;
    
protected bool preserveObjectReferences;
    
private ObjectToIdCache serializedObjects;
    
private bool isGetOnlyCollection;
    
private bool unsafeTypeForwardingEnabled;
    
protected bool serializeReadOnlyTypes;
    
protected ObjectToIdCache SerializedObjects { get; }
    
internal bool IsGetOnlyCollection { get; internal set; }
    
internal bool SerializeReadOnlyTypes { get; }
    
internal bool UnsafeTypeForwardingEnabled { get; }
    protected XmlObjectSerializerWriteContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver resolver);
    protected XmlObjectSerializerWriteContext(NetDataContractSerializer serializer);
    internal XmlObjectSerializerWriteContext(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal static XmlObjectSerializerWriteContext CreateContext(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal static XmlObjectSerializerWriteContext CreateContext(NetDataContractSerializer serializer, Hashtable surrogateDataContracts);
    protected ObjectToIdCache get_SerializedObjects();
    internal virtual bool get_IsGetOnlyCollection();
    internal virtual void set_IsGetOnlyCollection(bool value);
    internal bool get_SerializeReadOnlyTypes();
    internal bool get_UnsafeTypeForwardingEnabled();
    internal void StoreIsGetOnlyCollection();
    public void InternalSerializeReference(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    public virtual void InternalSerialize(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    internal void SerializeWithoutXsiType(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    internal virtual void SerializeWithXsiTypeAtTopLevel(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle originalDeclaredTypeHandle, Type graphType);
    protected virtual void SerializeWithXsiType(XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle objectTypeHandle, Type objectType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    internal bool OnHandleIsReference(XmlWriterDelegator xmlWriter, DataContract contract, object obj);
    protected void SerializeAndVerifyType(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, bool verifyKnownType, RuntimeTypeHandle declaredTypeHandle, Type declaredType);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, DataContract dataContract);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, string clrTypeName, string clrAssemblyName);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, SerializationInfo serInfo);
    public virtual void WriteAnyType(XmlWriterDelegator xmlWriter, object value);
    public virtual void WriteString(XmlWriterDelegator xmlWriter, string value);
    public virtual void WriteString(XmlWriterDelegator xmlWriter, string value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value);
    public virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value);
    public virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value);
    public virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void HandleGraphAtTopLevel(XmlWriterDelegator writer, object obj, DataContract contract);
    internal virtual bool OnHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    internal virtual void OnEndHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    public void WriteNull(XmlWriterDelegator xmlWriter, Type memberType, bool isMemberTypeSerializable);
    internal void WriteNull(XmlWriterDelegator xmlWriter, Type memberType, bool isMemberTypeSerializable, XmlDictionaryString name, XmlDictionaryString ns);
    public void IncrementArrayCount(XmlWriterDelegator xmlWriter, Array array);
    public void IncrementCollectionCount(XmlWriterDelegator xmlWriter, ICollection collection);
    public void IncrementCollectionCountGeneric(XmlWriterDelegator xmlWriter, ICollection`1<T> collection);
    private void IncrementCollectionCount(XmlWriterDelegator xmlWriter, int size);
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
    public static T GetDefaultValue();
    public static T GetNullableValue(Nullable`1<T> value);
    public static void ThrowRequiredMemberMustBeEmitted(string memberName, Type type);
    public static bool GetHasValue(Nullable`1<T> value);
    internal void WriteIXmlSerializable(XmlWriterDelegator xmlWriter, object obj);
    internal static void WriteRootIXmlSerializable(XmlWriterDelegator xmlWriter, object obj);
    private static void WriteIXmlSerializable(XmlWriterDelegator xmlWriter, object obj, XmlSerializableWriter xmlSerializableWriter);
    [SecuritySafeCriticalAttribute]
internal void GetObjectData(ISerializable obj, SerializationInfo serInfo, StreamingContext context);
    public void WriteISerializable(XmlWriterDelegator xmlWriter, ISerializable obj);
    internal void WriteSerializationInfo(XmlWriterDelegator xmlWriter, Type objType, SerializationInfo serInfo);
    public void WriteExtensionData(XmlWriterDelegator xmlWriter, ExtensionDataObject extensionData, int memberIndex);
    private void WriteExtensionDataMember(XmlWriterDelegator xmlWriter, ExtensionDataMember member);
    internal virtual void WriteExtensionDataTypeInfo(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    internal void WriteExtensionDataValue(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    internal bool TryWriteDeserializedExtensionData(XmlWriterDelegator xmlWriter, IDataNode dataNode);
    private void WriteExtensionClassData(XmlWriterDelegator xmlWriter, ClassDataNode dataNode);
    private void WriteExtensionCollectionData(XmlWriterDelegator xmlWriter, CollectionDataNode dataNode);
    private void WriteExtensionISerializableData(XmlWriterDelegator xmlWriter, ISerializableDataNode dataNode);
    private void WriteExtensionXmlData(XmlWriterDelegator xmlWriter, XmlDataNode dataNode);
    protected virtual void WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, object obj, RuntimeTypeHandle declaredTypeHandle);
    protected virtual void WriteNull(XmlWriterDelegator xmlWriter);
    private void WriteResolvedTypeInfo(XmlWriterDelegator writer, Type objectType, Type declaredType);
    private bool ResolveType(Type objectType, Type declaredType, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
    protected virtual bool WriteTypeInfo(XmlWriterDelegator writer, DataContract contract, DataContract declaredContract);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, string dataContractName, string dataContractNamespace);
    protected virtual void WriteTypeInfo(XmlWriterDelegator writer, XmlDictionaryString dataContractName, XmlDictionaryString dataContractNamespace);
}
internal class System.Runtime.Serialization.XmlObjectSerializerWriteContextComplex : XmlObjectSerializerWriteContext {
    
protected IDataContractSurrogate dataContractSurrogate;
    
private SerializationMode mode;
    
private SerializationBinder binder;
    
private ISurrogateSelector surrogateSelector;
    
private StreamingContext streamingContext;
    
private Hashtable surrogateDataContracts;
    
internal SerializationMode Mode { get; }
    internal XmlObjectSerializerWriteContextComplex(DataContractSerializer serializer, DataContract rootTypeDataContract, DataContractResolver dataContractResolver);
    internal XmlObjectSerializerWriteContextComplex(NetDataContractSerializer serializer, Hashtable surrogateDataContracts);
    internal XmlObjectSerializerWriteContextComplex(XmlObjectSerializer serializer, int maxItemsInObjectGraph, StreamingContext streamingContext, bool ignoreExtensionDataObject);
    internal virtual SerializationMode get_Mode();
    internal virtual DataContract GetDataContract(RuntimeTypeHandle typeHandle, Type type);
    internal virtual DataContract GetDataContract(int id, RuntimeTypeHandle typeHandle);
    internal virtual DataContract GetDataContractSkipValidation(int typeId, RuntimeTypeHandle typeHandle, Type type);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, DataContract dataContract);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, string clrTypeName, string clrAssemblyName);
    internal virtual bool WriteClrTypeInfo(XmlWriterDelegator xmlWriter, Type dataContractType, SerializationInfo serInfo);
    public virtual void WriteAnyType(XmlWriterDelegator xmlWriter, object value);
    public virtual void WriteString(XmlWriterDelegator xmlWriter, string value);
    public virtual void WriteString(XmlWriterDelegator xmlWriter, string value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value);
    public virtual void WriteBase64(XmlWriterDelegator xmlWriter, Byte[] value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value);
    public virtual void WriteUri(XmlWriterDelegator xmlWriter, Uri value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value);
    public virtual void WriteQName(XmlWriterDelegator xmlWriter, XmlQualifiedName value, XmlDictionaryString name, XmlDictionaryString ns);
    public virtual void InternalSerialize(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    internal virtual bool OnHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    internal virtual void OnEndHandleReference(XmlWriterDelegator xmlWriter, object obj, bool canContainCyclicReference);
    [SecuritySafeCriticalAttribute]
private bool CheckIfTypeSerializableForSharedTypeMode(Type memberType);
    internal virtual void CheckIfTypeSerializable(Type memberType, bool isMemberTypeSerializable);
    internal virtual Type GetSurrogatedType(Type type);
    private void InternalSerializeWithSurrogate(XmlWriterDelegator xmlWriter, object obj, bool isDeclaredType, bool writeXsiType, int declaredTypeID, RuntimeTypeHandle declaredTypeHandle);
    internal virtual void WriteArraySize(XmlWriterDelegator xmlWriter, int size);
}
internal class System.Runtime.Serialization.XmlReaderDelegator : object {
    
protected XmlReader reader;
    
protected XmlDictionaryReader dictionaryReader;
    
protected bool isEndOfEmptyElement;
    
internal XmlReader UnderlyingReader { get; }
    
internal ExtensionDataReader UnderlyingExtensionDataReader { get; }
    
internal int AttributeCount { get; }
    
internal bool IsEmptyElement { get; }
    
public XmlNodeType NodeType { get; }
    
internal int LineNumber { get; }
    
internal int LinePosition { get; }
    
internal bool Normalized { get; internal set; }
    
internal WhitespaceHandling WhitespaceHandling { get; internal set; }
    
internal string Name { get; }
    
public string LocalName { get; }
    
internal string NamespaceURI { get; }
    
internal string Value { get; }
    
internal Type ValueType { get; }
    
internal int Depth { get; }
    
internal bool EOF { get; }
    public XmlReaderDelegator(XmlReader reader);
    internal XmlReader get_UnderlyingReader();
    internal ExtensionDataReader get_UnderlyingExtensionDataReader();
    internal int get_AttributeCount();
    internal string GetAttribute(string name);
    internal string GetAttribute(string name, string namespaceUri);
    internal string GetAttribute(int i);
    internal bool get_IsEmptyElement();
    internal bool IsNamespaceURI(string ns);
    internal bool IsLocalName(string localName);
    internal bool IsNamespaceUri(XmlDictionaryString ns);
    internal bool IsLocalName(XmlDictionaryString localName);
    internal int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString ns);
    public bool IsStartElement();
    internal bool IsStartElement(string localname, string ns);
    public bool IsStartElement(XmlDictionaryString localname, XmlDictionaryString ns);
    internal bool MoveToAttribute(string name);
    internal bool MoveToAttribute(string name, string ns);
    internal void MoveToAttribute(int i);
    internal bool MoveToElement();
    internal bool MoveToFirstAttribute();
    internal bool MoveToNextAttribute();
    public XmlNodeType get_NodeType();
    internal bool Read();
    internal XmlNodeType MoveToContent();
    internal bool ReadAttributeValue();
    public void ReadEndElement();
    private Exception CreateInvalidPrimitiveTypeException(Type type);
    public object ReadElementContentAsAnyType(Type valueType);
    internal object ReadContentAsAnyType(Type valueType);
    internal IDataNode ReadExtensionData(Type valueType);
    private void ThrowConversionException(string value, string type);
    private void ThrowNotAtElement();
    internal virtual char ReadElementContentAsChar();
    internal virtual char ReadContentAsChar();
    private char ToChar(int value);
    public string ReadElementContentAsString();
    internal string ReadContentAsString();
    public bool ReadElementContentAsBoolean();
    internal bool ReadContentAsBoolean();
    public float ReadElementContentAsFloat();
    internal float ReadContentAsSingle();
    public double ReadElementContentAsDouble();
    internal double ReadContentAsDouble();
    public decimal ReadElementContentAsDecimal();
    internal decimal ReadContentAsDecimal();
    internal virtual Byte[] ReadElementContentAsBase64();
    internal virtual Byte[] ReadContentAsBase64();
    internal Byte[] ReadContentAsBase64(string str);
    internal virtual DateTime ReadElementContentAsDateTime();
    internal virtual DateTime ReadContentAsDateTime();
    public int ReadElementContentAsInt();
    internal int ReadContentAsInt();
    public long ReadElementContentAsLong();
    internal long ReadContentAsLong();
    public short ReadElementContentAsShort();
    internal short ReadContentAsShort();
    private short ToShort(int value);
    public byte ReadElementContentAsUnsignedByte();
    internal byte ReadContentAsUnsignedByte();
    private byte ToByte(int value);
    public sbyte ReadElementContentAsSignedByte();
    internal sbyte ReadContentAsSignedByte();
    private sbyte ToSByte(int value);
    public UInt32 ReadElementContentAsUnsignedInt();
    internal UInt32 ReadContentAsUnsignedInt();
    private UInt32 ToUInt32(long value);
    internal virtual ulong ReadElementContentAsUnsignedLong();
    internal virtual ulong ReadContentAsUnsignedLong();
    public ushort ReadElementContentAsUnsignedShort();
    internal ushort ReadContentAsUnsignedShort();
    private ushort ToUInt16(int value);
    public TimeSpan ReadElementContentAsTimeSpan();
    internal TimeSpan ReadContentAsTimeSpan();
    public Guid ReadElementContentAsGuid();
    internal Guid ReadContentAsGuid();
    public Uri ReadElementContentAsUri();
    internal Uri ReadContentAsUri();
    public XmlQualifiedName ReadElementContentAsQName();
    internal virtual XmlQualifiedName ReadContentAsQName();
    private XmlQualifiedName ParseQualifiedName(string str);
    private void CheckExpectedArrayLength(XmlObjectSerializerReadContext context, int arrayLength);
    protected int GetArrayLengthQuota(XmlObjectSerializerReadContext context);
    private void CheckActualArrayLength(int expectedLength, int actualLength, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    internal bool TryReadBooleanArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Boolean[]& array);
    internal bool TryReadDateTimeArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, DateTime[]& array);
    internal bool TryReadDecimalArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Decimal[]& array);
    internal bool TryReadInt32Array(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Int32[]& array);
    internal bool TryReadInt64Array(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Int64[]& array);
    internal bool TryReadSingleArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Single[]& array);
    internal bool TryReadDoubleArray(XmlObjectSerializerReadContext context, XmlDictionaryString itemName, XmlDictionaryString itemNamespace, int arrayLength, Double[]& array);
    internal IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    internal bool HasLineInfo();
    internal int get_LineNumber();
    internal int get_LinePosition();
    internal bool get_Normalized();
    internal void set_Normalized(bool value);
    internal WhitespaceHandling get_WhitespaceHandling();
    internal void set_WhitespaceHandling(WhitespaceHandling value);
    internal string get_Name();
    public string get_LocalName();
    internal string get_NamespaceURI();
    internal string get_Value();
    internal Type get_ValueType();
    internal int get_Depth();
    internal string LookupNamespace(string prefix);
    internal bool get_EOF();
    internal void Skip();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.XmlSerializableReader : XmlReader {
    
private XmlReaderDelegator xmlReader;
    
private int startDepth;
    
private bool isRootEmptyElement;
    
private XmlReader innerReader;
    
private XmlReader InnerReader { get; }
    
public XmlReaderSettings Settings { get; }
    
public XmlNodeType NodeType { get; }
    
public string Name { get; }
    
public string LocalName { get; }
    
public string NamespaceURI { get; }
    
public string Prefix { get; }
    
public bool HasValue { get; }
    
public string Value { get; }
    
public int Depth { get; }
    
public string BaseURI { get; }
    
public bool IsEmptyElement { get; }
    
public bool IsDefault { get; }
    
public char QuoteChar { get; }
    
public XmlSpace XmlSpace { get; }
    
public string XmlLang { get; }
    
public IXmlSchemaInfo SchemaInfo { get; }
    
public Type ValueType { get; }
    
public int AttributeCount { get; }
    
public string Item { get; }
    
public string Item { get; }
    
public string Item { get; }
    
public bool EOF { get; }
    
public ReadState ReadState { get; }
    
public XmlNameTable NameTable { get; }
    
public bool CanResolveEntity { get; }
    
public bool CanReadBinaryContent { get; }
    
public bool CanReadValueChunk { get; }
    
public bool HasAttributes { get; }
    
private bool System.Xml.Serialization.IXmlTextParser.Normalized { get; private set; }
    
private WhitespaceHandling System.Xml.Serialization.IXmlTextParser.WhitespaceHandling { get; private set; }
    
private int System.Xml.IXmlLineInfo.LineNumber { get; }
    
private int System.Xml.IXmlLineInfo.LinePosition { get; }
    private XmlReader get_InnerReader();
    internal void BeginRead(XmlReaderDelegator xmlReader);
    internal void EndRead();
    public virtual bool Read();
    public virtual void Close();
    public virtual XmlReaderSettings get_Settings();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Name();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    public virtual string get_Prefix();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual int get_Depth();
    public virtual string get_BaseURI();
    public virtual bool get_IsEmptyElement();
    public virtual bool get_IsDefault();
    public virtual char get_QuoteChar();
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual IXmlSchemaInfo get_SchemaInfo();
    public virtual Type get_ValueType();
    public virtual int get_AttributeCount();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual bool get_EOF();
    public virtual ReadState get_ReadState();
    public virtual XmlNameTable get_NameTable();
    public virtual bool get_CanResolveEntity();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_HasAttributes();
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string GetAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToElement();
    public virtual string LookupNamespace(string prefix);
    public virtual bool ReadAttributeValue();
    public virtual void ResolveEntity();
    public virtual bool IsStartElement();
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localname, string ns);
    public virtual XmlNodeType MoveToContent();
    public virtual object ReadContentAsObject();
    public virtual bool ReadContentAsBoolean();
    public virtual DateTime ReadContentAsDateTime();
    public virtual double ReadContentAsDouble();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual string ReadContentAsString();
    public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual string ReadString();
    private sealed virtual override bool System.Xml.Serialization.IXmlTextParser.get_Normalized();
    private sealed virtual override void System.Xml.Serialization.IXmlTextParser.set_Normalized(bool value);
    private sealed virtual override WhitespaceHandling System.Xml.Serialization.IXmlTextParser.get_WhitespaceHandling();
    private sealed virtual override void System.Xml.Serialization.IXmlTextParser.set_WhitespaceHandling(WhitespaceHandling value);
    private sealed virtual override bool System.Xml.IXmlLineInfo.HasLineInfo();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LineNumber();
    private sealed virtual override int System.Xml.IXmlLineInfo.get_LinePosition();
}
public static class System.Runtime.Serialization.XmlSerializableServices : object {
    
internal static string ReadNodesMethodName;
    
internal static string WriteNodesMethodName;
    
internal static string AddDefaultSchemaMethodName;
    private static XmlSerializableServices();
    public static XmlNode[] ReadNodes(XmlReader xmlReader);
    private static bool IsValidAttribute(XmlReader xmlReader);
    public static void WriteNodes(XmlWriter xmlWriter, XmlNode[] nodes);
    public static void AddDefaultSchema(XmlSchemaSet schemas, XmlQualifiedName typeQName);
}
internal class System.Runtime.Serialization.XmlSerializableWriter : XmlWriter {
    
private XmlWriter xmlWriter;
    
private int depth;
    
private object obj;
    
public WriteState WriteState { get; }
    
public XmlSpace XmlSpace { get; }
    
public string XmlLang { get; }
    internal void BeginWrite(XmlWriter xmlWriter, object obj);
    internal void EndWrite();
    public virtual void WriteStartDocument();
    public virtual void WriteEndDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    public virtual void Close();
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    public virtual void WriteCData(string text);
    public virtual void WriteComment(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual WriteState get_WriteState();
    public virtual void Flush();
    public virtual void WriteName(string name);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual string LookupPrefix(string ns);
    public virtual XmlSpace get_XmlSpace();
    public virtual string get_XmlLang();
    public virtual void WriteNmToken(string name);
}
internal class System.Runtime.Serialization.XmlWriterDelegator : object {
    
protected XmlWriter writer;
    
protected XmlDictionaryWriter dictionaryWriter;
    
internal int depth;
    
private int prefixes;
    
private static int CharChunkSize;
    
private static int ByteChunkSize;
    
internal XmlWriter Writer { get; }
    
internal WriteState WriteState { get; }
    
internal string XmlLang { get; }
    
internal XmlSpace XmlSpace { get; }
    public XmlWriterDelegator(XmlWriter writer);
    internal XmlWriter get_Writer();
    internal void Flush();
    internal string LookupPrefix(string ns);
    private void WriteEndAttribute();
    public void WriteEndElement();
    internal void WriteRaw(Char[] buffer, int index, int count);
    internal void WriteRaw(string data);
    internal void WriteXmlnsAttribute(XmlDictionaryString ns);
    internal void WriteXmlnsAttribute(string ns);
    internal void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private void WriteStartAttribute(string prefix, string localName, string ns);
    private void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteAttributeString(string prefix, string localName, string ns, string value);
    internal void WriteAttributeString(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, string value);
    private void WriteAttributeStringValue(string value);
    internal void WriteAttributeString(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, XmlDictionaryString value);
    private void WriteAttributeStringValue(XmlDictionaryString value);
    internal void WriteAttributeInt(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, int value);
    private void WriteAttributeIntValue(int value);
    internal void WriteAttributeBool(string prefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, bool value);
    private void WriteAttributeBoolValue(bool value);
    internal void WriteAttributeQualifiedName(string attrPrefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, string name, string ns);
    private void WriteAttributeQualifiedNameValue(string name, string ns);
    internal void WriteAttributeQualifiedName(string attrPrefix, XmlDictionaryString attrName, XmlDictionaryString attrNs, XmlDictionaryString name, XmlDictionaryString ns);
    private void WriteAttributeQualifiedNameValue(XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteStartElement(string localName, string ns);
    internal virtual void WriteStartElement(string prefix, string localName, string ns);
    public void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteStartElementPrimitive(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    internal void WriteEndElementPrimitive();
    internal WriteState get_WriteState();
    internal string get_XmlLang();
    internal XmlSpace get_XmlSpace();
    public void WriteNamespaceDecl(XmlDictionaryString ns);
    private Exception CreateInvalidPrimitiveTypeException(Type type);
    internal void WriteAnyType(object value);
    internal void WriteAnyType(object value, Type valueType);
    internal void WriteExtensionData(IDataNode dataNode);
    internal void WriteString(string value);
    internal virtual void WriteBoolean(bool value);
    public void WriteBoolean(bool value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDateTime(DateTime value);
    public void WriteDateTime(DateTime value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDecimal(decimal value);
    public void WriteDecimal(decimal value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteDouble(double value);
    public void WriteDouble(double value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteInt(int value);
    public void WriteInt(int value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteLong(long value);
    public void WriteLong(long value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteFloat(float value);
    public void WriteFloat(float value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteBase64(Byte[] bytes);
    internal virtual void WriteShort(short value);
    public void WriteShort(short value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedByte(byte value);
    public void WriteUnsignedByte(byte value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteSignedByte(sbyte value);
    public void WriteSignedByte(sbyte value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedInt(UInt32 value);
    public void WriteUnsignedInt(UInt32 value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedLong(ulong value);
    public void WriteUnsignedLong(ulong value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteUnsignedShort(ushort value);
    public void WriteUnsignedShort(ushort value, XmlDictionaryString name, XmlDictionaryString ns);
    internal virtual void WriteChar(char value);
    public void WriteChar(char value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteTimeSpan(TimeSpan value);
    public void WriteTimeSpan(TimeSpan value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteGuid(Guid value);
    public void WriteGuid(Guid value, XmlDictionaryString name, XmlDictionaryString ns);
    internal void WriteUri(Uri value);
    internal virtual void WriteQName(XmlQualifiedName value);
    internal void WriteQualifiedName(string localName, string ns);
    internal void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString ns);
    public void WriteBooleanArray(Boolean[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteDateTimeArray(DateTime[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteDecimalArray(Decimal[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteInt32Array(Int32[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteInt64Array(Int64[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteSingleArray(Single[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
    public void WriteDoubleArray(Double[] value, XmlDictionaryString itemName, XmlDictionaryString itemNamespace);
}
public static class System.Runtime.Serialization.XPathQueryGenerator : object {
    
private static string XPathSeparator;
    
private static string NsSeparator;
    public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, XmlNamespaceManager& namespaces);
    public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, StringBuilder rootElementXpath, XmlNamespaceManager& namespaces);
    private static DataContract ProcessDataContract(DataContract contract, ExportContext context, MemberInfo memberNode);
    private static DataContract ProcessClassDataContract(ClassDataContract contract, ExportContext context, MemberInfo memberNode);
    [IteratorStateMachineAttribute("System.Runtime.Serialization.XPathQueryGenerator/<GetDataMembers>d__6")]
private static IEnumerable`1<DataMember> GetDataMembers(ClassDataContract contract);
}
public class System.Runtime.Serialization.XsdDataContractExporter : object {
    
private ExportOptions options;
    
private XmlSchemaSet schemas;
    
private DataContractSet dataContractSet;
    
public ExportOptions Options { get; public set; }
    
public XmlSchemaSet Schemas { get; }
    
private DataContractSet DataContractSet { get; }
    public XsdDataContractExporter(XmlSchemaSet schemas);
    public ExportOptions get_Options();
    public void set_Options(ExportOptions value);
    public XmlSchemaSet get_Schemas();
    private XmlSchemaSet GetSchemaSet();
    private DataContractSet get_DataContractSet();
    private void TraceExportBegin();
    private void TraceExportEnd();
    private void TraceExportError(Exception exception);
    public void Export(ICollection`1<Assembly> assemblies);
    public void Export(ICollection`1<Type> types);
    public void Export(Type type);
    public XmlQualifiedName GetSchemaTypeName(Type type);
    public XmlSchemaType GetSchemaType(Type type);
    public XmlQualifiedName GetRootElementName(Type type);
    private Type GetSurrogatedType(Type type);
    private void CheckAndAddType(Type type);
    private void AddType(Type type);
    private void Export();
    private void AddKnownTypes();
    public bool CanExport(ICollection`1<Assembly> assemblies);
    public bool CanExport(ICollection`1<Type> types);
    public bool CanExport(Type type);
}
public class System.Runtime.Serialization.XsdDataContractImporter : object {
    
private ImportOptions options;
    
private CodeCompileUnit codeCompileUnit;
    
private DataContractSet dataContractSet;
    
private static XmlQualifiedName[] emptyTypeNameArray;
    
private static XmlSchemaElement[] emptyElementArray;
    
private XmlQualifiedName[] singleTypeNameArray;
    
private XmlSchemaElement[] singleElementArray;
    
public ImportOptions Options { get; public set; }
    
public CodeCompileUnit CodeCompileUnit { get; }
    
private DataContractSet DataContractSet { get; }
    
private XmlQualifiedName[] SingleTypeNameArray { get; }
    
private XmlSchemaElement[] SingleElementArray { get; }
    
private bool ImportXmlDataType { get; }
    public XsdDataContractImporter(CodeCompileUnit codeCompileUnit);
    private static XsdDataContractImporter();
    public ImportOptions get_Options();
    public void set_Options(ImportOptions value);
    public CodeCompileUnit get_CodeCompileUnit();
    private CodeCompileUnit GetCodeCompileUnit();
    private DataContractSet get_DataContractSet();
    public void Import(XmlSchemaSet schemas);
    public void Import(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames);
    public void Import(XmlSchemaSet schemas, XmlQualifiedName typeName);
    public XmlQualifiedName Import(XmlSchemaSet schemas, XmlSchemaElement element);
    public bool CanImport(XmlSchemaSet schemas);
    public bool CanImport(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames);
    public bool CanImport(XmlSchemaSet schemas, XmlQualifiedName typeName);
    public bool CanImport(XmlSchemaSet schemas, XmlSchemaElement element);
    public CodeTypeReference GetCodeTypeReference(XmlQualifiedName typeName);
    public CodeTypeReference GetCodeTypeReference(XmlQualifiedName typeName, XmlSchemaElement element);
    internal DataContract FindDataContract(XmlQualifiedName typeName);
    public ICollection`1<CodeTypeReference> GetKnownTypeReferences(XmlQualifiedName typeName);
    private XmlQualifiedName[] get_SingleTypeNameArray();
    private XmlSchemaElement[] get_SingleElementArray();
    [SecuritySafeCriticalAttribute]
private void InternalImport(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames, ICollection`1<XmlSchemaElement> elements, XmlQualifiedName[] elementTypeNames);
    private bool get_ImportXmlDataType();
    private void TraceImportError(Exception exception);
    private bool InternalCanImport(XmlSchemaSet schemas, ICollection`1<XmlQualifiedName> typeNames, ICollection`1<XmlSchemaElement> elements, XmlQualifiedName[] elementTypeNames);
}
internal class System.Runtime.Serialization.XsDurationDataContract : TimeSpanDataContract {
}
internal class System.Text.Base64Encoding : Encoding {
    
private static Byte[] char2val;
    
private static string val2char;
    
private static Byte[] val2byte;
    private static Base64Encoding();
    public virtual int GetMaxByteCount(int charCount);
    private bool IsValidLeadBytes(int v1, int v2, int v3, int v4);
    private bool IsValidTailBytes(int v3, int v4);
    [SecuritySafeCriticalAttribute]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Byte[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [SecuritySafeCriticalAttribute]
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Byte[] chars, int charIndex);
}
internal class System.Text.BinHexEncoding : Encoding {
    
private static Byte[] char2val;
    
private static string val2char;
    private static BinHexEncoding();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
}
internal class System.Text.SurrogateChar : ValueType {
    
private char lowChar;
    
private char highChar;
    
public static int MinValue;
    
public static int MaxValue;
    
private static char surHighMin;
    
private static char surHighMax;
    
private static char surLowMin;
    
private static char surLowMax;
    
public char LowChar { get; }
    
public char HighChar { get; }
    
public int Char { get; }
    public SurrogateChar(int ch);
    public SurrogateChar(char lowChar, char highChar);
    public char get_LowChar();
    public char get_HighChar();
    public int get_Char();
}
internal abstract class System.Xml.ArrayHelper`2 : object {
    public TArray[] ReadArray(XmlDictionaryReader reader, TArgument localName, TArgument namespaceUri, int maxArrayLength);
    public void WriteArray(XmlDictionaryWriter writer, string prefix, TArgument localName, TArgument namespaceUri, XmlDictionaryReader reader);
    protected abstract virtual int ReadArray(XmlDictionaryReader reader, TArgument localName, TArgument namespaceUri, TArray[] array, int offset, int count);
    protected abstract virtual void WriteArray(XmlDictionaryWriter writer, string prefix, TArgument localName, TArgument namespaceUri, TArray[] array, int offset, int count);
}
internal class System.Xml.BooleanArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, bool> {
    
public static BooleanArrayHelperWithDictionaryString Instance;
    private static BooleanArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
}
internal class System.Xml.BooleanArrayHelperWithString : ArrayHelper`2<string, bool> {
    
public static BooleanArrayHelperWithString Instance;
    private static BooleanArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
}
internal class System.Xml.BufferedReadStream : Stream {
    
private Stream stream;
    
private Byte[] storedBuffer;
    
private int storedLength;
    
private int storedOffset;
    
private bool readMore;
    
public bool CanWrite { get; }
    
public bool CanSeek { get; }
    
public bool CanRead { get; }
    
public long Length { get; }
    
public long Position { get; public set; }
    public BufferedReadStream(Stream stream);
    public BufferedReadStream(Stream stream, bool readMore);
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public int ReadBlock(Byte[] buffer, int offset, int count);
    public void Push(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Xml.BufferedWrite : object {
    
private Byte[] buffer;
    
private int offset;
    
internal int Length { get; }
    internal BufferedWrite(int initialSize);
    private void EnsureBuffer(int count);
    internal int get_Length();
    internal Byte[] GetBuffer();
    internal void Reset();
    internal void Write(Byte[] value);
    internal void Write(Byte[] value, int index, int count);
    internal void Write(string value);
    internal void Write(string value, int index, int count);
}
internal class System.Xml.ContentIDHeader : MimeHeader {
    public ContentIDHeader(string name, string value);
}
internal enum System.Xml.ContentTransferEncoding : Enum {
    
public int value__;
    
public static ContentTransferEncoding SevenBit;
    
public static ContentTransferEncoding EightBit;
    
public static ContentTransferEncoding Binary;
    
public static ContentTransferEncoding Other;
    
public static ContentTransferEncoding Unspecified;
}
internal class System.Xml.ContentTransferEncodingHeader : MimeHeader {
    
private ContentTransferEncoding contentTransferEncoding;
    
private string contentTransferEncodingValue;
    
public static ContentTransferEncodingHeader Binary;
    
public static ContentTransferEncodingHeader EightBit;
    
public static ContentTransferEncodingHeader SevenBit;
    
public ContentTransferEncoding ContentTransferEncoding { get; }
    
public string ContentTransferEncodingValue { get; }
    public ContentTransferEncodingHeader(string value);
    public ContentTransferEncodingHeader(ContentTransferEncoding contentTransferEncoding, string value);
    private static ContentTransferEncodingHeader();
    public ContentTransferEncoding get_ContentTransferEncoding();
    public string get_ContentTransferEncodingValue();
    private void ParseValue();
}
internal class System.Xml.ContentTypeHeader : MimeHeader {
    
public static ContentTypeHeader Default;
    
private string mediaType;
    
private string subType;
    
private Dictionary`2<string, string> parameters;
    
public string MediaType { get; }
    
public string MediaSubtype { get; }
    
public Dictionary`2<string, string> Parameters { get; }
    public ContentTypeHeader(string value);
    private static ContentTypeHeader();
    public string get_MediaType();
    public string get_MediaSubtype();
    public Dictionary`2<string, string> get_Parameters();
    private void ParseValue();
}
internal class System.Xml.DateTimeArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, DateTime> {
    
public static DateTimeArrayHelperWithDictionaryString Instance;
    private static DateTimeArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
}
internal class System.Xml.DateTimeArrayHelperWithString : ArrayHelper`2<string, DateTime> {
    
public static DateTimeArrayHelperWithString Instance;
    private static DateTimeArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
}
internal class System.Xml.DecimalArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, decimal> {
    
public static DecimalArrayHelperWithDictionaryString Instance;
    private static DecimalArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
}
internal class System.Xml.DecimalArrayHelperWithString : ArrayHelper`2<string, decimal> {
    
public static DecimalArrayHelperWithString Instance;
    private static DecimalArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
}
internal class System.Xml.DelimittedStreamReader : object {
    
private bool canGetNextStream;
    
private DelimittedReadStream currentStream;
    
private Byte[] delimitter;
    
private Byte[] matchBuffer;
    
private Byte[] scratch;
    
private BufferedReadStream stream;
    public DelimittedStreamReader(Stream stream);
    public void Close();
    private void Close(DelimittedReadStream caller);
    public Stream GetNextStream(Byte[] delimitter);
    private MatchState MatchDelimitter(Byte[] buffer, int start, int end);
    private int ProcessRead(Byte[] buffer, int offset, int read);
    private int Read(DelimittedReadStream caller, Byte[] buffer, int offset, int count);
    private bool MatchRemainder(int start, int count);
    internal void Push(Byte[] buffer, int offset, int count);
}
internal class System.Xml.DoubleArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, double> {
    
public static DoubleArrayHelperWithDictionaryString Instance;
    private static DoubleArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
}
internal class System.Xml.DoubleArrayHelperWithString : ArrayHelper`2<string, double> {
    
public static DoubleArrayHelperWithString Instance;
    private static DoubleArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Double[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
}
internal class System.Xml.EncodingStreamWrapper : Stream {
    
private static UTF8Encoding SafeUTF8;
    
private static UnicodeEncoding SafeUTF16;
    
private static UnicodeEncoding SafeBEUTF16;
    
private static UTF8Encoding ValidatingUTF8;
    
private static UnicodeEncoding ValidatingUTF16;
    
private static UnicodeEncoding ValidatingBEUTF16;
    
private static int BufferLength;
    
private static Byte[] encodingAttr;
    
private static Byte[] encodingUTF8;
    
private static Byte[] encodingUnicode;
    
private static Byte[] encodingUnicodeLE;
    
private static Byte[] encodingUnicodeBE;
    
private SupportedEncoding encodingCode;
    
private Encoding encoding;
    
private Encoder enc;
    
private Decoder dec;
    
private bool isReading;
    
private Stream stream;
    
private Char[] chars;
    
private Byte[] bytes;
    
private int byteOffset;
    
private int byteCount;
    
private Byte[] byteBuffer;
    
public bool CanRead { get; }
    
public bool CanSeek { get; }
    
public bool CanWrite { get; }
    
public long Position { get; public set; }
    
public bool CanTimeout { get; }
    
public long Length { get; }
    
public int ReadTimeout { get; public set; }
    
public int WriteTimeout { get; public set; }
    public EncodingStreamWrapper(Stream stream, Encoding encoding);
    public EncodingStreamWrapper(Stream stream, Encoding encoding, bool emitBOM);
    private static EncodingStreamWrapper();
    private void SetReadDocumentEncoding(SupportedEncoding e);
    private static Encoding GetEncoding(SupportedEncoding e);
    private static Encoding GetSafeEncoding(SupportedEncoding e);
    private static string GetEncodingName(SupportedEncoding enc);
    private static SupportedEncoding GetSupportedEncoding(Encoding encoding);
    private SupportedEncoding ReadBOMEncoding(bool notOutOfBand);
    private static SupportedEncoding ReadBOMEncoding(byte b1, byte b2, byte b3, byte b4, bool notOutOfBand, Int32& preserve);
    private void FillBuffer(int count);
    private void EnsureBuffers();
    private void EnsureByteBuffer();
    private static void CheckUTF8DeclarationEncoding(Byte[] buffer, int offset, int count, SupportedEncoding e, SupportedEncoding expectedEnc);
    private static bool CompareCaseInsensitive(Byte[] key, Byte[] buffer, int offset);
    private static bool Compare(Byte[] key, Byte[] buffer, int offset);
    private static bool IsWhitespace(byte ch);
    internal static ArraySegment`1<byte> ProcessBuffer(Byte[] buffer, int offset, int count, Encoding encoding);
    private static void ThrowExpectedEncodingMismatch(SupportedEncoding expEnc, SupportedEncoding actualEnc);
    private static void ThrowEncodingMismatch(string declEnc, SupportedEncoding enc);
    private static void ThrowEncodingMismatch(string declEnc, string docEnc);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void CleanupCharBreak();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void WriteByte(byte b);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void SetLength(long value);
}
internal class System.Xml.GuidArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, Guid> {
    
public static GuidArrayHelperWithDictionaryString Instance;
    private static GuidArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
}
internal class System.Xml.GuidArrayHelperWithString : ArrayHelper`2<string, Guid> {
    
public static GuidArrayHelperWithString Instance;
    private static GuidArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Guid[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
}
public interface System.Xml.IFragmentCapableXmlDictionaryWriter {
    
public bool CanFragment { get; }
    public abstract virtual bool get_CanFragment();
    public abstract virtual void StartFragment(Stream stream, bool generateSelfContainedTextFragment);
    public abstract virtual void EndFragment();
    public abstract virtual void WriteFragment(Byte[] buffer, int offset, int count);
}
internal class System.Xml.Int16ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, short> {
    
public static Int16ArrayHelperWithDictionaryString Instance;
    private static Int16ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
}
internal class System.Xml.Int16ArrayHelperWithString : ArrayHelper`2<string, short> {
    
public static Int16ArrayHelperWithString Instance;
    private static Int16ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int16[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
}
internal class System.Xml.Int32ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, int> {
    
public static Int32ArrayHelperWithDictionaryString Instance;
    private static Int32ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
}
internal class System.Xml.Int32ArrayHelperWithString : ArrayHelper`2<string, int> {
    
public static Int32ArrayHelperWithString Instance;
    private static Int32ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int32[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
}
internal class System.Xml.Int64ArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, long> {
    
public static Int64ArrayHelperWithDictionaryString Instance;
    private static Int64ArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
}
internal class System.Xml.Int64ArrayHelperWithString : ArrayHelper`2<string, long> {
    
public static Int64ArrayHelperWithString Instance;
    private static Int64ArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Int64[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
}
public interface System.Xml.IStreamProvider {
    public abstract virtual Stream GetStream();
    public abstract virtual void ReleaseStream(Stream stream);
}
public interface System.Xml.IXmlBinaryReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
}
public interface System.Xml.IXmlBinaryWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
}
public interface System.Xml.IXmlDictionary {
    public abstract virtual bool TryLookup(string value, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(int key, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
public interface System.Xml.IXmlMtomReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
}
public interface System.Xml.IXmlMtomWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
}
public interface System.Xml.IXmlTextReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
public interface System.Xml.IXmlTextWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
internal static class System.Xml.MailBnfHelper : object {
    
private static Boolean[] s_fqtext;
    
private static Boolean[] s_ttext;
    
private static Boolean[] s_digits;
    
private static Boolean[] s_boundary;
    private static MailBnfHelper();
    public static bool SkipCFWS(string data, Int32& offset);
    public static string ReadQuotedString(string data, Int32& offset, StringBuilder builder);
    public static string ReadParameterAttribute(string data, Int32& offset, StringBuilder builder);
    public static string ReadParameterValue(string data, Int32& offset, StringBuilder builder);
    public static string ReadToken(string data, Int32& offset, StringBuilder builder);
    public static string ReadDigits(string data, Int32& offset, StringBuilder builder);
    public static bool IsValidMimeBoundary(string data);
}
internal static class System.Xml.MimeGlobals : object {
    
internal static string MimeVersionHeader;
    
internal static string DefaultVersion;
    
internal static string ContentIDScheme;
    
internal static string ContentIDHeader;
    
internal static string ContentTypeHeader;
    
internal static string ContentTransferEncodingHeader;
    
internal static string EncodingBinary;
    
internal static string Encoding8bit;
    
internal static Byte[] COLONSPACE;
    
internal static Byte[] DASHDASH;
    
internal static Byte[] CRLF;
    
internal static Byte[] BoundaryPrefix;
    private static MimeGlobals();
}
internal class System.Xml.MimeHeader : object {
    
private string name;
    
private string value;
    
public string Name { get; }
    
public string Value { get; }
    public MimeHeader(string name, string value);
    public string get_Name();
    public string get_Value();
}
internal class System.Xml.MimeHeaderReader : object {
    
private string value;
    
private Byte[] buffer;
    
private int maxOffset;
    
private string name;
    
private int offset;
    
private ReadState readState;
    
private Stream stream;
    
public string Value { get; }
    
public string Name { get; }
    public MimeHeaderReader(Stream stream);
    public string get_Value();
    public string get_Name();
    public void Close();
    public bool Read(int maxBuffer, Int32& remaining);
    [SecuritySafeCriticalAttribute]
private bool ProcessBuffer(int maxBuffer, Int32& remaining);
    private bool BufferEnd();
    public void Reset(Stream stream);
    private void AppendValue(string value, int maxBuffer, Int32& remaining);
    private void AppendName(string value, int maxBuffer, Int32& remaining);
}
internal class System.Xml.MimeHeaders : object {
    
private Dictionary`2<string, MimeHeader> headers;
    
public ContentTypeHeader ContentType { get; }
    
public ContentIDHeader ContentID { get; }
    
public ContentTransferEncodingHeader ContentTransferEncoding { get; }
    
public MimeVersionHeader MimeVersion { get; }
    public ContentTypeHeader get_ContentType();
    public ContentIDHeader get_ContentID();
    public ContentTransferEncodingHeader get_ContentTransferEncoding();
    public MimeVersionHeader get_MimeVersion();
    public void Add(string name, string value, Int32& remaining);
    public void Add(MimeHeader header);
    public void Release(Int32& remaining);
}
internal class System.Xml.MimeMessageReader : object {
    
private static Byte[] CRLFCRLF;
    
private bool getContentStreamCalled;
    
private MimeHeaderReader mimeHeaderReader;
    
private DelimittedStreamReader reader;
    public MimeMessageReader(Stream stream);
    private static MimeMessageReader();
    public Stream GetContentStream();
    public MimeHeaders ReadHeaders(int maxBuffer, Int32& remaining);
}
internal class System.Xml.MimeReader : object {
    
private static Byte[] CRLFCRLF;
    
private Byte[] boundaryBytes;
    
private string content;
    
private Stream currentStream;
    
private MimeHeaderReader mimeHeaderReader;
    
private DelimittedStreamReader reader;
    
private Byte[] scratch;
    
public string Preface { get; }
    public MimeReader(Stream stream, string boundary);
    private static MimeReader();
    public void Close();
    public string get_Preface();
    public Stream GetContentStream();
    public bool ReadNextPart();
    public MimeHeaders ReadHeaders(int maxBuffer, Int32& remaining);
    private int BlockRead(Stream stream, Byte[] buffer, int offset, int count);
}
internal class System.Xml.MimeVersionHeader : MimeHeader {
    
public static MimeVersionHeader Default;
    
private string version;
    
public string Version { get; }
    public MimeVersionHeader(string value);
    private static MimeVersionHeader();
    public string get_Version();
    private void ParseValue();
}
internal class System.Xml.MimeWriter : object {
    
private Stream stream;
    
private Byte[] boundaryBytes;
    
private MimeWriterState state;
    
private BufferedWrite bufferedWrite;
    
private Stream contentStream;
    
internal MimeWriterState WriteState { get; }
    internal MimeWriter(Stream stream, string boundary);
    internal static int GetHeaderSize(string name, string value, int maxSizeInBytes);
    internal static Byte[] GetBoundaryBytes(string boundary);
    internal MimeWriterState get_WriteState();
    internal int GetBoundarySize();
    internal void StartPreface();
    internal void StartPart();
    internal void Close();
    private void Flush();
    internal void WriteHeader(string name, string value);
    internal Stream GetContentStream();
}
internal enum System.Xml.MimeWriterState : Enum {
    
public int value__;
    
public static MimeWriterState Start;
    
public static MimeWriterState StartPreface;
    
public static MimeWriterState StartPart;
    
public static MimeWriterState Header;
    
public static MimeWriterState Content;
    
public static MimeWriterState Closed;
}
internal class System.Xml.MtomBinaryData : object {
    
internal MtomBinaryDataType type;
    
internal IStreamProvider provider;
    
internal Byte[] chunk;
    
internal long Length { get; }
    internal MtomBinaryData(IStreamProvider provider);
    internal MtomBinaryData(Byte[] buffer, int offset, int count);
    internal long get_Length();
}
internal enum System.Xml.MtomBinaryDataType : Enum {
    
public int value__;
    
public static MtomBinaryDataType Provider;
    
public static MtomBinaryDataType Segment;
}
internal static class System.Xml.MtomGlobals : object {
    
internal static string XopIncludeLocalName;
    
internal static string XopIncludeNamespace;
    
internal static string XopIncludePrefix;
    
internal static string XopIncludeHrefLocalName;
    
internal static string XopIncludeHrefNamespace;
    
internal static string MediaType;
    
internal static string MediaSubtype;
    
internal static string BoundaryParam;
    
internal static string TypeParam;
    
internal static string XopMediaType;
    
internal static string XopMediaSubtype;
    
internal static string XopType;
    
internal static string StartParam;
    
internal static string StartInfoParam;
    
internal static string ActionParam;
    
internal static string CharsetParam;
    
internal static string MimeContentTypeLocalName;
    
internal static string MimeContentTypeNamespace200406;
    
internal static string MimeContentTypeNamespace200505;
    
internal static string DefaultContentTypeForBinary;
    private static MtomGlobals();
}
public class System.Xml.OnXmlDictionaryReaderClose : MulticastDelegate {
    public OnXmlDictionaryReaderClose(object object, IntPtr method);
    public virtual void Invoke(XmlDictionaryReader reader);
    public virtual IAsyncResult BeginInvoke(XmlDictionaryReader reader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Xml.PrefixHandle : object {
    
private XmlBufferReader bufferReader;
    
private PrefixHandleType type;
    
private int offset;
    
private int length;
    
private static String[] prefixStrings;
    
private static Byte[] prefixBuffer;
    
public bool IsEmpty { get; }
    
public bool IsXmlns { get; }
    
public bool IsXml { get; }
    public PrefixHandle(XmlBufferReader bufferReader);
    private static PrefixHandle();
    public void SetValue(PrefixHandleType type);
    public void SetValue(PrefixHandle prefix);
    public void SetValue(int offset, int length);
    public bool get_IsEmpty();
    public bool get_IsXmlns();
    public bool get_IsXml();
    public bool TryGetShortPrefix(PrefixHandleType& type);
    public static string GetString(PrefixHandleType type);
    public static PrefixHandleType GetAlphaPrefix(int index);
    public static Byte[] GetString(PrefixHandleType type, Int32& offset, Int32& length);
    public string GetString(XmlNameTable nameTable);
    public string GetString();
    public Byte[] GetString(Int32& offset, Int32& length);
    public int CompareTo(PrefixHandle that);
    private bool Equals2(PrefixHandle prefix2);
    private bool Equals2(string prefix2);
    private bool Equals2(XmlDictionaryString prefix2);
    public static bool op_Equality(PrefixHandle prefix1, string prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, string prefix2);
    public static bool op_Equality(PrefixHandle prefix1, XmlDictionaryString prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, XmlDictionaryString prefix2);
    public static bool op_Equality(PrefixHandle prefix1, PrefixHandle prefix2);
    public static bool op_Inequality(PrefixHandle prefix1, PrefixHandle prefix2);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
}
internal enum System.Xml.PrefixHandleType : Enum {
    
public int value__;
    
public static PrefixHandleType Empty;
    
public static PrefixHandleType A;
    
public static PrefixHandleType B;
    
public static PrefixHandleType C;
    
public static PrefixHandleType D;
    
public static PrefixHandleType E;
    
public static PrefixHandleType F;
    
public static PrefixHandleType G;
    
public static PrefixHandleType H;
    
public static PrefixHandleType I;
    
public static PrefixHandleType J;
    
public static PrefixHandleType K;
    
public static PrefixHandleType L;
    
public static PrefixHandleType M;
    
public static PrefixHandleType N;
    
public static PrefixHandleType O;
    
public static PrefixHandleType P;
    
public static PrefixHandleType Q;
    
public static PrefixHandleType R;
    
public static PrefixHandleType S;
    
public static PrefixHandleType T;
    
public static PrefixHandleType U;
    
public static PrefixHandleType V;
    
public static PrefixHandleType W;
    
public static PrefixHandleType X;
    
public static PrefixHandleType Y;
    
public static PrefixHandleType Z;
    
public static PrefixHandleType Buffer;
    
public static PrefixHandleType Max;
}
internal class System.Xml.SingleArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, float> {
    
public static SingleArrayHelperWithDictionaryString Instance;
    private static SingleArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
}
internal class System.Xml.SingleArrayHelperWithString : ArrayHelper`2<string, float> {
    
public static SingleArrayHelperWithString Instance;
    private static SingleArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, Single[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
}
internal class System.Xml.StringHandle : object {
    
private XmlBufferReader bufferReader;
    
private StringHandleType type;
    
private int key;
    
private int offset;
    
private int length;
    
private static String[] constStrings;
    
public bool IsEmpty { get; }
    
public bool IsXmlns { get; }
    public StringHandle(XmlBufferReader bufferReader);
    private static StringHandle();
    public void SetValue(int offset, int length);
    public void SetConstantValue(StringHandleConstStringType constStringType);
    public void SetValue(int offset, int length, bool escaped);
    public void SetValue(int key);
    public void SetValue(StringHandle value);
    public bool get_IsEmpty();
    public bool get_IsXmlns();
    public void ToPrefixHandle(PrefixHandle prefix);
    public string GetString(XmlNameTable nameTable);
    public string GetString();
    public Byte[] GetString(Int32& offset, Int32& length);
    public bool TryGetDictionaryString(XmlDictionaryString& value);
    public virtual string ToString();
    private bool Equals2(int key2, XmlBufferReader bufferReader2);
    private bool Equals2(XmlDictionaryString xmlString2);
    private bool Equals2(string s2);
    private bool Equals2(int offset2, int length2, XmlBufferReader bufferReader2);
    private bool Equals2(StringHandle s2);
    public static bool op_Equality(StringHandle s1, XmlDictionaryString xmlString2);
    public static bool op_Inequality(StringHandle s1, XmlDictionaryString xmlString2);
    public static bool op_Equality(StringHandle s1, string s2);
    public static bool op_Inequality(StringHandle s1, string s2);
    public static bool op_Equality(StringHandle s1, StringHandle s2);
    public static bool op_Inequality(StringHandle s1, StringHandle s2);
    public int CompareTo(StringHandle that);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum System.Xml.StringHandleConstStringType : Enum {
    
public int value__;
    
public static StringHandleConstStringType Type;
    
public static StringHandleConstStringType Root;
    
public static StringHandleConstStringType Item;
}
internal class System.Xml.TimeSpanArrayHelperWithDictionaryString : ArrayHelper`2<XmlDictionaryString, TimeSpan> {
    
public static TimeSpanArrayHelperWithDictionaryString Instance;
    private static TimeSpanArrayHelperWithDictionaryString();
    protected virtual int ReadArray(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
internal class System.Xml.TimeSpanArrayHelperWithString : ArrayHelper`2<string, TimeSpan> {
    
public static TimeSpanArrayHelperWithString Instance;
    private static TimeSpanArrayHelperWithString();
    protected virtual int ReadArray(XmlDictionaryReader reader, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual void WriteArray(XmlDictionaryWriter writer, string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
}
public class System.Xml.UniqueId : object {
    
private long idLow;
    
private long idHigh;
    [SecurityCriticalAttribute]

private string s;
    
private static int guidLength;
    
private static int uuidLength;
    
private static Int16[] char2val;
    
private static string val2char;
    
public int CharArrayLength { get; }
    
public bool IsGuid { get; }
    public UniqueId(Guid guid);
    public UniqueId(Byte[] guid);
    [SecuritySafeCriticalAttribute]
public UniqueId(Byte[] guid, int offset);
    [SecuritySafeCriticalAttribute]
public UniqueId(string value);
    [SecuritySafeCriticalAttribute]
public UniqueId(Char[] chars, int offset, int count);
    private static UniqueId();
    [SecuritySafeCriticalAttribute]
public int get_CharArrayLength();
    [SecurityCriticalAttribute]
private int UnsafeDecode(Int16* char2val, char ch1, char ch2);
    [SecurityCriticalAttribute]
private void UnsafeEncode(Char* val2char, byte b, Char* pch);
    public bool get_IsGuid();
    [SecurityCriticalAttribute]
private void UnsafeParse(Char* chars, int charCount);
    [SecuritySafeCriticalAttribute]
public int ToCharArray(Char[] chars, int offset);
    public bool TryGetGuid(Guid& guid);
    [SecuritySafeCriticalAttribute]
public bool TryGetGuid(Byte[] buffer, int offset);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    public static bool op_Equality(UniqueId id1, UniqueId id2);
    public static bool op_Inequality(UniqueId id1, UniqueId id2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [SecurityCriticalAttribute]
private long UnsafeGetInt64(Byte* pb);
    [SecurityCriticalAttribute]
private int UnsafeGetInt32(Byte* pb);
    [SecurityCriticalAttribute]
private void UnsafeSetInt64(long value, Byte* pb);
    [SecurityCriticalAttribute]
private void UnsafeSetInt32(int value, Byte* pb);
}
internal class System.Xml.ValueHandle : object {
    
private XmlBufferReader bufferReader;
    
private ValueHandleType type;
    
private int offset;
    
private int length;
    
private static Base64Encoding base64Encoding;
    
private static String[] constStrings;
    
private static Base64Encoding Base64Encoding { get; }
    public ValueHandle(XmlBufferReader bufferReader);
    private static ValueHandle();
    private static Base64Encoding get_Base64Encoding();
    public void SetConstantValue(ValueHandleConstStringType constStringType);
    public void SetValue(ValueHandleType type);
    public void SetDictionaryValue(int key);
    public void SetCharValue(int ch);
    public void SetQNameValue(int prefix, int key);
    public void SetValue(ValueHandleType type, int offset, int length);
    public bool IsWhitespace();
    public Type ToType();
    public bool ToBoolean();
    public int ToInt();
    public long ToLong();
    public ulong ToULong();
    public float ToSingle();
    public double ToDouble();
    public decimal ToDecimal();
    public DateTime ToDateTime();
    public UniqueId ToUniqueId();
    public TimeSpan ToTimeSpan();
    public Guid ToGuid();
    public virtual string ToString();
    public Byte[] ToByteArray();
    public string GetString();
    public bool Equals2(string str, bool checkLower);
    public void Sign(XmlSigningNodeWriter writer);
    public Object[] ToList();
    public object ToObject();
    public bool TryReadBase64(Byte[] buffer, int offset, int count, Int32& actual);
    public bool TryReadChars(Char[] chars, int offset, int count, Int32& actual);
    private bool TryReadUnicodeChars(Char[] chars, int offset, int count, Int32& actual);
    public bool TryGetDictionaryString(XmlDictionaryString& value);
    public bool TryGetByteArrayLength(Int32& length);
    private string GetCharsText();
    private string GetUnicodeCharsText();
    private string GetEscapedCharsText();
    private string GetCharText();
    private int GetChar();
    private int GetInt8();
    private int GetInt16();
    private int GetInt32();
    private long GetInt64();
    private ulong GetUInt64();
    private float GetSingle();
    private double GetDouble();
    private decimal GetDecimal();
    private UniqueId GetUniqueId();
    private Guid GetGuid();
    private void GetBase64(Byte[] buffer, int offset, int count);
    private XmlDictionaryString GetDictionaryString();
    private string GetQNameDictionaryText();
}
internal enum System.Xml.ValueHandleConstStringType : Enum {
    
public int value__;
    
public static ValueHandleConstStringType String;
    
public static ValueHandleConstStringType Number;
    
public static ValueHandleConstStringType Array;
    
public static ValueHandleConstStringType Object;
    
public static ValueHandleConstStringType Boolean;
    
public static ValueHandleConstStringType Null;
}
internal static class System.Xml.ValueHandleLength : object {
    
public static int Int8;
    
public static int Int16;
    
public static int Int32;
    
public static int Int64;
    
public static int UInt64;
    
public static int Single;
    
public static int Double;
    
public static int Decimal;
    
public static int DateTime;
    
public static int TimeSpan;
    
public static int Guid;
    
public static int UniqueId;
}
internal enum System.Xml.ValueHandleType : Enum {
    
public int value__;
    
public static ValueHandleType Empty;
    
public static ValueHandleType True;
    
public static ValueHandleType False;
    
public static ValueHandleType Zero;
    
public static ValueHandleType One;
    
public static ValueHandleType Int8;
    
public static ValueHandleType Int16;
    
public static ValueHandleType Int32;
    
public static ValueHandleType Int64;
    
public static ValueHandleType UInt64;
    
public static ValueHandleType Single;
    
public static ValueHandleType Double;
    
public static ValueHandleType Decimal;
    
public static ValueHandleType DateTime;
    
public static ValueHandleType TimeSpan;
    
public static ValueHandleType Guid;
    
public static ValueHandleType UniqueId;
    
public static ValueHandleType UTF8;
    
public static ValueHandleType EscapedUTF8;
    
public static ValueHandleType Base64;
    
public static ValueHandleType Dictionary;
    
public static ValueHandleType List;
    
public static ValueHandleType Char;
    
public static ValueHandleType Unicode;
    
public static ValueHandleType QName;
    
public static ValueHandleType ConstString;
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Xml.XmlBaseReader : XmlDictionaryReader {
    
private XmlBufferReader bufferReader;
    
private XmlNode node;
    
private NamespaceManager nsMgr;
    
private XmlElementNode[] elementNodes;
    
private XmlAttributeNode[] attributeNodes;
    
private XmlAtomicTextNode atomicTextNode;
    
private int depth;
    
private int attributeCount;
    
private int attributeStart;
    
private XmlDictionaryReaderQuotas quotas;
    
private XmlNameTable nameTable;
    
private XmlDeclarationNode declarationNode;
    
private XmlComplexTextNode complexTextNode;
    
private XmlWhitespaceTextNode whitespaceTextNode;
    
private XmlCDataNode cdataNode;
    
private XmlCommentNode commentNode;
    
private XmlElementNode rootElementNode;
    
private int attributeIndex;
    
private Char[] chars;
    
private string prefix;
    
private string localName;
    
private string ns;
    
private string value;
    
private int trailCharCount;
    
private int trailByteCount;
    
private Char[] trailChars;
    
private Byte[] trailBytes;
    
private bool rootElement;
    
private bool readingElement;
    
private XmlSigningNodeWriter signingWriter;
    
private bool signing;
    
private AttributeSorter attributeSorter;
    
private static XmlInitialNode initialNode;
    
private static XmlEndOfFileNode endOfFileNode;
    
private static XmlClosedNode closedNode;
    
private static BinHexEncoding binhexEncoding;
    
private static Base64Encoding base64Encoding;
    
private static string xmlns;
    
private static string xml;
    
private static string xmlnsNamespace;
    
private static string xmlNamespace;
    
private static BinHexEncoding BinHexEncoding { get; }
    
private static Base64Encoding Base64Encoding { get; }
    
protected XmlBufferReader BufferReader { get; }
    
public XmlDictionaryReaderQuotas Quotas { get; }
    
protected XmlNode Node { get; }
    
protected XmlElementNode ElementNode { get; }
    
protected bool OutsideRootElement { get; }
    
public bool CanReadBinaryContent { get; }
    
public bool CanReadValueChunk { get; }
    
public string BaseURI { get; }
    
public bool HasValue { get; }
    
public bool IsDefault { get; }
    
public string Item { get; }
    
public string Item { get; }
    
public string Item { get; }
    
public int AttributeCount { get; }
    
public int Depth { get; }
    
public bool EOF { get; }
    
public bool IsEmptyElement { get; }
    
public string LocalName { get; }
    
public string NamespaceURI { get; }
    
public XmlNameTable NameTable { get; }
    
public XmlNodeType NodeType { get; }
    
public string Prefix { get; }
    
public char QuoteChar { get; }
    
public ReadState ReadState { get; }
    
public string Value { get; }
    
public Type ValueType { get; }
    
public string XmlLang { get; }
    
public XmlSpace XmlSpace { get; }
    
public bool CanCanonicalize { get; }
    
protected bool Signing { get; }
    private static XmlBaseReader();
    private static BinHexEncoding get_BinHexEncoding();
    private static Base64Encoding get_Base64Encoding();
    protected XmlBufferReader get_BufferReader();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    protected XmlNode get_Node();
    protected void MoveToNode(XmlNode node);
    protected void MoveToInitial(XmlDictionaryReaderQuotas quotas);
    protected XmlDeclarationNode MoveToDeclaration();
    private bool CheckStandalone(int attr);
    private bool CheckDeclAttribute(int index, string localName, string value, bool checkLower, string valueSR);
    protected XmlCommentNode MoveToComment();
    protected XmlCDataNode MoveToCData();
    protected XmlAtomicTextNode MoveToAtomicText();
    protected XmlComplexTextNode MoveToComplexText();
    protected XmlTextNode MoveToWhitespaceText();
    protected XmlElementNode get_ElementNode();
    protected void MoveToEndElement();
    protected void MoveToEndOfFile();
    protected XmlElementNode EnterScope();
    protected void ExitScope();
    private XmlAttributeNode AddAttribute(QNameType qnameType, bool isAtomicValue);
    protected Namespace AddNamespace();
    protected XmlAttributeNode AddAttribute();
    protected XmlAttributeNode AddXmlAttribute();
    protected XmlAttributeNode AddXmlnsAttribute(Namespace ns);
    protected void FixXmlAttribute(XmlAttributeNode attributeNode);
    protected bool get_OutsideRootElement();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual string get_BaseURI();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    public virtual string get_Item(string localName, string namespaceUri);
    public virtual int get_AttributeCount();
    public virtual void Close();
    public sealed virtual int get_Depth();
    public virtual bool get_EOF();
    private XmlAttributeNode GetAttributeNode(int index);
    private XmlAttributeNode GetAttributeNode(string name);
    private XmlAttributeNode GetAttributeNode(string localName, string namespaceUri);
    private XmlAttributeNode GetAttributeNode(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string localName, string namespaceUri);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public sealed virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual string LookupNamespace(string prefix);
    protected Namespace LookupNamespace(PrefixHandleType prefix);
    protected Namespace LookupNamespace(PrefixHandle prefix);
    protected void ProcessAttributes();
    private void ProcessAttributes(XmlAttributeNode[] attributeNodes, int attributeCount);
    private void CheckAttributes(XmlAttributeNode[] attributeNodes, int attributeCount);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string localName, string namespaceUri);
    public virtual bool MoveToElement();
    public virtual XmlNodeType MoveToContent();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    private string GetLocalName(bool enforceAtomization);
    private string GetNamespaceUri(bool enforceAtomization);
    public virtual void GetNonAtomizedNames(String& localName, String& namespaceUri);
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string namespaceUri);
    public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
    public sealed virtual bool IsStartElement();
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localName, string namespaceUri);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int IndexOfLocalName(String[] localNames, string namespaceUri);
    public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual string ReadElementContentAsString();
    public virtual string ReadElementString();
    public virtual string ReadElementString(string name);
    public virtual string ReadElementString(string localName, string namespaceUri);
    public virtual void ReadStartElement();
    public virtual void ReadStartElement(string name);
    public virtual void ReadStartElement(string localName, string namespaceUri);
    public virtual void ReadEndElement();
    public virtual bool ReadAttributeValue();
    public virtual ReadState get_ReadState();
    private void SkipValue(XmlNode node);
    public virtual bool TryGetBase64ContentLength(Int32& length);
    public virtual Byte[] ReadContentAsBase64();
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual Byte[] ReadContentAsBinHex();
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    private int ReadBytes(Encoding encoding, int byteBlock, int charBlock, Byte[] buffer, int offset, int byteCount, bool readContent);
    public virtual string ReadContentAsString();
    public virtual bool ReadContentAsBoolean();
    public virtual long ReadContentAsLong();
    public virtual int ReadContentAsInt();
    public virtual DateTime ReadContentAsDateTime();
    public virtual double ReadContentAsDouble();
    public virtual float ReadContentAsFloat();
    public virtual decimal ReadContentAsDecimal();
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual TimeSpan ReadContentAsTimeSpan();
    public virtual Guid ReadContentAsGuid();
    public virtual object ReadContentAsObject();
    public virtual object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
    public virtual void ResolveEntity();
    public virtual void Skip();
    public virtual string get_Value();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual bool TryGetLocalNameAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetNamespaceUriAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetValueAsDictionaryString(XmlDictionaryString& value);
    public virtual Int16[] ReadInt16Array(string localName, string namespaceUri);
    public virtual Int16[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int32[] ReadInt32Array(string localName, string namespaceUri);
    public virtual Int32[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int64[] ReadInt64Array(string localName, string namespaceUri);
    public virtual Int64[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Single[] ReadSingleArray(string localName, string namespaceUri);
    public virtual Single[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Double[] ReadDoubleArray(string localName, string namespaceUri);
    public virtual Double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
    public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
    public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public string GetOpenElements();
    private Char[] GetCharBuffer(int count);
    private void SignStartElement(XmlSigningNodeWriter writer);
    private void SignAttribute(XmlSigningNodeWriter writer, XmlAttributeNode attributeNode);
    private void SignEndElement(XmlSigningNodeWriter writer);
    private void SignNode(XmlSigningNodeWriter writer);
    public virtual bool get_CanCanonicalize();
    protected bool get_Signing();
    protected void SignNode();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    protected abstract virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
internal abstract class System.Xml.XmlBaseWriter : XmlDictionaryWriter {
    
private XmlNodeWriter writer;
    
private NamespaceManager nsMgr;
    
private Element[] elements;
    
private int depth;
    
private string attributeLocalName;
    
private string attributeValue;
    
private bool isXmlAttribute;
    
private bool isXmlnsAttribute;
    
private WriteState writeState;
    
private DocumentState documentState;
    
private Byte[] trailBytes;
    
private int trailByteCount;
    
private XmlStreamNodeWriter nodeWriter;
    
private XmlSigningNodeWriter signingWriter;
    
private XmlUTF8NodeWriter textFragmentWriter;
    
private XmlNodeWriter oldWriter;
    
private Stream oldStream;
    
private int oldNamespaceBoundary;
    
private bool inList;
    
private static string xmlnsNamespace;
    
private static string xmlNamespace;
    
private static BinHexEncoding binhexEncoding;
    
private static String[] prefixes;
    
private XmlBaseWriterNodeWriterAsyncHelper nodeWriterAsyncHelper;
    
protected bool IsClosed { get; }
    
private static BinHexEncoding BinHexEncoding { get; }
    
public string XmlLang { get; }
    
public XmlSpace XmlSpace { get; }
    
public WriteState WriteState { get; }
    
protected int NamespaceBoundary { get; protected set; }
    
public bool CanCanonicalize { get; }
    
protected bool Signing { get; }
    
public bool CanFragment { get; }
    private static XmlBaseWriter();
    protected void SetOutput(XmlStreamNodeWriter writer);
    public virtual void Flush();
    public virtual void Close();
    protected bool get_IsClosed();
    protected void ThrowClosed();
    private static BinHexEncoding get_BinHexEncoding();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual WriteState get_WriteState();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private void StartAttribute(String& prefix, string localName, string ns, XmlDictionaryString xNs);
    public virtual void WriteStartAttribute(string prefix, string localName, string namespaceUri);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteEndAttribute();
    public virtual void WriteComment(string text);
    public virtual void WriteFullEndElement();
    public virtual void WriteCData(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    private void StartElement(String& prefix, string localName, string ns, XmlDictionaryString xNs);
    public virtual void WriteStartElement(string prefix, string localName, string namespaceUri);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteEndElement();
    private Element EnterScope();
    private void ExitScope();
    protected void FlushElement();
    protected void StartComment();
    protected void EndComment();
    protected void StartContent();
    protected void StartContent(char ch);
    protected void StartContent(string s);
    protected void StartContent(Char[] chars, int offset, int count);
    private void VerifyWhitespace(char ch);
    private void VerifyWhitespace(string s);
    private void VerifyWhitespace(Char[] chars, int offset, int count);
    private bool IsWhitespace(char ch);
    protected void EndContent();
    private void AutoComplete(WriteState writeState);
    private void EndStartElement();
    public virtual string LookupPrefix(string ns);
    internal string LookupNamespace(string prefix);
    private string GetQualifiedNamePrefix(string namespaceUri, XmlDictionaryString xNs);
    public virtual void WriteQualifiedName(string localName, string namespaceUri);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteProcessingInstruction(string name, string text);
    private void FinishDocument();
    public virtual void WriteEndDocument();
    protected int get_NamespaceBoundary();
    protected void set_NamespaceBoundary(int value);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteName(string name);
    public virtual void WriteNmToken(string name);
    public virtual void WriteWhitespace(string whitespace);
    public virtual void WriteString(string value);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteChars(Char[] chars, int offset, int count);
    public virtual void WriteRaw(string value);
    public virtual void WriteRaw(Char[] chars, int offset, int count);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteValue(object value);
    protected void WritePrimitiveValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    private void WriteValue(ulong value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteBase64(Byte[] buffer, int offset, int count);
    internal virtual IAsyncResult BeginWriteBase64(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal virtual void EndWriteBase64(IAsyncResult result);
    internal virtual AsyncCompletionResult WriteBase64Async(AsyncEventArgs`1<XmlWriteBase64AsyncArguments> state);
    public virtual void WriteBinHex(Byte[] buffer, int offset, int count);
    public virtual bool get_CanCanonicalize();
    protected bool get_Signing();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    protected abstract virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    public virtual bool get_CanFragment();
    public sealed virtual void StartFragment(Stream stream, bool generateSelfContainedTextFragment);
    public sealed virtual void EndFragment();
    public sealed virtual void WriteFragment(Byte[] buffer, int offset, int count);
    private void FlushBase64();
    private void FlushTrailBytes();
    private void WriteValue(Object[] array);
    private void WriteValue(Array array);
    protected void StartArray(int count);
    protected void EndArray();
    private void EnsureBufferBounds(Byte[] buffer, int offset, int count);
    private string GeneratePrefix(string ns, XmlDictionaryString xNs);
    protected void SignScope(XmlCanonicalWriter signingWriter);
    private void WriteAttributeText(string value);
}
internal enum System.Xml.XmlBinaryNodeType : Enum {
    
public int value__;
    
public static XmlBinaryNodeType EndElement;
    
public static XmlBinaryNodeType Comment;
    
public static XmlBinaryNodeType Array;
    
public static XmlBinaryNodeType MinAttribute;
    
public static XmlBinaryNodeType ShortAttribute;
    
public static XmlBinaryNodeType Attribute;
    
public static XmlBinaryNodeType ShortDictionaryAttribute;
    
public static XmlBinaryNodeType DictionaryAttribute;
    
public static XmlBinaryNodeType ShortXmlnsAttribute;
    
public static XmlBinaryNodeType XmlnsAttribute;
    
public static XmlBinaryNodeType ShortDictionaryXmlnsAttribute;
    
public static XmlBinaryNodeType DictionaryXmlnsAttribute;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeA;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeB;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeC;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeD;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeE;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeF;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeG;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeH;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeI;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeJ;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeK;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeL;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeM;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeN;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeO;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeP;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeQ;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeR;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeS;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeT;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeU;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeV;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeW;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeX;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeY;
    
public static XmlBinaryNodeType PrefixDictionaryAttributeZ;
    
public static XmlBinaryNodeType PrefixAttributeA;
    
public static XmlBinaryNodeType PrefixAttributeB;
    
public static XmlBinaryNodeType PrefixAttributeC;
    
public static XmlBinaryNodeType PrefixAttributeD;
    
public static XmlBinaryNodeType PrefixAttributeE;
    
public static XmlBinaryNodeType PrefixAttributeF;
    
public static XmlBinaryNodeType PrefixAttributeG;
    
public static XmlBinaryNodeType PrefixAttributeH;
    
public static XmlBinaryNodeType PrefixAttributeI;
    
public static XmlBinaryNodeType PrefixAttributeJ;
    
public static XmlBinaryNodeType PrefixAttributeK;
    
public static XmlBinaryNodeType PrefixAttributeL;
    
public static XmlBinaryNodeType PrefixAttributeM;
    
public static XmlBinaryNodeType PrefixAttributeN;
    
public static XmlBinaryNodeType PrefixAttributeO;
    
public static XmlBinaryNodeType PrefixAttributeP;
    
public static XmlBinaryNodeType PrefixAttributeQ;
    
public static XmlBinaryNodeType PrefixAttributeR;
    
public static XmlBinaryNodeType PrefixAttributeS;
    
public static XmlBinaryNodeType PrefixAttributeT;
    
public static XmlBinaryNodeType PrefixAttributeU;
    
public static XmlBinaryNodeType PrefixAttributeV;
    
public static XmlBinaryNodeType PrefixAttributeW;
    
public static XmlBinaryNodeType PrefixAttributeX;
    
public static XmlBinaryNodeType PrefixAttributeY;
    
public static XmlBinaryNodeType PrefixAttributeZ;
    
public static XmlBinaryNodeType MaxAttribute;
    
public static XmlBinaryNodeType MinElement;
    
public static XmlBinaryNodeType ShortElement;
    
public static XmlBinaryNodeType Element;
    
public static XmlBinaryNodeType ShortDictionaryElement;
    
public static XmlBinaryNodeType DictionaryElement;
    
public static XmlBinaryNodeType PrefixDictionaryElementA;
    
public static XmlBinaryNodeType PrefixDictionaryElementB;
    
public static XmlBinaryNodeType PrefixDictionaryElementC;
    
public static XmlBinaryNodeType PrefixDictionaryElementD;
    
public static XmlBinaryNodeType PrefixDictionaryElementE;
    
public static XmlBinaryNodeType PrefixDictionaryElementF;
    
public static XmlBinaryNodeType PrefixDictionaryElementG;
    
public static XmlBinaryNodeType PrefixDictionaryElementH;
    
public static XmlBinaryNodeType PrefixDictionaryElementI;
    
public static XmlBinaryNodeType PrefixDictionaryElementJ;
    
public static XmlBinaryNodeType PrefixDictionaryElementK;
    
public static XmlBinaryNodeType PrefixDictionaryElementL;
    
public static XmlBinaryNodeType PrefixDictionaryElementM;
    
public static XmlBinaryNodeType PrefixDictionaryElementN;
    
public static XmlBinaryNodeType PrefixDictionaryElementO;
    
public static XmlBinaryNodeType PrefixDictionaryElementP;
    
public static XmlBinaryNodeType PrefixDictionaryElementQ;
    
public static XmlBinaryNodeType PrefixDictionaryElementR;
    
public static XmlBinaryNodeType PrefixDictionaryElementS;
    
public static XmlBinaryNodeType PrefixDictionaryElementT;
    
public static XmlBinaryNodeType PrefixDictionaryElementU;
    
public static XmlBinaryNodeType PrefixDictionaryElementV;
    
public static XmlBinaryNodeType PrefixDictionaryElementW;
    
public static XmlBinaryNodeType PrefixDictionaryElementX;
    
public static XmlBinaryNodeType PrefixDictionaryElementY;
    
public static XmlBinaryNodeType PrefixDictionaryElementZ;
    
public static XmlBinaryNodeType PrefixElementA;
    
public static XmlBinaryNodeType PrefixElementB;
    
public static XmlBinaryNodeType PrefixElementC;
    
public static XmlBinaryNodeType PrefixElementD;
    
public static XmlBinaryNodeType PrefixElementE;
    
public static XmlBinaryNodeType PrefixElementF;
    
public static XmlBinaryNodeType PrefixElementG;
    
public static XmlBinaryNodeType PrefixElementH;
    
public static XmlBinaryNodeType PrefixElementI;
    
public static XmlBinaryNodeType PrefixElementJ;
    
public static XmlBinaryNodeType PrefixElementK;
    
public static XmlBinaryNodeType PrefixElementL;
    
public static XmlBinaryNodeType PrefixElementM;
    
public static XmlBinaryNodeType PrefixElementN;
    
public static XmlBinaryNodeType PrefixElementO;
    
public static XmlBinaryNodeType PrefixElementP;
    
public static XmlBinaryNodeType PrefixElementQ;
    
public static XmlBinaryNodeType PrefixElementR;
    
public static XmlBinaryNodeType PrefixElementS;
    
public static XmlBinaryNodeType PrefixElementT;
    
public static XmlBinaryNodeType PrefixElementU;
    
public static XmlBinaryNodeType PrefixElementV;
    
public static XmlBinaryNodeType PrefixElementW;
    
public static XmlBinaryNodeType PrefixElementX;
    
public static XmlBinaryNodeType PrefixElementY;
    
public static XmlBinaryNodeType PrefixElementZ;
    
public static XmlBinaryNodeType MaxElement;
    
public static XmlBinaryNodeType MinText;
    
public static XmlBinaryNodeType ZeroText;
    
public static XmlBinaryNodeType OneText;
    
public static XmlBinaryNodeType FalseText;
    
public static XmlBinaryNodeType TrueText;
    
public static XmlBinaryNodeType Int8Text;
    
public static XmlBinaryNodeType Int16Text;
    
public static XmlBinaryNodeType Int32Text;
    
public static XmlBinaryNodeType Int64Text;
    
public static XmlBinaryNodeType FloatText;
    
public static XmlBinaryNodeType DoubleText;
    
public static XmlBinaryNodeType DecimalText;
    
public static XmlBinaryNodeType DateTimeText;
    
public static XmlBinaryNodeType Chars8Text;
    
public static XmlBinaryNodeType Chars16Text;
    
public static XmlBinaryNodeType Chars32Text;
    
public static XmlBinaryNodeType Bytes8Text;
    
public static XmlBinaryNodeType Bytes16Text;
    
public static XmlBinaryNodeType Bytes32Text;
    
public static XmlBinaryNodeType StartListText;
    
public static XmlBinaryNodeType EndListText;
    
public static XmlBinaryNodeType EmptyText;
    
public static XmlBinaryNodeType DictionaryText;
    
public static XmlBinaryNodeType UniqueIdText;
    
public static XmlBinaryNodeType TimeSpanText;
    
public static XmlBinaryNodeType GuidText;
    
public static XmlBinaryNodeType UInt64Text;
    
public static XmlBinaryNodeType BoolText;
    
public static XmlBinaryNodeType UnicodeChars8Text;
    
public static XmlBinaryNodeType UnicodeChars16Text;
    
public static XmlBinaryNodeType UnicodeChars32Text;
    
public static XmlBinaryNodeType QNameDictionaryText;
    
public static XmlBinaryNodeType ZeroTextWithEndElement;
    
public static XmlBinaryNodeType OneTextWithEndElement;
    
public static XmlBinaryNodeType FalseTextWithEndElement;
    
public static XmlBinaryNodeType TrueTextWithEndElement;
    
public static XmlBinaryNodeType Int8TextWithEndElement;
    
public static XmlBinaryNodeType Int16TextWithEndElement;
    
public static XmlBinaryNodeType Int32TextWithEndElement;
    
public static XmlBinaryNodeType Int64TextWithEndElement;
    
public static XmlBinaryNodeType FloatTextWithEndElement;
    
public static XmlBinaryNodeType DoubleTextWithEndElement;
    
public static XmlBinaryNodeType DecimalTextWithEndElement;
    
public static XmlBinaryNodeType DateTimeTextWithEndElement;
    
public static XmlBinaryNodeType Chars8TextWithEndElement;
    
public static XmlBinaryNodeType Chars16TextWithEndElement;
    
public static XmlBinaryNodeType Chars32TextWithEndElement;
    
public static XmlBinaryNodeType Bytes8TextWithEndElement;
    
public static XmlBinaryNodeType Bytes16TextWithEndElement;
    
public static XmlBinaryNodeType Bytes32TextWithEndElement;
    
public static XmlBinaryNodeType StartListTextWithEndElement;
    
public static XmlBinaryNodeType EndListTextWithEndElement;
    
public static XmlBinaryNodeType EmptyTextWithEndElement;
    
public static XmlBinaryNodeType DictionaryTextWithEndElement;
    
public static XmlBinaryNodeType UniqueIdTextWithEndElement;
    
public static XmlBinaryNodeType TimeSpanTextWithEndElement;
    
public static XmlBinaryNodeType GuidTextWithEndElement;
    
public static XmlBinaryNodeType UInt64TextWithEndElement;
    
public static XmlBinaryNodeType BoolTextWithEndElement;
    
public static XmlBinaryNodeType UnicodeChars8TextWithEndElement;
    
public static XmlBinaryNodeType UnicodeChars16TextWithEndElement;
    
public static XmlBinaryNodeType UnicodeChars32TextWithEndElement;
    
public static XmlBinaryNodeType QNameDictionaryTextWithEndElement;
    
public static XmlBinaryNodeType MaxText;
}
internal class System.Xml.XmlBinaryNodeWriter : XmlStreamNodeWriter {
    
private IXmlDictionary dictionary;
    
private XmlBinaryWriterSession session;
    
private bool inAttribute;
    
private bool inList;
    
private bool wroteAttributeValue;
    
private AttributeValue attributeValue;
    
private static int maxBytesPerChar;
    
private int textNodeOffset;
    public void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    private void WriteNode(XmlBinaryNodeType nodeType);
    private void WroteAttributeValue();
    private void WriteTextNode(XmlBinaryNodeType nodeType);
    private Byte[] GetTextNodeBuffer(int size, Int32& offset);
    private void WriteTextNodeWithLength(XmlBinaryNodeType nodeType, int length);
    private void WriteTextNodeWithInt64(XmlBinaryNodeType nodeType, long value);
    public virtual void WriteDeclaration();
    public virtual void WriteStartElement(string prefix, string localName);
    private void WritePrefixNode(XmlBinaryNodeType nodeType, int ch);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndStartElement(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    private void WriteEndElement();
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndAttribute();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    private bool TryGetKey(XmlDictionaryString s, Int32& key);
    private void WriteDictionaryString(XmlDictionaryString s, int key);
    [SecuritySafeCriticalAttribute]
private void WriteName(string s);
    [SecurityCriticalAttribute]
private void UnsafeWriteName(Char* chars, int charCount);
    private void WriteMultiByteInt32(int i);
    public virtual void WriteComment(string value);
    public virtual void WriteCData(string value);
    private void WriteEmptyText();
    public virtual void WriteBoolText(bool value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteUInt64Text(ulong value);
    private void WriteInt64(long value);
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] base64Buffer, int base64Offset, int base64Count);
    public virtual void WriteText(XmlDictionaryString value);
    [SecuritySafeCriticalAttribute]
public virtual void WriteText(string value);
    [SecuritySafeCriticalAttribute]
public virtual void WriteText(Char[] chars, int offset, int count);
    public virtual void WriteText(Byte[] chars, int charOffset, int charCount);
    [SecurityCriticalAttribute]
private void UnsafeWriteText(Char* chars, int charCount);
    public virtual void WriteEscapedText(string value);
    public virtual void WriteEscapedText(XmlDictionaryString value);
    public virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public virtual void WriteCharEntity(int ch);
    [SecuritySafeCriticalAttribute]
public virtual void WriteFloatText(float f);
    [SecuritySafeCriticalAttribute]
public virtual void WriteDoubleText(double d);
    [SecuritySafeCriticalAttribute]
public virtual void WriteDecimalText(decimal d);
    public virtual void WriteDateTimeText(DateTime dt);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteGuidText(Guid guid);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public void WriteArrayNode();
    private void WriteArrayInfo(XmlBinaryNodeType nodeType, int count);
    [SecurityCriticalAttribute]
public void UnsafeWriteArray(XmlBinaryNodeType nodeType, int count, Byte* array, Byte* arrayMax);
    [SecurityCriticalAttribute]
private void UnsafeWriteArray(Byte* array, int byteCount);
    public void WriteDateTimeArray(DateTime[] array, int offset, int count);
    public void WriteGuidArray(Guid[] array, int offset, int count);
    public void WriteTimeSpanArray(TimeSpan[] array, int offset, int count);
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
    protected virtual void FlushBuffer();
    public virtual void Close();
}
internal class System.Xml.XmlBinaryReader : XmlBaseReader {
    
private bool isTextWithEndElement;
    
private bool buffered;
    
private ArrayState arrayState;
    
private int arrayCount;
    
private int maxBytesPerRead;
    
private XmlBinaryNodeType arrayNodeType;
    
private OnXmlDictionaryReaderClose onClose;
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public virtual void Close();
    public virtual string ReadElementContentAsString();
    public virtual bool ReadElementContentAsBoolean();
    public virtual int ReadElementContentAsInt();
    private bool CanOptimizeReadElementContent();
    public virtual float ReadElementContentAsFloat();
    public virtual double ReadElementContentAsDouble();
    public virtual decimal ReadElementContentAsDecimal();
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual TimeSpan ReadElementContentAsTimeSpan();
    public virtual Guid ReadElementContentAsGuid();
    public virtual UniqueId ReadElementContentAsUniqueId();
    public virtual bool TryGetBase64ContentLength(Int32& length);
    private void ReadTextWithEndElement();
    private XmlAtomicTextNode MoveToAtomicTextWithEndElement();
    public virtual bool Read();
    private bool ReadNode();
    private void VerifyWhitespace();
    private void ReadAttributes();
    private void ReadAttributes2();
    private void ReadText(XmlTextNode textNode, ValueHandleType type, int length);
    private void ReadBinaryText(XmlTextNode textNode, int length);
    private void ReadPartialUTF8Text(bool withEndElement, int length);
    private void ReadUnicodeText(bool withEndElement, int length);
    private void ReadPartialUnicodeText(bool withEndElement, int length);
    private void ReadPartialBinaryText(bool withEndElement, int length);
    private void InsertNode(XmlBinaryNodeType nodeType, int length);
    private void ReadAttributeText(XmlAttributeTextNode textNode);
    private void ReadName(ValueHandle value);
    private void ReadName(StringHandle handle);
    private void ReadName(PrefixHandle prefix);
    private void ReadDictionaryName(StringHandle s);
    private XmlBinaryNodeType GetNodeType();
    private void SkipNodeType();
    private int ReadDictionaryKey();
    private int ReadMultiByteUInt31();
    private int ReadUInt8();
    private int ReadUInt16();
    private int ReadUInt31();
    private bool IsValidArrayType(XmlBinaryNodeType nodeType);
    private void ReadArray();
    private void MoveToArrayElement();
    private void SkipArrayElements(int count);
    public virtual bool IsStartArray(Type& type);
    public virtual bool TryGetArrayLength(Int32& count);
    private bool IsStartArray(string localName, string namespaceUri, XmlBinaryNodeType nodeType);
    private bool IsStartArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, XmlBinaryNodeType nodeType);
    private void CheckArray(Array array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Boolean[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Int16[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Int32[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Int64[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Single[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Double[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadArray(Decimal[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    private int ReadArray(DateTime[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    private int ReadArray(Guid[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    private int ReadArray(TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
public class System.Xml.XmlBinaryReaderSession : object {
    
private static int MaxArrayEntries;
    
private XmlDictionaryString[] strings;
    
private Dictionary`2<int, XmlDictionaryString> stringDict;
    public XmlDictionaryString Add(int id, string value);
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(string value, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
    public void Clear();
}
internal class System.Xml.XmlBinaryWriter : XmlBaseWriter {
    
private XmlBinaryNodeWriter writer;
    
private Char[] chars;
    
private Byte[] bytes;
    public sealed virtual void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool attribute);
    private void WriteStartArray(string prefix, string localName, string namespaceUri, int count);
    private void WriteStartArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, int count);
    private void WriteEndArray();
    [SecurityCriticalAttribute]
private void UnsafeWriteArray(string prefix, string localName, string namespaceUri, XmlBinaryNodeType nodeType, int count, Byte* array, Byte* arrayMax);
    [SecurityCriticalAttribute]
private void UnsafeWriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, XmlBinaryNodeType nodeType, int count, Byte* array, Byte* arrayMax);
    private void CheckArray(Array array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
public class System.Xml.XmlBinaryWriterSession : object {
    
private PriorityDictionary`2<string, int> strings;
    
private PriorityDictionary`2<IXmlDictionary, IntArray> maps;
    
private int nextKey;
    public virtual bool TryAdd(XmlDictionaryString value, Int32& key);
    private int Add(string s);
    private IntArray AddKeys(IXmlDictionary dictionary, int minCount);
    public void Reset();
    internal bool TryLookup(XmlDictionaryString s, Int32& key);
}
internal class System.Xml.XmlBufferReader : object {
    
private XmlDictionaryReader reader;
    
private Stream stream;
    
private Byte[] streamBuffer;
    
private Byte[] buffer;
    
private int offsetMin;
    
private int offsetMax;
    
private IXmlDictionary dictionary;
    
private XmlBinaryReaderSession session;
    
private Byte[] guid;
    
private int offset;
    
private static int maxBytesPerChar;
    
private Char[] chars;
    
private int windowOffset;
    
private int windowOffsetMax;
    
private ValueHandle listValue;
    
private static Byte[] emptyByteArray;
    
private static XmlBufferReader empty;
    
public static XmlBufferReader Empty { get; }
    
public Byte[] Buffer { get; }
    
public bool IsStreamed { get; }
    
public bool EndOfFile { get; }
    
public int Offset { get; public set; }
    public XmlBufferReader(XmlDictionaryReader reader);
    public XmlBufferReader(Byte[] buffer);
    private static XmlBufferReader();
    public static XmlBufferReader get_Empty();
    public Byte[] get_Buffer();
    public bool get_IsStreamed();
    public void SetBuffer(Stream stream, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    public void SetBuffer(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    private void SetBuffer(Stream stream, Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlBinaryReaderSession session);
    public void Close();
    public bool get_EndOfFile();
    public byte GetByte();
    public void SkipByte();
    private byte GetByteHard();
    public Byte[] GetBuffer(int count, Int32& offset);
    public Byte[] GetBuffer(int count, Int32& offset, Int32& offsetMax);
    public Byte[] GetBuffer(Int32& offset, Int32& offsetMax);
    private Byte[] GetBufferHard(int count, Int32& offset);
    private void EnsureByte();
    private bool TryEnsureByte();
    private void EnsureBytes(int count);
    private bool TryEnsureBytes(int count);
    public void Advance(int count);
    public void InsertBytes(Byte[] buffer, int offset, int count);
    public void SetWindow(int windowOffset, int windowLength);
    public int get_Offset();
    public void set_Offset(int value);
    public int ReadBytes(int count);
    public int ReadMultiByteUInt31();
    public int ReadUInt8();
    public int ReadInt8();
    public int ReadUInt16();
    public int ReadInt16();
    public int ReadInt32();
    public int ReadUInt31();
    public long ReadInt64();
    [SecuritySafeCriticalAttribute]
public float ReadSingle();
    [SecuritySafeCriticalAttribute]
public double ReadDouble();
    [SecuritySafeCriticalAttribute]
public decimal ReadDecimal();
    public UniqueId ReadUniqueId();
    public DateTime ReadDateTime();
    public TimeSpan ReadTimeSpan();
    public Guid ReadGuid();
    public string ReadUTF8String(int length);
    [SecurityCriticalAttribute]
public void UnsafeReadArray(Byte* dst, Byte* dstMax);
    [SecurityCriticalAttribute]
private void UnsafeReadArray(Byte* dst, int length);
    private Char[] GetCharBuffer(int count);
    private int GetChars(int offset, int length, Char[] chars);
    private int GetChars(int offset, int length, Char[] chars, int charOffset);
    public string GetString(int offset, int length);
    public string GetUnicodeString(int offset, int length);
    public string GetString(int offset, int length, XmlNameTable nameTable);
    public int GetEscapedChars(int offset, int length, Char[] chars);
    private bool IsAttrChar(int ch);
    public string GetEscapedString(int offset, int length);
    public string GetEscapedString(int offset, int length, XmlNameTable nameTable);
    private int GetLessThanCharEntity(int offset, int length);
    private int GetGreaterThanCharEntity(int offset, int length);
    private int GetQuoteCharEntity(int offset, int length);
    private int GetAmpersandCharEntity(int offset, int length);
    private int GetApostropheCharEntity(int offset, int length);
    private int GetDecimalCharEntity(int offset, int length);
    private int GetHexCharEntity(int offset, int length);
    public int GetCharEntity(int offset, int length);
    public bool IsWhitespaceKey(int key);
    public bool IsWhitespaceUTF8(int offset, int length);
    public bool IsWhitespaceUnicode(int offset, int length);
    public bool Equals2(int key1, int key2, XmlBufferReader bufferReader2);
    public bool Equals2(int key1, XmlDictionaryString xmlString2);
    public bool Equals2(int offset1, int length1, Byte[] buffer2);
    public bool Equals2(int offset1, int length1, XmlBufferReader bufferReader2, int offset2, int length2);
    public bool Equals2(int offset1, int length1, int offset2, int length2);
    [SecuritySafeCriticalAttribute]
public bool Equals2(int offset1, int length1, string s2);
    public int Compare(int offset1, int length1, int offset2, int length2);
    public byte GetByte(int offset);
    public int GetInt8(int offset);
    public int GetInt16(int offset);
    public int GetInt32(int offset);
    public long GetInt64(int offset);
    public ulong GetUInt64(int offset);
    [SecuritySafeCriticalAttribute]
public float GetSingle(int offset);
    [SecuritySafeCriticalAttribute]
public double GetDouble(int offset);
    [SecuritySafeCriticalAttribute]
public decimal GetDecimal(int offset);
    public UniqueId GetUniqueId(int offset);
    public Guid GetGuid(int offset);
    public void GetBase64(int srcOffset, Byte[] buffer, int dstOffset, int count);
    public XmlBinaryNodeType GetNodeType();
    public void SkipNodeType();
    public Object[] GetList(int offset, int count);
    public XmlDictionaryString GetDictionaryString(int key);
    public int ReadDictionaryKey();
    public void ReadValue(XmlBinaryNodeType nodeType, ValueHandle value);
    private void ReadValue(ValueHandle value, ValueHandleType type, int length);
    private void ReadUnicodeValue(ValueHandle value, int length);
    private void ReadList(ValueHandle value);
    public void ReadQName(ValueHandle value);
    public Int32[] GetRows();
}
internal class System.Xml.XmlCanonicalWriter : object {
    
private XmlUTF8NodeWriter writer;
    
private MemoryStream elementStream;
    
private Byte[] elementBuffer;
    
private XmlUTF8NodeWriter elementWriter;
    
private bool inStartElement;
    
private int depth;
    
private Scope[] scopes;
    
private int xmlnsAttributeCount;
    
private XmlnsAttribute[] xmlnsAttributes;
    
private int attributeCount;
    
private Attribute[] attributes;
    
private Attribute attribute;
    
private Element element;
    
private Byte[] xmlnsBuffer;
    
private int xmlnsOffset;
    
private static int maxBytesPerChar;
    
private int xmlnsStartOffset;
    
private bool includeComments;
    
private String[] inclusivePrefixes;
    
private static string xmlnsNamespace;
    
private static Boolean[] isEscapedAttributeChar;
    
private static Boolean[] isEscapedElementChar;
    private static XmlCanonicalWriter();
    public void SetOutput(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public void Flush();
    public void Close();
    public void WriteDeclaration();
    public void WriteComment(string value);
    private void StartElement();
    private void EndElement();
    public void WriteStartElement(string prefix, string localName);
    public void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    private bool IsInclusivePrefix(XmlnsAttribute& xmlnsAttribute);
    public void WriteEndStartElement(bool isEmpty);
    public void WriteEndElement(string prefix, string localName);
    private void EnsureXmlnsBuffer(int byteCount);
    public void WriteXmlnsAttribute(string prefix, string ns);
    public void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public void WriteStartAttribute(string prefix, string localName);
    public void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public void WriteEndAttribute();
    public void WriteCharEntity(int ch);
    public void WriteEscapedText(string value);
    public void WriteEscapedText(Byte[] chars, int offset, int count);
    public void WriteEscapedText(Char[] chars, int offset, int count);
    public void WriteText(int ch);
    public void WriteText(Byte[] chars, int offset, int count);
    public void WriteText(string value);
    public void WriteText(Char[] chars, int offset, int count);
    private void ThrowIfClosed();
    private void ThrowClosed();
    private void WriteXmlnsAttribute(XmlnsAttribute& xmlnsAttribute);
    private void SortAttributes();
    private void AddAttribute(Attribute& attribute);
    private void AddXmlnsAttribute(XmlnsAttribute& xmlnsAttribute);
    private void ResolvePrefix(int prefixOffset, int prefixLength, Int32& nsOffset, Int32& nsLength);
    private void ResolvePrefix(Attribute& attribute);
    private void ResolvePrefixes();
    private int Compare(XmlnsAttribute& xmlnsAttribute1, XmlnsAttribute& xmlnsAttribute2);
    private int Compare(Attribute& attribute1, Attribute& attribute2);
    private int Compare(Byte[] buffer, int offset1, int length1, int offset2, int length2);
    private int Compare(Byte[] buffer1, int offset1, int length1, Byte[] buffer2, int offset2, int length2);
    private bool Equals(Byte[] buffer1, int offset1, int length1, Byte[] buffer2, int offset2, int length2);
}
internal static class System.Xml.XmlConverter : object {
    
public static int MaxDateTimeChars;
    
public static int MaxInt32Chars;
    
public static int MaxInt64Chars;
    
public static int MaxBoolChars;
    
public static int MaxFloatChars;
    
public static int MaxDoubleChars;
    
public static int MaxDecimalChars;
    
public static int MaxUInt64Chars;
    
public static int MaxPrimitiveChars;
    
private static Char[] whiteSpaceChars;
    
private static UTF8Encoding utf8Encoding;
    
private static UnicodeEncoding unicodeEncoding;
    
private static Base64Encoding base64Encoding;
    
public static Base64Encoding Base64Encoding { get; }
    
private static UTF8Encoding UTF8Encoding { get; }
    
private static UnicodeEncoding UnicodeEncoding { get; }
    private static XmlConverter();
    public static Base64Encoding get_Base64Encoding();
    private static UTF8Encoding get_UTF8Encoding();
    private static UnicodeEncoding get_UnicodeEncoding();
    public static bool ToBoolean(string value);
    public static bool ToBoolean(Byte[] buffer, int offset, int count);
    public static int ToInt32(string value);
    public static int ToInt32(Byte[] buffer, int offset, int count);
    public static long ToInt64(string value);
    public static long ToInt64(Byte[] buffer, int offset, int count);
    public static float ToSingle(string value);
    public static float ToSingle(Byte[] buffer, int offset, int count);
    public static double ToDouble(string value);
    public static double ToDouble(Byte[] buffer, int offset, int count);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(Byte[] buffer, int offset, int count);
    public static DateTime ToDateTime(long value);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(Byte[] buffer, int offset, int count);
    public static UniqueId ToUniqueId(string value);
    public static UniqueId ToUniqueId(Byte[] buffer, int offset, int count);
    public static TimeSpan ToTimeSpan(string value);
    public static TimeSpan ToTimeSpan(Byte[] buffer, int offset, int count);
    public static Guid ToGuid(string value);
    public static Guid ToGuid(Byte[] buffer, int offset, int count);
    public static ulong ToUInt64(string value);
    public static ulong ToUInt64(Byte[] buffer, int offset, int count);
    public static string ToString(Byte[] buffer, int offset, int count);
    public static string ToStringUnicode(Byte[] buffer, int offset, int count);
    public static Byte[] ToBytes(string value);
    public static int ToChars(Byte[] buffer, int offset, int count, Char[] chars, int charOffset);
    public static string ToString(bool value);
    public static string ToString(int value);
    public static string ToString(long value);
    public static string ToString(float value);
    public static string ToString(double value);
    public static string ToString(decimal value);
    public static string ToString(TimeSpan value);
    public static string ToString(UniqueId value);
    public static string ToString(Guid value);
    public static string ToString(ulong value);
    public static string ToString(DateTime value);
    private static string ToString(object value);
    public static string ToString(Object[] objects);
    public static void ToQualifiedName(string qname, String& prefix, String& localName);
    private static bool TryParseInt32(Byte[] chars, int offset, int count, Int32& result);
    private static bool TryParseInt64(Byte[] chars, int offset, int count, Int64& result);
    private static bool TryParseSingle(Byte[] chars, int offset, int count, Single& result);
    private static bool TryParseDouble(Byte[] chars, int offset, int count, Double& result);
    private static int ToInt32D2(Byte[] chars, int offset);
    private static int ToInt32D4(Byte[] chars, int offset, int count);
    private static int ToInt32D7(Byte[] chars, int offset, int count);
    private static bool TryParseDateTime(Byte[] chars, int offset, int count, DateTime& result);
    public static int ToChars(bool value, Byte[] buffer, int offset);
    public static int ToCharsR(int value, Byte[] chars, int offset);
    public static int ToChars(int value, Byte[] chars, int offset);
    public static int ToCharsR(long value, Byte[] chars, int offset);
    public static int ToChars(long value, Byte[] chars, int offset);
    [SecuritySafeCriticalAttribute]
private static bool IsNegativeZero(float value);
    [SecuritySafeCriticalAttribute]
private static bool IsNegativeZero(double value);
    private static int ToInfinity(bool isNegative, Byte[] buffer, int offset);
    private static int ToZero(bool isNegative, Byte[] buffer, int offset);
    public static int ToChars(double value, Byte[] buffer, int offset);
    public static int ToChars(float value, Byte[] buffer, int offset);
    public static int ToChars(decimal value, Byte[] buffer, int offset);
    public static int ToChars(ulong value, Byte[] buffer, int offset);
    private static int ToAsciiChars(string s, Byte[] buffer, int offset);
    private static int ToCharsD2(int value, Byte[] chars, int offset);
    private static int ToCharsD4(int value, Byte[] chars, int offset);
    private static int ToCharsD7(int value, Byte[] chars, int offset);
    public static int ToChars(DateTime value, Byte[] chars, int offset);
    public static bool IsWhitespace(string s);
    public static bool IsWhitespace(char ch);
    public static string StripWhitespace(string s);
    private static string Trim(string s);
}
public class System.Xml.XmlDictionary : object {
    
private static IXmlDictionary empty;
    
private Dictionary`2<string, XmlDictionaryString> lookup;
    
private XmlDictionaryString[] strings;
    
private int nextId;
    
public static IXmlDictionary Empty { get; }
    public XmlDictionary(int capacity);
    public static IXmlDictionary get_Empty();
    public virtual XmlDictionaryString Add(string value);
    public virtual bool TryLookup(string value, XmlDictionaryString& result);
    public virtual bool TryLookup(int key, XmlDictionaryString& result);
    public virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
public abstract class System.Xml.XmlDictionaryReader : XmlReader {
    
internal static int MaxInitialArrayLength;
    
public bool CanCanonicalize { get; }
    
public XmlDictionaryReaderQuotas Quotas { get; }
    public static XmlDictionaryReader CreateDictionaryReader(XmlReader reader);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public virtual bool get_CanCanonicalize();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    public virtual void MoveToStartElement();
    public virtual void MoveToStartElement(string name);
    public virtual void MoveToStartElement(string localName, string namespaceUri);
    public virtual void MoveToStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string namespaceUri);
    public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
    public virtual void ReadFullStartElement();
    public virtual void ReadFullStartElement(string name);
    public virtual void ReadFullStartElement(string localName, string namespaceUri);
    public virtual void ReadFullStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void ReadStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int IndexOfLocalName(String[] localNames, string namespaceUri);
    public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual bool TryGetBase64ContentLength(Int32& length);
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual Byte[] ReadContentAsBase64();
    internal Byte[] ReadContentAsBase64(int maxByteArrayContentLength, int maxInitialCount);
    public virtual string ReadContentAsString();
    protected string ReadContentAsString(int maxStringContentLength);
    public virtual string ReadString();
    protected string ReadString(int maxStringContentLength);
    public virtual Byte[] ReadContentAsBinHex();
    protected Byte[] ReadContentAsBinHex(int maxByteArrayContentLength);
    private Byte[] ReadContentAsBytes(bool base64, int maxByteArrayContentLength);
    protected bool IsTextNode(XmlNodeType nodeType);
    public virtual int ReadContentAsChars(Char[] chars, int offset, int count);
    public virtual object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
    public virtual string ReadContentAsString(String[] strings, Int32& index);
    public virtual string ReadContentAsString(XmlDictionaryString[] strings, Int32& index);
    public virtual decimal ReadContentAsDecimal();
    public virtual float ReadContentAsFloat();
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual Guid ReadContentAsGuid();
    public virtual TimeSpan ReadContentAsTimeSpan();
    public virtual void ReadContentAsQualifiedName(String& localName, String& namespaceUri);
    public virtual string ReadElementContentAsString();
    public virtual bool ReadElementContentAsBoolean();
    public virtual int ReadElementContentAsInt();
    public virtual long ReadElementContentAsLong();
    public virtual float ReadElementContentAsFloat();
    public virtual double ReadElementContentAsDouble();
    public virtual decimal ReadElementContentAsDecimal();
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual UniqueId ReadElementContentAsUniqueId();
    public virtual Guid ReadElementContentAsGuid();
    public virtual TimeSpan ReadElementContentAsTimeSpan();
    public virtual Byte[] ReadElementContentAsBase64();
    public virtual Byte[] ReadElementContentAsBinHex();
    public virtual void GetNonAtomizedNames(String& localName, String& namespaceUri);
    public virtual bool TryGetLocalNameAsDictionaryString(XmlDictionaryString& localName);
    public virtual bool TryGetNamespaceUriAsDictionaryString(XmlDictionaryString& namespaceUri);
    public virtual bool TryGetValueAsDictionaryString(XmlDictionaryString& value);
    private void CheckArray(Array array, int offset, int count);
    public virtual bool IsStartArray(Type& type);
    public virtual bool TryGetArrayLength(Int32& count);
    public virtual Boolean[] ReadBooleanArray(string localName, string namespaceUri);
    public virtual Boolean[] ReadBooleanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual Int16[] ReadInt16Array(string localName, string namespaceUri);
    public virtual Int16[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual Int32[] ReadInt32Array(string localName, string namespaceUri);
    public virtual Int32[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual Int64[] ReadInt64Array(string localName, string namespaceUri);
    public virtual Int64[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual Single[] ReadSingleArray(string localName, string namespaceUri);
    public virtual Single[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual Double[] ReadDoubleArray(string localName, string namespaceUri);
    public virtual Double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
    public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
    public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
public class System.Xml.XmlDictionaryReaderQuotas : object {
    
private bool readOnly;
    
private int maxStringContentLength;
    
private int maxArrayLength;
    
private int maxDepth;
    
private int maxNameTableCharCount;
    
private int maxBytesPerRead;
    
private XmlDictionaryReaderQuotaTypes modifiedQuotas;
    
private static int DefaultMaxDepth;
    
private static int DefaultMaxStringContentLength;
    
private static int DefaultMaxArrayLength;
    
private static int DefaultMaxBytesPerRead;
    
private static int DefaultMaxNameTableCharCount;
    
private static XmlDictionaryReaderQuotas defaultQuota;
    
private static XmlDictionaryReaderQuotas maxQuota;
    
public static XmlDictionaryReaderQuotas Max { get; }
    [DefaultValueAttribute("8192")]

public int MaxStringContentLength { get; public set; }
    [DefaultValueAttribute("16384")]

public int MaxArrayLength { get; public set; }
    [DefaultValueAttribute("4096")]

public int MaxBytesPerRead { get; public set; }
    [DefaultValueAttribute("32")]

public int MaxDepth { get; public set; }
    [DefaultValueAttribute("16384")]

public int MaxNameTableCharCount { get; public set; }
    
public XmlDictionaryReaderQuotaTypes ModifiedQuotas { get; }
    private XmlDictionaryReaderQuotas(int maxDepth, int maxStringContentLength, int maxArrayLength, int maxBytesPerRead, int maxNameTableCharCount, XmlDictionaryReaderQuotaTypes modifiedQuotas);
    private static XmlDictionaryReaderQuotas();
    public static XmlDictionaryReaderQuotas get_Max();
    public void CopyTo(XmlDictionaryReaderQuotas quotas);
    internal void InternalCopyTo(XmlDictionaryReaderQuotas quotas);
    public int get_MaxStringContentLength();
    public void set_MaxStringContentLength(int value);
    public int get_MaxArrayLength();
    public void set_MaxArrayLength(int value);
    public int get_MaxBytesPerRead();
    public void set_MaxBytesPerRead(int value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public int get_MaxNameTableCharCount();
    public void set_MaxNameTableCharCount(int value);
    public XmlDictionaryReaderQuotaTypes get_ModifiedQuotas();
    internal void MakeReadOnly();
}
[FlagsAttribute]
public enum System.Xml.XmlDictionaryReaderQuotaTypes : Enum {
    
public int value__;
    
public static XmlDictionaryReaderQuotaTypes MaxDepth;
    
public static XmlDictionaryReaderQuotaTypes MaxStringContentLength;
    
public static XmlDictionaryReaderQuotaTypes MaxArrayLength;
    
public static XmlDictionaryReaderQuotaTypes MaxBytesPerRead;
    
public static XmlDictionaryReaderQuotaTypes MaxNameTableCharCount;
}
public class System.Xml.XmlDictionaryString : object {
    
internal static int MinKey;
    
internal static int MaxKey;
    
private IXmlDictionary dictionary;
    
private string value;
    
private int key;
    
private Byte[] buffer;
    
private static EmptyStringDictionary emptyStringDictionary;
    
public static XmlDictionaryString Empty { get; }
    
public IXmlDictionary Dictionary { get; }
    
public int Key { get; }
    
public string Value { get; }
    public XmlDictionaryString(IXmlDictionary dictionary, string value, int key);
    private static XmlDictionaryString();
    internal static string GetString(XmlDictionaryString s);
    public static XmlDictionaryString get_Empty();
    public IXmlDictionary get_Dictionary();
    public int get_Key();
    public string get_Value();
    internal Byte[] ToUTF8();
    public virtual string ToString();
}
public abstract class System.Xml.XmlDictionaryWriter : XmlWriter {
    
internal bool FastAsync { get; }
    
public bool CanCanonicalize { get; }
    internal virtual bool get_FastAsync();
    internal virtual AsyncCompletionResult WriteBase64Async(AsyncEventArgs`1<XmlWriteBase64AsyncArguments> state);
    public virtual Task WriteBase64Async(Byte[] buffer, int index, int count);
    internal virtual IAsyncResult BeginWriteBase64(Byte[] buffer, int index, int count, AsyncCallback callback, object state);
    internal virtual void EndWriteBase64(IAsyncResult result);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding, bool ownsStream);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    public static XmlDictionaryWriter CreateDictionaryWriter(XmlWriter writer);
    public void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteStartAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteAttributeString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public void WriteAttributeString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public void WriteElementString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public void WriteElementString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteValue(IStreamProvider value);
    public virtual Task WriteValueAsync(IStreamProvider value);
    internal virtual IAsyncResult BeginWriteValue(IStreamProvider value, AsyncCallback callback, object state);
    internal virtual void EndWriteValue(IAsyncResult result);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual bool get_CanCanonicalize();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
    private void WriteElementNode(XmlDictionaryReader reader, bool defattr);
    private void WriteArrayNode(XmlDictionaryReader reader, string prefix, string localName, string namespaceUri, Type type);
    private void WriteArrayNode(XmlDictionaryReader reader, string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Type type);
    private void WriteArrayNode(XmlDictionaryReader reader, Type type);
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool isAttribute);
    public virtual void WriteNode(XmlReader reader, bool defattr);
    public virtual void WriteNode(XmlDictionaryReader reader, bool defattr);
    private void CheckArray(Array array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
}
internal static class System.Xml.XmlExceptionHelper : object {
    private static void ThrowXmlException(XmlDictionaryReader reader, string res);
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1);
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1, string arg2);
    private static void ThrowXmlException(XmlDictionaryReader reader, string res, string arg1, string arg2, string arg3);
    public static void ThrowXmlException(XmlDictionaryReader reader, XmlException exception);
    private static string GetName(string prefix, string localName);
    private static string GetWhatWasFound(XmlDictionaryReader reader);
    public static void ThrowStartElementExpected(XmlDictionaryReader reader);
    public static void ThrowStartElementExpected(XmlDictionaryReader reader, string name);
    public static void ThrowStartElementExpected(XmlDictionaryReader reader, string localName, string ns);
    public static void ThrowStartElementExpected(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static void ThrowFullStartElementExpected(XmlDictionaryReader reader);
    public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, string name);
    public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, string localName, string ns);
    public static void ThrowFullStartElementExpected(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static void ThrowEndElementExpected(XmlDictionaryReader reader, string localName, string ns);
    public static void ThrowMaxStringContentLengthExceeded(XmlDictionaryReader reader, int maxStringContentLength);
    public static void ThrowMaxArrayLengthExceeded(XmlDictionaryReader reader, int maxArrayLength);
    public static void ThrowMaxArrayLengthOrMaxItemsQuotaExceeded(XmlDictionaryReader reader, int maxQuota);
    public static void ThrowMaxDepthExceeded(XmlDictionaryReader reader, int maxDepth);
    public static void ThrowMaxBytesPerReadExceeded(XmlDictionaryReader reader, int maxBytesPerRead);
    public static void ThrowMaxNameTableCharCountExceeded(XmlDictionaryReader reader, int maxNameTableCharCount);
    public static void ThrowBase64DataExpected(XmlDictionaryReader reader);
    public static void ThrowUndefinedPrefix(XmlDictionaryReader reader, string prefix);
    public static void ThrowProcessingInstructionNotSupported(XmlDictionaryReader reader);
    public static void ThrowInvalidXml(XmlDictionaryReader reader, byte b);
    public static void ThrowUnexpectedEndOfFile(XmlDictionaryReader reader);
    public static void ThrowUnexpectedEndElement(XmlDictionaryReader reader);
    public static void ThrowTokenExpected(XmlDictionaryReader reader, string expected, char found);
    public static void ThrowTokenExpected(XmlDictionaryReader reader, string expected, string found);
    public static void ThrowInvalidCharRef(XmlDictionaryReader reader);
    public static void ThrowTagMismatch(XmlDictionaryReader reader, string expectedPrefix, string expectedLocalName, string foundPrefix, string foundLocalName);
    public static void ThrowDuplicateXmlnsAttribute(XmlDictionaryReader reader, string localName, string ns);
    public static void ThrowDuplicateAttribute(XmlDictionaryReader reader, string prefix1, string prefix2, string localName, string ns);
    public static void ThrowInvalidBinaryFormat(XmlDictionaryReader reader);
    public static void ThrowInvalidRootData(XmlDictionaryReader reader);
    public static void ThrowMultipleRootElements(XmlDictionaryReader reader);
    public static void ThrowDeclarationNotFirst(XmlDictionaryReader reader);
    public static void ThrowConversionOverflow(XmlDictionaryReader reader, string value, string type);
    public static void ThrowXmlDictionaryStringIDOutOfRange(XmlDictionaryReader reader);
    public static void ThrowXmlDictionaryStringIDUndefinedStatic(XmlDictionaryReader reader, int key);
    public static void ThrowXmlDictionaryStringIDUndefinedSession(XmlDictionaryReader reader, int key);
    public static void ThrowEmptyNamespace(XmlDictionaryReader reader);
    public static XmlException CreateConversionException(string value, string type, Exception exception);
    public static XmlException CreateEncodingException(Byte[] buffer, int offset, int count, Exception exception);
    public static XmlException CreateEncodingException(string value, Exception exception);
}
[DefaultMemberAttribute("Item")]
internal class System.Xml.XmlMtomReader : XmlDictionaryReader {
    
private Encoding[] encodings;
    
private XmlDictionaryReader xmlReader;
    
private XmlDictionaryReader infosetReader;
    
private MimeReader mimeReader;
    
private Dictionary`2<string, MimePart> mimeParts;
    
private OnXmlDictionaryReaderClose onClose;
    
private bool readingBinaryElement;
    
private int maxBufferSize;
    
private int bufferRemaining;
    
private MimePart part;
    
public XmlDictionaryReaderQuotas Quotas { get; }
    
public int AttributeCount { get; }
    
public string BaseURI { get; }
    
public bool CanReadBinaryContent { get; }
    
public bool CanReadValueChunk { get; }
    
public bool CanResolveEntity { get; }
    
public int Depth { get; }
    
public bool EOF { get; }
    
public bool HasAttributes { get; }
    
public bool HasValue { get; }
    
public bool IsDefault { get; }
    
public bool IsEmptyElement { get; }
    
public string LocalName { get; }
    
public string Name { get; }
    
public string NamespaceURI { get; }
    
public XmlNameTable NameTable { get; }
    
public XmlNodeType NodeType { get; }
    
public string Prefix { get; }
    
public char QuoteChar { get; }
    
public ReadState ReadState { get; }
    
public XmlReaderSettings Settings { get; }
    
public string Item { get; }
    
public string Item { get; }
    
public string Item { get; }
    
public string Value { get; }
    
public Type ValueType { get; }
    
public string XmlLang { get; }
    
public XmlSpace XmlSpace { get; }
    
public int LineNumber { get; }
    
public int LinePosition { get; }
    internal static void DecrementBufferQuota(int maxBuffer, Int32& remaining, int size);
    private void SetReadEncodings(Encoding[] encodings);
    private void CheckContentType(string contentType);
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    private void Initialize(Stream stream, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize);
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    private void ReadMessageMimeVersionHeader(MimeVersionHeader header);
    private void ReadMessageContentTypeHeader(ContentTypeHeader header, String& boundary, String& start, String& startInfo);
    private Encoding ReadRootContentTypeHeader(ContentTypeHeader header, Encoding[] expectedEncodings, string expectedType);
    private void CheckContentTransferEncodingOnRoot(ContentTransferEncodingHeader header);
    private void CheckContentTransferEncodingOnBinaryPart(ContentTransferEncodingHeader header);
    private string GetStartUri(string startUri);
    public virtual bool Read();
    private MimePart ReadMimePart(string uri);
    private MimePart ReadRootMimePart();
    private void AdvanceToContentOnElement();
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual bool get_CanResolveEntity();
    public virtual void Close();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string ns);
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual bool get_HasAttributes();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string ns);
    public virtual bool IsNamespaceUri(XmlDictionaryString ns);
    public virtual bool IsStartElement();
    public virtual bool IsStartElement(string localName);
    public virtual bool IsStartElement(string localName, string ns);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual string get_LocalName();
    public virtual string LookupNamespace(string ns);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public virtual bool ReadAttributeValue();
    public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
    public virtual Byte[] ReadContentAsBase64();
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual bool ReadContentAsBoolean();
    public virtual int ReadContentAsChars(Char[] chars, int index, int count);
    public virtual DateTime ReadContentAsDateTime();
    public virtual decimal ReadContentAsDecimal();
    public virtual double ReadContentAsDouble();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual object ReadContentAsObject();
    public virtual float ReadContentAsFloat();
    public virtual string ReadContentAsString();
    public virtual string ReadInnerXml();
    public virtual string ReadOuterXml();
    public virtual ReadState get_ReadState();
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual void ResolveEntity();
    public virtual XmlReaderSettings get_Settings();
    public virtual void Skip();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string ns);
    public virtual string get_Value();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
internal class System.Xml.XmlMtomWriter : XmlDictionaryWriter {
    
private static int MaxInlinedBytes;
    
private int maxSizeInBytes;
    
private XmlDictionaryWriter writer;
    
private XmlDictionaryWriter infosetWriter;
    
private MimeWriter mimeWriter;
    
private Encoding encoding;
    
private bool isUTF8;
    
private string contentID;
    
private string contentType;
    
private string initialContentTypeForRootPart;
    
private string initialContentTypeForMimeMessage;
    
private MemoryStream contentTypeStream;
    
private List`1<MimePart> mimeParts;
    
private IList`1<MtomBinaryData> binaryDataChunks;
    
private int depth;
    
private int totalSizeOfMimeParts;
    
private int sizeOfBufferedBinaryData;
    
private Char[] chars;
    
private Byte[] bytes;
    
private bool isClosed;
    
private bool ownsStream;
    
private XmlDictionaryWriter Writer { get; }
    
private bool IsInitialized { get; }
    
public XmlWriterSettings Settings { get; }
    
public WriteState WriteState { get; }
    
public string XmlLang { get; }
    
public XmlSpace XmlSpace { get; }
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    private XmlDictionaryWriter get_Writer();
    private bool get_IsInitialized();
    private void Initialize(Stream stream, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    private void Initialize();
    private static string GetBoundaryString();
    internal static bool IsUTF8Encoding(Encoding encoding);
    private static string GetContentTypeForMimeMessage(string boundary, string startUri, string startInfo);
    private static string GetContentTypeForRootMimePart(Encoding encoding, string startInfo);
    private static string CharSet(Encoding enc);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString ns);
    private void ThrowIfElementIsXOPInclude(string prefix, string localName, string ns);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    public virtual void WriteValue(IStreamProvider value);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    internal static int ValidateSizeOfMessage(int maxSize, int offset, int size);
    private void WriteBase64InlineIfPresent();
    private void WriteBase64Inline();
    private void WriteXOPInclude();
    public static string GenerateUriForMimePart(int index);
    private void WriteXOPBinaryParts();
    private void WriteMimeHeaders(string contentID, string contentType, string contentTransferEncoding);
    public virtual void Close();
    private void CheckIfStartContentTypeAttribute(string localName, string ns);
    private void CheckIfEndContentTypeAttribute();
    public virtual void Flush();
    public virtual string LookupPrefix(string ns);
    public virtual XmlWriterSettings get_Settings();
    public virtual void WriteAttributes(XmlReader reader, bool defattr);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteName(string name);
    public virtual void WriteNmToken(string name);
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool attribute);
    public virtual void WriteNode(XPathNavigator navigator, bool defattr);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteQualifiedName(string localName, string namespaceUri);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString ns);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual WriteState get_WriteState();
    public virtual void WriteString(string text);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string whitespace);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
}
internal abstract class System.Xml.XmlNodeWriter : object {
    
private static XmlNodeWriter nullNodeWriter;
    
public static XmlNodeWriter Null { get; }
    public static XmlNodeWriter get_Null();
    internal virtual AsyncCompletionResult WriteBase64TextAsync(AsyncEventArgs`1<XmlNodeWriterWriteBase64TextArgs> state);
    public virtual IAsyncResult BeginWriteBase64Text(Byte[] trailBuffer, int trailCount, Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWriteBase64Text(IAsyncResult result);
    public abstract virtual void Flush();
    public abstract virtual void Close();
    public abstract virtual void WriteDeclaration();
    public abstract virtual void WriteComment(string text);
    public abstract virtual void WriteCData(string text);
    public abstract virtual void WriteStartElement(string prefix, string localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public abstract virtual void WriteEndStartElement(bool isEmpty);
    public abstract virtual void WriteEndElement(string prefix, string localName);
    public virtual void WriteEndElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public abstract virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public abstract virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public abstract virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public abstract virtual void WriteEndAttribute();
    public abstract virtual void WriteCharEntity(int ch);
    public abstract virtual void WriteEscapedText(string value);
    public abstract virtual void WriteEscapedText(XmlDictionaryString value);
    public abstract virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public abstract virtual void WriteEscapedText(Byte[] buffer, int offset, int count);
    public abstract virtual void WriteText(string value);
    public abstract virtual void WriteText(XmlDictionaryString value);
    public abstract virtual void WriteText(Char[] chars, int offset, int count);
    public abstract virtual void WriteText(Byte[] buffer, int offset, int count);
    public abstract virtual void WriteInt32Text(int value);
    public abstract virtual void WriteInt64Text(long value);
    public abstract virtual void WriteBoolText(bool value);
    public abstract virtual void WriteUInt64Text(ulong value);
    public abstract virtual void WriteFloatText(float value);
    public abstract virtual void WriteDoubleText(double value);
    public abstract virtual void WriteDecimalText(decimal value);
    public abstract virtual void WriteDateTimeText(DateTime value);
    public abstract virtual void WriteUniqueIdText(UniqueId value);
    public abstract virtual void WriteTimeSpanText(TimeSpan value);
    public abstract virtual void WriteGuidText(Guid value);
    public abstract virtual void WriteStartListText();
    public abstract virtual void WriteListSeparator();
    public abstract virtual void WriteEndListText();
    public abstract virtual void WriteBase64Text(Byte[] trailBuffer, int trailCount, Byte[] buffer, int offset, int count);
    public abstract virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal class System.Xml.XmlNodeWriterWriteBase64TextArgs : object {
    [CompilerGeneratedAttribute]

private Byte[] <TrailBuffer>k__BackingField;
    [CompilerGeneratedAttribute]

private int <TrailCount>k__BackingField;
    [CompilerGeneratedAttribute]

private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Count>k__BackingField;
    
internal Byte[] TrailBuffer { get; internal set; }
    
internal int TrailCount { get; internal set; }
    
internal Byte[] Buffer { get; internal set; }
    
internal int Offset { get; internal set; }
    
internal int Count { get; internal set; }
    [CompilerGeneratedAttribute]
internal Byte[] get_TrailBuffer();
    [CompilerGeneratedAttribute]
internal void set_TrailBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_TrailCount();
    [CompilerGeneratedAttribute]
internal void set_TrailCount(int value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
internal void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(int value);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
}
internal class System.Xml.XmlSigningNodeWriter : XmlNodeWriter {
    
private XmlNodeWriter writer;
    
private XmlCanonicalWriter signingWriter;
    
private Byte[] chars;
    
private Byte[] base64Chars;
    
private bool text;
    
public XmlNodeWriter NodeWriter { get; public set; }
    
public XmlCanonicalWriter CanonicalWriter { get; }
    public XmlSigningNodeWriter(bool text);
    public void SetOutput(XmlNodeWriter writer, Stream stream, bool includeComments, String[] inclusivePrefixes);
    public XmlNodeWriter get_NodeWriter();
    public void set_NodeWriter(XmlNodeWriter value);
    public XmlCanonicalWriter get_CanonicalWriter();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteDeclaration();
    public virtual void WriteComment(string text);
    public virtual void WriteCData(string text);
    public virtual void WriteStartElement(string prefix, string localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndStartElement(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteEndAttribute();
    public virtual void WriteCharEntity(int ch);
    public virtual void WriteEscapedText(string value);
    public virtual void WriteEscapedText(Char[] chars, int offset, int count);
    public virtual void WriteEscapedText(XmlDictionaryString value);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public virtual void WriteText(string value);
    public virtual void WriteText(Char[] chars, int offset, int count);
    public virtual void WriteText(Byte[] chars, int offset, int count);
    public virtual void WriteText(XmlDictionaryString value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteBoolText(bool value);
    public virtual void WriteUInt64Text(ulong value);
    public virtual void WriteFloatText(float value);
    public virtual void WriteDoubleText(double value);
    public virtual void WriteDecimalText(decimal value);
    public virtual void WriteDateTimeText(DateTime value);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteGuidText(Guid value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count);
    private void WriteBase64Text(Byte[] buffer, int offset, int count);
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal abstract class System.Xml.XmlStreamNodeWriter : XmlNodeWriter {
    
private Stream stream;
    
private Byte[] buffer;
    
private int offset;
    
private bool ownsStream;
    
private static int bufferLength;
    
private static int maxEntityLength;
    
private static int maxBytesPerChar;
    
private Encoding encoding;
    
private int hasPendingWrite;
    
private AsyncEventArgs`1<object> flushBufferState;
    
private static UTF8Encoding UTF8Encoding;
    
private static AsyncCallback onFlushBufferComplete;
    
private static AsyncEventArgsCallback onGetFlushComplete;
    
public Stream Stream { get; public set; }
    
public Byte[] StreamBuffer { get; }
    
public int BufferOffset { get; }
    
public int Position { get; }
    private static XmlStreamNodeWriter();
    protected void SetOutput(Stream stream, bool ownsStream, Encoding encoding);
    public Stream get_Stream();
    public void set_Stream(Stream value);
    public Byte[] get_StreamBuffer();
    public int get_BufferOffset();
    public int get_Position();
    protected Byte[] GetBuffer(int count, Int32& offset);
    internal AsyncCompletionResult GetBufferAsync(GetBufferAsyncEventArgs getBufferState);
    private static void GetBufferFlushComplete(IAsyncEventArgs completionState);
    private AsyncCompletionResult FlushBufferAsync(AsyncEventArgs`1<object> state);
    private static void OnFlushBufferCompete(IAsyncResult result);
    protected IAsyncResult BeginGetBuffer(int count, AsyncCallback callback, object state);
    protected Byte[] EndGetBuffer(IAsyncResult result, Int32& offset);
    protected void Advance(int count);
    private void EnsureByte();
    protected void WriteByte(byte b);
    protected void WriteByte(char ch);
    protected void WriteBytes(byte b1, byte b2);
    protected void WriteBytes(char ch1, char ch2);
    public void WriteBytes(Byte[] byteBuffer, int byteOffset, int byteCount);
    public IAsyncResult BeginWriteBytes(Byte[] byteBuffer, int byteOffset, int byteCount, AsyncCallback callback, object state);
    public void EndWriteBytes(IAsyncResult result);
    [SecurityCriticalAttribute]
protected void UnsafeWriteBytes(Byte* bytes, int byteCount);
    [SecuritySafeCriticalAttribute]
protected void WriteUTF8Char(int ch);
    protected void WriteUTF8Chars(Byte[] chars, int charOffset, int charCount);
    [SecuritySafeCriticalAttribute]
protected void WriteUTF8Chars(string value);
    [SecurityCriticalAttribute]
protected void UnsafeWriteUTF8Chars(Char* chars, int charCount);
    [SecurityCriticalAttribute]
protected void UnsafeWriteUnicodeChars(Char* chars, int charCount);
    [SecurityCriticalAttribute]
protected int UnsafeGetUnicodeChars(Char* chars, int charCount, Byte[] buffer, int offset);
    [SecurityCriticalAttribute]
protected int UnsafeGetUTF8Length(Char* chars, int charCount);
    [SecurityCriticalAttribute]
protected int UnsafeGetUTF8Chars(Char* chars, int charCount, Byte[] buffer, int offset);
    protected virtual void FlushBuffer();
    protected virtual IAsyncResult BeginFlushBuffer(AsyncCallback callback, object state);
    protected virtual void EndFlushBuffer(IAsyncResult result);
    public virtual void Flush();
    public virtual void Close();
}
internal class System.Xml.XmlUTF8NodeWriter : XmlStreamNodeWriter {
    
private Byte[] entityChars;
    
private Boolean[] isEscapedAttributeChar;
    
private Boolean[] isEscapedElementChar;
    
private bool inAttribute;
    
private static int bufferLength;
    
private static int maxEntityLength;
    
private static int maxBytesPerChar;
    
private Encoding encoding;
    
private Char[] chars;
    
private InternalWriteBase64TextAsyncWriter internalWriteBase64TextAsyncWriter;
    
private static Byte[] startDecl;
    
private static Byte[] endDecl;
    
private static Byte[] utf8Decl;
    
private static Byte[] digits;
    
private static Boolean[] defaultIsEscapedAttributeChar;
    
private static Boolean[] defaultIsEscapedElementChar;
    
public Encoding Encoding { get; }
    public XmlUTF8NodeWriter(Boolean[] isEscapedAttributeChar, Boolean[] isEscapedElementChar);
    private static XmlUTF8NodeWriter();
    public void SetOutput(Stream stream, bool ownsStream, Encoding encoding);
    public Encoding get_Encoding();
    private Byte[] GetCharEntityBuffer();
    private Char[] GetCharBuffer(int charCount);
    public virtual void WriteDeclaration();
    public virtual void WriteCData(string text);
    private void WriteStartComment();
    private void WriteEndComment();
    public virtual void WriteComment(string text);
    public virtual void WriteStartElement(string prefix, string localName);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName);
    public virtual void WriteStartElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEndStartElement(bool isEmpty);
    public virtual void WriteEndElement(string prefix, string localName);
    public virtual void WriteEndElement(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    private void WriteStartXmlnsAttribute();
    public virtual void WriteXmlnsAttribute(string prefix, string ns);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString ns);
    public virtual void WriteXmlnsAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] nsBuffer, int nsOffset, int nsLength);
    public virtual void WriteStartAttribute(string prefix, string localName);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName);
    public virtual void WriteStartAttribute(Byte[] prefixBuffer, int prefixOffset, int prefixLength, Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEndAttribute();
    private void WritePrefix(string prefix);
    private void WritePrefix(Byte[] prefixBuffer, int prefixOffset, int prefixLength);
    private void WriteLocalName(string localName);
    private void WriteLocalName(Byte[] localNameBuffer, int localNameOffset, int localNameLength);
    public virtual void WriteEscapedText(XmlDictionaryString s);
    [SecuritySafeCriticalAttribute]
public virtual void WriteEscapedText(string s);
    [SecuritySafeCriticalAttribute]
public virtual void WriteEscapedText(Char[] s, int offset, int count);
    [SecurityCriticalAttribute]
private void UnsafeWriteEscapedText(Char* chars, int count);
    public virtual void WriteEscapedText(Byte[] chars, int offset, int count);
    public void WriteText(int ch);
    public virtual void WriteText(Byte[] chars, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual void WriteText(Char[] chars, int offset, int count);
    public virtual void WriteText(string value);
    public virtual void WriteText(XmlDictionaryString value);
    public void WriteLessThanCharEntity();
    public void WriteGreaterThanCharEntity();
    public void WriteAmpersandCharEntity();
    public void WriteApostropheCharEntity();
    public void WriteQuoteCharEntity();
    private void WriteHexCharEntity(int ch);
    public virtual void WriteCharEntity(int ch);
    private int ToBase16(Byte[] chars, int offset, UInt32 value);
    public virtual void WriteBoolText(bool value);
    public virtual void WriteDecimalText(decimal value);
    public virtual void WriteDoubleText(double value);
    public virtual void WriteFloatText(float value);
    public virtual void WriteDateTimeText(DateTime value);
    public virtual void WriteUniqueIdText(UniqueId value);
    public virtual void WriteInt32Text(int value);
    public virtual void WriteInt64Text(long value);
    public virtual void WriteUInt64Text(ulong value);
    public virtual void WriteGuidText(Guid value);
    public virtual void WriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count);
    private void InternalWriteBase64Text(Byte[] buffer, int offset, int count);
    internal virtual AsyncCompletionResult WriteBase64TextAsync(AsyncEventArgs`1<XmlNodeWriterWriteBase64TextArgs> xmlNodeWriterState);
    public virtual IAsyncResult BeginWriteBase64Text(Byte[] trailBytes, int trailByteCount, Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWriteBase64Text(IAsyncResult result);
    private IAsyncResult BeginInternalWriteBase64Text(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    private void EndInternalWriteBase64Text(IAsyncResult result);
    public virtual void WriteTimeSpanText(TimeSpan value);
    public virtual void WriteStartListText();
    public virtual void WriteListSeparator();
    public virtual void WriteEndListText();
    public virtual void WriteQualifiedName(string prefix, XmlDictionaryString localName);
}
internal class System.Xml.XmlUTF8TextReader : XmlBaseReader {
    
private static int MaxTextChunk;
    
private PrefixHandle prefix;
    
private StringHandle localName;
    
private Int32[] rowOffsets;
    
private OnXmlDictionaryReaderClose onClose;
    
private bool buffered;
    
private int maxBytesPerRead;
    
private static Byte[] charType;
    
public int LineNumber { get; }
    
public int LinePosition { get; }
    private static XmlUTF8TextReader();
    public sealed virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public sealed virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    private void MoveToInitial(XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public virtual void Close();
    private void SkipWhitespace();
    private void ReadDeclaration();
    private void VerifyNCName(string s);
    private void ReadQualifiedName(PrefixHandle prefix, StringHandle localName);
    private int ReadAttributeText(Byte[] buffer, int offset, int offsetMax);
    private void ReadAttributes();
    private void ReadNonFFFE();
    private bool IsNextCharacterNonFFFE(Byte[] buffer, int offset);
    private void BufferElement();
    private void ReadStartElement();
    private void ReadEndElement();
    private void ReadComment();
    private void ReadCData();
    private int ReadCharRef();
    private void ReadWhitespace();
    private int ReadWhitespace(Byte[] buffer, int offset, int offsetMax);
    private int ReadText(Byte[] buffer, int offset, int offsetMax);
    private int ReadTextAndWatchForInvalidCharacters(Byte[] buffer, int offset, int offsetMax);
    private int BreakText(Byte[] buffer, int offset, int length);
    private void ReadText(bool hasLeadingByteOf0xEF);
    private void ReadEscapedText();
    public virtual bool Read();
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    private void GetPosition(Int32& row, Int32& column);
}
internal class System.Xml.XmlUTF8TextWriter : XmlBaseWriter {
    
private XmlUTF8NodeWriter writer;
    
internal bool FastAsync { get; }
    
public bool CanFragment { get; }
    internal virtual bool get_FastAsync();
    public sealed virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
    public virtual bool get_CanFragment();
    protected virtual XmlSigningNodeWriter CreateSigningNodeWriter();
}
internal class System.Xml.XmlWriteBase64AsyncArguments : object {
    [CompilerGeneratedAttribute]

private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]

private int <Offset>k__BackingField;
    
internal Byte[] Buffer { get; internal set; }
    
internal int Index { get; internal set; }
    
internal int Count { get; internal set; }
    
internal int Offset { get; internal set; }
    [CompilerGeneratedAttribute]
internal Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
internal void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
    [CompilerGeneratedAttribute]
internal int get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(int value);
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
