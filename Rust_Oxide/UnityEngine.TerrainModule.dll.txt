[UsedByNativeCodeAttribute]
public class UnityEngine.DetailInstanceTransform : ValueType {
    
public float posX;
    
public float posY;
    
public float posZ;
    
public float scaleXZ;
    
public float scaleY;
    
public float rotationY;
}
[NativeHeaderAttribute("TerrainScriptingClasses.h")]
[NativeHeaderAttribute("Modules/Terrain/Public/TerrainDataScriptingInterface.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.DetailPrototype : object {
    
internal static Color DefaultHealthColor;
    
internal static Color DefaultDryColor;
    
internal GameObject m_Prototype;
    
internal Texture2D m_PrototypeTexture;
    
internal Color m_HealthyColor;
    
internal Color m_DryColor;
    
internal float m_MinWidth;
    
internal float m_MaxWidth;
    
internal float m_MinHeight;
    
internal float m_MaxHeight;
    
internal int m_NoiseSeed;
    
internal float m_NoiseSpread;
    
internal float m_Density;
    
internal float m_HoleEdgePadding;
    
internal int m_RenderMode;
    
internal int m_UsePrototypeMesh;
    
internal int m_UseInstancing;
    
internal int m_UseDensityScaling;
    
internal float m_AlignToGround;
    
internal float m_PositionJitter;
    
internal float m_TargetCoverage;
    
public GameObject prototype { get; public set; }
    
public Texture2D prototypeTexture { get; public set; }
    
public float minWidth { get; public set; }
    
public float maxWidth { get; public set; }
    
public float minHeight { get; public set; }
    
public float maxHeight { get; public set; }
    
public int noiseSeed { get; public set; }
    
public float noiseSpread { get; public set; }
    
public float density { get; public set; }
    [ObsoleteAttribute("bendFactor has no effect and is deprecated.", "False")]

public float bendFactor { get; public set; }
    
public float holeEdgePadding { get; public set; }
    
public Color healthyColor { get; public set; }
    
public Color dryColor { get; public set; }
    
public DetailRenderMode renderMode { get; public set; }
    
public bool usePrototypeMesh { get; public set; }
    
public bool useInstancing { get; public set; }
    
public float targetCoverage { get; public set; }
    
public bool useDensityScaling { get; public set; }
    
public float alignToGround { get; public set; }
    
public float positionJitter { get; public set; }
    public DetailPrototype(DetailPrototype other);
    private static DetailPrototype();
    public GameObject get_prototype();
    public void set_prototype(GameObject value);
    public Texture2D get_prototypeTexture();
    public void set_prototypeTexture(Texture2D value);
    public float get_minWidth();
    public void set_minWidth(float value);
    public float get_maxWidth();
    public void set_maxWidth(float value);
    public float get_minHeight();
    public void set_minHeight(float value);
    public float get_maxHeight();
    public void set_maxHeight(float value);
    public int get_noiseSeed();
    public void set_noiseSeed(int value);
    public float get_noiseSpread();
    public void set_noiseSpread(float value);
    public float get_density();
    public void set_density(float value);
    public float get_bendFactor();
    public void set_bendFactor(float value);
    public float get_holeEdgePadding();
    public void set_holeEdgePadding(float value);
    public Color get_healthyColor();
    public void set_healthyColor(Color value);
    public Color get_dryColor();
    public void set_dryColor(Color value);
    public DetailRenderMode get_renderMode();
    public void set_renderMode(DetailRenderMode value);
    public bool get_usePrototypeMesh();
    public void set_usePrototypeMesh(bool value);
    public bool get_useInstancing();
    public void set_useInstancing(bool value);
    public float get_targetCoverage();
    public void set_targetCoverage(float value);
    public bool get_useDensityScaling();
    public void set_useDensityScaling(bool value);
    public float get_alignToGround();
    public void set_alignToGround(float value);
    public float get_positionJitter();
    public void set_positionJitter(float value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool Equals(DetailPrototype other);
    public bool Validate();
    public bool Validate(String& errorMessage);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::ValidateDetailPrototype")]
internal static bool ValidateDetailPrototype(DetailPrototype prototype, String& errorMessage);
    internal static bool IsModeSupportedByRenderPipeline(DetailRenderMode renderMode, bool useInstancing, String& errorMessage);
}
public enum UnityEngine.DetailRenderMode : Enum {
    
public int value__;
    
public static DetailRenderMode GrassBillboard;
    
public static DetailRenderMode VertexLit;
    
public static DetailRenderMode Grass;
}
public enum UnityEngine.DetailScatterMode : Enum {
    
public int value__;
    
public static DetailScatterMode CoverageMode;
    
public static DetailScatterMode InstanceCountMode;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.PatchExtents : ValueType {
    
internal float m_min;
    
internal float m_max;
    
public float min { get; public set; }
    
public float max { get; public set; }
    public float get_min();
    public void set_min(float value);
    public float get_max();
    public void set_max(float value);
}
internal class UnityEngine.SpeedTreeWindAsset : Object {
}
[UsedByNativeCodeAttribute]
public class UnityEngine.SplatPrototype : object {
    
internal Texture2D m_Texture;
    
internal Texture2D m_NormalMap;
    
internal Vector2 m_TileSize;
    
internal Vector2 m_TileOffset;
    
internal Vector4 m_SpecularMetallic;
    
internal float m_Smoothness;
    
public Texture2D texture { get; public set; }
    
public Texture2D normalMap { get; public set; }
    
public Vector2 tileSize { get; public set; }
    
public Vector2 tileOffset { get; public set; }
    
public Color specular { get; public set; }
    
public float metallic { get; public set; }
    
public float smoothness { get; public set; }
    public Texture2D get_texture();
    public void set_texture(Texture2D value);
    public Texture2D get_normalMap();
    public void set_normalMap(Texture2D value);
    public Vector2 get_tileSize();
    public void set_tileSize(Vector2 value);
    public Vector2 get_tileOffset();
    public void set_tileOffset(Vector2 value);
    public Color get_specular();
    public void set_specular(Color value);
    public float get_metallic();
    public void set_metallic(float value);
    public float get_smoothness();
    public void set_smoothness(float value);
}
[UsedByNativeCodeAttribute]
[StaticAccessorAttribute("GetITerrainManager()", "1")]
[NativeHeaderAttribute("TerrainScriptingClasses.h")]
[NativeHeaderAttribute("Runtime/Interfaces/ITerrainManager.h")]
[NativeHeaderAttribute("Modules/Terrain/Public/Terrain.h")]
public class UnityEngine.Terrain : Behaviour {
    
public TerrainData terrainData { get; public set; }
    
public float treeDistance { get; public set; }
    
public float treeBillboardDistance { get; public set; }
    
public float treeCrossFadeLength { get; public set; }
    
public int treeMaximumFullLODCount { get; public set; }
    
public float detailObjectDistance { get; public set; }
    
public float detailObjectDensity { get; public set; }
    
public float heightmapPixelError { get; public set; }
    
public int heightmapMaximumLOD { get; public set; }
    
public int heightmapMinimumLODSimplification { get; public set; }
    
public float basemapDistance { get; public set; }
    [NativePropertyAttribute("StaticLightmapIndexInt")]

public int lightmapIndex { get; public set; }
    [NativePropertyAttribute("DynamicLightmapIndexInt")]

public int realtimeLightmapIndex { get; public set; }
    [NativePropertyAttribute("StaticLightmapST")]

public Vector4 lightmapScaleOffset { get; public set; }
    [NativePropertyAttribute("DynamicLightmapST")]

public Vector4 realtimeLightmapScaleOffset { get; public set; }
    [NativePropertyAttribute("FreeUnusedRenderingResourcesObsolete")]
[ObsoleteAttribute("Terrain.freeUnusedRenderingResources is obsolete; use keepUnusedRenderingResources instead.")]

public bool freeUnusedRenderingResources { get; public set; }
    [NativePropertyAttribute("KeepUnusedRenderingResources")]

public bool keepUnusedRenderingResources { get; public set; }
    
public ShadowCastingMode shadowCastingMode { get; public set; }
    
public ReflectionProbeUsage reflectionProbeUsage { get; public set; }
    
public Material materialTemplate { get; public set; }
    
public bool drawHeightmap { get; public set; }
    
public bool allowAutoConnect { get; public set; }
    
public int groupingID { get; public set; }
    
public bool drawInstanced { get; public set; }
    
public bool enableHeightmapRayTracing { get; public set; }
    
public RenderTexture normalmapTexture { get; }
    
public bool drawTreesAndFoliage { get; public set; }
    
public Vector3 patchBoundsMultiplier { get; public set; }
    
public float treeLODBiasMultiplier { get; public set; }
    
public bool collectDetailPatches { get; public set; }
    
public bool ignoreQualitySettings { get; public set; }
    
public TerrainRenderFlags editorRenderFlags { get; public set; }
    
public TreeMotionVectorModeOverride treeMotionVectorModeOverride { get; public set; }
    
public bool preserveTreePrototypeLayers { get; public set; }
    [StaticAccessorAttribute("Terrain", "2")]

public static GraphicsFormat heightmapFormat { get; }
    
public static TextureFormat heightmapTextureFormat { get; }
    
public static RenderTextureFormat heightmapRenderTextureFormat { get; }
    [StaticAccessorAttribute("Terrain", "2")]

public static GraphicsFormat normalmapFormat { get; }
    
public static TextureFormat normalmapTextureFormat { get; }
    
public static RenderTextureFormat normalmapRenderTextureFormat { get; }
    [StaticAccessorAttribute("Terrain", "2")]

public static GraphicsFormat holesFormat { get; }
    
public static RenderTextureFormat holesRenderTextureFormat { get; }
    [StaticAccessorAttribute("Terrain", "2")]

public static GraphicsFormat compressedHolesFormat { get; }
    
public static TextureFormat compressedHolesTextureFormat { get; }
    
public static Terrain activeTerrain { get; }
    [NativePropertyAttribute("ActiveTerrainsScriptingArray")]

public static Terrain[] activeTerrains { get; }
    
public Terrain leftNeighbor { get; }
    
public Terrain rightNeighbor { get; }
    
public Terrain topNeighbor { get; }
    
public Terrain bottomNeighbor { get; }
    
public UInt32 renderingLayerMask { get; public set; }
    [ObsoleteAttribute("splatmapDistance is deprecated, please use basemapDistance instead. (UnityUpgradable) -> basemapDistance", "True")]
[EditorBrowsableAttribute("1")]

public float splatmapDistance { get; public set; }
    [ObsoleteAttribute("castShadows is deprecated, please use shadowCastingMode instead.")]

public bool castShadows { get; public set; }
    [ObsoleteAttribute("Property materialType is not used any more. Set materialTemplate directly.", "False")]

public MaterialType materialType { get; public set; }
    [ObsoleteAttribute("Property legacySpecular is not used any more. Set materialTemplate directly.", "False")]

public Color legacySpecular { get; public set; }
    [ObsoleteAttribute("Property legacyShininess is not used any more. Set materialTemplate directly.", "False")]

public float legacyShininess { get; public set; }
    public TerrainData get_terrainData();
    public void set_terrainData(TerrainData value);
    public float get_treeDistance();
    public void set_treeDistance(float value);
    public float get_treeBillboardDistance();
    public void set_treeBillboardDistance(float value);
    public float get_treeCrossFadeLength();
    public void set_treeCrossFadeLength(float value);
    public int get_treeMaximumFullLODCount();
    public void set_treeMaximumFullLODCount(int value);
    public float get_detailObjectDistance();
    public void set_detailObjectDistance(float value);
    public float get_detailObjectDensity();
    public void set_detailObjectDensity(float value);
    public float get_heightmapPixelError();
    public void set_heightmapPixelError(float value);
    public int get_heightmapMaximumLOD();
    public void set_heightmapMaximumLOD(int value);
    public int get_heightmapMinimumLODSimplification();
    public void set_heightmapMinimumLODSimplification(int value);
    public float get_basemapDistance();
    public void set_basemapDistance(float value);
    public int get_lightmapIndex();
    public void set_lightmapIndex(int value);
    public int get_realtimeLightmapIndex();
    public void set_realtimeLightmapIndex(int value);
    public Vector4 get_lightmapScaleOffset();
    public void set_lightmapScaleOffset(Vector4 value);
    public Vector4 get_realtimeLightmapScaleOffset();
    public void set_realtimeLightmapScaleOffset(Vector4 value);
    public bool get_freeUnusedRenderingResources();
    public void set_freeUnusedRenderingResources(bool value);
    public bool get_keepUnusedRenderingResources();
    public void set_keepUnusedRenderingResources(bool value);
    public bool GetKeepUnusedCameraRenderingResources(int cameraInstanceID);
    public void SetKeepUnusedCameraRenderingResources(int cameraInstanceID, bool keepUnused);
    public ShadowCastingMode get_shadowCastingMode();
    public void set_shadowCastingMode(ShadowCastingMode value);
    public ReflectionProbeUsage get_reflectionProbeUsage();
    public void set_reflectionProbeUsage(ReflectionProbeUsage value);
    public void GetClosestReflectionProbes(List`1<ReflectionProbeBlendInfo> result);
    public Material get_materialTemplate();
    public void set_materialTemplate(Material value);
    public bool get_drawHeightmap();
    public void set_drawHeightmap(bool value);
    public bool get_allowAutoConnect();
    public void set_allowAutoConnect(bool value);
    public int get_groupingID();
    public void set_groupingID(int value);
    public bool get_drawInstanced();
    public void set_drawInstanced(bool value);
    public bool get_enableHeightmapRayTracing();
    public void set_enableHeightmapRayTracing(bool value);
    [NativeMethodAttribute("TryGetNormalMapTexture")]
public RenderTexture get_normalmapTexture();
    public bool get_drawTreesAndFoliage();
    public void set_drawTreesAndFoliage(bool value);
    public Vector3 get_patchBoundsMultiplier();
    public void set_patchBoundsMultiplier(Vector3 value);
    public float SampleHeight(Vector3 worldPosition);
    public void AddTreeInstance(TreeInstance instance);
    public void SetNeighbors(Terrain left, Terrain top, Terrain right, Terrain bottom);
    public float get_treeLODBiasMultiplier();
    public void set_treeLODBiasMultiplier(float value);
    public bool get_collectDetailPatches();
    public void set_collectDetailPatches(bool value);
    public bool get_ignoreQualitySettings();
    public void set_ignoreQualitySettings(bool value);
    public TerrainRenderFlags get_editorRenderFlags();
    public void set_editorRenderFlags(TerrainRenderFlags value);
    public Vector3 GetPosition();
    public void Flush();
    internal void RemoveTrees(Vector2 position, float radius, int prototypeIndex);
    [NativeMethodAttribute("CopySplatMaterialCustomProps")]
public void SetSplatMaterialPropertyBlock(MaterialPropertyBlock properties);
    public void GetSplatMaterialPropertyBlock(MaterialPropertyBlock dest);
    [NativeMethodAttribute("GetSplatMaterialCustomProps")]
private void Internal_GetSplatMaterialPropertyBlock(MaterialPropertyBlock dest);
    public TreeMotionVectorModeOverride get_treeMotionVectorModeOverride();
    public void set_treeMotionVectorModeOverride(TreeMotionVectorModeOverride value);
    public bool get_preserveTreePrototypeLayers();
    public void set_preserveTreePrototypeLayers(bool value);
    public static GraphicsFormat get_heightmapFormat();
    public static TextureFormat get_heightmapTextureFormat();
    public static RenderTextureFormat get_heightmapRenderTextureFormat();
    public static GraphicsFormat get_normalmapFormat();
    public static TextureFormat get_normalmapTextureFormat();
    public static RenderTextureFormat get_normalmapRenderTextureFormat();
    public static GraphicsFormat get_holesFormat();
    public static RenderTextureFormat get_holesRenderTextureFormat();
    public static GraphicsFormat get_compressedHolesFormat();
    public static TextureFormat get_compressedHolesTextureFormat();
    public static Terrain get_activeTerrain();
    public static void SetConnectivityDirty();
    public static Terrain[] get_activeTerrains();
    public static void GetActiveTerrains(List`1<Terrain> terrainList);
    private static void Internal_FillActiveTerrainList(object terrainList);
    [UsedByNativeCodeAttribute]
public static GameObject CreateTerrainGameObject(TerrainData assignTerrain);
    public Terrain get_leftNeighbor();
    public Terrain get_rightNeighbor();
    public Terrain get_topNeighbor();
    public Terrain get_bottomNeighbor();
    public UInt32 get_renderingLayerMask();
    public void set_renderingLayerMask(UInt32 value);
    public float get_splatmapDistance();
    public void set_splatmapDistance(float value);
    public bool get_castShadows();
    public void set_castShadows(bool value);
    public MaterialType get_materialType();
    public void set_materialType(MaterialType value);
    public Color get_legacySpecular();
    public void set_legacySpecular(Color value);
    public float get_legacyShininess();
    public void set_legacyShininess(float value);
    [ObsoleteAttribute("Use TerrainData.SyncHeightmap to notify all Terrain instances using the TerrainData.", "False")]
public void ApplyDelayedHeightmapModification();
    private void get_lightmapScaleOffset_Injected(Vector4& ret);
    private void set_lightmapScaleOffset_Injected(Vector4& value);
    private void get_realtimeLightmapScaleOffset_Injected(Vector4& ret);
    private void set_realtimeLightmapScaleOffset_Injected(Vector4& value);
    private void get_patchBoundsMultiplier_Injected(Vector3& ret);
    private void set_patchBoundsMultiplier_Injected(Vector3& value);
    private float SampleHeight_Injected(Vector3& worldPosition);
    private void AddTreeInstance_Injected(TreeInstance& instance);
    private void GetPosition_Injected(Vector3& ret);
    private void RemoveTrees_Injected(Vector2& position, float radius, int prototypeIndex);
}
[MovedFromAttribute("UnityEngine.Experimental.TerrainAPI")]
public static class UnityEngine.TerrainCallbacks : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private static HeightmapChangedCallback heightmapChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private static TextureChangedCallback textureChanged;
    [CompilerGeneratedAttribute]
public static void add_heightmapChanged(HeightmapChangedCallback value);
    [CompilerGeneratedAttribute]
public static void remove_heightmapChanged(HeightmapChangedCallback value);
    [CompilerGeneratedAttribute]
public static void add_textureChanged(TextureChangedCallback value);
    [CompilerGeneratedAttribute]
public static void remove_textureChanged(TextureChangedCallback value);
    [RequiredByNativeCodeAttribute]
internal static void InvokeHeightmapChangedCallback(TerrainData terrainData, RectInt heightRegion, bool synched);
    [RequiredByNativeCodeAttribute]
internal static void InvokeTextureChangedCallback(TerrainData terrainData, string textureName, RectInt texelRegion, bool synched);
}
[FlagsAttribute]
public enum UnityEngine.TerrainChangedFlags : Enum {
    
public int value__;
    
public static TerrainChangedFlags Heightmap;
    
public static TerrainChangedFlags TreeInstances;
    
public static TerrainChangedFlags DelayedHeightmapUpdate;
    
public static TerrainChangedFlags FlushEverythingImmediately;
    
public static TerrainChangedFlags RemoveDirtyDetailsImmediately;
    
public static TerrainChangedFlags HeightmapResolution;
    
public static TerrainChangedFlags Holes;
    
public static TerrainChangedFlags DelayedHolesUpdate;
    
public static TerrainChangedFlags WillBeDestroyed;
}
[NativeHeaderAttribute("TerrainScriptingClasses.h")]
[NativeHeaderAttribute("Modules/Terrain/Public/TerrainDataScriptingInterface.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.TerrainData : Object {
    
private static string k_ScriptingInterfaceName;
    
private static string k_ScriptingInterfacePrefix;
    
private static string k_HeightmapPrefix;
    
private static string k_DetailDatabasePrefix;
    
private static string k_TreeDatabasePrefix;
    
private static string k_SplatDatabasePrefix;
    
internal static int k_MaximumResolution;
    
internal static int k_MinimumDetailResolutionPerPatch;
    
internal static int k_MaximumDetailResolutionPerPatch;
    
internal static int k_MaximumDetailPatchCount;
    
internal static int k_MinimumAlphamapResolution;
    
internal static int k_MaximumAlphamapResolution;
    
internal static int k_MinimumBaseMapResolution;
    
internal static int k_MaximumBaseMapResolution;
    [ObsoleteAttribute("Please use heightmapResolution instead. (UnityUpgradable) -> heightmapResolution", "False")]

public int heightmapWidth { get; }
    [ObsoleteAttribute("Please use heightmapResolution instead. (UnityUpgradable) -> heightmapResolution", "False")]

public int heightmapHeight { get; }
    
public RenderTexture heightmapTexture { get; }
    
public int heightmapResolution { get; public set; }
    
private int internalHeightmapResolution { get; private set; }
    
public Vector3 heightmapScale { get; }
    
public Texture holesTexture { get; }
    
public bool enableHolesTextureCompression { get; public set; }
    
internal RenderTexture holesRenderTexture { get; }
    
public int holesResolution { get; }
    
public Vector3 size { get; public set; }
    
public Bounds bounds { get; }
    [ObsoleteAttribute("Terrain thickness is no longer required by the physics engine. Set appropriate continuous collision detection modes to fast moving bodies.")]

public float thickness { get; public set; }
    
public float wavingGrassStrength { get; public set; }
    
public float wavingGrassAmount { get; public set; }
    
public float wavingGrassSpeed { get; public set; }
    
public Color wavingGrassTint { get; public set; }
    
public int detailWidth { get; }
    
public int detailHeight { get; }
    
public int maxDetailScatterPerRes { get; }
    
public int detailPatchCount { get; }
    
public int detailResolution { get; }
    
public int detailResolutionPerPatch { get; }
    
public DetailScatterMode detailScatterMode { get; }
    
public DetailPrototype[] detailPrototypes { get; public set; }
    
public TreeInstance[] treeInstances { get; public set; }
    
public int treeInstanceCount { get; }
    
public TreePrototype[] treePrototypes { get; public set; }
    
public int alphamapLayers { get; }
    
public int alphamapResolution { get; public set; }
    
private int Internal_alphamapResolution { get; private set; }
    
public int alphamapWidth { get; }
    
public int alphamapHeight { get; }
    
public int baseMapResolution { get; public set; }
    
private int Internal_baseMapResolution { get; private set; }
    
public int alphamapTextureCount { get; }
    
public Texture2D[] alphamapTextures { get; }
    [ObsoleteAttribute("Please use the terrainLayers API instead.", "False")]

public SplatPrototype[] splatPrototypes { get; public set; }
    
public TerrainLayer[] terrainLayers { get; public set; }
    
internal TextureFormat atlasFormat { get; }
    
internal Terrain[] users { get; }
    
private static bool SupportsCopyTextureBetweenRTAndTexture { get; }
    
public static string AlphamapTextureName { get; }
    
public static string HolesTextureName { get; }
    private static TerrainData();
    [ThreadSafeAttribute]
[StaticAccessorAttribute("TerrainDataScriptingInterface", "2")]
private static int GetBoundaryValue(BoundaryValueType type);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::Create")]
private static void Internal_Create(TerrainData terrainData);
    [ObsoleteAttribute("Please use DirtyHeightmapRegion instead.", "False")]
public void UpdateDirtyRegion(int x, int y, int width, int height, bool syncHeightmapTextureImmediately);
    public int get_heightmapWidth();
    public int get_heightmapHeight();
    [NativeNameAttribute("GetHeightmap().GetHeightmapTexture")]
public RenderTexture get_heightmapTexture();
    public int get_heightmapResolution();
    public void set_heightmapResolution(int value);
    [NativeNameAttribute("GetHeightmap().GetResolution")]
private int get_internalHeightmapResolution();
    [NativeNameAttribute("GetHeightmap().SetResolution")]
private void set_internalHeightmapResolution(int value);
    [NativeNameAttribute("GetHeightmap().GetScale")]
public Vector3 get_heightmapScale();
    public Texture get_holesTexture();
    [NativeNameAttribute("GetHeightmap().GetEnableHolesTextureCompression")]
public bool get_enableHolesTextureCompression();
    [NativeNameAttribute("GetHeightmap().SetEnableHolesTextureCompression")]
public void set_enableHolesTextureCompression(bool value);
    internal RenderTexture get_holesRenderTexture();
    [NativeNameAttribute("GetHeightmap().IsHolesTextureCompressed")]
internal bool IsHolesTextureCompressed();
    [NativeNameAttribute("GetHeightmap().GetHolesTexture")]
internal RenderTexture GetHolesTexture();
    [NativeNameAttribute("GetHeightmap().GetCompressedHolesTexture")]
internal Texture2D GetCompressedHolesTexture();
    public int get_holesResolution();
    [NativeNameAttribute("GetHeightmap().GetSize")]
public Vector3 get_size();
    [NativeNameAttribute("GetHeightmap().SetSize")]
public void set_size(Vector3 value);
    [NativeNameAttribute("GetHeightmap().CalculateBounds")]
public Bounds get_bounds();
    public float get_thickness();
    public void set_thickness(float value);
    [NativeNameAttribute("GetHeightmap().GetHeight")]
public float GetHeight(int x, int y);
    [NativeNameAttribute("GetHeightmap().GetInterpolatedHeight")]
public float GetInterpolatedHeight(float x, float y);
    public Single[0...,0...] GetInterpolatedHeights(float xBase, float yBase, int xCount, int yCount, float xInterval, float yInterval);
    public void GetInterpolatedHeights(Single[0...,0...] results, int resultXOffset, int resultYOffset, float xBase, float yBase, int xCount, int yCount, float xInterval, float yInterval);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetInterpolatedHeights")]
private void Internal_GetInterpolatedHeights(Single[0...,0...] results, int resultXDimension, int resultXOffset, int resultYOffset, float xBase, float yBase, int xCount, int yCount, float xInterval, float yInterval);
    public Single[0...,0...] GetHeights(int xBase, int yBase, int width, int height);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetHeights")]
private Single[0...,0...] Internal_GetHeights(int xBase, int yBase, int width, int height);
    public void SetHeights(int xBase, int yBase, Single[0...,0...] heights);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetHeights")]
private void Internal_SetHeights(int xBase, int yBase, int width, int height, Single[0...,0...] heights);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetPatchMinMaxHeights")]
public PatchExtents[] GetPatchMinMaxHeights();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::OverrideMinMaxPatchHeights")]
public void OverrideMinMaxPatchHeights(PatchExtents[] minMaxHeights);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetMaximumHeightError")]
public Single[] GetMaximumHeightError();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::OverrideMaximumHeightError")]
public void OverrideMaximumHeightError(Single[] maxError);
    public void SetHeightsDelayLOD(int xBase, int yBase, Single[0...,0...] heights);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetHeightsDelayLOD")]
private void Internal_SetHeightsDelayLOD(int xBase, int yBase, int width, int height, Single[0...,0...] heights);
    public bool IsHole(int x, int y);
    public Boolean[0...,0...] GetHoles(int xBase, int yBase, int width, int height);
    public void SetHoles(int xBase, int yBase, Boolean[0...,0...] holes);
    public void SetHolesDelayLOD(int xBase, int yBase, Boolean[0...,0...] holes);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetHoles")]
private void Internal_SetHoles(int xBase, int yBase, int width, int height, Boolean[0...,0...] holes);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetHoles")]
private Boolean[0...,0...] Internal_GetHoles(int xBase, int yBase, int width, int height);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::IsHole")]
private bool Internal_IsHole(int x, int y);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetHolesDelayLOD")]
private void Internal_SetHolesDelayLOD(int xBase, int yBase, int width, int height, Boolean[0...,0...] holes);
    [NativeNameAttribute("GetHeightmap().GetSteepness")]
public float GetSteepness(float x, float y);
    [NativeNameAttribute("GetHeightmap().GetInterpolatedNormal")]
public Vector3 GetInterpolatedNormal(float x, float y);
    [NativeNameAttribute("GetHeightmap().GetAdjustedSize")]
internal int GetAdjustedSize(int size);
    [NativeNameAttribute("GetDetailDatabase().GetWavingGrassStrength")]
public float get_wavingGrassStrength();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetWavingGrassStrength")]
public void set_wavingGrassStrength(float value);
    [NativeNameAttribute("GetDetailDatabase().GetWavingGrassAmount")]
public float get_wavingGrassAmount();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetWavingGrassAmount")]
public void set_wavingGrassAmount(float value);
    [NativeNameAttribute("GetDetailDatabase().GetWavingGrassSpeed")]
public float get_wavingGrassSpeed();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetWavingGrassSpeed")]
public void set_wavingGrassSpeed(float value);
    [NativeNameAttribute("GetDetailDatabase().GetWavingGrassTint")]
public Color get_wavingGrassTint();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetWavingGrassTint")]
public void set_wavingGrassTint(Color value);
    [NativeNameAttribute("GetDetailDatabase().GetWidth")]
public int get_detailWidth();
    [NativeNameAttribute("GetDetailDatabase().GetHeight")]
public int get_detailHeight();
    [NativeNameAttribute("GetDetailDatabase().GetMaximumScatterPerRes")]
public int get_maxDetailScatterPerRes();
    public void SetDetailResolution(int detailResolution, int resolutionPerPatch);
    [NativeNameAttribute("GetDetailDatabase().SetDetailResolution")]
private void Internal_SetDetailResolution(int patchCount, int resolutionPerPatch);
    public void SetDetailScatterMode(DetailScatterMode scatterMode);
    [NativeNameAttribute("GetDetailDatabase().SetDetailScatterMode")]
private void Internal_SetDetailScatterMode(DetailScatterMode scatterMode);
    [NativeNameAttribute("GetDetailDatabase().GetPatchCount")]
public int get_detailPatchCount();
    [NativeNameAttribute("GetDetailDatabase().GetResolution")]
public int get_detailResolution();
    [NativeNameAttribute("GetDetailDatabase().GetResolutionPerPatch")]
public int get_detailResolutionPerPatch();
    [NativeNameAttribute("GetDetailDatabase().GetDetailScatterMode")]
public DetailScatterMode get_detailScatterMode();
    [NativeNameAttribute("GetDetailDatabase().ResetDirtyDetails")]
internal void ResetDirtyDetails();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::RefreshPrototypes")]
public void RefreshPrototypes();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetDetailPrototypes")]
public DetailPrototype[] get_detailPrototypes();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetDetailPrototypes")]
public void set_detailPrototypes(DetailPrototype[] value);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetSupportedLayers")]
public Int32[] GetSupportedLayers(int xBase, int yBase, int totalWidth, int totalHeight);
    public Int32[] GetSupportedLayers(Vector2Int positionBase, Vector2Int size);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetDetailLayer")]
public Int32[0...,0...] GetDetailLayer(int xBase, int yBase, int width, int height, int layer);
    public Int32[0...,0...] GetDetailLayer(Vector2Int positionBase, Vector2Int size, int layer);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::ComputeDetailInstanceTransforms")]
public DetailInstanceTransform[] ComputeDetailInstanceTransforms(int patchX, int patchY, int layer, float density, Bounds& bounds);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::ComputeDetailCoverage")]
public float ComputeDetailCoverage(int detailPrototypeIndex);
    public void SetDetailLayer(int xBase, int yBase, int layer, Int32[0...,0...] details);
    public void SetDetailLayer(Vector2Int basePosition, int layer, Int32[0...,0...] details);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetDetailLayer")]
private void Internal_SetDetailLayer(int xBase, int yBase, int totalWidth, int totalHeight, int detailIndex, Int32[0...,0...] data);
    public TreeInstance[] get_treeInstances();
    public void set_treeInstances(TreeInstance[] value);
    [NativeNameAttribute("GetTreeDatabase().GetInstances")]
private TreeInstance[] Internal_GetTreeInstances();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetTreeInstances")]
public void SetTreeInstances(TreeInstance[] instances, bool snapToHeightmap);
    public TreeInstance GetTreeInstance(int index);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetTreeInstance")]
private TreeInstance Internal_GetTreeInstance(int index);
    [NativeThrowsAttribute]
[FreeFunctionAttribute("TerrainDataScriptingInterface::SetTreeInstance")]
public void SetTreeInstance(int index, TreeInstance instance);
    [NativeNameAttribute("GetTreeDatabase().GetInstances().size")]
public int get_treeInstanceCount();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetTreePrototypes")]
public TreePrototype[] get_treePrototypes();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetTreePrototypes")]
public void set_treePrototypes(TreePrototype[] value);
    [NativeNameAttribute("GetTreeDatabase().RemoveTreePrototype")]
internal void RemoveTreePrototype(int index);
    [NativeNameAttribute("GetDetailDatabase().RemoveDetailPrototype")]
public void RemoveDetailPrototype(int index);
    [NativeNameAttribute("GetTreeDatabase().NeedUpgradeScaledPrototypes")]
internal bool NeedUpgradeScaledTreePrototypes();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::UpgradeScaledTreePrototype")]
internal void UpgradeScaledTreePrototype();
    [NativeNameAttribute("GetSplatDatabase().GetSplatCount")]
public int get_alphamapLayers();
    public Single[0...,0...,0...] GetAlphamaps(int x, int y, int width, int height);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetAlphamaps")]
private Single[0...,0...,0...] Internal_GetAlphamaps(int x, int y, int width, int height);
    public int get_alphamapResolution();
    public void set_alphamapResolution(int value);
    [RequiredByNativeCodeAttribute]
[NativeNameAttribute("GetSplatDatabase().GetAlphamapResolution")]
internal float GetAlphamapResolutionInternal();
    [NativeNameAttribute("GetSplatDatabase().GetAlphamapResolution")]
private int get_Internal_alphamapResolution();
    [NativeNameAttribute("GetSplatDatabase().SetAlphamapResolution")]
private void set_Internal_alphamapResolution(int value);
    public int get_alphamapWidth();
    public int get_alphamapHeight();
    public int get_baseMapResolution();
    public void set_baseMapResolution(int value);
    [NativeNameAttribute("GetSplatDatabase().GetBaseMapResolution")]
private int get_Internal_baseMapResolution();
    [NativeNameAttribute("GetSplatDatabase().SetBaseMapResolution")]
private void set_Internal_baseMapResolution(int value);
    public void SetAlphamaps(int x, int y, Single[0...,0...,0...] map);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetAlphamaps")]
private void Internal_SetAlphamaps(int x, int y, int width, int height, Single[0...,0...,0...] map);
    [NativeNameAttribute("GetSplatDatabase().SetBaseMapsDirty")]
public void SetBaseMapDirty();
    [NativeNameAttribute("GetSplatDatabase().GetAlphaTexture")]
public Texture2D GetAlphamapTexture(int index);
    [NativeNameAttribute("GetSplatDatabase().GetAlphaTextureCount")]
public int get_alphamapTextureCount();
    public Texture2D[] get_alphamapTextures();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetSplatPrototypes")]
public SplatPrototype[] get_splatPrototypes();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetSplatPrototypes")]
public void set_splatPrototypes(SplatPrototype[] value);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::GetTerrainLayers")]
public TerrainLayer[] get_terrainLayers();
    [FreeFunctionAttribute("TerrainDataScriptingInterface::SetTerrainLayers")]
public void set_terrainLayers(TerrainLayer[] value);
    [NativeNameAttribute("GetTreeDatabase().AddTree")]
internal void AddTree(TreeInstance& tree);
    [NativeNameAttribute("GetTreeDatabase().RemoveTrees")]
internal int RemoveTrees(Vector2 position, float radius, int prototypeIndex);
    [NativeNameAttribute("GetHeightmap().CopyHeightmapFromActiveRenderTexture")]
private void Internal_CopyActiveRenderTextureToHeightmap(RectInt rect, int destX, int destY, TerrainHeightmapSyncControl syncControl);
    [NativeNameAttribute("GetHeightmap().DirtyHeightmapRegion")]
private void Internal_DirtyHeightmapRegion(int x, int y, int width, int height, TerrainHeightmapSyncControl syncControl);
    [NativeNameAttribute("GetHeightmap().SyncHeightmapGPUModifications")]
public void SyncHeightmap();
    [NativeNameAttribute("GetHeightmap().CopyHolesFromActiveRenderTexture")]
private void Internal_CopyActiveRenderTextureToHoles(RectInt rect, int destX, int destY, bool allowDelayedCPUSync);
    [NativeNameAttribute("GetHeightmap().DirtyHolesRegion")]
private void Internal_DirtyHolesRegion(int x, int y, int width, int height, bool allowDelayedCPUSync);
    [NativeNameAttribute("GetHeightmap().SyncHolesGPUModifications")]
private void Internal_SyncHoles();
    [NativeNameAttribute("GetSplatDatabase().MarkDirtyRegion")]
private void Internal_MarkAlphamapDirtyRegion(int alphamapIndex, int x, int y, int width, int height);
    [NativeNameAttribute("GetSplatDatabase().ClearDirtyRegion")]
private void Internal_ClearAlphamapDirtyRegion(int alphamapIndex);
    [NativeNameAttribute("GetSplatDatabase().SyncGPUModifications")]
private void Internal_SyncAlphamaps();
    [NativeNameAttribute("GetDetailDatabase().GetAtlasTexture()->GetTextureFormat")]
internal TextureFormat get_atlasFormat();
    internal Terrain[] get_users();
    private static bool get_SupportsCopyTextureBetweenRTAndTexture();
    public void CopyActiveRenderTextureToHeightmap(RectInt sourceRect, Vector2Int dest, TerrainHeightmapSyncControl syncControl);
    public void DirtyHeightmapRegion(RectInt region, TerrainHeightmapSyncControl syncControl);
    public static string get_AlphamapTextureName();
    public static string get_HolesTextureName();
    public void CopyActiveRenderTextureToTexture(string textureName, int textureIndex, RectInt sourceRect, Vector2Int dest, bool allowDelayedCPUSync);
    public void DirtyTextureRegion(string textureName, RectInt region, bool allowDelayedCPUSync);
    public void SyncTexture(string textureName);
    private void get_heightmapScale_Injected(Vector3& ret);
    private void get_size_Injected(Vector3& ret);
    private void set_size_Injected(Vector3& value);
    private void get_bounds_Injected(Bounds& ret);
    private void GetInterpolatedNormal_Injected(float x, float y, Vector3& ret);
    private void get_wavingGrassTint_Injected(Color& ret);
    private void set_wavingGrassTint_Injected(Color& value);
    private void Internal_GetTreeInstance_Injected(int index, TreeInstance& ret);
    private void SetTreeInstance_Injected(int index, TreeInstance& instance);
    private int RemoveTrees_Injected(Vector2& position, float radius, int prototypeIndex);
    private void Internal_CopyActiveRenderTextureToHeightmap_Injected(RectInt& rect, int destX, int destY, TerrainHeightmapSyncControl syncControl);
    private void Internal_CopyActiveRenderTextureToHoles_Injected(RectInt& rect, int destX, int destY, bool allowDelayedCPUSync);
}
[ExtensionAttribute]
public static class UnityEngine.TerrainExtensions : object {
    [ExtensionAttribute]
public static void UpdateGIMaterials(Terrain terrain);
    [ExtensionAttribute]
public static void UpdateGIMaterials(Terrain terrain, int x, int y, int width, int height);
    [FreeFunctionAttribute]
[NativeConditionalAttribute("INCLUDE_DYNAMIC_GI && ENABLE_RUNTIME_GI")]
internal static void UpdateGIMaterialsForTerrain(int terrainInstanceID, Rect uvBounds);
    private static void UpdateGIMaterialsForTerrain_Injected(int terrainInstanceID, Rect& uvBounds);
}
public enum UnityEngine.TerrainHeightmapSyncControl : Enum {
    
public int value__;
    
public static TerrainHeightmapSyncControl None;
    
public static TerrainHeightmapSyncControl HeightOnly;
    
public static TerrainHeightmapSyncControl HeightAndLod;
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/Terrain/Public/TerrainLayerScriptingInterface.h")]
[NativeHeaderAttribute("TerrainScriptingClasses.h")]
public class UnityEngine.TerrainLayer : Object {
    
public Texture2D diffuseTexture { get; public set; }
    
public Texture2D normalMapTexture { get; public set; }
    
public Texture2D maskMapTexture { get; public set; }
    
public Vector2 tileSize { get; public set; }
    
public Vector2 tileOffset { get; public set; }
    [NativePropertyAttribute("SpecularColor")]

public Color specular { get; public set; }
    
public float metallic { get; public set; }
    
public float smoothness { get; public set; }
    
public float normalScale { get; public set; }
    
public Vector4 diffuseRemapMin { get; public set; }
    
public Vector4 diffuseRemapMax { get; public set; }
    
public Vector4 maskMapRemapMin { get; public set; }
    
public Vector4 maskMapRemapMax { get; public set; }
    [FreeFunctionAttribute("TerrainLayerScriptingInterface::Create")]
private static void Internal_Create(TerrainLayer layer);
    public Texture2D get_diffuseTexture();
    public void set_diffuseTexture(Texture2D value);
    public Texture2D get_normalMapTexture();
    public void set_normalMapTexture(Texture2D value);
    public Texture2D get_maskMapTexture();
    public void set_maskMapTexture(Texture2D value);
    public Vector2 get_tileSize();
    public void set_tileSize(Vector2 value);
    public Vector2 get_tileOffset();
    public void set_tileOffset(Vector2 value);
    public Color get_specular();
    public void set_specular(Color value);
    public float get_metallic();
    public void set_metallic(float value);
    public float get_smoothness();
    public void set_smoothness(float value);
    public float get_normalScale();
    public void set_normalScale(float value);
    public Vector4 get_diffuseRemapMin();
    public void set_diffuseRemapMin(Vector4 value);
    public Vector4 get_diffuseRemapMax();
    public void set_diffuseRemapMax(Vector4 value);
    public Vector4 get_maskMapRemapMin();
    public void set_maskMapRemapMin(Vector4 value);
    public Vector4 get_maskMapRemapMax();
    public void set_maskMapRemapMax(Vector4 value);
    private void get_tileSize_Injected(Vector2& ret);
    private void set_tileSize_Injected(Vector2& value);
    private void get_tileOffset_Injected(Vector2& ret);
    private void set_tileOffset_Injected(Vector2& value);
    private void get_specular_Injected(Color& ret);
    private void set_specular_Injected(Color& value);
    private void get_diffuseRemapMin_Injected(Vector4& ret);
    private void set_diffuseRemapMin_Injected(Vector4& value);
    private void get_diffuseRemapMax_Injected(Vector4& ret);
    private void set_diffuseRemapMax_Injected(Vector4& value);
    private void get_maskMapRemapMin_Injected(Vector4& ret);
    private void set_maskMapRemapMin_Injected(Vector4& value);
    private void get_maskMapRemapMax_Injected(Vector4& ret);
    private void set_maskMapRemapMax_Injected(Vector4& value);
}
[FlagsAttribute]
public enum UnityEngine.TerrainRenderFlags : Enum {
    
public int value__;
    [ObsoleteAttribute("TerrainRenderFlags.heightmap is obsolete, use TerrainRenderFlags.Heightmap instead. (UnityUpgradable) -> Heightmap")]

public static TerrainRenderFlags heightmap;
    [ObsoleteAttribute("TerrainRenderFlags.trees is obsolete, use TerrainRenderFlags.Trees instead. (UnityUpgradable) -> Trees")]

public static TerrainRenderFlags trees;
    [ObsoleteAttribute("TerrainRenderFlags.details is obsolete, use TerrainRenderFlags.Details instead. (UnityUpgradable) -> Details")]

public static TerrainRenderFlags details;
    [ObsoleteAttribute("TerrainRenderFlags.all is obsolete, use TerrainRenderFlags.All instead. (UnityUpgradable) -> All")]

public static TerrainRenderFlags all;
    
public static TerrainRenderFlags Heightmap;
    
public static TerrainRenderFlags Trees;
    
public static TerrainRenderFlags Details;
    
public static TerrainRenderFlags All;
}
[MovedFromAttribute("UnityEngine.Experimental.TerrainAPI")]
public class UnityEngine.TerrainTools.BrushTransform : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector2 <brushOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector2 <brushU>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector2 <brushV>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector2 <targetOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector2 <targetX>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector2 <targetY>k__BackingField;
    
public Vector2 brushOrigin { get; }
    
public Vector2 brushU { get; }
    
public Vector2 brushV { get; }
    
public Vector2 targetOrigin { get; }
    
public Vector2 targetX { get; }
    
public Vector2 targetY { get; }
    public BrushTransform(Vector2 brushOrigin, Vector2 brushU, Vector2 brushV);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector2 get_brushOrigin();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector2 get_brushU();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector2 get_brushV();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector2 get_targetOrigin();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector2 get_targetX();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector2 get_targetY();
    public Rect GetBrushXYBounds();
    public static BrushTransform FromRect(Rect brushRect);
    public Vector2 ToBrushUV(Vector2 targetXY);
    public Vector2 FromBrushUV(Vector2 brushUV);
}
[MovedFromAttribute("UnityEngine.Experimental.TerrainAPI")]
public class UnityEngine.TerrainTools.PaintContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private Terrain <originTerrain>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private RectInt <pixelRect>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private int <targetTextureWidth>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private int <targetTextureHeight>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private Vector2 <pixelSize>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private RenderTexture <sourceRenderTexture>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]

private RenderTexture <destinationRenderTexture>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private RenderTexture <oldRenderTexture>k__BackingField;
    
private List`1<TerrainTile> m_TerrainTiles;
    
private float m_HeightWorldSpaceMin;
    
private float m_HeightWorldSpaceMax;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]

private static Action`3<ITerrainInfo, ToolAction, string> onTerrainTileBeforePaint;
    
internal static int k_MinimumResolution;
    
internal static int k_MaximumResolution;
    
private static List`1<PaintedTerrain> s_PaintedTerrain;
    
public Terrain originTerrain { get; }
    
public RectInt pixelRect { get; }
    
public int targetTextureWidth { get; }
    
public int targetTextureHeight { get; }
    
public Vector2 pixelSize { get; }
    
public RenderTexture sourceRenderTexture { get; private set; }
    
public RenderTexture destinationRenderTexture { get; private set; }
    
public RenderTexture oldRenderTexture { get; private set; }
    
public int terrainCount { get; }
    
public float heightWorldSpaceMin { get; }
    
public float heightWorldSpaceSize { get; }
    
public static float kNormalizedHeightScale { get; }
    public PaintContext(Terrain terrain, RectInt pixelRect, int targetTextureWidth, int targetTextureHeight, bool sharedBoundaryTexel, bool fillOutsideTerrain);
    private static PaintContext();
    [CompilerGeneratedAttribute]
public Terrain get_originTerrain();
    [CompilerGeneratedAttribute]
public RectInt get_pixelRect();
    [CompilerGeneratedAttribute]
public int get_targetTextureWidth();
    [CompilerGeneratedAttribute]
public int get_targetTextureHeight();
    [CompilerGeneratedAttribute]
public Vector2 get_pixelSize();
    [CompilerGeneratedAttribute]
public RenderTexture get_sourceRenderTexture();
    [CompilerGeneratedAttribute]
private void set_sourceRenderTexture(RenderTexture value);
    [CompilerGeneratedAttribute]
public RenderTexture get_destinationRenderTexture();
    [CompilerGeneratedAttribute]
private void set_destinationRenderTexture(RenderTexture value);
    [CompilerGeneratedAttribute]
public RenderTexture get_oldRenderTexture();
    [CompilerGeneratedAttribute]
private void set_oldRenderTexture(RenderTexture value);
    public int get_terrainCount();
    public Terrain GetTerrain(int terrainIndex);
    public RectInt GetClippedPixelRectInTerrainPixels(int terrainIndex);
    public RectInt GetClippedPixelRectInRenderTexturePixels(int terrainIndex);
    public float get_heightWorldSpaceMin();
    public float get_heightWorldSpaceSize();
    public static float get_kNormalizedHeightScale();
    [CompilerGeneratedAttribute]
internal static void add_onTerrainTileBeforePaint(Action`3<ITerrainInfo, ToolAction, string> value);
    [CompilerGeneratedAttribute]
internal static void remove_onTerrainTileBeforePaint(Action`3<ITerrainInfo, ToolAction, string> value);
    internal static int ClampContextResolution(int resolution);
    public static PaintContext CreateFromBounds(Terrain terrain, Rect boundsInTerrainSpace, int inputTextureWidth, int inputTextureHeight, int extraBorderPixels, bool sharedBoundaryTexel, bool fillOutsideTerrain);
    private void FindTerrainTilesUnlimited(bool sharedBoundaryTexel, bool fillOutsideTerrain);
    public void CreateRenderTargets(RenderTextureFormat colorFormat);
    public void Cleanup(bool restoreRenderTexture);
    private void GatherInternal(Func`2<ITerrainInfo, Texture> terrainToTexture, Color defaultColor, string operationName, Material blitMaterial, int blitPass, Action`1<ITerrainInfo> beforeBlit, Action`1<ITerrainInfo> afterBlit);
    private void ScatterInternal(Func`2<ITerrainInfo, RenderTexture> terrainToRT, string operationName, Material blitMaterial, int blitPass, Action`1<ITerrainInfo> beforeBlit, Action`1<ITerrainInfo> afterBlit);
    public void Gather(Func`2<ITerrainInfo, Texture> terrainSource, Color defaultColor, Material blitMaterial, int blitPass, Action`1<ITerrainInfo> beforeBlit, Action`1<ITerrainInfo> afterBlit);
    public void Scatter(Func`2<ITerrainInfo, RenderTexture> terrainDest, Material blitMaterial, int blitPass, Action`1<ITerrainInfo> beforeBlit, Action`1<ITerrainInfo> afterBlit);
    public void GatherHeightmap();
    public void ScatterHeightmap(string editorUndoName);
    public void GatherHoles();
    public void ScatterHoles(string editorUndoName);
    public void GatherNormals();
    private SplatmapUserData GetTerrainLayerUserData(ITerrainInfo context, TerrainLayer terrainLayer, bool addLayerIfDoesntExist);
    public void GatherAlphamap(TerrainLayer inputLayer, bool addLayerIfDoesntExist);
    public void ScatterAlphamap(string editorUndoName);
    private static void OnTerrainPainted(ITerrainInfo tile, ToolAction action);
    public static void ApplyDelayedActions();
}
public enum UnityEngine.TerrainTools.TerrainBuiltinPaintMaterialPasses : Enum {
    
public int value__;
    
public static TerrainBuiltinPaintMaterialPasses RaiseLowerHeight;
    
public static TerrainBuiltinPaintMaterialPasses StampHeight;
    
public static TerrainBuiltinPaintMaterialPasses SetHeights;
    
public static TerrainBuiltinPaintMaterialPasses SmoothHeights;
    
public static TerrainBuiltinPaintMaterialPasses PaintTexture;
    
public static TerrainBuiltinPaintMaterialPasses PaintHoles;
}
[MovedFromAttribute("UnityEngine.Experimental.TerrainAPI")]
public static class UnityEngine.TerrainTools.TerrainPaintUtility : object {
    
private static Material s_BuiltinPaintMaterial;
    
private static Material s_BlitMaterial;
    
private static Material s_HeightBlitMaterial;
    
private static Material s_CopyTerrainLayerMaterial;
    
internal static bool paintTextureUsesCopyTexture { get; }
    public static Material GetBuiltinPaintMaterial();
    public static void GetBrushWorldSizeLimits(Single& minBrushWorldSize, Single& maxBrushWorldSize, float terrainTileWorldSize, int terrainTileTextureResolutionPixels, int minBrushResolutionPixels, int maxBrushResolutionPixels);
    public static BrushTransform CalculateBrushTransform(Terrain terrain, Vector2 brushCenterTerrainUV, float brushSize, float brushRotationDegrees);
    public static void BuildTransformPaintContextUVToPaintContextUV(PaintContext src, PaintContext dst, Vector4& scaleOffset);
    public static void SetupTerrainToolMaterialProperties(PaintContext paintContext, BrushTransform& brushXform, Material material);
    internal static bool get_paintTextureUsesCopyTexture();
    internal static PaintContext InitializePaintContext(Terrain terrain, int targetWidth, int targetHeight, RenderTextureFormat pcFormat, Rect boundsInTerrainSpace, int extraBorderPixels, bool sharedBoundaryTexel, bool fillOutsideTerrain);
    public static void ReleaseContextResources(PaintContext ctx);
    public static PaintContext BeginPaintHeightmap(Terrain terrain, Rect boundsInTerrainSpace, int extraBorderPixels, bool fillOutsideTerrain);
    public static void EndPaintHeightmap(PaintContext ctx, string editorUndoName);
    public static PaintContext BeginPaintHoles(Terrain terrain, Rect boundsInTerrainSpace, int extraBorderPixels, bool fillOutsideTerrain);
    public static void EndPaintHoles(PaintContext ctx, string editorUndoName);
    public static PaintContext CollectNormals(Terrain terrain, Rect boundsInTerrainSpace, int extraBorderPixels, bool fillOutsideTerrain);
    public static PaintContext BeginPaintTexture(Terrain terrain, Rect boundsInTerrainSpace, TerrainLayer inputLayer, int extraBorderPixels, bool fillOutsideTerrain);
    public static void EndPaintTexture(PaintContext ctx, string editorUndoName);
    public static Material GetBlitMaterial();
    public static Material GetHeightBlitMaterial();
    public static Material GetCopyTerrainLayerMaterial();
    internal static void DrawQuad(RectInt destinationPixels, RectInt sourcePixels, Texture sourceTexture);
    internal static void DrawQuad2(RectInt destinationPixels, RectInt sourcePixels, Texture sourceTexture, RectInt sourcePixels2, Texture sourceTexture2);
    internal static void DrawQuadPadded(RectInt destinationPixels, RectInt destinationPixelsPadded, RectInt sourcePixels, RectInt sourcePixelsPadded, Texture sourceTexture);
    internal static RectInt CalcPixelRectFromBounds(Terrain terrain, Rect boundsInTerrainSpace, int textureWidth, int textureHeight, int extraBorderPixels, bool sharedBoundaryTexel);
    public static Texture2D GetTerrainAlphaMapChecked(Terrain terrain, int mapIndex);
    public static int FindTerrainLayerIndex(Terrain terrain, TerrainLayer inputLayer);
    internal static int AddTerrainLayer(Terrain terrain, TerrainLayer inputLayer);
}
public class UnityEngine.TerrainUtils.TerrainMap : object {
    
private Vector3 m_patchSize;
    
private TerrainMapStatusCode m_errorCode;
    
private Dictionary`2<TerrainTileCoord, Terrain> m_terrainTiles;
    
public Dictionary`2<TerrainTileCoord, Terrain> terrainTiles { get; }
    public Terrain GetTerrain(int tileX, int tileZ);
    public static TerrainMap CreateFromConnectedNeighbors(Terrain originTerrain, Predicate`1<Terrain> filter, bool fullValidation);
    public static TerrainMap CreateFromPlacement(Terrain originTerrain, Predicate`1<Terrain> filter, bool fullValidation);
    public static TerrainMap CreateFromPlacement(Vector2 gridOrigin, Vector2 gridSize, Predicate`1<Terrain> filter, bool fullValidation);
    public Dictionary`2<TerrainTileCoord, Terrain> get_terrainTiles();
    private void AddTerrainInternal(int x, int z, Terrain terrain);
    private bool TryToAddTerrain(int tileX, int tileZ, Terrain terrain);
    private void ValidateTerrain(int tileX, int tileZ);
    private TerrainMapStatusCode Validate();
}
internal enum UnityEngine.TerrainUtils.TerrainMapStatusCode : Enum {
    
public int value__;
    
public static TerrainMapStatusCode OK;
    
public static TerrainMapStatusCode Overlapping;
    
public static TerrainMapStatusCode SizeMismatch;
    
public static TerrainMapStatusCode EdgeAlignmentMismatch;
}
[IsReadOnlyAttribute]
public class UnityEngine.TerrainUtils.TerrainTileCoord : ValueType {
    
public int tileX;
    
public int tileZ;
    public TerrainTileCoord(int tileX, int tileZ);
}
[MovedFromAttribute("UnityEngine.Experimental.TerrainAPI")]
public static class UnityEngine.TerrainUtils.TerrainUtility : object {
    internal static bool ValidTerrainsExist();
    internal static void ClearConnectivity();
    internal static Dictionary`2<int, TerrainMap> CollectTerrains(bool onlyAutoConnectedTerrains);
    [RequiredByNativeCodeAttribute]
public static void AutoConnect();
}
[NativeHeaderAttribute("Modules/Terrain/Public/Tree.h")]
[ExcludeFromPresetAttribute]
public class UnityEngine.Tree : Component {
    [NativePropertyAttribute("TreeData")]

public ScriptableObject data { get; public set; }
    
public bool hasSpeedTreeWind { get; }
    public ScriptableObject get_data();
    public void set_data(ScriptableObject value);
    [NativeMethodAttribute("HasSpeedTreeWind")]
public bool get_hasSpeedTreeWind();
}
[UsedByNativeCodeAttribute]
public class UnityEngine.TreeInstance : ValueType {
    
public Vector3 position;
    
public float widthScale;
    
public float heightScale;
    
public float rotation;
    
public Color32 color;
    
public Color32 lightmapColor;
    
public int prototypeIndex;
    
internal float temporaryDistance;
}
public enum UnityEngine.TreeMotionVectorModeOverride : Enum {
    
public int value__;
    
public static TreeMotionVectorModeOverride CameraMotionOnly;
    
public static TreeMotionVectorModeOverride PerObjectMotion;
    
public static TreeMotionVectorModeOverride ForceNoMotion;
    
public static TreeMotionVectorModeOverride InheritFromPrototype;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.TreePrototype : object {
    
internal GameObject m_Prefab;
    
internal float m_BendFactor;
    
internal int m_NavMeshLod;
    
public GameObject prefab { get; public set; }
    
public float bendFactor { get; public set; }
    
public int navMeshLod { get; public set; }
    public TreePrototype(TreePrototype other);
    public GameObject get_prefab();
    public void set_prefab(GameObject value);
    public float get_bendFactor();
    public void set_bendFactor(float value);
    public int get_navMeshLod();
    public void set_navMeshLod(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool Equals(TreePrototype other);
    internal bool Validate(String& errorMessage);
    [FreeFunctionAttribute("TerrainDataScriptingInterface::ValidateTreePrototype")]
internal static bool ValidateTreePrototype(TreePrototype prototype, String& errorMessage);
}
