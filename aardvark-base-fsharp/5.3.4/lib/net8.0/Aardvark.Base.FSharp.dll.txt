[CompilationMappingAttribute]
public static class Aardvark.Base.Ag : object {
    [CompilationMappingAttribute]
internal static object anyObj { get; }
    [CompilationMappingAttribute]
internal static ConditionalWeakTable`2<object, Dictionary`2<string, object>> globalValues { get; }
    internal static object get_anyObj();
    internal static ConditionalWeakTable`2<object, Dictionary`2<string, object>> get_globalValues();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasSynRule(Type nodeType, Type expected, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<object> runinh(Scope scope, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<object> syn(a node, Scope scope, string name, Type expectedType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static object Object.get_AllChildren(object );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void set(a target, string name, b value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void op_DynamicAssignment(a target, string name, b value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c opAux(d _d, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c opAux$W(FSharpFunc`2<a, FSharpFunc`2<b, c>> get, d _d, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c op_Dynamic(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c op_Dynamic$W(FSharpFunc`2<a, FSharpFunc`2<b, c>> get, a a, b b);
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.AgScopeExtensions : object {
    [ExtensionAttribute]
public static FSharpOption`1<object> TryGetInherited(Scope this, string name);
    [ExtensionAttribute]
public static FSharpOption`1<a> TryGetInherited(Scope this, string name);
    [ExtensionAttribute]
public static object GetInherted(Scope this, string name);
    [ExtensionAttribute]
public static a GetInherted(Scope this, string name);
    [ExtensionAttribute]
public static FSharpOption`1<a> TryGetSynthesized(object node, string name, Scope scope);
    [ExtensionAttribute]
public static FSharpOption`1<a> TryGetSynthesized(Scope scope, string name);
    [ExtensionAttribute]
public static a GetSynthesized(object node, string name, Scope scope);
    [ExtensionAttribute]
public static FSharpOption`1<object> TryGetAttributeValue(Scope scope, string name);
    [ExtensionAttribute]
public static FSharpOption`1<a> TryGetAttributeValue(Scope scope, string name);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.AMD64 : object {
    [CompilationMappingAttribute]
public static CallingConvention windows { get; }
    [CompilationMappingAttribute]
public static CallingConvention linux { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@58-6(Value this, Value obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@58-7(Value this, Value objTemp, Unit unitVar);
    public static CallingConvention get_windows();
    public static CallingConvention get_linux();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Amd64Base : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231250@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231252@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231253@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231254@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231255@;
    [DebuggerBrowsableAttribute("0")]
internal static T231256_3Bytes@ field231257@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231258@;
    private static Amd64Base();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void write(int index, Byte[] ptr, Byte[] data);
    public static Byte[] toArray(ArrayWriter p);
    public static ArrayWriter jump(byte offset);
    public static ArrayWriter jumpInt(int offset);
    public static ArrayWriter nops(int count);
    public static ArrayWriter call(IntPtr ptr);
    public static ArrayWriter jmp(IntPtr ptr);
    public static ArrayWriter pushret(int skip);
    public static ArrayWriter concat(a values);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Amd64Linux : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231259@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231260@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231261@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231262@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231263@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231264@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231265@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231266@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231267@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231268@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231269@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231270@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231271@;
    [CompilationMappingAttribute]
internal static Byte[][] argMovs64 { get; }
    [CompilationMappingAttribute]
internal static Byte[][] argMovs32 { get; }
    private static Amd64Linux();
    internal static Byte[][] get_argMovs64();
    internal static Byte[][] get_argMovs32();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArrayWriter setArg64Internal(int index, long value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArrayWriter setArg32Internal(int index, int value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArrayWriter setArg32(int index, int arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArrayWriter setArg64(int index, long arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArrayWriter compileCallInternal(IntPtr f, Object[] args);
    public static b[] functionProlog(a argCount);
    public static Byte[] functionEpilog(a argCount);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] compileCall(IntPtr f, Object[] args);
    public static Byte[] compileCalls(IEnumerable`1<Tuple`2<IntPtr, Object[]>> calls);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Amd64Windows : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231272@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231273@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231274@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231275@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231276@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231277@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231278@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231279@;
    [DebuggerBrowsableAttribute("0")]
internal static T231280_4Bytes@ field231281@;
    [DebuggerBrowsableAttribute("0")]
internal static T231280_4Bytes@ field231282@;
    [DebuggerBrowsableAttribute("0")]
internal static T231283_5Bytes@ field231284@;
    [DebuggerBrowsableAttribute("0")]
internal static T231283_5Bytes@ field231285@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231286@;
    [CompilationMappingAttribute]
internal static Byte[][] argumentMove64 { get; }
    [CompilationMappingAttribute]
internal static Byte[][] argumentMove32 { get; }
    [CompilationMappingAttribute]
internal static Byte[][] floatMoves32 { get; }
    private static Amd64Windows();
    internal static ArrayWriter prolog(byte additionalSpace);
    internal static ArrayWriter epilog(byte additionalSpace);
    internal static Byte[][] get_argumentMove64();
    internal static Byte[][] get_argumentMove32();
    internal static Byte[][] get_floatMoves32();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArrayWriter setArg64(int index, long arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArrayWriter setArg32(int index, int arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArrayWriter setArg32f(int index, float arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArrayWriter compileCallInternal(IntPtr f, Object[] args);
    internal static byte getAdditionalSize(int argCount);
    public static Byte[] functionProlog(int argCount);
    public static Byte[] functionEpilog(int argCount);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] compileCall(IntPtr f, Object[] args);
    public static Byte[] compileCalls(IEnumerable`1<Tuple`2<IntPtr, Object[]>> calls);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.ArmLinux : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231287_148Bytes@ field231288@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231289@;
    [DebuggerBrowsableAttribute("0")]
internal static T231251_2Bytes@ field231290@;
    [DebuggerBrowsableAttribute("0")]
internal static T231280_4Bytes@ field231291@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231292@;
    [DebuggerBrowsableAttribute("0")]
internal static T231280_4Bytes@ field231293@;
    [DebuggerBrowsableAttribute("0")]
internal static T231280_4Bytes@ field231294@;
    [CompilationMappingAttribute]
internal static Int32[] lookup { get; }
    [CompilationMappingAttribute]
public static Byte[] functionProlog { get; }
    [CompilationMappingAttribute]
public static Byte[] functionEpilog { get; }
    private static ArmLinux();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static UInt32 readArmImmediate(byte high, byte low);
    internal static Int32[] get_lookup();
    public static string printBits(int value);
    public static UInt32 countTrailingZeros(UInt32 value);
    public static UInt32 highestBit(UInt32 value);
    public static Tuple`2<UInt32, int> toValueAndRotation(UInt32 value);
    public static FSharpOption`1<Tuple`2<byte, byte>> toArmImmediate(UInt32 value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] ldr(int register, ushort offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] str(int register, ushort stackoffset);
    public static Builder value(Byte[] data);
    public static Byte[] runBuilder(Builder b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Builder concatBinary(Builder l, Builder r);
    public static Builder concat(IEnumerable`1<Builder> builders);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Builder mov(int register, int value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] immediateMov(int register, int value);
    public static Byte[] changeReturnAddress(int value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Builder setArg(int index, int value);
    public static Builder call(IntPtr ptr);
    public static Builder jmp(int offset);
    public static void printInstructions(Byte[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Builder compileCallInternal(IntPtr f, Object[] args);
    public static Byte[] get_functionProlog();
    public static Byte[] get_functionEpilog();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] compileCall(IntPtr f, Object[] args);
    public static Byte[] compileCalls(IEnumerable`1<Tuple`2<IntPtr, Object[]>> calls);
}
[DefaultMemberAttribute("Item")]
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Aardvark.Base.arr`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FingerTreeNode`2<a, int> root@;
    [CompilationMappingAttribute]
internal FingerTreeNode`2<a, int> root { get; }
    internal string AsString { get; }
    public int Length { get; }
    public a Item { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.arr`1")]
internal arr`1(FingerTreeNode`2<a, int> root);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FingerTreeNode`2<a, int> get_root();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(arr`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal bool Equals(arr`1<a> obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal string get_AsString();
    public int get_Length();
    public a get_Item(int i);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<a> System.Collections.Generic.IEnumerable<'a>.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(arr`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Arrays : object {
    public static FSharpValueOption`1<Tuple`2<int, Type>> |FixedArrayType|_|(Type t);
    public static FSharpValueOption`1<Tuple`2<Type, Object[]>> |FixedArray|_|(object o);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.ArraySegmentModule : object {
    public static FSharpValueOption`1<T> tryHeadV(ArraySegment`1<T> segment);
    public static T[] copyArray(ArraySegment`1<T> segment);
    public static ArraySegment`1<T1> copy(ArraySegment`1<T1> segment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T2[] mapArray(FSharpFunc`2<T1, T2> mapping, ArraySegment`1<T1> segment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArraySegment`1<T2> map(FSharpFunc`2<T1, T2> mapping, ArraySegment`1<T1> segment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(T value, ArraySegment`1<T> segment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T reduce(FSharpFunc`2<T, FSharpFunc`2<T, T>> reduction, ArraySegment`1<T> segment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArraySegment`1<T> slice(int start, int count, ArraySegment`1<T> segment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArraySegment`1<T> sliceFrom(int start, ArraySegment`1<T> segment);
}
[CompilationMappingAttribute]
internal class Aardvark.Base.ArrMeasureImpl`1 : object {
    internal static Measure`2<a, int> instance;
    internal static int init@728;
    internal static Measure`2<a, int> Instance { get; }
    private static ArrMeasureImpl`1();
    internal static Measure`2<a, int> get_Instance();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.ArrModule : object {
    internal static Measure`2<a, int> mm();
    internal static a outOfRange();
    public static arr`1<a> empty();
    public static arr`1<a> ofSeq(IEnumerable`1<a> s);
    public static arr`1<a> ofList(FSharpList`1<a> l);
    public static arr`1<a> ofArray(a[] l);
    public static IEnumerable`1<a> toSeq(arr`1<a> a);
    public static FSharpList`1<a> toList(arr`1<a> a);
    public static a[] toArray(arr`1<a> a);
    public static int length(arr`1<a> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a get(int i, arr`1<a> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static arr`1<a> set(int i, a value, arr`1<a> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<arr`1<a>, arr`1<a>> splitAt(int i, arr`1<a> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static arr`1<a> concatWithMiddle(arr`1<a> l, FSharpList`1<a> m, arr`1<a> r);
    public static FSharpOption`1<Tuple`2<a, arr`1<a>>> viewl(arr`1<a> a);
    public static FSharpOption`1<Tuple`2<a, arr`1<a>>> viewr(arr`1<a> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static arr`1<a> prepend(a value, arr`1<a> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static arr`1<a> append(a value, arr`1<a> a);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.ASM : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231310_1Bytes@ field231326@;
    [CompilationMappingAttribute]
public static OperatingSystem os { get; }
    [CompilationMappingAttribute]
public static Architecture cpu { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<int, FSharpFunc`2<int, Byte[]>> functionProlog { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<int, Byte[]> specific@610 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<int, FSharpFunc`2<int, Byte[]>> functionEpilog { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<int, Byte[]> specific@636-7 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<int, FSharpFunc`2<IEnumerable`1<Tuple`2<IntPtr, Object[]>>, Byte[]>> compileCallsNative { get; }
    [CompilationMappingAttribute]
public static int jumpSize { get; }
    [CompilationMappingAttribute]
public static int jumpArgumentOffset { get; }
    [CompilationMappingAttribute]
public static int jumpArgumentAlign { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Byte[], Tuple`2[]> disassemble { get; }
    [CompilationMappingAttribute]
public static int encodedJumpSize { get; }
    private static ASM();
    public static OperatingSystem get_os();
    public static FSharpChoice`3<Unit, Unit, Unit> |Windows|Linux|Mac|(OperatingSystem p);
    internal static Architecture getLinuxCpuArchitecture();
    public static Architecture get_cpu();
    public static FSharpFunc`2<int, FSharpFunc`2<int, Byte[]>> get_functionProlog();
    internal static FSharpFunc`2<int, Byte[]> get_specific@610();
    public static FSharpFunc`2<int, FSharpFunc`2<int, Byte[]>> get_functionEpilog();
    internal static FSharpFunc`2<int, Byte[]> get_specific@636-7();
    internal static FSharpFunc`2<int, FSharpFunc`2<IEnumerable`1<Tuple`2<IntPtr, Object[]>>, Byte[]>> get_compileCallsNative();
    public static int get_jumpSize();
    public static int get_jumpArgumentOffset();
    public static int get_jumpArgumentAlign();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] assembleJump(int nopBytes, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] assembleCalls(int dynamicArguments, a calls);
    public static FSharpFunc`2<Byte[], Tuple`2[]> get_disassemble();
    public static int get_encodedJumpSize();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Assembler : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231295@;
    [DebuggerBrowsableAttribute("0")]
internal static T231249_1Bytes@ field231296@;
    [CompilationMappingAttribute]
public static OperatingSystem os { get; }
    [CompilationMappingAttribute]
public static Architecture cpu { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<int, Byte[]> functionProlog { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<int, Byte[]> functionEpilog { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<int, FSharpFunc`2<long, ArrayWriter>> setArg64 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<int, FSharpFunc`2<int, ArrayWriter>> setArg32 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<int, FSharpFunc`2<float, ArrayWriter>> setArg32f { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<int, FSharpFunc`2<Tuple`2<IntPtr, Object[]>, Byte[]>> compileCall { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<IEnumerable`1<Tuple`2<IntPtr, Object[]>>, Byte[]> compileCallsInternal { get; }
    private static Assembler();
    public static OperatingSystem get_os();
    public static FSharpChoice`3<Unit, Unit, Unit> |Windows|Linux|Mac|(OperatingSystem p);
    internal static Architecture getLinuxCpuArchitecture();
    public static Architecture get_cpu();
    public static FSharpFunc`2<int, Byte[]> get_functionProlog();
    public static FSharpFunc`2<int, Byte[]> get_functionEpilog();
    public static FSharpFunc`2<int, FSharpFunc`2<long, ArrayWriter>> get_setArg64();
    public static FSharpFunc`2<int, FSharpFunc`2<int, ArrayWriter>> get_setArg32();
    public static FSharpFunc`2<int, FSharpFunc`2<float, ArrayWriter>> get_setArg32f();
    public static FSharpFunc`2<int, FSharpFunc`2<Tuple`2<IntPtr, Object[]>, Byte[]>> get_compileCall();
    internal static FSharpFunc`2<IEnumerable`1<Tuple`2<IntPtr, Object[]>>, Byte[]> get_compileCallsInternal();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] compileCalls(int padding, a calls);
}
[CompilationMappingAttribute]
public class Aardvark.Base.AverageWindow : object {
    internal int maxCount;
    internal Double[] values;
    internal int index;
    internal int count;
    internal double sum;
    public int Count { get; }
    public double Value { get; }
    public AverageWindow(int maxCount);
    public double Insert(double v);
    public int get_Count();
    public double get_Value();
    public void Reset();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.AVLModule : object {
    internal static FSharpChoice`2<Unit, a> |Nil|Node|(Node`1<a> n);
    internal static void rebalance(Node`1& n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ninsert'(FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp, Node`1& n, a value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ninsertNeighbourhood'(FSharpOption`1<a> prev, FSharpOption`1<a> next, FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp, Node`1& n, a value, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<FSharpOption`1<a>, Unit>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ninsertOrUpdateNeighbourhood'(FSharpOption`1<a> prev, FSharpOption`1<a> next, FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp, Node`1& n, a value, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<FSharpOption`1<a>, Unit>>> f);
    internal static FSharpOption`1<a> nextractLeftmost'(Node`1& n);
    internal static FSharpOption`1<a> nextractRightmost'(Node`1& n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool nremove'(Node`1& n, FSharpFunc`2<a, int> valueCmp);
    internal static IEnumerable`1<a> ntoSeq'(Node`1<a> n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> nextractMinimalWhere'(FSharpFunc`2<a, bool> condition, Node`1& n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> nfindMinimalWhere'(FSharpFunc`2<a, bool> condition, Node`1<a> n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> nfindMaximalWhere'(FSharpFunc`2<a, bool> condition, Node`1<a> n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> nextractMaximalWhere'(FSharpFunc`2<a, bool> condition, Node`1& n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> nfind'(FSharpFunc`2<a, int> cmp, Node`1<a> n);
    internal static void set@383(int h, Dictionary`2<int, FSharpOption`1[]> data, int x, int y, a v);
    internal static void dump@390(int h, Dictionary`2<int, FSharpOption`1[]> data, int l, int x, Node`1<a> n);
    internal static string padToLength@415(FSharpRef`1<int> maxLength, string s);
    internal static void nprint'(Node`1<a> n);
    public static Tree`1<a> custom(FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp);
    public static Tree`1<a> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool insert(Tree`1<a> t, a value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool insertNeighbourhood(Tree`1<a> t, a value, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<FSharpOption`1<a>, Unit>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool insertOrUpdateNeighbourhood(Tree`1<a> t, a value, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<FSharpOption`1<a>, Unit>>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void insert'(Tree`1<a> t, a value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(Tree`1<a> t, a value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void remove'(Tree`1<a> t, a value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool removeCmp(Tree`1<a> t, FSharpFunc`2<a, int> cmpValue);
    public static IEnumerable`1<a> toSeq(Tree`1<a> t);
    public static FSharpList`1<a> toList(Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> extractMinimalWhere(FSharpFunc`2<a, bool> condition, Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> extractMaximalWhere(FSharpFunc`2<a, bool> condition, Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> findMinimalWhere(FSharpFunc`2<a, bool> condition, Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> findMaximalWhere(FSharpFunc`2<a, bool> condition, Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> find(FSharpFunc`2<a, int> cmp, Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> get(a element, Tree`1<a> tree);
    public static void print(Tree`1<a> t);
    internal static void checkCorrectness@566(List`1<int> used, Tree`1<int> tree, Unit unitVar0);
    internal static void checkCompleteness@572(List`1<int> used, Tree`1<int> tree, Unit unitVar0);
    internal static void checkSorting@578(Tree`1<int> tree, Unit unitVar0);
    internal static int h@593(Node`1<int> n);
    internal static bool balanceAndHeightValid@601(Node`1<int> n);
    internal static void checkBalanceAndHeightCaches@592(Tree`1<int> tree, Unit unitVar0);
    internal static void checkFind@617(List`1<int> elements, List`1<int> used, Tree`1<int> tree, Unit unitVar0);
    public static void runTests();
    public static void test();
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
internal class Aardvark.Base.Block : object {
    internal MemoryManager Parent;
    internal IntPtr Offset;
    internal IntPtr Size;
    internal Block Prev;
    internal Block Next;
    internal bool Free;
    internal static Block Invalid { get; }
    public Block(MemoryManager parent, IntPtr o, IntPtr s, Block p, Block n, bool f);
    public virtual string ToString();
    internal static Block get_Invalid();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.BucketAVL : object {
    public static BucketTree`1<a> custom(FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool insert(BucketTree`1<a> t, a value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool insertNeighbourhood(BucketTree`1<a> t, a value, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<FSharpOption`1<a>, Unit>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(BucketTree`1<a> t, a value);
    public static IEnumerable`1<a> toSeq(BucketTree`1<a> t);
    public static FSharpList`1<a> toList(BucketTree`1<a> t);
    public static a[] toArray(BucketTree`1<a> t);
    public static void runTests();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Caches : object {
}
[AttributeUsageAttribute("64")]
[CompilationMappingAttribute]
public class Aardvark.Base.CacheSynthesizedAttribute : Attribute {
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Cancellable : object {
    [CompilationMappingAttribute]
public static CancelBuilder cancel { get; }
    public static void throwAndRollback(CancelState s);
    public static CancelBuilder get_cancel();
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public class Aardvark.Base.CodeFragment : object {
    internal managedptr memory@713;
    internal bool containsJmp@714;
    internal List`1<int> startOffsets;
    public Tuple`2[] Calls { get; }
    public IntPtr Offset { get; }
    public managedptr Memory { get; public set; }
    public bool ContainsJmp { get; }
    public CodeFragment(managedptr memory, bool containsJmp);
    public CodeFragment(MemoryManager manager, Byte[] content);
    public CodeFragment(MemoryManager manager, Tuple`2[] calls);
    public CodeFragment(MemoryManager manager);
    public Tuple`2[] get_Calls();
    public IntPtr get_Offset();
    public managedptr get_Memory();
    public void set_Memory(managedptr m);
    public bool get_ContainsJmp();
    public int WriteNextPointer(IntPtr target);
    public IntPtr ReadNextPointer();
    public void Write(Tuple`2[] calls);
    public void Write(Byte[] binary);
    public int Append(Byte[] data);
    public void Update(int id, Byte[] data);
    public void Remove(int id);
    public void Clear();
    public void Dispose();
    [CompilerGeneratedAttribute]
internal void resetStartOffsets();
    [CompilerGeneratedAttribute]
internal int nonAlignedJumpOffset();
    [CompilerGeneratedAttribute]
internal int alignedJumpArgumentOffset();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.CodeFragmentModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CodeFragment prolog(int maxArgs, MemoryManager m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CodeFragment epilog(int maxArgs, MemoryManager m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CodeFragment ofCalls(IEnumerable`1<Tuple`2<IntPtr, Object[]>> calls, MemoryManager m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void update(IEnumerable`1<Tuple`2<IntPtr, Object[]>> calls, CodeFragment f);
    public static void destroy(CodeFragment f);
    public static IntPtr offset(CodeFragment f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a usePointer(CodeFragment f, FSharpFunc`2<IntPtr, a> func);
    public static FSharpFunc`2<Unit, Unit> wrap(CodeFragment f);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.ColorBrewer : object {
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.ColorBrewerSchemes : object {
}
[CompilationMappingAttribute]
public class Aardvark.Base.ConcurrentHashQueue`1 : object {
    internal object lockObj;
    internal Dict`2<a, HashQueueNode`1<a>> nodes;
    internal HashQueueNode`1<a> first;
    internal HashQueueNode`1<a> last;
    public int Count { get; }
    public int get_Count();
    public bool Enqueue(a value);
    public a Dequeue();
    public bool TryDequeue(a& result);
    public bool Remove(a value);
    public void Clear();
    [CompilerGeneratedAttribute]
internal void detach(HashQueueNode`1<a> node);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.ConcurrentHashQueueModule : object {
    public static ConcurrentHashQueue`1<a> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool enqueue(a v, ConcurrentHashQueue`1<a> q);
    public static FSharpOption`1<a> tryDequeue(ConcurrentHashQueue`1<a> q);
    public static a dequeue(ConcurrentHashQueue`1<a> q);
    public static int count(ConcurrentHashQueue`1<a> q);
    public static void clear(ConcurrentHashQueue`1<a> q);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.ConversionHelpers : object {
    [ObsoleteAttribute("Use Enum.convert instead.")]
public static b convertEnum(a fmt);
    [ObsoleteAttribute("Use Enum.convert instead.")]
public static b convertEnum$W(FSharpFunc`2<a, int> op_Explicit, a fmt);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Converters : object {
    internal static b conv(a a);
    internal static b conv$W(FSharpFunc`2<a, b> op_Explicit, a a);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.CSharpCollectionExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Value> Dictionary`2.TryFind(Dictionary`2<Key, Value> x, Key key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpValueOption`1<Value> Dictionary`2.TryFindV(Dictionary`2<Key, Value> x, Key key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Value> Dict`2.TryFind(Dict`2<Key, Value> x, Key key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpValueOption`1<Value> Dict`2.TryFindV(Dict`2<Key, Value> x, Key key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Value> SymbolDict`1.TryFind(SymbolDict`1<Value> x, Symbol key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpValueOption`1<Value> SymbolDict`1.TryFindV(SymbolDict`1<Value> x, Symbol key);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.CSharpInterop : object {
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.CSharpListModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void add(a v, List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void addRange(IEnumerable`1<a> elements, List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void removeAt(int index, List`1<a> l);
    public static void clear(List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void insert(int index, a value, List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static List`1<b> map(FSharpFunc`2<a, b> f, List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static List`1<b> collect(FSharpFunc`2<a, IEnumerable`1<b>> f, List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static List`1<b> choose(FSharpFunc`2<a, FSharpOption`1<b>> f, List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static List`1<a> filter(FSharpFunc`2<a, bool> f, List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static List`1<a> append(List`1<a> l, List`1<a> r);
    public static List`1<a> concat(IEnumerable`1<List`1<a>> l);
    public static int count(List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void iter(FSharpFunc`2<a, Unit> f, List`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void iteri(FSharpFunc`2<int, FSharpFunc`2<a, Unit>> f, List`1<a> l);
    public static List`1<a> empty();
    public static List`1<a> ofSeq(IEnumerable`1<a> elements);
    public static List`1<a> ofList(FSharpList`1<a> elements);
    public static List`1<a> ofArray(a[] elements);
    public static FSharpList`1<a> toList(List`1<a> l);
    public static a[] toArray(List`1<a> l);
    public static IEnumerable`1<a> toSeq(List`1<a> l);
}
[CompilationMappingAttribute]
public class Aardvark.Base.CustomTaskScheduler : TaskScheduler {
    internal int threadCount;
    internal BlockingCollection`1<Task> workItems;
    internal Thread[] threads;
    internal bool isDisposed;
    internal int init@11;
    public int MaximumConcurrencyLevel { get; }
    public CustomTaskScheduler(int threadCount, ThreadPriority priority);
    public CustomTaskScheduler(int threadCount);
    public bool TryExecuteTask(Task t);
    public virtual void QueueTask(Task t);
    public virtual bool TryExecuteTaskInline(Task t, bool p);
    public virtual int get_MaximumConcurrencyLevel();
    public virtual IEnumerable`1<Task> GetScheduledTasks();
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.DelegateAdapters : object {
    public static Tuple`2<FSharpList`1<Type>, Type> getFunctionSignature(Type t);
    public static object wrapUntyped(Delegate d);
    public static a wrap(Delegate d);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.DependentHandle : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DependentHandle`2<a, b> makeDependent(a a, b b);
    public static void test();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.DerivedOrder : object {
    [CompilationMappingAttribute]
internal static Random random { get; }
    internal static Random get_random();
    public static int randomHeight();
    internal static ulong distance@570-2(SortKey`1<a> a, SortKey`1<a> b);
    internal static void resize@611-1(Order`1<a> x, int h);
    internal static Tuple`2<int, SortKey`1<a>> back@618-2(SortKey`1<a> n);
    internal static Tuple`2<int, SortKeyLink`1[]> findPrevAcc@669(Order`1<a> x, SortKeyLink`1[] acc, int index, int level, a v, SortKey`1<a> n);
    internal static Tuple`2<int, SortKey`1<a>> back@719-3(SortKey`1<a> n);
    internal static FSharpOption`1<SortKey`1<a>> search@763-2(int index, int level, SortKey`1<a> t);
    public static Order`1<a> create(IComparer`1<a> cmp);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.DictionaryModule : object {
    public static Dictionary`2<k, v> empty();
    public static Dictionary`2<k, v> emptyNoEquality();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void add(k key, v value, Dictionary`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void set(k key, v value, Dictionary`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(k key, Dictionary`2<k, v> d);
    public static void clear(Dictionary`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Dictionary`2<k, b> map(FSharpFunc`2<k, FSharpFunc`2<a, b>> f, Dictionary`2<k, a> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Dictionary`2<b, a> mapKeys(FSharpFunc`2<k, FSharpFunc`2<a, b>> f, Dictionary`2<k, a> d);
    public static Dictionary`2<k, v> union(a dicts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(k key, Dictionary`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<v> tryFind(k key, Dictionary`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpValueOption`1<v> tryFindV(k key, Dictionary`2<k, v> d);
    public static Dictionary`2<k, v> ofSeq(IEnumerable`1<Tuple`2<k, v>> elements);
    public static Dictionary`2<k, v> ofSeqV(IEnumerable`1<ValueTuple`2<k, v>> elements);
    public static Dictionary`2<k, v> ofList(FSharpList`1<Tuple`2<k, v>> elements);
    public static Dictionary`2<k, v> ofListV(FSharpList`1<ValueTuple`2<k, v>> elements);
    public static Dictionary`2<k, v> ofArray(Tuple`2[] elements);
    public static Dictionary`2<k, v> ofArrayV(ValueTuple`2[] elements);
    public static Dictionary`2<k, v> ofMap(FSharpMap`2<k, v> elements);
    public static IEnumerable`1<Tuple`2<k, v>> toSeq(Dictionary`2<k, v> d);
    public static IEnumerable`1<ValueTuple`2<k, v>> toSeqV(Dictionary`2<k, v> d);
    public static FSharpList`1<Tuple`2<k, v>> toList(Dictionary`2<k, v> d);
    public static FSharpList`1<ValueTuple`2<k, v>> toListV(Dictionary`2<k, v> d);
    public static Tuple`2[] toArray(Dictionary`2<k, v> d);
    public static ValueTuple`2[] toArrayV(Dictionary`2<k, v> d);
    public static FSharpMap`2<k, v> toMap(Dictionary`2<k, v> d);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.DictModule : object {
    public static Dict`2<k, v> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void add(k key, v value, Dict`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void set(k key, v value, Dict`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(k key, Dict`2<k, v> d);
    public static void clear(Dict`2<k, v> d);
    public static IEnumerable`1<k> keys(Dict`2<k, v> k);
    public static IEnumerable`1<v> values(Dict`2<k, v> k);
    public static IEnumerable`1<KeyValuePair`2<k, v>> keyValues(Dict`2<k, v> k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Dict`2<k, b> map(FSharpFunc`2<k, FSharpFunc`2<a, b>> f, Dict`2<k, a> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Dict`2<b, a> mapKeys(FSharpFunc`2<k, FSharpFunc`2<a, b>> f, Dict`2<k, a> d);
    public static Dict`2<k, v> union(a dicts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(k key, Dict`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<v> tryFind(k key, Dict`2<k, v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpValueOption`1<v> tryFindV(k key, Dict`2<k, v> d);
    public static Dict`2<k, v> ofSeq(IEnumerable`1<Tuple`2<k, v>> elements);
    public static Dict`2<k, v> ofSeqV(IEnumerable`1<ValueTuple`2<k, v>> elements);
    public static Dict`2<k, v> ofList(FSharpList`1<Tuple`2<k, v>> elements);
    public static Dict`2<k, v> ofListV(FSharpList`1<ValueTuple`2<k, v>> elements);
    public static Dict`2<k, v> ofArray(Tuple`2[] elements);
    public static Dict`2<k, v> ofArrayV(ValueTuple`2[] elements);
    public static Dict`2<k, v> ofMap(FSharpMap`2<k, v> elements);
    public static IEnumerable`1<Tuple`2<k, v>> toSeq(Dict`2<k, v> d);
    public static IEnumerable`1<ValueTuple`2<k, v>> toSeqV(Dict`2<k, v> d);
    public static FSharpList`1<Tuple`2<k, v>> toList(Dict`2<k, v> d);
    public static FSharpList`1<ValueTuple`2<k, v>> toListV(Dict`2<k, v> d);
    public static Tuple`2[] toArray(Dict`2<k, v> d);
    public static ValueTuple`2[] toArrayV(Dict`2<k, v> d);
    public static FSharpMap`2<k, v> toMap(Dict`2<k, v> d);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.DynamicLinker : object {
    [CompilationMappingAttribute]
internal static OperatingSystem os { get; }
    [CompilationMappingAttribute]
internal static IDynamicLinker linker { get; }
    internal static OperatingSystem get_os();
    public static a notimp();
    internal static IDynamicLinker get_linker();
    public static FSharpOption`1<Library> tryLoadLibrary(string name);
    public static Library loadLibrary(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Function> tryLoadFunction(string name, Library lib);
    [CompilerGeneratedAttribute]
internal static bool tryUnpackNativeLibrary$cont@120(FSharpList`1<ZipArchiveEntry> entries, Unit unitVar);
    public static bool tryUnpackNativeLibrary(string name);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.DynamicLinkerTypes : object {
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.EnumExtensions : object {
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.FileModule : object {
    public static void createParentDirectory(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeAllLines(string path, String[] lines);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeAllLinesSafe(string path, String[] lines);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeAllText(string path, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeAllTextSafe(string path, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeAllBytes(string path, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeAllBytesSafe(string path, Byte[] bytes);
    public static String[] readAllLines(string path);
    public static string readAllText(string path);
    public static Byte[] readAllBytes(string path);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.FingerTreeBenchmarks : object {
    public static double testPerf(FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runTest(string filename, FSharpFunc`2<int, a> create, FSharpFunc`2<int, FSharpFunc`2<a, b>> op, FSharpList`1<int> sizes);
    public static void run();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.FingerTreeImplementation : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@39(Affix`1<a> this, Affix`1<a> obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@39-1(IComparer comp, Affix`1<a> this, Affix`1<a> objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@39(IEqualityComparer comp, Affix`1<a> this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@39(Affix`1<a> this, Affix`1<a> obj, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@39-1(Affix`1<a> this, Affix`1<a> obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-2(Node`2<a, m> this, Node`2<a, m> obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-3(IComparer comp, Node`2<a, m> this, Node`2<a, m> objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@45-1(IEqualityComparer comp, Node`2<a, m> this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-2(Node`2<a, m> this, Node`2<a, m> obj, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-3(Node`2<a, m> this, Node`2<a, m> obj, Unit unitVar);
}
[CompilationMappingAttribute]
public class Aardvark.Base.FreeList`2 : object {
    internal static IComparer`1<Tuple`2<k, HashSet`1<v>>> comparer;
    internal SortedSetExt`1<Tuple`2<k, HashSet`1<v>>> sortedSet;
    internal Dictionary`2<k, HashSet`1<v>> sets;
    internal static int init@13;
    public IEnumerable`1<v> Values { get; }
    private static FreeList`2();
    public IEnumerable`1<v> get_Values();
    public FSharpOption`1<v> TryGetGreaterOrEqual(k minimal);
    public void Insert(k key, v value);
    public bool Remove(k key, v value);
    public bool Contains(k key, v value);
    public void Clear();
    [CompilerGeneratedAttribute]
internal FSharpOption`1<v> tryGet(k minimal);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void insert(k k, v v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal bool remove(k k, v v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal bool contains(k k, v v);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.FSharpMath : object {
    [GeneralizableValueAttribute]
public static T zero();
    [GeneralizableValueAttribute]
public static T zero$W(FSharpFunc`2<Unit, T> get_Zero);
    [GeneralizableValueAttribute]
public static T one();
    [GeneralizableValueAttribute]
public static T one$W(FSharpFunc`2<Unit, T> get_One);
    public static a signum(a x);
    public static a signum$W(FSharpFunc`2<a, a> signum, a x);
    public static b signumi(a x);
    public static b signumi$W(FSharpFunc`2<a, b> signumi, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a pow(a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a pow$W(FSharpFunc`2<a, FSharpFunc`2<b, a>> power, a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a op_Exponentiation(a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a op_Exponentiation$W(FSharpFunc`2<a, FSharpFunc`2<b, a>> power, a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a pown(a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a pown$W(FSharpFunc`2<a, FSharpFunc`2<b, a>> pown, a x, b y);
    public static a exp2(a x);
    public static a exp2$W(FSharpFunc`2<a, a> powerOfTwo, a x);
    public static a log2(a x);
    public static a log2$W(FSharpFunc`2<a, a> logBinary, a x);
    public static b log2int(a x);
    public static b log2int$W(FSharpFunc`2<a, b> log2Int, a x);
    public static a asinh(a x);
    public static a asinh$W(FSharpFunc`2<a, a> asinhb, a x);
    public static a acosh(a x);
    public static a acosh$W(FSharpFunc`2<a, a> acoshb, a x);
    public static a atanh(a x);
    public static a atanh$W(FSharpFunc`2<a, a> atanhb, a x);
    public static b sqr(a x);
    public static b sqr$W(FSharpFunc`2<a, FSharpFunc`2<a, b>> op_Multiply, a x);
    public static a cbrt(a x);
    public static a cbrt$W(FSharpFunc`2<a, a> cubeRoot, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b min(a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b min$W(FSharpFunc`2<a, FSharpFunc`2<b, b>> min, a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b max(a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b max$W(FSharpFunc`2<a, FSharpFunc`2<b, b>> max, a x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b clamp(a a, c b, b x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b clamp$W(FSharpFunc`2<a, FSharpFunc`2<b, b>> max, FSharpFunc`2<c, FSharpFunc`2<b, b>> min, a a, c b, b x);
    public static T saturate(T x);
    public static T saturate$W(FSharpFunc`2<T, T> saturate, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a lerp(a x, a y, b t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a lerp$W(FSharpFunc`2<b, FSharpFunc`2<a, FSharpFunc`2<a, a>>> linearInterp, a x, a y, b t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b invLerp(a a, a b, a y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b invLerp$W(FSharpFunc`2<a, FSharpFunc`2<a, FSharpFunc`2<a, b>>> invLerp, a a, a b, a y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static U step(T edge, U x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static U step$W(FSharpFunc`2<U, FSharpFunc`2<T, U>> step, T edge, U x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static U linearstep(T edge0, T edge1, U x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static U linearstep$W(FSharpFunc`2<U, FSharpFunc`2<T, FSharpFunc`2<T, U>>> linearstep, T edge0, T edge1, U x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static U smoothstep(T edge0, T edge1, U x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static U smoothstep$W(FSharpFunc`2<U, FSharpFunc`2<T, FSharpFunc`2<T, U>>> smoothstep, T edge0, T edge1, U x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T copysign(T value, U sign);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T copysign$W(FSharpFunc`2<T, FSharpFunc`2<U, T>> copySgn, T value, U sign);
    public static T degrees(T radians);
    public static T degrees$W(FSharpFunc`2<T, T> degreesFromRadians, T radians);
    public static T radians(T degrees);
    public static T radians$W(FSharpFunc`2<T, T> radiansFromDegrees, T degrees);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T madd(T x, U y, T z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T madd$W(FSharpFunc`2<T, FSharpFunc`2<U, FSharpFunc`2<T, T>>> multiplyAdd, T x, U y, T z);
    public static bool isNaN(T x);
    public static bool isNaN$W(FSharpFunc`2<T, bool> isNaN, T x);
    public static bool isInfinity(T x);
    public static bool isInfinity$W(FSharpFunc`2<T, bool> isInfinity, T x);
    public static bool isPositiveInfinity(T x);
    public static bool isPositiveInfinity$W(FSharpFunc`2<T, bool> isPositiveInfinity, T x);
    public static bool isNegativeInfinity(T x);
    public static bool isNegativeInfinity$W(FSharpFunc`2<T, bool> isNegativeInfinity, T x);
    public static bool isFinite(T x);
    public static bool isFinite$W(FSharpFunc`2<T, bool> isInfinity, FSharpFunc`2<T, bool> isNaN, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool approximateEquals(a epsilon, b x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool approximateEquals$W(FSharpFunc`2<b, FSharpFunc`2<b, FSharpFunc`2<a, bool>>> approximateEquals, a epsilon, b x, b y);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.FunctionReflection : object {
    internal static IEnumerable`1<Type> sequentializeTupleType(Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expression tupleGet(ParameterExpression p, int i);
    internal static Tuple`2<FSharpList`1<Type>, Type> getMethodSignatureInternal(Type t);
    public static Tuple`2<FSharpList`1<Type>, Type> getMethodSignature(Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LambdaExpression buildLambda(FSharpList`1<ParameterExpression> args, FSharpList`1<Expression> callArgs, object target, FSharpList`1<Type> argTypes, MethodInfo mi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a buildLambdaExpression(object target, MethodInfo mi, Type funType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a buildFunctionInternal(object target, FSharpList`1<Type> argTypes, MethodInfo mi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a buildFunction(object target, MethodInfo mi);
    [DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, FSharpFunc`2<Object[], object>> makeNAryFunctionInternal(Type t, int count, FSharpFunc`2<Object[], object> f);
    [DebuggerStepThroughAttribute]
public static x makeNAryFunction(FSharpFunc`2<Object[], object> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static r makeFormatFunction(FSharpFunc`2<string, FSharpFunc`2<Object[], object>> f, PrintfFormat`4<r, StringBuilder, Unit, object> fmt);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.GenericValues : object {
    [ObsoleteAttribute("Use LanguagePrimitives.GenericZero instead.")]
public static a zero();
    [ObsoleteAttribute("Use LanguagePrimitives.GenericZero instead.")]
public static a zero$W(FSharpFunc`2<a, FSharpFunc`2<a, a>> op_Subtraction);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Aardvark.Base.Geometry.BvhNode : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeaf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNode { get; }
    [CompilationMappingAttribute]
public static BvhNode NewLeaf(int _id);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeaf();
    [CompilationMappingAttribute]
public static BvhNode NewNode(Box3d _lBox, Box3d _rBox, BvhNode _left, BvhNode _right);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(BvhNode obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BvhNode obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Geometry.BvhNodeModule : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static double splitPenalty;
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static double cost(Box3d lBox, Box3d rBox, double lWeight, double rWeight, double invBoxArea);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static BvhSplit calculateSplit(Int32[] indexArray, int start, int count, Box3d box, Box3d[] boxes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static BvhNode build(Box3d[] boxes, Int32[] indices, int start, int count, Box3d box);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<RayHit`1<r>> intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, a[] data, RayPart part, BvhNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<RayHit`1<r>> intersections(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, a[] data, RayPart part, BvhNode node);
    internal static void cullAcc@239(FastHull3d hull, List`1<int> res, BvhNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<int> cull(FastHull3d hull, BvhNode node);
}
[CompilationMappingAttribute]
public class Aardvark.Base.Geometry.BvhTree`1 : object {
    internal FSharpOption`1<BvhNode> root;
    internal a[] data;
    internal Box3d bounds;
    public a[] Data { get; }
    public FSharpOption`1<BvhNode> Root { get; }
    public Box3d Bounds { get; }
    public BvhTree`1(a[] data, Box3d bounds, FSharpOption`1<BvhNode> root);
    public BvhTree`1(Tuple`2[] data);
    public BvhTree`1(FSharpFunc`2<a, Box3d> getBounds, a[] data);
    public a[] get_Data();
    public FSharpOption`1<BvhNode> get_Root();
    public Box3d get_Bounds();
    public FSharpOption`1<RayHit`1<r>> Intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, RayPart part);
    public IEnumerable`1<RayHit`1<r>> Intersections(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, RayPart part);
    public FSharpList`1<a> Cull(FastHull3d hull);
    private virtual override FSharpOption`1<RayHit`1<a>> Aardvark.Base.Geometry.IRayIntersectable<'a>.Intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<a>>>> tryIntersect, RayPart ray);
    private virtual override FSharpList`1<a> Aardvark.Base.Geometry.ICullable<'a>.Cull(FastHull3d hull);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Geometry.BvhTreeModule : object {
    public static BvhTree`1<a> ofArray(Tuple`2[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static BvhTree`1<a> create(FSharpFunc`2<a, Box3d> bounds, a[] data);
    public static a[] data(BvhTree`1<a> tree);
    public static FSharpOption`1<BvhNode> root(BvhTree`1<a> tree);
    public static Box3d bounds(BvhTree`1<a> tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<RayHit`1<r>> intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, RayPart part, BvhTree`1<a> tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<a> cull(FastHull3d hull, BvhTree`1<a> tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<a> cullFrustum(Trafo3d viewProj, BvhTree`1<a> tree);
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Geometry.GeometryExtensions : object {
    private static GeometryExtensions();
    [ExtensionAttribute]
public static FSharpOption`1<RayHit`1<a>> Intersect(IRayIntersectable`1<a> this, RayPart part);
    [ExtensionAttribute]
public static FSharpOption`1<RayHit`1<a>> Intersect$W(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<double>>> intersects, IRayIntersectable`1<a> this, RayPart part);
    [ExtensionAttribute]
public static FSharpList`1<a> CullFrustum(ICullable`1<a> this, Trafo3d viewProj);
    [CompilerGeneratedAttribute]
internal static Plane3d toPlane(V4d v);
    [CompilerGeneratedAttribute]
internal static Hull3d toHull3d(Trafo3d viewProj);
}
[CompilationMappingAttribute]
public interface Aardvark.Base.Geometry.ICullable`1 {
    public abstract virtual FSharpList`1<a> Cull(FastHull3d hull);
}
[CompilationMappingAttribute]
public interface Aardvark.Base.Geometry.IRayIntersectable`1 {
    public abstract virtual FSharpOption`1<RayHit`1<r>> Intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, RayPart part);
}
[CompilationMappingAttribute]
public class Aardvark.Base.Geometry.KdBuildInfo : ValueType {
    public int MaxCount;
    public int Splits;
    public static KdBuildInfo Default { get; }
    public static KdBuildInfo High { get; }
    public KdBuildInfo(int cnt, int splits);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(KdBuildInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(KdBuildInfo obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static KdBuildInfo get_Default();
    public static KdBuildInfo get_High();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(KdBuildInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Aardvark.Base.Geometry.KdNode : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static KdNode _unique_Empty;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static KdNode Empty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeaf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNode { get; }
    private static KdNode();
    [CompilationMappingAttribute]
public static KdNode get_Empty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEmpty();
    [CompilationMappingAttribute]
public static KdNode NewLeaf(Int32[] item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeaf();
    [CompilationMappingAttribute]
public static KdNode NewNode(Plane3d item1, KdNode item2, KdNode item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(KdNode obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(KdNode obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Geometry.KdNodeModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> count(Spatial`1<a> spatial, Plane3d plane, Int32[] indices, a[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static double cost(Box3d parent, Box3d lBox, Box3d rBox, int left, int both, int right);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static KdNode build(Spatial`1<a> spatial, KdBuildInfo info, a[] data, Box3d bounds, Int32[] indices);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<RayHit`1<r>> intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, a[] data, RayPart part, KdNode node);
}
[CompilationMappingAttribute]
public class Aardvark.Base.Geometry.KdTree`1 : object {
    internal KdNode root;
    internal a[] data;
    internal Box3d bounds;
    public Box3d Bounds { get; }
    public a[] Data { get; }
    public KdNode Root { get; }
    public KdTree`1(a[] data, KdNode root, Box3d bounds);
    public KdTree`1(Spatial`1<a> spatial, KdBuildInfo info, a[] data);
    public KdTree`1(Spatial`1<a> spatial, a[] data);
    public Box3d get_Bounds();
    public a[] get_Data();
    public KdNode get_Root();
    public FSharpOption`1<RayHit`1<r>> Intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, RayPart ray);
    private virtual override FSharpOption`1<RayHit`1<a>> Aardvark.Base.Geometry.IRayIntersectable<'a>.Intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<a>>>> tryIntersect, RayPart ray);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Geometry.KdTreeModule : object {
    public static Box3d bounds(KdTree`1<a> tree);
    public static KdNode root(KdTree`1<a> tree);
    public static a[] data(KdTree`1<a> tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static KdTree`1<a> build(Spatial`1<a> spatial, KdBuildInfo info, a[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<RayHit`1<r>> intersect(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<RayHit`1<r>>>> tryIntersect, RayPart ray, KdTree`1<a> tree);
}
[FlagsAttribute]
[CompilationMappingAttribute]
public enum Aardvark.Base.Geometry.PlaneSide : Enum {
    public int value__;
    public static PlaneSide None;
    public static PlaneSide Above;
    public static PlaneSide Below;
    public static PlaneSide Both;
}
[CompilationMappingAttribute]
public class Aardvark.Base.Geometry.RayHit`1 : ValueType {
    public double T;
    public r Value;
    public RayHit`1(double t, r value);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(RayHit`1<r> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(RayHit`1<r> obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RayHit`1<r> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Geometry.RayHitModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RayHit`1<r> create(double t, r value);
    public static double t(RayHit`1<r> hit);
    public static r value(RayHit`1<r> hit);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RayHit`1<b> map(FSharpFunc`2<a, b> f, RayHit`1<a> hit);
}
[ExtensionAttribute]
[CompilationMappingAttribute]
public class Aardvark.Base.Geometry.RayPart : ValueType {
    public FastRay3d Ray;
    public double TMin;
    public double TMax;
    public RayPart(FastRay3d ray, double min, double max);
    public RayPart(FastRay3d ray);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(RayPart obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [ExtensionAttribute]
public static FSharpOption`1<double> Intersects(RayPart x, Triangle3d tri);
    [ExtensionAttribute]
public static FSharpOption`1<double> Intersects(RayPart x, Box3d box);
    [ExtensionAttribute]
public static FSharpOption`1<double> Intersects(RayPart x, Sphere3d sphere);
    [ExtensionAttribute]
public static FSharpOption`1<double> Intersects(RayPart x, Cylinder3d cylinder);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RayPart obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Geometry.RayPartModule : object {
    public static FastRay3d ray(RayPart part);
    public static double tmin(RayPart part);
    public static double tmax(RayPart part);
    public static RayPart ofRay(FastRay3d ray);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RayPart create(FastRay3d ray, double tmin, double tmax);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<double> intersect(RayPart part, a a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<double> intersect$W(FSharpFunc`2<RayPart, FSharpFunc`2<a, FSharpOption`1<double>>> intersects, RayPart part, a a);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Geometry.Spatial : object {
    [CompilationMappingAttribute]
public static Spatial`1<Triangle3d> triangle { get; }
    [CompilationMappingAttribute]
public static Spatial`1<Box3d> box { get; }
    [CompilationMappingAttribute]
public static Spatial`1<V3d> point { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PlaneSide side(V3d pt, Plane3d plane);
    public static Spatial`1<Triangle3d> get_triangle();
    public static Spatial`1<Box3d> get_box();
    public static Spatial`1<V3d> get_point();
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class Aardvark.Base.Geometry.Spatial`1 : object {
    public abstract virtual Box3d ComputeBounds(IEnumerable`1<a> );
    public abstract virtual PlaneSide PlaneSide(Plane3d , a );
}
[CompilationMappingAttribute]
internal enum Aardvark.Base.HalfRangeKind : Enum {
    public int value__;
    public static HalfRangeKind Left;
    public static HalfRangeKind Right;
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
internal class Aardvark.Base.HashQueueNode`1 : object {
    internal a Value;
    internal HashQueueNode`1<a> Next;
    internal HashQueueNode`1<a> Prev;
    public HashQueueNode`1(a v, HashQueueNode`1<a> p, HashQueueNode`1<a> n);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.HashSetModule : object {
    public static HashSet`1<k> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool add(a k, HashSet`1<a> h);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(a a, HashSet`1<a> h);
    public static void clear(HashSet`1<a> h);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HashSet`1<b> map(FSharpFunc`2<a, b> f, HashSet`1<a> h);
    public static HashSet`1<a> union(a dicts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void unionWith(IEnumerable`1<a> xs, HashSet`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exceptWith(IEnumerable`1<a> xs, HashSet`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void intersectWith(IEnumerable`1<a> xs, HashSet`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(a v, HashSet`1<a> h);
    public static HashSet`1<a> ofSeq(IEnumerable`1<a> elements);
    public static HashSet`1<a> ofList(FSharpList`1<a> elements);
    public static HashSet`1<a> ofArray(a[] elements);
    public static IEnumerable`1<a> toSeq(HashSet`1<a> d);
    public static FSharpList`1<a> toList(HashSet`1<a> d);
    public static a[] toArray(HashSet`1<a> d);
    public static FSharpSet`1<a> toSet(HashSet`1<a> d);
}
[CompilationMappingAttribute]
internal static class Aardvark.Base.Helpers : object {
    [CompilationMappingAttribute]
internal static ResultBuilder result { get; }
    [CompilationMappingAttribute]
internal static Result`1<Unit> success { get; }
    internal static FSharpOption`1<Tuple`2<State, Unit>> run@46-10(FSharpFunc`2<a, Result`1<Unit>> f, IEnumerator`1<a> e, State s);
    internal static ResultBuilder get_result();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`1<Unit> assign(Type t, Type o);
    internal static Result`1<a> fail();
    internal static Result`1<Unit> get_success();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`1<Unit> tryInstantiateType(Type argType, Type realType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`1<Unit> tryInstantiateMethodInfo(MethodInfo mi, Type[] real);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethodInfo> tryInstantiate(MethodInfo mi, Type[] args);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public interface Aardvark.Base.IDeletableComparable {
    public bool IsDeleted { get; }
    public abstract virtual bool get_IsDeleted();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.Assembler : object {
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<State, Tuple`2<State, Unit>> assembleInstruction$cont@1341(ValueType vt, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<State, Tuple`2<State, Unit>> assembleInstruction$cont@1365-1(ValueType vt, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<State, Tuple`2<State, Unit>> assembleInstruction$cont@1399-2(Instruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<State, Tuple`2<State, Unit>> assembleInstruction$cont@1415-3(Instruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<State, Tuple`2<State, Unit>> assembleInstruction$cont@1433-4(Instruction i, Unit unitVar);
    internal static FSharpFunc`2<State, Tuple`2<State, Unit>> assembleInstruction(Instruction i);
    internal static FSharpFunc`2<State, Tuple`2<State, Unit>> assembleBody(IEnumerable`1<Instruction> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void assembleTo(ILGenerator il, IEnumerable`1<Instruction> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void assembleTo'(State state, IEnumerable`1<Instruction> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Delegate assembleDelegateInternal(Type tdel, FSharpList`1<Instruction> m);
    public static Delegate assembleDelegate(MethodDefinition m);
    public static a assembleDefinition(MethodDefinition m);
    public static a assemble(IEnumerable`1<Instruction> body);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.AssemblerTest : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231216_331Bytes@ field231217@;
    private static AssemblerTest();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static MethodInfo Type.GetInvokeMethod(Type );
    public static void listAdd();
    public static void testCustom();
    public static void testLambda();
    public static void testInject();
    public static void run();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Aardvark.Base.IL.Constant : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt16 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt16 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFloat64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFloat32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNativeInt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUNativeInt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsString { get; }
    [DynamicDependencyAttribute("2016", "Aardvark.Base.IL.Constant")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Constant(int _tag);
    [CompilationMappingAttribute]
public static Constant NewInt8(sbyte item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt8();
    [CompilationMappingAttribute]
public static Constant NewUInt8(byte item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt8();
    [CompilationMappingAttribute]
public static Constant NewInt16(short item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt16();
    [CompilationMappingAttribute]
public static Constant NewUInt16(ushort item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt16();
    [CompilationMappingAttribute]
public static Constant NewInt32(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt32();
    [CompilationMappingAttribute]
public static Constant NewUInt32(UInt32 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt32();
    [CompilationMappingAttribute]
public static Constant NewInt64(long item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt64();
    [CompilationMappingAttribute]
public static Constant NewUInt64(ulong item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt64();
    [CompilationMappingAttribute]
public static Constant NewFloat64(double item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFloat64();
    [CompilationMappingAttribute]
public static Constant NewFloat32(float item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFloat32();
    [CompilationMappingAttribute]
public static Constant NewNativeInt(IntPtr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNativeInt();
    [CompilationMappingAttribute]
public static Constant NewUNativeInt(UIntPtr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUNativeInt();
    [CompilationMappingAttribute]
public static Constant NewString(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Constant obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(Constant obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Constant obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.Disassembler : object {
    public static Tuple`3<FSharpMap`2<int, Parameter>, FSharpMap`2<int, Local>, Tuple`2[]> read(MethodBase m);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<ValueType> |LdIndirect|_|$cont@489(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<Type> |Ldelem|_|$cont@582-1(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<Type> |Ldelem|_|$cont@577(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<Type> |Stelem|_|$cont@600(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<ValueType> |Conv|_|$cont@682(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<ValueType> |ConvChecked|_|$cont@708-1(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<ValueType> |ConvChecked|_|$cont@697(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<Constant> |LdConst|_|$cont@752-1(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<Constant> |LdConst|_|$cont@744(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<Tuple`2<JumpCondition, int>> |ConditionalJump|_|$cont@792-1(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<Tuple`2<JumpCondition, int>> |ConditionalJump|_|$cont@786(RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Instruction> body$cont@920-7(FSharpMap`2<int, Label> branchTargetIds, RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Instruction> body$cont@920-6(FSharpMap`2<int, Label> branchTargetIds, RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Instruction> body$cont@920-5(FSharpMap`2<int, Label> branchTargetIds, RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Instruction> body$cont@920-4(FSharpMap`2<int, Label> branchTargetIds, RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Instruction> body$cont@920-3(FSharpMap`2<int, Label> branchTargetIds, RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Instruction> body$cont@920-2(FSharpMap`2<int, Label> branchTargetIds, RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Instruction> body$cont@920-1(FSharpMap`2<int, Label> branchTargetIds, RawInstruction i, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Instruction> body$cont@920(FSharpMap`2<int, Local> locals, FSharpMap`2<int, Label> branchTargetIds, RawInstruction i, Unit unitVar);
    public static MethodDefinition disassemble(MethodBase m);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.Frontend : object {
    [CompilationMappingAttribute]
public static CodeGenBuilder codegen { get; }
    [CompilationMappingAttribute]
public static ExecutableBuilder cil { get; }
    public static CodeGenBuilder get_codegen();
    public static ExecutableBuilder get_cil();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Aardvark.Base.IL.Instruction : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Start;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Nop;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Break;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Dup;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Pop;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Ldlen;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Add;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Sub;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Mul;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Div;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Rem;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_And;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Or;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Xor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Shl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Shr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Neg;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Not;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_CkFinite;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_LdNull;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_ReadOnly;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Tail;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_CallIndirect;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Ret;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_Throw;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Instruction _unique_EndFinally;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Start { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStart { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Nop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Break { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBreak { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Dup { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDup { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Pop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdarg { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdargA { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStarg { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdloc { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdlocA { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStloc { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdfld { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdfldA { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStfld { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdIndirect { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStIndirect { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCpObj { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdObj { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStObj { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNewObj { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInitObj { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCastClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIsInstance { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnbox { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnboxAny { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBox { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNewArr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Ldlen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdlen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdelem { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdelemA { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStelem { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Add { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAdd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Sub { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSub { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Mul { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMul { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Div { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDiv { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Rem { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRem { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction And { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Or { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Xor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Shl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsShl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Shr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsShr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Neg { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNeg { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Not { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConv { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConvChecked { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRefAnyVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction CkFinite { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCkFinite { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMkRefAny { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction LdNull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdNull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdConst { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLdToken { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWriteLine { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction ReadOnly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsReadOnly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Tail { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTail { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMark { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConditionalJump { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJump { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCall { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction CallIndirect { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCallIndirect { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Ret { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSwitch { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction Throw { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsThrow { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Instruction EndFinally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEndFinally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeave { get; }
    private static Instruction();
    [DynamicDependencyAttribute("2016", "Aardvark.Base.IL.Instruction")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Instruction(int _tag);
    [CompilationMappingAttribute]
public static Instruction get_Start();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStart();
    [CompilationMappingAttribute]
public static Instruction get_Nop();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNop();
    [CompilationMappingAttribute]
public static Instruction get_Break();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBreak();
    [CompilationMappingAttribute]
public static Instruction get_Dup();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDup();
    [CompilationMappingAttribute]
public static Instruction get_Pop();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPop();
    [CompilationMappingAttribute]
public static Instruction NewLdarg(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdarg();
    [CompilationMappingAttribute]
public static Instruction NewLdargA(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdargA();
    [CompilationMappingAttribute]
public static Instruction NewStarg(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStarg();
    [CompilationMappingAttribute]
public static Instruction NewLdloc(Local item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdloc();
    [CompilationMappingAttribute]
public static Instruction NewLdlocA(Local item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdlocA();
    [CompilationMappingAttribute]
public static Instruction NewStloc(Local item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStloc();
    [CompilationMappingAttribute]
public static Instruction NewLdfld(FieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdfld();
    [CompilationMappingAttribute]
public static Instruction NewLdfldA(FieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdfldA();
    [CompilationMappingAttribute]
public static Instruction NewStfld(FieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStfld();
    [CompilationMappingAttribute]
public static Instruction NewLdIndirect(ValueType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdIndirect();
    [CompilationMappingAttribute]
public static Instruction NewStIndirect(ValueType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStIndirect();
    [CompilationMappingAttribute]
public static Instruction NewCpObj(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCpObj();
    [CompilationMappingAttribute]
public static Instruction NewLdObj(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdObj();
    [CompilationMappingAttribute]
public static Instruction NewStObj(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStObj();
    [CompilationMappingAttribute]
public static Instruction NewNewObj(ConstructorInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNewObj();
    [CompilationMappingAttribute]
public static Instruction NewInitObj(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInitObj();
    [CompilationMappingAttribute]
public static Instruction NewCastClass(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCastClass();
    [CompilationMappingAttribute]
public static Instruction NewIsInstance(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIsInstance();
    [CompilationMappingAttribute]
public static Instruction NewUnbox(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnbox();
    [CompilationMappingAttribute]
public static Instruction NewUnboxAny(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnboxAny();
    [CompilationMappingAttribute]
public static Instruction NewBox(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBox();
    [CompilationMappingAttribute]
public static Instruction NewNewArr(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNewArr();
    [CompilationMappingAttribute]
public static Instruction get_Ldlen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdlen();
    [CompilationMappingAttribute]
public static Instruction NewLdelem(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdelem();
    [CompilationMappingAttribute]
public static Instruction NewLdelemA(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdelemA();
    [CompilationMappingAttribute]
public static Instruction NewStelem(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStelem();
    [CompilationMappingAttribute]
public static Instruction get_Add();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAdd();
    [CompilationMappingAttribute]
public static Instruction get_Sub();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSub();
    [CompilationMappingAttribute]
public static Instruction get_Mul();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMul();
    [CompilationMappingAttribute]
public static Instruction get_Div();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDiv();
    [CompilationMappingAttribute]
public static Instruction get_Rem();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRem();
    [CompilationMappingAttribute]
public static Instruction get_And();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnd();
    [CompilationMappingAttribute]
public static Instruction get_Or();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOr();
    [CompilationMappingAttribute]
public static Instruction get_Xor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXor();
    [CompilationMappingAttribute]
public static Instruction get_Shl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsShl();
    [CompilationMappingAttribute]
public static Instruction get_Shr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsShr();
    [CompilationMappingAttribute]
public static Instruction get_Neg();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNeg();
    [CompilationMappingAttribute]
public static Instruction get_Not();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNot();
    [CompilationMappingAttribute]
public static Instruction NewConv(ValueType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConv();
    [CompilationMappingAttribute]
public static Instruction NewConvChecked(ValueType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConvChecked();
    [CompilationMappingAttribute]
public static Instruction NewRefAnyVal(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRefAnyVal();
    [CompilationMappingAttribute]
public static Instruction get_CkFinite();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCkFinite();
    [CompilationMappingAttribute]
public static Instruction NewMkRefAny(Type item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMkRefAny();
    [CompilationMappingAttribute]
public static Instruction get_LdNull();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdNull();
    [CompilationMappingAttribute]
public static Instruction NewLdConst(Constant item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdConst();
    [CompilationMappingAttribute]
public static Instruction NewLdToken(object item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLdToken();
    [CompilationMappingAttribute]
public static Instruction NewWriteLine(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWriteLine();
    [CompilationMappingAttribute]
public static Instruction get_ReadOnly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsReadOnly();
    [CompilationMappingAttribute]
public static Instruction get_Tail();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTail();
    [CompilationMappingAttribute]
public static Instruction NewMark(Label item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMark();
    [CompilationMappingAttribute]
public static Instruction NewConditionalJump(JumpCondition item1, Label item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConditionalJump();
    [CompilationMappingAttribute]
public static Instruction NewJump(Label item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJump();
    [CompilationMappingAttribute]
public static Instruction NewCall(MethodBase item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCall();
    [CompilationMappingAttribute]
public static Instruction get_CallIndirect();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCallIndirect();
    [CompilationMappingAttribute]
public static Instruction get_Ret();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRet();
    [CompilationMappingAttribute]
public static Instruction NewSwitch(Label[] item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSwitch();
    [CompilationMappingAttribute]
public static Instruction get_Throw();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsThrow();
    [CompilationMappingAttribute]
public static Instruction get_EndFinally();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEndFinally();
    [CompilationMappingAttribute]
public static Instruction NewLeave(Label item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeave();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(Instruction obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Instruction obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Aardvark.Base.IL.JumpCondition : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static JumpCondition _unique_Less;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static JumpCondition _unique_LessOrEqual;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static JumpCondition _unique_Greater;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static JumpCondition _unique_GreaterOrEqual;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static JumpCondition _unique_Equal;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static JumpCondition _unique_NotEqual;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static JumpCondition _unique_False;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static JumpCondition _unique_True;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static JumpCondition Less { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static JumpCondition LessOrEqual { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLessOrEqual { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static JumpCondition Greater { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGreater { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static JumpCondition GreaterOrEqual { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGreaterOrEqual { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static JumpCondition Equal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEqual { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static JumpCondition NotEqual { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNotEqual { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static JumpCondition False { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFalse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static JumpCondition True { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTrue { get; }
    private static JumpCondition();
    [DynamicDependencyAttribute("2016", "Aardvark.Base.IL.JumpCondition")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal JumpCondition(int _tag);
    [CompilationMappingAttribute]
public static JumpCondition get_Less();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLess();
    [CompilationMappingAttribute]
public static JumpCondition get_LessOrEqual();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLessOrEqual();
    [CompilationMappingAttribute]
public static JumpCondition get_Greater();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGreater();
    [CompilationMappingAttribute]
public static JumpCondition get_GreaterOrEqual();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGreaterOrEqual();
    [CompilationMappingAttribute]
public static JumpCondition get_Equal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEqual();
    [CompilationMappingAttribute]
public static JumpCondition get_NotEqual();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNotEqual();
    [CompilationMappingAttribute]
public static JumpCondition get_False();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFalse();
    [CompilationMappingAttribute]
public static JumpCondition get_True();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTrue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(JumpCondition obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(JumpCondition obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(JumpCondition obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Aardvark.Base.IL.Label : object {
    internal int id;
    internal static int currentId;
    internal static int init@53;
    public int Id { get; }
    internal Label(int id);
    private static Label();
    public int get_Id();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    private virtual override int System.IComparable.CompareTo(object o);
}
[CompilationMappingAttribute]
public class Aardvark.Base.IL.Local : object {
    internal Type t;
    internal string name;
    internal int id;
    internal static int currentId;
    internal static int init@76-1;
    public int Id { get; }
    public string Name { get; }
    public Type Type { get; }
    internal Local(int id, string name, Type t);
    public Local(string name, Type t);
    public Local(Type t);
    private static Local();
    public int get_Id();
    public string get_Name();
    public Type get_Type();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    private virtual override int System.IComparable.CompareTo(object o);
}
[CompilationMappingAttribute]
public class Aardvark.Base.IL.MethodDefinition : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Type[] ArgumentTypes@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Type ReturnType@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Instruction> Body@;
    [CompilationMappingAttribute]
public Type[] ArgumentTypes { get; }
    [CompilationMappingAttribute]
public Type ReturnType { get; }
    [CompilationMappingAttribute]
public FSharpList`1<Instruction> Body { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.IL.MethodDefinition")]
public MethodDefinition(Type[] argumentTypes, Type returnType, FSharpList`1<Instruction> body);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Type[] get_ArgumentTypes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Instruction> get_Body();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(MethodDefinition obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MethodDefinition obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.ReflectionExtensions : object {
    public static BindingFlags BindingFlags.get_All.Static();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.Serializer : object {
    [CompilationMappingAttribute]
public static CoderBuilder code { get; }
    public static CoderBuilder get_code();
    public static Byte[] toArray(a data);
    public static a ofArray(Byte[] bytes);
    public static void test();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.StateMonad : object {
    [CompilationMappingAttribute]
public static StateBuilder state { get; }
    public static StateBuilder get_state();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.TypeBuilder : object {
}
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.TypeBuilderOld : object {
    [CompilationMappingAttribute]
internal static AssemblyBuilder bAss { get; }
    [CompilationMappingAttribute]
internal static ModuleBuilder bMod { get; }
    internal static AssemblyBuilder get_bAss();
    internal static ModuleBuilder get_bMod();
    internal static FSharpOption`1<MethodInfo> tryFindMethod@31(string name, Type[] args, Type ret, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static object implementInterface(Type iface, FSharpList`1<Tuple`4<Type, string, FSharpList`1<Type>, FSharpFunc`2<CodeGenState, Tuple`2<CodeGenState, Unit>>>> methods);
    internal static FSharpOption`1<MethodInfo> tryFindMethod@139-2(string name, Type[] args, Type ret, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static object implementSubType(Type baseType, FSharpList`1<Tuple`4<Type, string, FSharpList`1<Type>, FSharpFunc`2<CodeGenState, Tuple`2<CodeGenState, Unit>>>> methods);
    public static a implement(FSharpList`1<Tuple`4<Type, string, FSharpList`1<Type>, FSharpFunc`2<CodeGenState, Tuple`2<CodeGenState, Unit>>>> methods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type funcType(FSharpList`1<Type> args, Type ret);
    public static a func(FSharpFunc`2<CodeGenState, Tuple`2<CodeGenState, Unit>> code);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.IL.TypeBuilderTest : object {
    public static Type buildTest();
    public static Type buildFunc();
    public static void run();
}
[CompilationMappingAttribute]
public enum Aardvark.Base.IL.ValueType : Enum {
    public int value__;
    public static ValueType Int8;
    public static ValueType UInt8;
    public static ValueType Int16;
    public static ValueType UInt16;
    public static ValueType Int32;
    public static ValueType UInt32;
    public static ValueType Int64;
    public static ValueType UInt64;
    public static ValueType Float64;
    public static ValueType Float32;
    public static ValueType NativeInt;
    public static ValueType UNativeInt;
    public static ValueType Object;
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.InheritanceTypeExtensions : object {
    private static InheritanceTypeExtensions();
    [ExtensionAttribute]
public static Type[] GetBaseTypes(Type this);
    [ExtensionAttribute]
public static Type[] GetBaseTypesAndSelf(Type this);
    [ExtensionAttribute]
public static Type Substitute(Type x, Type p, Type v);
    [ExtensionAttribute]
public static Type SubstituteParameters(Type x, FSharpFunc`2<Type, Type> mapping);
    [ExtensionAttribute]
public static FSharpHashSet`1<Type> FreeVariables(Type x);
    [ExtensionAttribute]
public static Type[] TopologicalSort(IEnumerable`1<Type> this);
    [CompilerGeneratedAttribute]
internal static Type[] topoSort(Type[] types);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Type> baseTypes(Type t);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.IOModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string alterFileName(string str, FSharpFunc`2<string, string> f);
    public static FileStream createFileStream(string path);
}
[CompilationMappingAttribute]
public interface Aardvark.Base.IOrder {
    public int Count { get; }
    public ISortKey Root { get; }
    public abstract virtual int get_Count();
    public abstract virtual ISortKey get_Root();
}
[CompilationMappingAttribute]
public interface Aardvark.Base.IReal {
    public abstract virtual IReal InsertAfter();
}
[CompilationMappingAttribute]
public interface Aardvark.Base.IRuntimeMethod {
    public abstract virtual object Invoke(Object[] );
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public interface Aardvark.Base.ISortKey {
    public IOrder Clock { get; }
    public abstract virtual IOrder get_Clock();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Lens Operators : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c op_BarDot(a l, b r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c op_BarDot$W(FSharpFunc`2<a, FSharpFunc`2<b, c>> compose, a l, b r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lens`2<s, a> op_BarQmark(Lens`2<s, FSharpOption`1<a>> l, a r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lens`2<s, a> op_BarQmarkQmark(Lens`2<s, FSharpOption`1<a>> l, a empty, FSharpFunc`2<a, bool> isEmpty);
}
[CompilationMappingAttribute]
public class Aardvark.Base.Lens`2 : object {
    public virtual a Get(s s);
    public virtual s Set(s s, a v);
    public virtual s Update(s s, FSharpFunc`2<a, a> f);
    public static Lens`2<s, b> Compose(Lens`2<s, a> l, Lens`2<a, b> r);
}
[CompilationMappingAttribute]
internal class Aardvark.Base.Link`1 : ValueType {
    internal Node`1<a> Target;
    internal int Width;
    public Link`1(Node`1<a> target, int w);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal bool Equals(Link`1<a> obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Link`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
internal class Aardvark.Base.Linked`1 : object {
    internal a Value;
    internal Linked`1<a> Prev;
    internal Linked`1<a> Next;
    public Linked`1(a v, Linked`1<a> p, Linked`1<a> n);
    public Linked`1(a v);
}
[CompilationMappingAttribute]
internal class Aardvark.Base.LinkedEnumerator`1 : object {
    internal Linked`1<a> l;
    internal Linked`1<a> current;
    public LinkedEnumerator`1(Linked`1<a> l);
    private virtual override bool System.Collections.IEnumerator.MoveNext();
    private virtual override object System.Collections.IEnumerator.get_Current();
    private virtual override void System.Collections.IEnumerator.Reset();
    private virtual override a System.Collections.Generic.IEnumerator<'a>.get_Current();
    private virtual override void System.IDisposable.Dispose();
}
[AbstractClassAttribute]
[SealedAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Log : object {
    internal static Regex lineBreakRx;
    internal static FSharpFunc`2<string, Unit> writeLine;
    internal static FSharpFunc`2<string, Unit> writeDebug;
    internal static FSharpFunc`2<string, Unit> writeWarn;
    internal static FSharpFunc`2<string, Unit> writeError;
    internal static int init@7;
    [CompilerMessageAttribute("internal", "1337")]
public static FSharpFunc`2<string, Unit> WriteDebug { get; }
    [CompilerMessageAttribute("internal", "1337")]
public static FSharpFunc`2<string, Unit> WriteLine { get; }
    [CompilerMessageAttribute("internal", "1337")]
public static FSharpFunc`2<string, Unit> WriteWarn { get; }
    [CompilerMessageAttribute("internal", "1337")]
public static FSharpFunc`2<string, Unit> WriteError { get; }
    private static Log();
    public static FSharpFunc`2<string, Unit> get_WriteDebug();
    public static FSharpFunc`2<string, Unit> get_WriteLine();
    public static FSharpFunc`2<string, Unit> get_WriteWarn();
    public static FSharpFunc`2<string, Unit> get_WriteError();
    public static i debug(PrintfFormat`4<i, Unit, string, Unit> fmt);
    public static h line(PrintfFormat`4<h, Unit, string, Unit> fmt);
    public static g warn(PrintfFormat`4<g, Unit, string, Unit> fmt);
    public static f error(PrintfFormat`4<f, Unit, string, Unit> fmt);
    public static e startTimed(PrintfFormat`4<e, Unit, string, Unit> fmt);
    public static d start(PrintfFormat`4<d, Unit, string, Unit> fmt);
    public static void stop();
    public static c stop(PrintfFormat`4<c, Unit, string, Unit> fmt);
    public static b section(PrintfFormat`4<b, Unit, string, FSharpFunc`2<FSharpFunc`2<Unit, Unit>, Unit>> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a check(bool c, PrintfFormat`4<a, Unit, string, Unit> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static void printLines(FSharpFunc`2<string, Unit> print, string str);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.M33fModule : object {
    public static float gamma { get; }
    public static float cstar { get; }
    public static float sstar { get; }
    [CompilationMappingAttribute]
public static float epsilon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static float get_gamma();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static float get_cstar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static float get_sstar();
    public static float get_epsilon();
    public static float invSqrt(a x);
    public static float invSqrt$W(FSharpFunc`2<a, float> sqrt, a x);
    public static M33f quatToM33(V4f qV);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<float, float> givens(a m11, float m12, b m22);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<float, float> givens$W(FSharpFunc`2<a, FSharpFunc`2<b, float>> op_Subtraction, a m11, float m12, b m22);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static M33f diagonal(float m11, float m21, float m22, float m31, float m32, float m33);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<M33f, V4f> conjugate(int x, int y, int z, M33f m, V4f qV);
    public static Tuple`2<M33f, V4f> diagonalizeSymmetric(M33f m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<a, a> swap(bool c, a x, a y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<a, a> swap$W(FSharpFunc`2<a, a> op_UnaryNegation, bool c, a x, a y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<a, a> fswap(bool c, a x, a y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<M33f, M33f> decomposeAndSort(M33f m, M33f q);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<float, float> QRgivens(float p, float a);
    public static Tuple`2<M33f, M33f> QRdecompose(M33f m);
    public static Tuple`3<M33f, M33f, M33f> svd(M33f m);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public class Aardvark.Base.managedptr : object {
    internal Block block@154;
    public MemoryManager Parent { get; }
    public IntPtr Size { get; }
    public IntPtr Offset { get; }
    public bool Free { get; }
    internal Block Block { get; internal set; }
    public SByte[] Int8Array { get; }
    public Int16[] Int16Array { get; }
    public Int32[] Int32Array { get; }
    public Int64[] Int64Array { get; }
    public Byte[] UInt8Array { get; }
    public UInt16[] UInt16Array { get; }
    public UInt32[] UInt32Array { get; }
    public UInt64[] UInt64Array { get; }
    internal managedptr(Block block);
    public MemoryManager get_Parent();
    public IntPtr get_Size();
    public IntPtr get_Offset();
    public bool get_Free();
    public virtual string ToString();
    internal Block get_Block();
    internal void set_Block(Block b);
    public r Use(FSharpFunc`2<IntPtr, r> action);
    public void Write(int offset, IntPtr source, int size);
    public void Read(int offset, IntPtr target, int size);
    public void Write(int offset, a data);
    public a Read(int offset);
    public void Write(int offset, a[] data);
    public void Read(int offset, a[] data);
    public a[] Read(int offset, int count);
    public void Move(int sourceOffset, int targetOffset, int length);
    public void CopyTo(managedptr target);
    public SByte[] get_Int8Array();
    public Int16[] get_Int16Array();
    public Int32[] get_Int32Array();
    public Int64[] get_Int64Array();
    public Byte[] get_UInt8Array();
    public UInt16[] get_UInt16Array();
    public UInt32[] get_UInt32Array();
    public UInt64[] get_UInt64Array();
    [CompilerGeneratedAttribute]
internal void check();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.ManagedPtrModule : object {
    public static MemoryManager parent(managedptr b);
    public static IntPtr size(managedptr b);
    public static IntPtr offset(managedptr b);
    public static bool isFree(managedptr b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool realloc(IntPtr size, managedptr b);
    public static void free(managedptr b);
    public static managedptr spill(managedptr b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void write(int offset, a value, managedptr b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeArray(int offset, a[] value, managedptr b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a read(int offset, managedptr b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a[] readArray(int offset, managedptr b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void move(int sourceOffset, int targetOffset, int length, managedptr b);
}
[SealedAttribute]
[CompilationMappingAttribute]
internal class Aardvark.Base.MapDebugView`2 : object {
    internal MapExt`2<Key, Value> v;
    [DebuggerBrowsableAttribute("3")]
internal KeyValuePair`2[] Items { get; }
    public MapDebugView`2(MapExt`2<Key, Value> v);
    internal KeyValuePair`2[] get_Items();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Aardvark.Base.MapDebugView`2")]
[SealedAttribute]
[CustomPicklerAttribute]
[StructuredFormatDisplayAttribute("{AsString}")]
[DebuggerDisplayAttribute("Count = {Count}")]
[CompilationMappingAttribute]
public class Aardvark.Base.MapExt`2 : object {
    internal MapTree`2<Key, Value> tree;
    internal IComparer`1<Key> comparer;
    internal static IComparer`1<Key> defaultComparer;
    internal static MapExt`2<Key, Value> empty;
    internal static int init@1970;
    public static MapExt`2<Key, Value> Empty { get; }
    [DebuggerBrowsableAttribute("0")]
internal IComparer`1<Key> Comparer { get; }
    internal MapTree`2<Key, Value> Tree { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    public Value Item { get; }
    public FSharpSet`1<Key> Keys { get; }
    public IEnumerable`1<Value> Values { get; }
    public int Count { get; }
    public FSharpOption`1<Tuple`2<Key, Value>> TryMin { get; }
    public FSharpOption`1<Tuple`2<Key, Value>> TryMax { get; }
    public FSharpOption`1<Key> TryMinKey { get; }
    public FSharpOption`1<Key> TryMaxKey { get; }
    public FSharpValueOption`1<Key> TryMinKeyV { get; }
    public FSharpValueOption`1<Key> TryMaxKeyV { get; }
    public FSharpOption`1<Value> TryMinValue { get; }
    public FSharpOption`1<Value> TryMaxValue { get; }
    public FSharpValueOption`1<Value> TryMinValueV { get; }
    public FSharpValueOption`1<Value> TryMaxValueV { get; }
    internal string AsString { get; }
    internal MapExt`2(IComparer`1<Key> comparer, MapTree`2<Key, Value> tree);
    private static MapExt`2();
    public MapExt`2(IEnumerable`1<Tuple`2<Key, Value>> ie);
    internal static Pickler`1<MapExt`2<Key, Value>> CreatePickler(IPicklerResolver r);
    public static MapExt`2<Key, Value> get_Empty();
    public static MapExt`2<Key, Value> Create(IEnumerable`1<Tuple`2<Key, Value>> ie);
    public static MapExt`2<Key, Value> CreateV(IEnumerable`1<ValueTuple`2<Key, Value>> ie);
    public static MapExt`2<Key, Value> Create();
    internal IComparer`1<Key> get_Comparer();
    internal MapTree`2<Key, Value> get_Tree();
    public MapExt`2<Key, Value> Add(Key k, Value v);
    public bool get_IsEmpty();
    public Value get_Item(Key k);
    public FSharpSet`1<Key> get_Keys();
    public IEnumerable`1<Value> get_Values();
    public FSharpOption`1<Tuple`2<Key, Value>> TryAt(int i);
    public FSharpValueOption`1<ValueTuple`2<Key, Value>> TryAtV(int i);
    public Tuple`3<FSharpOption`1<Tuple`2<Key, Value>>, FSharpOption`1<Tuple`2<Key, Value>>, FSharpOption`1<Tuple`2<Key, Value>>> Neighbours(Key k);
    public Tuple`3<FSharpOption`1<Tuple`2<Key, Value>>, FSharpOption`1<Tuple`2<Key, Value>>, FSharpOption`1<Tuple`2<Key, Value>>> NeighboursAt(int i);
    public ValueTuple`3<FSharpValueOption`1<ValueTuple`2<Key, Value>>, FSharpValueOption`1<ValueTuple`2<Key, Value>>, FSharpValueOption`1<ValueTuple`2<Key, Value>>> NeighboursV(Key k);
    public ValueTuple`3<FSharpValueOption`1<ValueTuple`2<Key, Value>>, FSharpValueOption`1<ValueTuple`2<Key, Value>>, FSharpValueOption`1<ValueTuple`2<Key, Value>>> NeighboursAtV(int i);
    public FSharpOption`1<int> TryGetIndex(Key k);
    public FSharpValueOption`1<int> TryGetIndexV(Key k);
    public FSharpOption`1<a> TryPick(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpOption`1<a>>> f);
    public FSharpOption`1<a> TryPickBack(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpOption`1<a>>> f);
    public bool Exists(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    public MapExt`2<Key, Value> Filter(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    public bool ForAll(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public a Fold(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<a, a>>> f, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public z FoldSection(Key lo, Key hi, FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<z, z>>> f, z acc);
    public void Iterate(FSharpFunc`2<Key, FSharpFunc`2<Value, Unit>> f);
    public MapExt`2<Key, T2> MapRange(FSharpFunc`2<Value, T2> f);
    public MapExt`2<Key, T2> Map(FSharpFunc`2<Key, FSharpFunc`2<Value, T2>> f);
    public MapExt`2<Key2, Value2> MapMonotonic(FSharpFunc`2<Key, FSharpFunc`2<Value, Tuple`2<Key2, Value2>>> f);
    public MapExt`2<Key2, Value2> ChooseMonotonic(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpOption`1<Tuple`2<Key2, Value2>>>> f);
    internal MapExtReference`1<Value> GetReference(Key key);
    public FSharpOption`1<int> TryIndexOf(Key key);
    public FSharpOption`1<Tuple`3<Key, Value, MapExt`2<Key, Value>>> TryRemoveMin();
    public FSharpOption`1<Tuple`3<Key, Value, MapExt`2<Key, Value>>> TryRemoveMax();
    public FSharpValueOption`1<ValueTuple`4<Key, Value, FSharpValueOption`1<Key>, MapExt`2<Key, Value>>> TryRemoveMinV();
    public FSharpValueOption`1<ValueTuple`4<Key, Value, FSharpValueOption`1<Key>, MapExt`2<Key, Value>>> TryRemoveMaxV();
    public MapExt`2<Key, Result> Map2(MapExt`2<Key, Value2> other, FSharpFunc`2<Key, FSharpFunc`2<FSharpOption`1<Value>, FSharpFunc`2<FSharpOption`1<Value2>, Result>>> f);
    public MapExt`2<Key, Result> Choose2(MapExt`2<Key, Value2> other, FSharpFunc`2<Key, FSharpFunc`2<FSharpOption`1<Value>, FSharpFunc`2<FSharpOption`1<Value2>, FSharpOption`1<Result>>>> f);
    public MapExt`2<Key, Result> Choose2V(MapExt`2<Key, Value2> other, FSharpFunc`2<Key, FSharpFunc`2<FSharpValueOption`1<Value>, FSharpFunc`2<FSharpValueOption`1<Value2>, FSharpValueOption`1<Result>>>> f);
    public MapExt`2<Key, a> ComputeDelta(MapExt`2<Key, Value> other, FSharpFunc`2<Key, FSharpFunc`2<Value, a>> add, FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<Value, FSharpValueOption`1<a>>>> update, FSharpFunc`2<Key, FSharpFunc`2<Value, a>> remove);
    public Tuple`2<MapExt`2<Key, Value>, MapExt`2<Key, a>> ApplyDelta(MapExt`2<Key, Delta> other, FSharpFunc`2<Key, FSharpFunc`2<FSharpValueOption`1<Value>, FSharpFunc`2<Delta, ValueTuple`2<FSharpValueOption`1<Value>, FSharpValueOption`1<a>>>>> apply);
    public MapExt`2<Key, Value2> Choose(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpOption`1<Value2>>> f);
    public MapExt`2<Key, Value> Alter(Key k, FSharpFunc`2<FSharpOption`1<Value>, FSharpOption`1<Value>> f);
    public Tuple`2<MapExt`2<Key, Value>, MapExt`2<Key, Value>> Partition(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    public int get_Count();
    public FSharpOption`1<Tuple`2<Key, Value>> get_TryMin();
    public FSharpOption`1<Tuple`2<Key, Value>> get_TryMax();
    public FSharpOption`1<Key> get_TryMinKey();
    public FSharpOption`1<Key> get_TryMaxKey();
    public FSharpValueOption`1<Key> get_TryMinKeyV();
    public FSharpValueOption`1<Key> get_TryMaxKeyV();
    public FSharpOption`1<Value> get_TryMinValue();
    public FSharpOption`1<Value> get_TryMaxValue();
    public FSharpValueOption`1<Value> get_TryMinValueV();
    public FSharpValueOption`1<Value> get_TryMaxValueV();
    public MapExt`2<Key, Value> Range(Key min, Key max);
    public Tuple`3<MapExt`2<Key, Value>, FSharpOption`1<Value>, MapExt`2<Key, Value>> Split(Key k);
    public ValueTuple`5<MapExt`2<Key, Value>, FSharpValueOption`1<Key>, FSharpValueOption`1<Value>, FSharpValueOption`1<Key>, MapExt`2<Key, Value>> SplitV(Key k);
    public MapExt`2<Key, Value> UnionWith(MapExt`2<Key, Value> other, FSharpFunc`2<Value, FSharpFunc`2<Value, Value>> resolve);
    public MapExt`2<Key, Value> Union(MapExt`2<Key, Value> other);
    public MapExt`2<Key, b> IntersectWith(MapExt`2<Key, a> other, FSharpFunc`2<Value, FSharpFunc`2<a, b>> resolve);
    public MapExt`2<Key, Tuple`2<Value, a>> Intersect(MapExt`2<Key, a> other);
    public void Validate();
    public bool ContainsKey(Key k);
    public MapExt`2<Key, Value> Remove(Key k);
    public FSharpOption`1<Tuple`2<Value, MapExt`2<Key, Value>>> TryRemove(Key k);
    public FSharpValueOption`1<ValueTuple`2<Value, MapExt`2<Key, Value>>> TryRemoveV(Key k);
    public FSharpOption`1<Value> TryFind(Key k);
    public FSharpValueOption`1<Value> TryFindV(Key k);
    public FSharpList`1<Tuple`2<Key, Value>> ToList();
    public Tuple`2[] ToArray();
    public FSharpList`1<ValueTuple`2<Key, Value>> ToListV();
    public ValueTuple`2[] ToArrayV();
    public FSharpList`1<Value> ToValueList();
    public Value[] ToValueArray();
    public static MapExt`2<Key, Value> ofList(FSharpList`1<Tuple`2<Key, Value>> l);
    public static MapExt`2<Key, Value> ofListV(FSharpList`1<ValueTuple`2<Key, Value>> l);
    public int ComputeHashCode();
    public virtual bool Equals(object that);
    public virtual int GetHashCode();
    public IEnumerator`1<Tuple`2<Key, Value>> GetForwardEnumerator();
    public IEnumerator`1<Tuple`2<Key, Value>> GetBackwardEnumerator();
    public IEnumerator`1<ValueTuple`2<Key, Value>> GetForwardEnumeratorV();
    public IEnumerator`1<ValueTuple`2<Key, Value>> GetBackwardEnumeratorV();
    public virtual string ToString();
    internal string get_AsString();
    private virtual override IEnumerator`1<KeyValuePair`2<Key, Value>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override int System.IComparable.CompareTo(object obj);
}
[CompilationMappingAttribute]
internal static class Aardvark.Base.MapExtImplementation : object {
}
[CompilationRepresentationAttribute]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.MapExtModule : object {
    [CompilationSourceNameAttribute("isEmpty")]
public static bool IsEmpty(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("keys")]
public static FSharpSet`1<a> Keys(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("values")]
public static IEnumerable`1<b> Values(MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("add")]
public static MapExt`2<a, b> Add(a k, b v, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("find")]
public static b Find(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFind")]
public static FSharpOption`1<b> TryFind(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindV")]
public static FSharpValueOption`1<b> TryFindV(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("remove")]
public static MapExt`2<a, b> Remove(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryRemove")]
public static FSharpOption`1<Tuple`2<b, MapExt`2<a, b>>> TryRemove(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryRemoveV")]
public static FSharpValueOption`1<ValueTuple`2<b, MapExt`2<a, b>>> TryRemoveValue(a k, MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("tryRemoveMin")]
public static FSharpOption`1<Tuple`3<a, b, MapExt`2<a, b>>> TryRemoveMin(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("tryRemoveMax")]
public static FSharpOption`1<Tuple`3<a, b, MapExt`2<a, b>>> TryRemoveMax(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("tryRemoveMinV")]
public static FSharpValueOption`1<ValueTuple`4<a, b, FSharpValueOption`1<a>, MapExt`2<a, b>>> TryRemoveMinValue(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("tryRemoveMaxV")]
public static FSharpValueOption`1<ValueTuple`4<a, b, FSharpValueOption`1<a>, MapExt`2<a, b>>> TryRemoveMaxValue(MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("containsKey")]
public static bool ContainsKey(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("iter")]
public static void Iterate(FSharpFunc`2<a, FSharpFunc`2<b, Unit>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryPick")]
public static FSharpOption`1<c> TryPick(FSharpFunc`2<a, FSharpFunc`2<b, FSharpOption`1<c>>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryPickBack")]
public static FSharpOption`1<c> TryPickBack(FSharpFunc`2<a, FSharpFunc`2<b, FSharpOption`1<c>>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("pick")]
public static c Pick(FSharpFunc`2<a, FSharpFunc`2<b, FSharpOption`1<c>>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("exists")]
public static bool Exists(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("filter")]
public static MapExt`2<a, b> Filter(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("partition")]
public static Tuple`2<MapExt`2<a, b>, MapExt`2<a, b>> Partition(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("forall")]
public static bool ForAll(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapRange")]
public static MapExt`2<c, b> MapRange(FSharpFunc`2<a, b> f, MapExt`2<c, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map")]
public static MapExt`2<a, c> Map(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("fold")]
public static State Fold(FSharpFunc`2<State, FSharpFunc`2<Key, FSharpFunc`2<T, State>>> f, State z, MapExt`2<Key, T> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("foldBack")]
public static State FoldBack(FSharpFunc`2<Key, FSharpFunc`2<T, FSharpFunc`2<State, State>>> f, MapExt`2<Key, T> m, State z);
    [CompilationSourceNameAttribute("toSeq")]
public static IEnumerable`1<Tuple`2<a, b>> ToSeq(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toSeqV")]
public static IEnumerable`1<ValueTuple`2<a, b>> ToSeqV(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toValueSeq")]
public static IEnumerable`1<b> ToValueSeq(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toSeqBack")]
public static IEnumerable`1<Tuple`2<a, b>> ToSeqBack(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toSeqBackV")]
public static IEnumerable`1<ValueTuple`2<a, b>> ToSeqBackV(MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("findKey")]
public static a FindKey(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryFindKey")]
public static FSharpOption`1<a> TryFindKey(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("ofList")]
public static MapExt`2<Key, Value> OfList(FSharpList`1<Tuple`2<Key, Value>> l);
    [CompilationSourceNameAttribute("ofListV")]
public static MapExt`2<Key, Value> OfListV(FSharpList`1<ValueTuple`2<Key, Value>> l);
    [CompilationSourceNameAttribute("ofSeq")]
public static MapExt`2<a, b> OfSeq(IEnumerable`1<Tuple`2<a, b>> l);
    [CompilationSourceNameAttribute("ofSeqV")]
public static MapExt`2<a, b> OfSeqV(IEnumerable`1<ValueTuple`2<a, b>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("singleton")]
public static MapExt`2<a, b> Singleton(a k, b v);
    [CompilationSourceNameAttribute("ofArray")]
public static MapExt`2<Key, Value> OfArray(Tuple`2[] array);
    [CompilationSourceNameAttribute("ofArrayV")]
public static MapExt`2<Key, Value> OfArrayV(ValueTuple`2[] array);
    [CompilationSourceNameAttribute("toList")]
public static FSharpList`1<Tuple`2<a, b>> ToList(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toArray")]
public static Tuple`2[] ToArray(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toListV")]
public static FSharpList`1<ValueTuple`2<a, b>> ToListV(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toArrayV")]
public static ValueTuple`2[] ToArrayV(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toValueList")]
public static FSharpList`1<b> ToValueList(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("toValueArray")]
public static b[] ToValueArray(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("empty")]
public static MapExt`2<Key, Value> Empty();
    [CompilationSourceNameAttribute("count")]
public static int Count(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("tryMin")]
public static FSharpOption`1<a> TryMin(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("tryMinV")]
public static FSharpValueOption`1<a> TryMinV(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("min")]
public static a Min(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("tryMax")]
public static FSharpOption`1<a> TryMax(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("tryMaxV")]
public static FSharpValueOption`1<a> TryMaxV(MapExt`2<a, b> m);
    [CompilationSourceNameAttribute("max")]
public static a Max(MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryItem")]
public static FSharpOption`1<Tuple`2<a, b>> TryItem(int i, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryItemV")]
public static FSharpValueOption`1<ValueTuple`2<a, b>> TryItemV(int i, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("item")]
public static Tuple`2<a, b> Item(int i, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("alter")]
public static MapExt`2<a, b> Alter(a k, FSharpFunc`2<FSharpOption`1<b>, FSharpOption`1<b>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("mapMonotonic")]
public static MapExt`2<c, d> MapMonotonic(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, d>>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("chooseMonotonic")]
public static MapExt`2<c, d> ChooseMonotonic(FSharpFunc`2<a, FSharpFunc`2<b, FSharpOption`1<Tuple`2<c, d>>>> f, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("range")]
public static MapExt`2<a, b> Range(a min, a max, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("split")]
public static Tuple`3<MapExt`2<a, b>, FSharpOption`1<b>, MapExt`2<a, b>> Split(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("splitV")]
public static ValueTuple`5<MapExt`2<a, b>, FSharpValueOption`1<a>, FSharpValueOption`1<b>, FSharpValueOption`1<a>, MapExt`2<a, b>> SplitV(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryIndexOf")]
public static FSharpOption`1<int> TryIndexOf(a i, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("reference")]
internal static MapExtReference`1<b> GetReference(a i, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("union")]
public static MapExt`2<a, b> Union(MapExt`2<a, b> l, MapExt`2<a, b> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("unionWith")]
public static MapExt`2<b, a> UnionWith(FSharpFunc`2<a, FSharpFunc`2<a, a>> f, MapExt`2<b, a> l, MapExt`2<b, a> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("intersectWith")]
public static MapExt`2<d, c> IntersectWith(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, MapExt`2<d, a> l, MapExt`2<d, b> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("intersect")]
public static MapExt`2<a, Tuple`2<b, c>> Intersect(MapExt`2<a, b> l, MapExt`2<a, c> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("map2")]
public static MapExt`2<a, d> Map2(FSharpFunc`2<a, FSharpFunc`2<FSharpOption`1<b>, FSharpFunc`2<FSharpOption`1<c>, d>>> f, MapExt`2<a, b> l, MapExt`2<a, c> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("choose")]
public static MapExt`2<a, c> Choose(FSharpFunc`2<a, FSharpFunc`2<b, FSharpOption`1<c>>> f, MapExt`2<a, b> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("choose2")]
public static MapExt`2<a, d> Choose2(FSharpFunc`2<a, FSharpFunc`2<FSharpOption`1<b>, FSharpFunc`2<FSharpOption`1<c>, FSharpOption`1<d>>>> f, MapExt`2<a, b> l, MapExt`2<a, c> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("choose2V")]
public static MapExt`2<a, d> Choose2Value(FSharpFunc`2<a, FSharpFunc`2<FSharpValueOption`1<b>, FSharpFunc`2<FSharpValueOption`1<c>, FSharpValueOption`1<d>>>> f, MapExt`2<a, b> l, MapExt`2<a, c> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("neighbours")]
public static Tuple`3<FSharpOption`1<Tuple`2<a, b>>, FSharpOption`1<Tuple`2<a, b>>, FSharpOption`1<Tuple`2<a, b>>> Neighbours(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("neighboursAt")]
public static Tuple`3<FSharpOption`1<Tuple`2<a, b>>, FSharpOption`1<Tuple`2<a, b>>, FSharpOption`1<Tuple`2<a, b>>> NeighboursAt(int i, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("neighboursV")]
public static ValueTuple`3<FSharpValueOption`1<ValueTuple`2<a, b>>, FSharpValueOption`1<ValueTuple`2<a, b>>, FSharpValueOption`1<ValueTuple`2<a, b>>> NeighboursV(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("neighboursAtV")]
public static ValueTuple`3<FSharpValueOption`1<ValueTuple`2<a, b>>, FSharpValueOption`1<ValueTuple`2<a, b>>, FSharpValueOption`1<ValueTuple`2<a, b>>> NeighboursAtV(int i, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryGetIndex")]
public static FSharpOption`1<int> TryGetIndex(a k, MapExt`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilationSourceNameAttribute("tryGetIndexV")]
public static FSharpValueOption`1<int> TryGetIndexV(a k, MapExt`2<a, b> m);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.MarshalDelegateExtensions : object {
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Delegate, IntPtr> pinnedDelegates { get; }
    internal static ConcurrentDictionary`2<Delegate, IntPtr> get_pinnedDelegates();
    public static PinnedDelegate Marshal.PinDelegate.Static(Delegate d);
    public static PinnedDelegate Marshal.PinFunction.Static(FSharpFunc`2<a, b> f);
    public static PinnedDelegate Marshal.PinFunction.Static(FSharpFunc`2<a, FSharpFunc`2<b, c>> f);
    public static PinnedDelegate Marshal.PinFunction.Static(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, d>>> f);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.MatModule : object {
    public static Matrix' transpose(Matrix m);
    public static Matrix' transpose$W(FSharpFunc`2<Matrix, Matrix'> transposed, Matrix m);
    public static Scalar det(Matrix m);
    public static Scalar det$W(FSharpFunc`2<Matrix, Scalar> determinant, Matrix m);
    public static Matrix inverse(Matrix m);
    public static Matrix inverse$W(FSharpFunc`2<Matrix, Matrix> inverse, Matrix m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector' transform(Matrix m, Vector v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector' transform$W(FSharpFunc`2<Matrix, FSharpFunc`2<Vector, Vector'>> transform, Matrix m, Vector v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector transformPos(Matrix m, Vector v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector transformPos$W(FSharpFunc`2<Matrix, FSharpFunc`2<Vector, Vector>> transformPos, Matrix m, Vector v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector transformDir(Matrix m, Vector v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector transformDir$W(FSharpFunc`2<Matrix, FSharpFunc`2<Vector, Vector>> transformDir, Matrix m, Vector v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector transformPosProj(Matrix m, Vector v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector transformPosProj$W(FSharpFunc`2<Matrix, FSharpFunc`2<Vector, Vector>> transformPosProj, Matrix m, Vector v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anyEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyDifferent(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyDifferent$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anyDifferent, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allDifferent(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allDifferent$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allDifferent, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anySmaller(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anySmaller$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anySmaller, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyGreater(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyGreater$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anyGreater, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allSmaller(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allSmaller$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allSmaller, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allGreater(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allGreater$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allGreater, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anySmallerOrEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anySmallerOrEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anySmallerOrEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyGreaterOrEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyGreaterOrEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anyGreaterOrEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allSmallerOrEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allSmallerOrEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allSmallerOrEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allGreaterOrEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allGreaterOrEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allGreaterOrEqual, a a, b b);
}
[CompilationMappingAttribute]
public class Aardvark.Base.Measure`2 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<a, m> quantify@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<m, FSharpFunc`2<m, m>> mappend@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal m mempty@;
    [CompilationMappingAttribute]
public FSharpFunc`2<a, m> quantify { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<m, FSharpFunc`2<m, m>> mappend { get; }
    [CompilationMappingAttribute]
public m mempty { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.Measure`2")]
public Measure`2(FSharpFunc`2<a, m> quantify, FSharpFunc`2<m, FSharpFunc`2<m, m>> mappend, m mempty);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<a, m> get_quantify();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<m, FSharpFunc`2<m, m>> get_mappend();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public m get_mempty();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class Aardvark.Base.MeasureHelpers : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static m op_PlusDot(FSharpFunc`2<Measure`2<a, m>, m> a, FSharpFunc`2<Measure`2<a, m>, m> b, Measure`2<a, m> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static m q(a a, Measure`2<a, m> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static m cq(m m, Measure`2<a, m> _arg1);
}
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Aardvark.Base.Mem : ValueType {
    public long Bytes;
    public bool IsZero { get; }
    public double Kibibytes { get; }
    public double Mebibytes { get; }
    public double Gibibytes { get; }
    public double Tebibytes { get; }
    public double Pebibytes { get; }
    public double Exbibytes { get; }
    public double Kilobytes { get; }
    public double Megabytes { get; }
    public double Gigabytes { get; }
    public double Terabytes { get; }
    public double Petabytes { get; }
    public double Exabytes { get; }
    public static Mem Byte { get; }
    public static Mem Kibibyte { get; }
    public static Mem Mebibyte { get; }
    public static Mem Gibibyte { get; }
    public static Mem Tebibyte { get; }
    public static Mem Pebibyte { get; }
    public static Mem Exbibyte { get; }
    public static Mem Kilobyte { get; }
    public static Mem Megabyte { get; }
    public static Mem Gigabyte { get; }
    public static Mem Terabyte { get; }
    public static Mem Petabyte { get; }
    public static Mem Exabyte { get; }
    internal string AsString { get; }
    public static Mem Zero { get; }
    public Mem(long bytes);
    public Mem(int bytes);
    public Mem(ulong bytes);
    public Mem(UInt32 bytes);
    public Mem(IntPtr bytes);
    public Mem(UIntPtr bytes);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Mem obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(Mem obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_IsZero();
    public double get_Kibibytes();
    public double get_Mebibytes();
    public double get_Gibibytes();
    public double get_Tebibytes();
    public double get_Pebibytes();
    public double get_Exbibytes();
    public double get_Kilobytes();
    public double get_Megabytes();
    public double get_Gigabytes();
    public double get_Terabytes();
    public double get_Petabytes();
    public double get_Exabytes();
    public static Mem get_Byte();
    public static Mem get_Kibibyte();
    public static Mem get_Mebibyte();
    public static Mem get_Gibibyte();
    public static Mem get_Tebibyte();
    public static Mem get_Pebibyte();
    public static Mem get_Exbibyte();
    public static Mem get_Kilobyte();
    public static Mem get_Megabyte();
    public static Mem get_Gigabyte();
    public static Mem get_Terabyte();
    public static Mem get_Petabyte();
    public static Mem get_Exabyte();
    internal string get_AsString();
    public string ToStringDecimal();
    public string ToStringBinary();
    public string ToString(bool decimal);
    public virtual string ToString();
    public static Mem get_Zero();
    public static Mem op_Addition(Mem l, Mem r);
    public static Mem op_Subtraction(Mem l, Mem r);
    public static Mem op_UnaryNegation(Mem l);
    public static Mem op_Multiply(Mem l, int r);
    public static Mem op_Multiply(Mem l, double r);
    public static Mem op_Multiply(int l, Mem r);
    public static Mem op_Multiply(double l, Mem r);
    public static Mem op_Division(Mem l, int r);
    public static Mem op_Division(Mem l, double r);
    public static double op_Division(Mem l, Mem r);
    public static Mem FromKibibytes(double kib);
    public static Mem FromMebibytes(double mib);
    public static Mem FromGibibytes(double gib);
    public static Mem FromTebibytes(double tib);
    public static Mem FromPebibytes(double pib);
    public static Mem FromExbibytes(double eib);
    public static Mem FromKilobytes(double kb);
    public static Mem FromMegabytes(double mb);
    public static Mem FromGigabytes(double gm);
    public static Mem FromTerabytes(double tb);
    public static Mem FromPetabytes(double pb);
    public static Mem FromExabytes(double eb);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Mem obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.MemModule : object {
    [CompilationMappingAttribute]
public static Mem zero { get; }
    [CompilationMappingAttribute]
public static Mem B { get; }
    [CompilationMappingAttribute]
public static Mem kB { get; }
    [CompilationMappingAttribute]
public static Mem MB { get; }
    [CompilationMappingAttribute]
public static Mem GB { get; }
    [CompilationMappingAttribute]
public static Mem TB { get; }
    [CompilationMappingAttribute]
public static Mem PB { get; }
    [CompilationMappingAttribute]
public static Mem EB { get; }
    [CompilationMappingAttribute]
public static Mem kiB { get; }
    [CompilationMappingAttribute]
public static Mem MiB { get; }
    [CompilationMappingAttribute]
public static Mem GiB { get; }
    [CompilationMappingAttribute]
public static Mem TiB { get; }
    [CompilationMappingAttribute]
public static Mem PiB { get; }
    [CompilationMappingAttribute]
public static Mem EiB { get; }
    public static Mem get_zero();
    public static Mem get_B();
    public static Mem get_kB();
    public static Mem get_MB();
    public static Mem get_GB();
    public static Mem get_TB();
    public static Mem get_PB();
    public static Mem get_EB();
    public static Mem get_kiB();
    public static Mem get_MiB();
    public static Mem get_GiB();
    public static Mem get_TiB();
    public static Mem get_PiB();
    public static Mem get_EiB();
    public static Mem ofBytes(a b);
    public static Mem ofBytes$W(FSharpFunc`2<a, long> op_Explicit, a b);
    public static Mem ofKibibytes(a kib);
    public static Mem ofKibibytes$W(FSharpFunc`2<a, double> op_Explicit, a kib);
    public static Mem ofMebibytes(a mib);
    public static Mem ofMebibytes$W(FSharpFunc`2<a, double> op_Explicit, a mib);
    public static Mem ofGibibytes(a gib);
    public static Mem ofGibibytes$W(FSharpFunc`2<a, double> op_Explicit, a gib);
    public static Mem ofTebibytes(a tib);
    public static Mem ofTebibytes$W(FSharpFunc`2<a, double> op_Explicit, a tib);
    public static Mem ofPebibytes(a pib);
    public static Mem ofPebibytes$W(FSharpFunc`2<a, double> op_Explicit, a pib);
    public static Mem ofExbibytes(a eib);
    public static Mem ofExbibytes$W(FSharpFunc`2<a, double> op_Explicit, a eib);
    public static Mem ofKilobytes(a kb);
    public static Mem ofKilobytes$W(FSharpFunc`2<a, double> op_Explicit, a kb);
    public static Mem ofMegabytes(a mb);
    public static Mem ofMegabytes$W(FSharpFunc`2<a, double> op_Explicit, a mb);
    public static Mem ofGigabytes(a gb);
    public static Mem ofGigabytes$W(FSharpFunc`2<a, double> op_Explicit, a gb);
    public static Mem ofTerabytes(a tb);
    public static Mem ofTerabytes$W(FSharpFunc`2<a, double> op_Explicit, a tb);
    public static Mem ofPetabytes(a pb);
    public static Mem ofPetabytes$W(FSharpFunc`2<a, double> op_Explicit, a pb);
    public static Mem ofExabytes(a eb);
    public static Mem ofExabytes$W(FSharpFunc`2<a, double> op_Explicit, a eb);
}
[CompilationMappingAttribute]
public class Aardvark.Base.MemoryManager : object {
    internal MemoryManagerConfig config;
    internal FSharpRef`1<MemoryManager> this;
    internal IntPtr capacity@280;
    internal IntPtr allocated;
    internal IntPtr ptr;
    internal FreeList`2<IntPtr, Block> freeList;
    internal object l;
    internal ReaderWriterLockSlim pointerLock;
    internal Block firstBlock;
    internal Block lastBlock;
    internal int init@279-1;
    public IntPtr Pointer { get; }
    public ReaderWriterLockSlim PointerLock { get; }
    public IntPtr Capacity { get; }
    public IntPtr AllocatedBytes { get; }
    public IntPtr FreeBytes { get; }
    public IEnumerable`1<managedptr> FreeList { get; }
    public IntPtr FirstUsedByte { get; }
    public IntPtr LastUsedByte { get; }
    public object Lock { get; }
    public MemoryManager(IntPtr capacity, MemoryManagerConfig config);
    public MemoryManager(IntPtr cap, FSharpFunc`2<IntPtr, IntPtr> malloc, FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>> mfree);
    public IntPtr get_Pointer();
    public ReaderWriterLockSlim get_PointerLock();
    public IntPtr get_Capacity();
    public IntPtr get_AllocatedBytes();
    public IntPtr get_FreeBytes();
    public IEnumerable`1<managedptr> get_FreeList();
    public IntPtr get_FirstUsedByte();
    public IntPtr get_LastUsedByte();
    public void Dispose();
    public managedptr Alloc(IntPtr size);
    public managedptr AllocAligned(IntPtr align, IntPtr size);
    public void Free(managedptr ptr);
    public bool Realloc(managedptr ptr, IntPtr size);
    public managedptr Spill(managedptr ptr);
    public void Validate();
    public object get_Lock();
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
internal a readPointer(FSharpFunc`2<Unit, a> f);
    [CompilerGeneratedAttribute]
internal a writePointer(FSharpFunc`2<Unit, a> f);
    [CompilerGeneratedAttribute]
internal void validation();
    [CompilerGeneratedAttribute]
internal void free(Block b);
    [CompilerGeneratedAttribute]
internal void resize(IntPtr additional);
    [CompilerGeneratedAttribute]
internal Block alloc(IntPtr size);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`2<bool, Block> realloc(Block b, IntPtr size);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Block allocAligned(IntPtr align, IntPtr size);
    [CompilerGeneratedAttribute]
internal Block clone(Block b);
}
[CompilationMappingAttribute]
public class Aardvark.Base.MemoryManagerConfig : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<IntPtr, IntPtr> malloc@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>> mfree@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>>> mcopy@;
    [CompilationMappingAttribute]
public FSharpFunc`2<IntPtr, IntPtr> malloc { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>> mfree { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>>> mcopy { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.MemoryManagerConfig")]
public MemoryManagerConfig(FSharpFunc`2<IntPtr, IntPtr> malloc, FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>> mfree, FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>>> mcopy);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<IntPtr, IntPtr> get_malloc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>> get_mfree();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, FSharpFunc`2<IntPtr, Unit>>> get_mcopy();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.MemoryManagerModule : object {
    [CompilationMappingAttribute]
internal static MemoryManagerConfig nopConfig { get; }
    public static MemoryManager createHGlobal();
    internal static MemoryManagerConfig get_nopConfig();
    public static MemoryManager createNop();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static managedptr alloc(IntPtr size, MemoryManager m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void free(managedptr b, MemoryManager m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool realloc(managedptr b, IntPtr size, MemoryManager m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static managedptr spill(managedptr b, MemoryManager m);
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.MethodInfoGenericExtensions : object {
    [ExtensionAttribute]
public static FSharpOption`1<MethodInfo> TrySpecialize(MethodInfo this, Type[] args, Type ret);
    [ExtensionAttribute]
public static MethodInfo Specialize(MethodInfo this, Type[] args, Type ret);
}
[CompilationMappingAttribute]
internal static class Aardvark.Base.MethodResolver : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeDef Type.GetDefinition(Type );
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<MethodInfo> tryMakeApplicable$cont@274(Type[] args, Type ret, MethodInfo meth, ParameterInfo[] pars, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethodInfo> tryMakeApplicable(Type[] args, Type ret, MethodInfo meth);
}
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Aardvark.Base.MicroTime : ValueType {
    public long TotalNanoseconds;
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public double TotalMilliseconds { get; }
    public double TotalMicroseconds { get; }
    public bool IsZero { get; }
    public bool IsPositiveInfinity { get; }
    public bool IsNegativeInfinity { get; }
    public bool IsInfinite { get; }
    public bool IsFinite { get; }
    internal string AsString { get; }
    public static MicroTime PositiveInfinity { get; }
    public static MicroTime NegativeInfinity { get; }
    public static MicroTime Zero { get; }
    public static MicroTime Nanosecond { get; }
    public static MicroTime Microsecond { get; }
    public static MicroTime Millisecond { get; }
    public static MicroTime Second { get; }
    public static MicroTime Minute { get; }
    public MicroTime(long ns);
    public MicroTime(TimeSpan ts);
    public MicroTime(double ns);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MicroTime obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(MicroTime obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public double get_TotalMilliseconds();
    public double get_TotalMicroseconds();
    public bool get_IsZero();
    public bool get_IsPositiveInfinity();
    public bool get_IsNegativeInfinity();
    public bool get_IsInfinite();
    public bool get_IsFinite();
    internal string get_AsString();
    public virtual string ToString();
    public static MicroTime op_Addition(MicroTime l, MicroTime r);
    public static MicroTime op_Subtraction(MicroTime l, MicroTime r);
    public static MicroTime op_UnaryNegation(MicroTime l);
    public static MicroTime op_Multiply(MicroTime l, double r);
    public static MicroTime op_Multiply(double l, MicroTime r);
    public static MicroTime op_Multiply(MicroTime l, int r);
    public static MicroTime op_Multiply(int l, MicroTime r);
    public static MicroTime op_Division(MicroTime l, int r);
    public static MicroTime op_Division(MicroTime l, double r);
    internal static double ToFloat(MicroTime t);
    public static MicroTime DivideByInt(MicroTime l, int r);
    public static double op_Division(MicroTime l, MicroTime r);
    public static MicroTime get_PositiveInfinity();
    public static MicroTime get_NegativeInfinity();
    public static MicroTime get_Zero();
    public static MicroTime FromNanoseconds(long ns);
    public static MicroTime FromMicroseconds(double us);
    public static MicroTime FromMilliseconds(double ms);
    public static MicroTime FromSeconds(double s);
    public static MicroTime FromMinutes(double m);
    public static MicroTime FromTicks(long t);
    public static MicroTime get_Nanosecond();
    public static MicroTime get_Microsecond();
    public static MicroTime get_Millisecond();
    public static MicroTime get_Second();
    public static MicroTime get_Minute();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MicroTime obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.MicroTimeModule : object {
    [CompilationMappingAttribute]
public static MicroTime zero { get; }
    [CompilationMappingAttribute]
public static MicroTime ns { get; }
    [CompilationMappingAttribute]
public static MicroTime us { get; }
    [CompilationMappingAttribute]
public static MicroTime ms { get; }
    [CompilationMappingAttribute]
public static MicroTime s { get; }
    [CompilationMappingAttribute]
public static MicroTime m { get; }
    public static MicroTime get_zero();
    public static MicroTime get_ns();
    public static MicroTime get_us();
    public static MicroTime get_ms();
    public static MicroTime get_s();
    public static MicroTime get_m();
    public static MicroTime ofNanoseconds(a ns);
    public static MicroTime ofNanoseconds$W(FSharpFunc`2<a, long> op_Explicit, a ns);
    public static MicroTime ofMicroseconds(a us);
    public static MicroTime ofMicroseconds$W(FSharpFunc`2<a, double> op_Explicit, a us);
    public static MicroTime ofMilliseconds(a us);
    public static MicroTime ofMilliseconds$W(FSharpFunc`2<a, double> op_Explicit, a us);
    public static MicroTime ofSeconds(a us);
    public static MicroTime ofSeconds$W(FSharpFunc`2<a, double> op_Explicit, a us);
    public static MicroTime ofMinutes(a us);
    public static MicroTime ofMinutes$W(FSharpFunc`2<a, double> op_Explicit, a us);
    public static long nanoseconds(MicroTime t);
    public static double microseconds(MicroTime t);
    public static double milliseconds(MicroTime t);
    public static double seconds(MicroTime t);
    public static double minutes(MicroTime t);
    public static bool isZero(MicroTime t);
    public static bool isFinite(MicroTime t);
    public static bool isPositiveInfinity(MicroTime t);
    public static bool isNegativeInfinity(MicroTime t);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Monads : object {
    [CompilationMappingAttribute]
public static ContBuilder cont { get; }
    [CompilationMappingAttribute]
public static StateBuilder state { get; }
    [CompilationMappingAttribute]
public static StateContBuilder scont { get; }
    [CompilationMappingAttribute]
public static OptionBuilder option { get; }
    [CompilationMappingAttribute]
public static StateBuilder sopt { get; }
    [CompilationMappingAttribute]
public static StateSeqBuilder sseq { get; }
    public static ContBuilder get_cont();
    public static StateBuilder get_state();
    public static StateContBuilder get_scont();
    public static OptionBuilder get_option();
    public static StateBuilder get_sopt();
    public static StateSeqBuilder get_sseq();
}
[CompilationMappingAttribute]
public class Aardvark.Base.Monoid`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<a, bool> misEmpty@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal a mempty@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<a, FSharpFunc`2<a, a>> mappend@;
    [CompilationMappingAttribute]
public FSharpFunc`2<a, bool> misEmpty { get; }
    [CompilationMappingAttribute]
public a mempty { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<a, FSharpFunc`2<a, a>> mappend { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.Monoid`1")]
public Monoid`1(FSharpFunc`2<a, bool> misEmpty, a mempty, FSharpFunc`2<a, FSharpFunc`2<a, a>> mappend);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<a, bool> get_misEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public a get_mempty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<a, FSharpFunc`2<a, a>> get_mappend();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute]
public class Aardvark.Base.Multimethod : object {
    internal int parameterCount;
    internal Dictionary`2<MethodInfo, object> implementations;
    internal bool initialized;
    internal static Dictionary`2<Type, object> instances;
    internal MultimethodImpl methodCache;
    internal static int init@533;
    public Multimethod(int parameterCount, IEnumerable`1<Tuple`2<MethodInfo, object>> initial);
    public Multimethod(int parameterCount);
    public Multimethod(IEnumerable`1<MethodInfo> methods);
    private static Multimethod();
    public static object GetTarget(MethodInfo mi);
    public void Add(MethodInfo mi);
    public void Add(object target, MethodInfo mi);
    public bool TryInvoke(Object[] args, Object& result);
    public object InvokeUnsafe(Object[] args);
    public object Invoke(Object[] args);
    [CompilerGeneratedAttribute]
internal static object createInstance(Type t);
    [CompilerGeneratedAttribute]
internal static object createTarget(MethodInfo mi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`2<MethodInfo, object>> tryGetMethodInfo(Type retType, Type[] types);
}
[CompilationMappingAttribute]
public class Aardvark.Base.MultimethodException : Exception {
    protected MultimethodException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(Exception obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.MultimethodTest : object {
    public static Type dt { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_EqualsEquals(a a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_BangEquals(a a, a b);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static Type get_dt();
    public static object dispatcher(Object[] o);
    internal static double nop@733(Unit unitVar0);
    internal static double ours@750(Multimethod m, Unit unitVar0);
    internal static double dispatcher@793(Unit unitVar0);
    internal static double virtualCall@815(Unit unitVar0);
    internal static double staticCall@838(Unit unitVar0);
    public static void run();
}
[CompilationMappingAttribute]
public class Aardvark.Base.Native.BlobFile : object {
    internal FileManager store;
    internal ReaderWriterLockSlim rw;
    internal Guid id;
    internal FileHandle eid@1800;
    internal BlockHandle bid;
    public Guid Name { get; }
    public bool Exists { get; }
    public long Size { get; }
    public BlobFile(ReaderWriterLockSlim rw, FileManager store, Guid id, FileHandle eid);
    public Guid get_Name();
    public bool get_Exists();
    public long get_Size();
    public Byte[] Read();
    public void Write(Byte[] data);
    public void Delete();
    private virtual override Guid Aardvark.Base.Native.IBlobFile.get_Name();
    private virtual override bool Aardvark.Base.Native.IBlobFile.get_Exists();
    private virtual override long Aardvark.Base.Native.IBlobFile.get_Size();
    private virtual override Byte[] Aardvark.Base.Native.IBlobFile.Read();
    private virtual override void Aardvark.Base.Native.IBlobFile.Write(Byte[] arr);
    private virtual override void Aardvark.Base.Native.IBlobFile.Delete();
    private virtual override void Aardvark.Base.Native.IBlobFile.CopyTo(IBlobFile o);
}
[CompilationMappingAttribute]
public class Aardvark.Base.Native.BlobStore : object {
    internal FileManager store;
    internal ConcurrentDictionary`2<Guid, BlobFile> cache;
    internal ReaderWriterLockSlim rw;
    public Mem Memory { get; }
    public BlobStore(Memory m, FSharpFunc`2<int, Memory> getChunk);
    public Mem get_Memory();
    public BlobFile Get(Guid id);
    public BlobFile Create();
    public void Dispose();
    private virtual override Mem Aardvark.Base.Native.IBlobStore.get_Memory();
    private virtual override IBlobFile Aardvark.Base.Native.IBlobStore.Get(Guid id);
    private virtual override IBlobFile Aardvark.Base.Native.IBlobStore.Create();
    private virtual override void System.IDisposable.Dispose();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Native.BlobStoreModule : object {
    public static BlobStore directory(string dir);
    public static BlobStore hglobal();
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public class Aardvark.Base.Native.Block : object {
    public MemoryManager Memory;
    public long Offset;
    public long Size;
    public Block Next;
    public Block Prev;
    public bool IsFree;
    public Block(MemoryManager mem, long off, long size);
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Native.BlockExtensions : object {
    [ExtensionAttribute]
public static void Realloc(Block this, long size);
    [ExtensionAttribute]
public static void Read(Block this, Byte[] target);
    [ExtensionAttribute]
public static void Write(Block this, Byte[] source);
    [ExtensionAttribute]
public static Byte[] Read(Block this);
}
[CompilationMappingAttribute]
internal class Aardvark.Base.Native.DictHeader : ValueType {
    internal long Magic;
    internal int CapacityIndex;
    internal int Capacity;
    internal int FreeList;
    internal int Count;
    internal int FreeCount;
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DictHeader obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal bool Equals(DictHeader obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DictHeader obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
internal static class Aardvark.Base.Native.DictHeader Extensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool op_EqualsEquals(Guid a, Guid b);
    internal static a read(ptr ptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void write(a v, ptr ptr);
    internal static a op_BangBang(ptr`1<a> ptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void op_BangEquals(ptr`1<a> ptr, a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static long ptr.get_Magic(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_Magic(ptr x, long m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ptr.get_CapacityIndex(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_CapacityIndex(ptr x, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ptr.get_Capacity(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_Capacity(ptr x, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ptr.get_FreeList(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_FreeList(ptr x, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ptr.get_Count(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_Count(ptr x, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ptr.get_FreeCount(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_FreeCount(ptr x, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Guid ptr.get_Key(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_Key(ptr x, Guid m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static long ptr.get_Offset(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_Offset(ptr x, long m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static long ptr.get_Size(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_Size(ptr x, long m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ptr.get_HashCode(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_HashCode(ptr x, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ptr.get_Next(ptr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ptr.set_Next(ptr x, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ptr`1<a> op_DotPlus(ptr`1<a> ptr, int i);
}
[CompilationMappingAttribute]
internal class Aardvark.Base.Native.DictStore : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal long size@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Memory pointer@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ptr`1<DictHeader> header@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ptr`1<Entry> entries@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ptr`1<int> buckets@;
    [CompilationMappingAttribute]
internal long size { get; }
    [CompilationMappingAttribute]
internal Memory pointer { get; }
    [CompilationMappingAttribute]
internal ptr`1<DictHeader> header { get; }
    [CompilationMappingAttribute]
internal ptr`1<Entry> entries { get; }
    [CompilationMappingAttribute]
internal ptr`1<int> buckets { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.Native.DictStore")]
internal DictStore(long size, Memory pointer, ptr`1<DictHeader> header, ptr`1<Entry> entries, ptr`1<int> buckets);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal long get_size();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Memory get_pointer();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ptr`1<DictHeader> get_header();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ptr`1<Entry> get_entries();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ptr`1<int> get_buckets();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal bool Equals(DictStore obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DictStore obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
internal static class Aardvark.Base.Native.DictStoreModule : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231331_116Bytes@ field231332@;
    internal static long magic { get; }
    [CompilationMappingAttribute]
internal static long se { get; }
    [CompilationMappingAttribute]
internal static long si { get; }
    [CompilationMappingAttribute]
internal static long sh { get; }
    [CompilationMappingAttribute]
internal static Int32[] primeSizes { get; }
    [CompilationMappingAttribute]
internal static DictStore empty { get; }
    private static DictStoreModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static long get_magic();
    internal static long get_se();
    internal static long get_si();
    internal static long get_sh();
    internal static Int32[] get_primeSizes();
    internal static DictStore get_empty();
    internal static bool isDict(ptr ptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DictStore create(Memory mem, int capacityIndex);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DictStore getOrCreate(Memory mem, int capacityIndex);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DictStore realloc(DictStore store, int capacityIndex);
    internal static void release(DictStore s);
}
[CompilationMappingAttribute]
public class Aardvark.Base.Native.Entry : ValueType {
    public Guid Key;
    public long Offset;
    public long Size;
    public int HashCode;
    public int Next;
    public Entry(Guid k, long o, long s, int h, int n);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Entry obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(Entry obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Entry obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal class Aardvark.Base.Native.FileDictEnumerator : object {
    internal DictStore store;
    internal int cnt;
    internal int i;
    internal ptr`1<Entry> ptr;
    internal static int init@481-1;
    internal Entry Current { get; }
    public FileDictEnumerator(DictStore store);
    private static FileDictEnumerator();
    internal bool MoveNext();
    internal Entry get_Current();
    internal void Reset();
    private virtual override object System.Collections.IEnumerator.get_Current();
    private virtual override bool System.Collections.IEnumerator.MoveNext();
    private virtual override void System.Collections.IEnumerator.Reset();
    private virtual override Entry System.Collections.Generic.IEnumerator<Aardvark.Base.Native.Entry>.get_Current();
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute]
public class Aardvark.Base.Native.FileManager : object {
    internal FSharpFunc`2<int, Memory> getChunk;
    internal static int initialCapacityId;
    internal static long initialMemoryCapacity;
    internal static long chunkSize;
    internal static long headerSize;
    internal Memory mem@784;
    internal List`1<Memory> chunks;
    internal headerptr header;
    internal nodeptr nodes;
    internal blockptr blocks;
    internal dentryptr entries;
    internal IntPtr buckets;
    internal Stopwatch growManagerTime;
    internal Stopwatch growDictTime;
    internal Stopwatch growDataTime;
    internal Stopwatch rehashTime;
    internal Stopwatch reallocTime;
    internal long allocCount;
    internal long freeCount;
    internal Dict`2<Guid, FileHandle> handleCache;
    internal static int init@761;
    public Mem TotalMemory { get; }
    public int Entries { get; }
    public int Files { get; }
    public FileManagerStatistics Statistics { get; }
    public FileManager(Memory mem, FSharpFunc`2<int, Memory> getChunk);
    private static FileManager();
    public BlockHandle Alloc(long size);
    public void Free(BlockHandle block);
    public long SizeOf(BlockHandle block);
    public void Copy(Byte[] src, long srcOffset, BlockHandle dst, long dstOffset, long length);
    public void Copy(BlockHandle src, long srcOffset, Byte[] dst, long dstOffset, long length);
    public void Copy(BlockHandle src, long srcOffset, BlockHandle dst, long dstOffset, long length);
    public void Copy(BlockHandle src, Byte[] dst, long dstOffset, long length);
    public void Copy(BlockHandle src, long srcOffset, Byte[] dst, long length);
    public void Copy(BlockHandle src, Byte[] dst, long length);
    public void Copy(BlockHandle src, Byte[] dst);
    public void Copy(Byte[] src, BlockHandle dst, long dstOffset, long length);
    public void Copy(Byte[] src, long srcOffset, BlockHandle dst, long length);
    public void Copy(Byte[] src, BlockHandle dst, long length);
    public void Copy(Byte[] src, BlockHandle dst);
    public void Copy(BlockHandle src, BlockHandle dst, long dstOffset, long length);
    public void Copy(BlockHandle src, long srcOffset, BlockHandle dst, long length);
    public void Copy(BlockHandle src, BlockHandle dst, long length);
    public void Copy(BlockHandle src, BlockHandle dst);
    public Byte[] Read(BlockHandle src);
    public bool Exists(FileHandle file);
    public BlockHandle GetCurrentBlock(FileHandle file);
    public FileHandle GetFile(Guid key);
    public bool TryGetFile(Guid key, FileHandle& file);
    public void Resize(FileHandle file, long newSize);
    public void Delete(FileHandle file);
    public void Copy(Byte[] src, long srcOffset, FileHandle dst, long dstOffset, long length);
    public void Copy(Byte[] src, FileHandle dst, long dstOffset, long length);
    public void Copy(Byte[] src, long srcOffset, FileHandle dst, long length);
    public void Copy(Byte[] src, FileHandle dst, long length);
    public void Copy(Byte[] src, FileHandle dst);
    public void Copy(FileHandle src, long srcOffset, Byte[] dst, long dstOffset, long length);
    public void Copy(FileHandle src, Byte[] dst, long dstOffset, long length);
    public void Copy(FileHandle src, long srcOffset, Byte[] dst, long length);
    public void Copy(FileHandle src, Byte[] dst, long length);
    public void Copy(FileHandle src, Byte[] dst);
    public Byte[] Read(FileHandle src);
    public Mem get_TotalMemory();
    public int get_Entries();
    public int get_Files();
    public FileManagerStatistics get_Statistics();
    internal void Dispose(bool disposing);
    public void Dispose();
    public virtual void Finalize();
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
internal static bool isStore(Memory m);
    [CompilerGeneratedAttribute]
internal static long managerSize(int bCapacity);
    [CompilerGeneratedAttribute]
internal static long dictSize(int dCapacity);
    [CompilerGeneratedAttribute]
internal int nCapacity();
    [CompilerGeneratedAttribute]
internal int bCapacity();
    [CompilerGeneratedAttribute]
internal int dCapacity();
    [CompilerGeneratedAttribute]
internal void setPointers();
    [CompilerGeneratedAttribute]
internal void growManager();
    [CompilerGeneratedAttribute]
internal void growDict();
    [CompilerGeneratedAttribute]
internal void growData(long needed);
    [CompilerGeneratedAttribute]
internal Tuple`2<bool, int> newBlock();
    [CompilerGeneratedAttribute]
internal void deleteBlock(int bid);
    [CompilerGeneratedAttribute]
internal Tuple`2<bool, int> newNode();
    [CompilerGeneratedAttribute]
internal void deleteNode(int nid);
    [CompilerGeneratedAttribute]
internal Tuple`2<bool, int> newEntry();
    [CompilerGeneratedAttribute]
internal void deleteEntry(int eid);
    [CompilerGeneratedAttribute]
internal a withTree(FSharpFunc`2<FSharpRef`1<VirtualNode>, a> f);
    [CompilerGeneratedAttribute]
internal void insertFreeBlock(int bid);
    [CompilerGeneratedAttribute]
internal bool removeFreeBlock(int bid);
    [CompilerGeneratedAttribute]
internal Tuple`2<bool, int> getFreeBlock(long size);
    [CompilerGeneratedAttribute]
internal Tuple`2<bool, int> alloc(long size);
    [CompilerGeneratedAttribute]
internal void free(int bid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int findEntry(Guid key, int hashCode);
    [CompilerGeneratedAttribute]
internal bool removeEntryPtr(int eid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int setEntry(Guid key, int hashCode, int value);
    [CompilerGeneratedAttribute]
internal void rehash();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Native.FileManagerModule : object {
    public static FileManager directory(string dir);
    public static FileManager hglobal();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Native.FileManagerTypes : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int Red;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int Black;
    [DebuggerBrowsableAttribute("0")]
internal static T231333_116Bytes@ field231334@;
    [CompilationMappingAttribute]
public static Guid magic { get; }
    [CompilationMappingAttribute]
public static Int32[] primeSizes { get; }
    private static FileManagerTypes();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IntPtr op_PlusPlus(IntPtr ptr, a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IntPtr op_PlusPlus$W(FSharpFunc`2<a, int> op_Explicit, IntPtr ptr, a v);
    public static a op_BangBang(IntPtr ptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void op_LessMinusMinus(IntPtr ptr, a c);
    public static Guid get_magic();
    public static Int32[] get_primeSizes();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@746-9(FileManagerStatistics this, FileManagerStatistics obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@746-8(FileManagerStatistics this, FileManagerStatistics obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@746-11(FileManagerStatistics this, FileManagerStatistics objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@746-10(IComparer comp, FileManagerStatistics this, FileManagerStatistics objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@746-3(IEqualityComparer comp, FileManagerStatistics this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@746-6(FileManagerStatistics this, FileManagerStatistics obj, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@746-7(FileManagerStatistics this, FileManagerStatistics obj, Unit unitVar);
}
[DefaultMemberAttribute("Item")]
[CompilationMappingAttribute]
public class Aardvark.Base.Native.FileTable : object {
    internal static int initialExp;
    internal DictStore store;
    internal ptr`1<DictHeader> header;
    internal static int init@262;
    public int Count { get; }
    public Tuple`2<long, long> Item { get; public set; }
    public FileTable(Memory mem);
    private static FileTable();
    internal void Grow();
    internal int FindEntry(Guid key, int hashCode);
    internal int FindEntry(Guid key);
    internal void Set(Guid key, long offset, long size);
    internal Tuple`2<long, long> Get(Guid key);
    public bool Remove(Guid key);
    public bool TryGetValue(Guid key, Tuple`2& value);
    public int get_Count();
    public Tuple`2<long, long> get_Item(Guid key);
    public void set_Item(Guid key, Tuple`2<long, long> _arg1);
    public Tuple`2<long, long> GetOrAdd(Guid key, FSharpFunc`2<Guid, Tuple`2<long, long>> f);
    public bool ContainsKey(Guid key);
    public void Dispose();
    private virtual override void System.IDisposable.Dispose();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<Entry> System.Collections.Generic.IEnumerable<Aardvark.Base.Native.Entry>.GetEnumerator();
}
[CompilationMappingAttribute]
public interface Aardvark.Base.Native.IBlobFile {
    public Guid Name { get; }
    public bool Exists { get; }
    public long Size { get; }
    public abstract virtual Guid get_Name();
    public abstract virtual bool get_Exists();
    public abstract virtual long get_Size();
    public abstract virtual Byte[] Read();
    public abstract virtual void Write(Byte[] );
    public abstract virtual void Delete();
    public abstract virtual void CopyTo(IBlobFile );
}
[CompilationMappingAttribute]
public interface Aardvark.Base.Native.IBlobStore {
    public Mem Memory { get; }
    public abstract virtual Mem get_Memory();
    public abstract virtual IBlobFile Create();
    public abstract virtual IBlobFile Get(Guid );
}
[CompilationMappingAttribute]
public class Aardvark.Base.Native.MemoryManager : object {
    internal Memory store;
    internal long capacity;
    internal long allocated;
    internal FreeList`2<long, Block> free;
    internal Block first;
    internal Block last;
    internal ReaderWriterLockSlim pointer;
    internal int init@9;
    public double FillRate { get; }
    public long Allocated { get; }
    public long Capacity { get; }
    public MemoryManager(Memory store);
    public void ReadEntries(Tuple`3[] entries, FSharpFunc`2<a, FSharpFunc`2<Block, Unit>> newBlock);
    public double get_FillRate();
    public long get_Allocated();
    public long get_Capacity();
    public void Compact();
    internal void Swap(Block l, Block r);
    internal void Resize(bool hard, long minCapacity);
    public void Free(Block b);
    public Block Alloc(long size);
    public void Realloc(Block b, long newSize);
    public void Write(Block b, Byte[] data);
    public void Read(Block b, Byte[] data);
    public void Dispose();
    private virtual override void System.IDisposable.Dispose();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Native.NewImpl : object {
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Native.OldImpl : object {
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class Aardvark.Base.Native.ptr : object {
    internal static ptr nullptr;
    internal static int init@11;
    public IntPtr Pointer { get; }
    public bool IsValid { get; }
    public ptr RealPointer { get; }
    public static ptr Zero { get; }
    public static ptr Null { get; }
    private static ptr();
    public abstract virtual IntPtr get_Pointer();
    public abstract virtual bool get_IsValid();
    public virtual ptr get_RealPointer();
    public a Read();
    public void Write(a value);
    public a Get(int index);
    public void Set(int index, a value);
    public void Write(Byte[] source, long offset, long length);
    public void Read(Byte[] target, long offset, long length);
    public void CopyTo(IntPtr target, long length);
    public void CopyTo(ptr target, long length);
    public void CopyTo(Byte[] target, long offset, long length);
    public void CopyFrom(IntPtr source, long length);
    public void CopyFrom(ptr source, long length);
    public void CopyFrom(Byte[] source, long offset, long length);
    public Byte[] ToByteArray(long length);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static ptr get_Zero();
    public static ptr get_Null();
    public static ptr op_Addition(ptr p, IntPtr offset);
    public static ptr op_Subtraction(ptr p, IntPtr offset);
    public static ptr op_Addition(ptr p, a offset);
    public static ptr op_Addition$W(FSharpFunc`2<a, IntPtr> op_Explicit, ptr p, a offset);
    public static ptr op_Subtraction(ptr p, a offset);
    public static ptr op_Subtraction$W(FSharpFunc`2<a, IntPtr> op_Explicit, FSharpFunc`2<a, a> op_UnaryNegation, ptr p, a offset);
    public static ptr op_Addition(IntPtr offset, ptr p);
    public static ptr op_Addition(a offset, ptr p);
    public static ptr op_Addition$W(FSharpFunc`2<a, IntPtr> op_Explicit, a offset, ptr p);
    public static bool op_Equality(ptr ptr, IntPtr v);
}
[DefaultMemberAttribute("Item")]
[CompilationMappingAttribute]
public class Aardvark.Base.Native.ptr`1 : ptr {
    internal ptr p;
    internal static ptr`1<a> nullptr;
    internal static int sa;
    internal static long sa64;
    internal static int init@129-1;
    public IntPtr Pointer { get; }
    public ptr RealPointer { get; }
    public bool IsValid { get; }
    public static ptr`1<a> Zero { get; }
    public static ptr`1<a> Null { get; }
    public a Item { get; public set; }
    public a Value { get; public set; }
    public ptr`1(ptr p);
    private static ptr`1();
    public virtual IntPtr get_Pointer();
    public virtual ptr get_RealPointer();
    public virtual bool get_IsValid();
    public static ptr`1<a> get_Zero();
    public static ptr`1<a> get_Null();
    public a get_Item(int i);
    public void set_Item(int i, a value);
    public a get_Value();
    public void set_Value(a v);
    public void CopyTo(IntPtr target, long count);
    public void CopyTo(ptr target, long count);
    public void CopyTo(ptr`1<a> target, long count);
    public void CopyTo(a[] target, long offset, long count);
    public void CopyFrom(IntPtr source, long count);
    public void CopyFrom(ptr source, long count);
    public void CopyFrom(ptr`1<a> source, long count);
    public void CopyFrom(a[] source, long offset, long count);
    public a[] ToArray(int count);
    public static ptr`1<a> op_Addition(ptr`1<a> l, int index);
    public static ptr`1<a> op_Subtraction(ptr`1<a> l, int index);
    public static ptr`1<a> op_Addition(ptr`1<a> l, long index);
    public static ptr`1<a> op_Subtraction(ptr`1<a> l, long index);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Native.PtrModule : object {
    [CompilationMappingAttribute]
public static ptr zero { get; }
    public static ptr get_zero();
    public static bool isValid(ptr p);
    public static bool isNull(ptr p);
    public static ptr`1<a> cast(ptr p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a get(int i, ptr`1<a> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void set(int i, a value, ptr`1<a> p);
    public static a read(ptr`1<a> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void write(a value, ptr`1<a> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] toByteArray(long length, ptr ptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a[] toArray(int length, ptr`1<a> ptr);
}
[AbstractClassAttribute]
[CompilationMappingAttribute]
public abstract class Aardvark.Base.Native.sizedptr : ptr {
    internal static sizedptr nullptr;
    internal static int init@201-2;
    public long Size { get; }
    public static sizedptr Null { get; }
    public static sizedptr Zero { get; }
    private static sizedptr();
    public abstract virtual long get_Size();
    public static sizedptr get_Null();
    public static sizedptr get_Zero();
}
[CompilationMappingAttribute]
internal class Aardvark.Base.Native.ViewPointer : ptr {
    internal ptr p;
    internal IntPtr offset;
    internal ptr Source { get; }
    internal IntPtr Offset { get; }
    public bool IsValid { get; }
    public IntPtr Pointer { get; }
    public ViewPointer(ptr p, IntPtr offset);
    internal ptr get_Source();
    internal IntPtr get_Offset();
    public virtual bool get_IsValid();
    public virtual IntPtr get_Pointer();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.NativeUtilities : object {
    [CompilationMappingAttribute]
internal static OperatingSystem os { get; }
    internal static OperatingSystem get_os();
    public static void Marshal.Copy.Static(IntPtr source, IntPtr destination, UIntPtr length);
    public static void Marshal.Move.Static(IntPtr source, IntPtr destination, UIntPtr length);
    public static void Marshal.Set.Static(IntPtr memory, int value, UIntPtr length);
    public static int Marshal.Compare.Static(IntPtr source, IntPtr destination, UIntPtr length);
    public static void Marshal.Copy.Static(IntPtr source, IntPtr destination, int length);
    public static void Marshal.Move.Static(IntPtr source, IntPtr destination, int length);
    public static void Marshal.Set.Static(IntPtr memory, int value, int length);
    public static int Marshal.Compare.Static(IntPtr source, IntPtr destination, int length);
    public static void Marshal.Copy.Static(IntPtr source, IntPtr destination, a length);
    public static void Marshal.Copy.Static$W(FSharpFunc`2<a, UIntPtr> op_Explicit, IntPtr source, IntPtr destination, a length);
    public static void Marshal.Move.Static(IntPtr source, IntPtr destination, a length);
    public static void Marshal.Move.Static$W(FSharpFunc`2<a, UIntPtr> op_Explicit, IntPtr source, IntPtr destination, a length);
    public static void Marshal.Set.Static(IntPtr memory, int value, a length);
    public static void Marshal.Set.Static$W(FSharpFunc`2<a, UIntPtr> op_Explicit, IntPtr memory, int value, a length);
    public static int Marshal.Compare.Static(IntPtr source, IntPtr destination, a length);
    public static int Marshal.Compare.Static$W(FSharpFunc`2<a, UIntPtr> op_Explicit, IntPtr source, IntPtr destination, a length);
    [ObsoleteAttribute("Use NativeInt.pin instead.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a pinned(object a, FSharpFunc`2<IntPtr, a> f);
    [ObsoleteAttribute("Use NativePtr.pin instead.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static U pin(FSharpFunc`2<IntPtr, U> f, T value);
    [ObsoleteAttribute("Use NativePtr.pinArr instead.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static U pinArr(FSharpFunc`2<IntPtr, U> f, T[] array);
}
[CompilationMappingAttribute]
public class Aardvark.Base.NestedOrderMapping : object {
    internal Order`1<SortKeyTuple> derived;
    internal Dictionary`2<SortKeyTuple, SortKey`1<SortKeyTuple>> nodes;
    public IOrder Order { get; }
    public int Count { get; }
    public ISortKey Root { get; }
    public IOrder get_Order();
    public int get_Count();
    public ISortKey get_Root();
    public void Clear();
    public ISortKey Invoke(ISortKey outer, ISortKey inner);
    internal ISortKey Revoke(SortKeyTuple tup);
    public ISortKey Revoke(ISortKey outer, ISortKey inner);
    public FSharpList`1<ISortKey> RevokeAll(ISortKey outer);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.NiceUtilities : object {
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
internal class Aardvark.Base.Node`1 : object {
    internal a value;
    internal int height@9;
    internal Link`1[] next;
    internal int Height { get; }
    internal Link`1[] Next { get; }
    internal a Value { get; }
    public Node`1(a value, int height);
    internal int get_Height();
    internal Link`1[] get_Next();
    internal a get_Value();
    internal void Resize(int h);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Order : object {
    public static int count(IOrder c);
    public static ISortKey root(IOrder c);
}
[CompilationMappingAttribute]
public class Aardvark.Base.OrderMaintenance`1 : object {
    internal Order`1<a> derived;
    internal Dictionary`2<a, SortKey`1<a>> nodes;
    public int Count { get; }
    public IOrder Order { get; }
    public ISortKey Root { get; }
    public OrderMaintenance`1(IComparer`1<a> comparer);
    public OrderMaintenance`1(FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp);
    public int get_Count();
    public IOrder get_Order();
    public ISortKey get_Root();
    public void Clear();
    public ISortKey Invoke(a t);
    public FSharpOption`1<ISortKey> TryGet(a t);
    public ISortKey Revoke(a t);
}
[CompilationMappingAttribute]
public class Aardvark.Base.OrderMaintenanceTrie`2 : object {
    internal FSharpFunc`2<int, FSharpOption`1<IComparer`1<k>>> getComparer;
    internal IntDict`1<FSharpOption`1<IComparer`1<k>>> comparerCache;
    internal OrderMaintenanceTrieNode`2<k, a> root;
    public bool IsEmpty { get; }
    public OrderMaintenanceTrieNode`2<k, a> Root { get; }
    public FSharpValueOption`1<TrieReference`2<k, a>> First { get; }
    public FSharpValueOption`1<TrieReference`2<k, a>> Last { get; }
    public OrderMaintenanceTrie`2(FSharpFunc`2<int, FSharpOption`1<IComparer`1<k>>> getComparer);
    public OrderMaintenanceTrie`2(IComparer`1<k> cmp);
    public bool get_IsEmpty();
    public TrieReference`2<k, a> Set(FSharpList`1<k> key, a value);
    public void Iter(FSharpFunc`2<FSharpList`1<k>, FSharpFunc`2<a, Unit>> action);
    public FSharpValueOption`1<Tuple`2<FSharpValueOption`1<TrieReference`2<k, a>>, FSharpValueOption`1<TrieReference`2<k, a>>>> TryRemove(FSharpList`1<k> key);
    public TrieReference`2<k, a> AddOrUpdate(FSharpList`1<k> key, FSharpFunc`2<FSharpValueOption`1<a>, a> create);
    public FSharpValueOption`1<TrieReference`2<k, a>> Alter(FSharpList`1<k> key, FSharpFunc`2<FSharpValueOption`1<a>, FSharpValueOption`1<a>> update);
    public FSharpValueOption`1<a> TryGetValue(FSharpList`1<k> key);
    public FSharpValueOption`1<TrieReference`2<k, a>> TryGetReference(FSharpList`1<k> key);
    public bool ContainsKey(FSharpList`1<k> key);
    public void Clear();
    public OrderMaintenanceTrieNode`2<k, a> get_Root();
    public FSharpValueOption`1<TrieReference`2<k, a>> get_First();
    public FSharpValueOption`1<TrieReference`2<k, a>> get_Last();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<Tuple`2<FSharpList`1<k>, a>> System.Collections.Generic.IEnumerable<System.Tuple<Microsoft.FSharp.Collections.List<'k>, 'a>>.GetEnumerator();
    [CompilerGeneratedAttribute]
internal FSharpOption`1<IComparer`1<k>> getCachedComparer(int level);
}
[CompilerMessageAttribute("for internal use only", "1336")]
[CompilationMappingAttribute]
public static class Aardvark.Base.OrderMaintenanceTrieImplementation : object {
}
[CompilationMappingAttribute]
public class Aardvark.Base.OrderMapping : OrderMaintenance`1<ISortKey> {
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.PathModule : object {
    public static string combine(IEnumerable`1<string> paths);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string andPath(string first, string second);
    public static string withTrailingSlash(string path);
    public static string withoutTrailingSlash(string path);
}
[CustomPicklerProviderAttribute]
[CompilationMappingAttribute]
public class Aardvark.Base.Picklers.AdaptivePicklers : object {
    public static Pickler`1<FSharpHashSet`1<a>> HashSet(IPicklerResolver r);
    public static Pickler`1<CountingHashSet`1<a>> CountingHashSet(IPicklerResolver r);
    public static Pickler`1<FSharpHashSetDelta`1<a>> HashSetDelta(IPicklerResolver r);
    public static Pickler`1<IndexList`1<a>> IndexList(IPicklerResolver r);
    public static Pickler`1<IndexListDelta`1<a>> IndexListDelta(IPicklerResolver r);
    public static Pickler`1<FSharpHashMap`2<k, v>> HashMap(IPicklerResolver r);
    public static Pickler`1<FSharpHashMapDelta`2<k, v>> HashMapDelta(IPicklerResolver r);
}
[AbstractClassAttribute]
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.PolygonExtensions : object {
    [ExtensionAttribute]
public static Polygon2d Simplify(Polygon2d x, double eps);
    [ExtensionAttribute]
public static Polygon3d Simplify(Polygon3d x, double eps);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Predefined Lenses : object {
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Prelude : object {
    public static void inc(Int32& a);
    public static void dec(Int32& a);
    public static bool isNull(a a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IntPtr nativeptr`1.get_Address(IntPtr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T nativeptr`1.get_Value(IntPtr );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void nativeptr`1.set_Value(IntPtr ptr, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static T nativeptr`1.get_Item(IntPtr ptr, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void nativeptr`1.set_Item(IntPtr ptr, int index, T value);
    public static void Buffer.MemoryCopy.Static(IntPtr source, IntPtr destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    public static void Buffer.MemoryCopy.Static(IntPtr source, IntPtr destination, long destinationSizeInBytes, long sourceBytesToCopy);
    public static Func`2<a, b> toFunc(FSharpFunc`2<a, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b fromFunc(Func`2<a, b> f, a x);
    public static void dowhile(FSharpFunc`2<Unit, bool> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c uncurry(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c curry(FSharpFunc`2<Tuple`2<a, b>, c> f, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c flip(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, b a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a constF(a v, b _arg1);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.PrimitiveValueConverter : object {
    [CompilationMappingAttribute]
internal static FSharpList`1<object> integralConversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> fractionalConversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> booleanConversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> vector2Conversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> vector3Conversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> vector4Conversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> matrix22Conversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> matrix23Conversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> matrix33Conversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> matrix34Conversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> matrix44Conversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> colorConversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> specialConversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> allConversions { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> transposeFunctions { get; }
    [CompilationMappingAttribute]
internal static ConversionMapping`1<object> mapping { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Type, object> transposeMapping { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Type, object> dict@1223 { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> current@1224 { get; internal set; }
    [CompilationMappingAttribute]
internal static FSharpList`1<object> next@1224 { get; internal set; }
    [CompilationMappingAttribute]
internal static Dictionary`2<ValueTuple`3<bool, Type, Type>, object> uniformCache { get; }
    [CompilationMappingAttribute]
internal static Dictionary`2<Type, object> idFunctions { get; }
    internal static FSharpList`1<object> get_integralConversions();
    internal static FSharpList`1<object> get_fractionalConversions();
    internal static FSharpList`1<object> get_booleanConversions();
    internal static FSharpList`1<object> get_vector2Conversions();
    internal static FSharpList`1<object> get_vector3Conversions();
    internal static FSharpList`1<object> get_vector4Conversions();
    internal static FSharpList`1<object> get_matrix22Conversions();
    internal static FSharpList`1<object> get_matrix23Conversions();
    internal static FSharpList`1<object> get_matrix33Conversions();
    internal static FSharpList`1<object> get_matrix34Conversions();
    internal static FSharpList`1<object> get_matrix44Conversions();
    internal static FSharpList`1<object> get_colorConversions();
    internal static FSharpList`1<object> get_specialConversions();
    internal static FSharpList`1<object> get_allConversions();
    internal static FSharpList`1<object> get_transposeFunctions();
    internal static ConversionMapping`1<object> createCompiledMap(FSharpList`1<object> conversions);
    internal static ConversionMapping`1<object> get_mapping();
    internal static ConcurrentDictionary`2<Type, object> get_transposeMapping();
    internal static ConcurrentDictionary`2<Type, object> get_dict@1223();
    internal static FSharpList`1<object> get_current@1224();
    internal static void set_current@1224(FSharpList`1<object> value);
    internal static FSharpList`1<object> get_next@1224();
    internal static void set_next@1224(FSharpList`1<object> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpValueOption`1<object> tryGetConverterV(Type inType, Type outType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<object> tryGetConverter(Type inType, Type outType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static object getConverter(Type inType, Type outType);
    public static void addConverters(a converters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static object convert(Type outType, object value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<Array, Array> getArrayConverter(Type inputType, Type outputType);
    internal static Dictionary`2<ValueTuple`3<bool, Type, Type>, object> get_uniformCache();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static object getUniformConverter(bool transpose, Type inType, Type outType);
    internal static Dictionary`2<Type, object> get_idFunctions();
    public static object getIdentityConverter(Type t);
    public static object getTransposeConverter(Type t);
    public static bool isTransposable(Type t);
    public static FSharpFunc`2<a, b> converter();
    public static FSharpFunc`2<Array, a[]> arrayConverter(Type inputType);
    public static FSharpFunc`2<a, b> uniformConverter(bool transpose);
    public static FSharpFunc`2<a, a> transpose();
    public static bool transposable();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Printf : object {
    public static a formatf(PrintfFormat`4<a, Unit, StringFormat, StringFormat> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a kformatf(FSharpFunc`2<StringFormat, res> f, PrintfFormat`4<a, Unit, StringFormat, res> fmt);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Aardvark.Base.PtrArgument : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPtr64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPtr32 { get; }
    [CompilationMappingAttribute]
public static PtrArgument NewPtr64(IntPtr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPtr64();
    [CompilationMappingAttribute]
public static PtrArgument NewPtr32(IntPtr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPtr32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PtrArgument obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(PtrArgument obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PtrArgument obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.QuotationReflectionHelpers : object {
    public static FSharpOption`1<MethodInfo> tryGetMethodInfo(FSharpExpr e);
    public static MethodInfo getMethodInfo(FSharpExpr e);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Quotations.QuotationDisassembler : object {
    [DebuggerBrowsableAttribute("0")]
internal static T231218_453Bytes@ field231219@;
    [DebuggerBrowsableAttribute("0")]
internal static T231220_462Bytes@ field231221@;
    [DebuggerBrowsableAttribute("0")]
internal static T231222_342Bytes@ field231223@;
    [DebuggerBrowsableAttribute("0")]
internal static T231224_349Bytes@ field231225@;
    [DebuggerBrowsableAttribute("0")]
internal static T231226_345Bytes@ field231227@;
    [DebuggerBrowsableAttribute("0")]
internal static T231228_352Bytes@ field231229@;
    [DebuggerBrowsableAttribute("0")]
internal static T231222_342Bytes@ field231230@;
    [DebuggerBrowsableAttribute("0")]
internal static T231231_344Bytes@ field231232@;
    [CompilationMappingAttribute]
internal static MethodInfo add { get; }
    [CompilationMappingAttribute]
internal static MethodInfo sub { get; }
    [CompilationMappingAttribute]
internal static MethodInfo less { get; }
    [CompilationMappingAttribute]
internal static MethodInfo lessEqual { get; }
    [CompilationMappingAttribute]
internal static MethodInfo greater { get; }
    [CompilationMappingAttribute]
internal static MethodInfo greaterEqual { get; }
    [CompilationMappingAttribute]
internal static MethodInfo equal { get; }
    [CompilationMappingAttribute]
internal static MethodInfo notEqual { get; }
    private static QuotationDisassembler();
    internal static MethodInfo get_add();
    internal static MethodInfo get_sub();
    internal static MethodInfo get_less();
    internal static MethodInfo get_lessEqual();
    internal static MethodInfo get_greater();
    internal static MethodInfo get_greaterEqual();
    internal static MethodInfo get_equal();
    internal static MethodInfo get_notEqual();
    public static FSharpExpr Expr.Add.Static(FSharpExpr l, FSharpExpr r);
    public static FSharpExpr Expr.Sub.Static(FSharpExpr l, FSharpExpr r);
    public static FSharpExpr Expr.Compare.Static(JumpCondition op, FSharpExpr l, FSharpExpr r);
    public static FSharpExpr Expr.NegatedCompare.Static(JumpCondition op, FSharpExpr l, FSharpExpr r);
    public static FSharpExpr Expr.Constant.Static(Constant c);
    internal static FSharpFunc`2<DisassemblerState, Tuple`2<DisassemblerState, FSharpExpr>> simulate(FSharpList`1<Instruction> code);
    internal static FSharpMap`2<Label, FSharpList`1<Instruction>> buildEntries@222(FSharpMap`2<Label, FSharpList`1<Instruction>> current, FSharpList`1<Instruction> code);
    public static FSharpExpr disassemble(MethodDefinition m);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.Quotations.QuotationDisassemblerTest : object {
    public static void run();
}
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Aardvark.Base.RangeSet1i : object {
    internal MapExt`2<int, HalfRangeKind> store;
    internal static RangeSet1i empty;
    internal static int init@38;
    public static RangeSet1i Empty { get; }
    internal MapExt`2<int, HalfRangeKind> Store { get; }
    internal bool HasMaxValue { get; }
    public int Min { get; }
    public int Max { get; }
    public Range1i Range { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    internal string AsString { get; }
    internal RangeSet1i(MapExt`2<int, HalfRangeKind> store);
    private static RangeSet1i();
    public static RangeSet1i get_Empty();
    internal MapExt`2<int, HalfRangeKind> get_Store();
    internal bool get_HasMaxValue();
    public int get_Min();
    public int get_Max();
    public Range1i get_Range();
    public RangeSet1i Add(Range1i r);
    public RangeSet1i Remove(Range1i r);
    public RangeSet1i Union(RangeSet1i other);
    public RangeSet1i Intersect(Range1i r);
    internal FSharpValueOption`1<int> TryFindLeftBoundary(int v);
    public bool Contains(int v);
    public bool Contains(Range1i r);
    public int get_Count();
    public bool get_IsEmpty();
    public Range1i[] ToArray();
    public FSharpList`1<Range1i> ToList();
    public IEnumerable`1<Range1i> ToSeq();
    internal bool Equals(RangeSet1i other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal string get_AsString();
    public virtual string ToString();
    public RangeSetEnumerator1i GetEnumerator();
    private virtual override bool System.IEquatable<Aardvark.Base.RangeSet1i>.Equals(RangeSet1i other);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<Range1i> System.Collections.Generic.IEnumerable<Aardvark.Base.Range1i>.GetEnumerator();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.RangeSet1iModule : object {
    [CompilationMappingAttribute]
public static RangeSet1i empty { get; }
    public static RangeSet1i get_empty();
    public static int min(RangeSet1i set);
    public static int max(RangeSet1i set);
    public static Range1i range(RangeSet1i set);
    internal static FSharpList`1<ValueTuple`2<int, HalfRangeKind>> getHalfRanges(Range1i r);
    internal static RangeSet1i ofRange(Range1i r);
    internal static RangeSet1i ofRanges(IEnumerable`1<Range1i> ranges);
    public static RangeSet1i ofList(FSharpList`1<Range1i> ranges);
    public static RangeSet1i ofArray(Range1i[] ranges);
    public static RangeSet1i ofSeq(IEnumerable`1<Range1i> ranges);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1i add(Range1i range, RangeSet1i set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1i remove(Range1i range, RangeSet1i set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1i union(RangeSet1i l, RangeSet1i r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1i intersect(Range1i range, RangeSet1i set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(int value, RangeSet1i set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool containsRange(Range1i range, RangeSet1i set);
    public static int count(RangeSet1i set);
    public static bool isEmpty(RangeSet1i set);
    public static IEnumerable`1<Range1i> toSeq(RangeSet1i set);
    public static FSharpList`1<Range1i> toList(RangeSet1i set);
    public static Range1i[] toArray(RangeSet1i set);
}
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Aardvark.Base.RangeSet1l : object {
    internal MapExt`2<long, HalfRangeKind> store;
    internal static RangeSet1l empty;
    internal static int init@932-2;
    public static RangeSet1l Empty { get; }
    internal MapExt`2<long, HalfRangeKind> Store { get; }
    internal bool HasMaxValue { get; }
    public long Min { get; }
    public long Max { get; }
    public Range1l Range { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    internal string AsString { get; }
    internal RangeSet1l(MapExt`2<long, HalfRangeKind> store);
    private static RangeSet1l();
    public static RangeSet1l get_Empty();
    internal MapExt`2<long, HalfRangeKind> get_Store();
    internal bool get_HasMaxValue();
    public long get_Min();
    public long get_Max();
    public Range1l get_Range();
    public RangeSet1l Add(Range1l r);
    public RangeSet1l Remove(Range1l r);
    public RangeSet1l Union(RangeSet1l other);
    public RangeSet1l Intersect(Range1l r);
    internal FSharpValueOption`1<long> TryFindLeftBoundary(long v);
    public bool Contains(long v);
    public bool Contains(Range1l r);
    public int get_Count();
    public bool get_IsEmpty();
    public Range1l[] ToArray();
    public FSharpList`1<Range1l> ToList();
    public IEnumerable`1<Range1l> ToSeq();
    internal bool Equals(RangeSet1l other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal string get_AsString();
    public virtual string ToString();
    public RangeSetEnumerator1l GetEnumerator();
    private virtual override bool System.IEquatable<Aardvark.Base.RangeSet1l>.Equals(RangeSet1l other);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<Range1l> System.Collections.Generic.IEnumerable<Aardvark.Base.Range1l>.GetEnumerator();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.RangeSet1lModule : object {
    [CompilationMappingAttribute]
public static RangeSet1l empty { get; }
    public static RangeSet1l get_empty();
    public static long min(RangeSet1l set);
    public static long max(RangeSet1l set);
    public static Range1l range(RangeSet1l set);
    internal static FSharpList`1<ValueTuple`2<long, HalfRangeKind>> getHalfRanges(Range1l r);
    internal static RangeSet1l ofRange(Range1l r);
    internal static RangeSet1l ofRanges(IEnumerable`1<Range1l> ranges);
    public static RangeSet1l ofList(FSharpList`1<Range1l> ranges);
    public static RangeSet1l ofArray(Range1l[] ranges);
    public static RangeSet1l ofSeq(IEnumerable`1<Range1l> ranges);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1l add(Range1l range, RangeSet1l set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1l remove(Range1l range, RangeSet1l set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1l union(RangeSet1l l, RangeSet1l r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1l intersect(Range1l range, RangeSet1l set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(long value, RangeSet1l set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool containsRange(Range1l range, RangeSet1l set);
    public static int count(RangeSet1l set);
    public static bool isEmpty(RangeSet1l set);
    public static IEnumerable`1<Range1l> toSeq(RangeSet1l set);
    public static FSharpList`1<Range1l> toList(RangeSet1l set);
    public static Range1l[] toArray(RangeSet1l set);
}
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Aardvark.Base.RangeSet1ui : object {
    internal MapExt`2<UInt32, HalfRangeKind> store;
    internal static RangeSet1ui empty;
    internal static int init@485-1;
    public static RangeSet1ui Empty { get; }
    internal MapExt`2<UInt32, HalfRangeKind> Store { get; }
    internal bool HasMaxValue { get; }
    public UInt32 Min { get; }
    public UInt32 Max { get; }
    public Range1ui Range { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    internal string AsString { get; }
    internal RangeSet1ui(MapExt`2<UInt32, HalfRangeKind> store);
    private static RangeSet1ui();
    public static RangeSet1ui get_Empty();
    internal MapExt`2<UInt32, HalfRangeKind> get_Store();
    internal bool get_HasMaxValue();
    public UInt32 get_Min();
    public UInt32 get_Max();
    public Range1ui get_Range();
    public RangeSet1ui Add(Range1ui r);
    public RangeSet1ui Remove(Range1ui r);
    public RangeSet1ui Union(RangeSet1ui other);
    public RangeSet1ui Intersect(Range1ui r);
    internal FSharpValueOption`1<UInt32> TryFindLeftBoundary(UInt32 v);
    public bool Contains(UInt32 v);
    public bool Contains(Range1ui r);
    public int get_Count();
    public bool get_IsEmpty();
    public Range1ui[] ToArray();
    public FSharpList`1<Range1ui> ToList();
    public IEnumerable`1<Range1ui> ToSeq();
    internal bool Equals(RangeSet1ui other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal string get_AsString();
    public virtual string ToString();
    public RangeSetEnumerator1ui GetEnumerator();
    private virtual override bool System.IEquatable<Aardvark.Base.RangeSet1ui>.Equals(RangeSet1ui other);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<Range1ui> System.Collections.Generic.IEnumerable<Aardvark.Base.Range1ui>.GetEnumerator();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.RangeSet1uiModule : object {
    [CompilationMappingAttribute]
public static RangeSet1ui empty { get; }
    public static RangeSet1ui get_empty();
    public static UInt32 min(RangeSet1ui set);
    public static UInt32 max(RangeSet1ui set);
    public static Range1ui range(RangeSet1ui set);
    internal static FSharpList`1<ValueTuple`2<UInt32, HalfRangeKind>> getHalfRanges(Range1ui r);
    internal static RangeSet1ui ofRange(Range1ui r);
    internal static RangeSet1ui ofRanges(IEnumerable`1<Range1ui> ranges);
    public static RangeSet1ui ofList(FSharpList`1<Range1ui> ranges);
    public static RangeSet1ui ofArray(Range1ui[] ranges);
    public static RangeSet1ui ofSeq(IEnumerable`1<Range1ui> ranges);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1ui add(Range1ui range, RangeSet1ui set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1ui remove(Range1ui range, RangeSet1ui set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1ui union(RangeSet1ui l, RangeSet1ui r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1ui intersect(Range1ui range, RangeSet1ui set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(UInt32 value, RangeSet1ui set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool containsRange(Range1ui range, RangeSet1ui set);
    public static int count(RangeSet1ui set);
    public static bool isEmpty(RangeSet1ui set);
    public static IEnumerable`1<Range1ui> toSeq(RangeSet1ui set);
    public static FSharpList`1<Range1ui> toList(RangeSet1ui set);
    public static Range1ui[] toArray(RangeSet1ui set);
}
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Aardvark.Base.RangeSet1ul : object {
    internal MapExt`2<ulong, HalfRangeKind> store;
    internal static RangeSet1ul empty;
    internal static int init@1379-3;
    public static RangeSet1ul Empty { get; }
    internal MapExt`2<ulong, HalfRangeKind> Store { get; }
    internal bool HasMaxValue { get; }
    public ulong Min { get; }
    public ulong Max { get; }
    public Range1ul Range { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    internal string AsString { get; }
    internal RangeSet1ul(MapExt`2<ulong, HalfRangeKind> store);
    private static RangeSet1ul();
    public static RangeSet1ul get_Empty();
    internal MapExt`2<ulong, HalfRangeKind> get_Store();
    internal bool get_HasMaxValue();
    public ulong get_Min();
    public ulong get_Max();
    public Range1ul get_Range();
    public RangeSet1ul Add(Range1ul r);
    public RangeSet1ul Remove(Range1ul r);
    public RangeSet1ul Union(RangeSet1ul other);
    public RangeSet1ul Intersect(Range1ul r);
    internal FSharpValueOption`1<ulong> TryFindLeftBoundary(ulong v);
    public bool Contains(ulong v);
    public bool Contains(Range1ul r);
    public int get_Count();
    public bool get_IsEmpty();
    public Range1ul[] ToArray();
    public FSharpList`1<Range1ul> ToList();
    public IEnumerable`1<Range1ul> ToSeq();
    internal bool Equals(RangeSet1ul other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal string get_AsString();
    public virtual string ToString();
    public RangeSetEnumerator1ul GetEnumerator();
    private virtual override bool System.IEquatable<Aardvark.Base.RangeSet1ul>.Equals(RangeSet1ul other);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<Range1ul> System.Collections.Generic.IEnumerable<Aardvark.Base.Range1ul>.GetEnumerator();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.RangeSet1ulModule : object {
    [CompilationMappingAttribute]
public static RangeSet1ul empty { get; }
    public static RangeSet1ul get_empty();
    public static ulong min(RangeSet1ul set);
    public static ulong max(RangeSet1ul set);
    public static Range1ul range(RangeSet1ul set);
    internal static FSharpList`1<ValueTuple`2<ulong, HalfRangeKind>> getHalfRanges(Range1ul r);
    internal static RangeSet1ul ofRange(Range1ul r);
    internal static RangeSet1ul ofRanges(IEnumerable`1<Range1ul> ranges);
    public static RangeSet1ul ofList(FSharpList`1<Range1ul> ranges);
    public static RangeSet1ul ofArray(Range1ul[] ranges);
    public static RangeSet1ul ofSeq(IEnumerable`1<Range1ul> ranges);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1ul add(Range1ul range, RangeSet1ul set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1ul remove(Range1ul range, RangeSet1ul set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1ul union(RangeSet1ul l, RangeSet1ul r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RangeSet1ul intersect(Range1ul range, RangeSet1ul set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(ulong value, RangeSet1ul set);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool containsRange(Range1ul range, RangeSet1ul set);
    public static int count(RangeSet1ul set);
    public static bool isEmpty(RangeSet1ul set);
    public static IEnumerable`1<Range1ul> toSeq(RangeSet1ul set);
    public static FSharpList`1<Range1ul> toList(RangeSet1ul set);
    public static Range1ul[] toArray(RangeSet1ul set);
}
[CompilationMappingAttribute]
public class Aardvark.Base.RangeSetEnumerator1i : ValueType {
    internal IEnumerator`1<KeyValuePair`2<int, HalfRangeKind>> Inner@;
    internal KeyValuePair`2<int, HalfRangeKind> Left;
    internal KeyValuePair`2<int, HalfRangeKind> Right;
    [CompilationMappingAttribute]
internal IEnumerator`1<KeyValuePair`2<int, HalfRangeKind>> Inner { get; }
    public Range1i Current { get; }
    internal RangeSetEnumerator1i(IEnumerator`1<KeyValuePair`2<int, HalfRangeKind>> inner);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IEnumerator`1<KeyValuePair`2<int, HalfRangeKind>> get_Inner();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(RangeSetEnumerator1i obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool MoveNext();
    public void Reset();
    public Range1i get_Current();
    public void Dispose();
    private virtual override bool System.Collections.IEnumerator.MoveNext();
    private virtual override object System.Collections.IEnumerator.get_Current();
    private virtual override void System.Collections.IEnumerator.Reset();
    private virtual override void System.IDisposable.Dispose();
    private virtual override Range1i System.Collections.Generic.IEnumerator<Aardvark.Base.Range1i>.get_Current();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RangeSetEnumerator1i obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Aardvark.Base.RangeSetEnumerator1l : ValueType {
    internal IEnumerator`1<KeyValuePair`2<long, HalfRangeKind>> Inner@;
    internal KeyValuePair`2<long, HalfRangeKind> Left;
    internal KeyValuePair`2<long, HalfRangeKind> Right;
    [CompilationMappingAttribute]
internal IEnumerator`1<KeyValuePair`2<long, HalfRangeKind>> Inner { get; }
    public Range1l Current { get; }
    internal RangeSetEnumerator1l(IEnumerator`1<KeyValuePair`2<long, HalfRangeKind>> inner);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IEnumerator`1<KeyValuePair`2<long, HalfRangeKind>> get_Inner();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(RangeSetEnumerator1l obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool MoveNext();
    public void Reset();
    public Range1l get_Current();
    public void Dispose();
    private virtual override bool System.Collections.IEnumerator.MoveNext();
    private virtual override object System.Collections.IEnumerator.get_Current();
    private virtual override void System.Collections.IEnumerator.Reset();
    private virtual override void System.IDisposable.Dispose();
    private virtual override Range1l System.Collections.Generic.IEnumerator<Aardvark.Base.Range1l>.get_Current();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RangeSetEnumerator1l obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Aardvark.Base.RangeSetEnumerator1ui : ValueType {
    internal IEnumerator`1<KeyValuePair`2<UInt32, HalfRangeKind>> Inner@;
    internal KeyValuePair`2<UInt32, HalfRangeKind> Left;
    internal KeyValuePair`2<UInt32, HalfRangeKind> Right;
    [CompilationMappingAttribute]
internal IEnumerator`1<KeyValuePair`2<UInt32, HalfRangeKind>> Inner { get; }
    public Range1ui Current { get; }
    internal RangeSetEnumerator1ui(IEnumerator`1<KeyValuePair`2<UInt32, HalfRangeKind>> inner);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IEnumerator`1<KeyValuePair`2<UInt32, HalfRangeKind>> get_Inner();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(RangeSetEnumerator1ui obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool MoveNext();
    public void Reset();
    public Range1ui get_Current();
    public void Dispose();
    private virtual override bool System.Collections.IEnumerator.MoveNext();
    private virtual override object System.Collections.IEnumerator.get_Current();
    private virtual override void System.Collections.IEnumerator.Reset();
    private virtual override void System.IDisposable.Dispose();
    private virtual override Range1ui System.Collections.Generic.IEnumerator<Aardvark.Base.Range1ui>.get_Current();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RangeSetEnumerator1ui obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Aardvark.Base.RangeSetEnumerator1ul : ValueType {
    internal IEnumerator`1<KeyValuePair`2<ulong, HalfRangeKind>> Inner@;
    internal KeyValuePair`2<ulong, HalfRangeKind> Left;
    internal KeyValuePair`2<ulong, HalfRangeKind> Right;
    [CompilationMappingAttribute]
internal IEnumerator`1<KeyValuePair`2<ulong, HalfRangeKind>> Inner { get; }
    public Range1ul Current { get; }
    internal RangeSetEnumerator1ul(IEnumerator`1<KeyValuePair`2<ulong, HalfRangeKind>> inner);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IEnumerator`1<KeyValuePair`2<ulong, HalfRangeKind>> get_Inner();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(RangeSetEnumerator1ul obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool MoveNext();
    public void Reset();
    public Range1ul get_Current();
    public void Dispose();
    private virtual override bool System.Collections.IEnumerator.MoveNext();
    private virtual override object System.Collections.IEnumerator.get_Current();
    private virtual override void System.Collections.IEnumerator.Reset();
    private virtual override void System.IDisposable.Dispose();
    private virtual override Range1ul System.Collections.Generic.IEnumerator<Aardvark.Base.Range1ul>.get_Current();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RangeSetEnumerator1ul obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal static class Aardvark.Base.RangeSetUtils : object {
    internal static ValueTuple`2<T, bool> inc(T value);
    internal static ValueTuple`2<T, bool> inc$W(FSharpFunc`2<Unit, T> get_One, FSharpFunc`2<T, FSharpFunc`2<T, T>> op_Addition, T value);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.ReaderWriterLock : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a read(ReaderWriterLockSlim l, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a write(ReaderWriterLockSlim l, FSharpFunc`2<Unit, a> f);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.RealNumber : object {
    [CompilationMappingAttribute]
public static IReal zero { get; }
    [CompilationMappingAttribute]
internal static SortKey root@971 { get; }
    public static IReal get_zero();
    internal static SortKey get_root@971();
    public static IReal after(IReal k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IReal between(IReal l, IReal r);
}
[CompilationMappingAttribute]
public class Aardvark.Base.ReferenceCountingSet`1 : object {
    internal int nullCount;
    internal int version;
    internal Dictionary`2<object, ValueTuple`2<a, FSharpRef`1<int>>> store;
    internal int Version { get; }
    internal Dictionary`2<object, ValueTuple`2<a, FSharpRef`1<int>>> Store { get; }
    internal int NullCount { get; }
    public int Count { get; }
    public ReferenceCountingSet`1(IEnumerable`1<a> initial);
    internal int get_Version();
    internal Dictionary`2<object, ValueTuple`2<a, FSharpRef`1<int>>> get_Store();
    internal int get_NullCount();
    internal void SetTo(ReferenceCountingSet`1<a> other);
    internal FSharpList`1<SetOperation`1<a>> Apply(FSharpList`1<SetOperation`1<a>> deltas);
    public bool Add(a v);
    public bool Remove(a v);
    public bool Contains(a v);
    public void Clear();
    public int get_Count();
    public int GetReferenceCount(a v);
    public void ExceptWith(IEnumerable`1<a> items);
    public void UnionWith(IEnumerable`1<a> other);
    public void IntersectWith(IEnumerable`1<a> other);
    public void SymmetricExceptWith(IEnumerable`1<a> other);
    public bool IsSubsetOf(IEnumerable`1<a> other);
    public bool IsSupersetOf(IEnumerable`1<a> other);
    public bool IsProperSubsetOf(IEnumerable`1<a> other);
    public bool IsProperSupersetOf(IEnumerable`1<a> other);
    public bool Overlaps(IEnumerable`1<a> other);
    public bool SetEquals(IEnumerable`1<a> other);
    public ReferenceCountingSetEnumerator`1<a> GetEnumerator();
    private virtual override void System.Collections.Generic.ICollection<'a>.Add(a v);
    private virtual override bool System.Collections.Generic.ICollection<'a>.Remove(a v);
    private virtual override void System.Collections.Generic.ICollection<'a>.Clear();
    private virtual override int System.Collections.Generic.ICollection<'a>.get_Count();
    private virtual override void System.Collections.Generic.ICollection<'a>.CopyTo(a[] arr, int index);
    private virtual override bool System.Collections.Generic.ICollection<'a>.get_IsReadOnly();
    private virtual override bool System.Collections.Generic.ICollection<'a>.Contains(a v);
    private virtual override bool System.Collections.Generic.ISet<'a>.Add(a item);
    private virtual override void System.Collections.Generic.ISet<'a>.ExceptWith(IEnumerable`1<a> other);
    private virtual override void System.Collections.Generic.ISet<'a>.IntersectWith(IEnumerable`1<a> other);
    private virtual override void System.Collections.Generic.ISet<'a>.UnionWith(IEnumerable`1<a> other);
    private virtual override void System.Collections.Generic.ISet<'a>.SymmetricExceptWith(IEnumerable`1<a> other);
    private virtual override bool System.Collections.Generic.ISet<'a>.IsProperSubsetOf(IEnumerable`1<a> other);
    private virtual override bool System.Collections.Generic.ISet<'a>.IsProperSupersetOf(IEnumerable`1<a> other);
    private virtual override bool System.Collections.Generic.ISet<'a>.IsSubsetOf(IEnumerable`1<a> other);
    private virtual override bool System.Collections.Generic.ISet<'a>.IsSupersetOf(IEnumerable`1<a> other);
    private virtual override bool System.Collections.Generic.ISet<'a>.Overlaps(IEnumerable`1<a> other);
    private virtual override bool System.Collections.Generic.ISet<'a>.SetEquals(IEnumerable`1<a> other);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<a> System.Collections.Generic.IEnumerable<'a>.GetEnumerator();
    [CompilerGeneratedAttribute]
internal void hasChanged();
    [CompilerGeneratedAttribute]
internal ICollection`1<a> toCollection(IEnumerable`1<a> s);
    [CompilerGeneratedAttribute]
internal Tuple`3<int, int, int> compareSeq(IEnumerable`1<a> other);
    [CompilerGeneratedAttribute]
internal bool add(a v);
    [CompilerGeneratedAttribute]
internal bool remove(a v);
}
[CompilationMappingAttribute]
public class Aardvark.Base.ReferenceCountingSetEnumerator`1 : ValueType {
    internal bool containsNull;
    internal bool emitNull;
    internal bool currentIsNull;
    internal Enumerator<object, ValueTuple`2<a, FSharpRef`1<int>>> e;
    public a Current { get; }
    internal ReferenceCountingSetEnumerator`1(bool containsNull, Dictionary`2<object, ValueTuple`2<a, FSharpRef`1<int>>> store);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(ReferenceCountingSetEnumerator`1<a> obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public a get_Current();
    public bool MoveNext();
    private virtual override bool System.Collections.IEnumerator.MoveNext();
    private virtual override void System.Collections.IEnumerator.Reset();
    private virtual override object System.Collections.IEnumerator.get_Current();
    private virtual override a System.Collections.Generic.IEnumerator<'a>.get_Current();
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReferenceCountingSetEnumerator`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ExtensionAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.ReflectionHelpers : object {
    [CompilationMappingAttribute]
internal static object lockObj { get; }
    [CompilationMappingAttribute]
internal static Dict`2<Type, string> prettyNames { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Tuple`2<Type, string>> elements@201-22 { get; }
    [CompilationMappingAttribute]
internal static IEnumerable`1<Tuple`2<Type, string>> elements@189-23 { get; }
    [CompilationMappingAttribute]
internal static Dict`2<Type, string> result@190-9 { get; }
    [CompilationMappingAttribute]
internal static IEnumerator`1<Tuple`2<Type, string>> enumerator@191-9 { get; }
    [CompilationMappingAttribute]
internal static Dict`2<Type, string> genericPrettyNames { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Tuple`2<Type, string>> elements@201-24 { get; }
    [CompilationMappingAttribute]
internal static Type ty@1 { get; }
    [CompilationMappingAttribute]
internal static Type ty@1-1 { get; }
    [CompilationMappingAttribute]
internal static Type ty@1-2 { get; }
    [CompilationMappingAttribute]
internal static Type ty@1-3 { get; }
    [CompilationMappingAttribute]
internal static Type ty@1-4 { get; }
    [CompilationMappingAttribute]
internal static IEnumerable`1<Tuple`2<Type, string>> elements@189-25 { get; }
    [CompilationMappingAttribute]
internal static Dict`2<Type, string> result@190-10 { get; }
    [CompilationMappingAttribute]
internal static IEnumerator`1<Tuple`2<Type, string>> enumerator@191-10 { get; }
    [CompilationMappingAttribute]
internal static Regex idRx { get; }
    internal static object get_lockObj();
    internal static Dict`2<Type, string> get_prettyNames();
    internal static FSharpList`1<Tuple`2<Type, string>> get_elements@201-22();
    internal static IEnumerable`1<Tuple`2<Type, string>> get_elements@189-23();
    internal static Dict`2<Type, string> get_result@190-9();
    internal static IEnumerator`1<Tuple`2<Type, string>> get_enumerator@191-9();
    internal static Dict`2<Type, string> get_genericPrettyNames();
    internal static FSharpList`1<Tuple`2<Type, string>> get_elements@201-24();
    internal static Type get_ty@1();
    internal static Type get_ty@1-1();
    internal static Type get_ty@1-2();
    internal static Type get_ty@1-3();
    internal static Type get_ty@1-4();
    internal static IEnumerable`1<Tuple`2<Type, string>> get_elements@189-25();
    internal static Dict`2<Type, string> get_result@190-10();
    internal static IEnumerator`1<Tuple`2<Type, string>> get_enumerator@191-10();
    internal static Regex get_idRx();
    internal static string getPrettyNameInternal(Type t);
    [ExtensionAttribute]
[CompilationSourceNameAttribute("getPrettyName")]
public static string GetPrettyName(Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string Type.get_PrettyName(Type );
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.ReflectionPatterns : object {
    [CompilationMappingAttribute]
internal static Regex typePrefixPattern { get; }
    internal static Regex get_typePrefixPattern();
    public static Tuple`2<string, FSharpList`1<Type>> |Method|(MethodInfo mi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<FSharpList`1<Type>> compareMethods(MethodInfo template, MethodInfo m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpValueOption`1<FSharpList`1<Type>> |MethodQuote|_|(FSharpExpr e, MethodInfo mi);
    public static Tuple`2<Type, FSharpList`1<ParameterInfo>> |Create|(ConstructorInfo c);
}
[AttributeUsageAttribute("76")]
[CompilationMappingAttribute]
public class Aardvark.Base.RuleAttribute : Attribute {
}
[CompilationMappingAttribute]
public static class Aardvark.Base.RuntimeMethodBuilder : object {
    [CompilationMappingAttribute]
internal static AssemblyBuilder bAss { get; }
    [CompilationMappingAttribute]
internal static ModuleBuilder bMod { get; }
    internal static AssemblyBuilder get_bAss();
    internal static ModuleBuilder get_bMod();
    [CompilerGeneratedAttribute]
internal static LocalBuilder initializer@1(ILGenerator il, int i);
    [CompilerGeneratedAttribute]
internal static LocalBuilder initializer@1-1(ILGenerator il, int i);
    internal static FSharpOption`1[] createTable@353(MultimethodImpl this, IntPtr minId, int size);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static MultimethodImpl inlineCache(int argCount, FSharpFunc`2<Type[], FSharpOption`1<Tuple`2<object, MethodInfo>>> f);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.SimpleOrder : object {
    internal static ulong distance@103(SortKey a, SortKey b);
    public static Order create();
}
[DefaultMemberAttribute("Item")]
[CompilationMappingAttribute]
public class Aardvark.Base.SkipList`1 : object {
    internal FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp;
    internal Link`1[] root;
    internal int count;
    internal static Random random;
    internal static int init@33;
    public a Item { get; }
    public int Count { get; }
    public SkipList`1(FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp);
    private static SkipList`1();
    public bool Add(a v);
    public bool Remove(a v);
    public void Clear();
    public bool RemoveAt(int index);
    public FSharpOption`1<a> TryAt(int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public bool Contains(a v, SkipList`1<a> l);
    public a get_Item(int index);
    public int get_Count();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<a> System.Collections.Generic.IEnumerable<'a>.GetEnumerator();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static void resize(int height, Link`1[]& root);
    [CompilerGeneratedAttribute]
internal static int randomHeight();
    [CompilerGeneratedAttribute]
internal static Node`1<a> newNode(a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static Tuple`2<int, FSharpList`1<Tuple`2<int, Node`1<a>>>> findPrev(FSharpList`1<Tuple`2<int, Node`1<a>>> acc, FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp, int index, int level, a v, Node`1<a> n, Link`1[] links);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static Tuple`2<int, FSharpList`1<Tuple`2<int, Node`1<a>>>> findPrevIndex(FSharpList`1<Tuple`2<int, Node`1<a>>> acc, int currentIndex, int level, int id, Node`1<a> n, Link`1[] links);
    [CompilerGeneratedAttribute]
internal void print(SkipList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void removePtr(FSharpList`1<Tuple`2<int, Node`1<a>>> prev, Node`1<a> n);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<a> toSeq();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.SkipListModule : object {
    public static SkipList`1<a> empty();
    public static SkipList`1<a> custom(FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp);
    public static int count(SkipList`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool add(a v, SkipList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(a v, SkipList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool removeAt(int index, SkipList`1<a> l);
    public static void clear(SkipList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> at(int index, SkipList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<SkipList`1<a>, bool> contains(a v, SkipList`1<a> l);
    public static SkipList`1<a> ofSeq(IEnumerable`1<a> s);
    public static SkipList`1<a> ofList(FSharpList`1<a> l);
    public static SkipList`1<a> ofArray(a[] a);
    public static IEnumerable`1<a> toSeq(SkipList`1<a> s);
    public static FSharpList`1<a> toList(SkipList`1<a> s);
    public static a[] toArray(SkipList`1<a> s);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.SkipOrder : object {
    [CompilationMappingAttribute]
internal static Random random { get; }
    internal static Random get_random();
    public static int randomHeight();
    internal static ulong distance@262-1(SortKey a, SortKey b);
    internal static void resize@303(Order x, int h);
    internal static Tuple`2<int, SortKey> back@310(SortKey n);
    internal static Tuple`2<int, SortKey> back@378-1(SortKey n);
    internal static FSharpOption`1<SortKey> search@422-1(int index, int level, SortKey t);
    public static Order create();
}
[DefaultMemberAttribute("Item")]
[CompilationMappingAttribute]
public class Aardvark.Base.SortedDictionaryExt`2 : object {
    internal SortedSetExt`1<Tuple`2<k, FSharpRef`1<v>>> set;
    internal SortedSetExt`1<Tuple`2<k, FSharpRef`1<v>>> Set { get; }
    public int Count { get; }
    public v Item { get; public set; }
    internal SortedDictionaryExt`2(IComparer`1<Tuple`2<k, FSharpRef`1<v>>> comparer);
    public SortedDictionaryExt`2(FSharpFunc`2<k, FSharpFunc`2<k, int>> cmp);
    public SortedDictionaryExt`2(IComparer`1<k> comparer);
    internal SortedSetExt`1<Tuple`2<k, FSharpRef`1<v>>> get_Set();
    public bool TryGetValue(k key, v& result);
    public int get_Count();
    public void Add(k key, v value);
    public bool Remove(k key);
    public void Clear();
    public bool ContainsKey(k key);
    public v get_Item(k key);
    public void set_Item(k key, v value);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<KeyValuePair`2<k, v>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<'k, 'v>>.GetEnumerator();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.SortedDictionaryModule : object {
    internal static FSharpOption`1<Tuple`2<k, FSharpRef`1<v>>> optionalToOpt(Optional`1<Tuple`2<k, FSharpRef`1<v>>> o);
    internal static FSharpOption`1<Tuple`2<k, v>> optionalToOptValue(Optional`1<Tuple`2<k, FSharpRef`1<v>>> o);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpOption`1<Tuple`2<k, v>>, FSharpOption`1<FSharpRef`1<v>>, FSharpOption`1<Tuple`2<k, v>>> neighbourhoodInt(k key, SortedDictionaryExt`2<k, v> s);
    public static SortedDictionaryExt`2<k, v> empty();
    public static SortedDictionaryExt`2<k, v> custom(FSharpFunc`2<k, FSharpFunc`2<k, int>> cmp);
    public static int count(SortedDictionaryExt`2<k, v> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void add(k key, v value, SortedDictionaryExt`2<k, v> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(k key, SortedDictionaryExt`2<k, v> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<v> tryFind(k key, SortedDictionaryExt`2<k, v> s);
    public static void clear(SortedDictionaryExt`2<k, v> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<FSharpOption`1<Tuple`2<k, v>>, FSharpOption`1<v>, FSharpOption`1<Tuple`2<k, v>>> neighbourhood(k key, SortedDictionaryExt`2<k, v> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static v setWithNeighbours(k key, FSharpFunc`2<FSharpOption`1<Tuple`2<k, v>>, FSharpFunc`2<FSharpOption`1<v>, FSharpFunc`2<FSharpOption`1<Tuple`2<k, v>>, v>>> f, SortedDictionaryExt`2<k, v> s);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.SortedList : object {
    internal static Measure`2<a, FSharpOption`1<a>> mm();
    internal static Comparer`1<a> cmp();
    public static SortedList`1<a> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SortedList`1<a> add(a v, SortedList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SortedList`1<a> remove(a v, SortedList`1<a> l);
    public static SortedList`1<a> ofSeq(IEnumerable`1<a> s);
    public static SortedList`1<a> ofList(FSharpList`1<a> l);
    public static SortedList`1<a> ofArray(a[] l);
    public static IEnumerable`1<a> toSeq(SortedList`1<a> a);
    public static FSharpList`1<a> toList(SortedList`1<a> a);
    public static a[] toArray(SortedList`1<a> a);
    public static FSharpOption`1<a> maxOpt(SortedList`1<a> l);
    public static FSharpOption`1<a> minOpt(SortedList`1<a> l);
    public static a max(SortedList`1<a> l);
    public static a min(SortedList`1<a> l);
    public static FSharpOption`1<Tuple`2<a, SortedList`1<a>>> viewl(SortedList`1<a> a);
    public static FSharpOption`1<Tuple`2<a, SortedList`1<a>>> viewr(SortedList`1<a> a);
}
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Aardvark.Base.SortedList`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FingerTreeNode`2<a, FSharpOption`1<a>> root@;
    [CompilationMappingAttribute]
internal FingerTreeNode`2<a, FSharpOption`1<a>> root { get; }
    internal string AsString { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.SortedList`1")]
internal SortedList`1(FingerTreeNode`2<a, FSharpOption`1<a>> root);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FingerTreeNode`2<a, FSharpOption`1<a>> get_root();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SortedList`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal bool Equals(SortedList`1<a> obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal string get_AsString();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<a> System.Collections.Generic.IEnumerable<'a>.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SortedList`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal class Aardvark.Base.SortedMeasureImpl`1 : object {
    internal static Comparer`1<a> vcmp;
    internal static Measure`2<a, FSharpOption`1<a>> instance;
    internal static int init@849-1;
    internal static Measure`2<a, FSharpOption`1<a>> Instance { get; }
    internal static Comparer`1<a> ValueComparer { get; }
    private static SortedMeasureImpl`1();
    internal static Measure`2<a, FSharpOption`1<a>> get_Instance();
    internal static Comparer`1<a> get_ValueComparer();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.SortedSetModule : object {
    internal static FSharpOption`1<a> optionalToOpt(Optional`1<a> o);
    public static SortedSetExt`1<a> empty();
    public static SortedSetExt`1<a> cusom(FSharpFunc`2<a, FSharpFunc`2<a, int>> cmp);
    public static int count(SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool add(a value, SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(a value, SortedSetExt`1<a> s);
    public static void clear(SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(a value, SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void unionWith(IEnumerable`1<a> values, SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exceptWith(IEnumerable`1<a> values, SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void intersectWith(IEnumerable`1<a> values, SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void symmetricExceptWith(IEnumerable`1<a> values, SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<FSharpOption`1<a>, FSharpOption`1<a>, FSharpOption`1<a>> neighbourhood(a value, SortedSetExt`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void addWithNeighbours(a value, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<FSharpOption`1<a>, a>> f, SortedSetExt`1<a> s);
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[CompilationMappingAttribute]
internal class Aardvark.Base.SortKeyTuple : ValueType {
    internal ISortKey K0;
    internal ISortKey K1;
    public SortKeyTuple(ISortKey k0, ISortKey k1);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    private virtual override int System.IComparable.CompareTo(object o);
    private virtual override bool Aardvark.Base.IDeletableComparable.get_IsDeleted();
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public class Aardvark.Base.StableDict`2 : object {
    internal Dict`2<k, Linked`1<Tuple`2<k, v>>> content;
    internal Linked`1<Tuple`2<k, v>> first;
    internal Linked`1<Tuple`2<k, v>> last;
    public int Count { get; }
    public FSharpOption`1<Tuple`2<k, v>> First { get; }
    public FSharpOption`1<Tuple`2<k, v>> Last { get; }
    public int get_Count();
    public FSharpOption`1<Tuple`2<k, v>> get_First();
    public FSharpOption`1<Tuple`2<k, v>> get_Last();
    public bool ContainsKey(k v);
    public bool TryGetValue(k k, v& value);
    public bool TryAdd(k k, v value);
    public bool TryRemove(k k, v& value);
    public v GetOrAdd(k k, FSharpFunc`2<k, v> f);
    public bool Remove(k k);
    public FSharpOption`1<Tuple`2<k, v>> TryGetPrev(k v);
    public FSharpOption`1<Tuple`2<k, v>> TryGetNext(k v);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<Tuple`2<k, v>> System.Collections.Generic.IEnumerable<System.Tuple<'k, 'v>>.GetEnumerator();
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public class Aardvark.Base.StableSet`1 : object {
    internal Dict`2<a, Linked`1<a>> content;
    internal Linked`1<a> first;
    internal Linked`1<a> last;
    public int Count { get; }
    public FSharpOption`1<a> First { get; }
    public FSharpOption`1<a> Last { get; }
    public int get_Count();
    public FSharpOption`1<a> get_First();
    public FSharpOption`1<a> get_Last();
    public bool Contains(a v);
    public void Clear();
    public bool Add(a v);
    public bool Remove(a v);
    public void UnionWith(IEnumerable`1<a> s);
    public void ExeptWith(IEnumerable`1<a> s);
    public FSharpOption`1<a> TryGetPrev(a v);
    public FSharpOption`1<a> TryGetNext(a v);
    public FSharpOption`1<a> AddWithPrev(FSharpFunc`2<FSharpOption`1<a>, a> f);
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override IEnumerator`1<a> System.Collections.Generic.IEnumerable<'a>.GetEnumerator();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Stopwatch Extensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static MicroTime TimeSpan.get_MicroTime(TimeSpan );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static MicroTime Stopwatch.get_MicroTime(Stopwatch );
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.StreamModule : object {
    public static Byte[] readAllBytes(Stream stream);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.String Extensions : object {
}
[SealedAttribute]
[ExtensionAttribute]
[CompilationMappingAttribute]
public class Aardvark.Base.StringExtensions : object {
    [ExtensionAttribute]
public static string NormalizeLineEndings(string str, string replacementText);
    [ExtensionAttribute]
public static string NormalizeLineEndings(string str);
}
[CompilationMappingAttribute]
public class Aardvark.Base.StringFormat : ValueType {
    public string Format;
    public Object[] Args;
    public StringFormat(string f, Object[] a);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(StringFormat obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringFormat obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.SymDictModule : object {
    public static SymbolDict`1<v> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void add(Symbol key, v value, SymbolDict`1<v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void set(Symbol key, v value, SymbolDict`1<v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool remove(Symbol key, SymbolDict`1<v> d);
    public static void clear(SymbolDict`1<v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SymbolDict`1<b> map(FSharpFunc`2<Symbol, FSharpFunc`2<a, b>> f, SymbolDict`1<a> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SymbolDict`1<a> mapKeys(FSharpFunc`2<Symbol, FSharpFunc`2<a, Symbol>> f, SymbolDict`1<a> d);
    public static SymbolDict`1<v> union(a dicts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(Symbol key, SymbolDict`1<v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<v> tryFind(Symbol key, SymbolDict`1<v> d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpValueOption`1<v> tryFindV(Symbol key, SymbolDict`1<v> d);
    public static SymbolDict`1<v> ofSeq(IEnumerable`1<Tuple`2<Symbol, v>> elements);
    public static SymbolDict`1<v> ofSeqV(IEnumerable`1<ValueTuple`2<Symbol, v>> elements);
    public static SymbolDict`1<v> ofList(FSharpList`1<Tuple`2<Symbol, v>> elements);
    public static SymbolDict`1<v> ofListV(FSharpList`1<ValueTuple`2<Symbol, v>> elements);
    public static SymbolDict`1<v> ofArray(Tuple`2[] elements);
    public static SymbolDict`1<v> ofArrayV(ValueTuple`2[] elements);
    public static SymbolDict`1<v> ofMap(FSharpMap`2<Symbol, v> elements);
    public static IEnumerable`1<Tuple`2<Symbol, v>> toSeq(SymbolDict`1<v> d);
    public static IEnumerable`1<ValueTuple`2<Symbol, v>> toSeqV(SymbolDict`1<v> d);
    public static FSharpList`1<Tuple`2<Symbol, v>> toList(SymbolDict`1<v> d);
    public static FSharpList`1<ValueTuple`2<Symbol, v>> toListV(SymbolDict`1<v> d);
    public static Tuple`2[] toArray(SymbolDict`1<v> d);
    public static ValueTuple`2[] toArrayV(SymbolDict`1<v> d);
    public static FSharpMap`2<Symbol, v> toMap(SymbolDict`1<v> elements);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.SymModule : object {
    [CompilationMappingAttribute]
public static Symbol empty { get; }
    public static Symbol get_empty();
    public static Symbol newGuid();
    public static Symbol ofString(string str);
    public static string toString(Symbol sym);
    public static Guid toGuid(Symbol sym);
    public static int id(Symbol sym);
    public static bool isEmpty(Symbol sym);
    public static bool isNotEmpty(Symbol sym);
    public static bool isPositive(Symbol sym);
    public static bool isNegative(Symbol sym);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Threading : object {
    public static Thread startThread(FSharpFunc`2<Unit, Unit> f);
    public static a Interlocked.Change.Static(a& location, FSharpFunc`2<a, a> f);
    public static b Interlocked.Change.Static(a& location, FSharpFunc`2<a, Tuple`2<a, b>> f);
    public static int Interlocked.Change.Static(Int32& location, FSharpFunc`2<int, int> f);
    public static b Interlocked.Change.Static(Int32& location, FSharpFunc`2<int, Tuple`2<int, b>> f);
    public static long Interlocked.Change.Static(Int64& location, FSharpFunc`2<long, long> f);
    public static b Interlocked.Change.Static(Int64& location, FSharpFunc`2<long, Tuple`2<long, b>> f);
}
[CompilationMappingAttribute]
public class Aardvark.Base.Traceable`2 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Monoid`1<ops> tops@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal s tempty@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<s, FSharpFunc`2<ops, Tuple`2<s, ops>>> tapply@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<s, FSharpFunc`2<s, ops>> tcompute@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<s, FSharpFunc`2<ops, bool>> tcollapse@;
    [CompilationMappingAttribute]
public Monoid`1<ops> tops { get; }
    [CompilationMappingAttribute]
public s tempty { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<s, FSharpFunc`2<ops, Tuple`2<s, ops>>> tapply { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<s, FSharpFunc`2<s, ops>> tcompute { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<s, FSharpFunc`2<ops, bool>> tcollapse { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.Traceable`2")]
public Traceable`2(Monoid`1<ops> tops, s tempty, FSharpFunc`2<s, FSharpFunc`2<ops, Tuple`2<s, ops>>> tapply, FSharpFunc`2<s, FSharpFunc`2<s, ops>> tcompute, FSharpFunc`2<s, FSharpFunc`2<ops, bool>> tcollapse);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Monoid`1<ops> get_tops();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public s get_tempty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<s, FSharpFunc`2<ops, Tuple`2<s, ops>>> get_tapply();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<s, FSharpFunc`2<s, ops>> get_tcompute();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<s, FSharpFunc`2<ops, bool>> get_tcollapse();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.TrafoModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Trafo inverseAux(z _arg1, Trafo t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Trafo inverseAux$W(FSharpFunc`2<Trafo, Trafo> inverse, z _arg1, Trafo t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Matrix forwardAux(z _arg1, Trafo t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Matrix forwardAux$W(FSharpFunc`2<Trafo, Matrix> forward, z _arg1, Trafo t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Matrix backwardAux(z _arg1, Trafo t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Matrix backwardAux$W(FSharpFunc`2<Trafo, Matrix> backward, z _arg1, Trafo t);
    public static Trafo inverse(Trafo t);
    public static Trafo inverse$W(FSharpFunc`2<Trafo, Trafo> inverse, Trafo t);
    public static Matrix forward(Trafo t);
    public static Matrix forward$W(FSharpFunc`2<Trafo, Matrix> forward, Trafo t);
    public static Matrix backward(Trafo t);
    public static Matrix backward$W(FSharpFunc`2<Trafo, Matrix> backward, Trafo t);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Aardvark.Base.Tree`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Tree`1<a> _unique_Empty;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Tree`1<a> Empty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNode { get; }
    private static Tree`1();
    [CompilationMappingAttribute]
public static Tree`1<a> get_Empty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEmpty();
    [CompilationMappingAttribute]
public static Tree`1<a> NewNode(int item1, FSharpList`1<Tuple`2<a, Tree`1<a>>> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Tree`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(Tree`1<a> obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Tree`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.TreeModule : object {
    public static bool isEmpty(Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tree`1<b> map(FSharpFunc`2<a, b> mapping, Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tree`1<a> filter(FSharpFunc`2<a, bool> predicate, Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static s foldEdges(FSharpFunc`2<s, FSharpFunc`2<a, s>> folder, s seed, Tree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static s foldNodes(FSharpFunc`2<s, FSharpFunc`2<int, s>> folder, s seed, Tree`1<a> t);
    public static int count(Tree`1<a> t);
    public static a weight(Tree`1<a> t);
    public static a weight$W(FSharpFunc`2<Unit, a> get_Zero, FSharpFunc`2<a, FSharpFunc`2<a, a>> op_Addition, Tree`1<a> t);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public interface Aardvark.Base.TrieReference`2 {
    public FSharpList`1<k> Key { get; }
    public FSharpValueOption`1<TrieReference`2<k, a>> Prev { get; }
    public FSharpValueOption`1<TrieReference`2<k, a>> Next { get; }
    public a Value { get; public set; }
    public abstract virtual FSharpList`1<k> get_Key();
    public abstract virtual FSharpValueOption`1<TrieReference`2<k, a>> get_Prev();
    public abstract virtual FSharpValueOption`1<TrieReference`2<k, a>> get_Next();
    public abstract virtual a get_Value();
    public abstract virtual void set_Value(a );
}
[ObsoleteAttribute("Use TypeMeta module instead.")]
[CompilationMappingAttribute]
public static class Aardvark.Base.TypeInfo : object {
    [CompilationMappingAttribute]
public static SimpleType TByte { get; }
    [CompilationMappingAttribute]
public static SimpleType TSByte { get; }
    [CompilationMappingAttribute]
public static SimpleType TInt16 { get; }
    [CompilationMappingAttribute]
public static SimpleType TUInt16 { get; }
    [CompilationMappingAttribute]
public static SimpleType TInt32 { get; }
    [CompilationMappingAttribute]
public static SimpleType TUInt32 { get; }
    [CompilationMappingAttribute]
public static SimpleType TInt64 { get; }
    [CompilationMappingAttribute]
public static SimpleType TUInt64 { get; }
    [CompilationMappingAttribute]
public static SimpleType TFloat32 { get; }
    [CompilationMappingAttribute]
public static SimpleType TFloat64 { get; }
    [CompilationMappingAttribute]
public static SimpleType TDecimal { get; }
    [CompilationMappingAttribute]
public static SimpleType TUnit { get; }
    [CompilationMappingAttribute]
public static SimpleType TChar { get; }
    [CompilationMappingAttribute]
public static SimpleType TString { get; }
    [CompilationMappingAttribute]
public static VectorType TV2i { get; }
    [CompilationMappingAttribute]
public static VectorType TV3i { get; }
    [CompilationMappingAttribute]
public static VectorType TV4i { get; }
    [CompilationMappingAttribute]
public static VectorType TV2ui { get; }
    [CompilationMappingAttribute]
public static VectorType TV3ui { get; }
    [CompilationMappingAttribute]
public static VectorType TV4ui { get; }
    [CompilationMappingAttribute]
public static VectorType TV2l { get; }
    [CompilationMappingAttribute]
public static VectorType TV3l { get; }
    [CompilationMappingAttribute]
public static VectorType TV4l { get; }
    [CompilationMappingAttribute]
public static VectorType TV2f { get; }
    [CompilationMappingAttribute]
public static VectorType TV3f { get; }
    [CompilationMappingAttribute]
public static VectorType TV4f { get; }
    [CompilationMappingAttribute]
public static VectorType TV2d { get; }
    [CompilationMappingAttribute]
public static VectorType TV3d { get; }
    [CompilationMappingAttribute]
public static VectorType TV4d { get; }
    [CompilationMappingAttribute]
public static VectorType TC3b { get; }
    [CompilationMappingAttribute]
public static VectorType TC3us { get; }
    [CompilationMappingAttribute]
public static VectorType TC3ui { get; }
    [CompilationMappingAttribute]
public static VectorType TC3f { get; }
    [CompilationMappingAttribute]
public static VectorType TC3d { get; }
    [CompilationMappingAttribute]
public static VectorType TC4b { get; }
    [CompilationMappingAttribute]
public static VectorType TC4us { get; }
    [CompilationMappingAttribute]
public static VectorType TC4ui { get; }
    [CompilationMappingAttribute]
public static VectorType TC4f { get; }
    [CompilationMappingAttribute]
public static VectorType TC4d { get; }
    [CompilationMappingAttribute]
public static MatrixType TM22i { get; }
    [CompilationMappingAttribute]
public static MatrixType TM23i { get; }
    [CompilationMappingAttribute]
public static MatrixType TM33i { get; }
    [CompilationMappingAttribute]
public static MatrixType TM34i { get; }
    [CompilationMappingAttribute]
public static MatrixType TM44i { get; }
    [CompilationMappingAttribute]
public static MatrixType TM22l { get; }
    [CompilationMappingAttribute]
public static MatrixType TM23l { get; }
    [CompilationMappingAttribute]
public static MatrixType TM33l { get; }
    [CompilationMappingAttribute]
public static MatrixType TM34l { get; }
    [CompilationMappingAttribute]
public static MatrixType TM44l { get; }
    [CompilationMappingAttribute]
public static MatrixType TM22f { get; }
    [CompilationMappingAttribute]
public static MatrixType TM23f { get; }
    [CompilationMappingAttribute]
public static MatrixType TM33f { get; }
    [CompilationMappingAttribute]
public static MatrixType TM34f { get; }
    [CompilationMappingAttribute]
public static MatrixType TM44f { get; }
    [CompilationMappingAttribute]
public static MatrixType TM22d { get; }
    [CompilationMappingAttribute]
public static MatrixType TM23d { get; }
    [CompilationMappingAttribute]
public static MatrixType TM33d { get; }
    [CompilationMappingAttribute]
public static MatrixType TM34d { get; }
    [CompilationMappingAttribute]
public static MatrixType TM44d { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<ITypeInfo> IntegralTypes { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<ITypeInfo> elements@1-16 { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<ITypeInfo> FractionalTypes { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<ITypeInfo> elements@1-17 { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<ITypeInfo> NumTypes { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<ITypeInfo> VectorTypes { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<ITypeInfo> elements@1-18 { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<ITypeInfo> ColorTypes { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<ITypeInfo> elements@1-19 { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<ITypeInfo> MatrixTypes { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<ITypeInfo> elements@1-20 { get; }
    [CompilationMappingAttribute]
public static SimpleType TRef { get; }
    [CompilationMappingAttribute]
public static SimpleType TList { get; }
    [CompilationMappingAttribute]
public static SimpleType TSeq { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<char> VectorFields { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<char> elements@1-21 { get; }
    public static SimpleType get_TByte();
    public static SimpleType get_TSByte();
    public static SimpleType get_TInt16();
    public static SimpleType get_TUInt16();
    public static SimpleType get_TInt32();
    public static SimpleType get_TUInt32();
    public static SimpleType get_TInt64();
    public static SimpleType get_TUInt64();
    public static SimpleType get_TFloat32();
    public static SimpleType get_TFloat64();
    public static SimpleType get_TDecimal();
    public static SimpleType get_TUnit();
    public static SimpleType get_TChar();
    public static SimpleType get_TString();
    public static VectorType get_TV2i();
    public static VectorType get_TV3i();
    public static VectorType get_TV4i();
    public static VectorType get_TV2ui();
    public static VectorType get_TV3ui();
    public static VectorType get_TV4ui();
    public static VectorType get_TV2l();
    public static VectorType get_TV3l();
    public static VectorType get_TV4l();
    public static VectorType get_TV2f();
    public static VectorType get_TV3f();
    public static VectorType get_TV4f();
    public static VectorType get_TV2d();
    public static VectorType get_TV3d();
    public static VectorType get_TV4d();
    public static VectorType get_TC3b();
    public static VectorType get_TC3us();
    public static VectorType get_TC3ui();
    public static VectorType get_TC3f();
    public static VectorType get_TC3d();
    public static VectorType get_TC4b();
    public static VectorType get_TC4us();
    public static VectorType get_TC4ui();
    public static VectorType get_TC4f();
    public static VectorType get_TC4d();
    public static MatrixType get_TM22i();
    public static MatrixType get_TM23i();
    public static MatrixType get_TM33i();
    public static MatrixType get_TM34i();
    public static MatrixType get_TM44i();
    public static MatrixType get_TM22l();
    public static MatrixType get_TM23l();
    public static MatrixType get_TM33l();
    public static MatrixType get_TM34l();
    public static MatrixType get_TM44l();
    public static MatrixType get_TM22f();
    public static MatrixType get_TM23f();
    public static MatrixType get_TM33f();
    public static MatrixType get_TM34f();
    public static MatrixType get_TM44f();
    public static MatrixType get_TM22d();
    public static MatrixType get_TM23d();
    public static MatrixType get_TM33d();
    public static MatrixType get_TM34d();
    public static MatrixType get_TM44d();
    public static FSharpSet`1<ITypeInfo> get_IntegralTypes();
    internal static FSharpList`1<ITypeInfo> get_elements@1-16();
    public static FSharpSet`1<ITypeInfo> get_FractionalTypes();
    internal static FSharpList`1<ITypeInfo> get_elements@1-17();
    public static FSharpSet`1<ITypeInfo> get_NumTypes();
    public static FSharpSet`1<ITypeInfo> get_VectorTypes();
    internal static FSharpList`1<ITypeInfo> get_elements@1-18();
    public static FSharpSet`1<ITypeInfo> get_ColorTypes();
    internal static FSharpList`1<ITypeInfo> get_elements@1-19();
    public static FSharpSet`1<ITypeInfo> get_MatrixTypes();
    internal static FSharpList`1<ITypeInfo> get_elements@1-20();
    public static SimpleType get_TRef();
    public static SimpleType get_TList();
    public static SimpleType get_TSeq();
    internal static ITypeInfo typeInfo(Type t);
    public static FSharpSet`1<char> get_VectorFields();
    internal static FSharpList`1<char> get_elements@1-21();
}
[CompilationMappingAttribute]
public static class Aardvark.Base.TypeMeta : object {
}
[CompilationMappingAttribute]
public class Aardvark.Base.UndirectedGraph`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<int> nodes@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal MapExt`2<int, MapExt`2<int, e>> adjacency@;
    [CompilationMappingAttribute]
public FSharpSet`1<int> nodes { get; }
    [CompilationMappingAttribute]
public MapExt`2<int, MapExt`2<int, e>> adjacency { get; }
    [DynamicDependencyAttribute("1632", "Aardvark.Base.UndirectedGraph`1")]
public UndirectedGraph`1(FSharpSet`1<int> nodes, MapExt`2<int, MapExt`2<int, e>> adjacency);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<int> get_nodes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public MapExt`2<int, MapExt`2<int, e>> get_adjacency();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(UndirectedGraph`1<e> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public bool Equals(UndirectedGraph`1<e> obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UndirectedGraph`1<e> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.UndirectedGraphModule : object {
    internal static void add@125-1(FSharpRef`1<MapExt`2<int, MapExt`2<int, e>>> adjacency, int li, int ri, e e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static UndirectedGraph`1<e> ofNodes(FSharpSet`1<int> nodes, FSharpFunc`2<int, FSharpFunc`2<int, FSharpOption`1<e>>> getEdge);
    internal static void add@148-4(FSharpRef`1<MapExt`2<int, MapExt`2<int, e>>> adjacency, int li, int ri, e e);
    public static UndirectedGraph`1<e> ofEdges(IEnumerable`1<Tuple`3<int, int, e>> edges);
    public static FSharpSet`1<int> toNodes(UndirectedGraph`1<e> g);
    public static FSharpList`1<Tuple`3<int, int, e>> toEdges(UndirectedGraph`1<e> g);
    internal static FSharpOption`1<Tree`1<e>> traverse@180(UndirectedGraph`1<e> g, FSharpRef`1<int> edgeCount, HashSet`1<int> visited, int n);
    public static Tree`1<e> spanningTree(UndirectedGraph`1<e> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tree`1<e> minimumSpanningTree(FSharpFunc`2<e, FSharpFunc`2<e, int>> cmp, UndirectedGraph`1<e> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tree`1<e> maximumSpanningTree(FSharpFunc`2<e, FSharpFunc`2<e, int>> cmp, UndirectedGraph`1<e> g);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.UnmanagedFunctions : object {
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<object, IntPtr> pointers { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<IntPtr, Delegate> methodCache { get; }
    internal static ConcurrentDictionary`2<object, IntPtr> get_pointers();
    internal static ConcurrentDictionary`2<IntPtr, Delegate> get_methodCache();
    [SuppressUnmanagedCodeSecurityAttribute]
public static a wrap(IntPtr executableMemory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object convert(object o, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object invokeDelegate(Delegate d, Object[] args);
    [SuppressUnmanagedCodeSecurityAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a callFunctionPointer(IntPtr executableMemory, Object[] arguments);
    public static FSharpOption`1<IntPtr> tryFindFunctionPointer(a f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void registerPointer(a f, IntPtr ptr);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.VecModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b dot(a a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b dot$W(FSharpFunc`2<a, FSharpFunc`2<a, b>> dot, a a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a cross(a a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a cross$W(FSharpFunc`2<a, FSharpFunc`2<a, a>> cross, a a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b distance(a a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b distance$W(FSharpFunc`2<a, FSharpFunc`2<a, b>> distance, a a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b distanceSquared(a a, a b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b distanceSquared$W(FSharpFunc`2<a, FSharpFunc`2<a, b>> distanceSquared, a a, a b);
    public static b length(a v);
    public static b length$W(FSharpFunc`2<a, b> get_Length, a v);
    public static b lengthSquared(a v);
    public static b lengthSquared$W(FSharpFunc`2<a, b> get_LengthSquared, a v);
    public static b normalize(a v);
    public static b normalize$W(FSharpFunc`2<a, b> get_Normalized, a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a reflect(a n, a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a reflect$W(FSharpFunc`2<a, FSharpFunc`2<a, a>> reflect, a n, a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b refract(a eta, b n, b v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b refract$W(FSharpFunc`2<b, FSharpFunc`2<b, FSharpFunc`2<a, b>>> refract, a eta, b n, b v);
    public static b x(a v);
    public static b x$W(FSharpFunc`2<a, b> get_P_X, a v);
    public static b y(a v);
    public static b y$W(FSharpFunc`2<a, b> get_P_Y, a v);
    public static b z(a v);
    public static b z$W(FSharpFunc`2<a, b> get_P_Z, a v);
    public static b w(a v);
    public static b w$W(FSharpFunc`2<a, b> get_P_W, a v);
    public static b xy(a v);
    public static b xy$W(FSharpFunc`2<a, b> get_XY, a v);
    public static b yz(a v);
    public static b yz$W(FSharpFunc`2<a, b> get_YZ, a v);
    public static b zw(a v);
    public static b zw$W(FSharpFunc`2<a, b> get_ZW, a v);
    public static b xyz(a v);
    public static b xyz$W(FSharpFunc`2<a, b> get_XYZ, a v);
    public static b yzw(a v);
    public static b yzw$W(FSharpFunc`2<a, b> get_YZW, a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anyEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyDifferent(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyDifferent$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anyDifferent, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allDifferent(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allDifferent$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allDifferent, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anySmaller(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anySmaller$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anySmaller, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyGreater(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyGreater$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anyGreater, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allSmaller(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allSmaller$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allSmaller, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allGreater(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allGreater$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allGreater, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anySmallerOrEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anySmallerOrEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anySmallerOrEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyGreaterOrEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool anyGreaterOrEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> anyGreaterOrEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allSmallerOrEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allSmallerOrEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allSmallerOrEqual, a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allGreaterOrEqual(a a, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool allGreaterOrEqual$W(FSharpFunc`2<a, FSharpFunc`2<b, bool>> allGreaterOrEqual, a a, b b);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Aardvark.Base.Weak : object {
    [CompilationMappingAttribute]
internal static Dictionary`2<object, int> lastValues { get; }
    [CompilationMappingAttribute]
internal static int lastNone { get; internal set; }
    [CompilationMappingAttribute]
internal static Dictionary`2<object, int> statistics { get; }
    [CompilationMappingAttribute]
internal static int statisticsNone { get; internal set; }
    [CompilationMappingAttribute]
internal static ConditionalWeakTable`2<object, Finalizable> registrations { get; }
    internal static Dictionary`2<object, int> get_lastValues();
    internal static int get_lastNone();
    internal static void set_lastNone(int value);
    internal static Dictionary`2<object, int> get_statistics();
    internal static int get_statisticsNone();
    internal static void set_statisticsNone(int value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Array convertArray(FSharpFunc`2<a, b> f, Array arr);
    internal static void registerInStatistics(FSharpOption`1<object> data);
    public static void printStatistics();
    internal static ConditionalWeakTable`2<object, Finalizable> get_registrations();
    public static void registerFinalizer(a obj, FSharpFunc`2<object, Unit> finalizer, FSharpOption`1<object> data);
    public static FSharpValueOption`1<a> |Strong|_|(Weak`1<a> weak);
    public static void registerWeakFinalizer(Weak`1<object> w, FSharpFunc`2<object, Unit> finalizer, FSharpOption`1<object> data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Object.RegisterFinalizer(object x, FSharpFunc`2<object, Unit> f, FSharpOption`1<object> data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Object.RegisterFinalizer(object x, FSharpFunc`2<Unit, Unit> f);
    internal static FSharpFunc`2<b, Unit> finalize@186(FSharpOption`1<object> data, FSharpRef`1<FSharpOption`1<FSharpFunc`2<object, Unit>>> fRef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void IEnumerable`1.RegisterAnyFinalizer(IEnumerable`1<a> x, FSharpFunc`2<object, Unit> f, FSharpOption`1<object> data);
    internal static FSharpFunc`2<b, Unit> finalize@200-2(FSharpFunc`2<object, Unit> f, FSharpOption`1<object> data, FSharpRef`1<int> countRef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void IEnumerable`1.RegisterAllFinalizer(IEnumerable`1<a> x, FSharpFunc`2<object, Unit> f, FSharpOption`1<object> data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void IEnumerable`1.RegisterAnyFinalizer(IEnumerable`1<a> x, FSharpFunc`2<Unit, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void IEnumerable`1.RegisterAllFinalizer(IEnumerable`1<a> x, FSharpFunc`2<Unit, Unit> f, FSharpOption`1<a> data);
    internal static void finalizer@235(FSharpOption`1<object> data, FSharpRef`1<FSharpOption`1<FSharpFunc`2<object, Unit>>> fRef, b _arg1);
    internal static void finalizer@252-2(FSharpFunc`2<object, Unit> f, FSharpOption`1<object> data, FSharpRef`1<int> countRef, b _arg2);
}
[CompilationMappingAttribute]
public static class Aardvark.Base.WeakTable : object {
}
[CompilationMappingAttribute]
public static class MBrace.FsPickler.CustomPicklerProvider : object {
    [CompilationMappingAttribute]
internal static bool initialized { get; internal set; }
    internal static bool get_initialized();
    internal static void set_initialized(bool value);
    [OnAardvarkInitAttribute]
public static void init();
}
[CompilationMappingAttribute]
public class MBrace.FsPickler.CustomPicklerProviderAttribute : Attribute {
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class MBrace.FsPickler.PicklerExtensions : object {
    internal static bool recurse@22(Dictionary`2<Type, Type> assignment, Type decl, Type real);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpHashMap`2<Type, Type>> tryUnifyTypes(Type decl, Type real);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<IPicklerResolver, Pickler> clo0@126(PicklerRegistry this, MethodInfo mi);
    internal static FSharpFunc`2<Type, FSharpOption`1<FSharpFunc`2<a, Pickler>>> tryInstantiate@121(PicklerRegistry this, MethodInfo mi, Type pickledType);
    internal static void installCustomPicklers(FSharpList`1<Type> types);
    public static void FsPickler.AddCustomPicklers.Static(FSharpList`1<Type> types);
}
