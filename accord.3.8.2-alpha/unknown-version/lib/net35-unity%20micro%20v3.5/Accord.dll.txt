public class Accord.ByteRange : ValueType {
    private byte min;
    private byte max;
    public byte Min { get; public set; }
    public byte Max { get; public set; }
    public int Length { get; }
    public ByteRange(byte min, byte max);
    public sealed virtual byte get_Min();
    public sealed virtual void set_Min(byte value);
    public sealed virtual byte get_Max();
    public sealed virtual void set_Max(byte value);
    public int get_Length();
    public bool IsInside(byte x);
    public bool IsInside(ByteRange range);
    public bool IsOverlapping(ByteRange range);
    public ByteRange Intersection(ByteRange range);
    public static bool op_Equality(ByteRange range1, ByteRange range2);
    public static bool op_Inequality(ByteRange range1, ByteRange range2);
    public sealed virtual bool Equals(ByteRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static IntRange op_Implicit(ByteRange range);
    public static DoubleRange op_Implicit(ByteRange range);
    public static Range op_Implicit(ByteRange range);
    public sealed virtual IEnumerator`1<byte> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Accord.cast`1 : ValueType {
    private T value;
    public T Value { get; }
    public cast`1(object value);
    public T get_Value();
    public static cast`1<T> op_Implicit(double value);
    public static cast`1<T> op_Implicit(float value);
    public static cast`1<T> op_Implicit(decimal value);
    public static cast`1<T> op_Implicit(byte value);
    public static cast`1<T> op_Implicit(sbyte value);
    public static cast`1<T> op_Implicit(short value);
    public static cast`1<T> op_Implicit(ushort value);
    public static cast`1<T> op_Implicit(int value);
    public static cast`1<T> op_Implicit(UInt32 value);
    public static cast`1<T> op_Implicit(long value);
    public static cast`1<T> op_Implicit(ulong value);
    public static T op_Implicit(cast`1<T> value);
}
internal class Accord.cast`2 : ValueType {
    private T value;
    public T Value { get; }
    public cast`2(U value);
    public T get_Value();
    public static cast`2<T, U> op_Implicit(U value);
    public static T op_Implicit(cast`2<T, U> value);
}
public class Accord.Collections.BinaryNode`1 : object {
    [CompilerGeneratedAttribute]
private TNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private TNode <Right>k__BackingField;
    public TNode Left { get; public set; }
    public TNode Right { get; public set; }
    public bool IsLeaf { get; }
    public TNode[] Children { get; public set; }
    [CompilerGeneratedAttribute]
public TNode get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(TNode value);
    [CompilerGeneratedAttribute]
public TNode get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(TNode value);
    public sealed virtual bool get_IsLeaf();
    public sealed virtual bool Equals(TNode other);
    public sealed virtual TNode[] get_Children();
    public sealed virtual void set_Children(TNode[] value);
}
public class Accord.Collections.BinaryTraversalMethod`1 : MulticastDelegate {
    public BinaryTraversalMethod`1(object object, IntPtr method);
    public virtual IEnumerator`1<TNode> Invoke(BinaryTree`1<TNode> tree);
    public virtual IAsyncResult BeginInvoke(BinaryTree`1<TNode> tree, AsyncCallback callback, object object);
    public virtual IEnumerator`1<TNode> EndInvoke(IAsyncResult result);
}
public class Accord.Collections.BinaryTree`1 : object {
    [CompilerGeneratedAttribute]
private TNode <Root>k__BackingField;
    public TNode Root { get; public set; }
    [CompilerGeneratedAttribute]
public TNode get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(TNode value);
    public virtual IEnumerator`1<TNode> GetEnumerator();
    public IEnumerable`1<TNode> Traverse(BinaryTraversalMethod`1<TNode> method);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface Accord.Collections.ITreeNode`1 {
    public TNode[] Children { get; public set; }
    public bool IsLeaf { get; }
    public abstract virtual TNode[] get_Children();
    public abstract virtual void set_Children(TNode[] value);
    public abstract virtual bool get_IsLeaf();
}
public class Accord.Collections.KeyValuePairComparer`2 : Comparer`1<KeyValuePair`2<TKey, TValue>> {
    private IComparer`1<TKey> keyComparer;
    public static KeyValuePairComparer`2<TKey, TValue> Default { get; }
    public KeyValuePairComparer`2(IComparer`1<TKey> keyComparer);
    public virtual int Compare(KeyValuePair`2<TKey, TValue> x, KeyValuePair`2<TKey, TValue> y);
    public sealed virtual int Compare(TKey x, TKey y);
    public static KeyValuePairComparer`2<TKey, TValue> get_Default();
}
[DefaultMemberAttribute("Item")]
public class Accord.Collections.OrderedDictionary`2 : object {
    private List`1<TKey> list;
    private Dictionary`2<TKey, TValue> dictionary;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OrderedDictionary`2(int capacity);
    public OrderedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public OrderedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public OrderedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public TKey GetKeyByIndex(int index);
    public TValue GetValueByIndex(int index);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private TValue <get_Values>b__15_0(TKey x);
}
public enum Accord.Collections.PriorityOrder : Enum {
    public int value__;
    public static PriorityOrder Minimum;
    public static PriorityOrder Maximum;
}
public class Accord.Collections.PriorityQueue`1 : object {
    private int numberOfNodes;
    private PriorityQueueNode`1[] nodes;
    private long counter;
    private PriorityOrder order;
    public int Count { get; }
    public int Capacity { get; }
    public PriorityOrder Order { get; public set; }
    public PriorityQueueNode`1<T> First { get; }
    public bool IsReadOnly { get; }
    public PriorityQueue`1(int capacity, PriorityOrder order);
    public int get_Count();
    public int get_Capacity();
    public PriorityOrder get_Order();
    public void set_Order(PriorityOrder value);
    public void Clear();
    public bool Contains(PriorityQueueNode`1<T> node);
    public PriorityQueueNode`1<T> Enqueue(T value, double priority);
    [ConditionalAttribute("DEBUG")]
private void CheckQueue();
    private void swap(int i, int j);
    private void cascadeUp(PriorityQueueNode`1& node);
    private void cascadeDown(PriorityQueueNode`1& node);
    private bool HasHigherPriority(int i, int j);
    public PriorityQueueNode`1<T> Dequeue();
    public void Resize(int capacity);
    public PriorityQueueNode`1<T> get_First();
    public bool get_IsReadOnly();
    public void UpdatePriority(PriorityQueueNode`1& node, double priority);
    private void OnNodeUpdated(PriorityQueueNode`1& node);
    public void Remove(PriorityQueueNode`1<T> node);
    public sealed virtual IEnumerator`1<PriorityQueueNode`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PriorityQueueNode`1[] ToArray(bool sorted);
    public bool IsValidQueue();
    private bool checkChildren(int currentIndex, int childIndex);
    public virtual string ToString();
}
public class Accord.Collections.PriorityQueueNode`1 : ValueType {
    private double priority;
    private T value;
    private long insertionIndex;
    private Reference<T> queueIndex;
    public static PriorityQueueNode`1<T> Empty;
    public double Priority { get; internal set; }
    public T Value { get; public set; }
    public long InsertionIndex { get; }
    public int QueueIndex { get; internal set; }
    public bool IsEmpty { get; }
    public PriorityQueueNode`1(T value, double priority, int index, long insertionIndex);
    private static PriorityQueueNode`1();
    public double get_Priority();
    internal void set_Priority(double value);
    public T get_Value();
    public void set_Value(T value);
    public long get_InsertionIndex();
    public int get_QueueIndex();
    internal void set_QueueIndex(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool get_IsEmpty();
    public sealed virtual bool Equals(PriorityQueueNode`1<T> other);
    public sealed virtual int CompareTo(PriorityQueueNode`1<T> other);
    public static bool op_Equality(PriorityQueueNode`1<T> a, PriorityQueueNode`1<T> b);
    public static bool op_Inequality(PriorityQueueNode`1<T> a, PriorityQueueNode`1<T> b);
    public static bool op_GreaterThan(PriorityQueueNode`1<T> a, PriorityQueueNode`1<T> b);
    public static bool op_LessThan(PriorityQueueNode`1<T> a, PriorityQueueNode`1<T> b);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public abstract class Accord.Collections.ReadOnlyKeyedCollection`2 : ReadOnlyCollection`1<TValue> {
    private Dictionary`2<TKey, TValue> dictionary;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public bool IsReadOnly { get; }
    protected ReadOnlyKeyedCollection`2(IList`1<TValue> components);
    protected abstract virtual TKey GetKeyForItem(TValue item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual void Add(TKey key, TValue value);
    public void Add(KeyValuePair`2<TValue, TKey> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Insert(int index, TValue item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
}
public class Accord.Collections.RedBlackTree`1 : BinaryTree`1<RedBlackTreeNode`1<T>> {
    private IComparer`1<T> compare;
    private RedBlackTreeNode`1<T> root;
    private int count;
    private bool duplicates;
    public int Count { get; }
    public IComparer`1<T> Comparer { get; }
    public bool IsReadOnly { get; }
    public RedBlackTree`1(IComparer`1<T> comparer);
    public RedBlackTree`1(bool allowDuplicates);
    public RedBlackTree`1(IComparer`1<T> comparer, bool allowDuplicates);
    public sealed virtual int get_Count();
    public IComparer`1<T> get_Comparer();
    public sealed virtual void Clear();
    public RedBlackTreeNode`1<T> Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Add(RedBlackTreeNode`1<T> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<Accord.Collections.RedBlackTreeNode<T>>.Remove(RedBlackTreeNode`1<T> item);
    public RedBlackTreeNode`1<T> Remove(T item);
    public RedBlackTreeNode`1<T> Remove(RedBlackTreeNode`1<T> node);
    public sealed virtual void CopyTo(RedBlackTreeNode`1[] array, int arrayIndex);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public virtual IEnumerator`1<RedBlackTreeNode`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Contains(RedBlackTreeNode`1<T> item);
    public RedBlackTreeNode`1<T> Find(T item);
    public RedBlackTreeNode`1<T> FindLessThanOrEqualTo(RedBlackTreeNode`1<T> node, T value);
    public RedBlackTreeNode`1<T> FindLessThanOrEqualTo(T value);
    public RedBlackTreeNode`1<T> FindLessThan(RedBlackTreeNode`1<T> node, T value);
    public RedBlackTreeNode`1<T> FindLessThan(T value);
    public RedBlackTreeNode`1<T> FindGreaterThan(RedBlackTreeNode`1<T> node, T value);
    public RedBlackTreeNode`1<T> FindGreaterThan(T value);
    public RedBlackTreeNode`1<T> Min();
    public RedBlackTreeNode`1<T> Max();
    public RedBlackTreeNode`1<T> GetNextNode(RedBlackTreeNode`1<T> node);
    public RedBlackTreeNode`1<T> GetPreviousNode(RedBlackTreeNode`1<T> node);
    public RedBlackTreeNode`1<T> Resort(RedBlackTreeNode`1<T> node);
    private void rotate_left(RedBlackTreeNode`1<T> p);
    private void rotate_right(RedBlackTreeNode`1<T> p);
    internal bool check_node(RedBlackTreeNode`1<T> n, Int32& nblack);
    internal bool check();
}
public class Accord.Collections.RedBlackTree`2 : RedBlackTree`1<KeyValuePair`2<TKey, TValue>> {
    public RedBlackTree`2(IComparer`1<KeyValuePair`2<TKey, TValue>> comparer);
    public RedBlackTree`2(bool allowDuplicates);
    public RedBlackTree`2(IComparer`1<KeyValuePair`2<TKey, TValue>> comparer, bool allowDuplicates);
}
[DefaultMemberAttribute("Item")]
public class Accord.Collections.RedBlackTreeDictionary`2 : object {
    private RedBlackTree`2<TKey, TValue> tree;
    private ValueCollection<TKey, TValue> values;
    private KeyCollection<TKey, TValue> keys;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public RedBlackTreeDictionary`2(IComparer`1<TKey> comparer);
    private void init(IComparer`1<TKey> comparer);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public KeyValuePair`2<TKey, TValue> Min();
    public KeyValuePair`2<TKey, TValue> Max();
    public KeyValuePair`2<TKey, TValue> GetPrevious(TKey key);
    public bool TryGetPrevious(TKey key, KeyValuePair`2& prev);
    public KeyValuePair`2<TKey, TValue> GetNext(TKey key);
    public bool TryGetNext(TKey key, KeyValuePair`2& next);
}
public class Accord.Collections.RedBlackTreeNode`1 : BinaryNode`1<RedBlackTreeNode`1<T>> {
    private RedBlackTreeNode`1<T> parent;
    private RedBlackTreeNodeType color;
    private T value;
    public RedBlackTreeNode`1<T> Parent { get; public set; }
    public RedBlackTreeNodeType Color { get; public set; }
    public T Value { get; public set; }
    public RedBlackTreeNode`1(T value);
    public RedBlackTreeNode`1<T> get_Parent();
    public void set_Parent(RedBlackTreeNode`1<T> value);
    public RedBlackTreeNodeType get_Color();
    public void set_Color(RedBlackTreeNodeType value);
    public T get_Value();
    public void set_Value(T value);
    public virtual string ToString();
}
public class Accord.Collections.RedBlackTreeNode`2 : RedBlackTreeNode`1<KeyValuePair`2<TKey, TValue>> {
    public RedBlackTreeNode`2(TKey key, TValue value);
    public RedBlackTreeNode`2(KeyValuePair`2<TKey, TValue> item);
}
public enum Accord.Collections.RedBlackTreeNodeType : Enum {
    public int value__;
    public static RedBlackTreeNodeType Red;
    public static RedBlackTreeNodeType Black;
}
public class Accord.Collections.TraversalMethod`1 : MulticastDelegate {
    public TraversalMethod`1(object object, IntPtr method);
    public virtual IEnumerator`1<TNode> Invoke(Tree`1<TNode> tree);
    public virtual IAsyncResult BeginInvoke(Tree`1<TNode> tree, AsyncCallback callback, object object);
    public virtual IEnumerator`1<TNode> EndInvoke(IAsyncResult result);
}
public class Accord.Collections.Tree`1 : object {
    [CompilerGeneratedAttribute]
private TNode <Root>k__BackingField;
    public TNode Root { get; protected set; }
    [CompilerGeneratedAttribute]
public TNode get_Root();
    [CompilerGeneratedAttribute]
protected void set_Root(TNode value);
    public sealed virtual IEnumerator`1<TNode> GetEnumerator();
    public IEnumerable`1<TNode> Traverse(TraversalMethod`1<TNode> method);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Accord.Collections.TreeNode`1 : object {
    [CompilerGeneratedAttribute]
private TNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TNode[] <Children>k__BackingField;
    public TNode Parent { get; public set; }
    public int Index { get; public set; }
    public TNode[] Children { get; public set; }
    public TNode Next { get; }
    public TNode Previous { get; }
    public bool IsLeaf { get; }
    public TreeNode`1(int index);
    [CompilerGeneratedAttribute]
public TNode get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(TNode value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public sealed virtual TNode[] get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Children(TNode[] value);
    public TNode get_Next();
    public TNode get_Previous();
    public sealed virtual bool get_IsLeaf();
}
public static class Accord.Collections.TreeTraversal : object {
    public static IEnumerator`1<TNode> BreadthFirst(BinaryTree`1<TNode> tree);
    public static IEnumerator`1<TNode> PreOrder(BinaryTree`1<TNode> tree);
    public static IEnumerator`1<TNode> InOrder(BinaryTree`1<TNode> tree);
    public static IEnumerator`1<TNode> PostOrder(BinaryTree`1<TNode> tree);
    public static IEnumerator`1<TNode> DepthFirst(BinaryTree`1<TNode> tree);
    public static IEnumerator`1<TNode> DepthFirst(Tree`1<TNode> tree);
}
[DefaultMemberAttribute("Item")]
public class Accord.Collections.TwoWayDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> firstToSecond;
    private IDictionary`2<TSecond, TFirst> secondToFirst;
    private ReverseDictionary<TFirst, TSecond> reverse;
    public IDictionary`2<TSecond, TFirst> Reverse { get; }
    public int Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public TSecond Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public ICollection`1<TFirst> Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private IEnumerable`1<TFirst> Accord.Compat.IReadOnlyDictionary<TFirst,TSecond>.Keys { get; }
    public ICollection`1<TSecond> Values { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEnumerable`1<TSecond> Accord.Compat.IReadOnlyDictionary<TFirst,TSecond>.Values { get; }
    public TwoWayDictionary`2(int capacity);
    public TwoWayDictionary`2(IDictionary`2<TFirst, TSecond> dictionary);
    public IDictionary`2<TSecond, TFirst> get_Reverse();
    public sealed virtual int get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual TSecond get_Item(TFirst key);
    public sealed virtual void set_Item(TFirst key, TSecond value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual ICollection`1<TFirst> get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override IEnumerable`1<TFirst> Accord.Compat.IReadOnlyDictionary<TFirst,TSecond>.get_Keys();
    public sealed virtual ICollection`1<TSecond> get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerable`1<TSecond> Accord.Compat.IReadOnlyDictionary<TFirst,TSecond>.get_Values();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TFirst, TSecond>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Add(TFirst key, TSecond value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TFirst,TSecond>>.Add(KeyValuePair`2<TFirst, TSecond> item);
    public sealed virtual bool ContainsKey(TFirst key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TFirst,TSecond>>.Contains(KeyValuePair`2<TFirst, TSecond> item);
    public sealed virtual bool TryGetValue(TFirst key, TSecond& value);
    public sealed virtual bool Remove(TFirst key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TFirst,TSecond>>.Remove(KeyValuePair`2<TFirst, TSecond> item);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TFirst,TSecond>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
}
public class Accord.CommunicationBufferEventArgs : EventArgs {
    private Byte[] message;
    private int index;
    private int length;
    public int MessageLength { get; }
    public CommunicationBufferEventArgs(Byte[] message);
    public CommunicationBufferEventArgs(Byte[] buffer, int index, int length);
    public int get_MessageLength();
    public Byte[] GetMessage();
    public string GetMessageString();
}
public class Accord.Compat.AggregateException : Exception {
    private List`1<Exception> exceptions;
    public List`1<Exception> InnerExceptions { get; }
    public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    public List`1<Exception> get_InnerExceptions();
}
public class Accord.Compat.CancellationToken : ValueType {
    [CompilerGeneratedAttribute]
private bool <CanBeCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCancellationRequested>k__BackingField;
    private static CancellationToken none;
    public bool CanBeCancelled { get; public set; }
    public bool IsCancellationRequested { get; public set; }
    public static CancellationToken None { get; }
    private static CancellationToken();
    [CompilerGeneratedAttribute]
public bool get_CanBeCancelled();
    [CompilerGeneratedAttribute]
public void set_CanBeCancelled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCancellationRequested();
    [CompilerGeneratedAttribute]
public void set_IsCancellationRequested(bool value);
    public static CancellationToken get_None();
}
public class Accord.Compat.Complex : ValueType {
    public double Real;
    public double Imaginary;
    public static Complex Zero;
    public static Complex One;
    public static Complex I;
    public double Magnitude { get; }
    public double Phase { get; }
    public double SquaredMagnitude { get; }
    public Complex(double re, double im);
    public Complex(Complex c);
    private static Complex();
    public double get_Magnitude();
    public double get_Phase();
    public double get_SquaredMagnitude();
    public static Complex Conjugate(Complex complex);
    public static Complex Add(Complex a, Complex b);
    public static Complex Add(Complex a, double s);
    public static void Add(Complex a, Complex b, Complex& result);
    public static void Add(Complex a, double s, Complex& result);
    public static Complex Subtract(Complex a, Complex b);
    public static Complex Subtract(Complex a, double s);
    public static Complex Subtract(double s, Complex a);
    public static void Subtract(Complex a, Complex b, Complex& result);
    public static void Subtract(Complex a, double s, Complex& result);
    public static void Subtract(double s, Complex a, Complex& result);
    public static Complex Multiply(Complex a, Complex b);
    public static Complex Multiply(Complex a, double s);
    public static void Multiply(Complex a, Complex b, Complex& result);
    public static void Multiply(Complex a, double s, Complex& result);
    public static Complex Divide(Complex a, Complex b);
    public static Complex Divide(Complex a, double s);
    public static Complex Divide(double s, Complex a);
    public static void Divide(Complex a, Complex b, Complex& result);
    public static void Divide(Complex a, double s, Complex& result);
    public static void Divide(double s, Complex a, Complex& result);
    public static Complex Negate(Complex a);
    public static bool ApproxEqual(Complex a, Complex b);
    public static bool ApproxEqual(Complex a, Complex b, double tolerance);
    public static Complex Parse(string s);
    public static bool TryParse(string s, Complex& result);
    public static Complex Sqrt(Complex a);
    public static Complex Log(Complex a);
    public static Complex Exp(Complex a);
    public static Complex Sin(Complex a);
    public static Complex Cos(Complex a);
    public static Complex Tan(Complex a);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public static bool op_Equality(Complex u, Complex v);
    public static bool op_Inequality(Complex u, Complex v);
    public static Complex op_UnaryNegation(Complex a);
    public static Complex op_Addition(Complex a, Complex b);
    public static Complex op_Addition(Complex a, double s);
    public static Complex op_Addition(double s, Complex a);
    public static Complex op_Subtraction(Complex a, Complex b);
    public static Complex op_Subtraction(Complex a, double s);
    public static Complex op_Subtraction(double s, Complex a);
    public static Complex op_Multiply(Complex a, Complex b);
    public static Complex op_Multiply(double s, Complex a);
    public static Complex op_Multiply(Complex a, double s);
    public static Complex op_Division(Complex a, Complex b);
    public static Complex op_Division(Complex a, double s);
    public static Complex op_Division(double s, Complex a);
    public static Complex op_Explicit(float value);
    public static Complex op_Implicit(double value);
    private sealed virtual override object System.ICloneable.Clone();
    public Complex Clone();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Accord.Compat.ConcurrentBag`1 : object {
    private LinkedList`1<T> list;
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public void Add(T item);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public T[] ToArray();
}
[DefaultMemberAttribute("Item")]
internal class Accord.Compat.ConcurrentDictionary`2 : object {
    private Dictionary`2<TKey, TValue> dict;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Accord.Compat.ConcurrentStack`1 : object {
    private Stack`1<T> stack;
    public void Push(T item);
    public T[] ToArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
internal class Accord.Compat.Dummy : object {
}
[ExtensionAttribute]
internal static class Accord.Compat.EnumerableEx : object {
    [ExtensionAttribute]
internal static IEnumerable`1<TResult> Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    private static IEnumerable`1<TResult> ZipIterator(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
}
public static class Accord.Compat.EnvironmentEx : object {
    private static int CSIDL_SYSTEM;
    private static int CSIDL_SYSTEMX86;
    public static bool Is64BitProcess;
    private static EnvironmentEx();
    private static bool SHGetSpecialFolderPath(IntPtr hwndOwner, StringBuilder lpszPath, int nFolder, bool fCreate);
    public static string GetWindowsSystemDirectory32();
    public static string GetWindowsSystemDirectory64();
}
public interface Accord.Compat.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface Accord.Compat.IReadOnlyDictionary`2 {
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public TValue Item { get; }
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public class Accord.Compat.ISet`1 : object {
    internal HashSet`1<T> set;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ISet`1(HashSet`1<T> set);
    public static ISet`1<T> op_Implicit(HashSet`1<T> set);
    public static HashSet`1<T> op_Implicit(ISet`1<T> set);
    public virtual void Add(T item);
    public virtual void UnionWith(IEnumerable`1<T> items);
    public virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool SetEquals(ISet`1<T> set);
    public bool IsSubsetOf(IEnumerable`1<T> set);
}
internal class Accord.Compat.Lazy`1 : object {
    private Func`1<T> valueFactory;
    private object lockObj;
    private bool isValueCreated;
    private T value;
    public T Value { get; }
    public bool IsValueCreated { get; }
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public T get_Value();
    public bool get_IsValueCreated();
    public virtual string ToString();
}
internal class Accord.Compat.ManualResetEventSlim : object {
    private ManualResetEvent e;
    public ManualResetEventSlim(bool v);
    internal void Set();
    internal void Wait();
    internal void Reset();
    internal void Dispose();
}
internal static class Accord.Compat.Parallel : object {
    public static void For(int start, int stop, ForLoopBody loopBody);
    public static void ForEach(IEnumerable`1<T> values, ForEachLoopBody`1<T> loopBody);
    public static void For(int start, int stop, ParallelOptions options, ForLoopBody loopBody);
    public static void For(int start, int stop, ParallelOptions options, Func`1<T> initial, ForLoopBody`1<T> loopBody, Action`1<T> end);
    public static void For(int start, int stop, Func`1<T> initial, ForLoopBody`1<T> loopBody, Action`1<T> end);
}
public class Accord.Compat.ParallelOptions : object {
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public int MaxDegreeOfParallelism { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
}
[DefaultMemberAttribute("Item")]
public class Accord.Compat.ReadOnlyDictionary`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Accord.Compat.SortedSet`1 : ISet`1<T> {
    private SortedList`2<T, int> list;
    [CompilerGeneratedAttribute]
private T <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Min>k__BackingField;
    public T Max { get; private set; }
    public T Min { get; private set; }
    public SortedSet`1(IEnumerable`1<T> collection);
    [CompilerGeneratedAttribute]
public T get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(T value);
    [CompilerGeneratedAttribute]
public T get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(T value);
    public virtual void Add(T value);
    public virtual bool Remove(T value);
    public void UnionWith(ISet`1<T> set);
    public void ExceptWith(ISet`1<T> set);
    public virtual void Clear();
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Accord.Compat.SpinLock : ValueType {
    private int lockObj;
    public bool IsHeld { get; }
    public bool get_IsHeld();
    public void Enter(Boolean& taken);
    public void Exit();
}
[ExtensionAttribute]
internal static class Accord.Compat.StreamExtensions : object {
    [ExtensionAttribute]
internal static void CopyTo(Stream input, Stream output);
}
[ExtensionAttribute]
internal static class Accord.Compat.StringEx : object {
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string str);
}
internal class Accord.Compat.ThreadLocal`1 : object {
    [ThreadStaticAttribute]
private static Dictionary`2<object, T> lookupTable;
    private static object lockObj;
    private Func`1<T> init;
    public T Value { get; public set; }
    public ThreadLocal`1(Func`1<T> init);
    private static ThreadLocal`1();
    protected virtual override void Finalize();
    public T get_Value();
    public void set_Value(T value);
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
}
public static class Accord.Compat.Tuple : object {
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
}
public class Accord.Compat.Tuple`2 : object {
    [CompilerGeneratedAttribute]
private T1 <Item1>k__BackingField;
    [CompilerGeneratedAttribute]
private T2 <Item2>k__BackingField;
    public T1 Item1 { get; public set; }
    public T2 Item2 { get; public set; }
    public Tuple`2(T1 item1, T2 item2);
    [CompilerGeneratedAttribute]
public T1 get_Item1();
    [CompilerGeneratedAttribute]
public void set_Item1(T1 value);
    [CompilerGeneratedAttribute]
public T2 get_Item2();
    [CompilerGeneratedAttribute]
public void set_Item2(T2 value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Accord.Compat.Tuple`3 : object {
    [CompilerGeneratedAttribute]
private T1 <Item1>k__BackingField;
    [CompilerGeneratedAttribute]
private T2 <Item2>k__BackingField;
    [CompilerGeneratedAttribute]
private T3 <Item3>k__BackingField;
    public T1 Item1 { get; public set; }
    public T2 Item2 { get; public set; }
    public T3 Item3 { get; public set; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    [CompilerGeneratedAttribute]
public T1 get_Item1();
    [CompilerGeneratedAttribute]
public void set_Item1(T1 value);
    [CompilerGeneratedAttribute]
public T2 get_Item2();
    [CompilerGeneratedAttribute]
public void set_Item2(T2 value);
    [CompilerGeneratedAttribute]
public T3 get_Item3();
    [CompilerGeneratedAttribute]
public void set_Item3(T3 value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Accord.Compat.TypeExtensions : object {
    [ExtensionAttribute]
public static object GetValue(PropertyInfo info, object obj);
    [ExtensionAttribute]
public static T GetCustomAttribute(ICustomAttributeProvider info);
}
public class Accord.ConnectionFailedException : Exception {
    public ConnectionFailedException(string message);
    public ConnectionFailedException(string message, Exception innerException);
}
public class Accord.ConnectionLostException : Exception {
    public ConnectionLostException(string message);
    public ConnectionLostException(string message, Exception innerException);
    public ConnectionLostException(SerializationInfo info, StreamingContext context);
}
public class Accord.ConvergenceException : Exception {
    public ConvergenceException(string message);
    public ConvergenceException(string message, Exception innerException);
    protected ConvergenceException(SerializationInfo info, StreamingContext context);
}
public class Accord.DeviceBusyException : Exception {
    public DeviceBusyException(string message);
    public DeviceBusyException(string message, Exception innerException);
    public DeviceBusyException(SerializationInfo info, StreamingContext context);
}
public class Accord.DeviceErrorException : Exception {
    public DeviceErrorException(string message);
    public DeviceErrorException(string message, Exception innerException);
    public DeviceErrorException(SerializationInfo info, StreamingContext context);
}
public static class Accord.Diagnostics.Debug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
}
public class Accord.DimensionMismatchException : ArgumentException {
    public DimensionMismatchException(string paramName);
    public DimensionMismatchException(string paramName, string message);
    public DimensionMismatchException(string message, Exception innerException);
    protected DimensionMismatchException(SerializationInfo info, StreamingContext context);
}
public class Accord.DoublePoint : ValueType {
    public double X;
    public double Y;
    public DoublePoint(double x, double y);
    public double DistanceTo(DoublePoint anotherPoint);
    public double SquaredDistanceTo(DoublePoint anotherPoint);
    public static DoublePoint op_Addition(DoublePoint point1, DoublePoint point2);
    public static DoublePoint Add(DoublePoint point1, DoublePoint point2);
    public static DoublePoint op_Subtraction(DoublePoint point1, DoublePoint point2);
    public static DoublePoint Subtract(DoublePoint point1, DoublePoint point2);
    public static DoublePoint op_Addition(DoublePoint point, double valueToAdd);
    public static DoublePoint Add(DoublePoint point, double valueToAdd);
    public static DoublePoint op_Subtraction(DoublePoint point, double valueToSubtract);
    public static DoublePoint Subtract(DoublePoint point, double valueToSubtract);
    public static DoublePoint op_Multiply(DoublePoint point, double factor);
    public static DoublePoint Multiply(DoublePoint point, double factor);
    public static DoublePoint op_Division(DoublePoint point, double factor);
    public static DoublePoint Divide(DoublePoint point, double factor);
    public static bool op_Equality(DoublePoint point1, DoublePoint point2);
    public static bool op_Inequality(DoublePoint point1, DoublePoint point2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static IntPoint op_Explicit(DoublePoint point);
    public static Point op_Explicit(DoublePoint point);
    public IntPoint Round();
    public virtual string ToString();
    public double EuclideanNorm();
}
public class Accord.DoubleRange : ValueType {
    private double min;
    private double max;
    public double Min { get; public set; }
    public double Max { get; public set; }
    public double Length { get; }
    public DoubleRange(double min, double max);
    public sealed virtual double get_Min();
    public sealed virtual void set_Min(double value);
    public sealed virtual double get_Max();
    public sealed virtual void set_Max(double value);
    public double get_Length();
    public bool IsInside(double x);
    public bool IsInside(DoubleRange range);
    public bool IsOverlapping(DoubleRange range);
    public DoubleRange Intersection(DoubleRange range);
    public static bool op_Equality(DoubleRange range1, DoubleRange range2);
    public static bool op_Inequality(DoubleRange range1, DoubleRange range2);
    public sealed virtual bool Equals(DoubleRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public IntRange ToIntRange(bool provideInnerRange);
}
[ExtensionAttribute]
public static class Accord.ExtensionMethods : object {
    [ExtensionAttribute]
public static void Add(DataColumnCollection collection, String[] columnNames);
    [ExtensionAttribute]
public static void Add(DataColumnCollection collection, OrderedDictionary`2<string, Type> columns);
    [ExtensionAttribute]
public static string GetDescription(T source);
    [ExtensionAttribute]
public static bool Read(BinaryReader stream, T& structure);
    [ExtensionAttribute]
public static bool Write(BinaryWriter stream, T[] array);
    [ExtensionAttribute]
public static bool Write(BinaryWriter stream, T[][] array);
    [ExtensionAttribute]
public static bool Write(BinaryWriter stream, T[0...,0...] array);
    [ExtensionAttribute]
public static T[][] ReadJagged(BinaryReader stream, int rows, int columns);
    [ExtensionAttribute]
public static T[0...,0...] ReadMatrix(BinaryReader stream, int rows, int columns);
    [ExtensionAttribute]
public static Array ReadMatrix(BinaryReader stream, Type type, Int32[] lengths);
    [ExtensionAttribute]
public static long GetPosition(StreamReader reader);
    private static object GetField(StreamReader reader, string name);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Accord.IO.Serializer.Load<T>() instead.")]
public static T DeserializeAnyVersion(BinaryFormatter formatter, Stream stream);
    [ExtensionAttribute]
public static T To(object value);
    [ExtensionAttribute]
public static object To(object value, Type type);
    [ExtensionAttribute]
public static Type GetInnerMostType(Type type);
    [ExtensionAttribute]
public static bool HasDefaultConstructor(Type t);
    [ExtensionAttribute]
public static string Format(string str, Object[] args);
    [ExtensionAttribute]
public static bool IsEqual(IDictionary`2<TKey, TValue> a, IDictionary`2<TKey, TValue> b);
    [ExtensionAttribute]
public static bool HasMethod(object obj, string methodName);
    public static bool HasMethod(string methodName);
    [ExtensionAttribute]
public static bool IsGreaterThan(T a, object b);
    [ExtensionAttribute]
public static bool IsGreaterThanOrEqual(T a, object b);
    [ExtensionAttribute]
public static bool IsLessThan(T a, object b);
    [ExtensionAttribute]
public static bool IsLessThanOrEqual(T a, object b);
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
    [ExtensionAttribute]
public static IntPtr AddressOf(T t);
    private static IntPtr AddressOfRef(T& t);
    internal static WebClient NewWebClient();
    [ExtensionAttribute]
internal static void DownloadFileWithRetry(WebClient client, string url, string fileName, int maxAttempts, bool overwrite);
    [ExtensionAttribute]
public static Byte[] ToByteArray(T value);
    [ExtensionAttribute]
public static T ToStruct(Byte[] rawData, int position);
}
[AttributeUsageAttribute("4")]
public class Accord.FormatDecoderAttribute : FormatHandlerAttribute {
    public FormatDecoderAttribute(string extension);
    public static TDecoder GetDecoders(string fileExtension, Dictionary`2<string, Type> decoderTypes, Dictionary`2<string, TDecoder> cache);
}
[AttributeUsageAttribute("4")]
public class Accord.FormatEncoderAttribute : FormatHandlerAttribute {
    public FormatEncoderAttribute(string extension);
    public static TEncoder GetEncoder(string fileExtension, Dictionary`2<string, Type> encoderTypes, Dictionary`2<string, TEncoder> cache);
}
public abstract class Accord.FormatHandlerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    public string Extension { get; public set; }
    public FormatHandlerAttribute(string extension);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(string value);
    public static string GetNormalizedExtension(string fileName);
    public static TInterface GetHandler(string fileExtension, Dictionary`2<string, Type> handlerTypes, Dictionary`2<string, TInterface> cache);
    public static void PopulateDictionaryWithHandlersFromAllAssemblies(Dictionary`2<string, Type> dictionary);
}
public interface Accord.IFeatureDescriptor`1 {
    public T Descriptor { get; }
    public abstract virtual T get_Descriptor();
}
public interface Accord.IFeatureExtractor`2 {
}
[AttributeUsageAttribute("2048")]
public class Accord.IntegerAttribute : RangeAttribute {
    public int Minimum { get; }
    public int Maximum { get; }
    public IntegerAttribute(int minimum, int maximum);
    public int get_Minimum();
    public int get_Maximum();
}
public class Accord.InterlockedEx : object {
    public static double Add(Double& location1, double value);
    public static double Increment(Double& location1);
}
public class Accord.IntPoint : ValueType {
    public int X;
    public int Y;
    public IntPoint(int x, int y);
    public float DistanceTo(IntPoint anotherPoint);
    public float SquaredDistanceTo(Point anotherPoint);
    public static IntPoint op_Addition(IntPoint point1, IntPoint point2);
    public static IntPoint Add(IntPoint point1, IntPoint point2);
    public static IntPoint op_Subtraction(IntPoint point1, IntPoint point2);
    public static IntPoint Subtract(IntPoint point1, IntPoint point2);
    public static IntPoint op_Addition(IntPoint point, int valueToAdd);
    public static IntPoint Add(IntPoint point, int valueToAdd);
    public static IntPoint op_Subtraction(IntPoint point, int valueToSubtract);
    public static IntPoint Subtract(IntPoint point, int valueToSubtract);
    public static IntPoint op_Multiply(IntPoint point, int factor);
    public static IntPoint Multiply(IntPoint point, int factor);
    public static IntPoint op_Division(IntPoint point, int factor);
    public static IntPoint Divide(IntPoint point, int factor);
    public static bool op_Equality(IntPoint point1, IntPoint point2);
    public static bool op_Inequality(IntPoint point1, IntPoint point2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Point op_Implicit(IntPoint point);
    public static DoublePoint op_Implicit(IntPoint point);
    public virtual string ToString();
    public float EuclideanNorm();
    public sealed virtual int CompareTo(IntPoint other);
}
public class Accord.IntRange : ValueType {
    private int min;
    private int max;
    public int Min { get; public set; }
    public int Max { get; public set; }
    public int Length { get; }
    public IntRange(int min, int max);
    public sealed virtual int get_Min();
    public sealed virtual void set_Min(int value);
    public sealed virtual int get_Max();
    public sealed virtual void set_Max(int value);
    public int get_Length();
    public bool IsInside(int x);
    public IntRange Intersection(IntRange range);
    public bool IsInside(IntRange range);
    public bool IsOverlapping(IntRange range);
    public static bool op_Equality(IntRange range1, IntRange range2);
    public static bool op_Inequality(IntRange range1, IntRange range2);
    public sealed virtual bool Equals(IntRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static DoubleRange op_Implicit(IntRange range);
    public static Range op_Implicit(IntRange range);
    public sealed virtual IEnumerator`1<int> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class Accord.IO.Serializer : object {
    private static SerializerCompression DEFAULT_COMPRESSION;
    private static object lockObj;
    private static Serializer();
    private static SerializerCompression ParseCompression(string path);
    [ExtensionAttribute]
public static void Save(T obj, Stream stream, SerializerCompression compression);
    [ExtensionAttribute]
public static void Save(T obj, BinaryFormatter formatter, Stream stream, SerializerCompression compression);
    [ExtensionAttribute]
public static void Save(T obj, string path);
    [ExtensionAttribute]
public static void Save(T obj, string path, SerializerCompression compression);
    [ExtensionAttribute]
public static Byte[] Save(T obj, SerializerCompression compression);
    [ExtensionAttribute]
public static void Save(T obj, Byte[]& bytes, SerializerCompression compression);
    public static T Load(Stream stream, SerializerCompression compression);
    public static T Load(string path);
    public static T Load(string path, SerializerCompression compression);
    private static T load(string path, SerializerCompression compression);
    public static T Load(Byte[] bytes, SerializerCompression compression);
    public static T Load(Stream stream, T& value, SerializerCompression compression);
    public static T Load(string path, T& value);
    public static T Load(string path, T& value, SerializerCompression compression);
    public static T Load(Byte[] bytes, T& value, SerializerCompression compression);
    public static T Load(Stream stream, BinaryFormatter formatter, SerializerCompression compression);
    [ExtensionAttribute]
public static T DeepClone(T obj);
    private static SerializationBinder GetBinder(Type type);
    private static SurrogateSelector GetSurrogate(Type type);
    private static Assembly resolve(object sender, ResolveEventArgs args);
    [ExtensionAttribute]
public static T GetValue(SerializationInfo info, string name, T& value);
}
public enum Accord.IO.SerializerCompression : Enum {
    public int value__;
    public static SerializerCompression None;
    public static SerializerCompression GZip;
}
public interface Accord.IRange`1 {
    public T Min { get; public set; }
    public T Max { get; public set; }
    public abstract virtual T get_Min();
    public abstract virtual void set_Min(T value);
    public abstract virtual T get_Max();
    public abstract virtual void set_Max(T value);
}
public interface Accord.MachineLearning.IBinaryClassifier {
}
public interface Accord.MachineLearning.IBinaryClassifier`1 {
    public abstract virtual IMulticlassClassifier`1<TInput> ToMulticlass();
    public abstract virtual IMulticlassClassifier`2<TInput, T> ToMulticlass();
}
public interface Accord.MachineLearning.IBinaryLikelihoodClassifier`1 {
    public abstract virtual IMulticlassLikelihoodClassifier`1<TInput> ToMulticlass();
    public abstract virtual IMulticlassLikelihoodClassifier`2<TInput, T> ToMulticlass();
}
public interface Accord.MachineLearning.IBinaryScoreClassifier`1 {
    public abstract virtual IMulticlassScoreClassifier`1<TInput> ToMulticlass();
    public abstract virtual IMulticlassScoreClassifier`2<TInput, T> ToMulticlass();
}
public interface Accord.MachineLearning.IClassifier {
    public int NumberOfClasses { get; public set; }
    public abstract virtual int get_NumberOfClasses();
    public abstract virtual void set_NumberOfClasses(int value);
}
public interface Accord.MachineLearning.IClassifier`2 {
    public abstract virtual TClasses Decide(TInput input);
    public abstract virtual TClasses[] Decide(TInput[] input);
    public abstract virtual TClasses[] Decide(TInput[] input, TClasses[] result);
}
public interface Accord.MachineLearning.ICovariantTransform`2 {
    public abstract virtual TOutput Transform(TInput input);
    public abstract virtual TOutput[] Transform(TInput[] input);
}
public interface Accord.MachineLearning.IGenerative`1 {
    public abstract virtual double LogLikelihood(TInput input);
}
public interface Accord.MachineLearning.ILikelihoodTagger`1 {
    public abstract virtual double Probability(TInput[] sequence);
    public abstract virtual double Probability(TInput[] sequence, Int32[]& decision);
    public abstract virtual Double[] Probability(TInput[][] sequences);
    public abstract virtual Double[] Probability(TInput[][] sequences, Double[] result);
    public abstract virtual Double[] Probability(TInput[][] sequences, Int32[][]& decision);
    public abstract virtual Double[] Probability(TInput[][] sequences, Int32[][]& decision, Double[] result);
    public abstract virtual double LogLikelihood(TInput[] sequence);
    public abstract virtual double LogLikelihood(TInput[] sequence, Int32[]& decision);
    public abstract virtual Double[] LogLikelihood(TInput[][] sequences);
    public abstract virtual Double[] LogLikelihood(TInput[][] sequences, Double[] result);
    public abstract virtual Double[] LogLikelihood(TInput[][] sequences, Int32[][]& decision);
    public abstract virtual Double[] LogLikelihood(TInput[][] sequences, Int32[][]& decision, Double[] result);
    public abstract virtual Double[][] Probabilities(TInput[] sequence);
    public abstract virtual Double[][] Probabilities(TInput[] sequence, Double[][] result);
    public abstract virtual Double[][] Probabilities(TInput[] sequence, Int32[]& decision);
    public abstract virtual Double[][] Probabilities(TInput[] sequence, Int32[]& decision, Double[][] result);
    public abstract virtual Double[][] LogLikelihoods(TInput[] sequence);
    public abstract virtual Double[][] LogLikelihoods(TInput[] sequence, Double[][] result);
    public abstract virtual Double[][] LogLikelihoods(TInput[] sequence, Int32[]& decision);
    public abstract virtual Double[][] LogLikelihoods(TInput[] sequence, Int32[]& decision, Double[][] result);
    public abstract virtual Double[][][] Probabilities(TInput[][] sequences);
    public abstract virtual Double[][][] Probabilities(TInput[][] sequences, Double[][][] result);
    public abstract virtual Double[][][] Probabilities(TInput[][] sequences, Int32[][]& decision);
    public abstract virtual Double[][][] Probabilities(TInput[][] sequences, Int32[][]& decision, Double[][][] result);
    public abstract virtual Double[][][] LogLikelihoods(TInput[][] sequences);
    public abstract virtual Double[][][] LogLikelihoods(TInput[][] sequences, Double[][][] result);
    public abstract virtual Double[][][] LogLikelihoods(TInput[][] sequences, Int32[][]& decision);
    public abstract virtual Double[][][] LogLikelihoods(TInput[][] sequences, Int32[][]& decision, Double[][][] result);
}
public interface Accord.MachineLearning.IMulticlassClassifier {
}
public interface Accord.MachineLearning.IMulticlassClassifier`1 {
    public abstract virtual int Decide(TInput input);
    public abstract virtual Int32[] Decide(TInput[] input);
    public abstract virtual IMultilabelClassifier`1<TInput> ToMultilabel();
}
public interface Accord.MachineLearning.IMulticlassClassifier`2 {
}
public interface Accord.MachineLearning.IMulticlassLikelihoodClassifier`1 {
    public abstract virtual int Decide(TInput input);
    public abstract virtual Int32[] Decide(TInput[] input);
    public abstract virtual double Probability(TInput input);
    public abstract virtual Double[] Probability(TInput[] input);
    public abstract virtual Double[] Probability(TInput[] input, Double[] result);
    public abstract virtual double LogLikelihood(TInput input);
    public abstract virtual Double[] LogLikelihood(TInput[] input);
    public abstract virtual Double[] LogLikelihood(TInput[] input, Double[] result);
    public abstract virtual IMultilabelLikelihoodClassifier`1<TInput> ToMultilabel();
}
public interface Accord.MachineLearning.IMulticlassLikelihoodClassifier`2 {
}
public interface Accord.MachineLearning.IMulticlassLikelihoodClassifierBase`2 {
    public abstract virtual Double[] Probability(TInput[] input, TClasses[]& decision);
    public abstract virtual Double[] Probability(TInput[] input, TClasses[]& decision, Double[] result);
    public abstract virtual Double[] LogLikelihood(TInput[] input, TClasses[]& decision);
    public abstract virtual Double[] LogLikelihood(TInput[] input, TClasses[]& decision, Double[] result);
}
public interface Accord.MachineLearning.IMulticlassOutLikelihoodClassifier`2 {
    public abstract virtual double Probability(TInput input, TClasses& decision);
    public abstract virtual double LogLikelihood(TInput input, TClasses& decision);
}
public interface Accord.MachineLearning.IMulticlassOutScoreClassifier`2 {
    public abstract virtual double Score(TInput input, TClasses& decision);
}
public interface Accord.MachineLearning.IMulticlassRefLikelihoodClassifier`2 {
}
public interface Accord.MachineLearning.IMulticlassRefScoreClassifier`2 {
}
public interface Accord.MachineLearning.IMulticlassScoreClassifier`1 {
    public abstract virtual int Decide(TInput input);
    public abstract virtual Int32[] Decide(TInput[] input);
    public abstract virtual double Score(TInput input);
    public abstract virtual Double[] Score(TInput[] input);
    public abstract virtual Double[] Score(TInput[] input, Double[] result);
    public abstract virtual IMultilabelScoreClassifier`1<TInput> ToMultilabel();
}
public interface Accord.MachineLearning.IMulticlassScoreClassifier`2 {
}
public interface Accord.MachineLearning.IMulticlassScoreClassifierBase`2 {
    public abstract virtual Double[] Score(TInput[] input, TClasses[]& decision);
    public abstract virtual Double[] Score(TInput[] input, TClasses[]& decision, Double[] result);
}
public interface Accord.MachineLearning.IMultilabelClassifier {
}
public interface Accord.MachineLearning.IMultilabelClassifier`1 {
}
public interface Accord.MachineLearning.IMultilabelClassifier`2 {
    public abstract virtual TClasses Decide(TInput input, TClasses result);
}
public interface Accord.MachineLearning.IMultilabelLikelihoodClassifier`1 {
    public abstract virtual double Probability(TInput input, int classIndex);
    public abstract virtual Double[] Probability(TInput[] input, Int32[] classIndex);
    public abstract virtual Double[] Probability(TInput[] input, Int32[] classIndex, Double[] result);
    public abstract virtual Double[] Probability(TInput[] input, int classIndex);
    public abstract virtual Double[] Probability(TInput[] input, int classIndex, Double[] result);
    public abstract virtual double LogLikelihood(TInput input, int classIndex);
    public abstract virtual Double[] LogLikelihood(TInput[] input, Int32[] classIndex);
    public abstract virtual Double[] LogLikelihood(TInput[] input, Int32[] classIndex, Double[] result);
    public abstract virtual Double[] LogLikelihood(TInput[] input, int classIndex);
    public abstract virtual Double[] LogLikelihood(TInput[] input, int classIndex, Double[] result);
    public abstract virtual Double[] LogLikelihoods(TInput input);
    public abstract virtual Double[] LogLikelihoods(TInput input, Double[] result);
    public abstract virtual Double[][] LogLikelihoods(TInput[] input);
    public abstract virtual Double[][] LogLikelihoods(TInput[] input, Double[][] result);
    public abstract virtual Double[] Probabilities(TInput input);
    public abstract virtual Double[] Probabilities(TInput input, Double[] result);
    public abstract virtual Double[][] Probabilities(TInput[] input);
    public abstract virtual Double[][] Probabilities(TInput[] input, Double[][] result);
    public abstract virtual IMulticlassLikelihoodClassifier`1<TInput> ToMulticlass();
    public abstract virtual IMulticlassLikelihoodClassifier`2<TInput, T> ToMulticlass();
}
public interface Accord.MachineLearning.IMultilabelLikelihoodClassifier`2 {
}
public interface Accord.MachineLearning.IMultilabelLikelihoodClassifierBase`2 {
    public abstract virtual Double[][] Probabilities(TInput[] input, TClasses[]& decision);
    public abstract virtual Double[][] Probabilities(TInput[] input, TClasses[]& decision, Double[][] result);
    public abstract virtual Double[][] LogLikelihoods(TInput[] input, TClasses[]& decision);
    public abstract virtual Double[][] LogLikelihoods(TInput[] input, TClasses[]& decision, Double[][] result);
}
public interface Accord.MachineLearning.IMultilabelOutLikelihoodClassifier`2 {
    public abstract virtual Double[] Probabilities(TInput input, TClasses& decision);
    public abstract virtual Double[] Probabilities(TInput input, TClasses& decision, Double[] result);
    public abstract virtual Double[] LogLikelihoods(TInput input, TClasses& decision);
    public abstract virtual Double[] LogLikelihoods(TInput input, TClasses& decision, Double[] result);
}
public interface Accord.MachineLearning.IMultilabelOutScoreClassifier`2 {
    public abstract virtual Double[] Scores(TInput input, TClasses& decision);
    public abstract virtual Double[] Scores(TInput input, TClasses& decision, Double[] result);
}
public interface Accord.MachineLearning.IMultilabelRefLikelihoodClassifier`2 {
    public abstract virtual Double[] Probabilities(TInput input, TClasses& decision);
    public abstract virtual Double[] Probabilities(TInput input, TClasses& decision, Double[] result);
    public abstract virtual Double[] LogLikelihoods(TInput input, TClasses& decision);
    public abstract virtual Double[] LogLikelihoods(TInput input, TClasses& decision, Double[] result);
}
public interface Accord.MachineLearning.IMultilabelRefScoreClassifier`2 {
    public abstract virtual Double[] Scores(TInput input, TClasses& decision);
    public abstract virtual Double[] Scores(TInput input, TClasses& decision, Double[] result);
}
public interface Accord.MachineLearning.IMultilabelScoreClassifier`1 {
    public abstract virtual double Score(TInput input, int classIndex);
    public abstract virtual Double[] Score(TInput[] input, Int32[] classIndex);
    public abstract virtual Double[] Score(TInput[] input, Int32[] classIndex, Double[] result);
    public abstract virtual Double[] Score(TInput[] input, int classIndex);
    public abstract virtual Double[] Score(TInput[] input, int classIndex, Double[] result);
    public abstract virtual Double[] Scores(TInput input);
    public abstract virtual Double[] Scores(TInput input, Double[] result);
    public abstract virtual Double[][] Scores(TInput[] input);
    public abstract virtual Double[][] Scores(TInput[] input, Double[][] result);
    public abstract virtual IMulticlassScoreClassifier`1<TInput> ToMulticlass();
    public abstract virtual IMulticlassScoreClassifier`2<TInput, T> ToMulticlass();
}
public interface Accord.MachineLearning.IMultilabelScoreClassifier`2 {
}
public interface Accord.MachineLearning.IMultilabelScoreClassifierBase`2 {
    public abstract virtual Double[][] Scores(TInput[] input, TClasses[]& decision);
    public abstract virtual Double[][] Scores(TInput[] input, TClasses[]& decision, Double[][] result);
}
public interface Accord.MachineLearning.IMultipleRegression`1 {
}
public interface Accord.MachineLearning.IMultipleRegression`2 {
}
public interface Accord.MachineLearning.IMultipleTransform`2 {
    public abstract virtual TOutput[] Transform(TInput[] input, TOutput result);
}
public interface Accord.MachineLearning.IParallel {
    public ParallelOptions ParallelOptions { get; public set; }
    public abstract virtual ParallelOptions get_ParallelOptions();
    public abstract virtual void set_ParallelOptions(ParallelOptions value);
}
public interface Accord.MachineLearning.IRegression`1 {
}
public interface Accord.MachineLearning.IRegression`2 {
    public abstract virtual TOutput Regress(TInput input);
    public abstract virtual TOutput[] Regress(TInput[] input);
    public abstract virtual TOutput[] Regress(TInput[] input, TOutput[] result);
}
public interface Accord.MachineLearning.IScoreTagger`1 {
    public abstract virtual Double[][] Scores(TInput[] sequence);
    public abstract virtual Double[][] Scores(TInput[] sequence, Double[][] result);
    public abstract virtual Double[][] Scores(TInput[] sequence, Int32[]& decision);
    public abstract virtual Double[][] Scores(TInput[] sequence, Int32[]& decision, Double[][] result);
    public abstract virtual Double[][][] Scores(TInput[][] sequences);
    public abstract virtual Double[][][] Scores(TInput[][] sequences, Double[][][] result);
    public abstract virtual Double[][][] Scores(TInput[][] sequences, Int32[][]& decision);
    public abstract virtual Double[][][] Scores(TInput[][] sequences, Int32[][]& decision, Double[][][] result);
}
public interface Accord.MachineLearning.ISupportsCancellation {
    public CancellationToken Token { get; public set; }
    public abstract virtual CancellationToken get_Token();
    public abstract virtual void set_Token(CancellationToken value);
}
public interface Accord.MachineLearning.ITagger`1 {
}
public interface Accord.MachineLearning.ITransform {
    public int NumberOfInputs { get; public set; }
    public int NumberOfOutputs { get; public set; }
    public abstract virtual int get_NumberOfInputs();
    public abstract virtual void set_NumberOfInputs(int value);
    public abstract virtual int get_NumberOfOutputs();
    public abstract virtual void set_NumberOfOutputs(int value);
}
public interface Accord.MachineLearning.ITransform`1 {
}
public interface Accord.MachineLearning.ITransform`2 {
    public abstract virtual TOutput[] Transform(TInput[] input, TOutput[] result);
}
public class Accord.Math.Converters.RationalConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    private static bool IsNullableType(Type t);
    private static Type GetUnderlyingType(Type t);
}
public class Accord.Math.Hyperrectangle : ValueType {
    private Double[] min;
    private Double[] max;
    public Double[] Min { get; }
    public Double[] Max { get; }
    public int NumberOfDimensions { get; }
    public Hyperrectangle(double x, double y, double width, double height);
    public Hyperrectangle(Double[] min, Double[] max, bool copy);
    public Double[] get_Min();
    public Double[] get_Max();
    public int get_NumberOfDimensions();
    public Double[] GetLength();
    public static Hyperrectangle FromMinAndMax(Double[] min, Double[] max, bool copy);
    public static Hyperrectangle FromMinAndLength(Double[] min, Double[] size, bool copy);
    public bool IntersectsWith(Hyperrectangle rect);
    public bool Contains(Double[] point);
    public sealed virtual bool Equals(Hyperrectangle other);
    public sealed virtual object Clone();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[TypeConverterAttribute("Accord.Math.Converters.RationalConverter")]
public class Accord.Math.Rational : ValueType {
    private static double DEFAULT_TOLERANCE;
    [DecimalConstantAttribute("15", "0", "0", "0", "1")]
private static decimal DEFAULT_DECIMAL_TOLERANCE;
    private static float DEFAULT_FLOAT_TOLERANCE;
    private int _numerator;
    private int _denominator;
    public static Rational Zero;
    public static Rational One;
    public static Rational MinValue;
    public static Rational MaxValue;
    public static Rational Indeterminate;
    public static Rational PositiveInfinity;
    public static Rational NegativeInfinity;
    public static Rational Epsilon;
    public int Numerator { get; }
    public int Denominator { get; }
    public double Value { get; }
    public Rational(int numerator);
    public Rational(int numerator, int denominator);
    public Rational(double value);
    private static Rational();
    public static Rational Parse(string s);
    public static Rational Parse(string s, NumberStyles style);
    public static Rational Parse(string s, IFormatProvider provider);
    public static Rational Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Rational& result);
    public static bool TryParse(string s, NumberStyles style, Rational& result);
    public static bool TryParse(string s, IFormatProvider provider, Rational& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Rational& result);
    private static bool TryParse(string s, NumberStyles style, IFormatProvider provider, bool throwOnFailure, Rational& result);
    private static bool ParseFailure(bool throwOnFailure, Rational& result);
    private static bool TryParseInt(string s, NumberStyles style, IFormatProvider provider, bool throwOnFailure, Int32& result);
    public static Rational FromDouble(double value, double tolerance);
    public static Rational FromDecimal(decimal value, decimal tolerance);
    public static Rational FromDoubleWithMaxDenominator(double value, int maxDenominator, double tolerance);
    public static Rational Abs(Rational value);
    public static Rational Min(Rational val1, Rational val2);
    public static Rational Max(Rational val1, Rational val2);
    public static int Round(Rational x);
    public static Rational Pow(Rational baseValue, int exponent);
    public static int DivRem(Rational a, Rational b, Rational& remainder);
    public static bool IsInfinity(Rational r);
    public static bool IsPositiveInfinity(Rational r);
    public static bool IsNegativeInfinity(Rational r);
    public static bool IsIndeterminate(Rational r);
    public static bool IsZero(Rational r);
    public int get_Numerator();
    public int get_Denominator();
    public double get_Value();
    public Rational Inverse();
    public Rational Negate();
    public static Rational Simplify(int numerator, int denominator);
    public static Rational Simplify(long numerator, long denominator);
    public Rational Simplify();
    public double ToDouble();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public string ToMixedString();
    public string ToMixedString(string numberSeparator);
    public virtual bool Equals(object obj);
    public bool StrictlyEquals(Rational r);
    public virtual int GetHashCode();
    private static int FnvCombine(Int32[] hashes);
    public static bool op_Equality(Rational x, Rational y);
    public static bool op_Inequality(Rational x, Rational y);
    public static bool op_GreaterThan(Rational x, Rational y);
    public static bool op_GreaterThanOrEqual(Rational x, Rational y);
    public static bool op_LessThan(Rational x, Rational y);
    public static bool op_LessThanOrEqual(Rational x, Rational y);
    public static Rational op_UnaryPlus(Rational x);
    public static Rational op_UnaryNegation(Rational x);
    public static Rational op_Addition(Rational x, Rational y);
    public static Rational op_Subtraction(Rational x, Rational y);
    public static Rational op_Multiply(Rational x, Rational y);
    public static Rational op_Division(Rational x, Rational y);
    public static Rational op_Modulus(Rational x, Rational y);
    public static Rational op_Increment(Rational x);
    public static Rational op_Decrement(Rational x);
    public static Rational op_Implicit(int x);
    public static int op_Explicit(Rational x);
    public static Rational op_Implicit(UInt32 x);
    public static UInt32 op_Explicit(Rational x);
    public static Rational op_Implicit(short x);
    public static short op_Explicit(Rational x);
    public static Rational op_Implicit(ushort x);
    public static ushort op_Explicit(Rational x);
    public static Rational op_Implicit(long x);
    public static long op_Explicit(Rational x);
    public static Rational op_Implicit(ulong x);
    public static ulong op_Explicit(Rational x);
    public static Rational op_Implicit(sbyte x);
    public static sbyte op_Explicit(Rational x);
    public static Rational op_Implicit(byte x);
    public static byte op_Explicit(Rational x);
    public static Rational op_Explicit(float x);
    public static float op_Explicit(Rational x);
    public static Rational op_Explicit(double x);
    public static double op_Explicit(Rational x);
    public static Rational op_Explicit(decimal x);
    public static decimal op_Explicit(Rational x);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Rational other);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool Equals(Rational other);
    private static bool IsInteger(decimal x, decimal tolerance);
    private static bool IsInteger(float x, float tolerance);
    private static bool IsInteger(double x, double tolerance);
    private static int Gcd(int x, int y);
    private static long Gcd(long x, long y);
    private static int Lcm(int x, int y);
    private static long Lcm(long x, long y);
}
[ExtensionAttribute]
public static class Accord.Math.Sparse : object {
    public static Sparse`1<double> Parse(string values, Nullable`1<double> insertValueAtBeginning);
    public static Sparse`1<double> Parse(String[] values, Nullable`1<double> insertValueAtBeginning);
    [ExtensionAttribute]
public static T[][] ToDense(Sparse`1[] vectors);
    [ExtensionAttribute]
public static T[][] ToDense(Sparse`1[] vectors, int length);
    public static Sparse`1<T> FromDense(T[] dense, bool removeZeros);
    public static Sparse`1[] FromDense(T[][] dense, bool removeZeros);
    [ExtensionAttribute]
public static int Columns(Sparse`1[] inputs);
    public static Sparse`1<double> FromDictionary(IDictionary`2<int, int> dictionary);
}
[DefaultMemberAttribute("Item")]
public class Accord.Math.Sparse`1 : object {
    private Int32[] indices;
    private T[] values;
    public Int32[] Indices { get; public set; }
    public T[] Values { get; public set; }
    public T Item { get; public set; }
    public int Length { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Sparse`1(int length);
    public Sparse`1(Int32[] indices, T[] values);
    public Int32[] get_Indices();
    public void set_Indices(Int32[] value);
    public T[] get_Values();
    public void set_Values(T[] value);
    public T[] ToDense();
    public T[] ToDense(int length);
    public T[] ToSparse();
    public T get_Item(int i);
    public void set_Item(int i, T value);
    public sealed virtual object Clone();
    public static Array op_Implicit(Sparse`1<T> obj);
    public int get_Length();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public bool IsFull();
}
public class Accord.MessageTransferHandler : MulticastDelegate {
    public MessageTransferHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CommunicationBufferEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, CommunicationBufferEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("2048")]
public class Accord.NegativeAttribute : RealAttribute {
    public NegativeAttribute(double minimum, double maximum);
}
[AttributeUsageAttribute("2048")]
public class Accord.NegativeIntegerAttribute : IntegerAttribute {
    public NegativeIntegerAttribute(int minimum, int maximum);
}
[AttributeUsageAttribute("2048")]
public class Accord.NonnegativeAttribute : RangeAttribute {
    public NonnegativeAttribute(double minimum, double maximum);
}
[AttributeUsageAttribute("2048")]
public class Accord.NonnegativeIntegerAttribute : IntegerAttribute {
    public NonnegativeIntegerAttribute(int minimum, int maximum);
}
[AttributeUsageAttribute("2048")]
public class Accord.NonpositiveAttribute : RealAttribute {
    public NonpositiveAttribute(double minimum, double maximum);
}
public class Accord.NonPositiveDefiniteMatrixException : Exception {
    public NonPositiveDefiniteMatrixException(string message);
    public NonPositiveDefiniteMatrixException(string message, Exception innerException);
    protected NonPositiveDefiniteMatrixException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
public class Accord.NonpositiveIntegerAttribute : IntegerAttribute {
    public NonpositiveIntegerAttribute(int minimum, int maximum);
}
public class Accord.NonSymmetricMatrixException : InvalidOperationException {
    public NonSymmetricMatrixException(string message);
    public NonSymmetricMatrixException(string message, Exception innerException);
    protected NonSymmetricMatrixException(SerializationInfo info, StreamingContext context);
}
public class Accord.NotConnectedException : Exception {
    public NotConnectedException(string message);
    public NotConnectedException(string message, Exception innerException);
    public NotConnectedException(SerializationInfo info, StreamingContext context);
}
public class Accord.Point : ValueType {
    public float X;
    public float Y;
    public Point(float x, float y);
    public float DistanceTo(Point anotherPoint);
    public float SquaredDistanceTo(Point anotherPoint);
    public static Point op_Addition(Point point1, Point point2);
    public static Point Add(Point point1, Point point2);
    public static Point op_Subtraction(Point point1, Point point2);
    public static Point Subtract(Point point1, Point point2);
    public static Point op_Addition(Point point, float valueToAdd);
    public static Point Add(Point point, float valueToAdd);
    public static Point op_Subtraction(Point point, float valueToSubtract);
    public static Point Subtract(Point point, float valueToSubtract);
    public static Point op_Multiply(Point point, float factor);
    public static Point Multiply(Point point, float factor);
    public static Point op_Division(Point point, float factor);
    public static Point Divide(Point point, float factor);
    public static bool op_Equality(Point point1, Point point2);
    public static bool op_Inequality(Point point1, Point point2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static IntPoint op_Explicit(Point point);
    public static DoublePoint op_Implicit(Point point);
    public IntPoint Round();
    public virtual string ToString();
    public float EuclideanNorm();
}
public static class Accord.PolishExpression : object {
    public static double Evaluate(string expression, Double[] variables);
}
[AttributeUsageAttribute("2048")]
public class Accord.PositiveAttribute : RealAttribute {
    public PositiveAttribute(double minimum, double maximum);
}
[AttributeUsageAttribute("2048")]
public class Accord.PositiveIntegerAttribute : IntegerAttribute {
    public PositiveIntegerAttribute(int minimum, int maximum);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Accord.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NotSupportedWeights { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NotSupportedWeights();
}
public class Accord.Range : ValueType {
    private float min;
    private float max;
    public float Min { get; public set; }
    public float Max { get; public set; }
    public float Length { get; }
    public Range(float min, float max);
    public sealed virtual float get_Min();
    public sealed virtual void set_Min(float value);
    public sealed virtual float get_Max();
    public sealed virtual void set_Max(float value);
    public float get_Length();
    public bool IsInside(float x);
    public bool IsInside(Range range);
    public bool IsOverlapping(Range range);
    public Range Intersection(Range range);
    public static bool op_Equality(Range range1, Range range2);
    public static bool op_Inequality(Range range1, Range range2);
    public sealed virtual bool Equals(Range other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static DoubleRange op_Implicit(Range range);
    public IntRange ToIntRange(bool provideInnerRange);
}
[AttributeUsageAttribute("2048")]
public class Accord.RealAttribute : RangeAttribute {
    public double Minimum { get; }
    public double Maximum { get; }
    public RealAttribute(double minimum, double maximum);
    public double get_Minimum();
    public double get_Maximum();
}
[AttributeUsageAttribute("4")]
public class Accord.SerializationBinderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SerializationBinder <Binder>k__BackingField;
    public SerializationBinder Binder { get; private set; }
    public SerializationBinderAttribute(Type binderType);
    [CompilerGeneratedAttribute]
public SerializationBinder get_Binder();
    [CompilerGeneratedAttribute]
private void set_Binder(SerializationBinder value);
}
public class Accord.SingularMatrixException : Exception {
    public SingularMatrixException(string message);
    public SingularMatrixException(string message, Exception innerException);
    protected SingularMatrixException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class Accord.SourceTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    private Type SourceType { get; private set; }
    public SourceTypeAttribute(Type type);
    [CompilerGeneratedAttribute]
private Type get_SourceType();
    [CompilerGeneratedAttribute]
private void set_SourceType(Type value);
}
[AttributeUsageAttribute("4")]
public class Accord.SurrogateSelectorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SurrogateSelector <Selector>k__BackingField;
    public SurrogateSelector Selector { get; private set; }
    public SurrogateSelectorAttribute(Type surrogateSelectorType);
    [CompilerGeneratedAttribute]
public SurrogateSelector get_Selector();
    [CompilerGeneratedAttribute]
private void set_Selector(SurrogateSelector value);
}
public static class Accord.SystemTools : object {
    public static bool IsRunningOnMono();
    public static IntPtr CopyUnmanagedMemory(IntPtr dst, IntPtr src, int count);
    public static Byte* CopyUnmanagedMemory(Byte* dst, Byte* src, int count);
    public static IntPtr SetUnmanagedMemory(IntPtr dst, int filler, int count);
    public static Byte* SetUnmanagedMemory(Byte* dst, int filler, int count);
    private static Byte* memcpy(Byte* dst, Byte* src, int count);
    private static Byte* memset(Byte* dst, int filler, int count);
}
[ObsoleteAttribute("Prefer the use of ThreadLocal over shared Random objects.")]
public class Accord.ThreadSafeRandom : Random {
    private object sync;
    public ThreadSafeRandom(int seed);
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buffer);
    public virtual double NextDouble();
}
[AttributeUsageAttribute("2048")]
public class Accord.UnitAttribute : RangeAttribute {
}
internal class System.Collections.Concurrent.Dummy : object {
}
internal class System.Numerics.Dummy : object {
}
internal class System.Threading.Dummy : object {
}
internal class System.Threading.Tasks.Dummy : object {
}
