internal class Accord.IO.ArrayFlags : ValueType {
    public MatArrayType Class;
    public ArrayFlagsType Flags;
    public int NonZeroElements;
}
[FlagsAttribute]
internal enum Accord.IO.ArrayFlagsType : Enum {
    public byte value__;
    public static ArrayFlagsType None;
    public static ArrayFlagsType Logical;
    public static ArrayFlagsType Global;
    public static ArrayFlagsType Complex;
}
internal enum Accord.IO.MatArrayType : Enum {
    public byte value__;
    public static MatArrayType mxCELL_CLASS;
    public static MatArrayType mxSTRUCT_CLASS;
    public static MatArrayType mxOBJECT_CLASS;
    public static MatArrayType mxCHAR_CLASS;
    public static MatArrayType mxSPARSE_CLASS;
    public static MatArrayType mxDOUBLE_CLASS;
    public static MatArrayType mxSINGLE_CLASS;
    public static MatArrayType mxINT8_CLASS;
    public static MatArrayType mxUINT8_CLASS;
    public static MatArrayType mxINT16_CLASS;
    public static MatArrayType mxUINT16_CLASS;
    public static MatArrayType mxINT32_CLASS;
    public static MatArrayType mxUINT32_CLASS;
    public static MatArrayType mxINT64_CLASS;
    public static MatArrayType mxUINT64_CLASS;
}
internal class Accord.IO.MatDataTag : ValueType {
    public MatDataType DataType;
    public int NumberOfBytes;
    public short SmallData_NumberOfBytes;
    public MatDataType SmallData_Type;
    [FixedBufferAttribute("System.Byte", "4")]
public <SmallData_Value>e__FixedBuffer SmallData_Value;
    public bool IsSmallFormat { get; }
    public bool get_IsSmallFormat();
}
internal enum Accord.IO.MatDataType : Enum {
    public short value__;
    public static MatDataType miINT8;
    public static MatDataType miUINT8;
    public static MatDataType miINT16;
    public static MatDataType miUINT16;
    public static MatDataType miINT32;
    public static MatDataType miUINT32;
    public static MatDataType miSINGLE;
    public static MatDataType miDOUBLE;
    public static MatDataType miINT64;
    public static MatDataType miUINT64;
    public static MatDataType miMATRIX;
    public static MatDataType miCOMPRESSED;
    public static MatDataType miUTF8;
    public static MatDataType miUTF16;
    public static MatDataType miUTF32;
}
internal class Accord.IO.MatHeader : ValueType {
    public string TextField;
    public int SubsystemDataOffset;
    public short Version;
    public string Endian;
}
[DefaultMemberAttribute("Item")]
public class Accord.IO.MatNode : object {
    private long startOffset;
    private long matrixOffset;
    private Dictionary`2<string, MatNode> contents;
    private BinaryReader reader;
    private MatReader matReader;
    private bool compressed;
    private MatDataType matType;
    private int typeSize;
    private int length;
    private int bytes;
    private Type type;
    private object value;
    private Int32[] dimensions;
    private int readBytes;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public Dictionary`2<string, MatNode> Fields { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Count { get; }
    public MatNode Item { get; }
    public MatNode Item { get; }
    internal MatNode(MatReader matReader, BinaryReader reader, long offset, MatDataTag tag, bool lazy);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public Dictionary`2<string, MatNode> get_Fields();
    public object get_Value();
    public Type get_ValueType();
    public T GetValue();
    public int get_Count();
    public MatNode get_Item(string name);
    public MatNode get_Item(int name);
    private static void align(BinaryReader reader, int rreadBytes);
    private object read();
    private Array read(BinaryReader reader);
    public sealed virtual IEnumerator`1<MatNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class Accord.IO.MatReader : object {
    private BinaryReader reader;
    private bool autoTranspose;
    private Dictionary`2<string, MatNode> contents;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BigEndian>k__BackingField;
    public String[] FieldNames { get; }
    public Dictionary`2<string, MatNode> Fields { get; }
    public string Description { get; private set; }
    public int Version { get; private set; }
    public bool BigEndian { get; private set; }
    public bool Transpose { get; }
    public Stream BaseStream { get; }
    public MatNode Item { get; }
    public MatNode Item { get; }
    public MatReader(string fileName, bool autoTranspose, bool lazy);
    public MatReader(Stream input, bool autoTranspose, bool lazy);
    public MatReader(Byte[] input, bool autoTranspose, bool lazy);
    public MatReader(BinaryReader reader, bool autoTranspose, bool lazy);
    public String[] get_FieldNames();
    public Dictionary`2<string, MatNode> get_Fields();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    [CompilerGeneratedAttribute]
public bool get_BigEndian();
    [CompilerGeneratedAttribute]
private void set_BigEndian(bool value);
    public bool get_Transpose();
    public Stream get_BaseStream();
    public MatNode get_Item(string key);
    public MatNode get_Item(int key);
    private void init(BinaryReader reader, bool autoTranspose, bool lazy);
    public T Read(string key);
    public object Read(string key);
    internal static Type Translate(MatDataType type);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public class Accord.IO.MatSparse : object {
    [CompilerGeneratedAttribute]
private Int32[] <Rows>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private Array <Values>k__BackingField;
    public Int32[] Rows { get; private set; }
    public Int32[] Columns { get; private set; }
    public Array Values { get; private set; }
    internal MatSparse(Int32[] ir, Int32[] ic, Array values);
    [CompilerGeneratedAttribute]
public Int32[] get_Rows();
    [CompilerGeneratedAttribute]
private void set_Rows(Int32[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_Columns();
    [CompilerGeneratedAttribute]
private void set_Columns(Int32[] value);
    [CompilerGeneratedAttribute]
public Array get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(Array value);
}
public static class Accord.IO.NpyFormat : object {
    public static T Load(Byte[] bytes);
    public static T Load(Byte[] bytes, T& value);
    public static T Load(string path, T& value);
    public static T Load(Stream stream, T& value);
    public static T Load(string path);
    public static T Load(Stream stream);
    public static Array LoadMatrix(Byte[] bytes);
    public static Array LoadMatrix(string path);
    public static Array LoadJagged(Byte[] bytes);
    public static Array LoadJagged(string path);
    public static Array LoadMatrix(Stream stream);
    public static Array LoadJagged(Stream stream, bool trim);
    private static Array readValueMatrix(BinaryReader reader, Array matrix, int bytes, Type type, Int32[] shape);
    private static Array readValueJagged(BinaryReader reader, Array matrix, int bytes, Type type, Int32[] shape);
    private static Array readStringMatrix(BinaryReader reader, Array matrix, int bytes, Type type, Int32[] shape);
    private static bool parseReader(BinaryReader reader, Int32& bytes, Type& t, Int32[]& shape);
    private static Type GetType(string dtype, Int32& bytes, Nullable`1& isLittleEndian);
    private static Nullable`1<bool> IsLittleEndian(string type);
    public static Byte[] Save(Array array);
    public static ulong Save(Array array, string path);
    public static ulong Save(Array array, Stream stream);
    private static ulong writeValueMatrix(BinaryWriter reader, Array matrix, int bytes, Int32[] shape);
    private static ulong writeValueJagged(BinaryWriter reader, Array matrix, int bytes, Int32[] shape);
    private static ulong writeStringMatrix(BinaryWriter reader, Array matrix, int bytes, Int32[] shape);
    private static int writeHeader(BinaryWriter writer, string dtype, Int32[] shape);
    private static string GetDtypeFromType(Array array, Type& type, Int32& bytes);
}
public class Accord.IO.NpzDictionary : NpzDictionary`1<Array> {
    private bool jagged;
    public NpzDictionary(Stream stream, bool jagged);
    protected virtual Array Load(Stream s);
}
[DefaultMemberAttribute("Item")]
public class Accord.IO.NpzDictionary`1 : object {
    private Stream stream;
    private ZipArchive archive;
    private bool disposedValue;
    private Dictionary`2<string, ZipArchiveEntry> entries;
    private Dictionary`2<string, T> arrays;
    public IEnumerable`1<string> Keys { get; }
    public IEnumerable`1<T> Values { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public T Item { get; }
    public NpzDictionary`1(Stream stream);
    public sealed virtual IEnumerable`1<string> get_Keys();
    public sealed virtual IEnumerable`1<T> get_Values();
    public sealed virtual int get_Count();
    public object get_SyncRoot();
    public bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual T get_Item(string key);
    private T OpenEntry(ZipArchiveEntry entry);
    protected virtual T Load(Stream s);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool TryGetValue(string key, T& value);
    [IteratorStateMachineAttribute("Accord.IO.NpzDictionary`1/<GetEnumerator>d__24")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, T>> GetEnumerator();
    [IteratorStateMachineAttribute("Accord.IO.NpzDictionary`1/<System-Collections-IEnumerable-GetEnumerator>d__25")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Accord.IO.NpzDictionary`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__26")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Remove(T item);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public static class Accord.IO.NpzFormat : object {
    private static CompressionLevel DEFAULT_COMPRESSION;
    public static void Load(Byte[] bytes, T& value);
    public static void Load(string path, T& value);
    public static void Load(Stream stream, T& value);
    public static NpzDictionary`1<T> Load(Byte[] bytes);
    public static NpzDictionary`1<T> Load(string path, NpzDictionary`1& value);
    public static NpzDictionary`1<T> Load(Stream stream, NpzDictionary`1& value);
    public static NpzDictionary`1<T> Load(string path);
    public static NpzDictionary`1<T> Load(Stream stream);
    public static NpzDictionary`1<Array> LoadMatrix(Byte[] bytes);
    public static NpzDictionary`1<Array> LoadMatrix(string path);
    public static NpzDictionary`1<Array> LoadMatrix(Stream stream);
    public static NpzDictionary`1<Array> LoadJagged(Byte[] bytes);
    public static NpzDictionary`1<Array> LoadJagged(string path);
    public static NpzDictionary`1<Array> LoadJagged(Stream stream, bool trim);
    public static Byte[] Save(Dictionary`2<string, Array> arrays, CompressionLevel compression);
    public static Byte[] Save(Array array, CompressionLevel compression);
    public static void Save(Dictionary`2<string, Array> arrays, string path, CompressionLevel compression);
    public static void Save(Array array, string path, CompressionLevel compression);
    public static void Save(Dictionary`2<string, Array> arrays, Stream stream, CompressionLevel compression, bool leaveOpen);
    public static void Save(Array array, Stream stream, CompressionLevel compression, bool leaveOpen);
}
[SerializableAttribute]
public class Accord.MachineLearning.ParallelLearningBase : object {
    [NonSerializedAttribute]
private ParallelOptions parallelOptions;
    public ParallelOptions ParallelOptions { get; public set; }
    public CancellationToken Token { get; public set; }
    public sealed virtual ParallelOptions get_ParallelOptions();
    public sealed virtual void set_ParallelOptions(ParallelOptions value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    [OnDeserializedAttribute]
private void OnDeserializedMethod(StreamingContext context);
}
public class Accord.Math.AbsoluteConvergence : object {
    private double tolerance;
    private int maxIterations;
    private double newValue;
    [CompilerGeneratedAttribute]
private double <OldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentIteration>k__BackingField;
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public double OldValue { get; private set; }
    public double NewValue { get; public set; }
    public int CurrentIteration { get; public set; }
    public bool HasConverged { get; }
    public AbsoluteConvergence(int iterations, double tolerance, double startValue);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public double get_OldValue();
    [CompilerGeneratedAttribute]
private void set_OldValue(double value);
    public sealed virtual double get_NewValue();
    public sealed virtual void set_NewValue(double value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CurrentIteration();
    [CompilerGeneratedAttribute]
public void set_CurrentIteration(int value);
    public sealed virtual bool get_HasConverged();
    public sealed virtual void Clear();
}
public static class Accord.Math.Bessel : object {
    public static double J0(double x);
    public static double J(double x);
    public static double J(int n, double x);
    public static double Y0(double x);
    public static double Y(double x);
    public static double Y(int n, double x);
    public static double I0(double x);
    public static double I(double x);
    public static double I(int n, double x);
}
public static class Accord.Math.Beta : object {
    public static double Function(double a, double b);
    public static double Log(double a, double b);
    public static double Incomplete(double a, double b, double x);
    public static double Incbcf(double a, double b, double x);
    public static double Incbd(double a, double b, double x);
    public static double IncompleteInverse(double aa, double bb, double yy0);
    public static double PowerSeries(double a, double b, double x);
    public static double Multinomial(Double[] x);
}
[ExtensionAttribute]
public static class Accord.Math.Combinatorics : object {
    public static Int32[][] TruthTable(int length);
    public static Int32[][] TruthTable(int symbols, int length);
    [ExtensionAttribute]
public static Int32[][] TruthTable(Int32[] symbols);
    public static IEnumerable`1<Int32[]> Sequences(int length, bool inPlace);
    public static IEnumerable`1<Int32[]> Sequences(int symbols, int length, bool inPlace);
    [IteratorStateMachineAttribute("Accord.Math.Combinatorics/<Sequences>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<Int32[]> Sequences(Int32[] symbols, bool inPlace, bool firstColumnChangesFaster);
    [IteratorStateMachineAttribute("Accord.Math.Combinatorics/<Combinations>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<T[]> Combinations(T[] values, bool inPlace);
    [IteratorStateMachineAttribute("Accord.Math.Combinatorics/<Combinations>d__7`1")]
[ExtensionAttribute]
public static IEnumerable`1<T[]> Combinations(T[] values, int k, bool inPlace);
    [IteratorStateMachineAttribute("Accord.Math.Combinatorics/<Subsets>d__8`1")]
[ExtensionAttribute]
public static IEnumerable`1<SortedSet`1<T>> Subsets(ISet`1<T> set, bool inPlace);
    [IteratorStateMachineAttribute("Accord.Math.Combinatorics/<Subsets>d__9`1")]
[ExtensionAttribute]
public static IEnumerable`1<SortedSet`1<T>> Subsets(ISet`1<T> set, int k, bool inPlace);
    [IteratorStateMachineAttribute("Accord.Math.Combinatorics/<Permutations>d__10`1")]
public static IEnumerable`1<T[]> Permutations(T[] values, bool inPlace);
}
public class Accord.Math.Comparers.ArrayComparer`1 : object {
    public sealed virtual bool Equals(T[] x, T[] y);
    public sealed virtual int GetHashCode(T[] obj);
}
public enum Accord.Math.Comparers.ComparerDirection : Enum {
    public int value__;
    public static ComparerDirection Ascending;
    public static ComparerDirection Descending;
}
public class Accord.Math.Comparers.CustomComparer`1 : object {
    private Func`3<T, T, int> comparer;
    public CustomComparer`1(Func`3<T, T, int> comparer);
    public sealed virtual int Compare(T x, T y);
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
public class Accord.Math.Comparers.ElementComparer : ElementComparer`1<double> {
}
public class Accord.Math.Comparers.ElementComparer`1 : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    public sealed virtual int Compare(T[] x, T[] y);
    public sealed virtual bool Equals(T[] x, T[] y);
    public sealed virtual int GetHashCode(T[] obj);
}
public class Accord.Math.Comparers.GeneralComparer : object {
    private Func`2<double, double> map;
    private int direction;
    public ComparerDirection Direction { get; public set; }
    public GeneralComparer(ComparerDirection direction);
    public GeneralComparer(ComparerDirection direction, bool useAbsoluteValues);
    public GeneralComparer(ComparerDirection direction, Func`2<double, double> map);
    public ComparerDirection get_Direction();
    public void set_Direction(ComparerDirection value);
    public sealed virtual int Compare(double x, double y);
    public sealed virtual int Compare(int x, int y);
}
public class Accord.Math.Comparers.GeneralComparer`1 : object {
    private int direction;
    public ComparerDirection Direction { get; public set; }
    public GeneralComparer`1(ComparerDirection direction);
    public ComparerDirection get_Direction();
    public void set_Direction(ComparerDirection value);
    public sealed virtual int Compare(T x, T y);
}
[ObsoleteAttribute("Please use ArrayComparer<T> instead.")]
public class Accord.Math.Comparers.IntegerArrayComparer : ArrayComparer`1<int> {
}
[CompilerGeneratedAttribute]
internal class Accord.Math.Comparers.NamespaceDoc : object {
}
public class Accord.Math.Comparers.StableComparer`1 : object {
    private Comparison`1<T> comparison;
    public StableComparer`1(Comparison`1<T> comparison);
    public sealed virtual int Compare(KeyValuePair`2<int, T> x, KeyValuePair`2<int, T> y);
}
[ExtensionAttribute]
public static class Accord.Math.ComplexMatrix : object {
    [ExtensionAttribute]
public static Complex[] Abs(Complex[] x);
    [ExtensionAttribute]
public static Complex Sum(Complex[] x);
    [ExtensionAttribute]
public static Complex[] Multiply(Complex[] a, Complex[] b);
    [ExtensionAttribute]
public static Double[] Magnitude(Complex[] c);
    [ExtensionAttribute]
public static Double[0...,0...] Magnitude(Complex[0...,0...] c);
    [ExtensionAttribute]
public static Double[][] Magnitude(Complex[][] c);
    [ExtensionAttribute]
public static Double[] Phase(Complex[] c);
    [ExtensionAttribute]
public static Double[0...,0...] Phase(Complex[0...,0...] c);
    [ExtensionAttribute]
public static Double[][] Phase(Complex[][] c);
    [ExtensionAttribute]
public static Double[] Re(Complex[] c);
    [ExtensionAttribute]
public static Double[0...,0...] Re(Complex[0...,0...] c);
    [ExtensionAttribute]
public static Double[][] Re(Complex[][] c);
    [ExtensionAttribute]
public static Double[] Im(Complex[] c);
    [ExtensionAttribute]
public static Double[0...,0...] Im(Complex[0...,0...] c);
    [ExtensionAttribute]
public static Double[][] Im(Complex[][] c);
    [ExtensionAttribute]
public static Double[0...,0...] ToArray(Complex[] c);
    [ExtensionAttribute]
public static Complex[] ToComplex(Double[] real);
    [ExtensionAttribute]
public static Complex[] ToComplex(Double[] real, Double[] imag);
    [ExtensionAttribute]
public static DoubleRange Range(Complex[] array);
    [ExtensionAttribute]
public static bool IsEqual(Complex[][] objA, Complex[][] objB, double threshold);
    [ExtensionAttribute]
public static bool IsEqual(Complex[] objA, Complex[] objB, double threshold);
    [ExtensionAttribute]
public static double SquaredMagnitude(Complex value);
}
public static class Accord.Math.Constants : object {
    public static double EulerGamma;
    public static double DoubleEpsilon;
    [DecimalConstantAttribute("28", "0", "0", "0", "1")]
public static decimal DecimalEpsilon;
    public static float SingleEpsilon;
    public static double DoubleSmall;
    public static float SingleSmall;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal DecimalSmall;
    public static double LogMax;
    public static double LogMin;
    public static double Catalan;
    public static double LogPI;
    public static double Log2;
    public static double Log3;
    public static double LogSqrt2PI;
    public static double Log2PI;
    public static double Sqrt2PI;
    public static double SqrtHalfPI;
    public static double Sqrt2;
    public static double Sqrt2H;
    private static Constants();
    public static T One();
    public static T Zero();
}
[SerializableAttribute]
public class Accord.Math.ContinuousHistogram : object {
    private Int32[] values;
    private Range range;
    private float mean;
    private float stdDev;
    private float median;
    private float min;
    private float max;
    private int total;
    public Int32[] Values { get; }
    public Range Range { get; }
    public float Mean { get; }
    public float StdDev { get; }
    public float Median { get; }
    public float Min { get; }
    public float Max { get; }
    public ContinuousHistogram(Int32[] values, Range range);
    public Int32[] get_Values();
    public Range get_Range();
    public float get_Mean();
    public float get_StdDev();
    public float get_Median();
    public float get_Min();
    public float get_Max();
    public Range GetRange(float percent);
    public void Update();
}
public class Accord.Math.Convergence.GeneralConvergence : object {
    private int n;
    private double ftol_rel;
    private double ftol_abs;
    private double xtol_rel;
    private Double[] xtol_abs;
    private int nevals;
    private int maxeval;
    private TimeSpan maxtime;
    private DateTime start;
    private bool force_stop;
    public int NumberOfVariables { get; public set; }
    public double RelativeFunctionTolerance { get; public set; }
    public double AbsoluteFunctionTolerance { get; public set; }
    public double RelativeParameterTolerance { get; public set; }
    public Double[] AbsoluteParameterTolerance { get; public set; }
    public int Evaluations { get; public set; }
    public int MaximumEvaluations { get; public set; }
    public TimeSpan MaximumTime { get; public set; }
    public DateTime StartTime { get; public set; }
    public bool Cancel { get; public set; }
    public GeneralConvergence(int numberOfVariables);
    public int get_NumberOfVariables();
    public void set_NumberOfVariables(int value);
    public double get_RelativeFunctionTolerance();
    public void set_RelativeFunctionTolerance(double value);
    public double get_AbsoluteFunctionTolerance();
    public void set_AbsoluteFunctionTolerance(double value);
    public double get_RelativeParameterTolerance();
    public void set_RelativeParameterTolerance(double value);
    public Double[] get_AbsoluteParameterTolerance();
    public void set_AbsoluteParameterTolerance(Double[] value);
    public int get_Evaluations();
    public void set_Evaluations(int value);
    public int get_MaximumEvaluations();
    public void set_MaximumEvaluations(int value);
    public TimeSpan get_MaximumTime();
    public void set_MaximumTime(TimeSpan value);
    public DateTime get_StartTime();
    public void set_StartTime(DateTime value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public static class Accord.Math.CosineTransform : object {
    public static void DCT(Double[] data);
    public static void IDCT(Double[] data);
    public static void DCT(Double[0...,0...] data);
    public static void IDCT(Double[0...,0...] data);
}
public class Accord.Math.CSharpArrayFormatProvider : MatrixFormatProviderBase {
    private static CSharpArrayFormatProvider currentCulture;
    private static CSharpArrayFormatProvider invariantCulture;
    public static CSharpArrayFormatProvider CurrentCulture { get; }
    public static CSharpArrayFormatProvider InvariantCulture { get; }
    public CSharpArrayFormatProvider(IFormatProvider innerProvider, bool includeTypeName, bool includeSemicolon);
    private static CSharpArrayFormatProvider();
    public static CSharpArrayFormatProvider get_CurrentCulture();
    public static CSharpArrayFormatProvider get_InvariantCulture();
}
public class Accord.Math.CSharpJaggedMatrixFormatProvider : MatrixFormatProviderBase {
    private static CSharpJaggedMatrixFormatProvider currentCulture;
    private static CSharpJaggedMatrixFormatProvider invariantCulture;
    public static CSharpJaggedMatrixFormatProvider CurrentCulture { get; }
    public static CSharpJaggedMatrixFormatProvider InvariantCulture { get; }
    public CSharpJaggedMatrixFormatProvider(IFormatProvider innerProvider);
    private static CSharpJaggedMatrixFormatProvider();
    public static CSharpJaggedMatrixFormatProvider get_CurrentCulture();
    public static CSharpJaggedMatrixFormatProvider get_InvariantCulture();
}
public class Accord.Math.CSharpMatrixFormatProvider : MatrixFormatProviderBase {
    private static CSharpMatrixFormatProvider currentCulture;
    private static CSharpMatrixFormatProvider invariantCulture;
    public static CSharpMatrixFormatProvider CurrentCulture { get; }
    public static CSharpMatrixFormatProvider InvariantCulture { get; }
    public CSharpMatrixFormatProvider(IFormatProvider innerProvider);
    private static CSharpMatrixFormatProvider();
    public static CSharpMatrixFormatProvider get_CurrentCulture();
    public static CSharpMatrixFormatProvider get_InvariantCulture();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.CholeskyDecomposition : object {
    private Double[0...,0...] L;
    private Double[] D;
    private int n;
    private bool positiveDefinite;
    private bool destroyed;
    private bool robust;
    private bool undefined;
    private Double[0...,0...] leftTriangularFactor;
    private Double[0...,0...] diagonalMatrix;
    private Nullable`1<double> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    public bool IsPositiveDefinite { get; }
    public bool IsUndefined { get; }
    public Double[0...,0...] LeftTriangularFactor { get; }
    public Double[0...,0...] DiagonalMatrix { get; }
    public Double[] Diagonal { get; }
    public double Determinant { get; }
    public double LogDeterminant { get; }
    public bool Nonsingular { get; }
    public CholeskyDecomposition(Double[0...,0...] value, bool robust, bool inPlace, MatrixType valueType);
    public bool get_IsPositiveDefinite();
    public bool get_IsUndefined();
    public Double[0...,0...] get_LeftTriangularFactor();
    public Double[0...,0...] get_DiagonalMatrix();
    public Double[] get_Diagonal();
    public double get_Determinant();
    public double get_LogDeterminant();
    public bool get_Nonsingular();
    private void LLt();
    private void LDLt();
    public sealed virtual Double[0...,0...] Solve(Double[0...,0...] value);
    public Double[0...,0...] Solve(Double[0...,0...] value, bool inPlace);
    public sealed virtual Double[] Solve(Double[] value);
    public Double[] Solve(Double[] value, bool inPlace);
    public sealed virtual Double[0...,0...] Inverse();
    public Double[] InverseDiagonal(bool destroy);
    public Double[] InverseDiagonal(Double[] result, bool destroy);
    public double InverseTrace(bool destroy);
    public sealed virtual Double[0...,0...] Reverse();
    public sealed virtual Double[0...,0...] GetInformationMatrix();
    public static CholeskyDecomposition FromLeftTriangularMatrix(Double[0...,0...] leftTriangular);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.CholeskyDecompositionD : object {
    private Decimal[0...,0...] L;
    private Decimal[] D;
    private int n;
    private bool positiveDefinite;
    private bool destroyed;
    private bool robust;
    private bool undefined;
    private Decimal[0...,0...] leftTriangularFactor;
    private Decimal[0...,0...] diagonalMatrix;
    private Nullable`1<decimal> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    public bool IsPositiveDefinite { get; }
    public bool IsUndefined { get; }
    public Decimal[0...,0...] LeftTriangularFactor { get; }
    public Decimal[0...,0...] DiagonalMatrix { get; }
    public Decimal[] Diagonal { get; }
    public decimal Determinant { get; }
    public double LogDeterminant { get; }
    public bool Nonsingular { get; }
    public CholeskyDecompositionD(Decimal[0...,0...] value, bool robust, bool inPlace, MatrixType valueType);
    public bool get_IsPositiveDefinite();
    public bool get_IsUndefined();
    public Decimal[0...,0...] get_LeftTriangularFactor();
    public Decimal[0...,0...] get_DiagonalMatrix();
    public Decimal[] get_Diagonal();
    public decimal get_Determinant();
    public double get_LogDeterminant();
    public bool get_Nonsingular();
    private void LLt();
    private void LDLt();
    public sealed virtual Decimal[0...,0...] Solve(Decimal[0...,0...] value);
    public Decimal[0...,0...] Solve(Decimal[0...,0...] value, bool inPlace);
    public sealed virtual Decimal[] Solve(Decimal[] value);
    public Decimal[] Solve(Decimal[] value, bool inPlace);
    public sealed virtual Decimal[0...,0...] Inverse();
    public Decimal[] InverseDiagonal(bool destroy);
    public Decimal[] InverseDiagonal(Decimal[] result, bool destroy);
    public decimal InverseTrace(bool destroy);
    public sealed virtual Decimal[0...,0...] Reverse();
    public sealed virtual Decimal[0...,0...] GetInformationMatrix();
    public static CholeskyDecompositionD FromLeftTriangularMatrix(Decimal[0...,0...] leftTriangular);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.CholeskyDecompositionF : object {
    private Single[0...,0...] L;
    private Single[] D;
    private int n;
    private bool positiveDefinite;
    private bool destroyed;
    private bool robust;
    private bool undefined;
    private Single[0...,0...] leftTriangularFactor;
    private Single[0...,0...] diagonalMatrix;
    private Nullable`1<float> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    public bool IsPositiveDefinite { get; }
    public bool IsUndefined { get; }
    public Single[0...,0...] LeftTriangularFactor { get; }
    public Single[0...,0...] DiagonalMatrix { get; }
    public Single[] Diagonal { get; }
    public float Determinant { get; }
    public double LogDeterminant { get; }
    public bool Nonsingular { get; }
    public CholeskyDecompositionF(Single[0...,0...] value, bool robust, bool inPlace, MatrixType valueType);
    public bool get_IsPositiveDefinite();
    public bool get_IsUndefined();
    public Single[0...,0...] get_LeftTriangularFactor();
    public Single[0...,0...] get_DiagonalMatrix();
    public Single[] get_Diagonal();
    public float get_Determinant();
    public double get_LogDeterminant();
    public bool get_Nonsingular();
    private void LLt();
    private void LDLt();
    public sealed virtual Single[0...,0...] Solve(Single[0...,0...] value);
    public Single[0...,0...] Solve(Single[0...,0...] value, bool inPlace);
    public sealed virtual Single[] Solve(Single[] value);
    public Single[] Solve(Single[] value, bool inPlace);
    public sealed virtual Single[0...,0...] Inverse();
    public Single[] InverseDiagonal(bool destroy);
    public Single[] InverseDiagonal(Single[] result, bool destroy);
    public float InverseTrace(bool destroy);
    public sealed virtual Single[0...,0...] Reverse();
    public sealed virtual Single[0...,0...] GetInformationMatrix();
    public static CholeskyDecompositionF FromLeftTriangularMatrix(Single[0...,0...] leftTriangular);
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.EigenvalueDecomposition : object {
    private int n;
    private Double[] d;
    private Double[] e;
    private Double[0...,0...] V;
    private Double[0...,0...] H;
    private Double[] ort;
    private bool symmetric;
    private Nullable`1<int> rank;
    private Double[0...,0...] diagonalMatrix;
    private static double eps;
    public int Rank { get; }
    public Double[] RealEigenvalues { get; }
    public Double[] ImaginaryEigenvalues { get; }
    public Double[0...,0...] Eigenvectors { get; }
    public Double[0...,0...] DiagonalMatrix { get; }
    public EigenvalueDecomposition(Double[0...,0...] value, bool inPlace, bool sort);
    public EigenvalueDecomposition(Double[0...,0...] value, bool assumeSymmetric, bool inPlace, bool sort);
    public int get_Rank();
    public Double[] get_RealEigenvalues();
    public Double[] get_ImaginaryEigenvalues();
    public Double[0...,0...] get_Eigenvectors();
    public Double[0...,0...] get_DiagonalMatrix();
    private void tred2();
    private void tql2();
    private void orthes();
    private static void cdiv(double xr, double xi, double yr, double yi, Double& cdivr, Double& cdivi);
    private void hqr2();
    public Double[0...,0...] Reverse();
    public sealed virtual object Clone();
    [CompilerGeneratedAttribute]
private int <.ctor>b__13_0(int i, int j);
}
public class Accord.Math.Decompositions.EigenvalueDecompositionF : object {
    private int n;
    private Single[] d;
    private Single[] e;
    private Single[0...,0...] V;
    private Single[0...,0...] H;
    private Single[] ort;
    private bool symmetric;
    private Nullable`1<int> rank;
    private Single[0...,0...] diagonalMatrix;
    private static float eps;
    public int Rank { get; }
    public Single[] RealEigenvalues { get; }
    public Single[] ImaginaryEigenvalues { get; }
    public Single[0...,0...] Eigenvectors { get; }
    public Single[0...,0...] DiagonalMatrix { get; }
    public EigenvalueDecompositionF(Single[0...,0...] value, bool inPlace, bool sort);
    public EigenvalueDecompositionF(Single[0...,0...] value, bool assumeSymmetric, bool inPlace, bool sort);
    public int get_Rank();
    public Single[] get_RealEigenvalues();
    public Single[] get_ImaginaryEigenvalues();
    public Single[0...,0...] get_Eigenvectors();
    public Single[0...,0...] get_DiagonalMatrix();
    private void tred2();
    private void tql2();
    private void orthes();
    private static void cdiv(float xr, float xi, float yr, float yi, Single& cdivr, Single& cdivi);
    private void hqr2();
    public Single[0...,0...] Reverse();
    public sealed virtual object Clone();
    [CompilerGeneratedAttribute]
private int <.ctor>b__13_0(int i, int j);
}
public class Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition : object {
    private int n;
    private Double[] ar;
    private Double[] ai;
    private Double[] beta;
    private Double[0...,0...] Z;
    public Double[] RealAlphas { get; }
    public Double[] ImaginaryAlphas { get; }
    public Double[] Betas { get; }
    public bool IsSingular { get; }
    public bool IsDegenerate { get; }
    public Double[] RealEigenvalues { get; }
    public Double[] ImaginaryEigenvalues { get; }
    public Double[0...,0...] Eigenvectors { get; }
    public Double[0...,0...] DiagonalMatrix { get; }
    public GeneralizedEigenvalueDecomposition(Double[0...,0...] a, Double[0...,0...] b, bool sort);
    public Double[] get_RealAlphas();
    public Double[] get_ImaginaryAlphas();
    public Double[] get_Betas();
    public bool get_IsSingular();
    public bool get_IsDegenerate();
    public Double[] get_RealEigenvalues();
    public Double[] get_ImaginaryEigenvalues();
    public Double[0...,0...] get_Eigenvectors();
    public Double[0...,0...] get_DiagonalMatrix();
    private static int qzhes(int n, Double[0...,0...] a, Double[0...,0...] b, bool matz, Double[0...,0...] z);
    private static int qzit(int n, Double[0...,0...] a, Double[0...,0...] b, double eps1, bool matz, Double[0...,0...] z, Int32& ierr);
    private static int qzval(int n, Double[0...,0...] a, Double[0...,0...] b, Double[] alfr, Double[] alfi, Double[] beta, bool matz, Double[0...,0...] z);
    private static int qzvec(int n, Double[0...,0...] a, Double[0...,0...] b, Double[] alfr, Double[] alfi, Double[] beta, Double[0...,0...] z);
    public sealed virtual object Clone();
    [CompilerGeneratedAttribute]
private int <.ctor>b__5_0(int i, int j);
}
public class Accord.Math.Decompositions.GramSchmidtOrthogonalization : object {
    private Double[0...,0...] q;
    private Double[0...,0...] r;
    public Double[0...,0...] OrthogonalFactor { get; }
    public Double[0...,0...] UpperTriangularFactor { get; }
    public GramSchmidtOrthogonalization(Double[0...,0...] value);
    public GramSchmidtOrthogonalization(Double[0...,0...] value, bool modified);
    public Double[0...,0...] get_OrthogonalFactor();
    public Double[0...,0...] get_UpperTriangularFactor();
}
public interface Accord.Math.Decompositions.ISolverArrayDecomposition`1 {
    public abstract virtual T[][] Solve(T[][] value);
    public abstract virtual T[] Solve(T[] value);
    public abstract virtual T[][] SolveForDiagonal(T[] diagonal);
    public abstract virtual T[][] Inverse();
    public abstract virtual T[][] GetInformationMatrix();
    public abstract virtual T[][] Reverse();
}
public interface Accord.Math.Decompositions.ISolverMatrixDecomposition`1 {
    public abstract virtual T[0...,0...] Solve(T[0...,0...] value);
    public abstract virtual T[] Solve(T[] value);
    public abstract virtual T[0...,0...] Inverse();
    public abstract virtual T[0...,0...] GetInformationMatrix();
    public abstract virtual T[0...,0...] Reverse();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.JaggedCholeskyDecomposition : object {
    private Double[][] L;
    private Double[] D;
    private int n;
    private bool positiveDefinite;
    private bool undefined;
    private bool robust;
    private bool destroyed;
    private Double[][] leftTriangularFactor;
    private Double[][] diagonalMatrix;
    private Nullable`1<double> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    public bool IsPositiveDefinite { get; }
    public bool IsUndefined { get; }
    public Double[][] LeftTriangularFactor { get; }
    public Double[][] DiagonalMatrix { get; }
    public Double[] Diagonal { get; }
    public double Determinant { get; }
    public double LogDeterminant { get; }
    public bool Nonsingular { get; }
    public JaggedCholeskyDecomposition(Double[][] value, bool robust, bool inPlace, MatrixType valueType);
    public bool get_IsPositiveDefinite();
    public bool get_IsUndefined();
    public Double[][] get_LeftTriangularFactor();
    public Double[][] get_DiagonalMatrix();
    public Double[] get_Diagonal();
    public double get_Determinant();
    public double get_LogDeterminant();
    public bool get_Nonsingular();
    private void LLt();
    private void LDLt();
    public sealed virtual Double[][] Solve(Double[][] value);
    public Double[][] Solve(Double[][] value, bool inPlace);
    public sealed virtual Double[] Solve(Double[] value);
    public Double[] Solve(Double[] value, bool inPlace);
    public sealed virtual Double[][] SolveForDiagonal(Double[] diagonal);
    public sealed virtual Double[][] Inverse();
    public Double[] InverseDiagonal(bool destroy);
    public Double[] InverseDiagonal(Double[] result, bool destroy);
    public double InverseTrace(bool destroy);
    public sealed virtual Double[][] Reverse();
    public sealed virtual Double[][] GetInformationMatrix();
    public static JaggedCholeskyDecomposition FromLeftTriangularMatrix(Double[][] leftTriangular);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.JaggedCholeskyDecompositionD : object {
    private Decimal[][] L;
    private Decimal[] D;
    private int n;
    private bool positiveDefinite;
    private bool undefined;
    private bool robust;
    private bool destroyed;
    private Decimal[][] leftTriangularFactor;
    private Decimal[][] diagonalMatrix;
    private Nullable`1<decimal> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    public bool IsPositiveDefinite { get; }
    public bool IsUndefined { get; }
    public Decimal[][] LeftTriangularFactor { get; }
    public Decimal[][] DiagonalMatrix { get; }
    public Decimal[] Diagonal { get; }
    public decimal Determinant { get; }
    public double LogDeterminant { get; }
    public bool Nonsingular { get; }
    public JaggedCholeskyDecompositionD(Decimal[][] value, bool robust, bool inPlace, MatrixType valueType);
    public bool get_IsPositiveDefinite();
    public bool get_IsUndefined();
    public Decimal[][] get_LeftTriangularFactor();
    public Decimal[][] get_DiagonalMatrix();
    public Decimal[] get_Diagonal();
    public decimal get_Determinant();
    public double get_LogDeterminant();
    public bool get_Nonsingular();
    private void LLt();
    private void LDLt();
    public sealed virtual Decimal[][] Solve(Decimal[][] value);
    public Decimal[][] Solve(Decimal[][] value, bool inPlace);
    public sealed virtual Decimal[] Solve(Decimal[] value);
    public Decimal[] Solve(Decimal[] value, bool inPlace);
    public sealed virtual Decimal[][] SolveForDiagonal(Decimal[] diagonal);
    public sealed virtual Decimal[][] Inverse();
    public Decimal[] InverseDiagonal(bool destroy);
    public Decimal[] InverseDiagonal(Decimal[] result, bool destroy);
    public decimal InverseTrace(bool destroy);
    public sealed virtual Decimal[][] Reverse();
    public sealed virtual Decimal[][] GetInformationMatrix();
    public static JaggedCholeskyDecompositionD FromLeftTriangularMatrix(Decimal[][] leftTriangular);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.JaggedCholeskyDecompositionF : object {
    private Single[][] L;
    private Single[] D;
    private int n;
    private bool positiveDefinite;
    private bool undefined;
    private bool robust;
    private bool destroyed;
    private Single[][] leftTriangularFactor;
    private Single[][] diagonalMatrix;
    private Nullable`1<float> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    public bool IsPositiveDefinite { get; }
    public bool IsUndefined { get; }
    public Single[][] LeftTriangularFactor { get; }
    public Single[][] DiagonalMatrix { get; }
    public Single[] Diagonal { get; }
    public float Determinant { get; }
    public double LogDeterminant { get; }
    public bool Nonsingular { get; }
    public JaggedCholeskyDecompositionF(Single[][] value, bool robust, bool inPlace, MatrixType valueType);
    public bool get_IsPositiveDefinite();
    public bool get_IsUndefined();
    public Single[][] get_LeftTriangularFactor();
    public Single[][] get_DiagonalMatrix();
    public Single[] get_Diagonal();
    public float get_Determinant();
    public double get_LogDeterminant();
    public bool get_Nonsingular();
    private void LLt();
    private void LDLt();
    public sealed virtual Single[][] Solve(Single[][] value);
    public Single[][] Solve(Single[][] value, bool inPlace);
    public sealed virtual Single[] Solve(Single[] value);
    public Single[] Solve(Single[] value, bool inPlace);
    public sealed virtual Single[][] SolveForDiagonal(Single[] diagonal);
    public sealed virtual Single[][] Inverse();
    public Single[] InverseDiagonal(bool destroy);
    public Single[] InverseDiagonal(Single[] result, bool destroy);
    public float InverseTrace(bool destroy);
    public sealed virtual Single[][] Reverse();
    public sealed virtual Single[][] GetInformationMatrix();
    public static JaggedCholeskyDecompositionF FromLeftTriangularMatrix(Single[][] leftTriangular);
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.JaggedEigenvalueDecomposition : object {
    private int n;
    private Double[] d;
    private Double[] e;
    private Double[][] V;
    private Double[][] H;
    private Double[] ort;
    private bool symmetric;
    private Nullable`1<int> rank;
    private Double[][] diagonalMatrix;
    private static double eps;
    public int Rank { get; }
    public Double[] RealEigenvalues { get; }
    public Double[] ImaginaryEigenvalues { get; }
    public Double[][] Eigenvectors { get; }
    public Double[][] DiagonalMatrix { get; }
    public JaggedEigenvalueDecomposition(Double[][] value, bool inPlace, bool sort);
    public JaggedEigenvalueDecomposition(Double[][] value, bool assumeSymmetric, bool inPlace, bool sort);
    public int get_Rank();
    public Double[] get_RealEigenvalues();
    public Double[] get_ImaginaryEigenvalues();
    public Double[][] get_Eigenvectors();
    public Double[][] get_DiagonalMatrix();
    private void tred2();
    private void tql2();
    private void orthes();
    private static void cdiv(double xr, double xi, double yr, double yi, Double& cdivr, Double& cdivi);
    private void hqr2();
    public Double[][] Reverse();
    public sealed virtual object Clone();
    [CompilerGeneratedAttribute]
private int <.ctor>b__13_0(int i, int j);
}
public class Accord.Math.Decompositions.JaggedEigenvalueDecompositionF : object {
    private int n;
    private Single[] d;
    private Single[] e;
    private Single[][] V;
    private Single[][] H;
    private Single[] ort;
    private bool symmetric;
    private Nullable`1<int> rank;
    private Single[][] diagonalMatrix;
    private static float eps;
    public int Rank { get; }
    public Single[] RealEigenvalues { get; }
    public Single[] ImaginaryEigenvalues { get; }
    public Single[][] Eigenvectors { get; }
    public Single[][] DiagonalMatrix { get; }
    public JaggedEigenvalueDecompositionF(Single[][] value, bool inPlace, bool sort);
    public JaggedEigenvalueDecompositionF(Single[][] value, bool assumeSymmetric, bool inPlace, bool sort);
    public int get_Rank();
    public Single[] get_RealEigenvalues();
    public Single[] get_ImaginaryEigenvalues();
    public Single[][] get_Eigenvectors();
    public Single[][] get_DiagonalMatrix();
    private void tred2();
    private void tql2();
    private void orthes();
    private static void cdiv(float xr, float xi, float yr, float yi, Single& cdivr, Single& cdivi);
    private void hqr2();
    public Single[][] Reverse();
    public sealed virtual object Clone();
    [CompilerGeneratedAttribute]
private int <.ctor>b__13_0(int i, int j);
}
public class Accord.Math.Decompositions.JaggedGeneralizedEigenvalueDecomposition : object {
    private int n;
    private Double[] ar;
    private Double[] ai;
    private Double[] beta;
    private Double[][] Z;
    private static double eps;
    public int Rank { get; }
    public Double[] RealAlphas { get; }
    public Double[] ImaginaryAlphas { get; }
    public Double[] Betas { get; }
    public bool IsSingular { get; }
    public bool IsDegenerate { get; }
    public Double[] RealEigenvalues { get; }
    public Double[] ImaginaryEigenvalues { get; }
    public Double[][] Eigenvectors { get; }
    public Double[][] DiagonalMatrix { get; }
    public JaggedGeneralizedEigenvalueDecomposition(Double[][] a, Double[][] b, bool sort);
    public int get_Rank();
    public Double[] get_RealAlphas();
    public Double[] get_ImaginaryAlphas();
    public Double[] get_Betas();
    public bool get_IsSingular();
    public bool get_IsDegenerate();
    public Double[] get_RealEigenvalues();
    public Double[] get_ImaginaryEigenvalues();
    public Double[][] get_Eigenvectors();
    public Double[][] get_DiagonalMatrix();
    private static int qzhes(int n, Double[][] a, Double[][] b, bool matz, Double[][] z);
    private static int qzit(int n, Double[][] a, Double[][] b, double eps1, bool matz, Double[][] z, Int32& ierr);
    private static int qzval(int n, Double[][] a, Double[][] b, Double[] alfr, Double[] alfi, Double[] beta, bool matz, Double[][] z);
    private static int qzvec(int n, Double[][] a, Double[][] b, Double[] alfr, Double[] alfi, Double[] beta, Double[][] z);
    public sealed virtual object Clone();
    [CompilerGeneratedAttribute]
private int <.ctor>b__6_0(int i, int j);
}
public class Accord.Math.Decompositions.JaggedLuDecomposition : object {
    private int rows;
    private int cols;
    private Double[][] lu;
    private int pivotSign;
    private Int32[] pivotVector;
    private Nullable`1<double> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    private Double[][] lowerTriangularFactor;
    private Double[][] upperTriangularFactor;
    public bool Nonsingular { get; }
    public double Determinant { get; }
    public double LogDeterminant { get; }
    public Double[][] LowerTriangularFactor { get; }
    public Double[][] UpperTriangularFactor { get; }
    public Int32[] PivotPermutationVector { get; }
    public JaggedLuDecomposition(Double[][] value, bool transpose, bool inPlace);
    public bool get_Nonsingular();
    public double get_Determinant();
    public double get_LogDeterminant();
    public Double[][] get_LowerTriangularFactor();
    public Double[][] get_UpperTriangularFactor();
    public Int32[] get_PivotPermutationVector();
    public sealed virtual Double[][] Inverse();
    public sealed virtual Double[][] Reverse();
    public sealed virtual Double[][] GetInformationMatrix();
    public sealed virtual Double[][] Solve(Double[][] value);
    public sealed virtual Double[][] SolveForDiagonal(Double[] diagonal);
    public Double[][] SolveTranspose(Double[][] value);
    public sealed virtual Double[] Solve(Double[] value);
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.JaggedLuDecompositionD : object {
    private int rows;
    private int cols;
    private Decimal[][] lu;
    private int pivotSign;
    private Int32[] pivotVector;
    private Nullable`1<decimal> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    private Decimal[][] lowerTriangularFactor;
    private Decimal[][] upperTriangularFactor;
    public bool Nonsingular { get; }
    public decimal Determinant { get; }
    public double LogDeterminant { get; }
    public Decimal[][] LowerTriangularFactor { get; }
    public Decimal[][] UpperTriangularFactor { get; }
    public Int32[] PivotPermutationVector { get; }
    public JaggedLuDecompositionD(Decimal[][] value, bool transpose, bool inPlace);
    public bool get_Nonsingular();
    public decimal get_Determinant();
    public double get_LogDeterminant();
    public Decimal[][] get_LowerTriangularFactor();
    public Decimal[][] get_UpperTriangularFactor();
    public Int32[] get_PivotPermutationVector();
    public sealed virtual Decimal[][] Inverse();
    public sealed virtual Decimal[][] Reverse();
    public sealed virtual Decimal[][] GetInformationMatrix();
    public sealed virtual Decimal[][] Solve(Decimal[][] value);
    public sealed virtual Decimal[][] SolveForDiagonal(Decimal[] diagonal);
    public Decimal[][] SolveTranspose(Decimal[][] value);
    public sealed virtual Decimal[] Solve(Decimal[] value);
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.JaggedLuDecompositionF : object {
    private int rows;
    private int cols;
    private Single[][] lu;
    private int pivotSign;
    private Int32[] pivotVector;
    private Nullable`1<float> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    private Single[][] lowerTriangularFactor;
    private Single[][] upperTriangularFactor;
    public bool Nonsingular { get; }
    public float Determinant { get; }
    public double LogDeterminant { get; }
    public Single[][] LowerTriangularFactor { get; }
    public Single[][] UpperTriangularFactor { get; }
    public Int32[] PivotPermutationVector { get; }
    public JaggedLuDecompositionF(Single[][] value, bool transpose, bool inPlace);
    public bool get_Nonsingular();
    public float get_Determinant();
    public double get_LogDeterminant();
    public Single[][] get_LowerTriangularFactor();
    public Single[][] get_UpperTriangularFactor();
    public Int32[] get_PivotPermutationVector();
    public sealed virtual Single[][] Inverse();
    public sealed virtual Single[][] Reverse();
    public sealed virtual Single[][] GetInformationMatrix();
    public sealed virtual Single[][] Solve(Single[][] value);
    public sealed virtual Single[][] SolveForDiagonal(Single[] diagonal);
    public Single[][] SolveTranspose(Single[][] value);
    public sealed virtual Single[] Solve(Single[] value);
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.JaggedQrDecomposition : object {
    private int n;
    private int m;
    private int p;
    private bool economy;
    private Double[][] qr;
    private Double[] Rdiag;
    private Nullable`1<bool> fullRank;
    private Double[][] orthogonalFactor;
    private Double[][] upperTriangularFactor;
    public bool FullRank { get; }
    public Double[][] UpperTriangularFactor { get; }
    public Double[][] OrthogonalFactor { get; }
    public Double[] Diagonal { get; }
    public JaggedQrDecomposition(Double[][] value, bool transpose, bool economy, bool inPlace);
    public sealed virtual Double[][] Solve(Double[][] value);
    public Double[][] SolveTranspose(Double[][] value);
    public sealed virtual Double[] Solve(Double[] value);
    public sealed virtual Double[][] SolveForDiagonal(Double[] diagonal);
    public bool get_FullRank();
    public Double[][] get_UpperTriangularFactor();
    public Double[][] get_OrthogonalFactor();
    public Double[] get_Diagonal();
    public sealed virtual Double[][] Inverse();
    public sealed virtual Double[][] Reverse();
    public sealed virtual Double[][] GetInformationMatrix();
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.JaggedQrDecompositionD : object {
    private int n;
    private int m;
    private int p;
    private bool economy;
    private Decimal[][] qr;
    private Decimal[] Rdiag;
    private Nullable`1<bool> fullRank;
    private Decimal[][] orthogonalFactor;
    private Decimal[][] upperTriangularFactor;
    public bool FullRank { get; }
    public Decimal[][] UpperTriangularFactor { get; }
    public Decimal[][] OrthogonalFactor { get; }
    public Decimal[] Diagonal { get; }
    public JaggedQrDecompositionD(Decimal[][] value, bool transpose, bool economy, bool inPlace);
    public sealed virtual Decimal[][] Solve(Decimal[][] value);
    public Decimal[][] SolveTranspose(Decimal[][] value);
    public sealed virtual Decimal[] Solve(Decimal[] value);
    public sealed virtual Decimal[][] SolveForDiagonal(Decimal[] diagonal);
    public bool get_FullRank();
    public Decimal[][] get_UpperTriangularFactor();
    public Decimal[][] get_OrthogonalFactor();
    public Decimal[] get_Diagonal();
    public sealed virtual Decimal[][] Inverse();
    public sealed virtual Decimal[][] Reverse();
    public sealed virtual Decimal[][] GetInformationMatrix();
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.JaggedQrDecompositionF : object {
    private int n;
    private int m;
    private int p;
    private bool economy;
    private Single[][] qr;
    private Single[] Rdiag;
    private Nullable`1<bool> fullRank;
    private Single[][] orthogonalFactor;
    private Single[][] upperTriangularFactor;
    public bool FullRank { get; }
    public Single[][] UpperTriangularFactor { get; }
    public Single[][] OrthogonalFactor { get; }
    public Single[] Diagonal { get; }
    public JaggedQrDecompositionF(Single[][] value, bool transpose, bool economy, bool inPlace);
    public sealed virtual Single[][] Solve(Single[][] value);
    public Single[][] SolveTranspose(Single[][] value);
    public sealed virtual Single[] Solve(Single[] value);
    public sealed virtual Single[][] SolveForDiagonal(Single[] diagonal);
    public bool get_FullRank();
    public Single[][] get_UpperTriangularFactor();
    public Single[][] get_OrthogonalFactor();
    public Single[] get_Diagonal();
    public sealed virtual Single[][] Inverse();
    public sealed virtual Single[][] Reverse();
    public sealed virtual Single[][] GetInformationMatrix();
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.JaggedSingularValueDecomposition : object {
    private Double[][] u;
    private Double[][] v;
    private Double[] s;
    private int m;
    private int n;
    private bool swapped;
    private Int32[] si;
    private static double eps;
    private static double tiny;
    private Nullable`1<int> rank;
    private Nullable`1<double> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<double> pseudoDeterminant;
    private Nullable`1<double> lnpseudoDeterminant;
    private Double[][] diagonalMatrix;
    public double Condition { get; }
    public double Threshold { get; }
    public double TwoNorm { get; }
    public int Rank { get; }
    public bool IsSingular { get; }
    public Double[] Diagonal { get; }
    public Double[][] DiagonalMatrix { get; }
    public Double[][] RightSingularVectors { get; }
    public Double[][] LeftSingularVectors { get; }
    public Int32[] Ordering { get; }
    public double AbsoluteDeterminant { get; }
    public double LogDeterminant { get; }
    public double PseudoDeterminant { get; }
    public double LogPseudoDeterminant { get; }
    public JaggedSingularValueDecomposition(Double[][] value);
    public JaggedSingularValueDecomposition(Double[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors);
    public JaggedSingularValueDecomposition(Double[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose);
    public JaggedSingularValueDecomposition(Double[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose, bool inPlace);
    public double get_Condition();
    public double get_Threshold();
    public double get_TwoNorm();
    public int get_Rank();
    public bool get_IsSingular();
    public Double[] get_Diagonal();
    public Double[][] get_DiagonalMatrix();
    public Double[][] get_RightSingularVectors();
    public Double[][] get_LeftSingularVectors();
    public Int32[] get_Ordering();
    public double get_AbsoluteDeterminant();
    public double get_LogDeterminant();
    public double get_PseudoDeterminant();
    public double get_LogPseudoDeterminant();
    public sealed virtual Double[][] Solve(Double[][] value);
    public Double[][] SolveTranspose(Double[][] value);
    public sealed virtual Double[][] SolveForDiagonal(Double[] diagonal);
    public Double[] SolveTranspose(Double[] value);
    public sealed virtual Double[] Solve(Double[] value);
    public sealed virtual Double[][] Inverse();
    public sealed virtual Double[][] Reverse();
    public sealed virtual Double[][] GetInformationMatrix();
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.JaggedSingularValueDecompositionD : object {
    private Decimal[][] u;
    private Decimal[][] v;
    private Decimal[] s;
    private int m;
    private int n;
    private bool swapped;
    private Int32[] si;
    [DecimalConstantAttribute("28", "0", "0", "0", "2")]
private static decimal eps;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
private static decimal tiny;
    private Nullable`1<int> rank;
    private Nullable`1<decimal> determinant;
    private Nullable`1<decimal> lndeterminant;
    private Nullable`1<decimal> pseudoDeterminant;
    private Nullable`1<decimal> lnpseudoDeterminant;
    private Decimal[][] diagonalMatrix;
    public decimal Condition { get; }
    public decimal Threshold { get; }
    public decimal TwoNorm { get; }
    public int Rank { get; }
    public bool IsSingular { get; }
    public Decimal[] Diagonal { get; }
    public Decimal[][] DiagonalMatrix { get; }
    public Decimal[][] RightSingularVectors { get; }
    public Decimal[][] LeftSingularVectors { get; }
    public Int32[] Ordering { get; }
    public decimal AbsoluteDeterminant { get; }
    public decimal LogDeterminant { get; }
    public decimal PseudoDeterminant { get; }
    public decimal LogPseudoDeterminant { get; }
    public JaggedSingularValueDecompositionD(Decimal[][] value);
    public JaggedSingularValueDecompositionD(Decimal[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors);
    public JaggedSingularValueDecompositionD(Decimal[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose);
    public JaggedSingularValueDecompositionD(Decimal[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose, bool inPlace);
    private static JaggedSingularValueDecompositionD();
    public decimal get_Condition();
    public decimal get_Threshold();
    public decimal get_TwoNorm();
    public int get_Rank();
    public bool get_IsSingular();
    public Decimal[] get_Diagonal();
    public Decimal[][] get_DiagonalMatrix();
    public Decimal[][] get_RightSingularVectors();
    public Decimal[][] get_LeftSingularVectors();
    public Int32[] get_Ordering();
    public decimal get_AbsoluteDeterminant();
    public decimal get_LogDeterminant();
    public decimal get_PseudoDeterminant();
    public decimal get_LogPseudoDeterminant();
    public sealed virtual Decimal[][] Solve(Decimal[][] value);
    public Decimal[][] SolveTranspose(Decimal[][] value);
    public sealed virtual Decimal[][] SolveForDiagonal(Decimal[] diagonal);
    public Decimal[] SolveTranspose(Decimal[] value);
    public sealed virtual Decimal[] Solve(Decimal[] value);
    public sealed virtual Decimal[][] Inverse();
    public sealed virtual Decimal[][] Reverse();
    public sealed virtual Decimal[][] GetInformationMatrix();
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.JaggedSingularValueDecompositionF : object {
    private Single[][] u;
    private Single[][] v;
    private Single[] s;
    private int m;
    private int n;
    private bool swapped;
    private Int32[] si;
    private static float eps;
    private static float tiny;
    private Nullable`1<int> rank;
    private Nullable`1<float> determinant;
    private Nullable`1<float> lndeterminant;
    private Nullable`1<float> pseudoDeterminant;
    private Nullable`1<float> lnpseudoDeterminant;
    private Single[][] diagonalMatrix;
    public float Condition { get; }
    public float Threshold { get; }
    public float TwoNorm { get; }
    public int Rank { get; }
    public bool IsSingular { get; }
    public Single[] Diagonal { get; }
    public Single[][] DiagonalMatrix { get; }
    public Single[][] RightSingularVectors { get; }
    public Single[][] LeftSingularVectors { get; }
    public Int32[] Ordering { get; }
    public float AbsoluteDeterminant { get; }
    public float LogDeterminant { get; }
    public float PseudoDeterminant { get; }
    public float LogPseudoDeterminant { get; }
    public JaggedSingularValueDecompositionF(Single[][] value);
    public JaggedSingularValueDecompositionF(Single[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors);
    public JaggedSingularValueDecompositionF(Single[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose);
    public JaggedSingularValueDecompositionF(Single[][] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose, bool inPlace);
    public float get_Condition();
    public float get_Threshold();
    public float get_TwoNorm();
    public int get_Rank();
    public bool get_IsSingular();
    public Single[] get_Diagonal();
    public Single[][] get_DiagonalMatrix();
    public Single[][] get_RightSingularVectors();
    public Single[][] get_LeftSingularVectors();
    public Int32[] get_Ordering();
    public float get_AbsoluteDeterminant();
    public float get_LogDeterminant();
    public float get_PseudoDeterminant();
    public float get_LogPseudoDeterminant();
    public sealed virtual Single[][] Solve(Single[][] value);
    public Single[][] SolveTranspose(Single[][] value);
    public sealed virtual Single[][] SolveForDiagonal(Single[] diagonal);
    public Single[] SolveTranspose(Single[] value);
    public sealed virtual Single[] Solve(Single[] value);
    public sealed virtual Single[][] Inverse();
    public sealed virtual Single[][] Reverse();
    public sealed virtual Single[][] GetInformationMatrix();
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.LuDecomposition : object {
    private int rows;
    private int cols;
    private Double[0...,0...] lu;
    private int pivotSign;
    private Int32[] pivotVector;
    private Nullable`1<double> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    private Double[0...,0...] lowerTriangularFactor;
    private Double[0...,0...] upperTriangularFactor;
    public bool Nonsingular { get; }
    public double Determinant { get; }
    public double LogDeterminant { get; }
    public Double[0...,0...] LowerTriangularFactor { get; }
    public Double[0...,0...] UpperTriangularFactor { get; }
    public Int32[] PivotPermutationVector { get; }
    public LuDecomposition(Double[0...,0...] value);
    public LuDecomposition(Double[0...,0...] value, bool transpose);
    public LuDecomposition(Double[0...,0...] value, bool transpose, bool inPlace);
    public bool get_Nonsingular();
    public double get_Determinant();
    public double get_LogDeterminant();
    public Double[0...,0...] get_LowerTriangularFactor();
    public Double[0...,0...] get_UpperTriangularFactor();
    public Int32[] get_PivotPermutationVector();
    public sealed virtual Double[0...,0...] Inverse();
    public sealed virtual Double[0...,0...] Solve(Double[0...,0...] value);
    public Double[0...,0...] SolveTranspose(Double[0...,0...] value);
    public sealed virtual Double[] Solve(Double[] value);
    public sealed virtual Double[0...,0...] Reverse();
    public sealed virtual Double[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.LuDecompositionD : object {
    private int rows;
    private int cols;
    private Decimal[0...,0...] lu;
    private int pivotSign;
    private Int32[] pivotVector;
    private Nullable`1<decimal> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    private Decimal[0...,0...] lowerTriangularFactor;
    private Decimal[0...,0...] upperTriangularFactor;
    public bool Nonsingular { get; }
    public decimal Determinant { get; }
    public double LogDeterminant { get; }
    public Decimal[0...,0...] LowerTriangularFactor { get; }
    public Decimal[0...,0...] UpperTriangularFactor { get; }
    public Int32[] PivotPermutationVector { get; }
    public LuDecompositionD(Decimal[0...,0...] value);
    public LuDecompositionD(Decimal[0...,0...] value, bool transpose);
    public LuDecompositionD(Decimal[0...,0...] value, bool transpose, bool inPlace);
    public bool get_Nonsingular();
    public decimal get_Determinant();
    public double get_LogDeterminant();
    public Decimal[0...,0...] get_LowerTriangularFactor();
    public Decimal[0...,0...] get_UpperTriangularFactor();
    public Int32[] get_PivotPermutationVector();
    public sealed virtual Decimal[0...,0...] Inverse();
    public sealed virtual Decimal[0...,0...] Solve(Decimal[0...,0...] value);
    public Decimal[0...,0...] SolveTranspose(Decimal[0...,0...] value);
    public sealed virtual Decimal[] Solve(Decimal[] value);
    public sealed virtual Decimal[0...,0...] Reverse();
    public sealed virtual Decimal[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.LuDecompositionF : object {
    private int rows;
    private int cols;
    private Single[0...,0...] lu;
    private int pivotSign;
    private Int32[] pivotVector;
    private Nullable`1<float> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<bool> nonsingular;
    private Single[0...,0...] lowerTriangularFactor;
    private Single[0...,0...] upperTriangularFactor;
    public bool Nonsingular { get; }
    public float Determinant { get; }
    public double LogDeterminant { get; }
    public Single[0...,0...] LowerTriangularFactor { get; }
    public Single[0...,0...] UpperTriangularFactor { get; }
    public Int32[] PivotPermutationVector { get; }
    public LuDecompositionF(Single[0...,0...] value);
    public LuDecompositionF(Single[0...,0...] value, bool transpose);
    public LuDecompositionF(Single[0...,0...] value, bool transpose, bool inPlace);
    public bool get_Nonsingular();
    public float get_Determinant();
    public double get_LogDeterminant();
    public Single[0...,0...] get_LowerTriangularFactor();
    public Single[0...,0...] get_UpperTriangularFactor();
    public Int32[] get_PivotPermutationVector();
    public sealed virtual Single[0...,0...] Inverse();
    public sealed virtual Single[0...,0...] Solve(Single[0...,0...] value);
    public Single[0...,0...] SolveTranspose(Single[0...,0...] value);
    public sealed virtual Single[] Solve(Single[] value);
    public sealed virtual Single[0...,0...] Reverse();
    public sealed virtual Single[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
[CompilerGeneratedAttribute]
internal class Accord.Math.Decompositions.NamespaceDoc : object {
}
public class Accord.Math.Decompositions.NonnegativeMatrixFactorization : object {
    private Double[0...,0...] X;
    private Double[0...,0...] W;
    private Double[0...,0...] H;
    private int n;
    private int m;
    private int r;
    public Double[0...,0...] LeftNonnegativeFactors { get; }
    public Double[0...,0...] RightNonnegativeFactors { get; }
    public NonnegativeMatrixFactorization(Double[0...,0...] value, int r);
    public NonnegativeMatrixFactorization(Double[0...,0...] value, int r, int maxiter);
    public Double[0...,0...] get_LeftNonnegativeFactors();
    public Double[0...,0...] get_RightNonnegativeFactors();
    private void compute(int maxiter);
}
public class Accord.Math.Decompositions.QrDecomposition : object {
    private int n;
    private int m;
    private int p;
    private bool economy;
    private Double[0...,0...] qr;
    private Double[] Rdiag;
    private Nullable`1<bool> fullRank;
    private Double[0...,0...] orthogonalFactor;
    private Double[0...,0...] upperTriangularFactor;
    public bool FullRank { get; }
    public Double[0...,0...] UpperTriangularFactor { get; }
    public Double[0...,0...] OrthogonalFactor { get; }
    public Double[] Diagonal { get; }
    public QrDecomposition(Double[0...,0...] value, bool transpose, bool economy, bool inPlace);
    public sealed virtual Double[0...,0...] Solve(Double[0...,0...] value);
    public Double[0...,0...] SolveTranspose(Double[0...,0...] value);
    public sealed virtual Double[] Solve(Double[] value);
    public bool get_FullRank();
    public Double[0...,0...] get_UpperTriangularFactor();
    public Double[0...,0...] get_OrthogonalFactor();
    public Double[] get_Diagonal();
    public sealed virtual Double[0...,0...] Inverse();
    public sealed virtual Double[0...,0...] Reverse();
    public sealed virtual Double[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.QrDecompositionD : object {
    private int n;
    private int m;
    private int p;
    private bool economy;
    private Decimal[0...,0...] qr;
    private Decimal[] Rdiag;
    private Nullable`1<bool> fullRank;
    private Decimal[0...,0...] orthogonalFactor;
    private Decimal[0...,0...] upperTriangularFactor;
    public bool FullRank { get; }
    public Decimal[0...,0...] UpperTriangularFactor { get; }
    public Decimal[0...,0...] OrthogonalFactor { get; }
    public Decimal[] Diagonal { get; }
    public QrDecompositionD(Decimal[0...,0...] value, bool transpose, bool economy, bool inPlace);
    public sealed virtual Decimal[0...,0...] Solve(Decimal[0...,0...] value);
    public Decimal[0...,0...] SolveTranspose(Decimal[0...,0...] value);
    public sealed virtual Decimal[] Solve(Decimal[] value);
    public bool get_FullRank();
    public Decimal[0...,0...] get_UpperTriangularFactor();
    public Decimal[0...,0...] get_OrthogonalFactor();
    public Decimal[] get_Diagonal();
    public sealed virtual Decimal[0...,0...] Inverse();
    public sealed virtual Decimal[0...,0...] Reverse();
    public sealed virtual Decimal[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
public class Accord.Math.Decompositions.QrDecompositionF : object {
    private int n;
    private int m;
    private int p;
    private bool economy;
    private Single[0...,0...] qr;
    private Single[] Rdiag;
    private Nullable`1<bool> fullRank;
    private Single[0...,0...] orthogonalFactor;
    private Single[0...,0...] upperTriangularFactor;
    public bool FullRank { get; }
    public Single[0...,0...] UpperTriangularFactor { get; }
    public Single[0...,0...] OrthogonalFactor { get; }
    public Single[] Diagonal { get; }
    public QrDecompositionF(Single[0...,0...] value, bool transpose, bool economy, bool inPlace);
    public sealed virtual Single[0...,0...] Solve(Single[0...,0...] value);
    public Single[0...,0...] SolveTranspose(Single[0...,0...] value);
    public sealed virtual Single[] Solve(Single[] value);
    public bool get_FullRank();
    public Single[0...,0...] get_UpperTriangularFactor();
    public Single[0...,0...] get_OrthogonalFactor();
    public Single[] get_Diagonal();
    public sealed virtual Single[0...,0...] Inverse();
    public sealed virtual Single[0...,0...] Reverse();
    public sealed virtual Single[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.SingularValueDecomposition : object {
    private Double[0...,0...] u;
    private Double[0...,0...] v;
    private Double[] s;
    private int m;
    private int n;
    private bool swapped;
    private Int32[] si;
    private static double eps;
    private static double tiny;
    private Nullable`1<int> rank;
    private Nullable`1<double> determinant;
    private Nullable`1<double> lndeterminant;
    private Nullable`1<double> pseudoDeterminant;
    private Nullable`1<double> lnpseudoDeterminant;
    private Double[0...,0...] diagonalMatrix;
    public double Condition { get; }
    public double Threshold { get; }
    public double TwoNorm { get; }
    public int Rank { get; }
    public bool IsSingular { get; }
    public Double[] Diagonal { get; }
    public Double[0...,0...] DiagonalMatrix { get; }
    public Double[0...,0...] RightSingularVectors { get; }
    public Double[0...,0...] LeftSingularVectors { get; }
    public Int32[] Ordering { get; }
    public double AbsoluteDeterminant { get; }
    public double LogDeterminant { get; }
    public double PseudoDeterminant { get; }
    public double LogPseudoDeterminant { get; }
    public SingularValueDecomposition(Double[0...,0...] value);
    public SingularValueDecomposition(Double[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors);
    public SingularValueDecomposition(Double[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose);
    public SingularValueDecomposition(Double[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose, bool inPlace);
    public double get_Condition();
    public double get_Threshold();
    public double get_TwoNorm();
    public int get_Rank();
    public bool get_IsSingular();
    public Double[] get_Diagonal();
    public Double[0...,0...] get_DiagonalMatrix();
    public Double[0...,0...] get_RightSingularVectors();
    public Double[0...,0...] get_LeftSingularVectors();
    public Int32[] get_Ordering();
    public double get_AbsoluteDeterminant();
    public double get_LogDeterminant();
    public double get_PseudoDeterminant();
    public double get_LogPseudoDeterminant();
    public sealed virtual Double[0...,0...] Solve(Double[0...,0...] value);
    public Double[0...,0...] SolveTranspose(Double[0...,0...] value);
    public Double[0...,0...] SolveForDiagonal(Double[] value);
    public Double[] SolveTranspose(Double[] value);
    public sealed virtual Double[] Solve(Double[] value);
    public sealed virtual Double[0...,0...] Inverse();
    public sealed virtual Double[0...,0...] Reverse();
    public sealed virtual Double[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.SingularValueDecompositionD : object {
    private Decimal[0...,0...] u;
    private Decimal[0...,0...] v;
    private Decimal[] s;
    private int m;
    private int n;
    private bool swapped;
    private Int32[] si;
    [DecimalConstantAttribute("28", "0", "0", "0", "2")]
private static decimal eps;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
private static decimal tiny;
    private Nullable`1<int> rank;
    private Nullable`1<decimal> determinant;
    private Nullable`1<decimal> lndeterminant;
    private Nullable`1<decimal> pseudoDeterminant;
    private Nullable`1<decimal> lnpseudoDeterminant;
    private Decimal[0...,0...] diagonalMatrix;
    public decimal Condition { get; }
    public decimal Threshold { get; }
    public decimal TwoNorm { get; }
    public int Rank { get; }
    public bool IsSingular { get; }
    public Decimal[] Diagonal { get; }
    public Decimal[0...,0...] DiagonalMatrix { get; }
    public Decimal[0...,0...] RightSingularVectors { get; }
    public Decimal[0...,0...] LeftSingularVectors { get; }
    public Int32[] Ordering { get; }
    public decimal AbsoluteDeterminant { get; }
    public decimal LogDeterminant { get; }
    public decimal PseudoDeterminant { get; }
    public decimal LogPseudoDeterminant { get; }
    public SingularValueDecompositionD(Decimal[0...,0...] value);
    public SingularValueDecompositionD(Decimal[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors);
    public SingularValueDecompositionD(Decimal[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose);
    public SingularValueDecompositionD(Decimal[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose, bool inPlace);
    private static SingularValueDecompositionD();
    public decimal get_Condition();
    public decimal get_Threshold();
    public decimal get_TwoNorm();
    public int get_Rank();
    public bool get_IsSingular();
    public Decimal[] get_Diagonal();
    public Decimal[0...,0...] get_DiagonalMatrix();
    public Decimal[0...,0...] get_RightSingularVectors();
    public Decimal[0...,0...] get_LeftSingularVectors();
    public Int32[] get_Ordering();
    public decimal get_AbsoluteDeterminant();
    public decimal get_LogDeterminant();
    public decimal get_PseudoDeterminant();
    public decimal get_LogPseudoDeterminant();
    public sealed virtual Decimal[0...,0...] Solve(Decimal[0...,0...] value);
    public Decimal[0...,0...] SolveTranspose(Decimal[0...,0...] value);
    public Decimal[0...,0...] SolveForDiagonal(Decimal[] value);
    public Decimal[] SolveTranspose(Decimal[] value);
    public sealed virtual Decimal[] Solve(Decimal[] value);
    public sealed virtual Decimal[0...,0...] Inverse();
    public sealed virtual Decimal[0...,0...] Reverse();
    public sealed virtual Decimal[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Decompositions.SingularValueDecompositionF : object {
    private Single[0...,0...] u;
    private Single[0...,0...] v;
    private Single[] s;
    private int m;
    private int n;
    private bool swapped;
    private Int32[] si;
    private static float eps;
    private static float tiny;
    private Nullable`1<int> rank;
    private Nullable`1<float> determinant;
    private Nullable`1<float> lndeterminant;
    private Nullable`1<float> pseudoDeterminant;
    private Nullable`1<float> lnpseudoDeterminant;
    private Single[0...,0...] diagonalMatrix;
    public float Condition { get; }
    public float Threshold { get; }
    public float TwoNorm { get; }
    public int Rank { get; }
    public bool IsSingular { get; }
    public Single[] Diagonal { get; }
    public Single[0...,0...] DiagonalMatrix { get; }
    public Single[0...,0...] RightSingularVectors { get; }
    public Single[0...,0...] LeftSingularVectors { get; }
    public Int32[] Ordering { get; }
    public float AbsoluteDeterminant { get; }
    public float LogDeterminant { get; }
    public float PseudoDeterminant { get; }
    public float LogPseudoDeterminant { get; }
    public SingularValueDecompositionF(Single[0...,0...] value);
    public SingularValueDecompositionF(Single[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors);
    public SingularValueDecompositionF(Single[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose);
    public SingularValueDecompositionF(Single[0...,0...] value, bool computeLeftSingularVectors, bool computeRightSingularVectors, bool autoTranspose, bool inPlace);
    public float get_Condition();
    public float get_Threshold();
    public float get_TwoNorm();
    public int get_Rank();
    public bool get_IsSingular();
    public Single[] get_Diagonal();
    public Single[0...,0...] get_DiagonalMatrix();
    public Single[0...,0...] get_RightSingularVectors();
    public Single[0...,0...] get_LeftSingularVectors();
    public Int32[] get_Ordering();
    public float get_AbsoluteDeterminant();
    public float get_LogDeterminant();
    public float get_PseudoDeterminant();
    public float get_LogPseudoDeterminant();
    public sealed virtual Single[0...,0...] Solve(Single[0...,0...] value);
    public Single[0...,0...] SolveTranspose(Single[0...,0...] value);
    public Single[0...,0...] SolveForDiagonal(Single[] value);
    public Single[] SolveTranspose(Single[] value);
    public sealed virtual Single[] Solve(Single[] value);
    public sealed virtual Single[0...,0...] Inverse();
    public sealed virtual Single[0...,0...] Reverse();
    public sealed virtual Single[0...,0...] GetInformationMatrix();
    public sealed virtual object Clone();
}
public class Accord.Math.DefaultArrayFormatProvider : MatrixFormatProviderBase {
    private static DefaultArrayFormatProvider currentCulture;
    private static DefaultArrayFormatProvider invariantCulture;
    public static DefaultArrayFormatProvider CurrentCulture { get; }
    public static DefaultArrayFormatProvider InvariantCulture { get; }
    public DefaultArrayFormatProvider(IFormatProvider innerProvider);
    private static DefaultArrayFormatProvider();
    public static DefaultArrayFormatProvider get_CurrentCulture();
    public static DefaultArrayFormatProvider get_InvariantCulture();
}
public class Accord.Math.DefaultMatrixFormatProvider : MatrixFormatProviderBase {
    private static DefaultMatrixFormatProvider currentCulture;
    private static DefaultMatrixFormatProvider invariantCulture;
    public static DefaultMatrixFormatProvider CurrentCulture { get; }
    public static DefaultMatrixFormatProvider InvariantCulture { get; }
    public DefaultMatrixFormatProvider(IFormatProvider innerProvider);
    private static DefaultMatrixFormatProvider();
    public static DefaultMatrixFormatProvider get_CurrentCulture();
    public static DefaultMatrixFormatProvider get_InvariantCulture();
}
public class Accord.Math.Differentiation.FiniteDifferences : object {
    private static double DEFAULT_STEPSIZE;
    private static int DEFAULT_NPOINTS;
    private static int DEFAULT_ORDER;
    private int numberOfVariables;
    private int derivativeOrder;
    private Double[] stepSizes;
    private Double[0...,0...][] coefficients;
    private ThreadLocal`1<Double[][]> points;
    private int center;
    [CompilerGeneratedAttribute]
private Func`2<Double[], double> <Function>k__BackingField;
    private static Double[0...,0...][] coefficientCache;
    public Func`2<Double[], double> Function { get; public set; }
    public double StepSize { get; public set; }
    public Double[] StepSizes { get; }
    public int Order { get; public set; }
    public int NumberOfPoints { get; public set; }
    [ObsoleteAttribute("Please use NumberOfPoints instead.")]
public int Points { get; public set; }
    public int NumberOfVariables { get; }
    public FiniteDifferences(int variables);
    public FiniteDifferences(int variables, int order);
    public FiniteDifferences(int variables, int order, double stepSize);
    public FiniteDifferences(int variables, Func`2<Double[], double> function);
    public FiniteDifferences(int variables, Func`2<Double[], double> function, int order);
    public FiniteDifferences(int variables, Func`2<Double[], double> function, int order, double stepSize);
    private static FiniteDifferences();
    [CompilerGeneratedAttribute]
public Func`2<Double[], double> get_Function();
    [CompilerGeneratedAttribute]
public void set_Function(Func`2<Double[], double> value);
    public double get_StepSize();
    public void set_StepSize(double value);
    public Double[] get_StepSizes();
    public int get_Order();
    public void set_Order(int value);
    public int get_NumberOfPoints();
    public void set_NumberOfPoints(int value);
    public int get_Points();
    public void set_Points(int value);
    public int get_NumberOfVariables();
    private void init(int variables, Func`2<Double[], double> function, Nullable`1<int> order, Nullable`1<int> points, Nullable`1<double> stepSize);
    [ObsoleteAttribute("Please use Gradient(double[]) instead.")]
public Double[] Compute(Double[] x);
    [ObsoleteAttribute("Please use Gradient(double[], double[]) instead.")]
public void Compute(Double[] x, Double[] gradient);
    public Double[] Gradient(Double[] x);
    public Double[] Gradient(Double[] x, Double[] result);
    public Double[][] Hessian(Double[] x);
    public Double[][] Hessian(Double[] x, Double[][] result);
    private double derivative(Func`2<Double[], double> func, Double[] x, int index, Double[] points, double centerValue);
    private double GetUniformlySampledPoints(Func`2<Double[], double> func, Double[] x, int index, double centerValue, Double[] points);
    private static double Interpolate(Double[0...,0...][] coefficients, Double[] points, int order, int center, double step);
    public static Double[0...,0...][] CreateCoefficients(int numberOfPoints);
    public static double Derivative(Func`2<double, double> function, double value, int order);
    public static double Derivative(Func`2<double, double> function, double value);
    public static double Derivative(Func`2<double, double> function, double value, int order, double stepSize);
    public static Func`2<Double[], Double[]> Gradient(Func`2<Double[], double> function, int variables, int order);
    public static Func`2<Double[], Double[][]> Hessian(Func`2<Double[], double> function, int variables);
    [CompilerGeneratedAttribute]
private Double[][] <set_NumberOfPoints>b__23_0();
}
public static class Accord.Math.Distance : object {
    private static Yule cacheYule;
    private static Jaccard cacheJaccard;
    private static Hellinger cacheHellinger;
    private static Euclidean cacheEuclidean;
    private static SquareMahalanobis cacheSquareMahalanobis;
    private static RusselRao cacheRusselRao;
    private static Chebyshev cacheChebyshev;
    private static Dice cacheDice;
    private static SokalMichener cacheSokalMichener;
    private static WeightedEuclidean cacheWeightedEuclidean;
    private static Angular cacheAngular;
    private static SquareEuclidean cacheSquareEuclidean;
    private static Hamming cacheHamming;
    private static ArgMax cacheArgMax;
    private static Modular cacheModular;
    private static Cosine cacheCosine;
    private static Mahalanobis cacheMahalanobis;
    private static BrayCurtis cacheBrayCurtis;
    private static Minkowski cacheMinkowski;
    private static Levenshtein cacheLevenshtein;
    private static SokalSneath cacheSokalSneath;
    private static Matching cacheMatching;
    private static Canberra cacheCanberra;
    private static RogersTanimoto cacheRogersTanimoto;
    private static Manhattan cacheManhattan;
    private static Kulczynski cacheKulczynski;
    private static WeightedSquareEuclidean cacheWeightedSquareEuclidean;
    private static Distance();
    public static bool IsMetric(Func`3<Double[], Double[], double> value);
    public static bool IsMetric(Func`3<Int32[], Int32[], double> value);
    public static bool IsMetric(IDistance`1<T> value);
    public static IDistance`1<T> GetDistance(Func`3<T, T, double> func);
    [ObsoleteAttribute("Please use Distance.Hamming instead.")]
public static double BitwiseHamming(Byte[] x, Byte[] y);
    public static double Levenshtein(T[] x, T[] y);
    public static double Yule(Int32[] x, Int32[] y);
    public static double Yule(Double[] x, Double[] y);
    public static double Jaccard(Double[] x, Double[] y);
    public static double Hellinger(Double[] x, Double[] y);
    public static double Euclidean(double x, double y);
    public static double Euclidean(Double[] x, Double[] y);
    public static double Euclidean(double vector1x, double vector1y, double vector2x, double vector2y);
    public static double Euclidean(Tuple`2<double, double> x, Tuple`2<double, double> y);
    public static double Euclidean(Sparse`1<double> x, Sparse`1<double> y);
    public static double SquareMahalanobis(Double[] x, Double[] y, CholeskyDecomposition chol);
    public static double SquareMahalanobis(Double[] x, Double[] y, SingularValueDecomposition svd);
    public static double SquareMahalanobis(Double[] x, Double[] y, Double[0...,0...] precision);
    public static double SquareMahalanobis(Double[] x, Double[] y);
    public static double RusselRao(Int32[] x, Int32[] y);
    public static double RusselRao(Double[] x, Double[] y);
    public static double Chebyshev(Double[] x, Double[] y);
    public static double Dice(Int32[] x, Int32[] y);
    public static double Dice(Double[] x, Double[] y);
    public static double SokalMichener(Int32[] x, Int32[] y);
    public static double SokalMichener(Double[] x, Double[] y);
    public static double WeightedEuclidean(Double[] x, Double[] y, int dimensions);
    public static double WeightedEuclidean(Double[] x, Double[] y, Double[] weights);
    public static double WeightedEuclidean(Double[] x, Double[] y);
    public static double Angular(Double[] x, Double[] y);
    public static double SquareEuclidean(Double[] x, Double[] y);
    public static double SquareEuclidean(double x, double y);
    public static double SquareEuclidean(Sparse`1<double> x, Sparse`1<double> y);
    public static double SquareEuclidean(double x1, double y1, double x2, double y2);
    public static double Hamming(Byte[] x, Byte[] y);
    public static double Hamming(string x, string y);
    public static double Hamming(Double[] x, Double[] y);
    public static double Hamming(BitArray x, BitArray y);
    public static double ArgMax(Double[] x, Double[] y);
    public static double Modular(double x, double y, int modulo);
    public static double Modular(int x, int y, int modulo);
    public static double Modular(double x, double y);
    public static double Modular(int x, int y);
    public static double Cosine(Double[] x, Double[] y);
    public static double Mahalanobis(Double[] x, Double[] y, CholeskyDecomposition chol);
    public static double Mahalanobis(Double[] x, Double[] y, SingularValueDecomposition svd);
    public static double Mahalanobis(Double[] x, Double[] y, Double[0...,0...] precision);
    public static double Mahalanobis(Double[] x, Double[] y);
    public static double BrayCurtis(Double[] x, Double[] y);
    public static double Minkowski(Int32[] x, Int32[] y, double p);
    public static double Minkowski(Double[] x, Double[] y, double p);
    public static double Minkowski(Int32[] x, Int32[] y);
    public static double Minkowski(Double[] x, Double[] y);
    public static double Levenshtein(string x, string y);
    public static double SokalSneath(Int32[] x, Int32[] y);
    public static double SokalSneath(Double[] x, Double[] y);
    public static double Matching(Int32[] x, Int32[] y);
    public static double Matching(Double[] x, Double[] y);
    public static double Canberra(Double[] x, Double[] y);
    public static double RogersTanimoto(Int32[] x, Int32[] y);
    public static double RogersTanimoto(Double[] x, Double[] y);
    public static double Manhattan(Int32[] x, Int32[] y);
    public static double Manhattan(Double[] x, Double[] y);
    public static double Kulczynski(Int32[] x, Int32[] y);
    public static double Kulczynski(Double[] x, Double[] y);
    public static double WeightedSquareEuclidean(Double[] x, Double[] y, int dimensions);
    public static double WeightedSquareEuclidean(Double[] x, Double[] y, Double[] weights);
    public static double WeightedSquareEuclidean(Double[] x, Double[] y);
}
[SerializableAttribute]
public class Accord.Math.Distances.Angular : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Similarity(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.ArgMax : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.BrayCurtis : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Canberra : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Chebyshev : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Cosine : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Similarity(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Dice : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Dirac`1 : ValueType {
    public sealed virtual double Distance(T x, T y);
    public sealed virtual double Similarity(T x, T y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Euclidean : ValueType {
    public sealed virtual double Distance(double x, double y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public double Distance(double vector1x, double vector1y, double vector2x, double vector2y);
    public sealed virtual double Distance(Tuple`2<double, double> x, Tuple`2<double, double> y);
    public sealed virtual double Distance(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double Similarity(double x, double y);
    public sealed virtual double Similarity(Double[] x, Double[] y);
    public sealed virtual double Similarity(Tuple`2<double, double> x, Tuple`2<double, double> y);
    public sealed virtual double Similarity(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Hamming : ValueType {
    private static Byte[] lookup;
    private static Hamming();
    public sealed virtual double Distance(Byte[] x, Byte[] y);
    public sealed virtual double Distance(string x, string y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(BitArray x, BitArray y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Hamming`1 : ValueType {
    public sealed virtual double Distance(T[] x, T[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Hellinger : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
public interface Accord.Math.Distances.IDistance {
}
public interface Accord.Math.Distances.IDistance`1 {
}
public interface Accord.Math.Distances.IDistance`2 {
    public abstract virtual double Distance(T x, U y);
}
public interface Accord.Math.Distances.IMetric`1 {
}
public interface Accord.Math.Distances.ISimilarity`1 {
}
public interface Accord.Math.Distances.ISimilarity`2 {
    public abstract virtual double Similarity(T x, U y);
}
[SerializableAttribute]
public class Accord.Math.Distances.Jaccard : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Similarity(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Jaccard`1 : ValueType {
    public sealed virtual double Distance(T[] x, T[] y);
    public sealed virtual double Similarity(T[] x, T[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Kulczynski : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
public class Accord.Math.Distances.Levenshtein : ValueType {
    public sealed virtual double Distance(string x, string y);
    public sealed virtual object Clone();
}
public class Accord.Math.Distances.Levenshtein`1 : ValueType {
    public sealed virtual double Distance(T[] x, T[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Mahalanobis : ValueType {
    private CholeskyDecomposition chol;
    private SingularValueDecomposition svd;
    private Double[0...,0...] precision;
    public Mahalanobis(CholeskyDecomposition chol);
    public Mahalanobis(SingularValueDecomposition svd);
    public Mahalanobis(Double[0...,0...] precision);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public static Mahalanobis FromCovarianceMatrix(Double[0...,0...] covariance);
    public static Mahalanobis FromPrecisionMatrix(Double[0...,0...] precision);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Manhattan : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Matching : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Minkowski : ValueType {
    private double p;
    public static Minkowski Manhattan;
    public static Minkowski Euclidean;
    public double Order { get; }
    public Minkowski(double p);
    private static Minkowski();
    public double get_Order();
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public static Minkowski Nonmetric(double p);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Modular : ValueType {
    private int modulo;
    public int Modulo { get; }
    public Modular(int modulo);
    public int get_Modulo();
    public sealed virtual double Distance(double x, double y);
    public sealed virtual double Distance(int x, int y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.PearsonCorrelation : ValueType {
    public sealed virtual double Similarity(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.RogersTanimoto : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.RusselRao : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.SokalMichener : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.SokalSneath : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.SquareEuclidean : ValueType {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(double x, double y);
    public sealed virtual double Distance(Sparse`1<double> x, Sparse`1<double> y);
    public double Distance(double x1, double y1, double x2, double y2);
    public sealed virtual double Similarity(Double[] x, Double[] y);
    public sealed virtual double Similarity(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double Similarity(double x, double y);
    public static double Sparse(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.SquareMahalanobis : ValueType {
    private CholeskyDecomposition chol;
    private SingularValueDecomposition svd;
    private Double[0...,0...] precision;
    public SquareMahalanobis(CholeskyDecomposition chol);
    public SquareMahalanobis(SingularValueDecomposition svd);
    public SquareMahalanobis(Double[0...,0...] precision);
    public static SquareMahalanobis FromCovarianceMatrix(Double[0...,0...] covariance);
    public static SquareMahalanobis FromPrecisionMatrix(Double[0...,0...] precision);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.WeightedEuclidean : ValueType {
    private Double[] weights;
    public Double[] Weights { get; public set; }
    public WeightedEuclidean(int dimensions);
    public WeightedEuclidean(Double[] weights);
    public Double[] get_Weights();
    public void set_Weights(Double[] value);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Similarity(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.WeightedSquareEuclidean : ValueType {
    private Double[] weights;
    public Double[] Weights { get; public set; }
    public WeightedSquareEuclidean(int dimensions);
    public WeightedSquareEuclidean(Double[] weights);
    public Double[] get_Weights();
    public void set_Weights(Double[] value);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Similarity(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Math.Distances.Yule : ValueType {
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[GeneratedCodeAttribute("", "")]
public abstract class Accord.Math.Environments.OctaveEnvironment : object {
    private static int dimensionOffset;
    protected static double pi;
    protected static double eps;
    protected retm ret;
    protected static bool UseOctaveDimensionIndexing { get; protected set; }
    protected mat _ { get; }
    private static OctaveEnvironment();
    protected static bool get_UseOctaveDimensionIndexing();
    protected static void set_UseOctaveDimensionIndexing(bool value);
    protected static mat eye(int size);
    protected static mat inv(Double[0...,0...] matrix);
    protected static mat pinv(Double[0...,0...] matrix);
    protected static mat ones(int size);
    protected static mat ones(int n, int m);
    protected static mat zeros(int size);
    protected static mat zeros(int n, int m);
    protected static mat rand(int n, int m);
    protected static Double[] size(Double[0...,0...] m);
    protected static int rank(Double[0...,0...] m);
    protected static Double[] sum(Double[0...,0...] matrix);
    protected static double sum(Double[] vector);
    protected static double prod(Double[] vector);
    protected static Double[] sum(Double[0...,0...] matrix, int dimension);
    protected static double round(double f);
    protected static double ceil(double f);
    protected static double floor(double f);
    protected static Double[] round(Double[] f);
    protected static Double[] ceil(Double[] f);
    protected static Double[] floor(Double[] f);
    protected static Double[0...,0...] round(Double[0...,0...] f);
    protected static Double[0...,0...] ceil(Double[0...,0...] f);
    protected static Double[0...,0...] floor(Double[0...,0...] f);
    protected static double sin(double d);
    protected static double cos(double d);
    protected static double exp(double d);
    protected static double abs(double d);
    protected static double log(double d);
    protected static Double[] sin(Double[] d);
    protected static Double[] cos(Double[] d);
    protected static Double[] exp(Double[] d);
    protected static Double[] abs(Double[] d);
    protected static Double[] log(Double[] d);
    protected static mat sin(Double[0...,0...] d);
    protected static mat cos(Double[0...,0...] d);
    protected static mat exp(Double[0...,0...] d);
    protected static mat abs(Double[0...,0...] d);
    protected static mat log(Double[0...,0...] d);
    protected static mat magic(int n);
    protected List`1<mat> svd(Double[0...,0...] m);
    protected static void qr(Double[0...,0...] m, Double[0...,0...]& Q, Double[0...,0...]& R);
    protected static void qr(Double[0...,0...] m, Double[0...,0...]& Q, Double[0...,0...]& R, Double[]& d);
    protected static Double[] eig(Double[0...,0...] a, Double[0...,0...]& V);
    protected static Double[] eig(Double[0...,0...] a, Double[0...,0...]& V, Double[]& im);
    protected static Double[] eig(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...]& V);
    protected static Double[] eig(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...]& V, Double[]& im);
    protected static Double[] eig(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...]& V, Double[]& alphar, Double[]& beta);
    protected static Double[] eig(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...]& V, Double[]& im, Double[]& alphar, Double[]& alphai, Double[]& beta);
    protected static Double[0...,0...] chol(Double[0...,0...] a);
    protected mat get__();
}
[GeneratedCodeAttribute("", "")]
public abstract class Accord.Math.Environments.REnvironment : object {
    protected vec _ { get; }
    protected vec c(Double[] values);
    protected mat matrix(Double[] values, int rows, int cols);
    protected vec get__();
}
public static class Accord.Math.FourierTransform : object {
    private static int minLength;
    private static int maxLength;
    private static int minBits;
    private static int maxBits;
    private static Int32[][] reversedBits;
    private static Complex[][0...,0...] complexRotation;
    private static FourierTransform();
    public static void DFT(Complex[] data, Direction direction);
    public static void DFT2(Complex[0...,0...] data, Direction direction);
    public static void FFT(Complex[] data, Direction direction);
    public static void FFT2(Complex[0...,0...] data, Direction direction);
    private static Int32[] GetReversedBits(int numberOfBits);
    private static Complex[] GetComplexRotation(int numberOfBits, Direction direction);
    private static void ReorderData(Complex[] data);
}
public static class Accord.Math.Gabor : object {
    public static double Function1D(double x, double mean, double amplitude, double position, double width, double phase, double frequency);
    public static Complex Function2D(int x, int y, double lambda, double theta, double psi, double sigma, double gamma);
    public static double RealFunction2D(int x, int y, double lambda, double theta, double psi, double sigma, double gamma);
    public static double ImaginaryFunction2D(int x, int y, double lambda, double theta, double psi, double sigma, double gamma);
    public static Double[0...,0...] Kernel2D(double lambda, double theta, double psi, double sigma, double gamma);
    public static Double[0...,0...] Kernel2D(double lambda, double theta, double psi, double sigma, double gamma, bool normalized);
    public static Double[0...,0...] Kernel2D(int size, double lambda, double theta, double psi, double sigma, double gamma, bool normalized);
    public static Double[0...,0...] Kernel2D(int size, double lambda, double theta, double psi, double sigma, double gamma, bool normalized, GaborKernelKind function);
}
public enum Accord.Math.GaborKernelKind : Enum {
    public int value__;
    public static GaborKernelKind Real;
    public static GaborKernelKind Imaginary;
    public static GaborKernelKind Magnitude;
    public static GaborKernelKind SquaredMagnitude;
}
public static class Accord.Math.Gamma : object {
    public static double GammaMax;
    private static Double[] gamma_P;
    private static Double[] gamma_Q;
    private static Double[] STIR;
    private static Double[] log_A;
    private static Double[] log_B;
    private static Double[] log_C;
    private static Gamma();
    public static double Function(double x);
    public static double Multivariate(double x, int p);
    public static double Digamma(double x);
    public static double Trigamma(double x);
    public static double Stirling(double x);
    public static double UpperIncomplete(double a, double x);
    public static double LowerIncomplete(double a, double x);
    public static double Log(double x);
    public static double Log(double x, int p);
    public static double InverseLowerIncomplete(double a, double y);
    public static double InverseUpperIncomplete(double a, double y);
    public static double Inverse(double a, double y);
    private static double inverse(double a, double y);
}
public class Accord.Math.Geometry.Circle : object {
    [CompilerGeneratedAttribute]
private double <Radius>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Origin>k__BackingField;
    public double Area { get; }
    public double Circumference { get; }
    public double Diameter { get; }
    public double Radius { get; public set; }
    public Point Origin { get; public set; }
    public Circle(float x, float y, double radius);
    public Circle(double x, double y, double radius);
    public Circle(Point origin, double radius);
    public Circle(Point p1, Point p2, Point p3);
    public double get_Area();
    public double get_Circumference();
    public double get_Diameter();
    [CompilerGeneratedAttribute]
public double get_Radius();
    [CompilerGeneratedAttribute]
public void set_Radius(double value);
    [CompilerGeneratedAttribute]
public Point get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(Point value);
    public double DistanceToPoint(Point point);
}
public class Accord.Math.Geometry.ClosePointsMergingOptimizer : object {
    private float maxDistanceToMerge;
    public float MaxDistanceToMerge { get; public set; }
    public ClosePointsMergingOptimizer(float maxDistanceToMerge);
    public float get_MaxDistanceToMerge();
    public void set_MaxDistanceToMerge(float value);
    public sealed virtual List`1<IntPoint> OptimizeShape(List`1<IntPoint> shape);
}
public class Accord.Math.Geometry.ConvexHullDefects : object {
    [CompilerGeneratedAttribute]
private double <MinimumDepth>k__BackingField;
    public double MinimumDepth { get; public set; }
    public ConvexHullDefects(double minDepth);
    [CompilerGeneratedAttribute]
public double get_MinimumDepth();
    [CompilerGeneratedAttribute]
public void set_MinimumDepth(double value);
    public List`1<ConvexityDefect> FindDefects(List`1<IntPoint> contour, List`1<IntPoint> convexHull);
    private static ConvexityDefect extractDefect(List`1<IntPoint> contour, int startIndex, int endIndex);
}
public class Accord.Math.Geometry.ConvexityDefect : object {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Depth>k__BackingField;
    public int Start { get; public set; }
    public int End { get; public set; }
    public int Point { get; public set; }
    public double Depth { get; public set; }
    public ConvexityDefect(int point, int start, int end, double depth);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public void set_End(int value);
    [CompilerGeneratedAttribute]
public int get_Point();
    [CompilerGeneratedAttribute]
public void set_Point(int value);
    [CompilerGeneratedAttribute]
public double get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(double value);
}
public class Accord.Math.Geometry.CoplanarPosit : object {
    private float focalLength;
    private Vector3[] modelPoints;
    private Matrix3x3 modelVectors;
    private Matrix3x3 modelPseudoInverse;
    private Vector3 modelNormal;
    private Matrix3x3 alternateRotation;
    private Vector3 alternateTranslation;
    private float alternatePoseError;
    private Matrix3x3 bestRotation;
    private Vector3 bestTranslation;
    private float bestPoseError;
    private static float ErrorLimit;
    public Matrix3x3 BestEstimatedRotation { get; }
    public Vector3 BestEstimatedTranslation { get; }
    public float BestEstimationError { get; }
    public Matrix3x3 AlternateEstimatedRotation { get; }
    public Vector3 AlternateEstimatedTranslation { get; }
    public float AlternateEstimationError { get; }
    public Vector3[] Model { get; }
    public float FocalLength { get; public set; }
    public CoplanarPosit(Vector3[] model, float focalLength);
    public Matrix3x3 get_BestEstimatedRotation();
    public Vector3 get_BestEstimatedTranslation();
    public float get_BestEstimationError();
    public Matrix3x3 get_AlternateEstimatedRotation();
    public Vector3 get_AlternateEstimatedTranslation();
    public float get_AlternateEstimationError();
    public Vector3[] get_Model();
    public float get_FocalLength();
    public void set_FocalLength(float value);
    public void EstimatePose(Point[] points, Matrix3x3& rotation, Vector3& translation);
    private float Iterate(Point[] points, Matrix3x3& rotation, Vector3& translation);
    private void POS(Point[] imagePoints, Vector3 eps, Matrix3x3& rotation1, Matrix3x3& rotation2, Vector3& translation1, Vector3& translation2);
    private float GetError(Point[] imagePoints, Matrix3x3 rotation, Vector3 translation);
}
public class Accord.Math.Geometry.DiscreteCurveEvolution : object {
    private int vertices;
    public int NumberOfVertices { get; public set; }
    public DiscreteCurveEvolution(int vertices);
    public int get_NumberOfVertices();
    public void set_NumberOfVertices(int value);
    public sealed virtual List`1<IntPoint> OptimizeShape(List`1<IntPoint> shape);
    private static Double[] winkel(List`1<Complex> z);
}
public class Accord.Math.Geometry.FlatAnglesOptimizer : object {
    private float maxAngleToKeep;
    public float MaxAngleToKeep { get; public set; }
    public FlatAnglesOptimizer(float maxAngleToKeep);
    public float get_MaxAngleToKeep();
    public void set_MaxAngleToKeep(float value);
    public sealed virtual List`1<IntPoint> OptimizeShape(List`1<IntPoint> shape);
}
public static class Accord.Math.Geometry.GeometryTools : object {
    public static float GetAngleBetweenVectors(Point startPoint, Point vector1end, Point vector2end);
    public static float GetAngleBetweenLines(Point a1, Point a2, Point b1, Point b2);
}
public class Accord.Math.Geometry.GrahamConvexHull : object {
    public sealed virtual List`1<IntPoint> FindHull(List`1<IntPoint> points);
}
public interface Accord.Math.Geometry.IConvexHullAlgorithm {
    public abstract virtual List`1<IntPoint> FindHull(List`1<IntPoint> points);
}
public interface Accord.Math.Geometry.IShapeOptimizer {
    public abstract virtual List`1<IntPoint> OptimizeShape(List`1<IntPoint> shape);
}
public class Accord.Math.Geometry.KCurvature : object {
    [CompilerGeneratedAttribute]
private int <K>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange <Theta>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Suppression>k__BackingField;
    public int K { get; public set; }
    public DoubleRange Theta { get; public set; }
    public int Suppression { get; public set; }
    public KCurvature(int k, DoubleRange theta);
    [CompilerGeneratedAttribute]
public int get_K();
    [CompilerGeneratedAttribute]
public void set_K(int value);
    [CompilerGeneratedAttribute]
public DoubleRange get_Theta();
    [CompilerGeneratedAttribute]
public void set_Theta(DoubleRange value);
    [CompilerGeneratedAttribute]
public int get_Suppression();
    [CompilerGeneratedAttribute]
public void set_Suppression(int value);
    public List`1<IntPoint> FindPeaks(List`1<IntPoint> contour);
}
public class Accord.Math.Geometry.Line : object {
    private float k;
    private float b;
    public bool IsVertical { get; }
    public bool IsHorizontal { get; }
    public float Slope { get; }
    public float Intercept { get; }
    private Line(Point start, Point end);
    private Line(float slope, float intercept);
    private Line(float radius, float theta, bool unused);
    private Line(Point point, float theta);
    public bool get_IsVertical();
    public bool get_IsHorizontal();
    public float get_Slope();
    public float get_Intercept();
    public static Line FromPoints(Point point1, Point point2);
    public static Line FromSlopeIntercept(float slope, float intercept);
    public static Line FromRTheta(float radius, float theta);
    public static Line FromPointTheta(Point point, float theta);
    public float GetAngleBetweenLines(Line secondLine);
    public Nullable`1<Point> GetIntersectionWith(Line secondLine);
    public Nullable`1<Point> GetIntersectionWith(LineSegment other);
    public float DistanceToPoint(Point point);
    public static bool op_Equality(Line line1, Line line2);
    public static bool op_Inequality(Line line1, Line line2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Accord.Math.Geometry.LineSegment : object {
    private Point start;
    private Point end;
    private Line line;
    public Point Start { get; }
    public Point End { get; }
    public float Length { get; }
    public LineSegment(Point start, Point end);
    public Point get_Start();
    public Point get_End();
    public float get_Length();
    public static Line op_Explicit(LineSegment segment);
    public float DistanceToPoint(Point point);
    public Nullable`1<Point> GetIntersectionWith(LineSegment other);
    public Nullable`1<Point> GetIntersectionWith(Line other);
    private ProjectionLocation LocateProjection(Point point);
    public static bool op_Equality(LineSegment line1, LineSegment line2);
    public static bool op_Inequality(LineSegment line1, LineSegment line2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Accord.Math.Geometry.LineStraighteningOptimizer : object {
    private float maxDistanceToRemove;
    public float MaxDistanceToRemove { get; public set; }
    public LineStraighteningOptimizer(float maxDistanceToRemove);
    public float get_MaxDistanceToRemove();
    public void set_MaxDistanceToRemove(float value);
    public sealed virtual List`1<IntPoint> OptimizeShape(List`1<IntPoint> shape);
}
public static class Accord.Math.Geometry.PointsCloud : object {
    private static float quadrilateralRelativeDistortionLimit;
    public static float QuadrilateralRelativeDistortionLimit { get; public set; }
    private static PointsCloud();
    public static void Shift(IList`1<IntPoint> cloud, IntPoint shift);
    public static void GetBoundingRectangle(IEnumerable`1<IntPoint> cloud, IntPoint& minXY, IntPoint& maxXY);
    public static Point GetCenterOfGravity(IEnumerable`1<IntPoint> cloud);
    public static IntPoint GetFurthestPoint(IEnumerable`1<IntPoint> cloud, IntPoint referencePoint);
    public static void GetFurthestPointsFromLine(IEnumerable`1<IntPoint> cloud, IntPoint linePoint1, IntPoint linePoint2, IntPoint& furthestPoint1, IntPoint& furthestPoint2);
    public static void GetFurthestPointsFromLine(IEnumerable`1<IntPoint> cloud, IntPoint linePoint1, IntPoint linePoint2, IntPoint& furthestPoint1, Single& distance1, IntPoint& furthestPoint2, Single& distance2);
    public static IntPoint GetFurthestPointFromLine(IEnumerable`1<IntPoint> cloud, IntPoint linePoint1, IntPoint linePoint2);
    public static IntPoint GetFurthestPointFromLine(IEnumerable`1<IntPoint> cloud, IntPoint linePoint1, IntPoint linePoint2, Single& distance);
    public static float get_QuadrilateralRelativeDistortionLimit();
    public static void set_QuadrilateralRelativeDistortionLimit(float value);
    public static List`1<IntPoint> FindQuadrilateralCorners(IEnumerable`1<IntPoint> cloud);
}
public enum Accord.Math.Geometry.PolygonSubType : Enum {
    public int value__;
    public static PolygonSubType Unknown;
    public static PolygonSubType Trapezoid;
    public static PolygonSubType Parallelogram;
    public static PolygonSubType Rectangle;
    public static PolygonSubType Rhombus;
    public static PolygonSubType Square;
    public static PolygonSubType EquilateralTriangle;
    public static PolygonSubType IsoscelesTriangle;
    public static PolygonSubType RectangledTriangle;
    public static PolygonSubType RectangledIsoscelesTriangle;
}
public class Accord.Math.Geometry.Posit : object {
    private float focalLength;
    private Vector3[] modelPoints;
    private Matrix3x3 modelVectors;
    private Matrix3x3 modelPseudoInverse;
    private static float stop_epsilon;
    public Vector3[] Model { get; }
    public float FocalLength { get; public set; }
    public Posit(Vector3[] model, float focalLength);
    public Vector3[] get_Model();
    public float get_FocalLength();
    public void set_FocalLength(float value);
    public void EstimatePose(Point[] points, Matrix3x3& rotation, Vector3& translation);
}
public enum Accord.Math.Geometry.ShapeType : Enum {
    public int value__;
    public static ShapeType Unknown;
    public static ShapeType Circle;
    public static ShapeType Triangle;
    public static ShapeType Quadrilateral;
}
public class Accord.Math.Geometry.SimpleShapeChecker : object {
    private FlatAnglesOptimizer shapeOptimizer;
    private float minAcceptableDistortion;
    private float relativeDistortionLimit;
    private float angleError;
    private float lengthError;
    public float MinAcceptableDistortion { get; public set; }
    public float RelativeDistortionLimit { get; public set; }
    public float AngleError { get; public set; }
    public float LengthError { get; public set; }
    public float get_MinAcceptableDistortion();
    public void set_MinAcceptableDistortion(float value);
    public float get_RelativeDistortionLimit();
    public void set_RelativeDistortionLimit(float value);
    public float get_AngleError();
    public void set_AngleError(float value);
    public float get_LengthError();
    public void set_LengthError(float value);
    public ShapeType CheckShapeType(List`1<IntPoint> edgePoints);
    public bool IsCircle(List`1<IntPoint> edgePoints);
    public bool IsCircle(List`1<IntPoint> edgePoints, Point& center, Single& radius);
    public bool IsQuadrilateral(List`1<IntPoint> edgePoints);
    public bool IsQuadrilateral(List`1<IntPoint> edgePoints, List`1& corners);
    public bool IsTriangle(List`1<IntPoint> edgePoints);
    public bool IsTriangle(List`1<IntPoint> edgePoints, List`1& corners);
    public bool IsConvexPolygon(List`1<IntPoint> edgePoints, List`1& corners);
    public PolygonSubType CheckPolygonSubType(List`1<IntPoint> corners);
    public bool CheckIfPointsFitShape(List`1<IntPoint> edgePoints, List`1<IntPoint> corners);
    private List`1<IntPoint> GetShapeCorners(List`1<IntPoint> edgePoints);
}
public static class Accord.Math.HartleyTransform : object {
    public static void DHT(Double[] data);
    public static void DHT(Double[0...,0...] data);
    private static double cas(double theta);
}
public static class Accord.Math.HilbertTransform : object {
    public static void FHT(Double[] data, Direction direction);
    public static void FHT(Complex[] data, Direction direction);
}
public interface Accord.Math.IConvergence {
    public double Tolerance { get; public set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public abstract virtual double get_Tolerance();
    public abstract virtual void set_Tolerance(double value);
    public abstract virtual int get_MaxIterations();
    public abstract virtual void set_MaxIterations(int value);
    public abstract virtual int get_CurrentIteration();
    public abstract virtual bool get_HasConverged();
    public abstract virtual void Clear();
}
public interface Accord.Math.IConvergence`1 {
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public T NewValue { get; public set; }
    public abstract virtual int get_Iterations();
    public abstract virtual void set_Iterations(int value);
    public abstract virtual T get_NewValue();
    public abstract virtual void set_NewValue(T value);
}
public interface Accord.Math.IMatrixFormatProvider {
    public string FormatMatrixStart { get; }
    public string FormatMatrixEnd { get; }
    public string FormatRowStart { get; }
    public string FormatRowEnd { get; }
    public string FormatColStart { get; }
    public string FormatColEnd { get; }
    public string FormatRowDelimiter { get; }
    public string FormatColDelimiter { get; }
    public string ParseMatrixStart { get; }
    public string ParseMatrixEnd { get; }
    public string ParseRowStart { get; }
    public string ParseRowEnd { get; }
    public string ParseColStart { get; }
    public string ParseColEnd { get; }
    public string ParseRowDelimiter { get; }
    public string ParseColDelimiter { get; }
    public IFormatProvider InnerProvider { get; }
    public abstract virtual string get_FormatMatrixStart();
    public abstract virtual string get_FormatMatrixEnd();
    public abstract virtual string get_FormatRowStart();
    public abstract virtual string get_FormatRowEnd();
    public abstract virtual string get_FormatColStart();
    public abstract virtual string get_FormatColEnd();
    public abstract virtual string get_FormatRowDelimiter();
    public abstract virtual string get_FormatColDelimiter();
    public abstract virtual string get_ParseMatrixStart();
    public abstract virtual string get_ParseMatrixEnd();
    public abstract virtual string get_ParseRowStart();
    public abstract virtual string get_ParseRowEnd();
    public abstract virtual string get_ParseColStart();
    public abstract virtual string get_ParseColEnd();
    public abstract virtual string get_ParseRowDelimiter();
    public abstract virtual string get_ParseColDelimiter();
    public abstract virtual IFormatProvider get_InnerProvider();
}
public interface Accord.Math.Integration.IMultidimensionalIntegration {
    public int NumberOfParameters { get; }
    public Func`2<Double[], double> Function { get; public set; }
    public DoubleRange[] Range { get; }
    public abstract virtual int get_NumberOfParameters();
    public abstract virtual Func`2<Double[], double> get_Function();
    public abstract virtual void set_Function(Func`2<Double[], double> value);
    public abstract virtual DoubleRange[] get_Range();
}
public class Accord.Math.Integration.InfiniteAdaptiveGaussKronrod : object {
    private Int32[] iwork;
    private Double[] work;
    private double result;
    private double error;
    private int evaluations;
    private double abstol;
    private double reltol;
    private int limit;
    private int lenw;
    [CompilerGeneratedAttribute]
private Func`2<double, double> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private InfiniteAdaptiveGaussKronrodStatus <Status>k__BackingField;
    public int Subintervals { get; }
    public Func`2<double, double> Function { get; public set; }
    public DoubleRange Range { get; public set; }
    public double ToleranceAbsolute { get; public set; }
    public double ToleranceRelative { get; public set; }
    public InfiniteAdaptiveGaussKronrodStatus Status { get; private set; }
    public double Area { get; }
    public double Error { get; }
    public int FunctionEvaluations { get; }
    public InfiniteAdaptiveGaussKronrod(int subintervals);
    public InfiniteAdaptiveGaussKronrod(int subintervals, Func`2<double, double> function);
    public InfiniteAdaptiveGaussKronrod(int subintervals, Func`2<double, double> function, double a, double b);
    public int get_Subintervals();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<double, double> get_Function();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Function(Func`2<double, double> value);
    [CompilerGeneratedAttribute]
public sealed virtual DoubleRange get_Range();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Range(DoubleRange value);
    public double get_ToleranceAbsolute();
    public void set_ToleranceAbsolute(double value);
    public double get_ToleranceRelative();
    public void set_ToleranceRelative(double value);
    [CompilerGeneratedAttribute]
public sealed virtual InfiniteAdaptiveGaussKronrodStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(InfiniteAdaptiveGaussKronrodStatus value);
    public sealed virtual double get_Area();
    public double get_Error();
    public int get_FunctionEvaluations();
    private void init(int subintervals, Func`2<double, double> function, double a, double b);
    public sealed virtual bool Compute();
    public static double Integrate(Func`2<double, double> f);
    public static double Integrate(Func`2<double, double> f, double a, double b);
    public static double Integrate(Func`2<double, double> f, double a, double b, double tolerance);
    private static int qagi_(Func`2<double, double> f, double bound, int inf, double epsabs, double epsrel, Double& result, Double& abserr, Int32& neval, Int32& ier, int limit, int lenw, Int32& last, Int32[] iwork, Double[] dwork);
    private static int qagie_(Func`2<double, double> f, Double& bound, Int32& inf, Double& epsabs, Double& epsrel, Int32& limit, Double& result, Double& abserr, Int32& neval, Int32& ier, Double* alist__, Double* blist, Double* rlist, Double* elist, Int32* iord, Int32& last);
    private static int qelg_(Int32& n, Double* epstab, Double& result, Double& abserr, Double* res3la, Int32& nres);
    private static int qk15i_(Func`2<double, double> f, Double& boun, Int32& inf, double a, double b, Double& result, Double& abserr, Double& resabs, Double& resasc);
    private static int qpsrt_(Int32& limit, Int32& last, Int32& maxerr, Double& ermax, Double* elist, Int32* iord, Int32& nrmax);
    public sealed virtual object Clone();
}
public enum Accord.Math.Integration.InfiniteAdaptiveGaussKronrodStatus : Enum {
    public int value__;
    public static InfiniteAdaptiveGaussKronrodStatus Success;
    public static InfiniteAdaptiveGaussKronrodStatus MaximumSubdivisions;
    public static InfiniteAdaptiveGaussKronrodStatus RoundoffError;
    public static InfiniteAdaptiveGaussKronrodStatus BadBehavioredFunction;
    public static InfiniteAdaptiveGaussKronrodStatus AlgorithmDivergence;
    public static InfiniteAdaptiveGaussKronrodStatus IntegralDiverence;
}
public interface Accord.Math.Integration.INumericalIntegration {
    public double Area { get; }
    public abstract virtual double get_Area();
    public abstract virtual bool Compute();
}
public interface Accord.Math.Integration.INumericalIntegration`1 {
    public TCode Status { get; }
    public abstract virtual TCode get_Status();
}
public interface Accord.Math.Integration.IUnivariateIntegration {
    public Func`2<double, double> Function { get; public set; }
    public DoubleRange Range { get; public set; }
    public abstract virtual Func`2<double, double> get_Function();
    public abstract virtual void set_Function(Func`2<double, double> value);
    public abstract virtual DoubleRange get_Range();
    public abstract virtual void set_Range(DoubleRange value);
}
public class Accord.Math.Integration.MonteCarloIntegration : object {
    private int count;
    private double sum;
    private double sum2;
    [CompilerGeneratedAttribute]
private int <NumberOfParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange[] <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Double[], double> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private Random <Random>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Area>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    public int NumberOfParameters { get; private set; }
    public DoubleRange[] Range { get; private set; }
    public Func`2<Double[], double> Function { get; public set; }
    public Random Random { get; public set; }
    public double Area { get; public set; }
    public double Error { get; public set; }
    public int Iterations { get; public set; }
    public MonteCarloIntegration(int parameters, Func`2<Double[], double> function);
    public MonteCarloIntegration(int parameters);
    [CompilerGeneratedAttribute]
public sealed virtual int get_NumberOfParameters();
    [CompilerGeneratedAttribute]
private void set_NumberOfParameters(int value);
    [CompilerGeneratedAttribute]
public sealed virtual DoubleRange[] get_Range();
    [CompilerGeneratedAttribute]
private void set_Range(DoubleRange[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Double[], double> get_Function();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Function(Func`2<Double[], double> value);
    [CompilerGeneratedAttribute]
public Random get_Random();
    [CompilerGeneratedAttribute]
public void set_Random(Random value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Area();
    [CompilerGeneratedAttribute]
public void set_Area(double value);
    [CompilerGeneratedAttribute]
public double get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(double value);
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public void set_Iterations(int value);
    public void Reset();
    public sealed virtual bool Compute();
    public static double Integrate(Func`2<Double[], double> func, Double[] a, Double[] b, int samples);
    public static double Integrate(Func`2<Double[], double> func, Double[] a, Double[] b);
    public static double Integrate(Func`2<double, double> func, double a, double b, int samples);
    public sealed virtual object Clone();
}
[CompilerGeneratedAttribute]
internal class Accord.Math.Integration.NamespaceDoc : object {
}
public class Accord.Math.Integration.NonAdaptiveGaussKronrod : object {
    private double result;
    private double error;
    private int evaluations;
    private DoubleRange range;
    [CompilerGeneratedAttribute]
private Func`2<double, double> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ToleranceAbsolute>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ToleranceRelative>k__BackingField;
    [CompilerGeneratedAttribute]
private NonAdaptiveGaussKronrodStatus <Status>k__BackingField;
    private static Double[] x1;
    private static Double[] w87a;
    private static Double[] w87b;
    private static Double[] x2;
    private static Double[] x3;
    private static Double[] x4;
    private static Double[] w10;
    private static Double[] w21a;
    private static Double[] w21b;
    private static Double[] w43a;
    private static Double[] w43b;
    public Func`2<double, double> Function { get; public set; }
    public DoubleRange Range { get; public set; }
    public double ToleranceAbsolute { get; public set; }
    public double ToleranceRelative { get; public set; }
    public double Area { get; }
    public double Error { get; }
    public NonAdaptiveGaussKronrodStatus Status { get; private set; }
    public int FunctionEvaluations { get; }
    public NonAdaptiveGaussKronrod(Func`2<double, double> function);
    public NonAdaptiveGaussKronrod(Func`2<double, double> function, double a, double b);
    private static NonAdaptiveGaussKronrod();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<double, double> get_Function();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Function(Func`2<double, double> value);
    public sealed virtual DoubleRange get_Range();
    public sealed virtual void set_Range(DoubleRange value);
    [CompilerGeneratedAttribute]
public double get_ToleranceAbsolute();
    [CompilerGeneratedAttribute]
public void set_ToleranceAbsolute(double value);
    [CompilerGeneratedAttribute]
public double get_ToleranceRelative();
    [CompilerGeneratedAttribute]
public void set_ToleranceRelative(double value);
    public sealed virtual double get_Area();
    public double get_Error();
    [CompilerGeneratedAttribute]
public sealed virtual NonAdaptiveGaussKronrodStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(NonAdaptiveGaussKronrodStatus value);
    public int get_FunctionEvaluations();
    public sealed virtual bool Compute();
    public static double Integrate(Func`2<double, double> f, double a, double b);
    public static double Integrate(Func`2<double, double> f, double a, double b, double tolerance);
    internal static int qng_(Func`2<double, double> f, double a, double b, double epsabs, double epsrel, Double& result, Double& abserr, Int32& neval, Int32& ier);
    public sealed virtual object Clone();
}
public enum Accord.Math.Integration.NonAdaptiveGaussKronrodStatus : Enum {
    public int value__;
    public static NonAdaptiveGaussKronrodStatus Success;
    public static NonAdaptiveGaussKronrodStatus MaximumSteps;
}
public class Accord.Math.Integration.RombergMethod : object {
    private Double[] s;
    private DoubleRange range;
    [CompilerGeneratedAttribute]
private Func`2<double, double> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Area>k__BackingField;
    public Func`2<double, double> Function { get; public set; }
    public double Area { get; private set; }
    public int Steps { get; }
    public DoubleRange Range { get; public set; }
    public RombergMethod(Func`2<double, double> function);
    public RombergMethod(Func`2<double, double> function, double a, double b);
    public RombergMethod(int steps);
    public RombergMethod(int steps, Func`2<double, double> function);
    public RombergMethod(int steps, Func`2<double, double> function, double a, double b);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<double, double> get_Function();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Function(Func`2<double, double> value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Area();
    [CompilerGeneratedAttribute]
private void set_Area(double value);
    public int get_Steps();
    public sealed virtual DoubleRange get_Range();
    public sealed virtual void set_Range(DoubleRange value);
    public sealed virtual bool Compute();
    public static double Integrate(Func`2<double, double> func, double a, double b);
    public static double Integrate(Func`2<double, double> func, double a, double b, int steps);
    public sealed virtual object Clone();
}
public class Accord.Math.Integration.TrapezoidalRule : object {
    private DoubleRange range;
    [CompilerGeneratedAttribute]
private Func`2<double, double> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Area>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Steps>k__BackingField;
    public Func`2<double, double> Function { get; public set; }
    public double Area { get; private set; }
    public int Steps { get; public set; }
    public DoubleRange Range { get; public set; }
    public TrapezoidalRule(Func`2<double, double> function);
    public TrapezoidalRule(Func`2<double, double> function, double a, double b);
    public TrapezoidalRule(int steps);
    public TrapezoidalRule(int steps, Func`2<double, double> function);
    public TrapezoidalRule(int steps, Func`2<double, double> function, double a, double b);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<double, double> get_Function();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Function(Func`2<double, double> value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Area();
    [CompilerGeneratedAttribute]
private void set_Area(double value);
    [CompilerGeneratedAttribute]
public int get_Steps();
    [CompilerGeneratedAttribute]
public void set_Steps(int value);
    public sealed virtual DoubleRange get_Range();
    public sealed virtual void set_Range(DoubleRange value);
    public sealed virtual bool Compute();
    public sealed virtual object Clone();
    public static double Integrate(Func`2<double, double> func, double a, double b, int steps);
}
public interface Accord.Math.ISingleValueConvergence {
}
[ExtensionAttribute]
[GeneratedCodeAttribute("Accord.NET T4 Templates", "3.3")]
public static class Accord.Math.Jagged : object {
    public static T[][] Zeros(int rows, int columns);
    public static T[][][] Zeros(int rows, int columns, int depth);
    public static T[][] Ones(int rows, int columns);
    public static Double[][] Zeros(int rows, int columns);
    public static Double[][][] Zeros(int rows, int columns, int depth);
    public static Double[][] Ones(int rows, int columns);
    public static T[][] Create(int rows, int columns, T value);
    public static Array Create(Type elementType, Int32[] shape, object value);
    public static Array Create(Int32[] shape, T value);
    public static Array Zeros(Type elementType, Int32[] shape);
    public static Array Zeros(Int32[] shape);
    public static T[][] Square(int size, T value);
    public static T[][] Create(int rows, int columns, T[] values);
    public static T[][] Create(T[][] rows);
    public static T[][] Create(int rows, int columns, T[][] values, bool transpose);
    public static T[][] Create(T[0...,0...] values);
    public static T[][] OneHot(Boolean[] mask);
    public static T[][] OneHot(Int32[] indices);
    public static Double[][] OneHot(Int32[] indices);
    public static T[][] OneHot(Int32[] indices, int columns);
    public static Double[][] OneHot(Int32[] indices, int columns);
    public static T[][] OneHot(Boolean[] mask, T[][] result);
    public static T[][] OneHot(Int32[] indices, T[][] result);
    public static Double[][] OneHot(Int32[] indices, Double[][] result);
    public static T[][] KHot(Boolean[][] mask);
    public static T[][] KHot(Int32[][] indices, int columns);
    public static Double[][] KHot(Int32[][] indices, int columns);
    public static Double[][] KHot(Boolean[][] mask, int columns);
    public static T[][] KHot(Boolean[][] mask, T[][] result);
    public static T[][] KHot(Int32[][] indices, T[][] result);
    public static Double[][] KHot(Int32[][] indices, Double[][] result);
    public static T[][] CreateAs(T[0...,0...] matrix);
    public static T[][] CreateAs(T[][] matrix);
    public static T[][] RowVector(T[] values);
    public static T[][] ColumnVector(T[] values);
    public static Double[][] Identity(int size);
    public static T[][] Identity(int size);
    public static Double[][] Magic(int size);
    public static T[][] Diagonal(int size, T value);
    public static T[][] Diagonal(int size, T value, T[][] result);
    public static T[][] Diagonal(int rows, int cols, T value);
    public static T[][] Diagonal(int rows, int cols, T value, T[][] result);
    public static T[][] Diagonal(T[] values);
    public static T[][] Diagonal(T[] values, T[][] result);
    public static T[][] Diagonal(int size, T[] values);
    public static T[][] Diagonal(int size, T[] values, T[][] result);
    public static T[][] Diagonal(int rows, int cols, T[] values);
    public static T[][] Diagonal(int rows, int cols, T[] values, T[][] result);
    public static T[][] Diagonal(T[][][] blocks);
    public static TOutput[][] CreateAs(TInput[0...,0...] matrix);
    public static TOutput[][] CreateAs(TInput[][] matrix);
    public static TOutput[][][] CreateAs(TInput[][][] matrix);
    public static T[][] Reshape(T[] array, int rows, int cols, MatrixOrder order);
    [ExtensionAttribute]
public static T[][] Reshape(T[] array, int rows, int cols, T[][] result, MatrixOrder order);
    public static T[][] Random(int size, IRandomNumberGenerator`1<T> generator, bool symmetric, T[][] result);
    public static T[][] Random(int rows, int cols, IRandomNumberGenerator`1<T> generator, T[][] result);
    [IteratorStateMachineAttribute("Accord.Math.Jagged/<Enumerate>d__56")]
[ExtensionAttribute]
public static IEnumerable Enumerate(Array array, Int32[] shape);
    [IteratorStateMachineAttribute("Accord.Math.Jagged/<Enumerate>d__57`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Enumerate(Array array, Int32[] shape);
    [IteratorStateMachineAttribute("Accord.Math.Jagged/<Enumerate>d__58`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Enumerate(Array array);
    [IteratorStateMachineAttribute("Accord.Math.Jagged/<Enumerate>d__59")]
[ExtensionAttribute]
public static IEnumerable Enumerate(Array array);
    public static T[][] Transpose(T[0...,0...] matrix);
    public static Double[][] Parse(string str);
    public static Double[][] Parse(string str, IMatrixFormatProvider provider);
    public static bool TryParse(string s, IMatrixFormatProvider provider, Double[][]& matrix);
    public static Int32[][] Outer(Int32[] a, Int32[] b);
    public static Double[][] Outer(Int32[] a, Double[] b);
    public static Single[][] Outer(Int32[] a, Single[] b);
    public static Double[][] Outer(Double[] a, Double[] b);
    public static Double[][] Outer(Double[] a, Int32[] b);
    public static Double[][] Outer(Double[] a, Single[] b);
    public static Single[][] Outer(Single[] a, Single[] b);
    public static Double[][] Outer(Single[] a, Double[] b);
    public static Single[][] Outer(Single[] a, Int32[] b);
    public static Int64[][] Outer(Int64[] a, Int64[] b);
    public static Double[][] Outer(Int64[] a, Double[] b);
    public static Int32[][] Outer(Int64[] a, Int32[] b);
    public static Single[][] Outer(Int64[] a, Single[] b);
    public static Decimal[][] Outer(Decimal[] a, Decimal[] b);
    public static Double[][] Outer(Decimal[] a, Double[] b);
    public static Int32[][] Outer(Decimal[] a, Int32[] b);
    public static Single[][] Outer(Decimal[] a, Single[] b);
    public static Byte[][] Outer(Byte[] a, Byte[] b);
    public static Double[][] Outer(Byte[] a, Double[] b);
    public static Int32[][] Outer(Byte[] a, Int32[] b);
    public static Single[][] Outer(Byte[] a, Single[] b);
    public static Int16[][] Outer(Int16[] a, Int16[] b);
    public static Double[][] Outer(Int16[] a, Double[] b);
    public static Int32[][] Outer(Int16[] a, Int32[] b);
    public static Single[][] Outer(Int16[] a, Single[] b);
    public static SByte[][] Outer(SByte[] a, SByte[] b);
    public static Double[][] Outer(SByte[] a, Double[] b);
    public static Int32[][] Outer(SByte[] a, Int32[] b);
    public static Single[][] Outer(SByte[] a, Single[] b);
    public static Int32[][] Outer(Int32[] a, Int32[] b, Int32[][] result);
    public static Double[][] Outer(Int32[] a, Int32[] b, Double[][] result);
    public static Int32[][] Outer(Int32[] a, Double[] b, Int32[][] result);
    public static Double[][] Outer(Int32[] a, Double[] b, Double[][] result);
    public static Int32[][] Outer(Int32[] a, Single[] b, Int32[][] result);
    public static Single[][] Outer(Int32[] a, Single[] b, Single[][] result);
    public static Double[][] Outer(Int32[] a, Single[] b, Double[][] result);
    public static Double[][] Outer(Double[] a, Double[] b, Double[][] result);
    public static Int32[][] Outer(Double[] a, Double[] b, Int32[][] result);
    public static Double[][] Outer(Double[] a, Int32[] b, Double[][] result);
    public static Int32[][] Outer(Double[] a, Int32[] b, Int32[][] result);
    public static Double[][] Outer(Double[] a, Single[] b, Double[][] result);
    public static Single[][] Outer(Double[] a, Single[] b, Single[][] result);
    public static Int32[][] Outer(Double[] a, Single[] b, Int32[][] result);
    public static Single[][] Outer(Single[] a, Single[] b, Single[][] result);
    public static Double[][] Outer(Single[] a, Single[] b, Double[][] result);
    public static Int32[][] Outer(Single[] a, Single[] b, Int32[][] result);
    public static Single[][] Outer(Single[] a, Double[] b, Single[][] result);
    public static Double[][] Outer(Single[] a, Double[] b, Double[][] result);
    public static Int32[][] Outer(Single[] a, Double[] b, Int32[][] result);
    public static Single[][] Outer(Single[] a, Int32[] b, Single[][] result);
    public static Int32[][] Outer(Single[] a, Int32[] b, Int32[][] result);
    public static Double[][] Outer(Single[] a, Int32[] b, Double[][] result);
    public static Int64[][] Outer(Int64[] a, Int64[] b, Int64[][] result);
    public static Double[][] Outer(Int64[] a, Int64[] b, Double[][] result);
    public static Int32[][] Outer(Int64[] a, Int64[] b, Int32[][] result);
    public static Int64[][] Outer(Int64[] a, Double[] b, Int64[][] result);
    public static Double[][] Outer(Int64[] a, Double[] b, Double[][] result);
    public static Int32[][] Outer(Int64[] a, Double[] b, Int32[][] result);
    public static Int64[][] Outer(Int64[] a, Int32[] b, Int64[][] result);
    public static Int32[][] Outer(Int64[] a, Int32[] b, Int32[][] result);
    public static Double[][] Outer(Int64[] a, Int32[] b, Double[][] result);
    public static Int64[][] Outer(Int64[] a, Single[] b, Int64[][] result);
    public static Single[][] Outer(Int64[] a, Single[] b, Single[][] result);
    public static Double[][] Outer(Int64[] a, Single[] b, Double[][] result);
    public static Int32[][] Outer(Int64[] a, Single[] b, Int32[][] result);
    public static Decimal[][] Outer(Decimal[] a, Decimal[] b, Decimal[][] result);
    public static Double[][] Outer(Decimal[] a, Decimal[] b, Double[][] result);
    public static Int32[][] Outer(Decimal[] a, Decimal[] b, Int32[][] result);
    public static Decimal[][] Outer(Decimal[] a, Double[] b, Decimal[][] result);
    public static Double[][] Outer(Decimal[] a, Double[] b, Double[][] result);
    public static Int32[][] Outer(Decimal[] a, Double[] b, Int32[][] result);
    public static Decimal[][] Outer(Decimal[] a, Int32[] b, Decimal[][] result);
    public static Int32[][] Outer(Decimal[] a, Int32[] b, Int32[][] result);
    public static Double[][] Outer(Decimal[] a, Int32[] b, Double[][] result);
    public static Decimal[][] Outer(Decimal[] a, Single[] b, Decimal[][] result);
    public static Single[][] Outer(Decimal[] a, Single[] b, Single[][] result);
    public static Double[][] Outer(Decimal[] a, Single[] b, Double[][] result);
    public static Int32[][] Outer(Decimal[] a, Single[] b, Int32[][] result);
    public static Byte[][] Outer(Byte[] a, Byte[] b, Byte[][] result);
    public static Double[][] Outer(Byte[] a, Byte[] b, Double[][] result);
    public static Int32[][] Outer(Byte[] a, Byte[] b, Int32[][] result);
    public static Byte[][] Outer(Byte[] a, Double[] b, Byte[][] result);
    public static Double[][] Outer(Byte[] a, Double[] b, Double[][] result);
    public static Int32[][] Outer(Byte[] a, Double[] b, Int32[][] result);
    public static Byte[][] Outer(Byte[] a, Int32[] b, Byte[][] result);
    public static Int32[][] Outer(Byte[] a, Int32[] b, Int32[][] result);
    public static Double[][] Outer(Byte[] a, Int32[] b, Double[][] result);
    public static Byte[][] Outer(Byte[] a, Single[] b, Byte[][] result);
    public static Single[][] Outer(Byte[] a, Single[] b, Single[][] result);
    public static Double[][] Outer(Byte[] a, Single[] b, Double[][] result);
    public static Int32[][] Outer(Byte[] a, Single[] b, Int32[][] result);
    public static Int16[][] Outer(Int16[] a, Int16[] b, Int16[][] result);
    public static Double[][] Outer(Int16[] a, Int16[] b, Double[][] result);
    public static Int32[][] Outer(Int16[] a, Int16[] b, Int32[][] result);
    public static Int16[][] Outer(Int16[] a, Double[] b, Int16[][] result);
    public static Double[][] Outer(Int16[] a, Double[] b, Double[][] result);
    public static Int32[][] Outer(Int16[] a, Double[] b, Int32[][] result);
    public static Int16[][] Outer(Int16[] a, Int32[] b, Int16[][] result);
    public static Int32[][] Outer(Int16[] a, Int32[] b, Int32[][] result);
    public static Double[][] Outer(Int16[] a, Int32[] b, Double[][] result);
    public static Int16[][] Outer(Int16[] a, Single[] b, Int16[][] result);
    public static Single[][] Outer(Int16[] a, Single[] b, Single[][] result);
    public static Double[][] Outer(Int16[] a, Single[] b, Double[][] result);
    public static Int32[][] Outer(Int16[] a, Single[] b, Int32[][] result);
    public static SByte[][] Outer(SByte[] a, SByte[] b, SByte[][] result);
    public static Double[][] Outer(SByte[] a, SByte[] b, Double[][] result);
    public static Int32[][] Outer(SByte[] a, SByte[] b, Int32[][] result);
    public static SByte[][] Outer(SByte[] a, Double[] b, SByte[][] result);
    public static Double[][] Outer(SByte[] a, Double[] b, Double[][] result);
    public static Int32[][] Outer(SByte[] a, Double[] b, Int32[][] result);
    public static SByte[][] Outer(SByte[] a, Int32[] b, SByte[][] result);
    public static Int32[][] Outer(SByte[] a, Int32[] b, Int32[][] result);
    public static Double[][] Outer(SByte[] a, Int32[] b, Double[][] result);
    public static SByte[][] Outer(SByte[] a, Single[] b, SByte[][] result);
    public static Single[][] Outer(SByte[] a, Single[] b, Single[][] result);
    public static Double[][] Outer(SByte[] a, Single[] b, Double[][] result);
    public static Int32[][] Outer(SByte[] a, Single[] b, Int32[][] result);
    public static Double[][] Random(int rows, int columns);
    public static Double[][] Random(int size);
    public static Int32[][] Random(int rows, int columns, int min, int max, Int32[][] result);
    public static Int32[][] Random(int size, int min, int max, bool symmetric, Int32[][] result);
    public static Int16[][] Random(int rows, int columns, short min, short max, Int16[][] result);
    public static Int16[][] Random(int size, short min, short max, bool symmetric, Int16[][] result);
    public static Byte[][] Random(int rows, int columns, byte min, byte max, Byte[][] result);
    public static Byte[][] Random(int size, byte min, byte max, bool symmetric, Byte[][] result);
    public static SByte[][] Random(int rows, int columns, sbyte min, sbyte max, SByte[][] result);
    public static SByte[][] Random(int size, sbyte min, sbyte max, bool symmetric, SByte[][] result);
    public static Int64[][] Random(int rows, int columns, long min, long max, Int64[][] result);
    public static Int64[][] Random(int size, long min, long max, bool symmetric, Int64[][] result);
    public static UInt64[][] Random(int rows, int columns, ulong min, ulong max, UInt64[][] result);
    public static UInt64[][] Random(int size, ulong min, ulong max, bool symmetric, UInt64[][] result);
    public static UInt16[][] Random(int rows, int columns, ushort min, ushort max, UInt16[][] result);
    public static UInt16[][] Random(int size, ushort min, ushort max, bool symmetric, UInt16[][] result);
    public static Single[][] Random(int rows, int columns, float min, float max, Single[][] result);
    public static Single[][] Random(int size, float min, float max, bool symmetric, Single[][] result);
    public static Double[][] Random(int rows, int columns, double min, double max, Double[][] result);
    public static Double[][] Random(int size, double min, double max, bool symmetric, Double[][] result);
    public static Decimal[][] Random(int rows, int columns, decimal min, decimal max, Decimal[][] result);
    public static Decimal[][] Random(int size, decimal min, decimal max, bool symmetric, Decimal[][] result);
}
public class Accord.Math.JaggedReducedRowEchelonForm : object {
    private Double[][] rref;
    private int rows;
    private int cols;
    private Int32[] pivot;
    private Nullable`1<int> freeCount;
    public Int32[] Pivot { get; }
    public Double[][] Result { get; }
    public int FreeVariables { get; }
    public JaggedReducedRowEchelonForm(Double[][] value, bool inPlace);
    public Int32[] get_Pivot();
    public Double[][] get_Result();
    public int get_FreeVariables();
    private int count();
}
[SerializableAttribute]
public class Accord.Math.Kinematics.DenavitHartenbergJoint : object {
    [CompilerGeneratedAttribute]
private DenavitHartenbergMatrix <Matrix>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private DenavitHartenbergParameters <Parameters>k__BackingField;
    public DenavitHartenbergMatrix Matrix { get; private set; }
    public Vector3 Position { get; public set; }
    public DenavitHartenbergParameters Parameters { get; public set; }
    public DenavitHartenbergJoint(DenavitHartenbergParameters parameters);
    public DenavitHartenbergJoint(double alpha, double theta, double radius, double offset);
    [CompilerGeneratedAttribute]
public DenavitHartenbergMatrix get_Matrix();
    [CompilerGeneratedAttribute]
private void set_Matrix(DenavitHartenbergMatrix value);
    [CompilerGeneratedAttribute]
public Vector3 get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(Vector3 value);
    [CompilerGeneratedAttribute]
public DenavitHartenbergParameters get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(DenavitHartenbergParameters value);
    public Matrix4x4 Compute(Matrix4x4 transformMatrix, Vector4 referencePosition);
}
[SerializableAttribute]
public class Accord.Math.Kinematics.DenavitHartenbergJointCollection : List`1<DenavitHartenbergJoint> {
    public void Add(DenavitHartenbergParameters parameters);
    public void Add(double alpha, double theta, double radius, double offset);
}
public class Accord.Math.Kinematics.DenavitHartenbergMatrix : object {
    [CompilerGeneratedAttribute]
private Matrix4x4 <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix4x4 <X>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix4x4 <Z>k__BackingField;
    public Matrix4x4 Transform { get; public set; }
    public Matrix4x4 X { get; public set; }
    public Matrix4x4 Z { get; public set; }
    [CompilerGeneratedAttribute]
public Matrix4x4 get_Transform();
    [CompilerGeneratedAttribute]
public void set_Transform(Matrix4x4 value);
    [CompilerGeneratedAttribute]
public Matrix4x4 get_X();
    [CompilerGeneratedAttribute]
public void set_X(Matrix4x4 value);
    [CompilerGeneratedAttribute]
public Matrix4x4 get_Z();
    [CompilerGeneratedAttribute]
public void set_Z(Matrix4x4 value);
    public void Compute(DenavitHartenbergParameters parameters);
}
[SerializableAttribute]
public class Accord.Math.Kinematics.DenavitHartenbergModel : object {
    [NonSerializedAttribute]
private Matrix4x4 transformationMatrix;
    private DenavitHartenbergJointCollection joints;
    [NonSerializedAttribute]
private Vector3 position;
    public DenavitHartenbergJointCollection Joints { get; }
    public Vector3 Position { get; }
    public Matrix4x4 Transform { get; }
    public DenavitHartenbergModel(Vector3 position);
    public DenavitHartenbergJointCollection get_Joints();
    public Vector3 get_Position();
    public Matrix4x4 get_Transform();
    public void Compute();
    public void Compute(DenavitHartenbergModel parent);
    private void compute(Matrix4x4 currentMatrix, Vector3 position);
    public sealed virtual IEnumerator`1<DenavitHartenbergJoint> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[SerializableAttribute]
public class Accord.Math.Kinematics.DenavitHartenbergNode : object {
    [CompilerGeneratedAttribute]
private DenavitHartenbergNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private DenavitHartenbergModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private DenavitHartenbergNodeCollection <Children>k__BackingField;
    public DenavitHartenbergNode Parent { get; internal set; }
    public DenavitHartenbergModel Model { get; public set; }
    public DenavitHartenbergNodeCollection Children { get; private set; }
    public DenavitHartenbergNode(DenavitHartenbergModel model);
    [CompilerGeneratedAttribute]
public DenavitHartenbergNode get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(DenavitHartenbergNode value);
    [CompilerGeneratedAttribute]
public DenavitHartenbergModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(DenavitHartenbergModel value);
    [CompilerGeneratedAttribute]
public DenavitHartenbergNodeCollection get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(DenavitHartenbergNodeCollection value);
    public void Compute();
}
[SerializableAttribute]
public class Accord.Math.Kinematics.DenavitHartenbergNodeCollection : Collection`1<DenavitHartenbergNode> {
    [CompilerGeneratedAttribute]
private DenavitHartenbergNode <Owner>k__BackingField;
    public DenavitHartenbergNode Owner { get; private set; }
    public DenavitHartenbergNodeCollection(DenavitHartenbergNode owner);
    [CompilerGeneratedAttribute]
public DenavitHartenbergNode get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(DenavitHartenbergNode value);
    public void Add(DenavitHartenbergModel child);
    protected virtual void InsertItem(int index, DenavitHartenbergNode item);
}
[SerializableAttribute]
public class Accord.Math.Kinematics.DenavitHartenbergParameters : object {
    [CompilerGeneratedAttribute]
private double <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Theta>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Radius>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Offset>k__BackingField;
    public double Alpha { get; public set; }
    public double Theta { get; public set; }
    public double Radius { get; public set; }
    public double Offset { get; public set; }
    public DenavitHartenbergParameters(double alpha, double theta, double radius, double offset);
    [CompilerGeneratedAttribute]
public double get_Alpha();
    [CompilerGeneratedAttribute]
public void set_Alpha(double value);
    [CompilerGeneratedAttribute]
public double get_Theta();
    [CompilerGeneratedAttribute]
public void set_Theta(double value);
    [CompilerGeneratedAttribute]
public double get_Radius();
    [CompilerGeneratedAttribute]
public void set_Radius(double value);
    [CompilerGeneratedAttribute]
public double get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(double value);
}
[ExtensionAttribute]
[GeneratedCodeAttribute("Accord.NET T4 Templates", "3.6")]
public static class Accord.Math.Matrix : object {
    [ExtensionAttribute]
public static T[][] Transpose(IList`1<T[]> matrix);
    [ExtensionAttribute]
public static TItem[][] Transpose(TCollection matrix);
    [ExtensionAttribute]
public static T[][] Transpose(T[][] matrix);
    [ExtensionAttribute]
public static T[][] Transpose(T[][] matrix, bool inPlace);
    [ExtensionAttribute]
public static T[][] Transpose(T[] rowVector, T[][]& result);
    [ExtensionAttribute]
public static T[][] Transpose(T[] rowVector, T[][] result);
    [ExtensionAttribute]
public static int Rows(T[][] matrix);
    [ExtensionAttribute]
public static int Columns(T[][] matrix);
    [ExtensionAttribute]
public static int Columns(IEnumerable`1<T[]> matrix);
    [ExtensionAttribute]
public static int Columns(T[][] matrix, bool max);
    [ExtensionAttribute]
public static bool IsUpperTriangular(T[][] matrix);
    [ExtensionAttribute]
public static bool IsLowerTriangular(T[][] matrix);
    [ExtensionAttribute]
public static T[][] GetLowerTriangle(T[][] matrix, bool includeDiagonal);
    [ExtensionAttribute]
public static T[][] GetUpperTriangle(T[][] matrix, bool includeDiagonal);
    [ExtensionAttribute]
public static T[][] GetSymmetric(T[][] matrix, MatrixType type, T[][] result);
    [ExtensionAttribute]
public static bool IsDiagonal(T[][] matrix);
    [ExtensionAttribute]
public static float Trace(Single[][] matrix);
    [ExtensionAttribute]
public static T[] Diagonal(T[][] matrix);
    [ExtensionAttribute]
public static bool IsPositiveDefinite(Double[][] matrix);
    public static bool IsRectangular(T[][] matrix);
    [ExtensionAttribute]
public static bool IsRectangular(IEnumerable`1<T[]> matrix);
    public static TResult[][] Apply(TInput[][] matrix, Func`2<TInput, TResult> func);
    [ExtensionAttribute]
public static TResult[][] Apply(TInput[][] matrix, Func`4<TInput, int, int, TResult> func);
    [ExtensionAttribute]
public static TResult[][] Apply(TInput[][] matrix, Func`2<TInput, TResult> func, TResult[][] result);
    [ExtensionAttribute]
public static TResult[][] Apply(TInput[][] matrix, Func`4<TInput, int, int, TResult> func, TResult[][] result);
    [ExtensionAttribute]
public static T[][] MemberwiseClone(T[][] a);
    [ExtensionAttribute]
public static T[][] Copy(T[][] a);
    [ExtensionAttribute]
public static void CopyTo(T[][] matrix, T[][] destination, bool transpose);
    [ExtensionAttribute]
public static void CopyTo(T[] vector, T[] destination);
    [ExtensionAttribute]
public static void CopyTo(T[][] matrix, T[0...,0...] destination);
    internal static int GetLength(T[][] values, int dimension);
    internal static int GetLength(T[0...,0...] values, int dimension);
    [ExtensionAttribute]
public static Tuple`2<int, int> ArgMax(T[][] matrix);
    [ExtensionAttribute]
public static Int32[] ArgMax(T[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] ArgMax(T[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Tuple`2<int, int> ArgMin(T[][] matrix);
    [ExtensionAttribute]
public static Int32[] ArgMin(T[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] ArgMin(T[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static T Max(T[][] matrix);
    [ExtensionAttribute]
public static T Min(T[][] matrix);
    [ExtensionAttribute]
public static T[] Min(T[][] matrix, int dimension);
    [ExtensionAttribute]
public static T[] Max(T[][] matrix, int dimension);
    [ExtensionAttribute]
public static T[] Max(T[][] matrix, int dimension, T[] result);
    [ExtensionAttribute]
public static T[] Min(T[][] matrix, int dimension, T[] result);
    [ExtensionAttribute]
public static T[] Min(T[][] matrix, int dimension, Int32[]& indices);
    [ExtensionAttribute]
public static T[] Max(T[][] matrix, int dimension, Int32[]& indices);
    [ExtensionAttribute]
public static T[] Max(T[][] matrix, int dimension, Int32[]& indices, T[] result);
    [ExtensionAttribute]
public static T[] Min(T[][] matrix, int dimension, Int32[]& indices, T[] result);
    [ExtensionAttribute]
public static T Max(T[][] matrix, Tuple`2& imax);
    [ExtensionAttribute]
public static T Min(T[][] matrix, Tuple`2& imin);
    [ExtensionAttribute]
public static T[] Max(T[][] matrix, int dimension, Int32[] indices, T[] result);
    [ExtensionAttribute]
public static T[] Min(T[][] matrix, int dimension, Int32[] indices, T[] result);
    [ExtensionAttribute]
public static void GetRange(T[][] values, T& min, T& max);
    [ExtensionAttribute]
public static DoubleRange[] GetRange(Double[][] value, int dimension);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use GetRange instead.")]
public static DoubleRange[] Range(Double[][] value, int dimension);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Double[0...,0...] Multiply(Double[0...,0...] a, Double[0...,0...] b);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Double[][] Multiply(Double[][] a, Double[][] b);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Single[][] Multiply(Single[][] a, Single[][] b);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Double[][] Multiply(Single[][] a, Double[][] b);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Single[0...,0...] Multiply(Single[0...,0...] a, Single[0...,0...] b);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static void Multiply(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static void Multiply(Double[][] a, Double[][] b, Double[][] result);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static void Multiply(Double[0...,0...] a, Double[0...,0...] b, Double[][] result);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static void Multiply(Single[][] a, Single[][] b, Single[][] result);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static void Multiply(Single[][] a, Double[][] b, Double[][] result);
    [ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static void Multiply(Single[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithTranspose(a, b) method instead.")]
public static Double[0...,0...] MultiplyByTranspose(Double[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithTranspose(a, b) method instead.")]
public static Single[0...,0...] MultiplyByTranspose(Single[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithTranspose(a, b) method instead.")]
public static void MultiplyByTranspose(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithTranspose(a, b) method instead.")]
public static void MultiplyByTranspose(Single[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the TransposeAndDot(a, b) method instead.")]
public static Double[0...,0...] TransposeAndMultiply(Double[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the TransposeAndDot(a, b) method instead.")]
public static Double[][] TransposeAndMultiply(Double[][] a, Double[][] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the TransposeAndDot(a, b) method instead.")]
public static void TransposeAndMultiply(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the TransposeAndDot(a, b) method instead.")]
public static void TransposeAndMultiply(Double[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the TransposeAndDot(a, b) method instead.")]
public static Double[] TransposeAndMultiply(Double[0...,0...] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the TransposeAndDot(a, b) method instead.")]
public static void TransposeAndMultiply(Double[0...,0...] a, Double[] b, Double[] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the TransposeAndDotWithDiagonal(a, b) method instead.")]
public static Double[0...,0...] TransposeAndMultiplyByDiagonal(Double[0...,0...] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the TransposeAndDotWithDiagonal(a, b) method instead.")]
public static void TransposeAndMultiplyByDiagonal(Double[0...,0...] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithDiagonal(a, b) method instead.")]
public static Double[][] MultiplyByDiagonal(Double[][] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithDiagonal(a, b) method instead.")]
public static Single[][] MultiplyByDiagonal(Single[][] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithDiagonal(a, b) method instead.")]
public static Double[0...,0...] MultiplyByDiagonal(Double[0...,0...] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithDiagonal(a, b) method instead.")]
public static void MultiplyByDiagonal(Double[0...,0...] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithDiagonal(a, b) method instead.")]
public static void MultiplyByDiagonal(Double[][] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithDiagonal(a, b) method instead.")]
public static void MultiplyByDiagonal(Single[][] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithDiagonal(a, b) method instead.")]
public static Single[0...,0...] MultiplyByDiagonal(Single[0...,0...] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the DotWithDiagonal(a, b) method instead.")]
public static void MultiplyByDiagonal(Single[0...,0...] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Double[] Multiply(Double[] rowVector, Double[0...,0...] matrix);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Single[] Multiply(Single[] rowVector, Single[0...,0...] matrix);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Double[] Multiply(Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Single[] Multiply(Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Double[] Multiply(Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static Single[] Multiply(Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static double InnerProduct(Double[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Dot(a, b) method instead.")]
public static float InnerProduct(Single[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Outer(a, b) method instead.")]
public static Double[0...,0...] OuterProduct(Double[] a, Double[] b);
    [ObsoleteAttribute("Please use the Cross(a, b) method instead.")]
public static Double[] VectorProduct(Double[] a, Double[] b);
    [ObsoleteAttribute("Please use the Cross(a, b) method instead.")]
public static Single[] VectorProduct(Single[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Cartesian(sequences) method instead.")]
public static IEnumerable`1<IEnumerable`1<T>> CartesianProduct(IEnumerable`1<IEnumerable`1<T>> sequences);
    [ObsoleteAttribute("Please use the Cartesian(sequences) method instead.")]
public static T[][] CartesianProduct(T[][] sequences);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Cartesian(a, b) method instead.")]
public static T[][] CartesianProduct(T[] sequence1, T[] sequence2);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Konecker(a, b) method instead.")]
public static Double[0...,0...] KroneckerProduct(Double[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Konecker(a, b) method instead.")]
public static Double[] KroneckerProduct(Double[] a, Double[] b);
    [ObsoleteAttribute("Please use the Elementwise.Add(a, b) method instead.")]
public static Double[0...,0...] Add(Double[0...,0...] matrix, Double[] vector, int dimension);
    [ObsoleteAttribute("Please use the Elementwise.AddToDiagonal(a, b) method instead.")]
public static Double[0...,0...] AddToDiagonal(Double[0...,0...] matrix, double scalar, bool inPlace);
    [ObsoleteAttribute("Please use the Elementwise.AddToDiagonal(a, b) method instead.")]
public static Double[][] AddToDiagonal(Double[][] matrix, double scalar, bool inPlace);
    [ObsoleteAttribute("Please use the Elementwise.SubtractFromDiagonal(a, b) method instead.")]
public static Double[][] SubtractFromDiagonal(Double[][] matrix, double scalar, bool inPlace);
    [ExtensionAttribute]
public static Double[] Normalize(Double[] vector, Func`2<Double[], double> norm, bool inPlace);
    [ExtensionAttribute]
public static Single[] Normalize(Single[] vector, Func`2<Single[], float> norm, bool inPlace);
    [ExtensionAttribute]
public static Double[] Normalize(Double[] vector, bool inPlace);
    [ExtensionAttribute]
public static Single[] Normalize(Single[] vector, bool inPlace);
    [ExtensionAttribute]
public static Double[0...,0...] Power(Double[0...,0...] matrix, int n);
    [ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> Cartesian(IEnumerable`1<IEnumerable`1<T>> sequences);
    public static T[][] Cartesian(T[][] sequences);
    [ExtensionAttribute]
public static T[][] Cartesian(T[] sequence1, T[] sequence2);
    [ExtensionAttribute]
public static bool IsJagged(Type type);
    [ExtensionAttribute]
public static Type GetInnerMostType(Array array);
    [ExtensionAttribute]
public static int GetNumberOfBytes(Array array);
    [ExtensionAttribute]
public static bool IsInteger(double x, double threshold);
    [ExtensionAttribute]
[ObsoleteAttribute("Use IsEqual(a, b, rtol) with the named parameter rtol instead.")]
public static bool IsRelativelyEqual(double a, double b, double threshold);
    [ExtensionAttribute]
public static bool IsEqual(object objA, object objB, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Array objA, Array objB, double atol, double rtol);
    public static bool Equals(object value);
    [ExtensionAttribute]
public static bool DimensionEquals(Array a, Array b);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> list1, IEnumerable`1<T> list2);
    [ExtensionAttribute]
public static bool HasNaN(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static bool HasNaN(Double[] matrix);
    [ExtensionAttribute]
public static bool HasNaN(Double[][] matrix);
    [ExtensionAttribute]
public static bool HasInfinity(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static bool Has(Double[0...,0...] matrix, double value, double tolerance);
    [ExtensionAttribute]
public static bool Has(Single[0...,0...] matrix, float value, double tolerance);
    [ExtensionAttribute]
public static bool HasInfinity(Double[] matrix);
    [ExtensionAttribute]
public static bool HasInfinity(Double[][] matrix);
    [ExtensionAttribute]
public static T[0...,0...] Transpose(T[0...,0...] matrix);
    [ExtensionAttribute]
public static T[0...,0...] Transpose(T[0...,0...] matrix, bool inPlace);
    [ExtensionAttribute]
public static T[0...,0...] Transpose(T[] rowVector);
    [ExtensionAttribute]
public static T[0...,0...] Transpose(T[] rowVector, T[0...,0...] result);
    [ExtensionAttribute]
public static Array Transpose(Array array);
    [ExtensionAttribute]
public static Array Transpose(Array array, Int32[] order);
    [ExtensionAttribute]
public static T Transpose(T array, Int32[] order);
    private static Array transpose(Array array, Int32[] order);
    [ExtensionAttribute]
public static int GetNumberOfElements(T[] value);
    [ExtensionAttribute]
public static int GetNumberOfElements(T[][] value);
    [ExtensionAttribute]
public static int GetNumberOfElements(T[0...,0...] elements);
    [ExtensionAttribute]
public static int GetSizeInBytes(T[] elements);
    [ExtensionAttribute]
public static int GetSizeInBytes(T[][] elements);
    [ExtensionAttribute]
public static int GetSizeInBytes(T[0...,0...] elements);
    [ExtensionAttribute]
public static int Rows(T[] vector);
    [ExtensionAttribute]
public static int Rows(T[0...,0...] matrix);
    [ExtensionAttribute]
public static int Columns(T[0...,0...] matrix);
    [ExtensionAttribute]
public static bool IsSorted(T[] values);
    [ExtensionAttribute]
public static bool IsSorted(T[] values, ComparerDirection direction);
    [ExtensionAttribute]
public static bool IsSquare(T[][] matrix);
    [ExtensionAttribute]
public static bool IsSquare(T[0...,0...] matrix);
    [ExtensionAttribute]
public static bool IsUpperTriangular(T[0...,0...] matrix);
    [ExtensionAttribute]
public static bool IsLowerTriangular(T[0...,0...] matrix);
    [ExtensionAttribute]
public static T[0...,0...] ToLowerTriangular(T[0...,0...] matrix, MatrixType from, T[0...,0...] result);
    [ExtensionAttribute]
public static T[0...,0...] ToUpperTriangular(T[0...,0...] matrix, MatrixType from, T[0...,0...] result);
    [ExtensionAttribute]
public static T[][] ToLowerTriangular(T[][] matrix, MatrixType from, T[][] result);
    [ExtensionAttribute]
public static T[][] ToUpperTriangular(T[][] matrix, MatrixType from, T[][] result);
    [ExtensionAttribute]
public static T[0...,0...] GetLowerTriangle(T[0...,0...] matrix, bool includeDiagonal);
    [ExtensionAttribute]
public static T[0...,0...] GetUpperTriangle(T[0...,0...] matrix, bool includeDiagonal);
    [ExtensionAttribute]
public static T[0...,0...] GetSymmetric(T[0...,0...] matrix, MatrixType type, T[0...,0...] result);
    [ExtensionAttribute]
public static bool IsDiagonal(T[0...,0...] matrix);
    [ExtensionAttribute]
public static double Trace(Double[0...,0...] matrix);
    public static double Trace(Double[0...,0...] matrixA, Double[0...,0...] matrixB);
    [ExtensionAttribute]
public static int Trace(Int32[0...,0...] matrix);
    [ExtensionAttribute]
public static float Trace(Single[0...,0...] matrix);
    [ExtensionAttribute]
public static T[] Diagonal(T[0...,0...] matrix);
    [ExtensionAttribute]
public static double Determinant(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static double Determinant(Double[0...,0...] matrix, bool symmetric);
    [ExtensionAttribute]
public static double LogDeterminant(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static double LogDeterminant(Double[0...,0...] matrix, bool symmetric);
    [ExtensionAttribute]
public static double PseudoDeterminant(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static double PseudoDeterminant(Double[][] matrix);
    [ExtensionAttribute]
public static double LogPseudoDeterminant(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static double LogPseudoDeterminant(Double[][] matrix);
    [ExtensionAttribute]
public static int Rank(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static int Rank(Single[0...,0...] matrix);
    [ExtensionAttribute]
public static bool IsSingular(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static bool IsPositiveDefinite(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static TResult[] Apply(TInput[] vector, Func`2<TInput, TResult> func);
    [ExtensionAttribute]
public static TResult[] Apply(TInput[] vector, Func`3<TInput, int, TResult> func);
    [ExtensionAttribute]
public static TResult[] Apply(TInput[] vector, Func`2<TInput, TResult> func, TResult[] result);
    [ExtensionAttribute]
public static TResult[] Apply(TInput[] vector, Func`3<TInput, int, TResult> func, TResult[] result);
    [ExtensionAttribute]
public static TResult[0...,0...] Apply(TInput[0...,0...] matrix, Func`2<TInput, TResult> func);
    [ExtensionAttribute]
public static TResult[0...,0...] Apply(TInput[0...,0...] matrix, Func`4<TInput, int, int, TResult> func);
    [ExtensionAttribute]
public static TResult[0...,0...] Apply(TInput[0...,0...] matrix, Func`2<TInput, TResult> func, TResult[0...,0...] result);
    [ExtensionAttribute]
public static TResult[0...,0...] Apply(TInput[0...,0...] matrix, Func`4<TInput, int, int, TResult> func, TResult[0...,0...] result);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Apply passing a result parameter instead.")]
public static void ApplyInPlace(T[] vector, Func`2<T, T> func);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Apply passing a result parameter instead.")]
public static void ApplyInPlace(T[0...,0...] matrix, Func`2<T, T> func);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Apply passing a result parameter instead.")]
public static void ApplyInPlace(T[0...,0...] matrix, Func`4<T, int, int, T> func);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Apply passing a result parameter instead.")]
public static T[] ApplyInPlace(T[] vector, Func`3<T, int, T> func);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Apply passing a result parameter instead.")]
public static TResult[] ApplyWithIndex(TData[] vector, Func`3<TData, int, TResult> func);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Apply passing a result parameter instead.")]
public static TResult[0...,0...] ApplyWithIndex(TData[0...,0...] matrix, Func`4<TData, int, int, TResult> func);
    [ExtensionAttribute]
public static TResult[] Apply(IList`1<TData> vector, Func`2<TData, TResult> func);
    [ExtensionAttribute]
public static TResult[] Apply(IList`1<TData> vector, Func`2<TData, TResult> func, TResult[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Round(Double[0...,0...] matrix, int decimals);
    [ExtensionAttribute]
public static Double[0...,0...] Floor(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[0...,0...] Ceiling(Double[0...,0...] matrix);
    public static Double[] Round(Double[] vector, int decimals);
    public static Double[] Floor(Double[] vector);
    public static Double[] Ceiling(Double[] vector);
    [ExtensionAttribute]
public static Array DeepFlatten(Array array);
    [ExtensionAttribute]
public static T[] Flatten(T[0...,0...] matrix, MatrixOrder order);
    [ExtensionAttribute]
public static T[] Flatten(T[0...,0...] matrix, T[] result, MatrixOrder order);
    [ExtensionAttribute]
public static T[] Flatten(T[][] array, MatrixOrder order);
    [ExtensionAttribute]
public static T[] Flatten(T[][] array, T[] result, MatrixOrder order);
    [ExtensionAttribute]
public static T[] Reshape(T[0...,0...] matrix, MatrixOrder order);
    [ExtensionAttribute]
public static T[] Reshape(T[0...,0...] matrix, T[] result, MatrixOrder order);
    [ExtensionAttribute]
public static T[] Reshape(T[][] array, MatrixOrder order);
    [ExtensionAttribute]
public static T[] Reshape(T[][] array, T[] result, MatrixOrder order);
    [ExtensionAttribute]
public static Double[] Convolve(Double[] a, Double[] kernel);
    [ExtensionAttribute]
public static Double[] Convolve(Double[] a, Double[] kernel, bool trim);
    [ExtensionAttribute]
public static T[0...,0...] MemberwiseClone(T[0...,0...] a);
    [ExtensionAttribute]
public static T[] MemberwiseClone(T[] a);
    [ExtensionAttribute]
public static T[0...,0...] Copy(T[0...,0...] a);
    [ExtensionAttribute]
public static void CopyTo(T[0...,0...] matrix, T[0...,0...] destination, bool transpose);
    [ExtensionAttribute]
public static void CopyTo(T[0...,0...] matrix, T[][] destination, bool transpose);
    [ExtensionAttribute]
public static void CopyTo(T[0...,0...] matrix, T[][] destination);
    [ExtensionAttribute]
public static void SetTo(T[] destination, T[] matrix);
    [ExtensionAttribute]
public static void SetTo(T[] destination, T value);
    [ExtensionAttribute]
public static void SetTo(T[0...,0...] destination, T[0...,0...] matrix);
    [ExtensionAttribute]
public static void SetTo(T[0...,0...] destination, T[][] matrix);
    [ExtensionAttribute]
public static void SetTo(T[][] destination, T[0...,0...] matrix);
    [ExtensionAttribute]
public static void SetTo(T[0...,0...] destination, T value);
    [ExtensionAttribute]
public static void SetTo(T[][] destination, T value);
    [ExtensionAttribute]
public static void Clear(Array array);
    [ExtensionAttribute]
public static void Clear(T[][] array);
    [ExtensionAttribute]
public static T Replace(T array, object from, object to);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, Int32[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int32[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, Int16[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Int16[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Int16[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Int16[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Int16[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, short b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, short b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, short b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int16[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int16[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int16[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, short b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, Byte[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Byte[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, Byte[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Byte[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, Byte[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, byte b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, byte b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, byte b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Byte[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Byte[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, Byte[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, byte b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, SByte[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, SByte[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, SByte[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, SByte[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, SByte[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[] a, sbyte b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[0...,0...] a, sbyte b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int32[][] a, sbyte b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, SByte[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, SByte[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, SByte[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(int a, sbyte b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, Int32[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int32[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, Int16[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int16[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, Byte[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Byte[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, Byte[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Byte[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, Byte[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, byte b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, byte b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, byte b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Byte[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Byte[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, Byte[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, byte b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, SByte[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, SByte[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, SByte[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, SByte[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, SByte[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[] a, sbyte b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[0...,0...] a, sbyte b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int16[][] a, sbyte b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, SByte[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, SByte[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, SByte[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(short a, sbyte b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, Int32[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Int32[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Int32[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Int32[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Int32[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, int b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, int b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, int b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int32[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int32[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int32[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, int b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, Int16[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Int16[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Int16[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Int16[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Int16[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, short b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, short b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, short b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int16[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int16[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int16[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, short b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, Int64[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Int64[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Int64[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Int64[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Int64[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, long b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, long b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, long b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int64[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int64[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Int64[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, long b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, Byte[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Byte[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, Byte[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Byte[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, Byte[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, byte b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, byte b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, byte b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Byte[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Byte[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, Byte[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, byte b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, SByte[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, SByte[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, SByte[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, SByte[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, SByte[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[] a, sbyte b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[0...,0...] a, sbyte b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Single[][] a, sbyte b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, SByte[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, SByte[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, SByte[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(float a, sbyte b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, Int32[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Int32[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Int32[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Int32[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Int32[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, int b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, int b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, int b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int32[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int32[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int32[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, int b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, Int16[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Int16[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Int16[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Int16[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Int16[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, short b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, short b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, short b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int16[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int16[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int16[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, short b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, Single[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Single[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Single[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Single[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Single[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, float b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, float b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, float b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Single[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Single[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Single[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, float b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, Int64[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Int64[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Int64[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Int64[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Int64[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, long b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, long b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, long b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int64[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int64[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Int64[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, long b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, Byte[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Byte[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, Byte[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Byte[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, Byte[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, byte b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, byte b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, byte b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Byte[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Byte[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, Byte[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, byte b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, SByte[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, SByte[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, SByte[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, SByte[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, SByte[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[] a, sbyte b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[0...,0...] a, sbyte b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Double[][] a, sbyte b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, SByte[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, SByte[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, SByte[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(double a, sbyte b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, Int32[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Int32[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Int32[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Int32[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Int32[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, int b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, int b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, int b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int32[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int32[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int32[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, int b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, Int16[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Int16[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Int16[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Int16[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Int16[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, short b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, short b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, short b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int16[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int16[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int16[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, short b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, Byte[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Byte[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, Byte[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Byte[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, Byte[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, byte b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, byte b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, byte b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Byte[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Byte[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, Byte[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, byte b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, SByte[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, SByte[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, SByte[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, SByte[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, SByte[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[] a, sbyte b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[0...,0...] a, sbyte b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Int64[][] a, sbyte b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, SByte[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, SByte[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, SByte[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(long a, sbyte b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, Int32[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Int32[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Int32[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Int32[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Int32[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, int b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, int b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, int b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int32[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int32[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int32[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, int b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, Int16[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Int16[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Int16[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Int16[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Int16[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, short b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, short b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, short b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int16[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int16[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int16[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, short b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, Single[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Single[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Single[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Single[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Single[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, float b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, float b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, float b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Single[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Single[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Single[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, float b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, Double[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Double[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Double[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Double[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Double[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, double b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, double b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, double b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Double[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Double[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Double[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, double b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, Int64[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Int64[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Int64[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Int64[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Int64[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, long b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, long b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, long b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int64[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int64[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Int64[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, long b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, Byte[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Byte[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, Byte[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Byte[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, Byte[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, byte b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, byte b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, byte b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Byte[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Byte[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, Byte[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, byte b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, SByte[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, SByte[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, SByte[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, SByte[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, SByte[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[] a, sbyte b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[0...,0...] a, sbyte b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Decimal[][] a, sbyte b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, SByte[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, SByte[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, SByte[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(decimal a, sbyte b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, Int32[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int32[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, Int16[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int16[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, Byte[] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Byte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, Byte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Byte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, Byte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, byte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, byte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, byte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Byte[] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Byte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, Byte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, byte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, SByte[] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, SByte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, SByte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, SByte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, SByte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[] a, sbyte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[0...,0...] a, sbyte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(Byte[][] a, sbyte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, SByte[] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, SByte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, SByte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(byte a, sbyte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, Int32[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int32[] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int32[0...,0...] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int32[][] b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, int b, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, Int16[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int16[] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int16[0...,0...] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int16[][] b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, short b, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Single[] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Single[0...,0...] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Single[][] b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, float b, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Double[] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Double[0...,0...] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Double[][] b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, double b, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int64[] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int64[0...,0...] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Int64[][] b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, long b, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Decimal[] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Decimal[0...,0...] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Decimal[][] b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, decimal b, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, Byte[] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Byte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, Byte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Byte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, Byte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, byte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, byte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, byte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Byte[] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Byte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, Byte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, byte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, SByte[] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, SByte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, SByte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, SByte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, SByte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[] a, sbyte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[0...,0...] a, sbyte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(SByte[][] a, sbyte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, SByte[] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, SByte[0...,0...] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, SByte[][] b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsEqual(sbyte a, sbyte b, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Int32[][] a, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Int32[0...,0...] a, int atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Int16[][] a, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Int16[0...,0...] a, short atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Single[][] a, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Single[0...,0...] a, float atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Double[][] a, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Double[0...,0...] a, double atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Int64[][] a, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Int64[0...,0...] a, long atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Decimal[][] a, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Decimal[0...,0...] a, decimal atol, decimal rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Byte[][] a, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(Byte[0...,0...] a, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(SByte[][] a, byte atol, double rtol);
    [ExtensionAttribute]
public static bool IsSymmetric(SByte[0...,0...] a, byte atol, double rtol);
    public static T[0...,0...] Zeros(int rows, int columns);
    public static T[0...,0...,0...] Zeros(int rows, int columns, int depth);
    public static T[0...,0...] Ones(int rows, int columns);
    public static Double[0...,0...] Zeros(int rows, int columns);
    public static Double[0...,0...,0...] Zeros(int rows, int columns, int depth);
    public static Double[0...,0...] Ones(int rows, int columns);
    public static T[0...,0...] Create(int rows, int columns, T value);
    public static T[0...,0...] Create(int rows, int columns, T[0...,0...] values, bool transpose);
    public static T[0...,0...] Square(int size, T value);
    public static T[0...,0...] Create(int rows, int columns, T[] values);
    public static T[0...,0...] Create(T[][] rows);
    public static T[0...,0...] Create(T[0...,0...] values);
    public static T[0...,0...] OneHot(Int32[] indices);
    public static Double[0...,0...] OneHot(Int32[] indices);
    public static T[0...,0...] OneHot(Int32[] indices, int columns);
    public static Double[0...,0...] OneHot(Int32[] indices, int columns);
    public static T[0...,0...] OneHot(Int32[] indices, T[0...,0...] result);
    public static Double[0...,0...] OneHot(Int32[] indices, Double[0...,0...] result);
    public static T[0...,0...] KHot(Int32[][] indices, int columns);
    public static Double[0...,0...] KHot(Int32[][] indices, int columns);
    public static T[0...,0...] KHot(Int32[][] indices, T[0...,0...] result);
    public static Double[0...,0...] KHot(Int32[][] indices, Double[0...,0...] result);
    public static T[0...,0...] CreateAs(T[0...,0...] matrix);
    public static T[0...,0...] CreateAs(T[][] matrix);
    public static TOutput[0...,0...] CreateAs(TInput[0...,0...] matrix);
    public static TOutput[0...,0...] CreateAs(TInput[][] matrix);
    public static T[0...,0...] Diagonal(int size, T value);
    public static T[0...,0...] Diagonal(int size, T value, T[0...,0...] result);
    public static T[0...,0...] Diagonal(int rows, int cols, T value);
    public static T[0...,0...] Diagonal(int rows, int cols, T value, T[0...,0...] result);
    public static T[0...,0...] Diagonal(T[] values);
    public static T[0...,0...] Diagonal(T[] values, T[0...,0...] result);
    public static T[0...,0...] Diagonal(int size, T[] values);
    public static T[0...,0...] Diagonal(int size, T[] values, T[0...,0...] result);
    public static T[0...,0...] Diagonal(int rows, int cols, T[] values);
    public static T[0...,0...] Diagonal(int rows, int cols, T[] values, T[0...,0...] result);
    [ObsoleteAttribute("Please use Jagged.Diagonal instead.")]
public static T[][] JaggedDiagonal(T[] values);
    [ObsoleteAttribute("Please use Jagged.Diagonal instead.")]
public static T[][] JaggedDiagonal(int size, T value);
    public static T[0...,0...] Diagonal(T[0...,0...][] blocks);
    public static Double[0...,0...] Identity(int size);
    public static T[0...,0...] Identity(int size);
    [ObsoleteAttribute("Please use Jagged.Identity instead.")]
public static Double[][] JaggedIdentity(int size);
    [ObsoleteAttribute("Please use Jagged.Magic instead.")]
public static Double[][] JaggedMagic(int size);
    public static Double[0...,0...] Magic(int size);
    public static Double[0...,0...] Centering(int size);
    public static T[0...,0...] Random(int size, IRandomNumberGenerator`1<T> generator, bool symmetric, T[0...,0...] result);
    public static T[0...,0...] Random(int rows, int cols, IRandomNumberGenerator`1<T> generator, T[0...,0...] result);
    [ObsoleteAttribute("Please use INumberGenerator<T> instead.")]
public static Double[0...,0...] Random(int rows, int cols, IRandomNumberGenerator generator);
    [ObsoleteAttribute("Please use Vector.Random instead.")]
public static Single[] Random(int size, float minValue, float maxValue);
    [ObsoleteAttribute("Please use Vector.Random instead.")]
public static Double[] Random(int size, double minValue, double maxValue);
    [ObsoleteAttribute("Please use Vector.Random instead.")]
public static Double[] Random(int size, IRandomNumberGenerator generator);
    public static T[0...,0...] RowVector(T[] values);
    public static T[0...,0...] ColumnVector(T[] values);
    [ObsoleteAttribute("Please use Vector.Create instead.")]
public static T[] Vector(int n, T[] values);
    [ObsoleteAttribute("Please use Vector.Create instead.")]
public static T[] Vector(int n, T value);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Double[] Vector(double a, double b, double increment);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Int32[] Vector(int a, int b, int increment);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Double[] Vector(double a, double b, int points);
    [ObsoleteAttribute("Please use Vector.Range instead.")]
public static Int32[] Indices(int from, int to);
    [ObsoleteAttribute("Please use Vector.Range instead.")]
public static Int32[] Indices(int to);
    [ExtensionAttribute]
public static int GetTotalLength(Array array, bool deep, bool rectangular);
    [ExtensionAttribute]
public static Int32[] GetLength(Array array, bool deep, bool max);
    [ExtensionAttribute]
public static Array Trim(Array array);
    [ExtensionAttribute]
public static bool IsJagged(Array array);
    [ExtensionAttribute]
public static bool IsMatrix(Array array);
    [ExtensionAttribute]
public static bool IsVector(Array array);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Int32[] Interval(int from, int to);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Double[] Interval(DoubleRange range, double stepSize);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Double[] Interval(double from, double to, double stepSize);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Single[] Interval(float from, float to, double stepSize);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Double[] Interval(DoubleRange range, int steps);
    [ObsoleteAttribute("Please use Vector.Interval instead.")]
public static Double[] Interval(double from, double to, int steps);
    [ObsoleteAttribute("Please specify the number of steps instead of the step size for the rows and columns.")]
public static Double[][] Mesh(double rowMin, double rowMax, double rowStepSize, double colMin, double colMax, double colStepSize);
    public static Int32[][] Mesh(int rowMin, int rowMax, int colMin, int colMax);
    public static Double[][] Mesh(double rowMin, double rowMax, int rowSteps, double colMin, double colMax, int colSteps);
    public static Double[][] Mesh(DoubleRange rowRange, int rowSteps, DoubleRange colRange, int colSteps);
    [ObsoleteAttribute("Please specify the number of steps instead of the step size for the rows and columns.")]
public static Double[][] Mesh(DoubleRange rowRange, DoubleRange colRange, double rowStepSize, double colStepSize);
    [ExtensionAttribute]
public static T[][] Mesh(T[] x, T[] y);
    [ExtensionAttribute]
public static Tuple`2<T[0...,0...], T[0...,0...]> MeshGrid(T[] x, T[] y);
    [ExtensionAttribute]
public static T[] Concatenate(T[] a, T[] b);
    [ExtensionAttribute]
public static T[] Concatenate(T[] vector, T element);
    [ExtensionAttribute]
public static T[] Concatenate(T element, T[] vector);
    [ExtensionAttribute]
public static T[0...,0...] Concatenate(T[0...,0...] matrix, T[] vector);
    [ExtensionAttribute]
public static T[0...,0...] Concatenate(T[0...,0...] a, T[0...,0...] b);
    [ExtensionAttribute]
public static T[][] Concatenate(T[][] a, T[][] b);
    public static T[0...,0...] Concatenate(T[0...,0...][] matrices);
    public static T[][] Concatenate(T[][][] matrices);
    [ExtensionAttribute]
public static T[] Concatenate(T[][] vectors);
    [ExtensionAttribute]
public static T[0...,0...] Stack(T[] a, T[] b);
    [ExtensionAttribute]
public static T[][] Stack(T[][] a, T[][] b);
    public static T[0...,0...] Stack(T[][] vectors);
    public static T[0...,0...] Stack(T[] elements);
    [ExtensionAttribute]
public static T[0...,0...] Stack(T[] vector, T element);
    public static T[0...,0...] Stack(T[0...,0...][] matrices);
    [ExtensionAttribute]
public static T[0...,0...] Stack(T[0...,0...] matrix, T[] vector);
    public static T[][] Stack(T[][][] matrices);
    public static T[] Expand(T[] vector, Int32[] count);
    public static T[0...,0...] Expand(T[0...,0...] matrix, Int32[] count);
    [ExtensionAttribute]
public static T[][] Split(T[] vector, int size);
    [ExtensionAttribute]
public static T[] Merge(T[][] vectors, int size);
    [ExtensionAttribute]
public static T[] Merge(T[][] vectors);
    [ExtensionAttribute]
public static T[0...,0...] Pad(T[0...,0...] matrix, int all);
    [ExtensionAttribute]
public static T[0...,0...] Pad(T[0...,0...] matrix, int topBottom, int rightLeft);
    [ExtensionAttribute]
public static T[0...,0...] Pad(T[0...,0...] matrix, int top, int sides, int bottom);
    [ExtensionAttribute]
public static T[0...,0...] Pad(T[0...,0...] matrix, int top, int right, int bottom, int left);
    [ExtensionAttribute]
public static T[0...,0...] Reshape(T[] array, int rows, int cols, MatrixOrder order);
    [ExtensionAttribute]
public static T[0...,0...] Reshape(T[] array, int rows, int cols, T[0...,0...] result, MatrixOrder order);
    [ExtensionAttribute]
public static Array DeepToMatrix(Array array);
    [ExtensionAttribute]
public static T[0...,0...] ToMatrix(T[][] array, bool transpose);
    [ExtensionAttribute]
public static T[][] ToJagged(T[] array, bool asColumnVector);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use ToJagged() instead.")]
public static T[][] ToArray(T[] array, bool asColumnVector);
    [ExtensionAttribute]
public static T[0...,0...] ToMatrix(T[] array, bool asColumnVector);
    [ExtensionAttribute]
public static T[][] ToJagged(T[0...,0...] matrix, bool transpose);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use ToJagged() instead.")]
public static T[][] ToArray(T[0...,0...] matrix, bool transpose);
    [ExtensionAttribute]
public static TOutput[] Convert(TInput[] vector);
    [ExtensionAttribute]
public static object GetValue(Array array, bool deep, Int32[] indices);
    [ExtensionAttribute]
public static bool TryGetValue(Array array, bool deep, Int32[] indices, Object& value);
    [ExtensionAttribute]
public static void SetValue(Array array, object value, bool deep, Int32[] indices);
    [ExtensionAttribute]
public static IEnumerable`1<Int32[]> GetIndices(Array array, bool deep, bool max, MatrixOrder order);
    [ExtensionAttribute]
public static Int16[] ToInt16(Int32[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Int32[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Int32[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Int32[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(Int32[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Int32[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Int32[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Int32[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Int32[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Int32[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(Int32[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int32[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int32[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Int32[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(Int32[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int32[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int32[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int32[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Int32[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int32[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(Int32[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int32[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int32[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Int32[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(Int32[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int32[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int32[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int32[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Int32[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int32[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(Int32[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Int32[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Int32[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Int32[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(Int32[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Int32[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Int32[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Int32[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Int32[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Int32[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(Int32[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int32[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int32[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Int32[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(Int32[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int32[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int32[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int32[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Int32[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int32[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Int32[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int32[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int32[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Int32[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Int32[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int32[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int32[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int32[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Int32[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int32[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Int32[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int32[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int32[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Int32[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Int32[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int32[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int32[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int32[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Int32[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int32[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Int32[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int32[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int32[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Int32[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Int32[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int32[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int32[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int32[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Int32[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int32[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(Int32[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int32[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(Int32[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(Int32[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(Int32[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int32[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Int32[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Int32[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(Int32[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int32[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Int32[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int32[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Int32[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Int32[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Int32[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int32[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Int32[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Int32[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Int32[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int32[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(Int16[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Int16[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Int16[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Int16[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(Int16[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Int16[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Int16[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Int16[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Int16[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Int16[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(Int16[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int16[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int16[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Int16[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(Int16[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int16[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int16[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int16[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Int16[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int16[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(Int16[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int16[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int16[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Int16[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(Int16[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int16[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int16[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int16[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Int16[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int16[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(Int16[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Int16[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Int16[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Int16[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(Int16[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Int16[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Int16[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Int16[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Int16[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Int16[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(Int16[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int16[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int16[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Int16[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(Int16[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int16[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int16[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int16[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Int16[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int16[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Int16[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int16[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int16[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Int16[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Int16[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int16[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int16[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int16[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Int16[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int16[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Int16[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int16[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int16[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Int16[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Int16[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int16[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int16[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int16[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Int16[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int16[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Int16[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int16[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int16[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Int16[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Int16[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int16[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int16[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int16[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Int16[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int16[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(Int16[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int16[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(Int16[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(Int16[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(Int16[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int16[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Int16[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Int16[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(Int16[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int16[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Int16[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int16[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Int16[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Int16[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Int16[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int16[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Int16[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Int16[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Int16[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int16[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(Single[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Single[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Single[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Single[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(Single[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Single[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Single[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Single[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Single[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Single[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(Single[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Single[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Single[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Single[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(Single[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Single[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Single[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Single[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Single[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Single[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(Single[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Single[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(Single[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Single[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(Single[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Single[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Single[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Single[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Single[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Single[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(Single[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Single[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Single[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Single[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(Single[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Single[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Single[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Single[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Single[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Single[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(Single[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Single[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(Single[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Single[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(Single[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Single[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Single[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Single[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Single[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Single[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Single[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Single[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Single[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Single[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Single[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Single[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Single[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Single[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Single[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Single[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Single[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Single[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Single[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Single[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Single[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Single[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Single[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Single[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Single[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Single[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Single[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Single[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Single[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Single[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Single[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Single[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Single[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Single[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Single[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Single[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(Single[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Single[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(Single[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(Single[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(Single[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Single[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Single[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Single[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(Single[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Single[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Single[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Single[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Single[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Single[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Single[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Single[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Single[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Single[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Single[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Single[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(Double[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Double[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Double[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Double[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(Double[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Double[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Double[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Double[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Double[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Double[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(Double[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Double[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Double[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Double[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(Double[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Double[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Double[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Double[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Double[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Double[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(Double[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Double[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(Double[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Double[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(Double[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Double[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Double[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Double[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Double[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Double[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(Double[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Double[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Double[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Double[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(Double[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Double[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Double[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Double[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Double[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Double[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(Double[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Double[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(Double[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Double[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(Double[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Double[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Double[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Double[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Double[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Double[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Double[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Double[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Double[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Double[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Double[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Double[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Double[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Double[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Double[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Double[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Double[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Double[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Double[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Double[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Double[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Double[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Double[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Double[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Double[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Double[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Double[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Double[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Double[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Double[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Double[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Double[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Double[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Double[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Double[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Double[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(Double[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Double[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(Double[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(Double[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(Double[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Double[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Double[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Double[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(Double[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Double[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Double[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Double[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Double[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Double[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Double[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Double[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Double[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Double[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Double[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Double[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(Int64[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Int64[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Int64[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Int64[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(Int64[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Int64[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Int64[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Int64[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Int64[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Int64[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(Int64[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Int64[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Int64[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Int64[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(Int64[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Int64[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Int64[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Int64[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Int64[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Int64[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(Int64[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int64[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int64[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Int64[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(Int64[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int64[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int64[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Int64[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Int64[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Int64[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(Int64[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int64[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int64[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Int64[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(Int64[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int64[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int64[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Int64[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Int64[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Int64[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(Int64[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int64[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int64[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Int64[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(Int64[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int64[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int64[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Int64[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Int64[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Int64[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Int64[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int64[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int64[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Int64[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Int64[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int64[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int64[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Int64[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Int64[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Int64[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Int64[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int64[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int64[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Int64[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Int64[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int64[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int64[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Int64[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Int64[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Int64[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Int64[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int64[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int64[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Int64[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Int64[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int64[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int64[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Int64[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Int64[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Int64[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(Int64[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int64[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(Int64[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(Int64[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(Int64[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int64[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Int64[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Int64[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(Int64[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Int64[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Int64[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int64[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Int64[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Int64[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Int64[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int64[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Int64[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Int64[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Int64[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Int64[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(Byte[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Byte[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Byte[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Byte[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(Byte[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Byte[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Byte[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Byte[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Byte[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Byte[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(Byte[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Byte[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Byte[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Byte[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(Byte[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Byte[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Byte[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Byte[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Byte[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Byte[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(Byte[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Byte[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(Byte[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Byte[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(Byte[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Byte[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Byte[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Byte[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Byte[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Byte[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(Byte[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Byte[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(Byte[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Byte[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(Byte[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Byte[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Byte[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Byte[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Byte[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Byte[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(Byte[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Byte[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Byte[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Byte[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(Byte[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Byte[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Byte[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Byte[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Byte[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Byte[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Byte[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Byte[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Byte[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Byte[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Byte[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Byte[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Byte[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Byte[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Byte[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Byte[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Byte[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Byte[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Byte[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Byte[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Byte[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Byte[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Byte[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Byte[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Byte[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Byte[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Byte[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Byte[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Byte[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Byte[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Byte[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Byte[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Byte[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Byte[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Byte[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Byte[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(Byte[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Byte[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(Byte[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(Byte[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(Byte[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Byte[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Byte[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Byte[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(Byte[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Byte[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Byte[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Byte[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Byte[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Byte[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Byte[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Byte[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Byte[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Byte[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Byte[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Byte[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(SByte[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(SByte[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(SByte[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(SByte[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(SByte[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(SByte[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(SByte[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(SByte[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(SByte[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(SByte[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(SByte[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(SByte[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(SByte[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(SByte[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(SByte[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(SByte[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(SByte[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(SByte[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(SByte[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(SByte[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(SByte[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(SByte[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(SByte[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(SByte[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(SByte[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(SByte[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(SByte[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(SByte[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(SByte[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(SByte[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(SByte[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(SByte[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(SByte[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(SByte[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(SByte[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(SByte[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(SByte[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(SByte[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(SByte[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(SByte[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(SByte[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(SByte[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(SByte[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(SByte[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(SByte[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(SByte[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(SByte[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(SByte[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(SByte[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(SByte[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(SByte[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(SByte[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(SByte[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(SByte[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(SByte[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(SByte[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(SByte[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(SByte[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(SByte[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(SByte[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(SByte[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(SByte[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(SByte[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(SByte[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(SByte[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(SByte[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(SByte[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(SByte[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(SByte[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(SByte[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(SByte[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(SByte[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(SByte[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(SByte[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(SByte[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(SByte[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(SByte[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(SByte[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(SByte[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(SByte[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(SByte[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(SByte[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(SByte[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(SByte[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(SByte[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(SByte[][][] value);
    [ExtensionAttribute]
public static String[] ToString(SByte[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(SByte[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(SByte[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(SByte[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(SByte[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(SByte[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(Decimal[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Decimal[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Decimal[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(Decimal[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Decimal[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Decimal[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Decimal[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Decimal[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Decimal[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(Decimal[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Decimal[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Decimal[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(Decimal[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Decimal[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Decimal[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Decimal[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Decimal[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Decimal[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(Decimal[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(Decimal[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Decimal[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(Decimal[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Decimal[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Decimal[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Decimal[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Decimal[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Decimal[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(Decimal[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(Decimal[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Decimal[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(Decimal[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Decimal[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Decimal[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Decimal[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Decimal[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Decimal[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(Decimal[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Decimal[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Decimal[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(Decimal[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Decimal[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Decimal[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Decimal[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Decimal[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Decimal[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(Decimal[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(Decimal[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Decimal[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(Decimal[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Decimal[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Decimal[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Decimal[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Decimal[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Decimal[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Decimal[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Decimal[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Decimal[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Decimal[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Decimal[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Decimal[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Decimal[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Decimal[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Decimal[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Decimal[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Decimal[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Decimal[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Decimal[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Decimal[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Decimal[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Decimal[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Decimal[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Decimal[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(Decimal[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(Decimal[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(Decimal[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(Decimal[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Decimal[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Decimal[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Decimal[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(Decimal[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Decimal[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Decimal[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Decimal[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Decimal[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Decimal[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Decimal[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Decimal[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Decimal[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Decimal[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Decimal[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Decimal[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(Boolean[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Boolean[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Boolean[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(Boolean[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Boolean[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Boolean[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Boolean[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Boolean[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Boolean[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(Boolean[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Boolean[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Boolean[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(Boolean[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Boolean[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Boolean[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Boolean[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Boolean[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Boolean[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(Boolean[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(Boolean[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Boolean[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(Boolean[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Boolean[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Boolean[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Boolean[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Boolean[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Boolean[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(Boolean[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(Boolean[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Boolean[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(Boolean[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Boolean[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Boolean[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Boolean[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Boolean[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Boolean[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(Boolean[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Boolean[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Boolean[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(Boolean[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Boolean[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Boolean[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Boolean[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Boolean[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Boolean[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(Boolean[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(Boolean[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Boolean[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(Boolean[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Boolean[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Boolean[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Boolean[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Boolean[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Boolean[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Boolean[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Boolean[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Boolean[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Boolean[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Boolean[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Boolean[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Boolean[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Boolean[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Boolean[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Boolean[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Boolean[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Boolean[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Boolean[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Boolean[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Boolean[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Boolean[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Boolean[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Boolean[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(Boolean[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(Boolean[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(Boolean[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(Boolean[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Boolean[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Boolean[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(Boolean[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(Boolean[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(Boolean[][] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Boolean[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Boolean[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Boolean[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Boolean[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Boolean[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Boolean[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Boolean[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Boolean[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Boolean[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Boolean[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(Object[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Object[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Object[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Object[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(Object[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Object[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Object[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(Object[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(Object[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(Object[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(Object[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Object[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Object[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Object[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(Object[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Object[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Object[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(Object[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(Object[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(Object[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(Object[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Object[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(Object[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Object[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(Object[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Object[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Object[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(Object[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(Object[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(Object[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(Object[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Object[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(Object[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Object[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(Object[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Object[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Object[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(Object[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(Object[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(Object[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(Object[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Object[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Object[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Object[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(Object[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Object[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Object[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(Object[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(Object[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(Object[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(Object[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Object[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(Object[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Object[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(Object[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Object[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Object[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(Object[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(Object[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(Object[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(Object[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Object[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Object[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Object[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(Object[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Object[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Object[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(Object[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(Object[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(Object[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Object[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Object[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Object[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Object[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(Object[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Object[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Object[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(Object[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(Object[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(Object[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Object[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Object[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Object[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Object[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(Object[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Object[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Object[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(Object[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(Object[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(Object[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static String[] ToString(Object[] value);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Object[0...,0...] value);
    [ExtensionAttribute]
public static String[][] ToString(Object[][] value);
    [ExtensionAttribute]
public static String[][][] ToString(Object[][][] value);
    [ExtensionAttribute]
public static String[] ToString(Object[] value, String[] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Object[0...,0...] value, String[0...,0...] result);
    [ExtensionAttribute]
public static String[][] ToString(Object[0...,0...] value, String[][] result);
    [ExtensionAttribute]
public static String[][] ToString(Object[][] value, String[][] result);
    [ExtensionAttribute]
public static String[][][] ToString(Object[][][] value, String[][][] result);
    [ExtensionAttribute]
public static String[0...,0...] ToString(Object[][] value, String[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] ToInt32(String[] value);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(String[0...,0...] value);
    [ExtensionAttribute]
public static Int32[][] ToInt32(String[][] value);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(String[][][] value);
    [ExtensionAttribute]
public static Int32[] ToInt32(String[] value, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(String[0...,0...] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(String[0...,0...] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] ToInt32(String[][] value, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][][] ToInt32(String[][][] value, Int32[][][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] ToInt32(String[][] value, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] ToInt16(String[] value);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(String[0...,0...] value);
    [ExtensionAttribute]
public static Int16[][] ToInt16(String[][] value);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(String[][][] value);
    [ExtensionAttribute]
public static Int16[] ToInt16(String[] value, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(String[0...,0...] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(String[0...,0...] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] ToInt16(String[][] value, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][][] ToInt16(String[][][] value, Int16[][][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] ToInt16(String[][] value, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] ToSingle(String[] value);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(String[0...,0...] value);
    [ExtensionAttribute]
public static Single[][] ToSingle(String[][] value);
    [ExtensionAttribute]
public static Single[][][] ToSingle(String[][][] value);
    [ExtensionAttribute]
public static Single[] ToSingle(String[] value, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(String[0...,0...] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(String[0...,0...] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][] ToSingle(String[][] value, Single[][] result);
    [ExtensionAttribute]
public static Single[][][] ToSingle(String[][][] value, Single[][][] result);
    [ExtensionAttribute]
public static Single[0...,0...] ToSingle(String[][] value, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] ToDouble(String[] value);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(String[0...,0...] value);
    [ExtensionAttribute]
public static Double[][] ToDouble(String[][] value);
    [ExtensionAttribute]
public static Double[][][] ToDouble(String[][][] value);
    [ExtensionAttribute]
public static Double[] ToDouble(String[] value, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(String[0...,0...] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(String[0...,0...] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToDouble(String[][] value, Double[][] result);
    [ExtensionAttribute]
public static Double[][][] ToDouble(String[][][] value, Double[][][] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToDouble(String[][] value, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] ToInt64(String[] value);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(String[0...,0...] value);
    [ExtensionAttribute]
public static Int64[][] ToInt64(String[][] value);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(String[][][] value);
    [ExtensionAttribute]
public static Int64[] ToInt64(String[] value, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(String[0...,0...] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(String[0...,0...] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] ToInt64(String[][] value, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][][] ToInt64(String[][][] value, Int64[][][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] ToInt64(String[][] value, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] ToByte(String[] value);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(String[0...,0...] value);
    [ExtensionAttribute]
public static Byte[][] ToByte(String[][] value);
    [ExtensionAttribute]
public static Byte[][][] ToByte(String[][][] value);
    [ExtensionAttribute]
public static Byte[] ToByte(String[] value, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(String[0...,0...] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(String[0...,0...] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] ToByte(String[][] value, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][][] ToByte(String[][][] value, Byte[][][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] ToByte(String[][] value, Byte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] ToSByte(String[] value);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(String[0...,0...] value);
    [ExtensionAttribute]
public static SByte[][] ToSByte(String[][] value);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(String[][][] value);
    [ExtensionAttribute]
public static SByte[] ToSByte(String[] value, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(String[0...,0...] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(String[0...,0...] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] ToSByte(String[][] value, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][][] ToSByte(String[][][] value, SByte[][][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] ToSByte(String[][] value, SByte[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(String[] value);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(String[0...,0...] value);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(String[][] value);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(String[][][] value);
    [ExtensionAttribute]
public static Decimal[] ToDecimal(String[] value, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(String[0...,0...] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(String[0...,0...] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] ToDecimal(String[][] value, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][][] ToDecimal(String[][][] value, Decimal[][][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] ToDecimal(String[][] value, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(String[] value);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(String[0...,0...] value);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(String[][] value);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(String[][][] value);
    [ExtensionAttribute]
public static Boolean[] ToBoolean(String[] value, Boolean[] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(String[0...,0...] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(String[0...,0...] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][] ToBoolean(String[][] value, Boolean[][] result);
    [ExtensionAttribute]
public static Boolean[][][] ToBoolean(String[][][] value, Boolean[][][] result);
    [ExtensionAttribute]
public static Boolean[0...,0...] ToBoolean(String[][] value, Boolean[0...,0...] result);
    [ExtensionAttribute]
public static Object[] ToObject(String[] value);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(String[0...,0...] value);
    [ExtensionAttribute]
public static Object[][] ToObject(String[][] value);
    [ExtensionAttribute]
public static Object[][][] ToObject(String[][][] value);
    [ExtensionAttribute]
public static Object[] ToObject(String[] value, Object[] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(String[0...,0...] value, Object[0...,0...] result);
    [ExtensionAttribute]
public static Object[][] ToObject(String[0...,0...] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][] ToObject(String[][] value, Object[][] result);
    [ExtensionAttribute]
public static Object[][][] ToObject(String[][][] value, Object[][][] result);
    [ExtensionAttribute]
public static Object[0...,0...] ToObject(String[][] value, Object[0...,0...] result);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Int32[] Abs(Int32[] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] Abs(Double[] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] Sign(Double[] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] Abs(Double[0...,0...] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Int32[0...,0...] Abs(Int32[0...,0...] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] Sqrt(Double[] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] Sqrt(Double[0...,0...] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] Log(Double[0...,0...] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] Exp(Double[0...,0...] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] Exp(Double[] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] Log(Double[] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] Log(Int32[] value);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] ElementwisePower(Double[0...,0...] x, double y);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] ElementwisePower(Double[] x, double y);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] ElementwiseDivide(Double[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] ElementwiseDivide(Double[0...,0...] a, Double[0...,0...] b);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Single[0...,0...] ElementwiseDivide(Single[0...,0...] a, Single[0...,0...] b);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] ElementwiseDivide(Double[0...,0...] a, Double[] b, int dimension, bool inPlace);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] ElementwiseDivide(Int32[0...,0...] a, Int32[] b, int dimension);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] ElementwiseMultiply(Double[] a, Double[] b);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[] ElementwiseMultiply(Double[] a, Int32[] b);
    public static Double[0...,0...] ElementwiseMultiply(Double[0...,0...] a, Double[0...,0...] b);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Int32[] ElementwiseMultiply(Int32[] a, Int32[] b);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Int32[0...,0...] ElementwiseMultiply(Int32[0...,0...] a, Int32[0...,0...] b);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] ElementwiseMultiply(Double[0...,0...] a, Double[] b, int dimension);
    [ObsoleteAttribute("Please use the functions in the Elementwise class instead.")]
public static Double[0...,0...] ElementwiseMultiply(Double[0...,0...] a, Double[] b, Double[0...,0...] r, int dimension);
    [ExtensionAttribute]
public static int Rows(IList`1<IList`1<T>> values);
    [ExtensionAttribute]
public static int Columns(IList`1<IList`1<T>> values);
    [ExtensionAttribute]
public static T[0...,0...] ToMatrix(IList`1<IList`1<T>> values);
    [ExtensionAttribute]
public static T[][] ToJagged(IList`1<IList`1<T>> values);
    [ExtensionAttribute]
public static T[0...,0...] Get(T[0...,0...] source, int startRow, int endRow, int startColumn, int endColumn);
    [ExtensionAttribute]
public static T[0...,0...] Get(T[0...,0...] source, T[0...,0...] destination, int startRow, int endRow, int startColumn, int endColumn);
    [ExtensionAttribute]
public static T[0...,0...] Get(T[0...,0...] source, Int32[] rowIndexes, Int32[] columnIndexes, T[0...,0...] result);
    [ExtensionAttribute]
public static T[0...,0...] Get(T[0...,0...] source, Boolean[] rowMask, Boolean[] columnMask, T[0...,0...] result);
    [ExtensionAttribute]
public static T[0...,0...] Get(T[0...,0...] source, T[0...,0...] destination, Int32[] rowIndexes, Int32[] columnIndexes);
    [ExtensionAttribute]
public static T[0...,0...] Get(T[0...,0...] source, Int32[] rowIndexes);
    [ExtensionAttribute]
public static T[0...,0...] Get(T[0...,0...] source, int startRow, int endRow, Int32[] columnIndexes);
    [ExtensionAttribute]
public static T[0...,0...] Get(T[0...,0...] source, Int32[] rowIndexes, int startColumn, int endColumn);
    private static int end(int end, int length);
    private static int index(int end, int length);
    [ExtensionAttribute]
public static T[][] Get(T[][] source, int startRow, int endRow, int startColumn, int endColumn);
    [ExtensionAttribute]
public static T[][] Set(T[][] destination, int startRow, int endRow, int startColumn, int endColumn, T[][] values);
    [ExtensionAttribute]
public static T[][] Set(T[][] values, Func`2<T, bool> match, T value);
    [ExtensionAttribute]
public static T[][] Get(T[][] source, Int32[] rowIndexes, Int32[] columnIndexes, bool reuseMemory, T[][] result);
    [ExtensionAttribute]
public static T[][] Get(T[][] source, Boolean[] rowMask, Boolean[] columnMask, bool reuseMemory, T[][] result);
    [ExtensionAttribute]
public static T[][] Get(T[][] source, Int32[] indexes, bool transpose);
    [ExtensionAttribute]
public static T[][] Get(T[][] source, Int32[] rowIndexes, int startColumn, int endColumn, bool reuseMemory);
    [ExtensionAttribute]
public static T[][] Get(T[][] source, int startRow, int endRow, Int32[] columnIndexes);
    [ExtensionAttribute]
public static T[] Get(T[] source, Int32[] indexes, bool inPlace);
    [ExtensionAttribute]
public static T[] Get(T[] source, IList`1<int> indexes);
    [ExtensionAttribute]
public static T[] Get(T[] source, int startRow, int endRow);
    [ExtensionAttribute]
public static T Get(T[] source, int index);
    [ExtensionAttribute]
public static List`1<T> Get(List`1<T> source, Int32[] indexes);
    [ExtensionAttribute]
private static T[0...,0...] get(T[0...,0...] source, T[0...,0...] destination, int startRow, int endRow, int startColumn, int endColumn);
    [ExtensionAttribute]
private static T[0...,0...] get(T[0...,0...] source, T[0...,0...] destination, Int32[] rowIndexes, Int32[] columnIndexes);
    [ExtensionAttribute]
private static T[][] get(T[][] source, T[][] destination, Int32[] rowIndexes, Int32[] columnIndexes, bool reuseMemory);
    [ExtensionAttribute]
private static T[][] get(T[][] source, T[][] destination, int startRow, int endRow, int startColumn, int endColumn, bool reuseMemory);
    [ExtensionAttribute]
private static T[][] set(T[][] destination, T[][] source, int startRow, int endRow, int startColumn, int endColumn);
    [ExtensionAttribute]
public static Double[0...,0...] Solve(Double[0...,0...] matrix, Double[0...,0...] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Double[] Solve(Double[0...,0...] matrix, Double[] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Double[0...,0...] Inverse(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[0...,0...] Inverse(Double[0...,0...] matrix, bool inPlace);
    [ExtensionAttribute]
public static Double[0...,0...] PseudoInverse(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[][] Solve(Double[][] matrix, Double[][] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Double[] Solve(Double[][] matrix, Double[] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Double[][] SolveForDiagonal(Double[][] matrix, Double[] diagonalRightSide, bool leastSquares);
    [ExtensionAttribute]
public static ISolverMatrixDecomposition`1<double> Decompose(Double[0...,0...] matrix, bool leastSquares);
    [ExtensionAttribute]
public static ISolverArrayDecomposition`1<double> Decompose(Double[][] matrix, bool leastSquares);
    [ExtensionAttribute]
public static Double[][] Inverse(Double[][] matrix);
    [ExtensionAttribute]
public static Double[][] Inverse(Double[][] matrix, bool inPlace);
    [ExtensionAttribute]
public static Double[][] PseudoInverse(Double[][] matrix);
    [ExtensionAttribute]
public static Double[0...,0...] Divide(Double[0...,0...] a, Double[0...,0...] b, bool leastSquares);
    [ExtensionAttribute]
public static Double[][] Divide(Double[][] a, Double[][] b, bool leastSquares);
    [ExtensionAttribute]
public static Double[][] Null(Double[] vector);
    [ExtensionAttribute]
public static Double[][] Null(Double[][] matrix);
    [ExtensionAttribute]
public static Double[0...,0...] Null(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Single[0...,0...] Solve(Single[0...,0...] matrix, Single[0...,0...] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Single[] Solve(Single[0...,0...] matrix, Single[] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Single[0...,0...] Inverse(Single[0...,0...] matrix);
    [ExtensionAttribute]
public static Single[0...,0...] Inverse(Single[0...,0...] matrix, bool inPlace);
    [ExtensionAttribute]
public static Single[0...,0...] PseudoInverse(Single[0...,0...] matrix);
    [ExtensionAttribute]
public static Single[][] Solve(Single[][] matrix, Single[][] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Single[] Solve(Single[][] matrix, Single[] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Single[][] SolveForDiagonal(Single[][] matrix, Single[] diagonalRightSide, bool leastSquares);
    [ExtensionAttribute]
public static ISolverMatrixDecomposition`1<float> Decompose(Single[0...,0...] matrix, bool leastSquares);
    [ExtensionAttribute]
public static ISolverArrayDecomposition`1<float> Decompose(Single[][] matrix, bool leastSquares);
    [ExtensionAttribute]
public static Single[][] Inverse(Single[][] matrix);
    [ExtensionAttribute]
public static Single[][] Inverse(Single[][] matrix, bool inPlace);
    [ExtensionAttribute]
public static Single[][] PseudoInverse(Single[][] matrix);
    [ExtensionAttribute]
public static Single[0...,0...] Divide(Single[0...,0...] a, Single[0...,0...] b, bool leastSquares);
    [ExtensionAttribute]
public static Single[][] Divide(Single[][] a, Single[][] b, bool leastSquares);
    [ExtensionAttribute]
public static Single[][] Null(Single[] vector);
    [ExtensionAttribute]
public static Single[][] Null(Single[][] matrix);
    [ExtensionAttribute]
public static Single[0...,0...] Null(Single[0...,0...] matrix);
    [ExtensionAttribute]
public static Decimal[0...,0...] Solve(Decimal[0...,0...] matrix, Decimal[0...,0...] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Decimal[] Solve(Decimal[0...,0...] matrix, Decimal[] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Decimal[0...,0...] Inverse(Decimal[0...,0...] matrix);
    [ExtensionAttribute]
public static Decimal[0...,0...] Inverse(Decimal[0...,0...] matrix, bool inPlace);
    [ExtensionAttribute]
public static Decimal[0...,0...] PseudoInverse(Decimal[0...,0...] matrix);
    [ExtensionAttribute]
public static Decimal[][] Solve(Decimal[][] matrix, Decimal[][] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Decimal[] Solve(Decimal[][] matrix, Decimal[] rightSide, bool leastSquares);
    [ExtensionAttribute]
public static Decimal[][] SolveForDiagonal(Decimal[][] matrix, Decimal[] diagonalRightSide, bool leastSquares);
    [ExtensionAttribute]
public static ISolverMatrixDecomposition`1<decimal> Decompose(Decimal[0...,0...] matrix, bool leastSquares);
    [ExtensionAttribute]
public static ISolverArrayDecomposition`1<decimal> Decompose(Decimal[][] matrix, bool leastSquares);
    [ExtensionAttribute]
public static Decimal[][] Inverse(Decimal[][] matrix);
    [ExtensionAttribute]
public static Decimal[][] Inverse(Decimal[][] matrix, bool inPlace);
    [ExtensionAttribute]
public static Decimal[][] PseudoInverse(Decimal[][] matrix);
    [ExtensionAttribute]
public static Decimal[0...,0...] Divide(Decimal[0...,0...] a, Decimal[0...,0...] b, bool leastSquares);
    [ExtensionAttribute]
public static Decimal[][] Divide(Decimal[][] a, Decimal[][] b, bool leastSquares);
    [ExtensionAttribute]
public static Decimal[][] Null(Decimal[] vector);
    [ExtensionAttribute]
public static Decimal[][] Null(Decimal[][] matrix);
    [ExtensionAttribute]
public static Decimal[0...,0...] Null(Decimal[0...,0...] matrix);
    [ExtensionAttribute]
public static Tuple`2<int, int> ArgMax(T[0...,0...] matrix);
    [ExtensionAttribute]
public static Int32[] ArgMax(T[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] ArgMax(T[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Tuple`2<int, int> ArgMin(T[0...,0...] matrix);
    [ExtensionAttribute]
public static Int32[] ArgMin(T[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] ArgMin(T[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static T Max(T[0...,0...] matrix);
    [ExtensionAttribute]
public static T Min(T[0...,0...] matrix);
    [ExtensionAttribute]
public static T[] Min(T[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static T[] Max(T[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static T[] Max(T[0...,0...] matrix, int dimension, T[] result);
    [ExtensionAttribute]
public static T[] Min(T[0...,0...] matrix, int dimension, T[] result);
    [ExtensionAttribute]
public static T[] Min(T[0...,0...] matrix, int dimension, Int32[]& indices);
    [ExtensionAttribute]
public static T[] Max(T[0...,0...] matrix, int dimension, Int32[]& indices);
    [ExtensionAttribute]
public static T[] Max(T[0...,0...] matrix, int dimension, Int32[]& indices, T[] result);
    [ExtensionAttribute]
public static T[] Min(T[0...,0...] matrix, int dimension, Int32[]& indices, T[] result);
    [ExtensionAttribute]
public static T Max(T[0...,0...] matrix, Tuple`2& imax);
    [ExtensionAttribute]
public static T Min(T[0...,0...] matrix, Tuple`2& imin);
    [ExtensionAttribute]
public static T[] Max(T[0...,0...] matrix, int dimension, Int32[] indices, T[] result);
    [ExtensionAttribute]
public static T[] Min(T[0...,0...] matrix, int dimension, Int32[] indices, T[] result);
    [ExtensionAttribute]
public static void GetRange(T[] values, T& min, T& max);
    [ExtensionAttribute]
public static void GetRange(T[0...,0...] values, T& min, T& max);
    [ExtensionAttribute]
public static IntRange GetRange(Int32[] values);
    [ExtensionAttribute]
public static DoubleRange GetRange(Double[] values);
    [ExtensionAttribute]
public static IntRange GetRange(Int32[0...,0...] values);
    [ExtensionAttribute]
public static DoubleRange GetRange(Double[0...,0...] values);
    [ExtensionAttribute]
public static DoubleRange[] GetRange(Double[0...,0...] value, int dimension);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use GetRange instead.")]
public static IntRange Range(Int32[] values);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use GetRange instead.")]
public static DoubleRange Range(Double[] values);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use GetRange instead.")]
public static IntRange Range(Int32[0...,0...] values);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use GetRange instead.")]
public static DoubleRange Range(Double[0...,0...] values);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use GetRange instead.")]
public static DoubleRange[] Range(Double[0...,0...] value, int dimension);
    [ExtensionAttribute]
public static string ToString(T[0...,0...] matrix);
    [ExtensionAttribute]
public static string ToCSharp(T[0...,0...] matrix);
    [ExtensionAttribute]
public static string ToOctave(T[0...,0...] matrix);
    [ExtensionAttribute]
public static string ToString(T[0...,0...] matrix, bool multiline, IMatrixFormatProvider provider);
    [ExtensionAttribute]
public static string ToString(T[0...,0...] matrix, IMatrixFormatProvider provider);
    [ExtensionAttribute]
public static string ToString(T[0...,0...] matrix, string format, IMatrixFormatProvider provider);
    [ExtensionAttribute]
public static string ToString(T[0...,0...] matrix, string format);
    [ExtensionAttribute]
public static string ToCSharp(T[][] matrix);
    [ExtensionAttribute]
public static string ToOctave(T[][] matrix);
    [ExtensionAttribute]
public static string ToString(T[][] matrix);
    [ExtensionAttribute]
public static string ToString(T[][] matrix, IMatrixFormatProvider provider);
    [ExtensionAttribute]
public static string ToString(T[][] matrix, string format, IMatrixFormatProvider provider);
    [ExtensionAttribute]
public static string ToString(T[][] matrix, string format);
    [ExtensionAttribute]
public static string ToString(T[] array);
    [ExtensionAttribute]
public static string ToCSharp(T[] array);
    [ExtensionAttribute]
public static string ToOctave(T[] array);
    [ExtensionAttribute]
public static string ToString(T[] array, IMatrixFormatProvider provider);
    [ExtensionAttribute]
public static string ToString(T[] matrix, string format, IMatrixFormatProvider provider);
    [ExtensionAttribute]
public static string ToString(T[] array, string format);
    public static Double[0...,0...] Parse(string str);
    public static Double[0...,0...] Parse(string str, IMatrixFormatProvider provider);
    [ObsoleteAttribute("Please use the Jagged.Parse() method instead.")]
public static Double[][] ParseJagged(string s, IMatrixFormatProvider provider);
    public static bool TryParse(string s, IMatrixFormatProvider provider, Double[0...,0...]& matrix);
    public static bool TryParse(string s, IMatrixFormatProvider provider, Double[][]& matrix);
    [ExtensionAttribute]
public static int Dot(Int32[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int32[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int32[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int32[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int32[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int32[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int32[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int32[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[] columnVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int32[] columnVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int32[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int32[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int32[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int32[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Cross(Int32[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int32[] a, Int32[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static int Inner(Int32[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int32[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int32[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static double Dot(Int32[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Dot(Int32[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Int32[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Int32[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Int32[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int32[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int32[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int32[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int32[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int32[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int32[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int32[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[] columnVector, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int32[] columnVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int32[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int32[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int32[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int32[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Cross(Int32[] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int32[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Int32[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Int32[] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int32[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static float Dot(Int32[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Dot(Int32[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Int32[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Int32[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] Dot(Int32[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int32[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Int32[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int32[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int32[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int32[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int32[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int32[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int32[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int32[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int32[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int32[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int32[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int32[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int32[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int32[] columnVector, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int32[] columnVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int32[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int32[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int32[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int32[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Int32[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Int32[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Int32[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Cross(Int32[] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Int32[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static float Inner(Int32[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Kronecker(Int32[] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int32[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Int32[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int32[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int32[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static double Dot(Double[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Dot(Double[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Double[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Double[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[] columnVector, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[] columnVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Double[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Double[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Double[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Double[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Double[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Cross(Double[] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Double[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Double[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Double[] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Double[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static double Dot(Double[] a, Int32[] b);
    [ExtensionAttribute]
public static Double[] Dot(Double[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Double[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Double[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[] columnVector, Int32[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[] columnVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Double[][] a, Int32[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Double[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Double[][] a, Int32[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Double[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Double[][] a, Int32[] b);
    [ExtensionAttribute]
public static Double[] Cross(Double[] a, Int32[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Double[] a, Int32[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Double[] a, Int32[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Double[] a, Int32[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Double[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static double Dot(Double[] a, Single[] b);
    [ExtensionAttribute]
public static Double[] Dot(Double[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Double[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Single[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Double[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Double[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Single[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[] columnVector, Single[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[] columnVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Single[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Double[][] a, Single[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Double[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Double[][] a, Single[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Double[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Double[][] a, Single[] b);
    [ExtensionAttribute]
public static Double[] Cross(Double[] a, Single[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Double[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Double[] a, Single[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Double[] a, Single[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Single[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Double[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static float Dot(Single[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Dot(Single[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Single[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Single[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Single[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[] columnVector, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[] columnVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Single[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Single[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Single[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Single[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Single[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Cross(Single[] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Single[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static float Inner(Single[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Kronecker(Single[] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Single[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static double Dot(Single[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Dot(Single[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Single[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Single[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Single[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Single[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Single[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Single[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Single[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Single[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Single[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Single[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Single[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Single[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Single[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[] columnVector, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Single[] columnVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Single[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Single[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Single[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Single[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Single[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Single[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Cross(Single[] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Single[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Single[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Single[] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Single[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static float Dot(Single[] a, Int32[] b);
    [ExtensionAttribute]
public static Single[] Dot(Single[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Single[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Single[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Single[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[] columnVector, Int32[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[] columnVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Single[][] a, Int32[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Single[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Single[][] a, Int32[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Single[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Single[][] a, Int32[] b);
    [ExtensionAttribute]
public static Single[] Cross(Single[] a, Int32[] b);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Single[] a, Int32[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static float Inner(Single[] a, Int32[] b);
    [ExtensionAttribute]
public static Single[] Kronecker(Single[] a, Int32[] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Single[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static long Dot(Int64[] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[][] a, Int64[] columnVector);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[0...,0...] a, Int64[] columnVector);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Int64[][] b);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Int64[][] b);
    [ExtensionAttribute]
public static Int64[0...,0...] Dot(Int64[0...,0...] a, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[0...,0...] a, Int64[][] b);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int64[] columnVector);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int64[] columnVector);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Int64[][] b);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int64[][] b);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[0...,0...] a, Int64[][] b);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[][] a, Int64[] columnVector);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[0...,0...] a, Int64[] columnVector);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[] columnVector, Int64[][] b);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[] columnVector, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Int64[][] b);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[0...,0...] a, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[0...,0...] a, Int64[][] b);
    [ExtensionAttribute]
public static Int64[][] DotWithDiagonal(Int64[][] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDotWithDiagonal(Int64[][] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[][] DivideByDiagonal(Int64[][] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[] Cross(Int64[] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[0...,0...] Outer(Int64[] a, Int64[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static long Inner(Int64[] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[] Kronecker(Int64[] a, Int64[] b);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Int64[][] b);
    [ExtensionAttribute]
public static Int64[0...,0...] Kronecker(Int64[0...,0...] a, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Int64[0...,0...] b);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[0...,0...] a, Int64[][] b);
    [ExtensionAttribute]
public static double Dot(Int64[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Dot(Int64[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Int64[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int64[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[] columnVector, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[] columnVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int64[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int64[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int64[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Cross(Int64[] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int64[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Int64[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Int64[] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int64[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static int Dot(Int64[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int64[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[] columnVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[] columnVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int64[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int64[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int64[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Cross(Int64[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int64[] a, Int32[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static int Inner(Int64[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int64[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int64[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static float Dot(Int64[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Dot(Int64[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Int64[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Int64[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] Dot(Int64[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int64[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Int64[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int64[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int64[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int64[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int64[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int64[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int64[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int64[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int64[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int64[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int64[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int64[] columnVector, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int64[] columnVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int64[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int64[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int64[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int64[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Int64[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Int64[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Int64[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Cross(Int64[] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Int64[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static float Inner(Int64[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Kronecker(Int64[] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int64[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Int64[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int64[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int64[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static decimal Dot(Decimal[] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[][] a, Decimal[] columnVector);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[0...,0...] a, Decimal[] columnVector);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] Dot(Decimal[0...,0...] a, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[0...,0...] a, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Decimal[] columnVector);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Decimal[] columnVector);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[0...,0...] a, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[][] a, Decimal[] columnVector);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[0...,0...] a, Decimal[] columnVector);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[] columnVector, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[] columnVector, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[0...,0...] a, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[][] DotWithDiagonal(Decimal[][] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDotWithDiagonal(Decimal[][] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[][] DivideByDiagonal(Decimal[][] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[] Cross(Decimal[] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] Outer(Decimal[] a, Decimal[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static decimal Inner(Decimal[] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[] Kronecker(Decimal[] a, Decimal[] b);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Decimal[][] b);
    [ExtensionAttribute]
public static Decimal[0...,0...] Kronecker(Decimal[0...,0...] a, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Decimal[0...,0...] b);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[0...,0...] a, Decimal[][] b);
    [ExtensionAttribute]
public static double Dot(Decimal[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Decimal[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[] columnVector, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[] columnVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Decimal[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Decimal[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Decimal[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Cross(Decimal[] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Decimal[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Decimal[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Decimal[] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Decimal[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static int Dot(Decimal[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Decimal[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[] columnVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[] columnVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Decimal[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Decimal[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Decimal[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Cross(Decimal[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Decimal[] a, Int32[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static int Inner(Decimal[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Kronecker(Decimal[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Decimal[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static float Dot(Decimal[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Dot(Decimal[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Decimal[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Decimal[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] Dot(Decimal[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Decimal[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Decimal[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Decimal[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Decimal[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Decimal[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Decimal[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Decimal[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Decimal[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Decimal[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Decimal[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Decimal[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Decimal[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Decimal[] columnVector, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Decimal[] columnVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Decimal[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Decimal[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Decimal[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Decimal[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Decimal[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Decimal[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Cross(Decimal[] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Decimal[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static float Inner(Decimal[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Kronecker(Decimal[] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Decimal[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Decimal[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Decimal[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Decimal[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static byte Dot(Byte[] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[][] a, Byte[] columnVector);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[0...,0...] a, Byte[] columnVector);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Byte[][] b);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Byte[][] b);
    [ExtensionAttribute]
public static Byte[0...,0...] Dot(Byte[0...,0...] a, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[0...,0...] a, Byte[][] b);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Byte[] columnVector);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Byte[] columnVector);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Byte[][] b);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Byte[][] b);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[0...,0...] a, Byte[][] b);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[][] a, Byte[] columnVector);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[0...,0...] a, Byte[] columnVector);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[] columnVector, Byte[][] b);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[] columnVector, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Byte[][] b);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[0...,0...] a, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[0...,0...] a, Byte[][] b);
    [ExtensionAttribute]
public static Byte[][] DotWithDiagonal(Byte[][] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDotWithDiagonal(Byte[][] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[][] DivideByDiagonal(Byte[][] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[] Cross(Byte[] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[0...,0...] Outer(Byte[] a, Byte[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static byte Inner(Byte[] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[] Kronecker(Byte[] a, Byte[] b);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Byte[][] b);
    [ExtensionAttribute]
public static Byte[0...,0...] Kronecker(Byte[0...,0...] a, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Byte[0...,0...] b);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[0...,0...] a, Byte[][] b);
    [ExtensionAttribute]
public static double Dot(Byte[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Dot(Byte[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Byte[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Byte[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[] columnVector, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[] columnVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Byte[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Byte[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Byte[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Cross(Byte[] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Byte[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Byte[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Byte[] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Byte[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static int Dot(Byte[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Byte[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[] columnVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[] columnVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Byte[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Byte[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Byte[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Cross(Byte[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Byte[] a, Int32[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static int Inner(Byte[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Kronecker(Byte[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Byte[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static float Dot(Byte[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Dot(Byte[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Byte[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Byte[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] Dot(Byte[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Byte[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Byte[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Byte[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Byte[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Byte[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Byte[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Byte[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Byte[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Byte[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Byte[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Byte[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Byte[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Byte[] columnVector, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Byte[] columnVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Byte[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Byte[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Byte[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Byte[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Byte[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Byte[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Byte[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Cross(Byte[] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Byte[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static float Inner(Byte[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Kronecker(Byte[] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Byte[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Byte[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Byte[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Byte[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static short Dot(Int16[] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[][] a, Int16[] columnVector);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[0...,0...] a, Int16[] columnVector);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Int16[][] b);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Int16[][] b);
    [ExtensionAttribute]
public static Int16[0...,0...] Dot(Int16[0...,0...] a, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[0...,0...] a, Int16[][] b);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int16[] columnVector);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int16[] columnVector);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Int16[][] b);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int16[][] b);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[0...,0...] a, Int16[][] b);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[][] a, Int16[] columnVector);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[0...,0...] a, Int16[] columnVector);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[] columnVector, Int16[][] b);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[] columnVector, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Int16[][] b);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[0...,0...] a, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[0...,0...] a, Int16[][] b);
    [ExtensionAttribute]
public static Int16[][] DotWithDiagonal(Int16[][] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDotWithDiagonal(Int16[][] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[][] DivideByDiagonal(Int16[][] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[] Cross(Int16[] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[0...,0...] Outer(Int16[] a, Int16[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static short Inner(Int16[] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[] Kronecker(Int16[] a, Int16[] b);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Int16[][] b);
    [ExtensionAttribute]
public static Int16[0...,0...] Kronecker(Int16[0...,0...] a, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Int16[0...,0...] b);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[0...,0...] a, Int16[][] b);
    [ExtensionAttribute]
public static double Dot(Int16[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Dot(Int16[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Int16[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int16[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[] columnVector, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[] columnVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int16[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int16[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int16[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Cross(Int16[] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int16[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(Int16[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(Int16[] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int16[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static int Dot(Int16[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int16[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[] columnVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[] columnVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int16[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int16[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int16[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Cross(Int16[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int16[] a, Int32[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static int Inner(Int16[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int16[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int16[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static float Dot(Int16[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Dot(Int16[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Int16[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(Int16[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] Dot(Int16[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int16[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Int16[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int16[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(Int16[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int16[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int16[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int16[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int16[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int16[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int16[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int16[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int16[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int16[] columnVector, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int16[] columnVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int16[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int16[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int16[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int16[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Int16[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Int16[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Int16[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Cross(Int16[] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Int16[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static float Inner(Int16[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Kronecker(Int16[] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int16[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Int16[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int16[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int16[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static sbyte Dot(SByte[] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[][] a, SByte[] columnVector);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[0...,0...] a, SByte[] columnVector);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, SByte[][] b);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, SByte[][] b);
    [ExtensionAttribute]
public static SByte[0...,0...] Dot(SByte[0...,0...] a, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[0...,0...] a, SByte[][] b);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, SByte[] columnVector);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, SByte[] columnVector);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, SByte[][] b);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, SByte[][] b);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[0...,0...] a, SByte[][] b);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[][] a, SByte[] columnVector);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[0...,0...] a, SByte[] columnVector);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[] columnVector, SByte[][] b);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[] columnVector, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, SByte[][] b);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[0...,0...] a, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[0...,0...] a, SByte[][] b);
    [ExtensionAttribute]
public static SByte[][] DotWithDiagonal(SByte[][] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithDiagonal(SByte[0...,0...] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDotWithDiagonal(SByte[][] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[0...,0...] DivideByDiagonal(SByte[0...,0...] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[][] DivideByDiagonal(SByte[][] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[] Cross(SByte[] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[0...,0...] Outer(SByte[] a, SByte[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static sbyte Inner(SByte[] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[] Kronecker(SByte[] a, SByte[] b);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, SByte[][] b);
    [ExtensionAttribute]
public static SByte[0...,0...] Kronecker(SByte[0...,0...] a, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, SByte[0...,0...] b);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[0...,0...] a, SByte[][] b);
    [ExtensionAttribute]
public static double Dot(SByte[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Dot(SByte[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(SByte[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(SByte[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, Double[][] b);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[][] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[0...,0...] a, Double[] columnVector);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[] columnVector, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[] columnVector, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(SByte[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(SByte[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(SByte[][] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Cross(SByte[] a, Double[] b);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(SByte[] a, Double[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static double Inner(SByte[] a, Double[] b);
    [ExtensionAttribute]
public static Double[] Kronecker(SByte[] a, Double[] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, Double[][] b);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(SByte[0...,0...] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, Double[0...,0...] b);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[0...,0...] a, Double[][] b);
    [ExtensionAttribute]
public static int Dot(SByte[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(SByte[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[][] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[0...,0...] a, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[] columnVector, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[] columnVector, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(SByte[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(SByte[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(SByte[][] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Cross(SByte[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(SByte[] a, Int32[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static int Inner(SByte[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[] Kronecker(SByte[] a, Int32[] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, Int32[][] b);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(SByte[0...,0...] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, Int32[0...,0...] b);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[0...,0...] a, Int32[][] b);
    [ExtensionAttribute]
public static float Dot(SByte[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Dot(SByte[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(SByte[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] Dot(SByte[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] Dot(SByte[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(SByte[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(SByte[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(SByte[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Dot(SByte[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(SByte[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(SByte[] rowVector, Single[][] b);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(SByte[] rowVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(SByte[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(SByte[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(SByte[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(SByte[][] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(SByte[0...,0...] a, Single[] columnVector);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(SByte[] columnVector, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(SByte[] columnVector, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(SByte[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(SByte[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(SByte[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(SByte[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(SByte[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(SByte[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(SByte[][] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Cross(SByte[] a, Single[] b);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(SByte[] a, Single[] b);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Matrix.Dot instead.")]
public static float Inner(SByte[] a, Single[] b);
    [ExtensionAttribute]
public static Single[] Kronecker(SByte[] a, Single[] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(SByte[][] a, Single[][] b);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(SByte[0...,0...] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(SByte[][] a, Single[0...,0...] b);
    [ExtensionAttribute]
public static Single[][] Kronecker(SByte[0...,0...] a, Single[][] b);
    [ExtensionAttribute]
public static int DotAndDot(Int32[] rowVector, Int32[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int32[] rowVector, Int32[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Int32[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Int32[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int32[] rowVector, Int32[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int32[] rowVector, Int32[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int32[] rowVector, Double[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int32[] rowVector, Double[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int32[] rowVector, Double[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int32[] rowVector, Double[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Single[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Single[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Single[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int32[] rowVector, Single[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Double[] rowVector, Double[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Double[] rowVector, Double[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Double[] rowVector, Double[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Double[] rowVector, Double[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Int32[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Int32[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Double[] rowVector, Int32[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Double[] rowVector, Int32[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Double[] rowVector, Int32[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Double[] rowVector, Int32[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Single[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Single[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Single[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Double[] rowVector, Single[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Single[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Single[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Single[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Single[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Double[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Double[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Double[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Double[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Int32[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Int32[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Int32[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Int32[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Int32[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Single[] rowVector, Int32[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static long DotAndDot(Int64[] rowVector, Int64[][] matrix, Int64[] columnVector);
    [ExtensionAttribute]
public static long DotAndDot(Int64[] rowVector, Int64[0...,0...] matrix, Int64[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Int64[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Int64[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int64[] rowVector, Int64[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int64[] rowVector, Int64[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int64[] rowVector, Int64[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int64[] rowVector, Int64[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static long DotAndDot(Int64[] rowVector, Double[][] matrix, Int64[] columnVector);
    [ExtensionAttribute]
public static long DotAndDot(Int64[] rowVector, Double[0...,0...] matrix, Int64[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int64[] rowVector, Double[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int64[] rowVector, Double[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int64[] rowVector, Double[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int64[] rowVector, Double[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static long DotAndDot(Int64[] rowVector, Int32[][] matrix, Int64[] columnVector);
    [ExtensionAttribute]
public static long DotAndDot(Int64[] rowVector, Int32[0...,0...] matrix, Int64[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int64[] rowVector, Int32[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int64[] rowVector, Int32[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Int32[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Int32[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int64[] rowVector, Int32[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int64[] rowVector, Int32[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Single[][] matrix, Int64[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Single[0...,0...] matrix, Int64[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Single[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Single[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Single[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int64[] rowVector, Single[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static decimal DotAndDot(Decimal[] rowVector, Decimal[][] matrix, Decimal[] columnVector);
    [ExtensionAttribute]
public static decimal DotAndDot(Decimal[] rowVector, Decimal[0...,0...] matrix, Decimal[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Decimal[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Decimal[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Decimal[] rowVector, Decimal[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Decimal[] rowVector, Decimal[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Decimal[] rowVector, Decimal[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Decimal[] rowVector, Decimal[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static decimal DotAndDot(Decimal[] rowVector, Double[][] matrix, Decimal[] columnVector);
    [ExtensionAttribute]
public static decimal DotAndDot(Decimal[] rowVector, Double[0...,0...] matrix, Decimal[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Decimal[] rowVector, Double[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Decimal[] rowVector, Double[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Decimal[] rowVector, Double[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Decimal[] rowVector, Double[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static decimal DotAndDot(Decimal[] rowVector, Int32[][] matrix, Decimal[] columnVector);
    [ExtensionAttribute]
public static decimal DotAndDot(Decimal[] rowVector, Int32[0...,0...] matrix, Decimal[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Decimal[] rowVector, Int32[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Decimal[] rowVector, Int32[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Int32[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Int32[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Decimal[] rowVector, Int32[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Decimal[] rowVector, Int32[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Single[][] matrix, Decimal[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Single[0...,0...] matrix, Decimal[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Single[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Single[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Single[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Decimal[] rowVector, Single[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static byte DotAndDot(Byte[] rowVector, Byte[][] matrix, Byte[] columnVector);
    [ExtensionAttribute]
public static byte DotAndDot(Byte[] rowVector, Byte[0...,0...] matrix, Byte[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Byte[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Byte[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Byte[] rowVector, Byte[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Byte[] rowVector, Byte[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Byte[] rowVector, Byte[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Byte[] rowVector, Byte[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static byte DotAndDot(Byte[] rowVector, Double[][] matrix, Byte[] columnVector);
    [ExtensionAttribute]
public static byte DotAndDot(Byte[] rowVector, Double[0...,0...] matrix, Byte[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Byte[] rowVector, Double[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Byte[] rowVector, Double[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Byte[] rowVector, Double[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Byte[] rowVector, Double[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static byte DotAndDot(Byte[] rowVector, Int32[][] matrix, Byte[] columnVector);
    [ExtensionAttribute]
public static byte DotAndDot(Byte[] rowVector, Int32[0...,0...] matrix, Byte[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Byte[] rowVector, Int32[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Byte[] rowVector, Int32[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Int32[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Int32[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Byte[] rowVector, Int32[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Byte[] rowVector, Int32[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Single[][] matrix, Byte[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Single[0...,0...] matrix, Byte[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Single[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Single[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Single[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Byte[] rowVector, Single[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static short DotAndDot(Int16[] rowVector, Int16[][] matrix, Int16[] columnVector);
    [ExtensionAttribute]
public static short DotAndDot(Int16[] rowVector, Int16[0...,0...] matrix, Int16[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Int16[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Int16[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int16[] rowVector, Int16[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int16[] rowVector, Int16[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int16[] rowVector, Int16[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int16[] rowVector, Int16[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static short DotAndDot(Int16[] rowVector, Double[][] matrix, Int16[] columnVector);
    [ExtensionAttribute]
public static short DotAndDot(Int16[] rowVector, Double[0...,0...] matrix, Int16[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int16[] rowVector, Double[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int16[] rowVector, Double[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int16[] rowVector, Double[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int16[] rowVector, Double[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static short DotAndDot(Int16[] rowVector, Int32[][] matrix, Int16[] columnVector);
    [ExtensionAttribute]
public static short DotAndDot(Int16[] rowVector, Int32[0...,0...] matrix, Int16[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int16[] rowVector, Int32[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(Int16[] rowVector, Int32[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Int32[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Int32[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int16[] rowVector, Int32[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(Int16[] rowVector, Int32[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Single[][] matrix, Int16[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Single[0...,0...] matrix, Int16[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Single[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Single[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Single[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(Int16[] rowVector, Single[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static sbyte DotAndDot(SByte[] rowVector, SByte[][] matrix, SByte[] columnVector);
    [ExtensionAttribute]
public static sbyte DotAndDot(SByte[] rowVector, SByte[0...,0...] matrix, SByte[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, SByte[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, SByte[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(SByte[] rowVector, SByte[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(SByte[] rowVector, SByte[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(SByte[] rowVector, SByte[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(SByte[] rowVector, SByte[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static sbyte DotAndDot(SByte[] rowVector, Double[][] matrix, SByte[] columnVector);
    [ExtensionAttribute]
public static sbyte DotAndDot(SByte[] rowVector, Double[0...,0...] matrix, SByte[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Double[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Double[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(SByte[] rowVector, Double[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(SByte[] rowVector, Double[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(SByte[] rowVector, Double[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(SByte[] rowVector, Double[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static sbyte DotAndDot(SByte[] rowVector, Int32[][] matrix, SByte[] columnVector);
    [ExtensionAttribute]
public static sbyte DotAndDot(SByte[] rowVector, Int32[0...,0...] matrix, SByte[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(SByte[] rowVector, Int32[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static int DotAndDot(SByte[] rowVector, Int32[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Int32[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Int32[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(SByte[] rowVector, Int32[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static float DotAndDot(SByte[] rowVector, Int32[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Single[][] matrix, SByte[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Single[0...,0...] matrix, SByte[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Single[][] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Single[0...,0...] matrix, Single[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Single[][] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Single[0...,0...] matrix, Double[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Single[][] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static double DotAndDot(SByte[] rowVector, Single[0...,0...] matrix, Int32[] columnVector);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int32[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[] rowVector, Int32[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[] rowVector, Int32[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int32[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int32[] rowVector, Int32[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int32[0...,0...] a, Int32[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int32[] rowVector, Int32[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Int32[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int32[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int32[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int32[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int32[] rowVector, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[] rowVector, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int32[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int32[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int32[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int32[] a, Int32[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int32[] a, Int32[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int32[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int32[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int32[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int32[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[] rowVector, Int32[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[] rowVector, Int32[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int32[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int32[] rowVector, Int32[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int32[0...,0...] a, Int32[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int32[] rowVector, Int32[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Int32[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int32[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int32[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int32[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int32[] rowVector, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[] rowVector, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int32[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int32[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int32[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int32[] a, Int32[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int32[] a, Int32[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int32[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int32[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int32[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int32[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[] rowVector, Double[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[] rowVector, Double[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int32[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int32[] rowVector, Double[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int32[0...,0...] a, Double[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int32[] rowVector, Double[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Double[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int32[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int32[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int32[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int32[] rowVector, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[] rowVector, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int32[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int32[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int32[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int32[] a, Double[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int32[] a, Double[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int32[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int32[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int32[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int32[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[] rowVector, Double[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[] rowVector, Double[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int32[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int32[] rowVector, Double[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int32[0...,0...] a, Double[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int32[] rowVector, Double[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Double[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int32[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int32[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int32[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int32[] rowVector, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[] rowVector, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int32[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int32[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int32[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int32[] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int32[] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int32[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int32[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int32[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int32[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int32[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[] rowVector, Single[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int32[] rowVector, Single[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int32[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int32[] rowVector, Single[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int32[0...,0...] a, Single[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int32[] rowVector, Single[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int32[][] a, Single[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int32[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int32[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int32[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int32[] rowVector, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int32[] rowVector, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int32[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int32[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int32[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int32[] a, Single[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int32[] a, Single[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int32[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int32[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int32[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int32[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Int32[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int32[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int32[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int32[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Int32[] rowVector, Single[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int32[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int32[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int32[] rowVector, Single[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int32[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int32[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int32[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int32[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int32[] rowVector, Single[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int32[0...,0...] a, Single[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int32[] rowVector, Single[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int32[][] a, Single[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int32[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int32[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int32[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int32[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int32[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int32[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int32[] rowVector, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int32[] rowVector, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Int32[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Int32[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Int32[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Int32[] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Int32[] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Int32[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Int32[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int32[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int32[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int32[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Int32[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int32[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int32[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[] rowVector, Single[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int32[] rowVector, Single[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int32[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int32[] rowVector, Single[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int32[0...,0...] a, Single[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int32[] rowVector, Single[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int32[][] a, Single[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int32[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int32[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int32[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int32[] rowVector, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int32[] rowVector, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int32[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int32[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int32[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int32[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int32[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int32[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int32[] a, Single[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int32[] a, Single[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int32[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int32[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int32[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int32[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Double[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Double[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Double[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Double[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Double[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Double[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[] rowVector, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[] rowVector, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Double[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Double[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Double[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Double[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Double[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Double[] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Double[] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Double[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Double[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Double[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Double[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[] rowVector, Double[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[] rowVector, Double[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Double[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Double[] rowVector, Double[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Double[0...,0...] a, Double[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Double[] rowVector, Double[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Double[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Double[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Double[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Double[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Double[] rowVector, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[] rowVector, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Double[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Double[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Double[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Double[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Double[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Double[] a, Double[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Double[] a, Double[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Double[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Double[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Double[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Double[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Int32[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Int32[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Int32[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Int32[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Int32[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Int32[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[] rowVector, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[] rowVector, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Double[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Double[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Double[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Double[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Double[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Double[] a, Int32[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Double[] a, Int32[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Double[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Double[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Double[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Double[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[] rowVector, Int32[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[] rowVector, Int32[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Double[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Double[] rowVector, Int32[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Double[0...,0...] a, Int32[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Double[] rowVector, Int32[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Int32[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Double[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Double[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Double[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Double[] rowVector, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[] rowVector, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Double[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Double[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Double[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Double[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Double[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Double[] a, Int32[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Double[] a, Int32[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Double[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Double[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Double[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Double[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Double[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Single[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Double[] rowVector, Single[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Single[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Double[0...,0...] a, Single[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Double[] rowVector, Single[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Double[][] a, Single[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Double[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Double[] rowVector, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Double[] rowVector, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Double[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Double[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Double[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Double[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Double[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Double[] a, Single[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Double[] a, Single[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Double[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Double[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Double[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Double[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Double[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Double[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Double[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Double[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Double[] rowVector, Single[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Double[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Double[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Double[] rowVector, Single[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Double[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Double[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Double[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Double[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Double[] rowVector, Single[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Double[0...,0...] a, Single[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Double[] rowVector, Single[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Double[][] a, Single[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Double[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Double[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Double[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Double[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Double[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Double[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Double[] rowVector, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Double[] rowVector, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Double[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Double[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Double[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Double[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Double[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Double[] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Double[] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Double[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Double[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Double[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Double[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Double[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Double[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Double[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Double[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[] rowVector, Single[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Double[] rowVector, Single[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Double[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Double[] rowVector, Single[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Double[0...,0...] a, Single[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Double[] rowVector, Single[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Double[][] a, Single[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Double[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Double[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Double[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Double[] rowVector, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Double[] rowVector, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Double[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Double[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Double[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Double[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Double[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Double[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Double[] a, Single[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Double[] a, Single[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Double[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Double[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Double[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Double[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Single[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Single[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Single[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Single[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Single[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Single[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Single[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[] rowVector, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[] rowVector, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Single[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Single[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Single[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Single[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Single[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Single[] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Single[] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Single[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Single[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Single[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Single[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[] rowVector, Single[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[] rowVector, Single[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Single[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Single[] rowVector, Single[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Single[0...,0...] a, Single[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Single[] rowVector, Single[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Single[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Single[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Single[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Single[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Single[] rowVector, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[] rowVector, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Single[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Single[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Single[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Single[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Single[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Single[] a, Single[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Single[] a, Single[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Single[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Single[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Single[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Single[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[] rowVector, Single[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[] rowVector, Single[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Single[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Single[] rowVector, Single[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Single[0...,0...] a, Single[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Single[] rowVector, Single[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Single[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Single[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Single[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Single[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Single[] rowVector, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[] rowVector, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Single[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Single[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Single[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Single[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Single[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Single[] a, Single[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Single[] a, Single[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Single[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Single[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Single[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Single[0...,0...] a, Double[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Double[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[0...,0...] a, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Double[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[][] matrix, Double[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[0...,0...] matrix, Double[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Double[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Double[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Double[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[0...,0...] a, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Double[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Double[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Double[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Double[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[0...,0...] a, Double[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[0...,0...] matrix, Double[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[][] matrix, Double[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Double[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[0...,0...] a, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[] rowVector, Double[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[] rowVector, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Double[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Single[][] a, Double[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Single[0...,0...] a, Double[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Single[][] a, Double[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Single[0...,0...] a, Double[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Single[][] a, Double[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Single[] a, Double[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Single[] a, Double[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Single[] a, Double[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Single[0...,0...] a, Double[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Double[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[0...,0...] a, Double[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Single[] a, Double[] b, Single[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Single[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[] rowVector, Double[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[] rowVector, Double[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Single[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Single[] rowVector, Double[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Single[0...,0...] a, Double[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Single[] rowVector, Double[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Double[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Single[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Single[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Single[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Single[] rowVector, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[] rowVector, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Single[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Single[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Single[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Single[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Single[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Single[] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Single[] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Single[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Single[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Single[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Single[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[] rowVector, Double[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[] rowVector, Double[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Single[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Single[] rowVector, Double[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Single[0...,0...] a, Double[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Single[] rowVector, Double[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Double[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Single[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Single[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Single[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Single[] rowVector, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[] rowVector, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Single[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Single[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Single[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Single[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Single[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Single[] a, Double[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Single[] a, Double[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Single[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Single[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Single[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Single[0...,0...] a, Int32[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[][] a, Int32[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Single[0...,0...] a, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Int32[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[][] matrix, Int32[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[0...,0...] matrix, Int32[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Single[] rowVector, Int32[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Int32[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Int32[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[0...,0...] a, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Int32[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Single[0...,0...] a, Int32[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Single[] rowVector, Int32[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Single[][] a, Int32[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[0...,0...] a, Int32[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[0...,0...] matrix, Int32[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Single[][] matrix, Int32[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[][] a, Int32[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[0...,0...] a, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Single[] rowVector, Int32[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Single[] rowVector, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Int32[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Single[][] a, Int32[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Single[0...,0...] a, Int32[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Single[][] a, Int32[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Single[0...,0...] a, Int32[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Single[][] a, Int32[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Single[] a, Int32[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Single[] a, Int32[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Single[] a, Int32[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Single[0...,0...] a, Int32[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[][] a, Int32[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Single[0...,0...] a, Int32[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Single[] a, Int32[] b, Single[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Single[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Single[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[] rowVector, Int32[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Single[] rowVector, Int32[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Single[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Single[] rowVector, Int32[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Single[0...,0...] a, Int32[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Single[] rowVector, Int32[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Single[][] a, Int32[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Single[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Single[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Single[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Single[] rowVector, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Single[] rowVector, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Single[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Single[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Single[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Single[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Single[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Single[] a, Int32[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Single[] a, Int32[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Single[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Single[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Single[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Single[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Single[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Single[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[] rowVector, Int32[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Single[] rowVector, Int32[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Single[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Single[] rowVector, Int32[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Single[0...,0...] a, Int32[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Single[] rowVector, Int32[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Single[][] a, Int32[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Single[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Single[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Single[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Single[] rowVector, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Single[] rowVector, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Single[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Single[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Single[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Single[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Single[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Single[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Single[] a, Int32[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Single[] a, Int32[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Single[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Single[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Single[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Single[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Dot(Int64[0...,0...] a, Int64[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Int64[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[0...,0...] a, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Int64[0...,0...] matrix, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[][] matrix, Int64[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[0...,0...] matrix, Int64[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Int64[][] matrix, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int64[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int64[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[0...,0...] a, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Int64[0...,0...] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int64[] columnVector, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Int64[][] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int64[] columnVector, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[0...,0...] a, Int64[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[0...,0...] matrix, Int64[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[][] matrix, Int64[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Int64[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[0...,0...] a, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[] rowVector, Int64[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[] rowVector, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Int64[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDotWithDiagonal(Int64[][] a, Int64[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Int64[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DotWithDiagonal(Int64[][] a, Int64[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Int64[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DivideByDiagonal(Int64[][] a, Int64[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Outer(Int64[] a, Int64[] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Outer(Int64[] a, Int64[] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Cross(Int64[] a, Int64[] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Kronecker(Int64[0...,0...] a, Int64[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Int64[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[0...,0...] a, Int64[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Kronecker(Int64[] a, Int64[] b, Int64[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int64[0...,0...] a, Int64[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Int64[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[0...,0...] a, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Int64[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[][] matrix, Int64[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[0...,0...] matrix, Int64[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Int64[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int64[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Int64[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[0...,0...] a, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Int64[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int64[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Int64[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Int64[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[0...,0...] a, Int64[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[0...,0...] matrix, Int64[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[][] matrix, Int64[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Int64[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[0...,0...] a, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[] rowVector, Int64[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[] rowVector, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Int64[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int64[][] a, Int64[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Int64[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int64[][] a, Int64[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Int64[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int64[][] a, Int64[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int64[] a, Int64[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int64[] a, Int64[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int64[] a, Int64[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int64[0...,0...] a, Int64[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Int64[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[0...,0...] a, Int64[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int64[] a, Int64[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int64[0...,0...] a, Int64[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Int64[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[0...,0...] a, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Int64[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[][] matrix, Int64[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[0...,0...] matrix, Int64[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Int64[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int64[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int64[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[0...,0...] a, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Int64[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int64[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Int64[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int64[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[0...,0...] a, Int64[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[0...,0...] matrix, Int64[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[][] matrix, Int64[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Int64[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[0...,0...] a, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[] rowVector, Int64[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[] rowVector, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Int64[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int64[][] a, Int64[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Int64[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int64[][] a, Int64[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Int64[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int64[][] a, Int64[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int64[] a, Int64[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int64[] a, Int64[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int64[] a, Int64[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int64[0...,0...] a, Int64[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Int64[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[0...,0...] a, Int64[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int64[] a, Int64[] b, Int32[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Dot(Int64[0...,0...] a, Double[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Double[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[0...,0...] a, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Double[0...,0...] matrix, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[][] matrix, Double[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[0...,0...] matrix, Double[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Double[][] matrix, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Double[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Double[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[0...,0...] a, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Double[0...,0...] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Double[] columnVector, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Double[][] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Double[] columnVector, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[0...,0...] a, Double[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[0...,0...] matrix, Double[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[][] matrix, Double[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Double[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[0...,0...] a, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[] rowVector, Double[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[] rowVector, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Double[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDotWithDiagonal(Int64[][] a, Double[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Double[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DotWithDiagonal(Int64[][] a, Double[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Double[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DivideByDiagonal(Int64[][] a, Double[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Outer(Int64[] a, Double[] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Outer(Int64[] a, Double[] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Cross(Int64[] a, Double[] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Kronecker(Int64[0...,0...] a, Double[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Double[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[0...,0...] a, Double[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Kronecker(Int64[] a, Double[] b, Int64[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int64[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Double[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Double[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Double[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Double[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Double[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Double[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[] rowVector, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[] rowVector, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int64[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int64[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int64[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int64[] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int64[] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int64[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int64[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int64[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int64[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Double[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Double[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Double[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Double[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Double[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Double[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[] rowVector, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[] rowVector, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int64[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int64[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int64[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int64[] a, Double[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int64[] a, Double[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int64[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int64[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int64[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Dot(Int64[0...,0...] a, Int32[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Int32[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[0...,0...] a, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Int32[0...,0...] matrix, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[][] matrix, Int32[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[0...,0...] matrix, Int32[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Int32[][] matrix, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int32[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int32[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[0...,0...] a, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Int32[0...,0...] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int32[] columnVector, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Int32[][] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Int32[] columnVector, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[0...,0...] a, Int32[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[0...,0...] matrix, Int32[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[][] matrix, Int32[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Int32[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[0...,0...] a, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[] rowVector, Int32[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[] rowVector, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Int32[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDotWithDiagonal(Int64[][] a, Int32[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Int32[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DotWithDiagonal(Int64[][] a, Int32[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Int32[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DivideByDiagonal(Int64[][] a, Int32[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Outer(Int64[] a, Int32[] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Outer(Int64[] a, Int32[] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Cross(Int64[] a, Int32[] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Kronecker(Int64[0...,0...] a, Int32[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Int32[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[0...,0...] a, Int32[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Kronecker(Int64[] a, Int32[] b, Int64[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int64[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Int32[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Int32[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Int32[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int32[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Int32[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Int32[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[] rowVector, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[] rowVector, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int64[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int64[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int64[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int64[] a, Int32[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int64[] a, Int32[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int64[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int64[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int64[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int64[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Int32[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Int32[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Int32[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Int32[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Int32[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Int32[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[] rowVector, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[] rowVector, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int64[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int64[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int64[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int64[] a, Int32[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int64[] a, Int32[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int64[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int64[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int64[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Dot(Int64[0...,0...] a, Single[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[][] a, Single[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Dot(Int64[0...,0...] a, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Single[0...,0...] matrix, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[][] matrix, Single[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[0...,0...] matrix, Single[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Dot(Int64[] rowVector, Single[][] matrix, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Single[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[0...,0...] a, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Single[0...,0...] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[] columnVector, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] DotWithTransposed(Int64[] rowVector, Single[][] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] DotWithTransposed(Int64[][] a, Single[] columnVector, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[0...,0...] a, Single[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[0...,0...] matrix, Single[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[] TransposeAndDot(Int64[][] matrix, Single[] columnVector, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[][] a, Single[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[0...,0...] a, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDot(Int64[] rowVector, Single[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDot(Int64[] rowVector, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Single[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] TransposeAndDotWithDiagonal(Int64[][] a, Single[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Single[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DotWithDiagonal(Int64[][] a, Single[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Single[] diagonal, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] DivideByDiagonal(Int64[][] a, Single[] diagonal, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Outer(Int64[] a, Single[] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Outer(Int64[] a, Single[] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Cross(Int64[] a, Single[] b, Int64[] result);
    [ExtensionAttribute]
public static Int64[0...,0...] Kronecker(Int64[0...,0...] a, Single[0...,0...] b, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[][] a, Single[0...,0...] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[][] Kronecker(Int64[0...,0...] a, Single[][] b, Int64[][] result);
    [ExtensionAttribute]
public static Int64[] Kronecker(Int64[] a, Single[] b, Int64[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Int64[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int64[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int64[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int64[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Int64[] rowVector, Single[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int64[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int64[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int64[] rowVector, Single[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int64[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int64[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int64[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int64[] rowVector, Single[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int64[] rowVector, Single[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int64[][] a, Single[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int64[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int64[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int64[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int64[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int64[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int64[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int64[] rowVector, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int64[] rowVector, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Int64[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Int64[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Int64[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Int64[] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Int64[] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Int64[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Int64[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int64[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int64[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int64[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Int64[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int64[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int64[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Single[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int64[] rowVector, Single[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Single[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int64[] rowVector, Single[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int64[][] a, Single[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int64[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int64[] rowVector, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int64[] rowVector, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int64[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int64[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int64[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int64[] a, Single[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int64[] a, Single[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int64[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int64[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int64[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int64[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int64[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int64[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Single[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int64[] rowVector, Single[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Single[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int64[0...,0...] a, Single[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int64[] rowVector, Single[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int64[][] a, Single[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int64[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int64[] rowVector, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int64[] rowVector, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int64[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int64[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int64[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int64[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int64[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int64[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int64[] a, Single[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int64[] a, Single[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int64[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int64[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int64[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int64[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Dot(Decimal[0...,0...] a, Decimal[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Decimal[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[0...,0...] a, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Decimal[0...,0...] matrix, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[][] matrix, Decimal[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[0...,0...] matrix, Decimal[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Decimal[][] matrix, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Decimal[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Decimal[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[0...,0...] a, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Decimal[0...,0...] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Decimal[] columnVector, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Decimal[][] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Decimal[] columnVector, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Decimal[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[0...,0...] matrix, Decimal[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[][] matrix, Decimal[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Decimal[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[0...,0...] a, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[] rowVector, Decimal[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[] rowVector, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDotWithDiagonal(Decimal[][] a, Decimal[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithDiagonal(Decimal[][] a, Decimal[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DivideByDiagonal(Decimal[][] a, Decimal[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Outer(Decimal[] a, Decimal[] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Outer(Decimal[] a, Decimal[] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Cross(Decimal[] a, Decimal[] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Kronecker(Decimal[0...,0...] a, Decimal[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Decimal[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[0...,0...] a, Decimal[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Kronecker(Decimal[] a, Decimal[] b, Decimal[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Decimal[0...,0...] a, Decimal[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Decimal[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[0...,0...] a, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Decimal[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[][] matrix, Decimal[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[0...,0...] matrix, Decimal[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Decimal[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Decimal[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Decimal[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[0...,0...] a, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Decimal[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Decimal[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Decimal[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Decimal[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Decimal[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[0...,0...] matrix, Decimal[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[][] matrix, Decimal[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Decimal[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[0...,0...] a, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[] rowVector, Decimal[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[] rowVector, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Decimal[][] a, Decimal[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Decimal[][] a, Decimal[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Decimal[][] a, Decimal[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Decimal[] a, Decimal[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Decimal[] a, Decimal[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Decimal[] a, Decimal[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Decimal[0...,0...] a, Decimal[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Decimal[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[0...,0...] a, Decimal[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Decimal[] a, Decimal[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Decimal[0...,0...] a, Decimal[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Decimal[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[0...,0...] a, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Decimal[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[][] matrix, Decimal[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[0...,0...] matrix, Decimal[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Decimal[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Decimal[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Decimal[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[0...,0...] a, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Decimal[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Decimal[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Decimal[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Decimal[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Decimal[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[0...,0...] matrix, Decimal[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[][] matrix, Decimal[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Decimal[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[0...,0...] a, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[] rowVector, Decimal[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[] rowVector, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Decimal[][] a, Decimal[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Decimal[][] a, Decimal[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Decimal[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Decimal[][] a, Decimal[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Decimal[] a, Decimal[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Decimal[] a, Decimal[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Decimal[] a, Decimal[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Decimal[0...,0...] a, Decimal[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Decimal[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[0...,0...] a, Decimal[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Decimal[] a, Decimal[] b, Int32[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Dot(Decimal[0...,0...] a, Double[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Double[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[0...,0...] a, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Double[0...,0...] matrix, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[][] matrix, Double[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[0...,0...] matrix, Double[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Double[][] matrix, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Double[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Double[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[0...,0...] a, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Double[0...,0...] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Double[] columnVector, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Double[][] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Double[] columnVector, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Double[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[0...,0...] matrix, Double[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[][] matrix, Double[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Double[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[0...,0...] a, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[] rowVector, Double[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[] rowVector, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Double[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDotWithDiagonal(Decimal[][] a, Double[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Double[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithDiagonal(Decimal[][] a, Double[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Double[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DivideByDiagonal(Decimal[][] a, Double[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Outer(Decimal[] a, Double[] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Outer(Decimal[] a, Double[] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Cross(Decimal[] a, Double[] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Kronecker(Decimal[0...,0...] a, Double[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Double[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[0...,0...] a, Double[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Kronecker(Decimal[] a, Double[] b, Decimal[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Decimal[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Double[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Double[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Double[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Double[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Double[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Double[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[] rowVector, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[] rowVector, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Decimal[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Decimal[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Decimal[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Decimal[] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Decimal[] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Decimal[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Decimal[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Decimal[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Decimal[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Double[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Double[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Double[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Double[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Double[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Double[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[] rowVector, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[] rowVector, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Decimal[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Decimal[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Decimal[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Decimal[] a, Double[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Decimal[] a, Double[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Decimal[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Decimal[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Decimal[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Dot(Decimal[0...,0...] a, Int32[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Int32[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[0...,0...] a, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Int32[0...,0...] matrix, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[][] matrix, Int32[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[0...,0...] matrix, Int32[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Int32[][] matrix, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Int32[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Int32[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[0...,0...] a, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Int32[0...,0...] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Int32[] columnVector, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Int32[][] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Int32[] columnVector, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Int32[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[0...,0...] matrix, Int32[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[][] matrix, Int32[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Int32[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[0...,0...] a, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[] rowVector, Int32[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[] rowVector, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDotWithDiagonal(Decimal[][] a, Int32[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithDiagonal(Decimal[][] a, Int32[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DivideByDiagonal(Decimal[][] a, Int32[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Outer(Decimal[] a, Int32[] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Outer(Decimal[] a, Int32[] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Cross(Decimal[] a, Int32[] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Kronecker(Decimal[0...,0...] a, Int32[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Int32[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[0...,0...] a, Int32[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Kronecker(Decimal[] a, Int32[] b, Decimal[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Decimal[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Int32[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Int32[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Int32[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Int32[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Int32[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Int32[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[] rowVector, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[] rowVector, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Decimal[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Decimal[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Decimal[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Decimal[] a, Int32[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Decimal[] a, Int32[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Decimal[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Decimal[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Decimal[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Decimal[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Int32[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Int32[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Int32[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Int32[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Int32[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Int32[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[] rowVector, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[] rowVector, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Decimal[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Decimal[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Decimal[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Decimal[] a, Int32[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Decimal[] a, Int32[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Decimal[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Decimal[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Decimal[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Dot(Decimal[0...,0...] a, Single[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[][] a, Single[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Dot(Decimal[0...,0...] a, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Single[0...,0...] matrix, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[][] matrix, Single[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[0...,0...] matrix, Single[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Dot(Decimal[] rowVector, Single[][] matrix, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Single[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[0...,0...] a, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Single[0...,0...] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[] columnVector, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] DotWithTransposed(Decimal[] rowVector, Single[][] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithTransposed(Decimal[][] a, Single[] columnVector, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Single[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[0...,0...] matrix, Single[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] TransposeAndDot(Decimal[][] matrix, Single[] columnVector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[][] a, Single[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[0...,0...] a, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDot(Decimal[] rowVector, Single[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDot(Decimal[] rowVector, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Single[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] TransposeAndDotWithDiagonal(Decimal[][] a, Single[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Single[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DotWithDiagonal(Decimal[][] a, Single[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Single[] diagonal, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] DivideByDiagonal(Decimal[][] a, Single[] diagonal, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Outer(Decimal[] a, Single[] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Outer(Decimal[] a, Single[] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Cross(Decimal[] a, Single[] b, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] Kronecker(Decimal[0...,0...] a, Single[0...,0...] b, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[][] a, Single[0...,0...] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[][] Kronecker(Decimal[0...,0...] a, Single[][] b, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[] Kronecker(Decimal[] a, Single[] b, Decimal[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Decimal[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Decimal[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Decimal[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Decimal[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Decimal[] rowVector, Single[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Decimal[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Decimal[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Decimal[] rowVector, Single[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Decimal[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Decimal[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Decimal[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Decimal[] rowVector, Single[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Decimal[] rowVector, Single[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Decimal[][] a, Single[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Decimal[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Decimal[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Decimal[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Decimal[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Decimal[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Decimal[] rowVector, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Decimal[] rowVector, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Decimal[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Decimal[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Decimal[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Decimal[] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Decimal[] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Decimal[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Decimal[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Decimal[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Decimal[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Decimal[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Decimal[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Decimal[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Decimal[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Single[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Decimal[] rowVector, Single[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Single[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Decimal[] rowVector, Single[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Decimal[][] a, Single[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Decimal[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Decimal[] rowVector, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Decimal[] rowVector, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Decimal[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Decimal[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Decimal[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Decimal[] a, Single[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Decimal[] a, Single[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Decimal[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Decimal[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Decimal[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Decimal[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Decimal[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Decimal[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Single[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Decimal[] rowVector, Single[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Single[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Decimal[0...,0...] a, Single[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Decimal[] rowVector, Single[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Decimal[][] a, Single[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Decimal[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Decimal[] rowVector, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Decimal[] rowVector, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Decimal[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Decimal[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Decimal[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Decimal[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Decimal[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Decimal[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Decimal[] a, Single[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Decimal[] a, Single[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Decimal[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Decimal[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Decimal[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Decimal[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Dot(Byte[0...,0...] a, Byte[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Byte[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[0...,0...] a, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Byte[0...,0...] matrix, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[][] matrix, Byte[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[0...,0...] matrix, Byte[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Byte[][] matrix, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Byte[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Byte[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[0...,0...] a, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Byte[0...,0...] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Byte[] columnVector, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Byte[][] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Byte[] columnVector, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[0...,0...] a, Byte[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[0...,0...] matrix, Byte[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[][] matrix, Byte[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Byte[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[0...,0...] a, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[] rowVector, Byte[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[] rowVector, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Byte[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDotWithDiagonal(Byte[][] a, Byte[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Byte[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DotWithDiagonal(Byte[][] a, Byte[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Byte[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DivideByDiagonal(Byte[][] a, Byte[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Outer(Byte[] a, Byte[] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Outer(Byte[] a, Byte[] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Cross(Byte[] a, Byte[] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Kronecker(Byte[0...,0...] a, Byte[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Byte[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[0...,0...] a, Byte[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Kronecker(Byte[] a, Byte[] b, Byte[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Byte[0...,0...] a, Byte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Byte[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[0...,0...] a, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Byte[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[][] matrix, Byte[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[0...,0...] matrix, Byte[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Byte[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Byte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Byte[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[0...,0...] a, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Byte[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Byte[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Byte[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Byte[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[0...,0...] a, Byte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[0...,0...] matrix, Byte[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[][] matrix, Byte[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Byte[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[0...,0...] a, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[] rowVector, Byte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[] rowVector, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Byte[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Byte[][] a, Byte[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Byte[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Byte[][] a, Byte[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Byte[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Byte[][] a, Byte[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Byte[] a, Byte[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Byte[] a, Byte[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Byte[] a, Byte[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Byte[0...,0...] a, Byte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Byte[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[0...,0...] a, Byte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Byte[] a, Byte[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Byte[0...,0...] a, Byte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Byte[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[0...,0...] a, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Byte[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[][] matrix, Byte[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[0...,0...] matrix, Byte[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Byte[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Byte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Byte[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[0...,0...] a, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Byte[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Byte[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Byte[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Byte[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[0...,0...] a, Byte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[0...,0...] matrix, Byte[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[][] matrix, Byte[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Byte[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[0...,0...] a, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[] rowVector, Byte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[] rowVector, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Byte[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Byte[][] a, Byte[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Byte[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Byte[][] a, Byte[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Byte[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Byte[][] a, Byte[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Byte[] a, Byte[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Byte[] a, Byte[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Byte[] a, Byte[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Byte[0...,0...] a, Byte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Byte[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[0...,0...] a, Byte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Byte[] a, Byte[] b, Int32[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Dot(Byte[0...,0...] a, Double[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Double[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[0...,0...] a, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Double[0...,0...] matrix, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[][] matrix, Double[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[0...,0...] matrix, Double[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Double[][] matrix, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Double[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Double[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[0...,0...] a, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Double[0...,0...] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Double[] columnVector, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Double[][] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Double[] columnVector, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[0...,0...] a, Double[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[0...,0...] matrix, Double[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[][] matrix, Double[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Double[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[0...,0...] a, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[] rowVector, Double[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[] rowVector, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Double[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDotWithDiagonal(Byte[][] a, Double[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Double[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DotWithDiagonal(Byte[][] a, Double[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Double[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DivideByDiagonal(Byte[][] a, Double[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Outer(Byte[] a, Double[] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Outer(Byte[] a, Double[] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Cross(Byte[] a, Double[] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Kronecker(Byte[0...,0...] a, Double[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Double[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[0...,0...] a, Double[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Kronecker(Byte[] a, Double[] b, Byte[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Byte[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Double[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Double[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Double[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Double[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Double[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Double[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[] rowVector, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[] rowVector, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Byte[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Byte[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Byte[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Byte[] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Byte[] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Byte[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Byte[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Byte[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Byte[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Double[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Double[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Double[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Double[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Double[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Double[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[] rowVector, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[] rowVector, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Byte[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Byte[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Byte[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Byte[] a, Double[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Byte[] a, Double[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Byte[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Byte[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Byte[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Dot(Byte[0...,0...] a, Int32[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Int32[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[0...,0...] a, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Int32[0...,0...] matrix, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[][] matrix, Int32[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[0...,0...] matrix, Int32[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Int32[][] matrix, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Int32[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Int32[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[0...,0...] a, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Int32[0...,0...] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Int32[] columnVector, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Int32[][] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Int32[] columnVector, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[0...,0...] a, Int32[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[0...,0...] matrix, Int32[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[][] matrix, Int32[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Int32[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[0...,0...] a, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[] rowVector, Int32[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[] rowVector, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Int32[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDotWithDiagonal(Byte[][] a, Int32[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Int32[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DotWithDiagonal(Byte[][] a, Int32[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Int32[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DivideByDiagonal(Byte[][] a, Int32[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Outer(Byte[] a, Int32[] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Outer(Byte[] a, Int32[] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Cross(Byte[] a, Int32[] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Kronecker(Byte[0...,0...] a, Int32[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Int32[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[0...,0...] a, Int32[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Kronecker(Byte[] a, Int32[] b, Byte[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Byte[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Int32[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Int32[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Int32[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Int32[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Int32[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Int32[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[] rowVector, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[] rowVector, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Byte[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Byte[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Byte[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Byte[] a, Int32[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Byte[] a, Int32[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Byte[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Byte[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Byte[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Byte[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Int32[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Int32[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Int32[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Int32[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Int32[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Int32[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[] rowVector, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[] rowVector, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Byte[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Byte[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Byte[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Byte[] a, Int32[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Byte[] a, Int32[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Byte[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Byte[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Byte[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Dot(Byte[0...,0...] a, Single[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[][] a, Single[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Dot(Byte[0...,0...] a, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Single[0...,0...] matrix, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[][] matrix, Single[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[0...,0...] matrix, Single[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Dot(Byte[] rowVector, Single[][] matrix, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Single[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[0...,0...] a, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Single[0...,0...] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[] columnVector, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[] DotWithTransposed(Byte[] rowVector, Single[][] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[][] DotWithTransposed(Byte[][] a, Single[] columnVector, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[0...,0...] a, Single[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[0...,0...] matrix, Single[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[] TransposeAndDot(Byte[][] matrix, Single[] columnVector, Byte[] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[][] a, Single[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[0...,0...] a, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDot(Byte[] rowVector, Single[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDot(Byte[] rowVector, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Single[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] TransposeAndDotWithDiagonal(Byte[][] a, Single[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Single[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DotWithDiagonal(Byte[][] a, Single[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Single[] diagonal, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] DivideByDiagonal(Byte[][] a, Single[] diagonal, Byte[][] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Outer(Byte[] a, Single[] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Outer(Byte[] a, Single[] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Cross(Byte[] a, Single[] b, Byte[] result);
    [ExtensionAttribute]
public static Byte[0...,0...] Kronecker(Byte[0...,0...] a, Single[0...,0...] b, Byte[0...,0...] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[][] a, Single[0...,0...] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[][] Kronecker(Byte[0...,0...] a, Single[][] b, Byte[][] result);
    [ExtensionAttribute]
public static Byte[] Kronecker(Byte[] a, Single[] b, Byte[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Byte[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Byte[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Byte[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Byte[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Byte[] rowVector, Single[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Byte[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Byte[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Byte[] rowVector, Single[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Byte[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Byte[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Byte[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Byte[] rowVector, Single[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Byte[] rowVector, Single[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Byte[][] a, Single[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Byte[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Byte[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Byte[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Byte[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Byte[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Byte[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Byte[] rowVector, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Byte[] rowVector, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Byte[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Byte[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Byte[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Byte[] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Byte[] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Byte[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Byte[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Byte[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Byte[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Byte[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Byte[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Byte[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Byte[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Single[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Byte[] rowVector, Single[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Single[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Byte[] rowVector, Single[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Byte[][] a, Single[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Byte[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Byte[] rowVector, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Byte[] rowVector, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Byte[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Byte[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Byte[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Byte[] a, Single[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Byte[] a, Single[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Byte[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Byte[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Byte[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Byte[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Byte[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Byte[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Single[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Byte[] rowVector, Single[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Single[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Byte[0...,0...] a, Single[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Byte[] rowVector, Single[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Byte[][] a, Single[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Byte[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Byte[] rowVector, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Byte[] rowVector, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Byte[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Byte[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Byte[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Byte[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Byte[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Byte[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Byte[] a, Single[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Byte[] a, Single[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Byte[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Byte[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Byte[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Byte[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Dot(Int16[0...,0...] a, Int16[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Int16[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[0...,0...] a, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Int16[0...,0...] matrix, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[][] matrix, Int16[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[0...,0...] matrix, Int16[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Int16[][] matrix, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int16[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int16[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[0...,0...] a, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Int16[0...,0...] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int16[] columnVector, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Int16[][] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int16[] columnVector, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[0...,0...] a, Int16[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[0...,0...] matrix, Int16[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[][] matrix, Int16[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Int16[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[0...,0...] a, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[] rowVector, Int16[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[] rowVector, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Int16[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDotWithDiagonal(Int16[][] a, Int16[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Int16[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DotWithDiagonal(Int16[][] a, Int16[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Int16[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DivideByDiagonal(Int16[][] a, Int16[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Outer(Int16[] a, Int16[] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Outer(Int16[] a, Int16[] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Cross(Int16[] a, Int16[] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Kronecker(Int16[0...,0...] a, Int16[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Int16[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[0...,0...] a, Int16[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Kronecker(Int16[] a, Int16[] b, Int16[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int16[0...,0...] a, Int16[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Int16[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[0...,0...] a, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Int16[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[][] matrix, Int16[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[0...,0...] matrix, Int16[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Int16[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int16[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Int16[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[0...,0...] a, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Int16[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int16[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Int16[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Int16[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[0...,0...] a, Int16[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[0...,0...] matrix, Int16[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[][] matrix, Int16[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Int16[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[0...,0...] a, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[] rowVector, Int16[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[] rowVector, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Int16[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int16[][] a, Int16[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Int16[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int16[][] a, Int16[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Int16[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int16[][] a, Int16[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int16[] a, Int16[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int16[] a, Int16[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int16[] a, Int16[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int16[0...,0...] a, Int16[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Int16[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[0...,0...] a, Int16[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int16[] a, Int16[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int16[0...,0...] a, Int16[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Int16[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[0...,0...] a, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Int16[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[][] matrix, Int16[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[0...,0...] matrix, Int16[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Int16[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int16[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int16[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[0...,0...] a, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Int16[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int16[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Int16[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int16[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[0...,0...] a, Int16[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[0...,0...] matrix, Int16[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[][] matrix, Int16[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Int16[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[0...,0...] a, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[] rowVector, Int16[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[] rowVector, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Int16[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int16[][] a, Int16[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Int16[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int16[][] a, Int16[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Int16[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int16[][] a, Int16[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int16[] a, Int16[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int16[] a, Int16[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int16[] a, Int16[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int16[0...,0...] a, Int16[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Int16[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[0...,0...] a, Int16[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int16[] a, Int16[] b, Int32[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Dot(Int16[0...,0...] a, Double[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Double[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[0...,0...] a, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Double[0...,0...] matrix, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[][] matrix, Double[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[0...,0...] matrix, Double[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Double[][] matrix, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Double[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Double[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[0...,0...] a, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Double[0...,0...] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Double[] columnVector, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Double[][] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Double[] columnVector, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[0...,0...] a, Double[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[0...,0...] matrix, Double[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[][] matrix, Double[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Double[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[0...,0...] a, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[] rowVector, Double[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[] rowVector, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Double[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDotWithDiagonal(Int16[][] a, Double[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Double[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DotWithDiagonal(Int16[][] a, Double[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Double[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DivideByDiagonal(Int16[][] a, Double[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Outer(Int16[] a, Double[] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Outer(Int16[] a, Double[] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Cross(Int16[] a, Double[] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Kronecker(Int16[0...,0...] a, Double[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Double[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[0...,0...] a, Double[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Kronecker(Int16[] a, Double[] b, Int16[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int16[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Double[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Double[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Double[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Double[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Double[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Double[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[] rowVector, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[] rowVector, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int16[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int16[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int16[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int16[] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int16[] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int16[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int16[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int16[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int16[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Double[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Double[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Double[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Double[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Double[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Double[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[] rowVector, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[] rowVector, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int16[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int16[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int16[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int16[] a, Double[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int16[] a, Double[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int16[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int16[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int16[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Dot(Int16[0...,0...] a, Int32[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Int32[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[0...,0...] a, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Int32[0...,0...] matrix, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[][] matrix, Int32[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[0...,0...] matrix, Int32[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Int32[][] matrix, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int32[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int32[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[0...,0...] a, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Int32[0...,0...] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int32[] columnVector, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Int32[][] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Int32[] columnVector, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[0...,0...] a, Int32[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[0...,0...] matrix, Int32[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[][] matrix, Int32[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Int32[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[0...,0...] a, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[] rowVector, Int32[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[] rowVector, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Int32[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDotWithDiagonal(Int16[][] a, Int32[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Int32[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DotWithDiagonal(Int16[][] a, Int32[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Int32[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DivideByDiagonal(Int16[][] a, Int32[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Outer(Int16[] a, Int32[] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Outer(Int16[] a, Int32[] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Cross(Int16[] a, Int32[] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Kronecker(Int16[0...,0...] a, Int32[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Int32[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[0...,0...] a, Int32[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Kronecker(Int16[] a, Int32[] b, Int16[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int16[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Int32[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Int32[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Int32[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int32[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Int32[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Int32[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[] rowVector, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[] rowVector, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int16[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int16[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int16[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int16[] a, Int32[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int16[] a, Int32[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int16[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int16[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int16[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int16[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Int32[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Int32[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Int32[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Int32[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Int32[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Int32[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[] rowVector, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[] rowVector, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int16[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int16[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int16[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int16[] a, Int32[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int16[] a, Int32[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int16[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int16[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int16[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Dot(Int16[0...,0...] a, Single[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[][] a, Single[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Dot(Int16[0...,0...] a, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Single[0...,0...] matrix, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[][] matrix, Single[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[0...,0...] matrix, Single[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Dot(Int16[] rowVector, Single[][] matrix, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Single[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[0...,0...] a, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Single[0...,0...] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[] columnVector, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] DotWithTransposed(Int16[] rowVector, Single[][] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] DotWithTransposed(Int16[][] a, Single[] columnVector, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[0...,0...] a, Single[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[0...,0...] matrix, Single[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[] TransposeAndDot(Int16[][] matrix, Single[] columnVector, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[][] a, Single[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[0...,0...] a, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDot(Int16[] rowVector, Single[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDot(Int16[] rowVector, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Single[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] TransposeAndDotWithDiagonal(Int16[][] a, Single[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Single[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DotWithDiagonal(Int16[][] a, Single[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Single[] diagonal, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] DivideByDiagonal(Int16[][] a, Single[] diagonal, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Outer(Int16[] a, Single[] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Outer(Int16[] a, Single[] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Cross(Int16[] a, Single[] b, Int16[] result);
    [ExtensionAttribute]
public static Int16[0...,0...] Kronecker(Int16[0...,0...] a, Single[0...,0...] b, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[][] a, Single[0...,0...] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[][] Kronecker(Int16[0...,0...] a, Single[][] b, Int16[][] result);
    [ExtensionAttribute]
public static Int16[] Kronecker(Int16[] a, Single[] b, Int16[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(Int16[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int16[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int16[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(Int16[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(Int16[] rowVector, Single[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int16[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int16[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(Int16[] rowVector, Single[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int16[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int16[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int16[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int16[] rowVector, Single[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(Int16[] rowVector, Single[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(Int16[][] a, Single[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int16[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int16[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int16[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(Int16[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int16[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int16[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(Int16[] rowVector, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(Int16[] rowVector, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(Int16[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(Int16[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(Int16[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(Int16[] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(Int16[] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(Int16[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(Int16[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int16[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int16[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(Int16[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(Int16[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(Int16[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(Int16[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Single[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(Int16[] rowVector, Single[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Single[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(Int16[] rowVector, Single[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(Int16[][] a, Single[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(Int16[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(Int16[] rowVector, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(Int16[] rowVector, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(Int16[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(Int16[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(Int16[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(Int16[] a, Single[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(Int16[] a, Single[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(Int16[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(Int16[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(Int16[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(Int16[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(Int16[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(Int16[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Single[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(Int16[] rowVector, Single[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Single[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(Int16[0...,0...] a, Single[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(Int16[] rowVector, Single[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(Int16[][] a, Single[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(Int16[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(Int16[] rowVector, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(Int16[] rowVector, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(Int16[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(Int16[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(Int16[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(Int16[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(Int16[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(Int16[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(Int16[] a, Single[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(Int16[] a, Single[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(Int16[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(Int16[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(Int16[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(Int16[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Dot(SByte[0...,0...] a, SByte[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, SByte[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[0...,0...] a, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, SByte[0...,0...] matrix, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[][] matrix, SByte[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[0...,0...] matrix, SByte[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, SByte[][] matrix, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, SByte[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, SByte[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[0...,0...] a, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, SByte[0...,0...] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, SByte[] columnVector, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, SByte[][] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, SByte[] columnVector, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[0...,0...] a, SByte[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[0...,0...] matrix, SByte[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[][] matrix, SByte[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, SByte[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[0...,0...] a, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[] rowVector, SByte[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[] rowVector, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, SByte[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDotWithDiagonal(SByte[][] a, SByte[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithDiagonal(SByte[0...,0...] a, SByte[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DotWithDiagonal(SByte[][] a, SByte[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DivideByDiagonal(SByte[0...,0...] a, SByte[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DivideByDiagonal(SByte[][] a, SByte[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Outer(SByte[] a, SByte[] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Outer(SByte[] a, SByte[] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Cross(SByte[] a, SByte[] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Kronecker(SByte[0...,0...] a, SByte[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, SByte[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[0...,0...] a, SByte[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Kronecker(SByte[] a, SByte[] b, SByte[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(SByte[0...,0...] a, SByte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, SByte[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[0...,0...] a, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, SByte[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[][] matrix, SByte[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[0...,0...] matrix, SByte[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, SByte[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, SByte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, SByte[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[0...,0...] a, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, SByte[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, SByte[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, SByte[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, SByte[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[0...,0...] a, SByte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[0...,0...] matrix, SByte[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[][] matrix, SByte[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, SByte[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[0...,0...] a, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[] rowVector, SByte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[] rowVector, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, SByte[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(SByte[][] a, SByte[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(SByte[0...,0...] a, SByte[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(SByte[][] a, SByte[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(SByte[0...,0...] a, SByte[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(SByte[][] a, SByte[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(SByte[] a, SByte[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(SByte[] a, SByte[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(SByte[] a, SByte[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(SByte[0...,0...] a, SByte[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, SByte[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[0...,0...] a, SByte[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(SByte[] a, SByte[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(SByte[0...,0...] a, SByte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, SByte[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[0...,0...] a, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, SByte[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[][] matrix, SByte[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[0...,0...] matrix, SByte[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, SByte[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, SByte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, SByte[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[0...,0...] a, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, SByte[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, SByte[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, SByte[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, SByte[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[0...,0...] a, SByte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[0...,0...] matrix, SByte[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[][] matrix, SByte[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, SByte[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[0...,0...] a, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[] rowVector, SByte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[] rowVector, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, SByte[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(SByte[][] a, SByte[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(SByte[0...,0...] a, SByte[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(SByte[][] a, SByte[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(SByte[0...,0...] a, SByte[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(SByte[][] a, SByte[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(SByte[] a, SByte[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(SByte[] a, SByte[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(SByte[] a, SByte[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(SByte[0...,0...] a, SByte[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, SByte[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[0...,0...] a, SByte[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(SByte[] a, SByte[] b, Int32[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Dot(SByte[0...,0...] a, Double[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, Double[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[0...,0...] a, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, Double[0...,0...] matrix, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[][] matrix, Double[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[0...,0...] matrix, Double[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, Double[][] matrix, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, Double[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Double[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[0...,0...] a, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, Double[0...,0...] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, Double[] columnVector, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, Double[][] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Double[] columnVector, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[0...,0...] a, Double[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[0...,0...] matrix, Double[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[][] matrix, Double[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, Double[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[0...,0...] a, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[] rowVector, Double[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[] rowVector, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Double[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDotWithDiagonal(SByte[][] a, Double[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Double[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DotWithDiagonal(SByte[][] a, Double[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Double[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DivideByDiagonal(SByte[][] a, Double[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Outer(SByte[] a, Double[] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Outer(SByte[] a, Double[] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Cross(SByte[] a, Double[] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Kronecker(SByte[0...,0...] a, Double[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, Double[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[0...,0...] a, Double[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Kronecker(SByte[] a, Double[] b, SByte[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(SByte[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, Double[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, Double[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, Double[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, Double[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, Double[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Double[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[0...,0...] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[][] matrix, Double[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[] rowVector, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[] rowVector, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(SByte[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(SByte[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Double[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(SByte[][] a, Double[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(SByte[] a, Double[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(SByte[] a, Double[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(SByte[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(SByte[0...,0...] a, Double[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, Double[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[0...,0...] a, Double[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(SByte[] a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(SByte[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, Double[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, Double[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, Double[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, Double[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, Double[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Double[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[0...,0...] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[][] matrix, Double[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[] rowVector, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[] rowVector, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(SByte[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(SByte[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Double[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(SByte[][] a, Double[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(SByte[] a, Double[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(SByte[] a, Double[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(SByte[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(SByte[0...,0...] a, Double[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, Double[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[0...,0...] a, Double[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(SByte[] a, Double[] b, Int32[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Dot(SByte[0...,0...] a, Int32[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, Int32[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[0...,0...] a, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, Int32[0...,0...] matrix, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[][] matrix, Int32[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[0...,0...] matrix, Int32[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, Int32[][] matrix, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, Int32[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Int32[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[0...,0...] a, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, Int32[0...,0...] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, Int32[] columnVector, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, Int32[][] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Int32[] columnVector, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[0...,0...] a, Int32[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[0...,0...] matrix, Int32[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[][] matrix, Int32[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, Int32[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[0...,0...] a, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[] rowVector, Int32[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[] rowVector, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Int32[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDotWithDiagonal(SByte[][] a, Int32[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Int32[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DotWithDiagonal(SByte[][] a, Int32[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Int32[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DivideByDiagonal(SByte[][] a, Int32[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Outer(SByte[] a, Int32[] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Outer(SByte[] a, Int32[] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Cross(SByte[] a, Int32[] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Kronecker(SByte[0...,0...] a, Int32[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, Int32[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[0...,0...] a, Int32[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Kronecker(SByte[] a, Int32[] b, SByte[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(SByte[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, Int32[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, Int32[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, Int32[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, Int32[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, Int32[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Int32[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[0...,0...] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[][] matrix, Int32[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[] rowVector, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[] rowVector, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(SByte[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(SByte[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Int32[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(SByte[][] a, Int32[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(SByte[] a, Int32[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(SByte[] a, Int32[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(SByte[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(SByte[0...,0...] a, Int32[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, Int32[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[0...,0...] a, Int32[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(SByte[] a, Int32[] b, Int32[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(SByte[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, Int32[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, Int32[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, Int32[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, Int32[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, Int32[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Int32[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[0...,0...] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[][] matrix, Int32[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[] rowVector, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[] rowVector, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(SByte[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(SByte[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Int32[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(SByte[][] a, Int32[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(SByte[] a, Int32[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(SByte[] a, Int32[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(SByte[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(SByte[0...,0...] a, Int32[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, Int32[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[0...,0...] a, Int32[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(SByte[] a, Int32[] b, Double[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Dot(SByte[0...,0...] a, Single[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[][] a, Single[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Dot(SByte[0...,0...] a, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, Single[0...,0...] matrix, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[][] matrix, Single[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[0...,0...] matrix, Single[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Dot(SByte[] rowVector, Single[][] matrix, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Single[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[0...,0...] a, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, Single[0...,0...] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[] columnVector, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[] DotWithTransposed(SByte[] rowVector, Single[][] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[][] DotWithTransposed(SByte[][] a, Single[] columnVector, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[0...,0...] a, Single[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[0...,0...] matrix, Single[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[] TransposeAndDot(SByte[][] matrix, Single[] columnVector, SByte[] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[][] a, Single[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[0...,0...] a, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDot(SByte[] rowVector, Single[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDot(SByte[] rowVector, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Single[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] TransposeAndDotWithDiagonal(SByte[][] a, Single[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Single[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DotWithDiagonal(SByte[][] a, Single[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Single[] diagonal, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] DivideByDiagonal(SByte[][] a, Single[] diagonal, SByte[][] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Outer(SByte[] a, Single[] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Outer(SByte[] a, Single[] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Cross(SByte[] a, Single[] b, SByte[] result);
    [ExtensionAttribute]
public static SByte[0...,0...] Kronecker(SByte[0...,0...] a, Single[0...,0...] b, SByte[0...,0...] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[][] a, Single[0...,0...] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[][] Kronecker(SByte[0...,0...] a, Single[][] b, SByte[][] result);
    [ExtensionAttribute]
public static SByte[] Kronecker(SByte[] a, Single[] b, SByte[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Dot(SByte[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Dot(SByte[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(SByte[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Dot(SByte[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Dot(SByte[] rowVector, Single[0...,0...] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(SByte[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(SByte[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] Dot(SByte[] rowVector, Single[][] matrix, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(SByte[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(SByte[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(SByte[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(SByte[] rowVector, Single[0...,0...] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[] columnVector, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[] DotWithTransposed(SByte[] rowVector, Single[][] b, Single[] result);
    [ExtensionAttribute]
public static Single[][] DotWithTransposed(SByte[][] a, Single[] columnVector, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(SByte[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(SByte[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(SByte[0...,0...] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[] TransposeAndDot(SByte[][] matrix, Single[] columnVector, Single[] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(SByte[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(SByte[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDot(SByte[] rowVector, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDot(SByte[] rowVector, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] TransposeAndDotWithDiagonal(SByte[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DotWithDiagonal(SByte[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Single[] diagonal, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] DivideByDiagonal(SByte[][] a, Single[] diagonal, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] Outer(SByte[] a, Single[] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Outer(SByte[] a, Single[] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Cross(SByte[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Single[0...,0...] Kronecker(SByte[0...,0...] a, Single[0...,0...] b, Single[0...,0...] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(SByte[][] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(SByte[][] a, Single[0...,0...] b, Single[][] result);
    [ExtensionAttribute]
public static Single[][] Kronecker(SByte[0...,0...] a, Single[][] b, Single[][] result);
    [ExtensionAttribute]
public static Single[] Kronecker(SByte[] a, Single[] b, Single[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Dot(SByte[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Dot(SByte[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, Single[0...,0...] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] Dot(SByte[] rowVector, Single[][] matrix, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, Single[0...,0...] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[] columnVector, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[] DotWithTransposed(SByte[] rowVector, Single[][] b, Double[] result);
    [ExtensionAttribute]
public static Double[][] DotWithTransposed(SByte[][] a, Single[] columnVector, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[0...,0...] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[] TransposeAndDot(SByte[][] matrix, Single[] columnVector, Double[] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDot(SByte[] rowVector, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDot(SByte[] rowVector, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] TransposeAndDotWithDiagonal(SByte[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DotWithDiagonal(SByte[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Single[] diagonal, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] DivideByDiagonal(SByte[][] a, Single[] diagonal, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] Outer(SByte[] a, Single[] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Outer(SByte[] a, Single[] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Cross(SByte[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Kronecker(SByte[0...,0...] a, Single[0...,0...] b, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[][] a, Single[0...,0...] b, Double[][] result);
    [ExtensionAttribute]
public static Double[][] Kronecker(SByte[0...,0...] a, Single[][] b, Double[][] result);
    [ExtensionAttribute]
public static Double[] Kronecker(SByte[] a, Single[] b, Double[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Dot(SByte[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Dot(SByte[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, Single[0...,0...] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Dot(SByte[] rowVector, Single[][] matrix, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, Single[0...,0...] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithTransposed(SByte[0...,0...] a, Single[] columnVector, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[] DotWithTransposed(SByte[] rowVector, Single[][] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] DotWithTransposed(SByte[][] a, Single[] columnVector, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[0...,0...] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[] TransposeAndDot(SByte[][] matrix, Single[] columnVector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDot(SByte[] rowVector, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDot(SByte[] rowVector, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] TransposeAndDotWithDiagonal(SByte[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] TransposeAndDotWithDiagonal(SByte[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DotWithDiagonal(SByte[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DotWithDiagonal(SByte[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] DivideByDiagonal(SByte[0...,0...] a, Single[] diagonal, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] DivideByDiagonal(SByte[][] a, Single[] diagonal, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Outer(SByte[] a, Single[] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Outer(SByte[] a, Single[] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Cross(SByte[] a, Single[] b, Int32[] result);
    [ExtensionAttribute]
public static Int32[0...,0...] Kronecker(SByte[0...,0...] a, Single[0...,0...] b, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[][] a, Single[0...,0...] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[][] Kronecker(SByte[0...,0...] a, Single[][] b, Int32[][] result);
    [ExtensionAttribute]
public static Int32[] Kronecker(SByte[] a, Single[] b, Int32[] result);
    public static Double[0...,0...] Random(int rows, int columns);
    public static Double[0...,0...] Random(int size);
    public static Int32[0...,0...] Random(int rows, int columns, int min, int max, Int32[0...,0...] result);
    public static Int32[0...,0...] Random(int size, int min, int max, bool symmetric, Int32[0...,0...] result);
    public static Int16[0...,0...] Random(int rows, int columns, short min, short max, Int16[0...,0...] result);
    public static Int16[0...,0...] Random(int size, short min, short max, bool symmetric, Int16[0...,0...] result);
    public static Byte[0...,0...] Random(int rows, int columns, byte min, byte max, Byte[0...,0...] result);
    public static Byte[0...,0...] Random(int size, byte min, byte max, bool symmetric, Byte[0...,0...] result);
    public static SByte[0...,0...] Random(int rows, int columns, sbyte min, sbyte max, SByte[0...,0...] result);
    public static SByte[0...,0...] Random(int size, sbyte min, sbyte max, bool symmetric, SByte[0...,0...] result);
    public static Int64[0...,0...] Random(int rows, int columns, long min, long max, Int64[0...,0...] result);
    public static Int64[0...,0...] Random(int size, long min, long max, bool symmetric, Int64[0...,0...] result);
    public static UInt64[0...,0...] Random(int rows, int columns, ulong min, ulong max, UInt64[0...,0...] result);
    public static UInt64[0...,0...] Random(int size, ulong min, ulong max, bool symmetric, UInt64[0...,0...] result);
    public static UInt16[0...,0...] Random(int rows, int columns, ushort min, ushort max, UInt16[0...,0...] result);
    public static UInt16[0...,0...] Random(int size, ushort min, ushort max, bool symmetric, UInt16[0...,0...] result);
    public static Single[0...,0...] Random(int rows, int columns, float min, float max, Single[0...,0...] result);
    public static Single[0...,0...] Random(int size, float min, float max, bool symmetric, Single[0...,0...] result);
    public static Double[0...,0...] Random(int rows, int columns, double min, double max, Double[0...,0...] result);
    public static Double[0...,0...] Random(int size, double min, double max, bool symmetric, Double[0...,0...] result);
    public static Decimal[0...,0...] Random(int rows, int columns, decimal min, decimal max, Decimal[0...,0...] result);
    public static Decimal[0...,0...] Random(int size, decimal min, decimal max, bool symmetric, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static int Sum(Int32[] vector);
    [ExtensionAttribute]
public static int Sum(Int32[0...,0...] matrix);
    [ExtensionAttribute]
public static int Sum(Int32[][] matrix);
    [ExtensionAttribute]
public static Int32[] Sum(Int32[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] Sum(Int32[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static int Product(Int32[] vector);
    [ExtensionAttribute]
public static int Product(Int32[0...,0...] matrix);
    [ExtensionAttribute]
public static int Product(Int32[][] matrix);
    [ExtensionAttribute]
public static Int32[] Product(Int32[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] Product(Int32[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static short Sum(Int16[] vector);
    [ExtensionAttribute]
public static short Sum(Int16[0...,0...] matrix);
    [ExtensionAttribute]
public static short Sum(Int16[][] matrix);
    [ExtensionAttribute]
public static Int16[] Sum(Int16[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int16[] Sum(Int16[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static short Product(Int16[] vector);
    [ExtensionAttribute]
public static short Product(Int16[0...,0...] matrix);
    [ExtensionAttribute]
public static short Product(Int16[][] matrix);
    [ExtensionAttribute]
public static Int16[] Product(Int16[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int16[] Product(Int16[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static float Sum(Single[] vector);
    [ExtensionAttribute]
public static float Sum(Single[0...,0...] matrix);
    [ExtensionAttribute]
public static float Sum(Single[][] matrix);
    [ExtensionAttribute]
public static Single[] Sum(Single[][] matrix, int dimension);
    [ExtensionAttribute]
public static Single[] Sum(Single[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static float Product(Single[] vector);
    [ExtensionAttribute]
public static float Product(Single[0...,0...] matrix);
    [ExtensionAttribute]
public static float Product(Single[][] matrix);
    [ExtensionAttribute]
public static Single[] Product(Single[][] matrix, int dimension);
    [ExtensionAttribute]
public static Single[] Product(Single[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static double Sum(Double[] vector);
    [ExtensionAttribute]
public static double Sum(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static double Sum(Double[][] matrix);
    [ExtensionAttribute]
public static Double[] Sum(Double[][] matrix, int dimension);
    [ExtensionAttribute]
public static Double[] Sum(Double[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static double Product(Double[] vector);
    [ExtensionAttribute]
public static double Product(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static double Product(Double[][] matrix);
    [ExtensionAttribute]
public static Double[] Product(Double[][] matrix, int dimension);
    [ExtensionAttribute]
public static Double[] Product(Double[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static long Sum(Int64[] vector);
    [ExtensionAttribute]
public static long Sum(Int64[0...,0...] matrix);
    [ExtensionAttribute]
public static long Sum(Int64[][] matrix);
    [ExtensionAttribute]
public static Int64[] Sum(Int64[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int64[] Sum(Int64[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static long Product(Int64[] vector);
    [ExtensionAttribute]
public static long Product(Int64[0...,0...] matrix);
    [ExtensionAttribute]
public static long Product(Int64[][] matrix);
    [ExtensionAttribute]
public static Int64[] Product(Int64[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int64[] Product(Int64[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static decimal Sum(Decimal[] vector);
    [ExtensionAttribute]
public static decimal Sum(Decimal[0...,0...] matrix);
    [ExtensionAttribute]
public static decimal Sum(Decimal[][] matrix);
    [ExtensionAttribute]
public static Decimal[] Sum(Decimal[][] matrix, int dimension);
    [ExtensionAttribute]
public static Decimal[] Sum(Decimal[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static decimal Product(Decimal[] vector);
    [ExtensionAttribute]
public static decimal Product(Decimal[0...,0...] matrix);
    [ExtensionAttribute]
public static decimal Product(Decimal[][] matrix);
    [ExtensionAttribute]
public static Decimal[] Product(Decimal[][] matrix, int dimension);
    [ExtensionAttribute]
public static Decimal[] Product(Decimal[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static int Sum(Boolean[] vector);
    [ExtensionAttribute]
public static int Sum(Boolean[0...,0...] matrix);
    [ExtensionAttribute]
public static int Sum(Boolean[][] matrix);
    [ExtensionAttribute]
public static Int32[] Sum(Boolean[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] Sum(Boolean[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static int Product(Boolean[] vector);
    [ExtensionAttribute]
public static int Product(Boolean[0...,0...] matrix);
    [ExtensionAttribute]
public static int Product(Boolean[][] matrix);
    [ExtensionAttribute]
public static Int32[] Product(Boolean[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] Product(Boolean[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[] Sum(Int32[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Int32[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Int32[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Int32[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Int32[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Int32[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Int32[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Int32[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Single[] Sum(Int32[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Sum(Int32[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Int32[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Int32[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Double[] Sum(Int32[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Sum(Int32[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Int32[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Int32[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Int32[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Int32[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Int32[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Int32[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Int32[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Int32[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Int32[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Int32[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Int16[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Int16[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Int16[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Int16[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Int16[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Int16[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Int16[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Int16[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Single[] Sum(Int16[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Sum(Int16[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Int16[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Int16[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Double[] Sum(Int16[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Sum(Int16[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Int16[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Int16[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Int16[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Int16[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Int16[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Int16[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Int16[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Int16[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Int16[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Int16[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Single[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Single[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Single[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Single[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Single[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Single[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Single[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Single[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Single[] Sum(Single[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Sum(Single[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Single[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Single[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Double[] Sum(Single[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Sum(Single[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Single[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Single[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Single[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Single[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Single[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Single[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Single[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Single[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Single[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Single[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Double[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Double[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Double[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Double[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Double[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Double[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Double[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Double[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Single[] Sum(Double[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Sum(Double[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Double[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Double[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Double[] Sum(Double[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Sum(Double[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Double[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Double[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Double[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Double[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Double[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Double[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Double[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Double[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Double[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Double[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Int64[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Int64[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Int64[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Int64[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Int64[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Int64[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Int64[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Int64[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Single[] Sum(Int64[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Sum(Int64[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Int64[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Int64[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Double[] Sum(Int64[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Sum(Int64[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Int64[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Int64[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Int64[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Int64[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Int64[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Int64[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Int64[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Int64[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Int64[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Int64[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Decimal[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Decimal[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Decimal[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Decimal[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Decimal[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Decimal[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Decimal[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Decimal[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Single[] Sum(Decimal[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Sum(Decimal[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Decimal[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Decimal[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Double[] Sum(Decimal[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Sum(Decimal[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Decimal[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Decimal[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Decimal[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Decimal[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Decimal[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Decimal[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Decimal[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Decimal[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Decimal[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Decimal[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Boolean[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Sum(Boolean[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Boolean[][] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Product(Boolean[0...,0...] matrix, int dimension, Int32[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Boolean[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Sum(Boolean[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Boolean[][] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Product(Boolean[0...,0...] matrix, int dimension, Int16[] result);
    [ExtensionAttribute]
public static Single[] Sum(Boolean[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Sum(Boolean[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Boolean[][] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Single[] Product(Boolean[0...,0...] matrix, int dimension, Single[] result);
    [ExtensionAttribute]
public static Double[] Sum(Boolean[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Sum(Boolean[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Boolean[][] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Double[] Product(Boolean[0...,0...] matrix, int dimension, Double[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Boolean[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Sum(Boolean[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Boolean[][] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Product(Boolean[0...,0...] matrix, int dimension, Int64[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Boolean[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Sum(Boolean[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Boolean[][] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[] Product(Boolean[0...,0...] matrix, int dimension, Decimal[] result);
    [ExtensionAttribute]
public static Int32[] CumulativeSum(Int32[] vector);
    [ExtensionAttribute]
public static Int32[] CumulativeSum(Int32[] vector, Int32[] result);
    [ExtensionAttribute]
public static Int32[][] CumulativeSum(Int32[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[][] CumulativeSum(Int32[][] matrix, int dimension, Int32[][] result);
    [ExtensionAttribute]
public static Int32[0...,0...] CumulativeSum(Int32[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Int32[0...,0...] CumulativeSum(Int32[0...,0...] matrix, int dimension, Int32[0...,0...] result);
    [ExtensionAttribute]
public static Int16[] CumulativeSum(Int16[] vector);
    [ExtensionAttribute]
public static Int16[] CumulativeSum(Int16[] vector, Int16[] result);
    [ExtensionAttribute]
public static Int16[][] CumulativeSum(Int16[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int16[][] CumulativeSum(Int16[][] matrix, int dimension, Int16[][] result);
    [ExtensionAttribute]
public static Int16[0...,0...] CumulativeSum(Int16[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Int16[0...,0...] CumulativeSum(Int16[0...,0...] matrix, int dimension, Int16[0...,0...] result);
    [ExtensionAttribute]
public static Single[] CumulativeSum(Single[] vector);
    [ExtensionAttribute]
public static Single[] CumulativeSum(Single[] vector, Single[] result);
    [ExtensionAttribute]
public static Single[][] CumulativeSum(Single[][] matrix, int dimension);
    [ExtensionAttribute]
public static Single[][] CumulativeSum(Single[][] matrix, int dimension, Single[][] result);
    [ExtensionAttribute]
public static Single[0...,0...] CumulativeSum(Single[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Single[0...,0...] CumulativeSum(Single[0...,0...] matrix, int dimension, Single[0...,0...] result);
    [ExtensionAttribute]
public static Double[] CumulativeSum(Double[] vector);
    [ExtensionAttribute]
public static Double[] CumulativeSum(Double[] vector, Double[] result);
    [ExtensionAttribute]
public static Double[][] CumulativeSum(Double[][] matrix, int dimension);
    [ExtensionAttribute]
public static Double[][] CumulativeSum(Double[][] matrix, int dimension, Double[][] result);
    [ExtensionAttribute]
public static Double[0...,0...] CumulativeSum(Double[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Double[0...,0...] CumulativeSum(Double[0...,0...] matrix, int dimension, Double[0...,0...] result);
    [ExtensionAttribute]
public static Int64[] CumulativeSum(Int64[] vector);
    [ExtensionAttribute]
public static Int64[] CumulativeSum(Int64[] vector, Int64[] result);
    [ExtensionAttribute]
public static Int64[][] CumulativeSum(Int64[][] matrix, int dimension);
    [ExtensionAttribute]
public static Int64[][] CumulativeSum(Int64[][] matrix, int dimension, Int64[][] result);
    [ExtensionAttribute]
public static Int64[0...,0...] CumulativeSum(Int64[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Int64[0...,0...] CumulativeSum(Int64[0...,0...] matrix, int dimension, Int64[0...,0...] result);
    [ExtensionAttribute]
public static Decimal[] CumulativeSum(Decimal[] vector);
    [ExtensionAttribute]
public static Decimal[] CumulativeSum(Decimal[] vector, Decimal[] result);
    [ExtensionAttribute]
public static Decimal[][] CumulativeSum(Decimal[][] matrix, int dimension);
    [ExtensionAttribute]
public static Decimal[][] CumulativeSum(Decimal[][] matrix, int dimension, Decimal[][] result);
    [ExtensionAttribute]
public static Decimal[0...,0...] CumulativeSum(Decimal[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Decimal[0...,0...] CumulativeSum(Decimal[0...,0...] matrix, int dimension, Decimal[0...,0...] result);
    [ExtensionAttribute]
public static T[0...,0...] Remove(T[0...,0...] data, Int32[] rowIndexes, Int32[] columnIndexes);
    [ExtensionAttribute]
public static T[] GetColumn(T[0...,0...] m, int index, T[] result);
    [ExtensionAttribute]
public static T[] GetColumn(T[][] m, int index, T[] result);
    [ExtensionAttribute]
public static T[][] GetColumns(T[][] m, Int32[] index);
    [ExtensionAttribute]
public static T[][] GetColumns(T[][] m, Int32[] index, T[][] result);
    [ExtensionAttribute]
public static T[] GetRow(T[][] m, int index, T[] result);
    [ExtensionAttribute]
public static T[] GetRow(T[0...,0...] m, int index, T[] result);
    [ExtensionAttribute]
public static T[][] GetRows(T[][] m, Int32[] index);
    [ExtensionAttribute]
public static T[][] GetRows(T[][] m, Int32[] index, T[][] result);
    [ExtensionAttribute]
public static T[0...,0...] GetColumns(T[0...,0...] m, Int32[] index);
    [ExtensionAttribute]
public static T[0...,0...] GetColumns(T[0...,0...] m, Int32[] index, T[0...,0...] result);
    [ExtensionAttribute]
public static T[0...,0...] SetColumn(T[0...,0...] m, int index, T[] column);
    [ExtensionAttribute]
public static T[][] SetColumn(T[][] m, int index, T[] column);
    [ExtensionAttribute]
public static T[][] SetColumn(T[][] m, int index, T value);
    [ExtensionAttribute]
public static T[0...,0...] SetRow(T[0...,0...] m, int index, T[] row);
    [ExtensionAttribute]
public static T[][] SetRow(T[][] m, int index, T[] row);
    [ExtensionAttribute]
public static T[][] SetRow(T[][] m, int index, T value);
    [ExtensionAttribute]
public static T[][] RemoveColumn(T[][] matrix, int index);
    [ExtensionAttribute]
public static T[0...,0...] RemoveColumn(T[0...,0...] matrix, int index);
    [ExtensionAttribute]
public static T[0...,0...] InsertColumn(T[0...,0...] matrix);
    [ExtensionAttribute]
public static T[][] InsertColumn(T[][] matrix);
    [ExtensionAttribute]
public static T[0...,0...] InsertColumn(T[0...,0...] matrix, TSource[] column);
    [ExtensionAttribute]
public static T[0...,0...] InsertColumn(T[0...,0...] matrix, TSource value);
    [ExtensionAttribute]
public static T[][] InsertColumn(T[][] matrix, TSource[] column);
    [ExtensionAttribute]
public static T[][] InsertColumn(T[][] matrix, TSource value);
    [ExtensionAttribute]
public static T[][] InsertRow(T[][] matrix, TSource value);
    [ExtensionAttribute]
public static T[0...,0...] InsertRow(T[0...,0...] matrix, TSource[] row);
    [ExtensionAttribute]
public static T[][] InsertRow(T[][] matrix, TSource[] row);
    [ExtensionAttribute]
public static T[0...,0...] InsertRow(T[0...,0...] matrix);
    [ExtensionAttribute]
public static T[][] InsertRow(T[][] matrix);
    [ExtensionAttribute]
public static T[0...,0...] InsertColumn(T[0...,0...] matrix, TSource[] column, int index);
    [ExtensionAttribute]
public static T[0...,0...] InsertColumn(T[0...,0...] matrix, TSource value, int index);
    [ExtensionAttribute]
public static T[][] InsertColumn(T[][] matrix, TSource[] column, int index);
    [ExtensionAttribute]
public static T[][] InsertColumn(T[][] matrix, TSource value, int index);
    [ExtensionAttribute]
public static T[][] InsertRow(T[][] matrix, TSource value, int index);
    [ExtensionAttribute]
public static T[0...,0...] InsertRow(T[0...,0...] matrix, TSource[] row, int index);
    [ExtensionAttribute]
public static T[0...,0...] InsertRow(T[0...,0...] matrix, TSource value, int index);
    [ExtensionAttribute]
public static T[][] InsertRow(T[][] matrix, TSource[] row, int index);
    [ExtensionAttribute]
public static T[0...,0...] RemoveRow(T[0...,0...] matrix, int index);
    [ExtensionAttribute]
public static T[] RemoveAt(T[] array, int index);
    [ExtensionAttribute]
public static int Count(T[] data, Func`2<T, bool> func);
    [ExtensionAttribute]
public static int First(T[] data, Func`2<T, bool> func);
    [ExtensionAttribute]
public static Nullable`1<int> FirstOrNull(T[] data, Func`2<T, bool> func);
    [ExtensionAttribute]
public static int IndexOf(T[] data, T value);
    [ExtensionAttribute]
public static Int32[] Find(T[] data, Func`2<T, bool> func);
    [ExtensionAttribute]
public static Int32[] Find(T[] data, Func`2<T, bool> func, bool firstOnly);
    [ExtensionAttribute]
public static Int32[][] Find(T[0...,0...] data, Func`2<T, bool> func);
    [ExtensionAttribute]
public static Int32[][] Find(T[0...,0...] data, Func`2<T, bool> func, bool firstOnly);
    [ExtensionAttribute]
public static T[] RemoveAll(T[] values, T value);
    [ExtensionAttribute]
public static void Swap(T[] values, Int32[] indices);
    public static void Swap(T& a, T& b);
    [ExtensionAttribute]
public static void Swap(T[] array, int a, int b);
    [ExtensionAttribute]
public static T[][] Distinct(T[0...,0...] values);
    [ExtensionAttribute]
public static T[][] Distinct(T[][] values);
    [ExtensionAttribute]
public static T[] Distinct(T[] values);
    [ExtensionAttribute]
public static T[] Distinct(T[] values, bool allowNulls);
    [ExtensionAttribute]
public static T[] Distinct(T[] values, Func`2<T, TProperty> property);
    [ExtensionAttribute]
public static Int32[] DistinctCount(T[0...,0...] matrix);
    [ExtensionAttribute]
public static Int32[] DistinctCount(T[][] matrix);
    [ExtensionAttribute]
public static int DistinctCount(T[] values);
    public static TValue[0...,0...] Sort(TKey[] keys, TValue[0...,0...] values);
    public static TValue[0...,0...] Sort(TKey[] keys, TValue[0...,0...] values, IComparer`1<TKey> comparer);
    public static TValue[][] Sort(TKey[] keys, TValue[][] values, IComparer`1<TKey> comparer);
    public static TValue[][] Sort(TKey[] keys, TValue[][] values);
    [ExtensionAttribute]
public static T[] Reversed(T[] values);
    [ExtensionAttribute]
public static T[] First(T[] values, int count);
    [ExtensionAttribute]
public static T[] Last(T[] values, int count);
    [ExtensionAttribute]
public static Int32[] Top(T[] values, int count, bool inPlace);
    [ExtensionAttribute]
public static Int32[] Bottom(T[] values, int count, bool inPlace);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Accord.Sort.Partition instead.")]
public static int Partition(T[] list, TValue[] keys, int left, int right, bool asc);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Accord.Sort.Partition instead.")]
public static int Partition(T[] list, int left, int right, bool asc);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Accord.Sort.Partition instead.")]
public static int Partition(TKey[] list, TValue[] keys, int left, int right, Func`3<TKey, TKey, int> compare, bool asc);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Accord.Sort.Partition instead.")]
public static int Partition(T[] list, int left, int right, Func`3<T, T, int> compare, bool asc);
    [ExtensionAttribute]
private static T cast(object value);
    [ExtensionAttribute]
public static void Set(T[][] destination, T value);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T value);
    [ExtensionAttribute]
public static void Set(T[][] destination, T[][] value);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T[0...,0...] value);
    [ExtensionAttribute]
public static void Set(T[][] destination, T[][] value, Int32[] rowIndices, int startColumn, int endColumn);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T[0...,0...] value, Int32[] rowIndices, int startColumn, int endColumn);
    [ExtensionAttribute]
public static void Set(T[][] destination, T value, Int32[] rowIndices, int startColumn, int endColumn);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T[0...,0...] value, int startRow, int endRow, Int32[] columnIndices);
    [ExtensionAttribute]
public static void Set(T[][] destination, T[][] value, int startRow, int endRow, Int32[] columnIndices);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T value, Int32[] rowIndices, int startColumn, int endColumn);
    [ExtensionAttribute]
public static void Set(T[][] destination, T value, int startRow, int endRow, Int32[] columnIndices);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T value, int startRow, int endRow, Int32[] columnIndices);
    [ExtensionAttribute]
public static void Set(T[][] destination, T value, int startRow, int endRow, int startCol, int endCol);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T value, int startRow, int endRow, int startCol, int endCol);
    [ExtensionAttribute]
public static void Set(T[][] destination, T value, Int32[] rowIndices, Int32[] columnIndices);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T value, Int32[] rowIndices, Int32[] columnIndices);
    [ExtensionAttribute]
public static void Set(T[][] destination, T[][] value, Int32[] rowIndices, Int32[] columnIndices);
    [ExtensionAttribute]
public static void Set(T[0...,0...] destination, T[0...,0...] value, Int32[] rowIndices, Int32[] columnIndices);
    [ExtensionAttribute]
public static void Set(T[] destination, T value, Int32[] indices);
    [ExtensionAttribute]
public static void Set(T[] destination, T value, int startRow, int endRow);
    [ExtensionAttribute]
public static void Set(T[] destination, T value, int index);
    [ExtensionAttribute]
public static void Set(List`1<T> destination, T value, Int32[] indices);
    [ExtensionAttribute]
private static void set(T[0...,0...] dst, Int32[] dstRowIndices, Int32[] dstColumnIndices, T[0...,0...] src, Int32[] srcRowIndices, Int32[] srcColumnIndices);
    [ExtensionAttribute]
private static void set(T[][] dst, Int32[] dstRowIndices, Int32[] dstColumnIndices, T[][] src, Int32[] srcRowIndices, Int32[] srcColumnIndices);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[0...,0...] Submatrix(T[0...,0...] source, int startRow, int endRow, int startColumn, int endColumn);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[0...,0...] Submatrix(T[0...,0...] source, T[0...,0...] destination, int startRow, int endRow, int startColumn, int endColumn);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[0...,0...] Submatrix(T[0...,0...] source, Int32[] rowIndexes, Int32[] columnIndexes);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static void Submatrix(T[0...,0...] source, T[0...,0...] destination, Int32[] rowIndexes, Int32[] columnIndexes);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[0...,0...] Submatrix(T[0...,0...] source, Int32[] rowIndexes);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[0...,0...] Submatrix(T[0...,0...] source, int startRow, int endRow, Int32[] columnIndexes);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[0...,0...] Submatrix(T[0...,0...] source, Int32[] rowIndexes, int startColumn, int endColumn);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[][] Submatrix(T[][] source, int startRow, int endRow, int startColumn, int endColumn);
    [ExtensionAttribute]
public static T[][] Submatrix(T[][] source, Int32[] rowIndexes, Int32[] columnIndexes, bool reuseMemory);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[][] Submatrix(T[][] source, Int32[] indexes, bool transpose);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[][] Submatrix(T[][] source, Int32[] rowIndexes, int startColumn, int endColumn, bool reuseMemory);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[][] Submatrix(T[][] source, int startRow, int endRow, Int32[] columnIndexes);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[] Submatrix(T[] source, Int32[] indexes, bool inPlace);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[] Submatrix(T[] source, IList`1<int> indexes);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[] Submatrix(T[] source, int startRow, int endRow);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static T[] Submatrix(T[] source, int first);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Get instead.")]
public static List`1<T> Submatrix(List`1<T> source, Int32[] indexes);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Classes.Separate(T[], int[]) instead.")]
public static T[][] Subgroups(T[] values, Int32[] groups);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Classes.Separate(T[], int[], int) instead.")]
public static T[][] Subgroups(T[] values, Int32[] groups, int classes);
    [ExtensionAttribute]
public static Array ExpandDimensions(Array array, int dimension);
    [ExtensionAttribute]
public static Array Squeeze(Array array);
    [ExtensionAttribute]
public static Array Flatten(Array array, MatrixOrder order);
    [ExtensionAttribute]
public static Array Reshape(Array array, Int32[] shape, MatrixOrder order);
    [ExtensionAttribute]
public static Array Convert(Array array);
    [ExtensionAttribute]
public static Array Convert(Array array, Type type);
    [ExtensionAttribute]
public static Array Get(Array source, int dimension, Int32[] indices);
    [ExtensionAttribute]
public static Array Get(Array source, int dimension, int index);
    [ExtensionAttribute]
public static Array Get(Array source, int dimension, int start, int end);
    [ExtensionAttribute]
public static void Set(Array destination, int dimension, int index, Array value);
    [ExtensionAttribute]
public static void Set(Array destination, int dimension, int start, int end, Array value);
    [ExtensionAttribute]
public static bool IsSquare(Array array);
    public static Array Zeros(Int32[] shape);
    public static Array Zeros(Type type, Int32[] shape);
    public static Array Create(Int32[] shape, T value);
    public static Array Create(Type elementType, Int32[] shape, object value);
    [ExtensionAttribute]
public static Int32[] ArgSort(T[] values);
    [ExtensionAttribute]
public static int ArgMax(T[] values);
    [ExtensionAttribute]
public static int ArgMax(T[] values, T& max);
    [ExtensionAttribute]
public static int ArgMin(T[] values);
    [ExtensionAttribute]
public static int ArgMin(T[] values, T& min);
    [ExtensionAttribute]
public static Nullable`1<T> Max(Nullable`1[] values, Int32& imax);
    [ExtensionAttribute]
public static Nullable`1<T> Min(Nullable`1[] values, Int32& imin);
    [ExtensionAttribute]
public static T Max(T[] values, Int32& imax);
    [ExtensionAttribute]
public static T Max(T[] values, Int32& imax, bool alreadySorted);
    [ExtensionAttribute]
public static T Max(T[] values);
    [ExtensionAttribute]
public static T Min(T[] values, Int32& imin);
    [ExtensionAttribute]
public static T Min(T[] values);
    [ExtensionAttribute]
public static T Max(T[] values, int length, Int32& imax);
    [ExtensionAttribute]
public static T Max(T[] values, int length);
    [ExtensionAttribute]
public static T Min(T[] values, int length, Int32& imax);
    [ExtensionAttribute]
public static T Min(T[] values, int length);
}
[SerializableAttribute]
public class Accord.Math.Matrix3x3 : ValueType {
    public float V00;
    public float V01;
    public float V02;
    public float V10;
    public float V11;
    public float V12;
    public float V20;
    public float V21;
    public float V22;
    public static Matrix3x3 Identity { get; }
    public float Determinant { get; }
    public static Matrix3x3 get_Identity();
    public float get_Determinant();
    public Single[] ToArray();
    public static Matrix3x3 CreateRotationY(float radians);
    public static Matrix3x3 CreateRotationX(float radians);
    public static Matrix3x3 CreateRotationZ(float radians);
    public static Matrix3x3 CreateFromYawPitchRoll(float yaw, float pitch, float roll);
    public void ExtractYawPitchRoll(Single& yaw, Single& pitch, Single& roll);
    public static Matrix3x3 CreateFromRows(Vector3 row0, Vector3 row1, Vector3 row2);
    public static Matrix3x3 CreateFromColumns(Vector3 column0, Vector3 column1, Vector3 column2);
    public static Matrix3x3 CreateDiagonal(Vector3 vector);
    public Vector3 GetRow(int index);
    public Vector3 GetColumn(int index);
    public static Matrix3x3 op_Multiply(Matrix3x3 matrix1, Matrix3x3 matrix2);
    public static Matrix3x3 Multiply(Matrix3x3 matrix1, Matrix3x3 matrix2);
    public static Matrix3x3 op_Addition(Matrix3x3 matrix1, Matrix3x3 matrix2);
    public static Matrix3x3 Add(Matrix3x3 matrix1, Matrix3x3 matrix2);
    public static Matrix3x3 op_Subtraction(Matrix3x3 matrix1, Matrix3x3 matrix2);
    public static Matrix3x3 Subtract(Matrix3x3 matrix1, Matrix3x3 matrix2);
    public static Vector3 op_Multiply(Matrix3x3 matrix, Vector3 vector);
    public static Vector3 Multiply(Matrix3x3 matrix, Vector3 vector);
    public static Matrix3x3 op_Multiply(Matrix3x3 matrix, float factor);
    public static Matrix3x3 Multiply(Matrix3x3 matrix, float factor);
    public static Matrix3x3 op_Addition(Matrix3x3 matrix, float value);
    public static Matrix3x3 Add(Matrix3x3 matrix, float value);
    public static bool op_Equality(Matrix3x3 matrix1, Matrix3x3 matrix2);
    public static bool op_Inequality(Matrix3x3 matrix1, Matrix3x3 matrix2);
    public bool Equals(Matrix3x3 matrix);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Matrix3x3 Transpose();
    public Matrix3x3 MultiplySelfByTranspose();
    public Matrix3x3 MultiplyTransposeBySelf();
    public Matrix3x3 Adjugate();
    public Matrix3x3 Inverse();
    public Matrix3x3 PseudoInverse();
    public void SVD(Matrix3x3& u, Vector3& e, Matrix3x3& v);
}
[SerializableAttribute]
public class Accord.Math.Matrix4x4 : ValueType {
    public float V00;
    public float V01;
    public float V02;
    public float V03;
    public float V10;
    public float V11;
    public float V12;
    public float V13;
    public float V20;
    public float V21;
    public float V22;
    public float V23;
    public float V30;
    public float V31;
    public float V32;
    public float V33;
    public static Matrix4x4 Identity { get; }
    public static Matrix4x4 get_Identity();
    public Single[] ToArray();
    public static Matrix4x4 CreateRotationY(float radians);
    public static Matrix4x4 CreateRotationX(float radians);
    public static Matrix4x4 CreateRotationZ(float radians);
    public static Matrix4x4 CreateFromYawPitchRoll(float yaw, float pitch, float roll);
    public void ExtractYawPitchRoll(Single& yaw, Single& pitch, Single& roll);
    public static Matrix4x4 CreateFromRotation(Matrix3x3 rotationMatrix);
    public static Matrix4x4 CreateTranslation(Vector3 position);
    public static Matrix4x4 CreateLookAt(Vector3 cameraPosition, Vector3 cameraTarget);
    public static Matrix4x4 CreatePerspective(float width, float height, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreateFromRows(Vector4 row0, Vector4 row1, Vector4 row2, Vector4 row3);
    public static Matrix4x4 CreateFromColumns(Vector4 column0, Vector4 column1, Vector4 column2, Vector4 column3);
    public static Matrix4x4 CreateDiagonal(Vector4 vector);
    public Vector4 GetRow(int index);
    public Vector4 GetColumn(int index);
    public static Matrix4x4 op_Multiply(Matrix4x4 matrix1, Matrix4x4 matrix2);
    public static Matrix4x4 Multiply(Matrix4x4 matrix1, Matrix4x4 matrix2);
    public static Matrix4x4 op_Addition(Matrix4x4 matrix1, Matrix4x4 matrix2);
    public static Matrix4x4 Add(Matrix4x4 matrix1, Matrix4x4 matrix2);
    public static Matrix4x4 op_Subtraction(Matrix4x4 matrix1, Matrix4x4 matrix2);
    public static Matrix4x4 Subtract(Matrix4x4 matrix1, Matrix4x4 matrix2);
    public static Vector4 op_Multiply(Matrix4x4 matrix, Vector4 vector);
    public static Vector4 Multiply(Matrix4x4 matrix, Vector4 vector);
    public static bool op_Equality(Matrix4x4 matrix1, Matrix4x4 matrix2);
    public static bool op_Inequality(Matrix4x4 matrix1, Matrix4x4 matrix2);
    public bool Equals(Matrix4x4 matrix);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Accord.Math.MatrixFormatProviderBase : object {
    [CompilerGeneratedAttribute]
private string <FormatMatrixStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatMatrixEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatRowStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatRowEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatColStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatColEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatRowDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatColDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseMatrixStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseMatrixEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseRowStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseRowEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseColStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseColEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseRowDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseColDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatProvider <InnerProvider>k__BackingField;
    public string FormatMatrixStart { get; protected set; }
    public string FormatMatrixEnd { get; protected set; }
    public string FormatRowStart { get; protected set; }
    public string FormatRowEnd { get; protected set; }
    public string FormatColStart { get; protected set; }
    public string FormatColEnd { get; protected set; }
    public string FormatRowDelimiter { get; protected set; }
    public string FormatColDelimiter { get; protected set; }
    public string ParseMatrixStart { get; protected set; }
    public string ParseMatrixEnd { get; protected set; }
    public string ParseRowStart { get; protected set; }
    public string ParseRowEnd { get; protected set; }
    public string ParseColStart { get; protected set; }
    public string ParseColEnd { get; protected set; }
    public string ParseRowDelimiter { get; protected set; }
    public string ParseColDelimiter { get; protected set; }
    public IFormatProvider InnerProvider { get; protected set; }
    protected MatrixFormatProviderBase(IFormatProvider innerProvider);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FormatMatrixStart();
    [CompilerGeneratedAttribute]
protected void set_FormatMatrixStart(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FormatMatrixEnd();
    [CompilerGeneratedAttribute]
protected void set_FormatMatrixEnd(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FormatRowStart();
    [CompilerGeneratedAttribute]
protected void set_FormatRowStart(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FormatRowEnd();
    [CompilerGeneratedAttribute]
protected void set_FormatRowEnd(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FormatColStart();
    [CompilerGeneratedAttribute]
protected void set_FormatColStart(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FormatColEnd();
    [CompilerGeneratedAttribute]
protected void set_FormatColEnd(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FormatRowDelimiter();
    [CompilerGeneratedAttribute]
protected void set_FormatRowDelimiter(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FormatColDelimiter();
    [CompilerGeneratedAttribute]
protected void set_FormatColDelimiter(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParseMatrixStart();
    [CompilerGeneratedAttribute]
protected void set_ParseMatrixStart(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParseMatrixEnd();
    [CompilerGeneratedAttribute]
protected void set_ParseMatrixEnd(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParseRowStart();
    [CompilerGeneratedAttribute]
protected void set_ParseRowStart(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParseRowEnd();
    [CompilerGeneratedAttribute]
protected void set_ParseRowEnd(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParseColStart();
    [CompilerGeneratedAttribute]
protected void set_ParseColStart(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParseColEnd();
    [CompilerGeneratedAttribute]
protected void set_ParseColEnd(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParseRowDelimiter();
    [CompilerGeneratedAttribute]
protected void set_ParseRowDelimiter(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParseColDelimiter();
    [CompilerGeneratedAttribute]
protected void set_ParseColDelimiter(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IFormatProvider get_InnerProvider();
    [CompilerGeneratedAttribute]
protected void set_InnerProvider(IFormatProvider value);
    public sealed virtual object GetFormat(Type formatType);
}
public class Accord.Math.MatrixFormatter : object {
    public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
    public static string Format(string format, Array matrix, IMatrixFormatProvider formatProvider);
    private static bool parseOptions(string format, String& newline, String& elementFormat);
    private static string handleOtherFormats(string format, object arg, IFormatProvider culture);
    public static Double[][] ParseJagged(string str, IMatrixFormatProvider provider);
    public static Double[0...,0...] ParseMultidimensional(string str, IMatrixFormatProvider provider);
}
public enum Accord.Math.MatrixOrder : Enum {
    public int value__;
    public static MatrixOrder CRowMajor;
    public static MatrixOrder FortranColumnMajor;
    public static MatrixOrder Default;
}
[FlagsAttribute]
public enum Accord.Math.MatrixType : Enum {
    public int value__;
    public static MatrixType Symmetric;
    public static MatrixType LowerTriangular;
    public static MatrixType UpperTriangular;
    public static MatrixType Diagonal;
    public static MatrixType Rectangular;
    public static MatrixType Square;
}
[ObsoleteAttribute("Please use Accord.Math.Distances.Cosine instead.")]
public class Accord.Math.Metrics.CosineDistance : object {
    public sealed virtual double GetDistance(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.Cosine instead.")]
public class Accord.Math.Metrics.CosineSimilarity : object {
    public sealed virtual double GetSimilarityScore(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.Euclidean instead.")]
public class Accord.Math.Metrics.EuclideanDistance : object {
    public sealed virtual double GetDistance(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.Euclidean instead.")]
public class Accord.Math.Metrics.EuclideanSimilarity : object {
    public sealed virtual double GetSimilarityScore(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.Hamming instead.")]
public class Accord.Math.Metrics.HammingDistance : object {
    public sealed virtual double GetDistance(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.IDistance instead.")]
public interface Accord.Math.Metrics.IDistance {
    public abstract virtual double GetDistance(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.ISimilarity instead.")]
public interface Accord.Math.Metrics.ISimilarity {
    public abstract virtual double GetSimilarityScore(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.Jaccard instead.")]
public class Accord.Math.Metrics.JaccardDistance : object {
    public sealed virtual double GetDistance(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.Manhattan instead.")]
public class Accord.Math.Metrics.ManhattanDistance : object {
    public sealed virtual double GetDistance(Double[] p, Double[] q);
}
[ObsoleteAttribute("Please use Accord.Math.Distances.PearsonCorrelation instead.")]
public class Accord.Math.Metrics.PearsonCorrelation : object {
    public sealed virtual double GetSimilarityScore(Double[] p, Double[] q);
}
[ExtensionAttribute]
public static class Accord.Math.Norm : object {
    [ExtensionAttribute]
public static double Norm1(Double[0...,0...] a);
    [ExtensionAttribute]
public static double Norm1(Double[][] a);
    [ExtensionAttribute]
public static double Norm2(Double[0...,0...] a);
    [ExtensionAttribute]
public static double Norm2(Double[][] a);
    [ExtensionAttribute]
public static float Frobenius(Single[0...,0...] a);
    [ExtensionAttribute]
public static float Frobenius(Single[][] a);
    [ExtensionAttribute]
public static float SquareEuclidean(Single[0...,0...] a);
    [ExtensionAttribute]
public static float SquareEuclidean(Single[][] a);
    [ExtensionAttribute]
public static float SquareEuclidean(Single[] a);
    [ExtensionAttribute]
public static float SquareEuclidean(Sparse`1<float> a);
    [ExtensionAttribute]
public static Single[] SquareEuclidean(Single[0...,0...] a, int dimension);
    [ExtensionAttribute]
public static Single[] SquareEuclidean(Single[][] a, int dimension);
    [ExtensionAttribute]
public static Single[] SquareEuclidean(Sparse`1[] a, int dimension);
    [ExtensionAttribute]
public static float Euclidean(Single[0...,0...] a);
    [ExtensionAttribute]
public static float Euclidean(Single[][] a);
    [ExtensionAttribute]
public static float Euclidean(Sparse`1<float> a);
    [ExtensionAttribute]
public static float Euclidean(Single[] a);
    [ExtensionAttribute]
public static Single[] Euclidean(Single[0...,0...] a, int dimension);
    [ExtensionAttribute]
public static Single[] Euclidean(Single[][] a, int dimension);
    [ExtensionAttribute]
public static Single[] Euclidean(Sparse`1[] a, int dimension);
    [ExtensionAttribute]
public static double Frobenius(Double[0...,0...] a);
    [ExtensionAttribute]
public static double Frobenius(Double[][] a);
    [ExtensionAttribute]
public static double SquareEuclidean(Double[0...,0...] a);
    [ExtensionAttribute]
public static double SquareEuclidean(Double[][] a);
    [ExtensionAttribute]
public static double SquareEuclidean(Double[] a);
    [ExtensionAttribute]
public static double SquareEuclidean(Sparse`1<double> a);
    [ExtensionAttribute]
public static Double[] SquareEuclidean(Double[0...,0...] a, int dimension);
    [ExtensionAttribute]
public static Double[] SquareEuclidean(Double[][] a, int dimension);
    [ExtensionAttribute]
public static Double[] SquareEuclidean(Sparse`1[] a, int dimension);
    [ExtensionAttribute]
public static double Euclidean(Double[0...,0...] a);
    [ExtensionAttribute]
public static double Euclidean(Double[][] a);
    [ExtensionAttribute]
public static double Euclidean(Sparse`1<double> a);
    [ExtensionAttribute]
public static double Euclidean(Double[] a);
    [ExtensionAttribute]
public static Double[] Euclidean(Double[0...,0...] a, int dimension);
    [ExtensionAttribute]
public static Double[] Euclidean(Double[][] a, int dimension);
    [ExtensionAttribute]
public static Double[] Euclidean(Sparse`1[] a, int dimension);
}
public static class Accord.Math.Normal : object {
    private static Double[] inverse_P0;
    private static Double[] inverse_Q0;
    private static Double[] inverse_P1;
    private static Double[] inverse_Q1;
    private static Double[] inverse_P2;
    private static Double[] inverse_Q2;
    private static Double[] high_R;
    private static Double[] BVND_WN20;
    private static Double[] BVND_XN20;
    private static Double[] BVND_WN12;
    private static Double[] BVND_XN12;
    private static Double[] BVND_WN6;
    private static Double[] BVND_XN6;
    private static Normal();
    public static double Function(double value);
    public static double Log(double value);
    public static double Complemented(double value);
    public static double Inverse(double y0);
    public static double HighAccuracyFunction(double x);
    public static double HighAccuracyComplemented(double x);
    public static double Bivariate(double x, double y, double rho);
    public static double BivariateComplemented(double x, double y, double rho);
    private static double BVND(double dh, double dk, double r);
    public static double Derivative(double value);
    public static double LogDerivative(double value);
    public static double Gaussian(double sigmaSquared, double x);
    public static double Gaussian2D(double sigmaSquared, double x, double y);
    public static Double[] Kernel(double sigmaSquared, int size);
    public static Double[0...,0...] Kernel2D(double sigmaSquared, int size);
}
public class Accord.Math.OctaveArrayFormatProvider : MatrixFormatProviderBase {
    private static OctaveArrayFormatProvider invariantCulture;
    private static OctaveArrayFormatProvider currentCulture;
    public static OctaveArrayFormatProvider CurrentCulture { get; }
    public static OctaveArrayFormatProvider InvariantCulture { get; }
    public OctaveArrayFormatProvider(IFormatProvider innerProvider);
    private static OctaveArrayFormatProvider();
    public static OctaveArrayFormatProvider get_CurrentCulture();
    public static OctaveArrayFormatProvider get_InvariantCulture();
}
public class Accord.Math.OctaveMatrixFormatProvider : MatrixFormatProviderBase {
    private static OctaveMatrixFormatProvider invariantCulture;
    private static OctaveMatrixFormatProvider currentCulture;
    public static OctaveMatrixFormatProvider CurrentCulture { get; }
    public static OctaveMatrixFormatProvider InvariantCulture { get; }
    public OctaveMatrixFormatProvider(IFormatProvider innerProvider);
    private static OctaveMatrixFormatProvider();
    public static OctaveMatrixFormatProvider get_CurrentCulture();
    public static OctaveMatrixFormatProvider get_InvariantCulture();
}
public class Accord.Math.Optimization.AugmentedLagrangian : BaseGradientOptimizationMethod {
    private IGradientOptimizationMethod dualSolver;
    private IConstraint[] lesserThanConstraints;
    private IConstraint[] greaterThanConstraints;
    private IConstraint[] equalityConstraints;
    private double rho;
    private double rhoMax;
    private double rhoMin;
    private Double[] lambda;
    private Double[] mu;
    private Double[] nu;
    private Double[] g;
    private double ftol_abs;
    private double ftol_rel;
    private double xtol_rel;
    private int functionEvaluations;
    private int maxEvaluations;
    private int iterations;
    [CompilerGeneratedAttribute]
private AugmentedLagrangianStatus <Status>k__BackingField;
    public AugmentedLagrangianStatus Status { get; private set; }
    public int Iterations { get; }
    public int Evaluations { get; }
    public int MaxEvaluations { get; public set; }
    public IGradientOptimizationMethod Optimizer { get; }
    public AugmentedLagrangian(int numberOfVariables, IEnumerable`1<IConstraint> constraints);
    public AugmentedLagrangian(NonlinearObjectiveFunction function, IEnumerable`1<IConstraint> constraints);
    public AugmentedLagrangian(IGradientOptimizationMethod innerSolver, NonlinearObjectiveFunction function, IEnumerable`1<IConstraint> constraints);
    public AugmentedLagrangian(IGradientOptimizationMethod innerSolver, IEnumerable`1<IConstraint> constraints);
    [CompilerGeneratedAttribute]
public sealed virtual AugmentedLagrangianStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(AugmentedLagrangianStatus value);
    public int get_Iterations();
    public int get_Evaluations();
    public int get_MaxEvaluations();
    public void set_MaxEvaluations(int value);
    public IGradientOptimizationMethod get_Optimizer();
    private void init(NonlinearObjectiveFunction function, IEnumerable`1<IConstraint> constraints, IGradientOptimizationMethod innerSolver);
    private double objectiveFunction(Double[] x);
    private Double[] objectiveGradient(Double[] x);
    protected virtual bool Optimize();
    private AugmentedLagrangianStatus optimize();
    private bool xtolreach(Double[] currentSolution, double reltol, double abstol);
    private static bool relstop(double vold, double vnew, double reltol, double abstol);
}
public enum Accord.Math.Optimization.AugmentedLagrangianStatus : Enum {
    public int value__;
    public static AugmentedLagrangianStatus Converged;
    public static AugmentedLagrangianStatus NoProgress;
    public static AugmentedLagrangianStatus MaxEvaluations;
    public static AugmentedLagrangianStatus Cancelled;
}
public abstract class Accord.Math.Optimization.BaseGradientOptimizationMethod : BaseOptimizationMethod {
    [CompilerGeneratedAttribute]
private Func`2<Double[], Double[]> <Gradient>k__BackingField;
    public Func`2<Double[], Double[]> Gradient { get; public set; }
    protected BaseGradientOptimizationMethod(int numberOfVariables);
    protected BaseGradientOptimizationMethod(int numberOfVariables, Func`2<Double[], double> function, Func`2<Double[], Double[]> gradient);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Double[], Double[]> get_Gradient();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Gradient(Func`2<Double[], Double[]> value);
    public virtual bool Maximize();
    public virtual bool Minimize();
}
public abstract class Accord.Math.Optimization.BaseLeastSquaresMethod : ParallelLearningBase {
    private int numberOfParameters;
    private Double[] solution;
    private RelativeConvergence convergence;
    [CompilerGeneratedAttribute]
private LeastSquaresFunction <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private LeastSquaresGradientFunction <Gradient>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public LeastSquaresFunction Function { get; public set; }
    public LeastSquaresGradientFunction Gradient { get; public set; }
    public Double[] Solution { get; public set; }
    [ObsoleteAttribute("Please use NumberOfParameters instead.")]
public int NumberOfVariables { get; public set; }
    public int NumberOfParameters { get; public set; }
    public double Value { get; public set; }
    protected RelativeConvergence Convergence { get; protected set; }
    public int MaxIterations { get; public set; }
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int CurrentIteration { get; public set; }
    public bool HasConverged { get; }
    [CompilerGeneratedAttribute]
public sealed virtual LeastSquaresFunction get_Function();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Function(LeastSquaresFunction value);
    [CompilerGeneratedAttribute]
public sealed virtual LeastSquaresGradientFunction get_Gradient();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Gradient(LeastSquaresGradientFunction value);
    public sealed virtual Double[] get_Solution();
    public sealed virtual void set_Solution(Double[] value);
    public sealed virtual int get_NumberOfVariables();
    public sealed virtual void set_NumberOfVariables(int value);
    public int get_NumberOfParameters();
    public void set_NumberOfParameters(int value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Value(double value);
    protected RelativeConvergence get_Convergence();
    protected void set_Convergence(RelativeConvergence value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_CurrentIteration();
    public void set_CurrentIteration(int value);
    public sealed virtual bool get_HasConverged();
    private void init(int numberOfParameters);
    protected abstract virtual void Initialize();
    public double ComputeError(Double[][] input, Double[] output);
}
public abstract class Accord.Math.Optimization.BaseOptimizationMethod : object {
    private int numberOfVariables;
    private Double[] x;
    private double value;
    [NonSerializedAttribute]
private CancellationToken token;
    [CompilerGeneratedAttribute]
private Func`2<Double[], double> <Function>k__BackingField;
    public CancellationToken Token { get; public set; }
    public Func`2<Double[], double> Function { get; public set; }
    public int NumberOfVariables { get; public set; }
    public Double[] Solution { get; public set; }
    public double Value { get; protected set; }
    protected BaseOptimizationMethod(int numberOfVariables);
    protected BaseOptimizationMethod(int numberOfVariables, Func`2<Double[], double> function);
    protected BaseOptimizationMethod(NonlinearObjectiveFunction function);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Double[], double> get_Function();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Function(Func`2<Double[], double> value);
    public virtual int get_NumberOfVariables();
    public virtual void set_NumberOfVariables(int value);
    public sealed virtual Double[] get_Solution();
    public sealed virtual void set_Solution(Double[] value);
    public sealed virtual double get_Value();
    protected void set_Value(double value);
    protected virtual void OnNumberOfVariablesChanged(int numberOfVariables);
    public bool Maximize(Double[] values);
    public bool Minimize(Double[] values);
    public virtual bool Maximize();
    public virtual bool Minimize();
    protected abstract virtual bool Optimize();
    protected static ArgumentOutOfRangeException ArgumentException(string paramName, string message, string code);
    protected static InvalidOperationException OperationException(string message, string code);
}
public class Accord.Math.Optimization.BinarySearch : object {
    [CompilerGeneratedAttribute]
private int <LowerBound>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UpperBound>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<int, double> <Function>k__BackingField;
    public int LowerBound { get; public set; }
    public int UpperBound { get; public set; }
    public int Solution { get; private set; }
    public double Value { get; private set; }
    public Func`2<int, double> Function { get; private set; }
    public BinarySearch(Func`2<int, double> function, int a, int b);
    [CompilerGeneratedAttribute]
public int get_LowerBound();
    [CompilerGeneratedAttribute]
public void set_LowerBound(int value);
    [CompilerGeneratedAttribute]
public int get_UpperBound();
    [CompilerGeneratedAttribute]
public void set_UpperBound(int value);
    [CompilerGeneratedAttribute]
public int get_Solution();
    [CompilerGeneratedAttribute]
private void set_Solution(int value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    [CompilerGeneratedAttribute]
public Func`2<int, double> get_Function();
    [CompilerGeneratedAttribute]
private void set_Function(Func`2<int, double> value);
    public int Find(double value);
    public int FindRoot();
    public static int Find(Func`2<int, double> function, int lowerBound, int upperBound, double value);
}
public class Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShanno : BaseGradientOptimizationMethod {
    private static double stpmin;
    private static double stpmax;
    private int iterations;
    private int evaluations;
    private int corrections;
    private Double[] lowerBound;
    private Double[] upperBound;
    private Double[] work;
    private double factr;
    private double pgtol;
    [CompilerGeneratedAttribute]
private EventHandler`1<OptimizationProgressEventArgs> Progress;
    [CompilerGeneratedAttribute]
private int <MaxIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundedBroydenFletcherGoldfarbShannoStatus <Status>k__BackingField;
    public int Iterations { get; }
    public int MaxIterations { get; public set; }
    public int Evaluations { get; }
    public int Corrections { get; public set; }
    public Double[] UpperBounds { get; public set; }
    public Double[] LowerBounds { get; public set; }
    public double FunctionTolerance { get; public set; }
    public double GradientTolerance { get; public set; }
    public BoundedBroydenFletcherGoldfarbShannoStatus Status { get; private set; }
    public BoundedBroydenFletcherGoldfarbShanno(int numberOfVariables);
    public BoundedBroydenFletcherGoldfarbShanno(int numberOfVariables, Func`2<Double[], double> function, Func`2<Double[], Double[]> gradient);
    [CompilerGeneratedAttribute]
public void add_Progress(EventHandler`1<OptimizationProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Progress(EventHandler`1<OptimizationProgressEventArgs> value);
    public int get_Iterations();
    [CompilerGeneratedAttribute]
public int get_MaxIterations();
    [CompilerGeneratedAttribute]
public void set_MaxIterations(int value);
    public int get_Evaluations();
    public int get_Corrections();
    public void set_Corrections(int value);
    public Double[] get_UpperBounds();
    public void set_UpperBounds(Double[] value);
    public Double[] get_LowerBounds();
    public void set_LowerBounds(Double[] value);
    public double get_FunctionTolerance();
    public void set_FunctionTolerance(double value);
    public double get_GradientTolerance();
    public void set_GradientTolerance(double value);
    [CompilerGeneratedAttribute]
public sealed virtual BoundedBroydenFletcherGoldfarbShannoStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(BoundedBroydenFletcherGoldfarbShannoStatus value);
    protected virtual bool Optimize();
    private void exit(string csave, Boolean[] lsave, Int32[] isave, Double[] x, Double[] dsave, Double& newF, Double[]& newG);
    private static void active(int n, Double[] l, int _l_offset, Double[] u, int _u_offset, Int32[] nbd, int _nbd_offset, Double[] x, int _x_offset, Int32[] iwhere, int _iwhere_offset, int iprint, Boolean& prjctd, Boolean& cnstnd, Boolean& boxed);
    private static void dtrsl(Double[] t, int _t_offset, int ldt, int n, Double[] b, int _b_offset, int job, Int32& info);
    private static void bmv(int m, Double[] sy, int _sy_offset, Double[] wt, int _wt_offset, int col, Double[] v, int _v_offset, Double[] p, int _p_offset, Int32& info);
    private static void cauchy(int n, Double[] x, int _x_offset, Double[] l, int _l_offset, Double[] u, int _u_offset, Int32[] nbd, int _nbd_offset, Double[] g, int _g_offset, Int32[] iorder, int _iorder_offset, Int32[] iwhere, int _iwhere_offset, Double[] t, int _t_offset, Double[] d, int _d_offset, Double[] xcp, int _xcp_offset, int m, Double[] wy, int _wy_offset, Double[] ws, int _ws_offset, Double[] sy, int _sy_offset, Double[] wt, int _wt_offset, double theta, int col, int head, Double[] p, int _p_offset, Double[] c, int _c_offset, Double[] wbp, int _wbp_offset, Double[] v, int _v_offset, Int32& nseg, int iprint, double sbgnrm, Int32& info, double epsmch);
    private static void cmprlb(int n, int m, Double[] x, int _x_offset, Double[] g, int _g_offset, Double[] ws, int _ws_offset, Double[] wy, int _wy_offset, Double[] sy, int _sy_offset, Double[] wt, int _wt_offset, Double[] z, int _z_offset, Double[] r, int _r_offset, Double[] wa, int _wa_offset, Int32[] index, int _index_offset, double theta, int col, int head, int nfree, bool cnstnd, Int32& info);
    private static void dcsrch(double f, double g, Double& stp, double ftol, double gtol, double xtol, double stpmin, double stpmax, String& task, Int32[] isave, int _isave_offset, Double[] dsave, int _dsave_offset);
    internal static void dcstep(Double& stx, Double& fx, Double& dx, Double& sty, Double& fy, Double& dy, Double& stp, double fp, double dp, Boolean& brackt, double stpmin, double stpmax);
    private static void errclb(int n, int m, double factr, Double[] l, int _l_offset, Double[] u, int _u_offset, Int32[] nbd, int _nbd_offset, String& task, Int32& info, Int32& k);
    private static void formk(int n, int nsub, Int32[] ind, int _ind_offset, int nenter, int ileave, Int32[] indx2, int _indx2_offset, int iupdat, bool updatd, Double[] wn, int _wn_offset, Double[] wn1, int _wn1_offset, int m, Double[] ws, int _ws_offset, Double[] wy, int _wy_offset, Double[] sy, int _sy_offset, double theta, int col, int head, Int32& info);
    private static void formt(int m, Double[] wt, int _wt_offset, Double[] sy, int _sy_offset, Double[] ss, int _ss_offset, int col, double theta, Int32& info);
    private static void freev(int n, Int32& nfree, Int32[] index, int _index_offset, Int32& nenter, Int32& ileave, Int32[] indx2, int _indx2_offset, Int32[] iwhere, int _iwhere_offset, Boolean& wrk, bool updatd, bool cnstnd, int iprint, int iter);
    private static void hpsolb(int n, Double[] t, int _t_offset, Int32[] iorder, int _iorder_offset, int iheap);
    private static void lnsrlb(int n, Double[] l, int _l_offset, Double[] u, int _u_offset, Int32[] nbd, int _nbd_offset, Double[] x, int _x_offset, double f, Double& fold, Double& gd, Double& gdold, Double[] g, int _g_offset, Double[] d, int _d_offset, Double[] r, int _r_offset, Double[] t, int _t_offset, Double[] z, int _z_offset, Double& stp, Double& dnorm, Double& dtd, Double& xstep, Double& stpmx, int iter, Int32& ifun, Int32& iback, Int32& nfgv, Int32& info, String& task, bool boxed, bool cnstnd, String& csave, Int32[] isave, int _isave_offset, Double[] dsave, int _dsave_offset);
    private static void mainlb(int n, int m, Double[] x, int _x_offset, Double[] l, int _l_offset, Double[] u, int _u_offset, Int32[] nbd, int _nbd_offset, Double& f, Double[] g, int _g_offset, double factr, double pgtol, Double[] ws, int _ws_offset, Double[] wy, int _wy_offset, Double[] sy, int _sy_offset, Double[] ss, int _ss_offset, Double[] wt, int _wt_offset, Double[] wn, int _wn_offset, Double[] snd, int _snd_offset, Double[] z, int _z_offset, Double[] r, int _r_offset, Double[] d, int _d_offset, Double[] t, int _t_offset, Double[] xp, int _xp_offset, Double[] wa, int _wa_offset, Int32[] index, int _index_offset, Int32[] iwhere, int _iwhere_offset, Int32[] indx2, int _indx2_offset, String& task, int iprint, String& csave, Boolean[] lsave, int _lsave_offset, Int32[] isave, int _isave_offset, Double[] dsave, int _dsave_offset);
    internal static void matupd(int n, int m, Double[] ws, int _ws_offset, Double[] wy, int _wy_offset, Double[] sy, int _sy_offset, Double[] ss, int _ss_offset, Double[] d, int _d_offset, Double[] r, int _r_offset, Int32& itail, int iupdat, Int32& col, Int32& head, Double& theta, double rr, double dr, double stp, double dtd);
    internal static void projgr(int n, Double[] l, int _l_offset, Double[] u, int _u_offset, Int32[] nbd, int _nbd_offset, Double[] x, int _x_offset, Double[] g, int _g_offset, Double& sbgnrm);
    internal static void setulb(int n, int m, Double[] x, int _x_offset, Double[] l, int _l_offset, Double[] u, int _u_offset, Int32[] nbd, int _nbd_offset, Double& f, Double[] g, int _g_offset, double factr, double pgtol, Double[] wa, int _wa_offset, Int32[] iwa, int _iwa_offset, String& task, int iprint, String& csave, Boolean[] lsave, int _lsave_offset, Int32[] isave, int _isave_offset, Double[] dsave, int _dsave_offset);
    internal static void subsm(int n, int m, int nsub, Int32[] ind, int _ind_offset, Double[] l, int _l_offset, Double[] u, int _u_offset, Int32[] nbd, int _nbd_offset, Double[] x, int _x_offset, Double[] d, int _d_offset, Double[] xp, int _xp_offset, Double[] ws, int _ws_offset, Double[] wy, int _wy_offset, double theta, Double[] xx, int _xx_offset, Double[] gg, int _gg_offset, int col, int head, Int32& iword, Double[] wv, int _wv_offset, Double[] wn, int _wn_offset, int iprint, Int32& info);
    private static void dpofa(Double[] a, int _a_offset, int lda, int n, Int32& info);
    private static void dscal(int n, double da, Double[] dx, int _dx_offset, int incx);
    private static double ddot(int n, Double[] dx, int _dx_offset, int incx, Double[] dy, int _dy_offset, int incy);
    private static void dcopy(int n, Double[] dx, int _dx_offset, int incx, Double[] dy, int _dy_offset, int incy);
    private static void daxpy(int n, double da, Double[] dx, int _dx_offset, int incx, Double[] dy, int _dy_offset, int incy);
}
public class Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoInnerStatus : object {
    [CompilerGeneratedAttribute]
private Int32[] <Integers>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Doubles>k__BackingField;
    [CompilerGeneratedAttribute]
private Boolean[] <Booleans>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Strings>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Work>k__BackingField;
    public Int32[] Integers { get; public set; }
    public Double[] Doubles { get; public set; }
    public Boolean[] Booleans { get; public set; }
    public string Strings { get; public set; }
    public Double[] Work { get; public set; }
    public BoundedBroydenFletcherGoldfarbShannoInnerStatus(Int32[] isave, Double[] dsave, Boolean[] lsave, string csave, Double[] work);
    [CompilerGeneratedAttribute]
public Int32[] get_Integers();
    [CompilerGeneratedAttribute]
public void set_Integers(Int32[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Doubles();
    [CompilerGeneratedAttribute]
public void set_Doubles(Double[] value);
    [CompilerGeneratedAttribute]
public Boolean[] get_Booleans();
    [CompilerGeneratedAttribute]
public void set_Booleans(Boolean[] value);
    [CompilerGeneratedAttribute]
public string get_Strings();
    [CompilerGeneratedAttribute]
public void set_Strings(string value);
    [CompilerGeneratedAttribute]
public Double[] get_Work();
    [CompilerGeneratedAttribute]
public void set_Work(Double[] value);
}
public enum Accord.Math.Optimization.BoundedBroydenFletcherGoldfarbShannoStatus : Enum {
    public int value__;
    public static BoundedBroydenFletcherGoldfarbShannoStatus Stop;
    public static BoundedBroydenFletcherGoldfarbShannoStatus MaximumIterations;
    public static BoundedBroydenFletcherGoldfarbShannoStatus FunctionConvergence;
    public static BoundedBroydenFletcherGoldfarbShannoStatus GradientConvergence;
    [DescriptionAttribute("ABNORMAL_TERMINATION_IN_LNSRCH")]
public static BoundedBroydenFletcherGoldfarbShannoStatus LineSearchFailed;
}
public class Accord.Math.Optimization.BrentSearch : object {
    private static int DefaultMaxIterations;
    private static double DefaultTolerance;
    [CompilerGeneratedAttribute]
private double <Tolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LowerBound>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UpperBound>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private BrentSearchStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<double, double> <Function>k__BackingField;
    public int NumberOfVariables { get; public set; }
    public double Tolerance { get; public set; }
    public double LowerBound { get; public set; }
    public double UpperBound { get; public set; }
    public double Solution { get; public set; }
    public double Value { get; private set; }
    public int MaxIterations { get; public set; }
    public BrentSearchStatus Status { get; private set; }
    public Func`2<double, double> Function { get; private set; }
    public BrentSearch(Func`2<double, double> function, double lowerBound, double upperBound, double tol, int maxIterations);
    public sealed virtual int get_NumberOfVariables();
    public sealed virtual void set_NumberOfVariables(int value);
    [CompilerGeneratedAttribute]
public double get_Tolerance();
    [CompilerGeneratedAttribute]
public void set_Tolerance(double value);
    [CompilerGeneratedAttribute]
public double get_LowerBound();
    [CompilerGeneratedAttribute]
public void set_LowerBound(double value);
    [CompilerGeneratedAttribute]
public double get_UpperBound();
    [CompilerGeneratedAttribute]
public void set_UpperBound(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Solution();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Solution(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    [CompilerGeneratedAttribute]
public int get_MaxIterations();
    [CompilerGeneratedAttribute]
public void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public BrentSearchStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(BrentSearchStatus value);
    [CompilerGeneratedAttribute]
public Func`2<double, double> get_Function();
    [CompilerGeneratedAttribute]
private void set_Function(Func`2<double, double> value);
    public bool FindRoot();
    public bool Find(double value);
    public sealed virtual bool Minimize();
    public sealed virtual bool Maximize();
    public static double Minimize(Func`2<double, double> function, double lowerBound, double upperBound, double tol, int maxIterations);
    public static double Maximize(Func`2<double, double> function, double lowerBound, double upperBound, double tol, int maxIterations);
    public static double FindRoot(Func`2<double, double> function, double lowerBound, double upperBound, double tol, int maxIterations);
    public static double Find(Func`2<double, double> function, double value, double lowerBound, double upperBound, double tol, int maxIterations);
    private static BrentSearchResult MinimizeInternal(Func`2<double, double> function, double lowerBound, double upperBound, double tol, int maxIterations);
    private static BrentSearchResult FindRootInternal(Func`2<double, double> function, double lowerBound, double upperBound, double tol, int maxIterations);
    private static double HandleResult(BrentSearchResult result);
    [CompilerGeneratedAttribute]
private double <Maximize>b__41_0(double x);
}
public enum Accord.Math.Optimization.BrentSearchStatus : Enum {
    public byte value__;
    public static BrentSearchStatus None;
    public static BrentSearchStatus Success;
    public static BrentSearchStatus RootNotBracketed;
    public static BrentSearchStatus FunctionNotFinite;
    public static BrentSearchStatus MaxIterationsReached;
}
public class Accord.Math.Optimization.BroydenFletcherGoldfarbShanno : BaseGradientOptimizationMethod {
    private int m;
    private double epsilon;
    private int past;
    private double delta;
    private int max_iterations;
    private LineSearch linesearch;
    private int max_linesearch;
    private double min_step;
    private double max_step;
    private double ftol;
    private double wolfe;
    private double gtol;
    private double xtol;
    private double orthantwise_c;
    private int orthantwise_start;
    private int orthantwise_end;
    [CompilerGeneratedAttribute]
private EventHandler`1<OptimizationProgressEventArgs> Progress;
    [CompilerGeneratedAttribute]
private BroydenFletcherGoldfarbShannoStatus <Status>k__BackingField;
    public int Corrections { get; public set; }
    public double Epsilon { get; public set; }
    public int Past { get; public set; }
    public double Delta { get; public set; }
    public int MaxIterations { get; public set; }
    public LineSearch LineSearch { get; public set; }
    public int MaxLineSearch { get; public set; }
    public double MinStep { get; public set; }
    public double MaxStep { get; public set; }
    public double ParameterTolerance { get; public set; }
    public double Wolfe { get; public set; }
    public double GradientTolerance { get; public set; }
    public double FunctionTolerance { get; public set; }
    public double OrthantwiseC { get; public set; }
    public int OrthantwiseStart { get; public set; }
    public int OrthantwiseEnd { get; public set; }
    public BroydenFletcherGoldfarbShannoStatus Status { get; public set; }
    public BroydenFletcherGoldfarbShanno(int numberOfVariables);
    public BroydenFletcherGoldfarbShanno(NonlinearObjectiveFunction function);
    public BroydenFletcherGoldfarbShanno(int numberOfVariables, Func`2<Double[], double> function, Func`2<Double[], Double[]> gradient);
    public int get_Corrections();
    public void set_Corrections(int value);
    public double get_Epsilon();
    public void set_Epsilon(double value);
    public int get_Past();
    public void set_Past(int value);
    public double get_Delta();
    public void set_Delta(double value);
    public int get_MaxIterations();
    public void set_MaxIterations(int value);
    public LineSearch get_LineSearch();
    public void set_LineSearch(LineSearch value);
    public int get_MaxLineSearch();
    public void set_MaxLineSearch(int value);
    public double get_MinStep();
    public void set_MinStep(double value);
    public double get_MaxStep();
    public void set_MaxStep(double value);
    public double get_ParameterTolerance();
    public void set_ParameterTolerance(double value);
    public double get_Wolfe();
    public void set_Wolfe(double value);
    public double get_GradientTolerance();
    public void set_GradientTolerance(double value);
    public double get_FunctionTolerance();
    public void set_FunctionTolerance(double value);
    public double get_OrthantwiseC();
    public void set_OrthantwiseC(double value);
    public int get_OrthantwiseStart();
    public void set_OrthantwiseStart(int value);
    public int get_OrthantwiseEnd();
    public void set_OrthantwiseEnd(int value);
    [CompilerGeneratedAttribute]
public void add_Progress(EventHandler`1<OptimizationProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Progress(EventHandler`1<OptimizationProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual BroydenFletcherGoldfarbShannoStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(BroydenFletcherGoldfarbShannoStatus value);
    protected virtual void OnNumberOfVariablesChanged(int numberOfVariables);
    protected virtual bool Optimize();
}
public enum Accord.Math.Optimization.BroydenFletcherGoldfarbShannoStatus : Enum {
    public int value__;
    [DescriptionAttribute("LBFGS_SUCCESS")]
public static BroydenFletcherGoldfarbShannoStatus Success;
    [DescriptionAttribute("LBFGS_STOP")]
public static BroydenFletcherGoldfarbShannoStatus Stop;
    [DescriptionAttribute("LBFGS_ALREADY_MINIMIZED")]
public static BroydenFletcherGoldfarbShannoStatus AlreadyMinimized;
    [DescriptionAttribute("LBFGSERR_UNKNOWNERROR")]
public static BroydenFletcherGoldfarbShannoStatus UnknownError;
    [DescriptionAttribute("LBFGSERR_OUTOFINTERVAL")]
public static BroydenFletcherGoldfarbShannoStatus OutOfInterval;
    [DescriptionAttribute("LBFGSERR_INCORRECT_TMINMAX")]
public static BroydenFletcherGoldfarbShannoStatus IncorrectMinMax;
    [DescriptionAttribute("LBFGSERR_ROUNDING_ERROR")]
public static BroydenFletcherGoldfarbShannoStatus RoundingError;
    [DescriptionAttribute("LBFGSERR_MINIMUMSTEP")]
public static BroydenFletcherGoldfarbShannoStatus MinimumStep;
    [DescriptionAttribute("LBFGSERR_MAXIMUMSTEP")]
public static BroydenFletcherGoldfarbShannoStatus MaximumStep;
    [DescriptionAttribute("LBFGSERR_MAXIMUMLINESEARCH")]
public static BroydenFletcherGoldfarbShannoStatus MaximumLineSearch;
    [DescriptionAttribute("LBFGSERR_MAXIMUMITERATION")]
public static BroydenFletcherGoldfarbShannoStatus MaximumIterations;
    [DescriptionAttribute("LBFGSERR_WIDTHTOOSMALL")]
public static BroydenFletcherGoldfarbShannoStatus IntervalWidthTooSmall;
    [DescriptionAttribute("LBFGSERR_INVALIDPARAMETERS")]
public static BroydenFletcherGoldfarbShannoStatus InvalidParameters;
    [DescriptionAttribute("LBFGSERR_INCREASEGRADIENT")]
public static BroydenFletcherGoldfarbShannoStatus IncreaseGradient;
}
public class Accord.Math.Optimization.Cobyla : BaseOptimizationMethod {
    private double rhobeg;
    private double rhoend;
    private int maxfun;
    private int iterations;
    private NonlinearConstraint[] constraints;
    [CompilerGeneratedAttribute]
private CobylaStatus <Status>k__BackingField;
    public int Iterations { get; }
    public int MaxIterations { get; public set; }
    public CobylaStatus Status { get; private set; }
    public Cobyla(int numberOfVariables);
    public Cobyla(int numberOfVariables, Func`2<Double[], double> function);
    public Cobyla(NonlinearObjectiveFunction function);
    public Cobyla(NonlinearObjectiveFunction function, IEnumerable`1<NonlinearConstraint> constraints);
    public Cobyla(NonlinearObjectiveFunction function, NonlinearConstraint[] constraints);
    public int get_Iterations();
    public int get_MaxIterations();
    public void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public sealed virtual CobylaStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(CobylaStatus value);
    protected virtual bool Optimize();
    private CobylaStatus cobyla();
    private static void trstlp(int n, int m, Double[0...,0...] a, Double[] b, double rho, Double[] dx, Boolean& ifull);
}
public enum Accord.Math.Optimization.CobylaStatus : Enum {
    public int value__;
    public static CobylaStatus Success;
    public static CobylaStatus MaxIterationsReached;
    public static CobylaStatus DivergingRoundingErrors;
    public static CobylaStatus NoPossibleSolution;
}
public class Accord.Math.Optimization.ConjugateGradient : BaseGradientOptimizationMethod {
    private Double[] g;
    private Double[] d;
    private Double[] gold;
    private Double[] w;
    private double ftol;
    private double gtol;
    private double xtol;
    private double stpmin;
    private double stpmax;
    private double epsilon;
    private int maxfev;
    private int iterations;
    private int evaluations;
    private int searches;
    private int maxIterations;
    private double tolerance;
    [CompilerGeneratedAttribute]
private ConjugateGradientMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private ConjugateGradientCode <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<OptimizationProgressEventArgs> Progress;
    private bool brackt;
    private bool stage1;
    private double finit;
    private double dgtest;
    private double width;
    private double width1;
    private double stmin;
    private double stmax;
    private double dg2;
    private double dgx;
    private double dgy;
    private int infoc;
    private double stx;
    private double fx;
    private double sty;
    private double fy;
    private double ftest1;
    public double Tolerance { get; public set; }
    public int MaxIterations { get; public set; }
    public ConjugateGradientMethod Method { get; public set; }
    public int Iterations { get; }
    public int Evaluations { get; }
    public int Searches { get; }
    public ConjugateGradientCode Status { get; private set; }
    public ConjugateGradient(int numberOfVariables);
    public ConjugateGradient(int numberOfVariables, Func`2<Double[], double> function, Func`2<Double[], Double[]> gradient);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public int get_MaxIterations();
    public void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public ConjugateGradientMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(ConjugateGradientMethod value);
    public int get_Iterations();
    public int get_Evaluations();
    public int get_Searches();
    [CompilerGeneratedAttribute]
public sealed virtual ConjugateGradientCode get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(ConjugateGradientCode value);
    [CompilerGeneratedAttribute]
public void add_Progress(EventHandler`1<OptimizationProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Progress(EventHandler`1<OptimizationProgressEventArgs> value);
    protected virtual void OnNumberOfVariablesChanged(int numberOfVariables);
    protected virtual bool Optimize();
    private ConjugateGradientCode cvsmod(Double& f, Double[] s, Double& stp, Int32& info, Int32& nfev, Double[] wa, Double& dginit, Double& dgout);
}
public enum Accord.Math.Optimization.ConjugateGradientCode : Enum {
    public int value__;
    public static ConjugateGradientCode Success;
    public static ConjugateGradientCode StepSize;
    public static ConjugateGradientCode DescentNotObtained;
    public static ConjugateGradientCode RoundingErrors;
    public static ConjugateGradientCode StepHigh;
    public static ConjugateGradientCode StepLow;
    public static ConjugateGradientCode MaximumEvaluations;
    public static ConjugateGradientCode Precision;
}
public enum Accord.Math.Optimization.ConjugateGradientMethod : Enum {
    public int value__;
    public static ConjugateGradientMethod FletcherReeves;
    public static ConjugateGradientMethod PolakRibiere;
    public static ConjugateGradientMethod PositivePolakRibiere;
}
[ExtensionAttribute]
public static class Accord.Math.Optimization.ConstraintExtensions : object {
    [ExtensionAttribute]
public static double GetViolation(IConstraint constraint, Double[] input);
    [ExtensionAttribute]
public static bool IsViolated(IConstraint constraint, Double[] input);
}
public enum Accord.Math.Optimization.ConstraintType : Enum {
    public int value__;
    public static ConstraintType EqualTo;
    public static ConstraintType GreaterThanOrEqualTo;
    public static ConstraintType LesserThanOrEqualTo;
}
internal static class Accord.Math.Optimization.ExpressionParser : object {
    public static void Parse(SortedSet`1<string> list, Expression expr);
    public static Expression`1<Func`2<Double[], Double[]>> Replace(Expression`1<Func`1<Double[]>> expr, IDictionary`2<string, int> variables);
    public static Expression`1<Func`2<Double[], double>> Replace(Expression`1<Func`1<double>> expr, IDictionary`2<string, int> variables);
    public static Expression Replace(ParameterExpression parameter, Expression expr, IDictionary`2<string, int> variables);
}
public class Accord.Math.Optimization.FanChenLinQuadraticOptimization : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private static double TAU;
    private int active_size;
    private Int32[] y;
    private Double[] G;
    private Status[] alpha_status;
    private Double[] alpha;
    private Func`5<int, Int32[], int, Double[], Double[]> Q;
    private Double[] temp;
    private Double[] QD;
    private double eps;
    private Double[] C;
    private Double[] p;
    private Int32[] active_set;
    private Int32[] indices;
    private Double[] G_bar;
    private int l;
    private bool unshrink;
    private bool shrinking;
    private double rho;
    private double obj;
    public int NumberOfVariables { get; public set; }
    public Double[] Solution { get; public set; }
    public CancellationToken Token { get; public set; }
    public double Value { get; }
    public double Rho { get; }
    public double Tolerance { get; public set; }
    public bool Shrinking { get; public set; }
    public Double[] UpperBounds { get; public set; }
    public FanChenLinQuadraticOptimization(int numberOfVariables, Func`5<int, Int32[], int, Double[], Double[]> Q);
    public FanChenLinQuadraticOptimization(int numberOfVariables, Func`5<int, Int32[], int, Double[], Double[]> Q, Double[] p, Int32[] y);
    public sealed virtual int get_NumberOfVariables();
    public sealed virtual void set_NumberOfVariables(int value);
    public sealed virtual Double[] get_Solution();
    public sealed virtual void set_Solution(Double[] value);
    public CancellationToken get_Token();
    public void set_Token(CancellationToken value);
    public sealed virtual double get_Value();
    public double get_Rho();
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public bool get_Shrinking();
    public void set_Shrinking(bool value);
    public Double[] get_UpperBounds();
    public void set_UpperBounds(Double[] value);
    private void initialize(int numberOfVariables, Func`5<int, Int32[], int, Double[], Double[]> Q, Double[] p, Int32[] y);
    private void setNumberOfVariables(int numberOfVariables);
    public sealed virtual bool Minimize();
    public sealed virtual bool Maximize();
    private void update_alpha_status(int i);
    private bool is_upper_bound(int i);
    private bool is_lower_bound(int i);
    private bool is_free(int i);
    private void reconstruct_gradient();
    private int select_working_set(Int32& out_i, Int32& out_j);
    private double calculate_rho();
    private void do_shrinking();
    private bool be_shrunk(int i, double Gmax1, double Gmax2);
    private void swap_index(int i, int j);
    private static void swap(T[] array, int i, int j);
}
public class Accord.Math.Optimization.GaussNewton : BaseLeastSquaresMethod {
    private Double[] gradient;
    private Double[] errors;
    private Double[] deltas;
    private Double[][] hessian;
    private Double[][] jacobian;
    private JaggedSingularValueDecomposition decomposition;
    public Double[][] Hessian { get; }
    public Double[] Residuals { get; }
    public Double[][] Jacobian { get; }
    public Double[] Deltas { get; }
    public Double[] StandardErrors { get; }
    public GaussNewton(int parameters);
    public Double[][] get_Hessian();
    public Double[] get_Residuals();
    public Double[][] get_Jacobian();
    public Double[] get_Deltas();
    public sealed virtual Double[] get_StandardErrors();
    protected virtual void Initialize();
    public sealed virtual double Minimize(Double[][] inputs, Double[] outputs);
    private double iterate(Double[][] inputs, Double[] outputs);
    [CompilerGeneratedAttribute]
private Double[] <iterate>b__20_0();
}
public class Accord.Math.Optimization.GoldfarbIdnani : BaseGradientOptimizationMethod {
    private Double[0...,0...] hessian;
    private Double[] linearTerms;
    private Double[0...,0...] constraintMatrix;
    private Double[] constraintValues;
    private Double[] constraintTolerances;
    private int r;
    private Double[] work;
    private Double[] iwrv;
    private Double[] iwzv;
    private Double[] iwuv;
    private Double[] iwrm;
    private Double[] iwsv;
    private Double[] iwnbv;
    [CompilerGeneratedAttribute]
private int <NumberOfConstraints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfEqualities>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Deletions>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Lagrangian>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ActiveConstraints>k__BackingField;
    [CompilerGeneratedAttribute]
private GoldfarbIdnaniStatus <Status>k__BackingField;
    public int NumberOfConstraints { get; private set; }
    public int NumberOfEqualities { get; private set; }
    public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public int Deletions { get; public set; }
    public Double[] Lagrangian { get; private set; }
    public Int32[] ActiveConstraints { get; private set; }
    public Double[0...,0...] ConstraintMatrix { get; }
    public Double[] ConstraintValues { get; }
    public Double[] ConstraintTolerances { get; }
    public Double[0...,0...] QuadraticTerms { get; }
    public Double[] LinearTerms { get; }
    public GoldfarbIdnaniStatus Status { get; private set; }
    public GoldfarbIdnani(QuadraticObjectiveFunction function, IEnumerable`1<LinearConstraint> constraints);
    public GoldfarbIdnani(QuadraticObjectiveFunction function, LinearConstraintCollection constraints);
    public GoldfarbIdnani(QuadraticObjectiveFunction function, Double[0...,0...] constraintMatrix, Double[] constraintValues, int numberOfEqualities);
    public GoldfarbIdnani(Double[0...,0...] quadratic, Double[] linear, Double[0...,0...] constraintMatrix, Double[] constraintValues, int numberOfEqualities);
    [CompilerGeneratedAttribute]
public int get_NumberOfConstraints();
    [CompilerGeneratedAttribute]
private void set_NumberOfConstraints(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfEqualities();
    [CompilerGeneratedAttribute]
private void set_NumberOfEqualities(int value);
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public void set_Iterations(int value);
    [CompilerGeneratedAttribute]
public int get_MaxIterations();
    [CompilerGeneratedAttribute]
public void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public int get_Deletions();
    [CompilerGeneratedAttribute]
public void set_Deletions(int value);
    [CompilerGeneratedAttribute]
public Double[] get_Lagrangian();
    [CompilerGeneratedAttribute]
private void set_Lagrangian(Double[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_ActiveConstraints();
    [CompilerGeneratedAttribute]
private void set_ActiveConstraints(Int32[] value);
    public Double[0...,0...] get_ConstraintMatrix();
    public Double[] get_ConstraintValues();
    public Double[] get_ConstraintTolerances();
    public Double[0...,0...] get_QuadraticTerms();
    public Double[] get_LinearTerms();
    [CompilerGeneratedAttribute]
public sealed virtual GoldfarbIdnaniStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(GoldfarbIdnaniStatus value);
    private void initialize(int numberOfVariables, Double[0...,0...] hessian, Double[] linearTerms, Double[0...,0...] constraintMatrix, Double[] b, int numberOfEqualities);
    public virtual bool Minimize();
    public virtual bool Maximize();
    protected virtual bool Optimize();
    private GoldfarbIdnaniStatus minimize(Double[0...,0...] D, Double[] d);
    private void qpgen2(Double[0...,0...] dmat, Double[] dvec, Int32[] iact, Int32& nact, Int32& ierr);
    private void dpori(Double[0...,0...] a);
    private void dposl(Double[0...,0...] a, Double[] b);
    private bool dpofa(Double[0...,0...] a);
}
public enum Accord.Math.Optimization.GoldfarbIdnaniStatus : Enum {
    public int value__;
    public static GoldfarbIdnaniStatus Success;
    public static GoldfarbIdnaniStatus NonPositiveDefinite;
    public static GoldfarbIdnaniStatus NoPossibleSolution;
}
public class Accord.Math.Optimization.GradientDescent : BaseGradientOptimizationMethod {
    private RelativeConvergence convergence;
    private double eta;
    private int numberOfUpdatesBeforeConvergenceCheck;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressChangedEventArgs> ProgressChanged;
    public double LearningRate { get; public set; }
    public double Tolerance { get; public set; }
    public int Iterations { get; public set; }
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    public double get_LearningRate();
    public void set_LearningRate(double value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public int get_Iterations();
    public void set_Iterations(int value);
    protected virtual bool Optimize();
    protected void OnProgressChanged(ProgressChangedEventArgs args);
}
public interface Accord.Math.Optimization.IConstraint {
    public ConstraintType ShouldBe { get; }
    public double Value { get; }
    public double Tolerance { get; }
    public int NumberOfVariables { get; }
    public abstract virtual ConstraintType get_ShouldBe();
    public abstract virtual double get_Value();
    public abstract virtual double get_Tolerance();
    public abstract virtual int get_NumberOfVariables();
    public abstract virtual double Function(Double[] x);
    public abstract virtual Double[] Gradient(Double[] x);
}
public interface Accord.Math.Optimization.IFunctionOptimizationMethod`2 {
    public Func`2<TInput, TOutput> Function { get; public set; }
    public abstract virtual Func`2<TInput, TOutput> get_Function();
    public abstract virtual void set_Function(Func`2<TInput, TOutput> value);
}
public interface Accord.Math.Optimization.IGradientOptimizationMethod {
}
public interface Accord.Math.Optimization.IGradientOptimizationMethod`2 {
    public Func`2<TInput, TInput> Gradient { get; public set; }
    public abstract virtual Func`2<TInput, TInput> get_Gradient();
    public abstract virtual void set_Gradient(Func`2<TInput, TInput> value);
}
public interface Accord.Math.Optimization.ILeastSquaresMethod {
    public CancellationToken Token { get; public set; }
    public LeastSquaresFunction Function { get; public set; }
    public LeastSquaresGradientFunction Gradient { get; public set; }
    public int NumberOfVariables { get; public set; }
    public Double[] Solution { get; public set; }
    public Double[] StandardErrors { get; }
    public double Value { get; public set; }
    public abstract virtual CancellationToken get_Token();
    public abstract virtual void set_Token(CancellationToken value);
    public abstract virtual LeastSquaresFunction get_Function();
    public abstract virtual void set_Function(LeastSquaresFunction value);
    public abstract virtual LeastSquaresGradientFunction get_Gradient();
    public abstract virtual void set_Gradient(LeastSquaresGradientFunction value);
    public abstract virtual int get_NumberOfVariables();
    public abstract virtual void set_NumberOfVariables(int value);
    public abstract virtual double Minimize(Double[][] inputs, Double[] outputs);
    public abstract virtual Double[] get_Solution();
    public abstract virtual void set_Solution(Double[] value);
    public abstract virtual Double[] get_StandardErrors();
    public abstract virtual double get_Value();
    public abstract virtual void set_Value(double value);
}
public interface Accord.Math.Optimization.IObjectiveFunction {
    public IDictionary`2<string, int> Variables { get; }
    public IDictionary`2<int, string> Indices { get; }
    public int NumberOfVariables { get; }
    public Func`2<Double[], double> Function { get; }
    public abstract virtual IDictionary`2<string, int> get_Variables();
    public abstract virtual IDictionary`2<int, string> get_Indices();
    public abstract virtual int get_NumberOfVariables();
    public abstract virtual Func`2<Double[], double> get_Function();
}
public interface Accord.Math.Optimization.IOptimizationMethod {
}
public interface Accord.Math.Optimization.IOptimizationMethod`1 {
}
public interface Accord.Math.Optimization.IOptimizationMethod`2 {
    public int NumberOfVariables { get; public set; }
    public TInput Solution { get; public set; }
    public TOutput Value { get; }
    public abstract virtual int get_NumberOfVariables();
    public abstract virtual void set_NumberOfVariables(int value);
    public abstract virtual TInput get_Solution();
    public abstract virtual void set_Solution(TInput value);
    public abstract virtual TOutput get_Value();
    public abstract virtual bool Minimize();
    public abstract virtual bool Maximize();
}
public interface Accord.Math.Optimization.IOptimizationMethod`3 {
    public TCode Status { get; }
    public abstract virtual TCode get_Status();
}
internal static class Accord.Math.Optimization.LBFGS : object {
    private static lbfgs_parameter_t _defparam;
    private static LBFGS();
    internal static int main(Double[] start, Func`2<Double[], double> fn, Func`2<Double[], Double[]> gn, EventHandler`1<OptimizationProgressEventArgs> progress, lbfgs_parameter_t param);
    private static lbfgs_progress_t ProgressMethod(EventHandler`1<OptimizationProgressEventArgs> progress);
    private static lbfgs_evaluate_t NewMethod(Func`2<Double[], double> fn, Func`2<Double[], Double[]> gn);
    private static bool fsigndiff(double x, double y);
    private static Double[] vecalloc(int size);
    private static void veccpy(Double[] y, Double[] x, int n);
    private static void vecncpy(Double[] y, Double[] x, int n);
    private static void vecadd(Double[] y, Double[] x, double c, int n);
    private static void vecdiff(Double[] z, Double[] x, Double[] y, int n);
    private static void vecscale(Double[] y, double c, int n);
    private static void vecdot(Double& s, Double[] x, Double[] y, int n);
    private static void vec2norm(Double& s, Double[] x, int n);
    private static void vec2norminv(Double& s, Double[] x, int n);
    private static Code lbfgs(int n, Double[] x, Double& ptr_fx, lbfgs_evaluate_t proc_evaluate, lbfgs_progress_t proc_progress, object instance, lbfgs_parameter_t _param);
    private static Code line_search_backtracking(int n, Double[] x, Double& f, Double[] g, Double[] s, Double& stp, Double[] xp, Double[] gp, Double[] wp, callback_data_t& cd, lbfgs_parameter_t& param);
    private static Code line_search_backtracking_owlqn(int n, Double[] x, Double& f, Double[] g, Double[] s, Double& stp, Double[] xp, Double[] gp, Double[] wp, callback_data_t& cd, lbfgs_parameter_t& param);
    private static Code line_search_morethuente(int n, Double[] x, Double& f, Double[] g, Double[] s, Double& stp, Double[] xp, Double[] gp, Double[] wa, callback_data_t& cd, lbfgs_parameter_t& param);
    private static void CUBIC_MINIMIZER(Double& cm, Double& u, Double& fu, Double& du, Double& v, Double& fv, Double& dv, Double& a, Double& d, Double& gamma, Double& theta, Double& p, Double& q, Double& r, Double& s);
    private static void CUBIC_MINIMIZER2(Double& cm, Double& u, Double& fu, Double& du, Double& v, Double& fv, Double& dv, Double& xmin, Double& xmax, Double& a, Double& d, Double& gamma, Double& theta, Double& p, Double& q, Double& r, Double& s);
    public static void QUARD_MINIMIZER(Double& qm, Double& u, Double& fu, Double& du, Double& v, Double& fv, Double& a);
    public static void QUARD_MINIMIZER2(Double& qm, Double& u, Double& du, Double& v, Double& dv, Double& a);
    private static Code update_trial_interval(Double& x, Double& fx, Double& dx, Double& y, Double& fy, Double& dy, Double& t, Double& ft, Double& dt, double tmin, double tmax, Int32& brackt);
    private static double owlqn_x1norm(Double[] x, int start, int n);
    private static void owlqn_pseudo_gradient(Double[] pg, Double[] x, Double[] g, int n, double c, int start, int end);
    private static void owlqn_project(Double[] d, Double[] sign, int start, int end);
}
internal class Accord.Math.Optimization.lbfgs_parameter_t : object {
    public int m;
    public double epsilon;
    public int past;
    public double delta;
    public int max_iterations;
    public LineSearch linesearch;
    public int max_linesearch;
    public double min_step;
    public double max_step;
    public double ftol;
    public double wolfe;
    public double gtol;
    public double xtol;
    public double orthantwise_c;
    public int orthantwise_start;
    public int orthantwise_end;
}
public class Accord.Math.Optimization.LeastSquaresFunction : MulticastDelegate {
    public LeastSquaresFunction(object object, IntPtr method);
    public virtual double Invoke(Double[] parameters, Double[] input);
    public virtual IAsyncResult BeginInvoke(Double[] parameters, Double[] input, AsyncCallback callback, object object);
    public virtual double EndInvoke(IAsyncResult result);
}
public class Accord.Math.Optimization.LeastSquaresGradientFunction : MulticastDelegate {
    public LeastSquaresGradientFunction(object object, IntPtr method);
    public virtual void Invoke(Double[] parameters, Double[] input, Double[] result);
    public virtual IAsyncResult BeginInvoke(Double[] parameters, Double[] input, Double[] result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Accord.Math.Optimization.LevenbergMarquardt : BaseLeastSquaresMethod {
    private static double lambdaMax;
    private Double[][] jacobian;
    private Double[][] hessian;
    private Double[] diagonal;
    private Double[] gradient;
    private Double[] weights;
    private Double[] deltas;
    private Double[] errors;
    private double lambda;
    private double v;
    private int blocks;
    private int outputCount;
    private JaggedCholeskyDecomposition decomposition;
    public double LearningRate { get; public set; }
    public double Adjustment { get; public set; }
    public int Blocks { get; public set; }
    public Double[][] Hessian { get; }
    public Double[] StandardErrors { get; }
    public LevenbergMarquardt(int parameters);
    public double get_LearningRate();
    public void set_LearningRate(double value);
    public double get_Adjustment();
    public void set_Adjustment(double value);
    public int get_Blocks();
    public void set_Blocks(int value);
    public Double[][] get_Hessian();
    public sealed virtual Double[] get_StandardErrors();
    protected virtual void Initialize();
    public sealed virtual double Minimize(Double[][] inputs, Double[] outputs);
    private double iterate(Double[][] inputs, Double[] outputs, int blockSize, int finalBlock, int jacobianSize);
    private double computeErrors(Double[][] input, Double[] output, Int32[] block);
    private void computeJacobian(Double[][] input, Int32[] block);
    [CompilerGeneratedAttribute]
private void <iterate>b__30_0(int i);
}
public class Accord.Math.Optimization.LinearConstraint : object {
    public static double DefaultTolerance;
    private Int32[] indices;
    private Double[] combinedAs;
    private Double[] grad;
    [CompilerGeneratedAttribute]
private int <NumberOfVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstraintType <ShouldBe>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Tolerance>k__BackingField;
    public int NumberOfVariables { get; private set; }
    public Int32[] VariablesAtIndices { get; public set; }
    public Double[] CombinedAs { get; public set; }
    public ConstraintType ShouldBe { get; public set; }
    public double Value { get; public set; }
    public double Tolerance { get; public set; }
    public LinearConstraint(int numberOfVariables);
    public LinearConstraint(Double[] coefficients);
    public LinearConstraint(IObjectiveFunction function, string constraint, CultureInfo format);
    public LinearConstraint(IObjectiveFunction function, string constraint);
    public LinearConstraint(IObjectiveFunction function, Expression`1<Func`1<bool>> constraint);
    [CompilerGeneratedAttribute]
public sealed virtual int get_NumberOfVariables();
    [CompilerGeneratedAttribute]
private void set_NumberOfVariables(int value);
    public Int32[] get_VariablesAtIndices();
    public void set_VariablesAtIndices(Int32[] value);
    public Double[] get_CombinedAs();
    public void set_CombinedAs(Double[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ConstraintType get_ShouldBe();
    [CompilerGeneratedAttribute]
public void set_ShouldBe(ConstraintType value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Tolerance();
    [CompilerGeneratedAttribute]
public void set_Tolerance(double value);
    public static bool TryParse(string str, IObjectiveFunction function, LinearConstraint& constraint);
    public static bool TryParse(string str, CultureInfo culture, IObjectiveFunction function, LinearConstraint& constraint);
    public sealed virtual double Function(Double[] x);
    public sealed virtual Double[] Gradient(Double[] x);
    private void parseString(IObjectiveFunction function, string constraint, CultureInfo culture);
    private void parseExpression(IObjectiveFunction function, Expression`1<Func`1<bool>> constraint);
    private static string parse(Dictionary`2<string, double> terms, Expression expr, Double& value);
}
public class Accord.Math.Optimization.LinearConstraintCollection : Collection`1<LinearConstraint> {
    public LinearConstraintCollection(IEnumerable`1<LinearConstraint> list);
    public LinearConstraintCollection(IList`1<LinearConstraint> list);
    public Double[0...,0...] CreateMatrix(int numberOfVariables, Double[]& b, Int32& equalities);
    public Double[0...,0...] CreateMatrix(int numberOfVariables, Double[]& b, Double[]& tolerances, Int32& equalities);
    [ObsoleteAttribute("This method is obsolete because the convention is inconsistent with GoldfarbIdnani. Use Create(...) instead.")]
public static LinearConstraintCollection FromMatrix(Double[0...,0...] a, Double[] b, int meq);
    public static LinearConstraintCollection Create(Double[0...,0...] a, Double[] b, int meq);
}
public enum Accord.Math.Optimization.LineSearch : Enum {
    public int value__;
    public static LineSearch Default;
    public static LineSearch BacktrackingArmijo;
    public static LineSearch RegularWolfe;
    public static LineSearch StrongWolfe;
}
[SerializableAttribute]
public class Accord.Math.Optimization.LineSearchFailedException : Exception {
    private int info;
    public int Information { get; }
    public LineSearchFailedException(int info, string message);
    public LineSearchFailedException(string message);
    public LineSearchFailedException(string message, Exception innerException);
    protected LineSearchFailedException(SerializationInfo info, StreamingContext context);
    public int get_Information();
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.AbsoluteLoss : LossBase`1<Double[][]> {
    private bool mean;
    public bool Mean { get; public set; }
    public AbsoluteLoss(Double[][] expected);
    public bool get_Mean();
    public void set_Mean(bool value);
    public virtual double Loss(Double[][] actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.AccuracyLoss : ZeroOneLoss {
    public AccuracyLoss(Double[][] expected);
    public AccuracyLoss(Double[] expected);
    public AccuracyLoss(Int32[] expected);
    public AccuracyLoss(Boolean[] expected);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.BinaryCrossEntropyLoss : LossBase`1<Boolean[][]> {
    public BinaryCrossEntropyLoss(Int32[][] expected);
    public BinaryCrossEntropyLoss(Double[][] expected);
    public BinaryCrossEntropyLoss(Double[] expected);
    public BinaryCrossEntropyLoss(Boolean[] expected);
    public BinaryCrossEntropyLoss(Int32[] expected);
    public virtual double Loss(Boolean[][] actual);
    public sealed virtual double Loss(Double[][] actual);
    public sealed virtual double Loss(Double[] actual);
    public sealed virtual double Loss(Int32[] actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.CategoryCrossEntropyLoss : LossBase`1<Boolean[][]> {
    public CategoryCrossEntropyLoss(Double[][] expected);
    public CategoryCrossEntropyLoss(Int32[] expected);
    public CategoryCrossEntropyLoss(Boolean[][] expected);
    public virtual double Loss(Boolean[][] actual);
    public sealed virtual double Loss(Double[][] actual);
    public sealed virtual double Loss(Int32[] actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.EuclideanLoss : SquareLoss {
    public EuclideanLoss(Double[][] expected);
    public EuclideanLoss(Double[] expected);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.HammingLoss : LossBase`1<Int32[][]> {
    private bool mean;
    private int total;
    public bool Mean { get; public set; }
    public HammingLoss(Double[][] expected);
    public HammingLoss(Int32[][] expected);
    public HammingLoss(Int32[] expected);
    public HammingLoss(Boolean[][] expected);
    public bool get_Mean();
    public void set_Mean(bool value);
    public sealed virtual double Loss(Double[][] actual);
    public virtual double Loss(Int32[][] actual);
    public sealed virtual double Loss(Int32[] actual);
    public sealed virtual double Loss(Boolean[][] actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.HingeLoss : ValueType {
    private Boolean[][] expected;
    public Boolean[][] Expected { get; public set; }
    public HingeLoss(Double[][] expected);
    public HingeLoss(Double[] expected);
    public HingeLoss(Int32[] expected);
    public HingeLoss(Boolean[] expected);
    public Boolean[][] get_Expected();
    public void set_Expected(Boolean[][] value);
    public double Loss(Double[][] actual);
    public sealed virtual double Loss(Double[] actual);
    public sealed virtual double Loss(bool expected, double actual);
    public sealed virtual double Derivative(bool expected, double actual);
    public sealed virtual double Loss(double expected, double actual);
    public sealed virtual double Derivative(double expected, double actual);
}
public interface Accord.Math.Optimization.Losses.IDifferentiableLoss`3 {
    public abstract virtual TLoss Loss(TInput expected, TScore actual);
    public abstract virtual TLoss Derivative(TInput expected, TScore actual);
}
public interface Accord.Math.Optimization.Losses.ILoss`1 {
}
public interface Accord.Math.Optimization.Losses.ILoss`2 {
    public abstract virtual TLoss Loss(TScore actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.LogisticLoss : ValueType {
    private Double[][] expected;
    public Double[][] Expected { get; public set; }
    public LogisticLoss(Double[] expected);
    public LogisticLoss(Double[][] expected);
    public LogisticLoss(Int32[] expected);
    public Double[][] get_Expected();
    public void set_Expected(Double[][] value);
    public sealed virtual double Loss(Double[] actual);
    public sealed virtual double Loss(Double[][] actual);
    public sealed virtual double Loss(double expected, double actual);
    public sealed virtual double Derivative(double expected, double actual);
    public sealed virtual double Loss(bool expected, double actual);
    public sealed virtual double Derivative(bool expected, double actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.LogLikelihoodLoss : object {
    public sealed virtual double Loss(Double[][] actual);
    public sealed virtual double Loss(Double[] actual);
}
[SerializableAttribute]
public abstract class Accord.Math.Optimization.Losses.LossBase`1 : LossBase`3<T, T, double> {
}
[SerializableAttribute]
public abstract class Accord.Math.Optimization.Losses.LossBase`3 : object {
    private TInput expected;
    public TInput Expected { get; protected set; }
    public TInput get_Expected();
    protected void set_Expected(TInput value);
    public abstract virtual TLoss Loss(TScore actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.RSquaredLoss : LossBase`3<Double[][], Double[][], Double[]> {
    [CompilerGeneratedAttribute]
private int <NumberOfInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Adjust>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Weights>k__BackingField;
    public int NumberOfInputs { get; public set; }
    public bool Adjust { get; public set; }
    public Double[] Weights { get; public set; }
    public RSquaredLoss(int numberOfInputs, Double[] expected);
    public RSquaredLoss(int numberOfInputs, Double[][] expected);
    [CompilerGeneratedAttribute]
public int get_NumberOfInputs();
    [CompilerGeneratedAttribute]
public void set_NumberOfInputs(int value);
    [CompilerGeneratedAttribute]
public bool get_Adjust();
    [CompilerGeneratedAttribute]
public void set_Adjust(bool value);
    [CompilerGeneratedAttribute]
public Double[] get_Weights();
    [CompilerGeneratedAttribute]
public void set_Weights(Double[] value);
    public sealed virtual double Loss(Double[] actual);
    public virtual Double[] Loss(Double[][] actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.SmoothHingeLoss : ValueType {
    private HingeLoss hinge;
    public SmoothHingeLoss(Double[][] expected);
    public SmoothHingeLoss(Double[] expected);
    public SmoothHingeLoss(Int32[] expected);
    public SmoothHingeLoss(Boolean[] expected);
    public sealed virtual double Loss(Double[] actual);
    public sealed virtual double Loss(bool expected, double actual);
    public sealed virtual double Derivative(bool expected, double actual);
    public sealed virtual double Loss(double expected, double actual);
    public sealed virtual double Derivative(double expected, double actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.SquaredHingeLoss : ValueType {
    private HingeLoss hinge;
    public SquaredHingeLoss(Double[][] expected);
    public SquaredHingeLoss(Double[] expected);
    public SquaredHingeLoss(Int32[] expected);
    public SquaredHingeLoss(Boolean[] expected);
    public sealed virtual double Loss(Double[] actual);
    public sealed virtual double Loss(bool expected, double actual);
    public sealed virtual double Derivative(bool expected, double actual);
    public sealed virtual double Loss(double expected, double actual);
    public sealed virtual double Derivative(double expected, double actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.SquareLoss : LossBase`1<Double[][]> {
    private bool mean;
    private bool root;
    public bool Root { get; public set; }
    public bool Mean { get; public set; }
    public SquareLoss(Double[][] expected);
    public SquareLoss(Double[] expected);
    public bool get_Root();
    public void set_Root(bool value);
    public bool get_Mean();
    public void set_Mean(bool value);
    public virtual double Loss(Double[][] actual);
    public double Loss(Double[] actual);
}
[SerializableAttribute]
public class Accord.Math.Optimization.Losses.ZeroOneLoss : LossBase`1<Int32[]> {
    private bool mean;
    [CompilerGeneratedAttribute]
private int <NumberOfClasses>k__BackingField;
    public bool Mean { get; public set; }
    public int NumberOfClasses { get; public set; }
    public bool IsBinary { get; }
    public ZeroOneLoss(Double[][] expected);
    public ZeroOneLoss(int classes, Double[][] expected);
    public ZeroOneLoss(Double[] expected);
    public ZeroOneLoss(int classes, Double[] expected);
    public ZeroOneLoss(Int32[] expected);
    public ZeroOneLoss(int classes, Int32[] expected);
    public ZeroOneLoss(Boolean[] expected);
    public bool get_Mean();
    public void set_Mean(bool value);
    [CompilerGeneratedAttribute]
public int get_NumberOfClasses();
    [CompilerGeneratedAttribute]
public void set_NumberOfClasses(int value);
    public bool get_IsBinary();
    public sealed virtual double Loss(Double[][] actual);
    public virtual double Loss(Int32[] actual);
    public sealed virtual double Loss(Boolean[] actual);
    public sealed virtual double Loss(Double[] actual);
}
public class Accord.Math.Optimization.Munkres : object {
    private Double[][] originalMatrix;
    private Double[][] costMatrix;
    private Double[][] validCost;
    private Boolean[][] stars;
    private Boolean[] rowCover;
    private Boolean[] colCover;
    internal Int32[] starZ;
    internal Int32[] primeZ;
    private Boolean[][] validMap;
    private double tolerance;
    private Double[] minRow;
    private Double[] minCol;
    internal Boolean[] validRow;
    internal Boolean[] validCol;
    private int path_row_0;
    private int path_col_0;
    private int nRows;
    private int nCols;
    private int n;
    [CompilerGeneratedAttribute]
private Double[] <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public Double[] MinRow { get; }
    public Double[] MinCol { get; }
    public Boolean[] ValidRow { get; }
    public Boolean[] ValidCol { get; }
    public double Tolerance { get; public set; }
    public Double[][] CostMatrix { get; }
    public int NumberOfVariables { get; public set; }
    public int NumberOfTasks { get; }
    public int NumberOfWorkers { get; }
    public Double[] Solution { get; public set; }
    public double Value { get; protected set; }
    public Munkres(int numberOfJobs, int numberOfWorkers);
    public Munkres(Double[][] costMatrix);
    public Double[] get_MinRow();
    public Double[] get_MinCol();
    public Boolean[] get_ValidRow();
    public Boolean[] get_ValidCol();
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public Double[][] get_CostMatrix();
    public sealed virtual int get_NumberOfVariables();
    public sealed virtual void set_NumberOfVariables(int value);
    public int get_NumberOfTasks();
    public int get_NumberOfWorkers();
    [CompilerGeneratedAttribute]
public sealed virtual Double[] get_Solution();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Solution(Double[] value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
protected void set_Value(double value);
    private void init(Double[][] costMatrix);
    public sealed virtual bool Minimize();
    public sealed virtual bool Maximize();
    private bool run(Double[][] m);
    internal int RunStep(int step);
    private int step_zero();
    private int step_one();
    private int step_two();
    internal static Boolean[][] findZeros(Double[][] C, Double[] minRow, Double[] minCol, Double[][]& min);
    private int step_three();
    private int step_four();
    private List`1<Tuple`2<int, int>> find_all_zeros();
    private int step_five();
    private int step_six();
    private double find_smallest();
    private int step_seven();
    [CompilerGeneratedAttribute]
private bool <step_four>b__59_0(Tuple`2<int, int> x);
}
[CompilerGeneratedAttribute]
internal class Accord.Math.Optimization.NamespaceDoc : object {
}
public class Accord.Math.Optimization.NelderMead : BaseOptimizationMethod {
    private int nmax;
    private GeneralConvergence stop;
    private static double alpha;
    private static double beta;
    private static double gamm;
    private static double delta;
    private Double[] lb;
    private Double[] ub;
    private Double[] xstep;
    private Double[][] pts;
    private Double[] val;
    private Double[] c;
    private Double[] xcur;
    private NelderMeadStatus status;
    private double minf_max;
    private double psi;
    private double fdiff;
    public int Capacity { get; }
    public double MaximumValue { get; public set; }
    public Double[] StepSize { get; }
    public int NumberOfVariables { get; public set; }
    public GeneralConvergence Convergence { get; public set; }
    public NelderMeadStatus Status { get; }
    public Double[] LowerBounds { get; }
    public Double[] UpperBounds { get; }
    public double DiameterTolerance { get; public set; }
    public double Difference { get; }
    public NelderMead(int numberOfVariables);
    public NelderMead(int numberOfVariables, Func`2<Double[], double> function);
    public NelderMead(NonlinearObjectiveFunction function);
    private void init(int n);
    public int get_Capacity();
    public double get_MaximumValue();
    public void set_MaximumValue(double value);
    public Double[] get_StepSize();
    public virtual int get_NumberOfVariables();
    public virtual void set_NumberOfVariables(int value);
    protected virtual void OnNumberOfVariablesChanged(int numberOfVariables);
    public GeneralConvergence get_Convergence();
    public void set_Convergence(GeneralConvergence value);
    public sealed virtual NelderMeadStatus get_Status();
    public Double[] get_LowerBounds();
    public Double[] get_UpperBounds();
    public double get_DiameterTolerance();
    public void set_DiameterTolerance(double value);
    public double get_Difference();
    public NelderMeadStatus Minimize(double fmin);
    protected virtual bool Optimize();
    private NelderMeadStatus minimize();
    private static bool reflectpt(int n, Double[] xnew, Double[] c, double scale, Double[] xold, Double[] lb, Double[] ub);
    internal NelderMeadStatus checkeval(Double[] xc, double fc);
    private static bool close(double a, double b);
    internal static bool nlopt_stop_ftol(GeneralConvergence stop, double f, double oldf);
    internal static bool nlopt_stop_xtol(GeneralConvergence stop, Double[] x, Double[] oldx, int n);
    internal static bool nlopt_stop_forced(GeneralConvergence stop);
    internal static bool nlopt_stop_evals(GeneralConvergence stop);
    internal static bool nlopt_stop_time(GeneralConvergence stop);
    internal static bool relstop(double old, double n, double reltol, double abstol);
}
public enum Accord.Math.Optimization.NelderMeadStatus : Enum {
    public int value__;
    public static NelderMeadStatus ForcedStop;
    public static NelderMeadStatus Success;
    public static NelderMeadStatus MaximumTimeReached;
    public static NelderMeadStatus MinimumAllowedValueReached;
    public static NelderMeadStatus MaximumEvaluationsReached;
    public static NelderMeadStatus Failure;
    public static NelderMeadStatus FunctionToleranceReached;
    public static NelderMeadStatus SolutionToleranceReached;
}
public class Accord.Math.Optimization.NonlinearConstraint : object {
    private static double DEFAULT_TOL;
    private Func`2<Double[], double> function;
    private Func`2<Double[], Double[]> gradient;
    [CompilerGeneratedAttribute]
private int <NumberOfVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstraintType <ShouldBe>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Tolerance>k__BackingField;
    public int NumberOfVariables { get; private set; }
    public ConstraintType ShouldBe { get; private set; }
    public double Value { get; private set; }
    public double Tolerance { get; public set; }
    public NonlinearConstraint(IObjectiveFunction objective, Expression`1<Func`1<double>> function, ConstraintType shouldBe, double value, Expression`1<Func`1<Double[]>> gradient, double withinTolerance);
    public NonlinearConstraint(IObjectiveFunction objective, Expression`1<Func`2<Double[], bool>> constraint, Func`2<Double[], Double[]> gradient);
    public NonlinearConstraint(int numberOfVariables, Expression`1<Func`2<Double[], bool>> constraint, Func`2<Double[], Double[]> gradient);
    public NonlinearConstraint(IObjectiveFunction objective, Func`2<Double[], double> function, ConstraintType shouldBe, double value, Func`2<Double[], Double[]> gradient, double withinTolerance);
    public NonlinearConstraint(int numberOfVariables, Func`2<Double[], double> function, ConstraintType shouldBe, double value, Func`2<Double[], Double[]> gradient, double withinTolerance);
    [CompilerGeneratedAttribute]
public sealed virtual int get_NumberOfVariables();
    [CompilerGeneratedAttribute]
private void set_NumberOfVariables(int value);
    [CompilerGeneratedAttribute]
public sealed virtual ConstraintType get_ShouldBe();
    [CompilerGeneratedAttribute]
private void set_ShouldBe(ConstraintType value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Tolerance();
    [CompilerGeneratedAttribute]
public void set_Tolerance(double value);
    public sealed virtual double Function(Double[] x);
    public sealed virtual Double[] Gradient(Double[] x);
    protected void Create(int numberOfVariables, Func`2<Double[], double> function, ConstraintType shouldBe, double value, Func`2<Double[], Double[]> gradient, double tolerance);
    private static void parse(Expression`1<Func`2<Double[], bool>> constraint, Func`2& function, ConstraintType& shouldBe, Double& value);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public class Accord.Math.Optimization.NonlinearObjectiveFunction : object {
    private Dictionary`2<string, int> variables;
    private IDictionary`2<string, int> readOnlyVariables;
    private Dictionary`2<int, string> indices;
    private IDictionary`2<int, string> readOnlyIndices;
    [CompilerGeneratedAttribute]
private Func`2<Double[], double> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Double[], Double[]> <Gradient>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfVariables>k__BackingField;
    public IDictionary`2<string, int> Variables { get; }
    public IDictionary`2<int, string> Indices { get; }
    protected Dictionary`2<string, int> InnerVariables { get; }
    protected Dictionary`2<int, string> InnerIndices { get; }
    public Func`2<Double[], double> Function { get; protected set; }
    public Func`2<Double[], Double[]> Gradient { get; protected set; }
    public int NumberOfVariables { get; protected set; }
    public NonlinearObjectiveFunction(int numberOfVariables, Func`2<Double[], double> function);
    public NonlinearObjectiveFunction(int numberOfVariables, Func`2<Double[], double> function, Func`2<Double[], Double[]> gradient);
    public NonlinearObjectiveFunction(Expression`1<Func`1<double>> function, Expression`1<Func`1<Double[]>> gradient);
    public sealed virtual IDictionary`2<string, int> get_Variables();
    public sealed virtual IDictionary`2<int, string> get_Indices();
    protected Dictionary`2<string, int> get_InnerVariables();
    protected Dictionary`2<int, string> get_InnerIndices();
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Double[], double> get_Function();
    [CompilerGeneratedAttribute]
protected void set_Function(Func`2<Double[], double> value);
    [CompilerGeneratedAttribute]
public Func`2<Double[], Double[]> get_Gradient();
    [CompilerGeneratedAttribute]
protected void set_Gradient(Func`2<Double[], Double[]> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_NumberOfVariables();
    [CompilerGeneratedAttribute]
protected void set_NumberOfVariables(int value);
    internal static void CheckGradient(Func`2<Double[], Double[]> value, Double[] probe);
}
public class Accord.Math.Optimization.OptimizationProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Iteration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Evaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Gradient>k__BackingField;
    [CompilerGeneratedAttribute]
private double <GradientNorm>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SolutionNorm>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Step>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Finished>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    public int Iteration { get; private set; }
    public int Evaluations { get; private set; }
    public Double[] Gradient { get; private set; }
    public double GradientNorm { get; private set; }
    public Double[] Solution { get; private set; }
    public double SolutionNorm { get; private set; }
    public double Value { get; private set; }
    public double Step { get; private set; }
    public bool Finished { get; private set; }
    public object Tag { get; public set; }
    public OptimizationProgressEventArgs(int iteration, int evaluations, Double[] gradient, double gnorm, Double[] solution, double xnorm, double value, double stp, bool finished);
    [CompilerGeneratedAttribute]
public int get_Iteration();
    [CompilerGeneratedAttribute]
private void set_Iteration(int value);
    [CompilerGeneratedAttribute]
public int get_Evaluations();
    [CompilerGeneratedAttribute]
private void set_Evaluations(int value);
    [CompilerGeneratedAttribute]
public Double[] get_Gradient();
    [CompilerGeneratedAttribute]
private void set_Gradient(Double[] value);
    [CompilerGeneratedAttribute]
public double get_GradientNorm();
    [CompilerGeneratedAttribute]
private void set_GradientNorm(double value);
    [CompilerGeneratedAttribute]
public Double[] get_Solution();
    [CompilerGeneratedAttribute]
private void set_Solution(Double[] value);
    [CompilerGeneratedAttribute]
public double get_SolutionNorm();
    [CompilerGeneratedAttribute]
private void set_SolutionNorm(double value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    [CompilerGeneratedAttribute]
public double get_Step();
    [CompilerGeneratedAttribute]
private void set_Step(double value);
    [CompilerGeneratedAttribute]
public bool get_Finished();
    [CompilerGeneratedAttribute]
private void set_Finished(bool value);
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
}
public class Accord.Math.Optimization.QuadraticConstraint : NonlinearConstraint {
    [CompilerGeneratedAttribute]
private Double[0...,0...] <QuadraticTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <LinearTerms>k__BackingField;
    public Double[0...,0...] QuadraticTerms { get; private set; }
    public Double[] LinearTerms { get; private set; }
    public QuadraticConstraint(IObjectiveFunction objective, Double[0...,0...] quadraticTerms, Double[] linearTerms, ConstraintType shouldBe, double value, double withinTolerance);
    [CompilerGeneratedAttribute]
public Double[0...,0...] get_QuadraticTerms();
    [CompilerGeneratedAttribute]
private void set_QuadraticTerms(Double[0...,0...] value);
    [CompilerGeneratedAttribute]
public Double[] get_LinearTerms();
    [CompilerGeneratedAttribute]
private void set_LinearTerms(Double[] value);
    private double function(Double[] x);
    private Double[] gradient(Double[] x);
}
[ExtensionAttribute]
internal static class Accord.Math.Optimization.QuadraticExpressionParser : object {
    [ExtensionAttribute]
public static string ToVariable(int num, char prefix);
    public static Dictionary`2<Tuple`2<string, string>, double> ParseString(string f, CultureInfo culture);
    public static Tuple`2<string, string> ParseExpression(Dictionary`2<Tuple`2<string, string>, double> terms, Expression expr, Double& scalar, bool dontAdd);
    private static Tuple`2<string, string> addTuple(Dictionary`2<Tuple`2<string, string>, double> terms, double v, string v1, string v2);
}
public class Accord.Math.Optimization.QuadraticObjectiveFunction : NonlinearObjectiveFunction {
    private Double[0...,0...] Q;
    private Double[] d;
    [CompilerGeneratedAttribute]
private double <ConstantTerm>k__BackingField;
    public Double[0...,0...] QuadraticTerms { get; }
    public Double[] LinearTerms { get; }
    public double ConstantTerm { get; public set; }
    public QuadraticObjectiveFunction(Double[0...,0...] quadraticTerms, Double[] linearTerms, String[] variables);
    public QuadraticObjectiveFunction(string function);
    public QuadraticObjectiveFunction(string function, CultureInfo culture);
    public QuadraticObjectiveFunction(Expression`1<Func`1<double>> function);
    public Double[0...,0...] get_QuadraticTerms();
    public Double[] get_LinearTerms();
    [CompilerGeneratedAttribute]
public double get_ConstantTerm();
    [CompilerGeneratedAttribute]
public void set_ConstantTerm(double value);
    private void initialize(Dictionary`2<Tuple`2<string, string>, double> terms);
    private Double[0...,0...] createQuadraticTermsMatrix(Dictionary`2<Tuple`2<string, string>, double> quadratic);
    private Double[] createLinearTermsVector(Dictionary`2<string, double> linear);
    private double function(Double[] input);
    private Double[] gradient(Double[] input);
    public static QuadraticObjectiveFunction op_Multiply(double scalar, QuadraticObjectiveFunction a);
    public static QuadraticObjectiveFunction op_Multiply(QuadraticObjectiveFunction a, double scalar);
    public static QuadraticObjectiveFunction op_Division(QuadraticObjectiveFunction a, double scalar);
    public static QuadraticObjectiveFunction op_UnaryNegation(QuadraticObjectiveFunction a);
    public static QuadraticObjectiveFunction op_Addition(QuadraticObjectiveFunction a, QuadraticObjectiveFunction b);
    public static QuadraticObjectiveFunction op_Subtraction(QuadraticObjectiveFunction a, QuadraticObjectiveFunction b);
    public virtual string ToString();
    public static bool TryParse(string str, QuadraticObjectiveFunction& function);
    public static bool TryParse(string str, CultureInfo culture, QuadraticObjectiveFunction& function);
}
public class Accord.Math.Optimization.ResilientBackpropagation : BaseGradientOptimizationMethod {
    private RelativeConvergence convergence;
    private double initialStep;
    private double deltaMax;
    private double deltaMin;
    private double etaMinus;
    private double etaPlus;
    private Double[] gradient;
    private Double[] previousGradient;
    private Double[] weightsUpdates;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressChangedEventArgs> ProgressChanged;
    public double UpdateUpperBound { get; public set; }
    public double UpdateLowerBound { get; public set; }
    public double DecreaseFactor { get; public set; }
    public double IncreaseFactor { get; public set; }
    public double Tolerance { get; public set; }
    public int Iterations { get; public set; }
    public ResilientBackpropagation(NonlinearObjectiveFunction function);
    public ResilientBackpropagation(int numberOfVariables, Func`2<Double[], double> function, Func`2<Double[], Double[]> gradient);
    public ResilientBackpropagation(int numberOfVariables);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    public double get_UpdateUpperBound();
    public void set_UpdateUpperBound(double value);
    public double get_UpdateLowerBound();
    public void set_UpdateLowerBound(double value);
    public double get_DecreaseFactor();
    public void set_DecreaseFactor(double value);
    public double get_IncreaseFactor();
    public void set_IncreaseFactor(double value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public int get_Iterations();
    public void set_Iterations(int value);
    protected virtual void OnNumberOfVariablesChanged(int numberOfVariables);
    protected virtual bool Optimize();
    private double runEpoch();
    protected void OnProgressChanged(ProgressChangedEventArgs args);
    public void Reset(double rate);
}
public class Accord.Math.Optimization.Subplex : BaseOptimizationMethod {
    private int n;
    private double minf_max;
    private GeneralConvergence stop;
    private static double psi;
    private static double omega;
    private static int nsmin;
    private static int nsmax;
    private Double[] lb;
    private Double[] ub;
    private Double[] xprev;
    private Double[] dx;
    private Double[] absdx;
    private Double[] xstep;
    private Double[] xstep0;
    private Int32[] p;
    private int sindex;
    private NelderMead nelderMead;
    private NelderMeadStatus status;
    public NelderMeadStatus Status { get; }
    public double MaximumValue { get; public set; }
    public Double[] StepSize { get; }
    public GeneralConvergence Convergence { get; public set; }
    public Double[] LowerBounds { get; }
    public Double[] UpperBounds { get; }
    public Subplex(int numberOfVariables);
    public Subplex(int numberOfVariables, Func`2<Double[], double> function);
    public Subplex(NonlinearObjectiveFunction function);
    private void init(int n);
    public sealed virtual NelderMeadStatus get_Status();
    public double get_MaximumValue();
    public void set_MaximumValue(double value);
    public Double[] get_StepSize();
    public GeneralConvergence get_Convergence();
    public void set_Convergence(GeneralConvergence value);
    public Double[] get_LowerBounds();
    public Double[] get_UpperBounds();
    protected virtual bool Optimize();
    private NelderMeadStatus sbplx_minimize();
    private double subspace_func(Double[] xs);
}
public class Accord.Math.Optimization.TrustRegionNewtonMethod : BaseGradientOptimizationMethod {
    private double eps;
    private int max_iter;
    [CompilerGeneratedAttribute]
private Func`2<Double[], Double[]> <Hessian>k__BackingField;
    public double Tolerance { get; public set; }
    public int MaxIterations { get; public set; }
    public Func`2<Double[], Double[]> Hessian { get; public set; }
    public TrustRegionNewtonMethod(int numberOfVariables);
    public TrustRegionNewtonMethod(int numberOfVariables, Func`2<Double[], double> function, Func`2<Double[], Double[]> gradient, Func`2<Double[], Double[]> hessian);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public int get_MaxIterations();
    public void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public Func`2<Double[], Double[]> get_Hessian();
    [CompilerGeneratedAttribute]
public void set_Hessian(Func`2<Double[], Double[]> value);
    protected virtual bool Optimize();
    private void tron(Double[] w);
    private int trcg(double delta, Double[] g, Double[] s, Double[] r);
}
public static class Accord.Math.OwensT : object {
    private static Double[] arange;
    private static Double[] c2;
    private static Double[] hrange;
    private static Int32[] meth;
    private static Int32[] ord;
    private static Double[] pts;
    private static Int32[] select;
    private static Double[] wts;
    private static OwensT();
    public static double Function(double h, double a);
    public static double Function(double h, double a, double ah);
}
public class Accord.Math.PerlinNoise : object {
    private double initFrequency;
    private double initAmplitude;
    private double persistence;
    private int octaves;
    public double InitFrequency { get; public set; }
    public double InitAmplitude { get; public set; }
    public double Persistence { get; public set; }
    public int Octaves { get; public set; }
    public PerlinNoise(int octaves, double persistence);
    public PerlinNoise(int octaves, double persistence, double initFrequency, double initAmplitude);
    public double get_InitFrequency();
    public void set_InitFrequency(double value);
    public double get_InitAmplitude();
    public void set_InitAmplitude(double value);
    public double get_Persistence();
    public void set_Persistence(double value);
    public int get_Octaves();
    public void set_Octaves(int value);
    public double Function(double x);
    public double Function2D(double x, double y);
    private static double Noise(int x);
    private static double Noise(int x, int y);
    private static double SmoothedNoise(double x);
    private static double SmoothedNoise(double x, double y);
    private static double CosineInterpolate(double x1, double x2, double a);
}
[SerializableAttribute]
public class Accord.Math.Plane : object {
    [NonSerializedAttribute]
private Vector3 normal;
    private float offset;
    public Vector3 Normal { get; }
    public float A { get; public set; }
    public float B { get; public set; }
    public float C { get; public set; }
    public float Offset { get; public set; }
    public Plane(float a, float b, float c);
    public Plane(Vector3 normal);
    public Plane(float a, float b, float c, float offset);
    public Plane(Vector3 normal, float offset);
    public static Plane FromPoints(Point3 point1, Point3 point2, Point3 point3);
    public Vector3 get_Normal();
    public float get_A();
    public void set_A(float value);
    public float get_B();
    public void set_B(float value);
    public float get_C();
    public void set_C(float value);
    public float get_Offset();
    public void set_Offset(float value);
    public double DistanceToPoint(Point3 point);
    public void Normalize();
    public static bool op_Equality(Plane a, Plane b);
    public static bool op_Inequality(Plane a, Plane b);
    public bool Equals(Plane other, double tolerance);
    public sealed virtual bool Equals(Plane other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public string ToString(char variable);
    public string ToString(char variable, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Math.Point3 : ValueType {
    [NonSerializedAttribute]
private Vector3 coordinates;
    private static Point3 origin;
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Z { get; public set; }
    public static Point3 Origin { get; }
    public Point3(float x, float y, float z);
    public Point3(Vector3 coordinates);
    private static Point3();
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public float get_Z();
    public void set_Z(float value);
    public static Vector3 op_Implicit(Point3 point);
    public static Point3 op_Implicit(Vector3 vector);
    public static Point3 FromVector(Vector3 vector);
    public static bool Collinear(Point3 p1, Point3 p2, Point3 p3);
    public static Point3 get_Origin();
    public static bool op_Equality(Point3 a, Point3 b);
    public static bool op_Inequality(Point3 a, Point3 b);
    public bool Equals(Point3 other, double tolerance);
    public bool Equals(Point3 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Accord.Math.Random.ConstantGenerator : object {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public double Value { get; public set; }
    public ConstantGenerator(double value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    public sealed virtual Double[] Generate(int samples);
    public sealed virtual Double[] Generate(int samples, Double[] result);
    public sealed virtual double Generate();
}
[ObsoleteAttribute("Please use Accord.Statistics.Distributions.Exponential instead.")]
public class Accord.Math.Random.ExponentialGenerator : object {
    private UniformOneGenerator rand;
    private float rate;
    public float Rate { get; }
    public float Mean { get; }
    public float Variance { get; }
    public ExponentialGenerator(float rate);
    public ExponentialGenerator(float rate, int seed);
    public float get_Rate();
    public sealed virtual float get_Mean();
    public sealed virtual float get_Variance();
    public sealed virtual float Next();
    public sealed virtual void SetSeed(int seed);
}
[ObsoleteAttribute("Please use Accord.Statistics.Distributions.NormalDistribution instead.")]
public class Accord.Math.Random.GaussianGenerator : object {
    private StandardGenerator rand;
    private float mean;
    private float stdDev;
    public float Mean { get; }
    public float Variance { get; }
    public float StdDev { get; }
    public GaussianGenerator(float mean, float stdDev);
    public GaussianGenerator(float mean, float stdDev, int seed);
    public sealed virtual float get_Mean();
    public sealed virtual float get_Variance();
    public float get_StdDev();
    public sealed virtual float Next();
    public sealed virtual void SetSeed(int seed);
}
public static class Accord.Math.Random.Generator : object {
    private static Random sourceRandom;
    private static object sourceRandomLock;
    private static Nullable`1<int> sourceSeed;
    private static int sourceLastUpdateTicks;
    private static object sourceSeedLock;
    private static bool accessed;
    [ThreadStaticAttribute]
private static int threadLastUpdateTicks;
    [ThreadStaticAttribute]
private static bool threadOverriden;
    [ThreadStaticAttribute]
private static Nullable`1<int> threadSeed;
    [ThreadStaticAttribute]
private static Random threadRandom;
    public static bool HasBeenAccessed { get; public set; }
    public static long LastUpdateTicks { get; }
    public static long ThreadLastUpdateTicks { get; }
    public static Nullable`1<int> ThreadSeed { get; public set; }
    public static Random Random { get; }
    public static Nullable`1<int> Seed { get; public set; }
    private static Generator();
    public static bool get_HasBeenAccessed();
    public static void set_HasBeenAccessed(bool value);
    private static int GetRandomSeed();
    public static long get_LastUpdateTicks();
    public static long get_ThreadLastUpdateTicks();
    public static Nullable`1<int> get_ThreadSeed();
    public static void set_ThreadSeed(Nullable`1<int> value);
    public static Random get_Random();
    public static Nullable`1<int> get_Seed();
    public static void set_Seed(Nullable`1<int> value);
}
[ObsoleteAttribute("Please use IRandomNumberGenerator<T> instead.")]
public interface Accord.Math.Random.IRandomNumberGenerator {
    public float Mean { get; }
    public float Variance { get; }
    public abstract virtual float get_Mean();
    public abstract virtual float get_Variance();
    public abstract virtual float Next();
    public abstract virtual void SetSeed(int seed);
}
public interface Accord.Math.Random.IRandomNumberGenerator`1 {
    public abstract virtual T[] Generate(int samples);
    public abstract virtual T[] Generate(int samples, T[] result);
    public abstract virtual T Generate();
}
internal class Accord.Math.Random.RandomNumberGeneratorAdapter : object {
    private IRandomNumberGenerator rng;
    public int Seed { get; public set; }
    public RandomNumberGeneratorAdapter(IRandomNumberGenerator rng);
    public sealed virtual float Generate();
    public sealed virtual Single[] Generate(int samples);
    public sealed virtual Single[] Generate(int samples, Single[] result);
    public int get_Seed();
    public void set_Seed(int value);
    private sealed virtual override double Accord.Math.Random.IRandomNumberGenerator<System.Double>.Generate();
    private sealed virtual override Double[] Accord.Math.Random.IRandomNumberGenerator<System.Double>.Generate(int samples);
    public sealed virtual Double[] Generate(int samples, Double[] result);
}
[ObsoleteAttribute("Please use Accord.Statistics.Distributions.NormalDistribution.Standard instead.")]
public class Accord.Math.Random.StandardGenerator : object {
    private UniformOneGenerator rand;
    private float secondValue;
    private bool useSecond;
    public float Mean { get; }
    public float Variance { get; }
    public StandardGenerator(int seed);
    public sealed virtual float get_Mean();
    public sealed virtual float get_Variance();
    public sealed virtual float Next();
    public sealed virtual void SetSeed(int seed);
}
[ObsoleteAttribute("Please use Accord.Statistics.UniformDistribution instead.")]
public class Accord.Math.Random.UniformGenerator : object {
    private UniformOneGenerator rand;
    private float min;
    private float length;
    public float Mean { get; }
    public float Variance { get; }
    public Range Range { get; }
    public UniformGenerator(Range range);
    public UniformGenerator(Range range, int seed);
    public sealed virtual float get_Mean();
    public sealed virtual float get_Variance();
    public Range get_Range();
    public sealed virtual float Next();
    public sealed virtual void SetSeed(int seed);
}
[ObsoleteAttribute("Please use Accord.Statistics.Distributions.Uniform.Standard instead.")]
public class Accord.Math.Random.UniformOneGenerator : object {
    private ThreadSafeRandom rand;
    public float Mean { get; }
    public float Variance { get; }
    public UniformOneGenerator(int seed);
    public sealed virtual float get_Mean();
    public sealed virtual float get_Variance();
    public sealed virtual float Next();
    public sealed virtual void SetSeed(int seed);
}
public class Accord.Math.Random.ZigguratExponentialGenerator : object {
    private ZigguratUniformOneGenerator u;
    private UInt32[] ke;
    private Double[] fe;
    private Double[] we;
    public ZigguratExponentialGenerator(int seed);
    public sealed virtual Double[] Generate(int samples);
    public sealed virtual Double[] Generate(int samples, Double[] result);
    public sealed virtual double Generate();
    private void setup();
}
public class Accord.Math.Random.ZigguratNormalGenerator : object {
    private ZigguratUniformOneGenerator u;
    private UInt32[] kn;
    private Double[] fn;
    private Double[] wn;
    public ZigguratNormalGenerator(int seed);
    public sealed virtual Double[] Generate(int samples);
    public sealed virtual Double[] Generate(int samples, Double[] result);
    public sealed virtual double Generate();
    private void setup();
}
public class Accord.Math.Random.ZigguratUniformGenerator : object {
    private ZigguratUniformOneGenerator u;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Length>k__BackingField;
    public double Min { get; public set; }
    public double Length { get; public set; }
    public ZigguratUniformGenerator(double min, double max);
    public ZigguratUniformGenerator(double min, double max, int seed);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(double value);
    public sealed virtual Double[] Generate(int samples);
    public sealed virtual Double[] Generate(int samples, Double[] result);
    public sealed virtual double Generate();
}
public class Accord.Math.Random.ZigguratUniformOneGenerator : object {
    private UInt32 jsr;
    public ZigguratUniformOneGenerator(int seed);
    public sealed virtual Double[] Generate(int samples);
    public sealed virtual Double[] Generate(int samples, Double[] result);
    public sealed virtual Int32[] Generate(int samples, Int32[] result);
    public sealed virtual UInt32[] Generate(int samples, UInt32[] result);
    public sealed virtual double Generate();
    public UInt32 Next();
    private sealed virtual override Int32[] Accord.Math.Random.IRandomNumberGenerator<System.Int32>.Generate(int samples);
    private sealed virtual override int Accord.Math.Random.IRandomNumberGenerator<System.Int32>.Generate();
    private sealed virtual override UInt32[] Accord.Math.Random.IRandomNumberGenerator<System.UInt32>.Generate(int samples);
    private sealed virtual override UInt32 Accord.Math.Random.IRandomNumberGenerator<System.UInt32>.Generate();
}
public class Accord.Math.ReducedRowEchelonForm : object {
    private Double[0...,0...] rref;
    private int rows;
    private int cols;
    private Int32[] pivot;
    private Nullable`1<int> freeCount;
    public Int32[] Pivot { get; }
    public Double[0...,0...] Result { get; }
    public int FreeVariables { get; }
    public ReducedRowEchelonForm(Double[0...,0...] value, bool inPlace);
    public Int32[] get_Pivot();
    public Double[0...,0...] get_Result();
    public int get_FreeVariables();
    private int count();
}
public class Accord.Math.RelativeConvergence : object {
    private double tolerance;
    private int maxIterations;
    private double newValue;
    private double startValue;
    private int checks;
    private int maxChecks;
    [CompilerGeneratedAttribute]
private double <OldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentIteration>k__BackingField;
    public double Tolerance { get; public set; }
    public int MaxIterations { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public double OldValue { get; private set; }
    public double NewValue { get; public set; }
    public int CurrentIteration { get; public set; }
    public bool HasConverged { get; }
    public double Delta { get; }
    public double RelativeDelta { get; }
    public double StartValue { get; }
    public RelativeConvergence(int iterations, double tolerance);
    public RelativeConvergence(int iterations, double tolerance, int checks);
    public RelativeConvergence(int iterations, double tolerance, int checks, double startValue);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    private void init(int iterations, double tolerance, int checks, double startValue);
    [CompilerGeneratedAttribute]
public double get_OldValue();
    [CompilerGeneratedAttribute]
private void set_OldValue(double value);
    public sealed virtual double get_NewValue();
    public sealed virtual void set_NewValue(double value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CurrentIteration();
    [CompilerGeneratedAttribute]
public void set_CurrentIteration(int value);
    public sealed virtual bool get_HasConverged();
    private bool checkConvergence();
    public double get_Delta();
    public double get_RelativeDelta();
    public double get_StartValue();
    public sealed virtual void Clear();
    public virtual string ToString();
}
public class Accord.Math.RelativeParameterConvergence : object {
    private Double[] oldValues;
    private Double[] newValues;
    private double tolerance;
    private int maxIterations;
    private double maxChange;
    [CompilerGeneratedAttribute]
private int <CurrentIteration>k__BackingField;
    public double Tolerance { get; public set; }
    public int MaxIterations { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public double Delta { get; }
    public Double[] OldValues { get; }
    public Double[] NewValues { get; public set; }
    public int CurrentIteration { get; public set; }
    public bool HasDiverged { get; }
    public bool HasConverged { get; }
    private Double[] Accord.Math.IConvergence<System.Double[]>.NewValue { get; private set; }
    public RelativeParameterConvergence(int iterations, double tolerance);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public double get_Delta();
    public Double[] get_OldValues();
    public Double[] get_NewValues();
    public void set_NewValues(Double[] value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CurrentIteration();
    [CompilerGeneratedAttribute]
public void set_CurrentIteration(int value);
    public bool get_HasDiverged();
    public sealed virtual bool get_HasConverged();
    public sealed virtual void Clear();
    private sealed virtual override Double[] Accord.Math.IConvergence<System.Double[]>.get_NewValue();
    private sealed virtual override void Accord.Math.IConvergence<System.Double[]>.set_NewValue(Double[] value);
}
public static class Accord.Math.SineTransform : object {
    public static void DST(Double[] data);
    public static void IDST(Double[] data);
    public static void DST(Double[][] data);
    public static void IDST(Double[][] data);
}
[ExtensionAttribute]
public static class Accord.Math.Special : object {
    private static Double[] erfc_P;
    private static Double[] erfc_Q;
    private static Double[] erfc_R;
    private static Double[] erfc_S;
    private static Double[] erfc_T;
    private static Double[] erfc_U;
    private static int ftop;
    private static Double[] fcache;
    private static Double[] lnfcache;
    private static Special();
    public static double Erfc(double value);
    public static double Erf(double x);
    public static double Ierf(double y);
    public static double Ierfc(double y);
    public static double Polevl(double x, Double[] coef, int n);
    public static double P1evl(double x, Double[] coef, int n);
    public static double BSpline(int n, double x);
    public static double Binomial(int n, int k);
    public static double Binomial(double n, double k);
    public static double LogBinomial(int n, int k);
    public static double LogBinomial(double n, double k);
    public static double Factorial(double n);
    public static double LogFactorial(double n);
    public static double LogFactorial(int n);
    public static double Factorial(int n);
    public static double Log1m(double x);
    public static double Log1p(double x);
    public static double Expm1(double x);
    public static double Epslon(double x);
    public static double Sign(double a, double b);
    public static double LogDiff(double lnx, double lny);
    public static double LogSum(double lnx, double lny);
    public static double LogSum(float lnx, float lny);
    public static double LogSum(Double[] values);
    [ExtensionAttribute]
public static double LogSumExp(Double[] array);
    public static double Sec(double x);
    public static double Cosec(double x);
    public static double Cotan(double x);
    public static double Asec(double x);
    public static double Acosec(double x);
    public static double Acotan(double x);
    public static double Sech(double x);
    public static double Cosech(double x);
    public static double Cotanh(double x);
    public static double Asinh(double x);
    public static double Acosh(double x);
    public static double Atanh(double x);
    public static double Asech(double x);
    public static double Acosech(double x);
    public static double Acotanh(double x);
    public static Double[] Softmax(Double[] input);
    public static Double[] Softmax(Double[] input, Double[] result);
    public static double Log1pexp(double x);
}
internal class Accord.Math.svd : object {
    public static void svdcmp(Double[0...,0...] a, Double[]& w, Double[0...,0...]& v);
    private static double Sign(double a, double b);
    private static double Pythag(double a, double b);
}
public static class Accord.Math.Taylor : object {
    public static double Sin(double x, int nTerms);
    public static double Cos(double x, int nTerms);
    public static double Sinh(double x, int nTerms);
    public static double Cosh(double x, int nTerms);
    public static double Exp(double d, int nTerms);
}
[ExtensionAttribute]
public static class Accord.Math.Tools : object {
    [ObsoleteAttribute("Please use Generator.Random instead.")]
public static Random Random { get; }
    public static Random get_Random();
    [ObsoleteAttribute("Please set the Seed property of Accord.Math.Random.Generator instead.")]
public static void SetupGenerator(Nullable`1<int> seed);
    public static float Angle(float x, float y);
    public static double Angle(double x, double y);
    public static double Angle(IntPoint previous, IntPoint next);
    public static int Direction(IntPoint previous, IntPoint next);
    public static int GreatestCommonDivisor(int a, int b);
    public static int NextPowerOf2(int x);
    public static int PreviousPowerOf2(int x);
    public static double Hypotenuse(double a, double b);
    public static decimal Hypotenuse(decimal a, decimal b);
    public static float Hypotenuse(float a, float b);
    public static int Mod(int x, int m);
    public static double Mod(double x, double m);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Scale instead.")]
public static int Scale(IntRange from, IntRange to, int x);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Scale instead.")]
public static double Scale(DoubleRange from, DoubleRange to, double x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static double Scale(double fromMin, double fromMax, double toMin, double toMax, double x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Double[] Scale(double fromMin, double fromMax, double toMin, double toMax, Double[] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Int32[] Scale(int fromMin, int fromMax, int toMin, int toMax, Int32[] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Int32[] Scale(IntRange from, IntRange to, Int32[] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Double[] Scale(DoubleRange from, DoubleRange to, Double[] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Single[] Scale(float fromMin, float fromMax, float toMin, float toMax, Single[] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Single[] Scale(Range from, Range to, Single[] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Double[] Scale(double toMin, double toMax, Double[] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Double[][] Scale(Double[] fromMin, Double[] fromMax, Double[] toMin, Double[] toMax, Double[][] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Double[][] Scale(double fromMin, double fromMax, double toMin, double toMax, Double[][] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Double[][] Scale(Double[] fromMin, Double[] fromMax, double toMin, double toMax, Double[][] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Double[][] Scale(Double[] toMin, Double[] toMax, Double[][] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static Double[][] Scale(double toMin, double toMax, Double[][] x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static float Scale(float fromMin, float fromMax, float toMin, float toMax, float x);
    [ObsoleteAttribute("Please use Vector.Scale instead.")]
public static double Scale(IntRange from, DoubleRange to, int x);
    public static double Acosh(double x);
    public static double Asinh(double d);
    public static double Atanh(double d);
    public static int FactorialPower(int value, int degree);
    public static double TruncatedPower(double value, double degree);
    public static float InvSqrt(float f);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Sort instead.")]
public static void StableSort(T[] values, Comparison`1<T> comparison);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Sort instead.")]
public static void StableSort(T[] values);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Sort instead.")]
public static void StableSort(T[] values, Int32[]& order);
    public static double Interpolate1D(double value, Double[] x, Double[] y, double lower, double upper);
    public static double Max(double a, double b, double c);
    public static double Min(double a, double b, double c);
    public static int Pow2(int power);
    public static bool IsPowerOf2(int x);
    public static int Log2(int x);
    public static decimal Sqrt(decimal x, decimal epsilon);
}
public static class Accord.Math.Transforms.FourierTransform2 : object {
    public static void DFT(Complex[] data, Direction direction);
    public static void DFT2(Complex[][] data, Direction direction);
    public static void FFT(Complex[] data, Direction direction);
    public static void FFT(Double[] real, Double[] imag, Direction direction);
    public static void FFT2(Complex[][] data, Direction direction);
    private static void FFT(Double[] real, Double[] imag);
    private static void IDFT(Complex[] data);
    private static void IDFT(Double[] real, Double[] imag);
    private static void TransformRadix2(Double[] real, Double[] imag);
    private static void TransformRadix2(Complex[] complex);
    private static void TransformBluestein(Double[] real, Double[] imag);
    private static void TransformBluestein(Complex[] data);
    public static void Convolve(Double[] x, Double[] y, Double[] result);
    public static void Convolve(Complex[] x, Complex[] y, Complex[] result);
    public static void Convolve(Double[] xreal, Double[] ximag, Double[] yreal, Double[] yimag, Double[] outreal, Double[] outimag);
    private static int HighestOneBit(int i);
    private static int Reverse(int i);
    public static Double[] GetMagnitudeSpectrum(Complex[] fft);
    public static Double[] GetPowerSpectrum(Complex[] fft);
    public static Double[] GetPhaseSpectrum(Complex[] fft);
    public static Double[] GetFrequencyVector(int length, int sampleRate);
    public static double GetSpectralResolution(int samplingRate, int samples);
    public static Double[] GetPowerCepstrum(Complex[] signal);
}
[ExtensionAttribute]
public static class Accord.Math.Vector : object {
    [ExtensionAttribute]
public static Int32[] GetIndices(T[] array);
    public static T[] Zeros(int size);
    public static T[] Ones(int size);
    public static T[] Ones(Boolean[] mask);
    public static Double[] Zeros(int size);
    public static Double[] Ones(int size);
    public static Double[] Ones(Boolean[] mask);
    public static T[] Create(int size, T value);
    public static T[] Create(int size, T[] values);
    public static T[] Create(T value, Boolean[] mask);
    public static T[] Create(T[] values);
    public static T[] CreateAs(T[] vector);
    public static T[] OneHot(int index, int columns);
    public static T[] OneHot(bool mask);
    public static T[] OneHot(bool mask, T[] result);
    public static Double[] OneHot(int index, int columns);
    public static T[] OneHot(int index, T[] result);
    public static Double[] OneHot(int index, Double[] result);
    public static T[] KHot(Int32[] indices, int columns);
    public static T[] KHot(Boolean[] mask);
    public static Double[] KHot(Int32[] indices, int columns);
    public static T[] KHot(Int32[] indices, T[] result);
    public static T[] KHot(Boolean[] mask, T[] result);
    public static Double[] KHot(Int32[] indices, Double[] result);
    [ExtensionAttribute]
public static Int32[] Histogram(Int32[] labels);
    [ExtensionAttribute]
public static Int32[] Histogram(Int32[] labels, int size);
    [ExtensionAttribute]
public static Int32[] Histogram(Int32[] labels, Int32[] result);
    [ExtensionAttribute]
public static T[] Copy(T[] vector);
    public static Int32[] Interval(int a, int b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static Int32[] Interval(int a, int b, double stepSize);
    public static Int32[] Interval(int a, int b, int steps, bool includeLast);
    public static Single[] Interval(float a, float b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static Single[] Interval(float a, float b, double stepSize);
    public static Single[] Interval(float a, float b, int steps, bool includeLast);
    public static Double[] Interval(double a, double b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static Double[] Interval(double a, double b, double stepSize);
    public static Double[] Interval(double a, double b, int steps, bool includeLast);
    public static Int16[] Interval(short a, short b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static Int16[] Interval(short a, short b, double stepSize);
    public static Int16[] Interval(short a, short b, int steps, bool includeLast);
    public static Byte[] Interval(byte a, byte b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static Byte[] Interval(byte a, byte b, double stepSize);
    public static Byte[] Interval(byte a, byte b, int steps, bool includeLast);
    public static SByte[] Interval(sbyte a, sbyte b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static SByte[] Interval(sbyte a, sbyte b, double stepSize);
    public static SByte[] Interval(sbyte a, sbyte b, int steps, bool includeLast);
    public static Int64[] Interval(long a, long b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static Int64[] Interval(long a, long b, double stepSize);
    public static Int64[] Interval(long a, long b, int steps, bool includeLast);
    public static Decimal[] Interval(decimal a, decimal b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static Decimal[] Interval(decimal a, decimal b, decimal stepSize);
    public static Decimal[] Interval(decimal a, decimal b, int steps, bool includeLast);
    public static UInt64[] Interval(ulong a, ulong b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static UInt64[] Interval(ulong a, ulong b, double stepSize);
    public static UInt64[] Interval(ulong a, ulong b, int steps, bool includeLast);
    public static UInt16[] Interval(ushort a, ushort b);
    [ObsoleteAttribute("Please use Vector.Range(a, b, stepSize) instead.")]
public static UInt16[] Interval(ushort a, ushort b, double stepSize);
    public static UInt16[] Interval(ushort a, ushort b, int steps, bool includeLast);
    [ExtensionAttribute]
public static Double[] Interval(DoubleRange range, int steps);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Range(range, stepSize) instead.")]
public static Double[] Interval(DoubleRange range, double stepSize);
    [ExtensionAttribute]
public static Single[] Interval(Range range, int steps);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Range(range, stepSize) instead.")]
public static Single[] Interval(Range range, double stepSize);
    [ExtensionAttribute]
public static Byte[] Interval(ByteRange range, int steps);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Range(range, stepSize) instead.")]
public static Byte[] Interval(ByteRange range, double stepSize);
    [ExtensionAttribute]
public static Int32[] Interval(IntRange range, int steps);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Vector.Range(range, stepSize) instead.")]
public static Int32[] Interval(IntRange range, double stepSize);
    [ExtensionAttribute]
public static void Shuffle(T[] array);
    [ExtensionAttribute]
public static void Shuffle(IList`1<T> array);
    [ExtensionAttribute]
public static void Sort(T[] values, Comparison`1<T> comparison, bool stable, bool asc);
    [ExtensionAttribute]
public static void Sort(T[] values, bool stable, bool asc);
    [ExtensionAttribute]
public static void Sort(T[] values, Int32[]& order, bool stable, ComparerDirection direction);
    [ExtensionAttribute]
public static T[] Shuffled(T[] array);
    [ExtensionAttribute]
public static TList Shuffled(TList array);
    [ExtensionAttribute]
public static T[] Sorted(T[] values, Comparison`1<T> comparison, bool stable);
    [ExtensionAttribute]
public static T[] Sorted(T[] values, bool stable, bool asc);
    [ExtensionAttribute]
public static T[] Sorted(ICollection`1<T> values, bool stable);
    [ExtensionAttribute]
public static T[] Sorted(T[] values, Int32[]& order, bool stable, ComparerDirection direction);
    public static Double[] Parse(string str);
    public static Double[] Parse(string str, IMatrixFormatProvider provider);
    public static bool TryParse(string s, IMatrixFormatProvider provider, Double[]& vector);
    public static Double[] Random(int size);
    [ExtensionAttribute]
public static T[] Sample(T[] values, int size, bool replacement);
    public static Int32[] Sample(int size);
    public static Int32[] Sample(int sampleSize, int populationSize);
    public static Int32[] Sample(double percentage, int populationSize);
    public static Single[] Sample(float size);
    public static Single[] Sample(int sampleSize, float populationSize);
    public static Single[] Sample(double percentage, float populationSize);
    public static Double[] Sample(double size);
    public static Double[] Sample(int sampleSize, double populationSize);
    public static Double[] Sample(double percentage, double populationSize);
    public static Int16[] Sample(short size);
    public static Int16[] Sample(int sampleSize, short populationSize);
    public static Int16[] Sample(double percentage, short populationSize);
    public static Byte[] Sample(byte size);
    public static Byte[] Sample(int sampleSize, byte populationSize);
    public static Byte[] Sample(double percentage, byte populationSize);
    public static SByte[] Sample(sbyte size);
    public static SByte[] Sample(int sampleSize, sbyte populationSize);
    public static SByte[] Sample(double percentage, sbyte populationSize);
    public static Int64[] Sample(long size);
    public static Int64[] Sample(int sampleSize, long populationSize);
    public static Int64[] Sample(double percentage, long populationSize);
    public static Decimal[] Sample(decimal size);
    public static Decimal[] Sample(int sampleSize, decimal populationSize);
    public static Decimal[] Sample(double percentage, decimal populationSize);
    public static UInt64[] Sample(ulong size);
    public static UInt64[] Sample(int sampleSize, ulong populationSize);
    public static UInt64[] Sample(double percentage, ulong populationSize);
    public static UInt16[] Sample(ushort size);
    public static UInt16[] Sample(int sampleSize, ushort populationSize);
    public static UInt16[] Sample(double percentage, ushort populationSize);
    public static Int32[] Random(int size, int min, int max);
    public static Int16[] Random(int size, short min, short max);
    public static Byte[] Random(int size, byte min, byte max);
    public static SByte[] Random(int size, sbyte min, sbyte max);
    public static Int64[] Random(int size, long min, long max);
    public static UInt64[] Random(int size, ulong min, ulong max);
    public static UInt16[] Random(int size, ushort min, ushort max);
    public static Single[] Random(int size, float min, float max);
    public static Double[] Random(int size, double min, double max);
    public static Decimal[] Random(int size, decimal min, decimal max);
    public static Int32[] Range(int n);
    public static Int32[] Range(int a, int b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__124")]
public static IEnumerable`1<int> EnumerableRange(int n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__125")]
public static IEnumerable`1<int> EnumerableRange(int a, int b);
    public static Int32[] Range(int a, int b, int stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__127")]
public static IEnumerable`1<int> EnumerableRange(int a, int b, int stepSize);
    public static Single[] Range(int a, int b, float stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__129")]
public static IEnumerable`1<float> EnumerableRange(int a, int b, float stepSize);
    public static Double[] Range(int a, int b, double stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__131")]
public static IEnumerable`1<double> EnumerableRange(int a, int b, double stepSize);
    public static Single[] Range(float n);
    public static Single[] Range(float a, float b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__134")]
public static IEnumerable`1<float> EnumerableRange(float n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__135")]
public static IEnumerable`1<float> EnumerableRange(float a, float b);
    public static Single[] Range(float a, float b, int stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__137")]
public static IEnumerable`1<float> EnumerableRange(float a, float b, int stepSize);
    public static Single[] Range(float a, float b, float stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__139")]
public static IEnumerable`1<float> EnumerableRange(float a, float b, float stepSize);
    public static Single[] Range(float a, float b, short stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__141")]
public static IEnumerable`1<float> EnumerableRange(float a, float b, short stepSize);
    public static Single[] Range(float a, float b, byte stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__143")]
public static IEnumerable`1<float> EnumerableRange(float a, float b, byte stepSize);
    public static Single[] Range(float a, float b, sbyte stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__145")]
public static IEnumerable`1<float> EnumerableRange(float a, float b, sbyte stepSize);
    public static Single[] Range(float a, float b, long stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__147")]
public static IEnumerable`1<float> EnumerableRange(float a, float b, long stepSize);
    public static Single[] Range(float a, float b, ulong stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__149")]
public static IEnumerable`1<float> EnumerableRange(float a, float b, ulong stepSize);
    public static Single[] Range(float a, float b, ushort stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__151")]
public static IEnumerable`1<float> EnumerableRange(float a, float b, ushort stepSize);
    public static Double[] Range(double n);
    public static Double[] Range(double a, double b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__154")]
public static IEnumerable`1<double> EnumerableRange(double n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__155")]
public static IEnumerable`1<double> EnumerableRange(double a, double b);
    public static Double[] Range(double a, double b, int stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__157")]
public static IEnumerable`1<double> EnumerableRange(double a, double b, int stepSize);
    public static Double[] Range(double a, double b, double stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__159")]
public static IEnumerable`1<double> EnumerableRange(double a, double b, double stepSize);
    public static Double[] Range(double a, double b, short stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__161")]
public static IEnumerable`1<double> EnumerableRange(double a, double b, short stepSize);
    public static Double[] Range(double a, double b, byte stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__163")]
public static IEnumerable`1<double> EnumerableRange(double a, double b, byte stepSize);
    public static Double[] Range(double a, double b, sbyte stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__165")]
public static IEnumerable`1<double> EnumerableRange(double a, double b, sbyte stepSize);
    public static Double[] Range(double a, double b, long stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__167")]
public static IEnumerable`1<double> EnumerableRange(double a, double b, long stepSize);
    public static Double[] Range(double a, double b, ulong stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__169")]
public static IEnumerable`1<double> EnumerableRange(double a, double b, ulong stepSize);
    public static Double[] Range(double a, double b, ushort stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__171")]
public static IEnumerable`1<double> EnumerableRange(double a, double b, ushort stepSize);
    public static Int16[] Range(short n);
    public static Int16[] Range(short a, short b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__174")]
public static IEnumerable`1<short> EnumerableRange(short n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__175")]
public static IEnumerable`1<short> EnumerableRange(short a, short b);
    public static Single[] Range(short a, short b, float stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__177")]
public static IEnumerable`1<float> EnumerableRange(short a, short b, float stepSize);
    public static Double[] Range(short a, short b, double stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__179")]
public static IEnumerable`1<double> EnumerableRange(short a, short b, double stepSize);
    public static Int16[] Range(short a, short b, short stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__181")]
public static IEnumerable`1<short> EnumerableRange(short a, short b, short stepSize);
    public static Byte[] Range(byte n);
    public static Byte[] Range(byte a, byte b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__184")]
public static IEnumerable`1<byte> EnumerableRange(byte n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__185")]
public static IEnumerable`1<byte> EnumerableRange(byte a, byte b);
    public static Single[] Range(byte a, byte b, float stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__187")]
public static IEnumerable`1<float> EnumerableRange(byte a, byte b, float stepSize);
    public static Double[] Range(byte a, byte b, double stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__189")]
public static IEnumerable`1<double> EnumerableRange(byte a, byte b, double stepSize);
    public static Byte[] Range(byte a, byte b, byte stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__191")]
public static IEnumerable`1<byte> EnumerableRange(byte a, byte b, byte stepSize);
    public static SByte[] Range(sbyte n);
    public static SByte[] Range(sbyte a, sbyte b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__194")]
public static IEnumerable`1<sbyte> EnumerableRange(sbyte n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__195")]
public static IEnumerable`1<sbyte> EnumerableRange(sbyte a, sbyte b);
    public static Single[] Range(sbyte a, sbyte b, float stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__197")]
public static IEnumerable`1<float> EnumerableRange(sbyte a, sbyte b, float stepSize);
    public static Double[] Range(sbyte a, sbyte b, double stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__199")]
public static IEnumerable`1<double> EnumerableRange(sbyte a, sbyte b, double stepSize);
    public static SByte[] Range(sbyte a, sbyte b, sbyte stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__201")]
public static IEnumerable`1<sbyte> EnumerableRange(sbyte a, sbyte b, sbyte stepSize);
    public static Int64[] Range(long n);
    public static Int64[] Range(long a, long b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__204")]
public static IEnumerable`1<long> EnumerableRange(long n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__205")]
public static IEnumerable`1<long> EnumerableRange(long a, long b);
    public static Single[] Range(long a, long b, float stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__207")]
public static IEnumerable`1<float> EnumerableRange(long a, long b, float stepSize);
    public static Double[] Range(long a, long b, double stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__209")]
public static IEnumerable`1<double> EnumerableRange(long a, long b, double stepSize);
    public static Int64[] Range(long a, long b, long stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__211")]
public static IEnumerable`1<long> EnumerableRange(long a, long b, long stepSize);
    public static Decimal[] Range(decimal n);
    public static Decimal[] Range(decimal a, decimal b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__214")]
public static IEnumerable`1<decimal> EnumerableRange(decimal n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__215")]
public static IEnumerable`1<decimal> EnumerableRange(decimal a, decimal b);
    public static Decimal[] Range(decimal a, decimal b, decimal stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__217")]
public static IEnumerable`1<decimal> EnumerableRange(decimal a, decimal b, decimal stepSize);
    public static UInt64[] Range(ulong n);
    public static UInt64[] Range(ulong a, ulong b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__220")]
public static IEnumerable`1<ulong> EnumerableRange(ulong n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__221")]
public static IEnumerable`1<ulong> EnumerableRange(ulong a, ulong b);
    public static Single[] Range(ulong a, ulong b, float stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__223")]
public static IEnumerable`1<float> EnumerableRange(ulong a, ulong b, float stepSize);
    public static Double[] Range(ulong a, ulong b, double stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__225")]
public static IEnumerable`1<double> EnumerableRange(ulong a, ulong b, double stepSize);
    public static UInt64[] Range(ulong a, ulong b, ulong stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__227")]
public static IEnumerable`1<ulong> EnumerableRange(ulong a, ulong b, ulong stepSize);
    public static UInt16[] Range(ushort n);
    public static UInt16[] Range(ushort a, ushort b);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__230")]
public static IEnumerable`1<ushort> EnumerableRange(ushort n);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__231")]
public static IEnumerable`1<ushort> EnumerableRange(ushort a, ushort b);
    public static Single[] Range(ushort a, ushort b, float stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__233")]
public static IEnumerable`1<float> EnumerableRange(ushort a, ushort b, float stepSize);
    public static Double[] Range(ushort a, ushort b, double stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__235")]
public static IEnumerable`1<double> EnumerableRange(ushort a, ushort b, double stepSize);
    public static UInt16[] Range(ushort a, ushort b, ushort stepSize);
    [IteratorStateMachineAttribute("Accord.Math.Vector/<EnumerableRange>d__237")]
public static IEnumerable`1<ushort> EnumerableRange(ushort a, ushort b, ushort stepSize);
    [ExtensionAttribute]
public static Double[] Range(DoubleRange range);
    [ExtensionAttribute]
public static Double[] Range(DoubleRange range, double stepSize);
    [ExtensionAttribute]
public static Double[] Range(DoubleRange range, float stepSize);
    [ExtensionAttribute]
public static Double[] Range(DoubleRange range, byte stepSize);
    [ExtensionAttribute]
public static Double[] Range(DoubleRange range, int stepSize);
    [ExtensionAttribute]
public static Single[] Range(Range range);
    [ExtensionAttribute]
public static Double[] Range(Range range, double stepSize);
    [ExtensionAttribute]
public static Single[] Range(Range range, float stepSize);
    [ExtensionAttribute]
public static Single[] Range(Range range, byte stepSize);
    [ExtensionAttribute]
public static Single[] Range(Range range, int stepSize);
    [ExtensionAttribute]
public static Byte[] Range(ByteRange range);
    [ExtensionAttribute]
public static Double[] Range(ByteRange range, double stepSize);
    [ExtensionAttribute]
public static Single[] Range(ByteRange range, float stepSize);
    [ExtensionAttribute]
public static Byte[] Range(ByteRange range, byte stepSize);
    [ExtensionAttribute]
public static Int32[] Range(IntRange range);
    [ExtensionAttribute]
public static Double[] Range(IntRange range, double stepSize);
    [ExtensionAttribute]
public static Single[] Range(IntRange range, float stepSize);
    [ExtensionAttribute]
public static Int32[] Range(IntRange range, int stepSize);
    [ExtensionAttribute]
public static int Scale(int value, int fromMin, int fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int32[] values, int fromMin, int fromMax, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static int Scale(int value, IRange`1<int> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Int32[] values, int fromMin, int fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int32[] values, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int32[] values, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Int32[] values, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static float Scale(int value, int fromMin, int fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int32[] values, int fromMin, int fromMax, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static float Scale(int value, IRange`1<int> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Int32[] values, int fromMin, int fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int32[] values, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int32[] values, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Int32[] values, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static double Scale(int value, int fromMin, int fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int32[] values, int fromMin, int fromMax, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static double Scale(int value, IRange`1<int> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Int32[] values, int fromMin, int fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int32[] values, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int32[] values, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Int32[] values, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static short Scale(int value, int fromMin, int fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int32[] values, int fromMin, int fromMax, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static short Scale(int value, IRange`1<int> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Int32[] values, int fromMin, int fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int32[] values, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int32[] values, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Int32[] values, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static byte Scale(int value, int fromMin, int fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int32[] values, int fromMin, int fromMax, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static byte Scale(int value, IRange`1<int> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Int32[] values, int fromMin, int fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int32[] values, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int32[] values, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Int32[] values, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static sbyte Scale(int value, int fromMin, int fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int32[] values, int fromMin, int fromMax, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static sbyte Scale(int value, IRange`1<int> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Int32[] values, int fromMin, int fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int32[] values, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int32[] values, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Int32[] values, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static long Scale(int value, int fromMin, int fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int32[] values, int fromMin, int fromMax, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static long Scale(int value, IRange`1<int> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Int32[] values, int fromMin, int fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int32[] values, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int32[] values, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Int32[] values, IRange`1<int> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Int32[] values, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static int Scale(float value, float fromMin, float fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Single[] values, float fromMin, float fromMax, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static int Scale(float value, IRange`1<float> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Single[] values, float fromMin, float fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Single[] values, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Single[] values, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Single[] values, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static float Scale(float value, float fromMin, float fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Single[] values, float fromMin, float fromMax, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static float Scale(float value, IRange`1<float> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Single[] values, float fromMin, float fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Single[] values, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Single[] values, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Single[] values, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static double Scale(float value, float fromMin, float fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Single[] values, float fromMin, float fromMax, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static double Scale(float value, IRange`1<float> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Single[] values, float fromMin, float fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Single[] values, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Single[] values, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Single[] values, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static short Scale(float value, float fromMin, float fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Single[] values, float fromMin, float fromMax, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static short Scale(float value, IRange`1<float> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Single[] values, float fromMin, float fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Single[] values, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Single[] values, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Single[] values, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static byte Scale(float value, float fromMin, float fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Single[] values, float fromMin, float fromMax, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static byte Scale(float value, IRange`1<float> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Single[] values, float fromMin, float fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Single[] values, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Single[] values, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Single[] values, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static sbyte Scale(float value, float fromMin, float fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Single[] values, float fromMin, float fromMax, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static sbyte Scale(float value, IRange`1<float> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Single[] values, float fromMin, float fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Single[] values, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Single[] values, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Single[] values, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static long Scale(float value, float fromMin, float fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Single[] values, float fromMin, float fromMax, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static long Scale(float value, IRange`1<float> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Single[] values, float fromMin, float fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Single[] values, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Single[] values, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Single[] values, IRange`1<float> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Single[] values, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static int Scale(double value, double fromMin, double fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Double[] values, double fromMin, double fromMax, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static int Scale(double value, IRange`1<double> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Double[] values, double fromMin, double fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Double[] values, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Double[] values, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Double[] values, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static float Scale(double value, double fromMin, double fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Double[] values, double fromMin, double fromMax, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static float Scale(double value, IRange`1<double> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Double[] values, double fromMin, double fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Double[] values, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Double[] values, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Double[] values, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static double Scale(double value, double fromMin, double fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Double[] values, double fromMin, double fromMax, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static double Scale(double value, IRange`1<double> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Double[] values, double fromMin, double fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Double[] values, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Double[] values, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Double[] values, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static short Scale(double value, double fromMin, double fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Double[] values, double fromMin, double fromMax, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static short Scale(double value, IRange`1<double> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Double[] values, double fromMin, double fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Double[] values, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Double[] values, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Double[] values, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static byte Scale(double value, double fromMin, double fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Double[] values, double fromMin, double fromMax, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static byte Scale(double value, IRange`1<double> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Double[] values, double fromMin, double fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Double[] values, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Double[] values, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Double[] values, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static sbyte Scale(double value, double fromMin, double fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Double[] values, double fromMin, double fromMax, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static sbyte Scale(double value, IRange`1<double> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Double[] values, double fromMin, double fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Double[] values, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Double[] values, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Double[] values, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static long Scale(double value, double fromMin, double fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Double[] values, double fromMin, double fromMax, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static long Scale(double value, IRange`1<double> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Double[] values, double fromMin, double fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Double[] values, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Double[] values, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Double[] values, IRange`1<double> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Double[] values, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static int Scale(short value, short fromMin, short fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int16[] values, short fromMin, short fromMax, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static int Scale(short value, IRange`1<short> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Int16[] values, short fromMin, short fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int16[] values, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int16[] values, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Int16[] values, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static float Scale(short value, short fromMin, short fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int16[] values, short fromMin, short fromMax, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static float Scale(short value, IRange`1<short> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Int16[] values, short fromMin, short fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int16[] values, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int16[] values, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Int16[] values, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static double Scale(short value, short fromMin, short fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int16[] values, short fromMin, short fromMax, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static double Scale(short value, IRange`1<short> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Int16[] values, short fromMin, short fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int16[] values, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int16[] values, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Int16[] values, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static short Scale(short value, short fromMin, short fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int16[] values, short fromMin, short fromMax, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static short Scale(short value, IRange`1<short> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Int16[] values, short fromMin, short fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int16[] values, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int16[] values, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Int16[] values, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static byte Scale(short value, short fromMin, short fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int16[] values, short fromMin, short fromMax, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static byte Scale(short value, IRange`1<short> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Int16[] values, short fromMin, short fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int16[] values, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int16[] values, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Int16[] values, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static sbyte Scale(short value, short fromMin, short fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int16[] values, short fromMin, short fromMax, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static sbyte Scale(short value, IRange`1<short> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Int16[] values, short fromMin, short fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int16[] values, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int16[] values, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Int16[] values, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static long Scale(short value, short fromMin, short fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int16[] values, short fromMin, short fromMax, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static long Scale(short value, IRange`1<short> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Int16[] values, short fromMin, short fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int16[] values, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int16[] values, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Int16[] values, IRange`1<short> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Int16[] values, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static int Scale(byte value, byte fromMin, byte fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Byte[] values, byte fromMin, byte fromMax, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static int Scale(byte value, IRange`1<byte> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Byte[] values, byte fromMin, byte fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Byte[] values, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Byte[] values, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Byte[] values, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static float Scale(byte value, byte fromMin, byte fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Byte[] values, byte fromMin, byte fromMax, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static float Scale(byte value, IRange`1<byte> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Byte[] values, byte fromMin, byte fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Byte[] values, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Byte[] values, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Byte[] values, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static double Scale(byte value, byte fromMin, byte fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Byte[] values, byte fromMin, byte fromMax, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static double Scale(byte value, IRange`1<byte> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Byte[] values, byte fromMin, byte fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Byte[] values, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Byte[] values, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Byte[] values, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static short Scale(byte value, byte fromMin, byte fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Byte[] values, byte fromMin, byte fromMax, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static short Scale(byte value, IRange`1<byte> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Byte[] values, byte fromMin, byte fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Byte[] values, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Byte[] values, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Byte[] values, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static byte Scale(byte value, byte fromMin, byte fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Byte[] values, byte fromMin, byte fromMax, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static byte Scale(byte value, IRange`1<byte> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Byte[] values, byte fromMin, byte fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Byte[] values, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Byte[] values, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Byte[] values, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static sbyte Scale(byte value, byte fromMin, byte fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Byte[] values, byte fromMin, byte fromMax, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static sbyte Scale(byte value, IRange`1<byte> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Byte[] values, byte fromMin, byte fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Byte[] values, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Byte[] values, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Byte[] values, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static long Scale(byte value, byte fromMin, byte fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Byte[] values, byte fromMin, byte fromMax, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static long Scale(byte value, IRange`1<byte> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Byte[] values, byte fromMin, byte fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Byte[] values, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Byte[] values, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Byte[] values, IRange`1<byte> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Byte[] values, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static int Scale(sbyte value, sbyte fromMin, sbyte fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static int Scale(sbyte value, IRange`1<sbyte> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(SByte[] values, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(SByte[] values, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(SByte[] values, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static float Scale(sbyte value, sbyte fromMin, sbyte fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static float Scale(sbyte value, IRange`1<sbyte> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(SByte[] values, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(SByte[] values, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(SByte[] values, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static double Scale(sbyte value, sbyte fromMin, sbyte fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static double Scale(sbyte value, IRange`1<sbyte> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(SByte[] values, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(SByte[] values, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(SByte[] values, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static short Scale(sbyte value, sbyte fromMin, sbyte fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static short Scale(sbyte value, IRange`1<sbyte> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(SByte[] values, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(SByte[] values, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(SByte[] values, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static byte Scale(sbyte value, sbyte fromMin, sbyte fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static byte Scale(sbyte value, IRange`1<sbyte> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(SByte[] values, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(SByte[] values, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(SByte[] values, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static sbyte Scale(sbyte value, sbyte fromMin, sbyte fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static sbyte Scale(sbyte value, IRange`1<sbyte> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(SByte[] values, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(SByte[] values, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(SByte[] values, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static long Scale(sbyte value, sbyte fromMin, sbyte fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static long Scale(sbyte value, IRange`1<sbyte> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(SByte[] values, sbyte fromMin, sbyte fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(SByte[] values, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(SByte[] values, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(SByte[] values, IRange`1<sbyte> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(SByte[] values, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static int Scale(long value, long fromMin, long fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int64[] values, long fromMin, long fromMax, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static int Scale(long value, IRange`1<long> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Int64[] values, long fromMin, long fromMax, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int64[] values, int toMin, int toMax);
    [ExtensionAttribute]
public static Int32[] Scale(Int64[] values, int toMin, int toMax, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static Int32[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<int> toRange);
    [ExtensionAttribute]
public static Int32[] Scale(Int64[] values, IRange`1<int> toRange, Int32[] result);
    [ExtensionAttribute]
public static float Scale(long value, long fromMin, long fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int64[] values, long fromMin, long fromMax, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static float Scale(long value, IRange`1<long> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Int64[] values, long fromMin, long fromMax, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int64[] values, float toMin, float toMax);
    [ExtensionAttribute]
public static Single[] Scale(Int64[] values, float toMin, float toMax, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static Single[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<float> toRange);
    [ExtensionAttribute]
public static Single[] Scale(Int64[] values, IRange`1<float> toRange, Single[] result);
    [ExtensionAttribute]
public static double Scale(long value, long fromMin, long fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int64[] values, long fromMin, long fromMax, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static double Scale(long value, IRange`1<long> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Int64[] values, long fromMin, long fromMax, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int64[] values, double toMin, double toMax);
    [ExtensionAttribute]
public static Double[] Scale(Int64[] values, double toMin, double toMax, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static Double[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<double> toRange);
    [ExtensionAttribute]
public static Double[] Scale(Int64[] values, IRange`1<double> toRange, Double[] result);
    [ExtensionAttribute]
public static short Scale(long value, long fromMin, long fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int64[] values, long fromMin, long fromMax, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static short Scale(long value, IRange`1<long> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Int64[] values, long fromMin, long fromMax, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int64[] values, short toMin, short toMax);
    [ExtensionAttribute]
public static Int16[] Scale(Int64[] values, short toMin, short toMax, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static Int16[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<short> toRange);
    [ExtensionAttribute]
public static Int16[] Scale(Int64[] values, IRange`1<short> toRange, Int16[] result);
    [ExtensionAttribute]
public static byte Scale(long value, long fromMin, long fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int64[] values, long fromMin, long fromMax, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static byte Scale(long value, IRange`1<long> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Int64[] values, long fromMin, long fromMax, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int64[] values, byte toMin, byte toMax);
    [ExtensionAttribute]
public static Byte[] Scale(Int64[] values, byte toMin, byte toMax, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static Byte[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<byte> toRange);
    [ExtensionAttribute]
public static Byte[] Scale(Int64[] values, IRange`1<byte> toRange, Byte[] result);
    [ExtensionAttribute]
public static sbyte Scale(long value, long fromMin, long fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int64[] values, long fromMin, long fromMax, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static sbyte Scale(long value, IRange`1<long> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Int64[] values, long fromMin, long fromMax, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int64[] values, sbyte toMin, sbyte toMax);
    [ExtensionAttribute]
public static SByte[] Scale(Int64[] values, sbyte toMin, sbyte toMax, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static SByte[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<sbyte> toRange);
    [ExtensionAttribute]
public static SByte[] Scale(Int64[] values, IRange`1<sbyte> toRange, SByte[] result);
    [ExtensionAttribute]
public static long Scale(long value, long fromMin, long fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int64[] values, long fromMin, long fromMax, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static long Scale(long value, IRange`1<long> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Int64[] values, long fromMin, long fromMax, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int64[] values, long toMin, long toMax);
    [ExtensionAttribute]
public static Int64[] Scale(Int64[] values, long toMin, long toMax, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static Int64[] Scale(Int64[] values, IRange`1<long> fromRange, IRange`1<long> toRange);
    [ExtensionAttribute]
public static Int64[] Scale(Int64[] values, IRange`1<long> toRange, Int64[] result);
    [ExtensionAttribute]
public static double Dot(Sparse`1<double> a, Sparse`1<double> b);
    [ExtensionAttribute]
public static double Dot(Sparse`1<double> a, Double[] b);
    [ExtensionAttribute]
public static Double[] Add(Sparse`1<double> a, Double[] b, Double[] result);
    [ExtensionAttribute]
public static Sparse`1[] Divide(Sparse`1[] a, Double[] b, Sparse`1[] result);
    [ExtensionAttribute]
public static Sparse`1<double> Divide(Sparse`1<double> a, double b, Sparse`1<double> result);
}
[SerializableAttribute]
public class Accord.Math.Vector3 : ValueType {
    public float X;
    public float Y;
    public float Z;
    public float Max { get; }
    public float Min { get; }
    public int MaxIndex { get; }
    public int MinIndex { get; }
    public float Norm { get; }
    public float Square { get; }
    public Vector3(float x, float y, float z);
    public Vector3(float value);
    public float get_Max();
    public float get_Min();
    public int get_MaxIndex();
    public int get_MinIndex();
    public float get_Norm();
    public float get_Square();
    public virtual string ToString();
    public Single[] ToArray();
    public static Vector3 op_Addition(Vector3 vector1, Vector3 vector2);
    public static Vector3 Add(Vector3 vector1, Vector3 vector2);
    public static Vector3 op_Addition(Vector3 vector, float value);
    public static Vector3 Add(Vector3 vector, float value);
    public static Vector3 op_Subtraction(Vector3 vector1, Vector3 vector2);
    public static Vector3 Subtract(Vector3 vector1, Vector3 vector2);
    public static Vector3 op_Subtraction(Vector3 vector, float value);
    public static Vector3 Subtract(Vector3 vector, float value);
    public static Vector3 op_Multiply(Vector3 vector1, Vector3 vector2);
    public static Vector3 Multiply(Vector3 vector1, Vector3 vector2);
    public static Vector3 op_Multiply(Vector3 vector, float factor);
    public static Vector3 Multiply(Vector3 vector, float factor);
    public static Vector3 op_Division(Vector3 vector1, Vector3 vector2);
    public static Vector3 Divide(Vector3 vector1, Vector3 vector2);
    public static Vector3 op_Division(Vector3 vector, float factor);
    public static Vector3 Divide(Vector3 vector, float factor);
    public static bool op_Equality(Vector3 vector1, Vector3 vector2);
    public static bool op_Inequality(Vector3 vector1, Vector3 vector2);
    public bool Equals(Vector3 vector);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public float Normalize();
    public Vector3 Inverse();
    public Vector3 Abs();
    public static Vector3 Cross(Vector3 vector1, Vector3 vector2);
    public static float Dot(Vector3 vector1, Vector3 vector2);
    public Vector4 ToVector4();
}
[SerializableAttribute]
public class Accord.Math.Vector4 : ValueType {
    public float X;
    public float Y;
    public float Z;
    public float W;
    public float Max { get; }
    public float Min { get; }
    public int MaxIndex { get; }
    public int MinIndex { get; }
    public float Norm { get; }
    public float Square { get; }
    public Vector4(float x, float y, float z, float w);
    public Vector4(float value);
    public float get_Max();
    public float get_Min();
    public int get_MaxIndex();
    public int get_MinIndex();
    public float get_Norm();
    public float get_Square();
    public virtual string ToString();
    public Single[] ToArray();
    public static Vector4 op_Addition(Vector4 vector1, Vector4 vector2);
    public static Vector4 Add(Vector4 vector1, Vector4 vector2);
    public static Vector4 op_Addition(Vector4 vector, float value);
    public static Vector4 Add(Vector4 vector, float value);
    public static Vector4 op_Subtraction(Vector4 vector1, Vector4 vector2);
    public static Vector4 Subtract(Vector4 vector1, Vector4 vector2);
    public static Vector4 op_Subtraction(Vector4 vector, float value);
    public static Vector4 Subtract(Vector4 vector, float value);
    public static Vector4 op_Multiply(Vector4 vector1, Vector4 vector2);
    public static Vector4 Multiply(Vector4 vector1, Vector4 vector2);
    public static Vector4 op_Multiply(Vector4 vector, float factor);
    public static Vector4 Multiply(Vector4 vector, float factor);
    public static Vector4 op_Division(Vector4 vector1, Vector4 vector2);
    public static Vector4 Divide(Vector4 vector1, Vector4 vector2);
    public static Vector4 op_Division(Vector4 vector, float factor);
    public static Vector4 Divide(Vector4 vector, float factor);
    public static bool op_Equality(Vector4 vector1, Vector4 vector2);
    public static bool op_Inequality(Vector4 vector1, Vector4 vector2);
    public bool Equals(Vector4 vector);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public float Normalize();
    public Vector4 Inverse();
    public Vector4 Abs();
    public static float Dot(Vector4 vector1, Vector4 vector2);
    public Vector3 ToVector3();
}
public class Accord.Math.Wavelets.CDF97 : object {
    private static double alpha;
    private static double beta;
    private static double gamma;
    private static double delta;
    private static double zeta;
    private int levels;
    public CDF97(int levels);
    public sealed virtual void Forward(Double[] data);
    public sealed virtual void Forward(Double[0...,0...] data);
    public sealed virtual void Backward(Double[] data);
    public sealed virtual void Backward(Double[0...,0...] data);
    public static void FWT97(Double[] x);
    public static void IWT97(Double[] x);
    public static Double[0...,0...] FWT97(Double[0...,0...] data, int levels);
    public static Double[0...,0...] IWT97(Double[0...,0...] data, int levels);
    private static Double[0...,0...] fwt2d(Double[0...,0...] x, int width, int height);
    private static Double[0...,0...] iwt2d(Double[0...,0...] x, int width, int height);
}
public class Accord.Math.Wavelets.Haar : object {
    private static double SQRT2;
    private static double w0;
    private static double w1;
    private static double s0;
    private static double s1;
    private int levels;
    public Haar(int levels);
    public sealed virtual void Forward(Double[] data);
    public sealed virtual void Backward(Double[] data);
    public sealed virtual void Forward(Double[0...,0...] data);
    public sealed virtual void Backward(Double[0...,0...] data);
    public static void FWT(Double[] data);
    public static void IWT(Double[] data);
    public static void FWT(Double[0...,0...] data, int iterations);
    public static void IWT(Double[0...,0...] data, int iterations);
}
public interface Accord.Math.Wavelets.IWavelet {
    public abstract virtual void Forward(Double[] data);
    public abstract virtual void Forward(Double[0...,0...] data);
    public abstract virtual void Backward(Double[] data);
    public abstract virtual void Backward(Double[0...,0...] data);
}
[ExtensionAttribute]
public static class Accord.Sort : object {
    private static int INTROSORT_THRESHOLD;
    public static int Insertion(T[] keys, bool asc);
    public static int Insertion(T[] keys, U[] items, bool asc);
    public static int Insertion(T[] keys, Func`3<T, T, int> comparer, bool asc);
    public static int Insertion(TKey[] keys, TValue[] items, Func`3<TKey, TKey, int> comparer, bool asc);
    public static int Insertion(T[] keys, int first, int last, bool asc);
    public static int Insertion(TKey[] keys, TValue[] items, int first, int last, bool asc);
    public static int Insertion(T[] keys, int first, int last, Func`3<T, T, int> comparer, bool asc);
    public static int Insertion(TKeys[] keys, TValue[] items, int first, int last, Func`3<TKeys, TKeys, int> comparer, bool asc);
    public static void Partial(T[] items, int n, bool asc);
    public static void Partial(TKey[] keys, TValue[] items, int n, bool asc);
    [ExtensionAttribute]
public static int Partition(TKey[] keys, TValue[] items, int first, int last, bool asc);
    [ExtensionAttribute]
public static int Partition(T[] keys, int first, int last, bool asc);
    [ExtensionAttribute]
public static int Partition(TKey[] keys, TValue[] items, int first, int last, Func`3<TKey, TKey, int> compare, bool asc);
    [ExtensionAttribute]
public static int Partition(T[] items, int first, int last, Func`3<T, T, int> compare, bool asc);
    [ExtensionAttribute]
public static TKey NthElement(TKey[] keys, TValue[] items, int first, int last, int n, Func`3<TKey, TKey, int> compare, bool asc);
    [ExtensionAttribute]
public static T NthElement(T[] items, int first, int last, int n, Func`3<T, T, int> compare, bool asc);
    [ExtensionAttribute]
public static TKey NthElement(TKey[] keys, TValue[] items, int first, int last, int n, bool asc);
    [ExtensionAttribute]
public static T NthElement(T[] items, int n, bool asc);
    [ExtensionAttribute]
public static TKey NthElement(TKey[] keys, TValue[] items, int n, bool asc);
    [ExtensionAttribute]
public static T NthElement(T[] items, int first, int last, int n, bool asc);
    private static int pivot(T[] keys, U[] items, int first, int last, bool asc);
    private static int pivot(T[] keys, int first, int last, bool asc);
    private static int pivot(T[] keys, U[] items, int first, int last, Func`3<T, T, int> comparer, bool asc);
    private static int pivot(T[] keys, int first, int last, Func`3<T, T, int> comparer, bool asc);
}
[ExtensionAttribute]
public static class Accord.Statistics.Classes : object {
    public static Double[] GetRatio(Int32[] positives, Int32[] negatives);
    [ExtensionAttribute]
public static Double[] GetRatio(Int32[][] data, int positiveColumn, int negativeColumn);
    [ExtensionAttribute]
public static Int32[][] Summarize(Int32[][] data, int groupIndex, int yesNoIndex);
    [ExtensionAttribute]
public static T[][] Separate(T[] values, Int32[] labels);
    [ExtensionAttribute]
public static T[][] Separate(T[] values, Int32[] labels, int groups);
    [ExtensionAttribute]
public static Int32[][] Expand(Int32[] data, Int32[] positives, Int32[] negatives);
    [ExtensionAttribute]
public static Int32[][] Expand(Int32[][] data, int labelColumn, int positiveColumn, int negativeColumn);
    public static Int32[] Random(int samples, int classes);
    public static Int32[] Random(int samples, Double[] proportion);
    public static Int32[] Random(int samples, double proportion);
    public static Int32[] Random(Int32[] labels, int categories);
    public static Int32[] Random(Int32[] labels, int classes, int categories);
    public static Int32[] Random(Int32[] labels, double proportion);
    public static double GetRatio(Int32[] y, Int32& positives, Int32& negatives);
    [ExtensionAttribute]
public static double GetRatio(Boolean[] y, Int32& positives, Int32& negatives);
    [ExtensionAttribute]
public static int ToZeroOne(bool p);
    [ExtensionAttribute]
public static int ToZeroOne(int p);
    [ExtensionAttribute]
public static int ToZeroOne(double p);
    [ExtensionAttribute]
public static Int32[] ToZeroOne(Boolean[] p);
    [ExtensionAttribute]
public static Int32[] ToZeroOne(Int32[] p);
    [ExtensionAttribute]
public static Int32[] ToZeroOne(Double[] p);
    [ExtensionAttribute]
public static int ToMinusOnePlusOne(bool p);
    [ExtensionAttribute]
public static int ToMinusOnePlusOne(int p);
    [ExtensionAttribute]
public static int ToMinusOnePlusOne(double p);
    [ExtensionAttribute]
public static Int32[] ToMinusOnePlusOne(Boolean[] p);
    [ExtensionAttribute]
public static Int32[] ToMinusOnePlusOne(Int32[] p);
    [ExtensionAttribute]
public static Int32[] ToMinusOnePlusOne(Double[] p);
    [ExtensionAttribute]
public static Double[][] ToMinusOnePlusOne(Boolean[][] p);
    [ExtensionAttribute]
public static T[][] ToMinusOnePlusOne(Boolean[][] p);
    [ExtensionAttribute]
public static Int32[] ToMulticlass(Double[] p);
    [ExtensionAttribute]
public static Int32[] ToMulticlass(Int32[] p);
    [ExtensionAttribute]
public static Int32[] ToMulticlass(Double[] p, int min);
    [ExtensionAttribute]
public static Int32[] ToMulticlass(Int32[] p, int min);
    [ExtensionAttribute]
public static bool IsZeroOne(Int32[] p);
    [ExtensionAttribute]
public static bool IsMinusOnePlusOne(Int32[] p);
    [ExtensionAttribute]
public static bool IsBinary(Int32[] p);
    [ExtensionAttribute]
public static bool IsMultilabel(Boolean[][] y);
    [ExtensionAttribute]
public static bool IsMulticlass(Boolean[][] y);
    public static bool Decide(double distance);
    public static bool Decide(int label);
    public static Boolean[] Decide(Double[] values);
    public static Boolean[] Decide(Int32[] values);
    public static Boolean[][] Decide(Double[][] values);
    public static Boolean[][] Decide(Int32[][] values);
}
[ExtensionAttribute]
public static class Accord.Statistics.Measures : object {
    private static double ONE_THIRD;
    private static double TWO_THIRDS;
    private static Measures();
    [ExtensionAttribute]
public static int HistogramMin(Int32[] values);
    [ExtensionAttribute]
public static int HistogramMax(Int32[] values);
    [ExtensionAttribute]
public static long HistogramSum(Int32[] values);
    [ExtensionAttribute]
public static double HistogramMean(Int32[] values);
    [ExtensionAttribute]
public static double HistogramStandardDeviation(Int32[] values);
    [ExtensionAttribute]
public static double HistogramStandardDeviation(Int32[] values, double mean);
    [ExtensionAttribute]
public static int HistogramMedian(Int32[] values);
    [ExtensionAttribute]
public static IntRange GetHistogramRange(Int32[] values, double percent);
    [ExtensionAttribute]
public static double HistogramEntropy(Int32[] values);
    [ExtensionAttribute]
public static int HistogramMode(Int32[] values);
    [ExtensionAttribute]
public static double Mean(Double[][] matrix);
    [ExtensionAttribute]
public static double Mean(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[] Mean(Double[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Double[] Mean(Double[][] matrix, int dimension);
    [ExtensionAttribute]
public static Double[] Mean(Double[0...,0...] matrix, Double[] sums);
    [ExtensionAttribute]
public static Double[] Mean(Double[][] matrix, Double[] sums);
    [ExtensionAttribute]
public static Double[] StandardDeviation(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[] StandardDeviation(Double[0...,0...] matrix, Double[] means);
    [ExtensionAttribute]
public static Double[] StandardDeviation(Double[][] matrix, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static Double[] StandardDeviation(Double[][] matrix, bool unbiased);
    [ExtensionAttribute]
public static Double[] Variance(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[] Variance(Double[0...,0...] matrix, Double[] means);
    [ExtensionAttribute]
public static Double[] Variance(Double[][] matrix);
    [ExtensionAttribute]
public static Double[] Variance(Double[][] matrix, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static Double[] Median(Double[0...,0...] matrix, QuantileMethod type);
    [ExtensionAttribute]
public static Double[] Median(Double[][] matrix, QuantileMethod type);
    [ExtensionAttribute]
public static Double[] Quartiles(Double[0...,0...] matrix, DoubleRange[]& range, QuantileMethod type);
    [ExtensionAttribute]
public static Double[] Quartiles(Double[][] matrix, DoubleRange[]& range, QuantileMethod type);
    public static Double[] Quartiles(Double[][] matrix, Double[]& q1, Double[]& q3, QuantileMethod type);
    public static Double[] Quartiles(Double[0...,0...] matrix, Double[]& q1, Double[]& q3, QuantileMethod type);
    [ExtensionAttribute]
public static T[] Mode(T[0...,0...] matrix);
    [ExtensionAttribute]
public static T[] Mode(T[][] matrix);
    [ExtensionAttribute]
public static Double[] Skewness(Double[0...,0...] matrix, bool unbiased);
    [ExtensionAttribute]
public static Double[] Skewness(Double[0...,0...] matrix, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static Double[] Skewness(Double[][] matrix, bool unbiased);
    [ExtensionAttribute]
public static Double[] Skewness(Double[][] matrix, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static Double[] Kurtosis(Double[0...,0...] matrix, bool unbiased);
    [ExtensionAttribute]
public static Double[] Kurtosis(Double[0...,0...] matrix, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static Double[] Kurtosis(Double[][] matrix, bool unbiased);
    [ExtensionAttribute]
public static Double[] Kurtosis(Double[][] matrix, Double[] means, bool unbiased);
    public static Double[] StandardError(Double[0...,0...] matrix);
    public static Double[] StandardError(int samples, Double[] standardDeviations);
    [ExtensionAttribute]
public static Double[0...,0...] Covariance(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[0...,0...] Covariance(Double[0...,0...] matrix, int dimension);
    [ExtensionAttribute]
public static Double[0...,0...] Covariance(Double[0...,0...] matrix, Double[] means);
    [ExtensionAttribute]
public static Double[0...,0...] Scatter(Double[0...,0...] matrix, Double[] means);
    [ExtensionAttribute]
public static Double[0...,0...] Scatter(Double[0...,0...] matrix, Double[] means, double divisor);
    [ExtensionAttribute]
public static Double[0...,0...] Scatter(Double[0...,0...] matrix, Double[] means, int dimension);
    [ExtensionAttribute]
public static Double[0...,0...] Scatter(Double[0...,0...] matrix, Double[] means, double divisor, int dimension);
    [ExtensionAttribute]
public static Double[][] Covariance(Double[][] matrix);
    [ExtensionAttribute]
public static Double[][] Covariance(Double[][] matrix, int dimension);
    [ExtensionAttribute]
public static Double[][] Covariance(Double[][] matrix, Double[] means);
    [ExtensionAttribute]
public static Double[][] Scatter(Double[][] matrix, Double[] means);
    [ExtensionAttribute]
public static Double[][] Scatter(Double[][] matrix, Double[] means, double divisor);
    [ExtensionAttribute]
public static Double[][] Scatter(Double[][] matrix, double divisor, int dimension);
    [ExtensionAttribute]
public static Double[][] Scatter(Double[][] matrix, Double[] means, int dimension);
    public static Double[][] Scatter(Double[][] matrix, Double[] means, double divisor, int dimension);
    public static Double[0...,0...] PooledCovariance(Double[0...,0...][] covariances, Double[] weights);
    [ExtensionAttribute]
public static Double[0...,0...] Correlation(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[][] Correlation(Double[][] matrix);
    [ExtensionAttribute]
public static Double[0...,0...] Correlation(Double[0...,0...] matrix, Double[] means, Double[] standardDeviations);
    [ExtensionAttribute]
public static Double[][] Correlation(Double[][] matrix, Double[] means, Double[] standardDeviations);
    private static double z(double v, double mean, double sdev);
    [ExtensionAttribute]
public static Double[] WeightedMean(Double[][] matrix, Double[] weights);
    [ExtensionAttribute]
public static Double[] WeightedMean(Double[][] matrix, Double[] weights, int dimension);
    [ExtensionAttribute]
public static Double[] WeightedMean(Double[0...,0...] matrix, Double[] weights);
    [ExtensionAttribute]
public static Double[] WeightedMean(Double[0...,0...] matrix, Double[] weights, int dimension);
    [ExtensionAttribute]
public static Double[] WeightedMean(Double[][] matrix, Int32[] weights);
    [ExtensionAttribute]
public static Double[] WeightedMean(Double[][] matrix, Int32[] weights, int dimension);
    [ExtensionAttribute]
public static Double[] WeightedMean(Double[0...,0...] matrix, Int32[] weights);
    [ExtensionAttribute]
public static Double[] WeightedMean(Double[0...,0...] matrix, Int32[] weights, int dimension);
    [ExtensionAttribute]
public static Double[] ExponentialWeightedMean(Double[][] matrix, double alpha);
    [ExtensionAttribute]
public static Double[] ExponentialWeightedMean(Double[][] matrix, int window, double alpha);
    [ExtensionAttribute]
public static Double[0...,0...] ExponentialWeightedCovariance(Double[][] matrix, double alpha, bool unbiased);
    [ExtensionAttribute]
public static Double[0...,0...] ExponentialWeightedCovariance(Double[][] matrix, int window, double alpha, bool unbiased);
    [ExtensionAttribute]
public static Double[] WeightedStandardDeviation(Double[0...,0...] matrix, Int32[] weights);
    [ExtensionAttribute]
public static Double[] WeightedStandardDeviation(Double[0...,0...] matrix, Int32[] weights, Double[] means);
    [ExtensionAttribute]
public static Double[] WeightedStandardDeviation(Double[][] matrix, Int32[] weights, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static Double[] WeightedStandardDeviation(Double[][] matrix, Int32[] weights, bool unbiased);
    [ExtensionAttribute]
public static Double[] WeightedStandardDeviation(Double[0...,0...] matrix, Double[] weights);
    [ExtensionAttribute]
public static Double[] WeightedStandardDeviation(Double[0...,0...] matrix, Double[] weights, Double[] means);
    [ExtensionAttribute]
public static Double[] WeightedStandardDeviation(Double[][] matrix, Double[] weights, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static Double[] WeightedStandardDeviation(Double[][] matrix, Double[] weights, bool unbiased);
    [ExtensionAttribute]
public static Double[0...,0...] WeightedCovariance(Double[][] matrix, Double[] weights, Double[] means);
    [ExtensionAttribute]
public static Double[0...,0...] WeightedCovariance(Double[][] matrix, Double[] weights, int dimension);
    [ExtensionAttribute]
public static Double[0...,0...] WeightedCovariance(Double[][] matrix, Int32[] weights, int dimension);
    [ExtensionAttribute]
public static Double[0...,0...] WeightedCovariance(Double[][] matrix, Double[] weights, Double[] means, int dimension);
    [ExtensionAttribute]
public static Double[0...,0...] WeightedCovariance(Double[][] matrix, Int32[] weights, Double[] means, int dimension);
    [ExtensionAttribute]
public static Double[0...,0...] WeightedScatter(Double[][] matrix, Double[] weights, Double[] means, double factor, int dimension);
    [ExtensionAttribute]
public static Double[0...,0...] WeightedScatter(Double[][] matrix, Int32[] weights, Double[] means, double factor, int dimension);
    private static Double[] GetDecayWeights(int window, double alpha);
    private static void Validate(Double[][] matrix, int window, double alpha);
    private static double correct(bool unbiased, WeightType weightType, double sum, double weightSum, double squareSum);
    [ExtensionAttribute]
public static double Mean(Double[] values);
    [ExtensionAttribute]
public static double Mean(Int32[] values);
    [ExtensionAttribute]
public static double GeometricMean(Double[] values);
    [ExtensionAttribute]
public static double LogGeometricMean(Double[] values);
    [ExtensionAttribute]
public static double GeometricMean(Int32[] values);
    [ExtensionAttribute]
public static double LogGeometricMean(Int32[] values);
    public static double GrandMean(Double[] means, Int32[] samples);
    [ExtensionAttribute]
public static double Mean(UInt16[] values);
    [ExtensionAttribute]
public static float Mean(Single[] values);
    [ExtensionAttribute]
public static double TruncatedMean(Double[] values, double percent, bool inPlace, bool alreadySorted);
    public static double ContraHarmonicMean(Double[] values, int order);
    public static double ContraHarmonicMean(Double[] values);
    [ExtensionAttribute]
public static double StandardDeviation(Double[] values, bool unbiased);
    [ExtensionAttribute]
public static double StandardDeviation(Single[] values);
    [ExtensionAttribute]
public static double StandardDeviation(Double[] values, double mean, bool unbiased);
    [ExtensionAttribute]
public static float StandardDeviation(Single[] values, float mean);
    [ExtensionAttribute]
public static double StandardDeviation(Int32[] values, double mean);
    public static double StandardError(int samples, double standardDeviation);
    public static double StandardError(Double[] values);
    [ExtensionAttribute]
public static double Variance(Double[] values);
    [ExtensionAttribute]
public static double Variance(Double[] values, bool unbiased);
    [ExtensionAttribute]
public static double Variance(Int32[] values);
    [ExtensionAttribute]
public static double Variance(Int32[] values, bool unbiased);
    [ExtensionAttribute]
public static double Variance(Single[] values);
    [ExtensionAttribute]
public static double Variance(Double[] values, double mean);
    [ExtensionAttribute]
public static double Variance(Double[] values, double mean, bool unbiased);
    [ExtensionAttribute]
public static double Variance(Int32[] values, double mean, bool unbiased);
    [ExtensionAttribute]
public static float Variance(Single[] values, float mean);
    public static double PooledStandardDeviation(bool unbiased, Double[][] samples);
    public static double PooledStandardDeviation(Double[][] samples);
    public static double PooledStandardDeviation(Int32[] sizes, Double[] variances, bool unbiased);
    public static double PooledVariance(Double[][] samples);
    public static double PooledVariance(bool unbiased, Double[][] samples);
    public static double PooledVariance(Int32[] sizes, Double[] variances, bool unbiased);
    [ExtensionAttribute]
public static T Mode(T[] values);
    [ExtensionAttribute]
public static T Mode(T[] values, Int32& count);
    [ExtensionAttribute]
public static T Mode(T[] values, bool inPlace, bool alreadySorted);
    [ExtensionAttribute]
public static T Mode(T[] values, Int32& count, bool inPlace, bool alreadySorted);
    private static T mode_bag(T[] values, Int32& bestCount);
    private static T mode_sort(T[] values, bool inPlace, bool alreadySorted, Int32& bestCount);
    [ExtensionAttribute]
public static double Covariance(Double[] vector1, Double[] vector2, bool unbiased);
    [ExtensionAttribute]
public static double Covariance(Double[] vector1, double mean1, Double[] vector2, double mean2, bool unbiased);
    [ExtensionAttribute]
public static double Skewness(Double[] values, bool unbiased);
    [ExtensionAttribute]
public static double Skewness(Double[] values, double mean, bool unbiased);
    [ExtensionAttribute]
public static double Kurtosis(Double[] values, bool unbiased);
    [ExtensionAttribute]
public static double Kurtosis(Double[] values, double mean, bool unbiased);
    [ExtensionAttribute]
public static double Entropy(Double[] values, Double[] weights, Func`2<double, double> pdf);
    [ExtensionAttribute]
public static double Entropy(Double[] values, Func`2<double, double> pdf);
    public static double Entropy(bool expected, double predicted);
    public static double Entropy(bool expected, bool predicted);
    [ExtensionAttribute]
public static double WeightedEntropy(Double[] values, Double[] weights, Func`2<double, double> pdf);
    [ExtensionAttribute]
public static double WeightedEntropy(Double[] values, Int32[] weights, Func`2<double, double> pdf);
    [ExtensionAttribute]
public static double Entropy(Double[] values);
    [ExtensionAttribute]
public static double Entropy(Double[] values, double eps);
    [ExtensionAttribute]
public static double Entropy(Double[0...,0...] values, double eps);
    [ExtensionAttribute]
public static double Entropy(Double[0...,0...] values);
    public static double Entropy(Int32[] values, int startValue, int endValue);
    public static double WeightedEntropy(Int32[] values, Double[] weights, int startValue, int endValue);
    public static double WeightedEntropy(Double[] values, Double[] weights, int startValue, int endValue);
    public static double Entropy(IList`1<int> values, int startValue, int endValue);
    public static double WeightedEntropy(IList`1<int> values, IList`1<double> weights, int startValue, int endValue);
    public static double Entropy(Int32[] values, IntRange valueRange);
    public static double WeightedEntropy(Int32[] values, Double[] weights, int classes);
    public static double WeightedEntropy(Double[] values, Double[] weights, int classes);
    public static double Entropy(Int32[] values, int classes);
    public static double Entropy(IList`1<int> values, int classes);
    public static double WeightedEntropy(IList`1<int> values, IList`1<double> weights, int classes);
    [ExtensionAttribute]
public static double Median(Double[] values, bool alreadySorted, QuantileMethod type, bool inPlace);
    [ExtensionAttribute]
public static double Median(Int32[] values, bool alreadySorted, QuantileMethod type, bool inPlace);
    [ExtensionAttribute]
public static double Quartiles(Double[] values, DoubleRange& range, bool alreadySorted, QuantileMethod type, bool inPlace);
    [ExtensionAttribute]
public static double Quartiles(Double[] values, Double& q1, Double& q3, bool alreadySorted, QuantileMethod type, bool inPlace);
    [ExtensionAttribute]
public static double LowerQuartile(Double[] values, bool alreadySorted, QuantileMethod type, bool inPlace);
    [ExtensionAttribute]
public static double UpperQuartile(Double[] values, bool alreadySorted, QuantileMethod type, bool inPlace);
    [ExtensionAttribute]
public static double Quantile(Double[] values, double probabilities, bool alreadySorted, QuantileMethod type, bool inPlace);
    [ExtensionAttribute]
public static Double[] Quantiles(Double[] values, Double[] probabilities, bool alreadySorted, QuantileMethod type, bool inPlace);
    private static Double[] Q1(Double[] x, Double[] p, bool alreadySorted, Double[] result);
    private static double Q1(Double[] x, double p);
    private static Double[] Q2(Double[] x, Double[] p, bool alreadySorted, Double[] result);
    private static double Q2(Double[] x, double p);
    private static T[] Q3(T[] x, Double[] p, bool alreadySorted, T[] result);
    private static T Q3(T[] x, double p, double lowThreshold);
    private static Double[] Q4(Double[] x, Double[] p, bool alreadySorted, Double[] result);
    private static double Q4(Double[] x, double pj, double lowThreshold);
    private static Double[] Q5(Double[] x, Double[] p, bool alreadySorted, Double[] result);
    private static double Q5(Double[] x, double p, double lowThreshold, double highThreshold);
    private static Double[] Q6(Double[] x, Double[] p, bool alreadySorted, Double[] result);
    private static double Q6(Double[] x, double p, double lowThreshold, double highThreshold);
    private static Double[] Q7(Double[] x, Double[] p, bool alreadySorted, Double[] result);
    private static double Q7(Double[] x, double p);
    private static Double[] Q8(Double[] x, Double[] p, bool alreadySorted, Double[] result);
    private static double Q8(Double[] x, double p, double lowThreshold, double highThreshold);
    private static Double[] Q9(Double[] x, Double[] p, bool alreadySorted, Double[] result);
    private static double Q9(Double[] x, double p, double lowThreshold, double highThreshold);
    [ExtensionAttribute]
public static double ExponentialWeightedMean(Double[] values, double alpha);
    [ExtensionAttribute]
public static double ExponentialWeightedMean(Double[] values, int window, double alpha);
    [ExtensionAttribute]
public static double ExponentialWeightedVariance(Double[] values, double alpha, bool unbiased);
    [ExtensionAttribute]
public static double ExponentialWeightedVariance(Double[] values, int window, double alpha, bool unbiased);
    [ExtensionAttribute]
public static double WeightedMean(Double[] values, Double[] weights);
    [ExtensionAttribute]
public static double WeightedMean(Double[] values, Int32[] weights);
    [ExtensionAttribute]
public static double WeightedStandardDeviation(Double[] values, Double[] weights);
    [ExtensionAttribute]
public static double WeightedStandardDeviation(Double[] values, Double[] weights, WeightType weightType);
    [ExtensionAttribute]
public static double WeightedStandardDeviation(Double[] values, Double[] weights, bool unbiased, WeightType weightType);
    [ExtensionAttribute]
public static double WeightedStandardDeviation(Double[] values, Double[] weights, double mean);
    [ExtensionAttribute]
public static double WeightedStandardDeviation(Double[] values, Double[] weights, double mean, bool unbiased, WeightType weightType);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Double[] weights);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Double[] weights, WeightType weightType);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Double[] weights, bool unbiased);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Double[] weights, bool unbiased, WeightType weightType);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Double[] weights, double mean);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Double[] weights, double mean, bool unbiased, WeightType weightType);
    [ExtensionAttribute]
public static double WeightedStandardDeviation(Double[] values, Int32[] weights);
    [ExtensionAttribute]
public static double WeightedStandardDeviation(Double[] values, Int32[] weights, double mean);
    [ExtensionAttribute]
public static double WeightedStandardDeviation(Double[] values, Int32[] weights, double mean, bool unbiased);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Int32[] weights);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Int32[] weights, bool unbiased);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Int32[] weights, double mean);
    [ExtensionAttribute]
public static double WeightedVariance(Double[] values, Int32[] weights, double mean, bool unbiased);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[][] matrix, Double[] weights);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[][] matrix, Double[] weights, Double[] means);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[][] matrix, Double[] weights, Double[] means, bool unbiased, WeightType weightType);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[0...,0...] matrix, Double[] weights);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[0...,0...] matrix, Double[] weights, WeightType weightType);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[0...,0...] matrix, Double[] weights, Double[] means);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[0...,0...] matrix, Double[] weights, Double[] means, WeightType weightType);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[0...,0...] matrix, Double[] weights, Double[] means, bool unbiased, WeightType weightType);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[][] matrix, Int32[] weights);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[][] matrix, Int32[] weights, Double[] means);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[][] matrix, Int32[] weights, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[0...,0...] matrix, Int32[] weights);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[0...,0...] matrix, Int32[] weights, Double[] means);
    [ExtensionAttribute]
public static Double[] WeightedVariance(Double[0...,0...] matrix, Int32[] weights, Double[] means, bool unbiased);
    [ExtensionAttribute]
public static T WeightedMode(T[] values, Double[] weights, bool inPlace, bool alreadySorted);
    [ExtensionAttribute]
public static T WeightedMode(T[] values, Int32[] weights, bool inPlace, bool alreadySorted);
    private static T weighted_mode_bag(T[] values, Double[] weights);
    private static T weighted_mode_sort(T[] values, Double[] weights, bool inPlace, bool alreadySorted);
    private static T weighted_mode_bag(T[] values, Int32[] weights);
    private static T weighted_mode_sort(T[] values, Int32[] weights, bool inPlace, bool alreadySorted);
    [ExtensionAttribute]
public static double WeightedMax(Double[] values, Double[] weights, Int32& imax, bool alreadySorted);
    [ExtensionAttribute]
public static double WeightedMin(Double[] values, Double[] weights, Int32& imin, bool alreadySorted);
    [ExtensionAttribute]
public static double WeightedMax(Double[] values, Int32[] weights, Int32& imax, bool alreadySorted);
    [ExtensionAttribute]
public static double WeightedMin(Double[] values, Int32[] weights, Int32& imin, bool alreadySorted);
    private static void Validate(Double[] vector, int window, double alpha);
}
public interface Accord.Statistics.Models.IConvergenceLearning {
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public abstract virtual double get_Tolerance();
    public abstract virtual void set_Tolerance(double value);
    public abstract virtual int get_Iterations();
    public abstract virtual void set_Iterations(int value);
    public abstract virtual int get_MaxIterations();
    public abstract virtual void set_MaxIterations(int value);
    public abstract virtual int get_CurrentIteration();
    public abstract virtual bool get_HasConverged();
}
public enum Accord.Statistics.QuantileMethod : Enum {
    public int value__;
    public static QuantileMethod Default;
    public static QuantileMethod R;
    public static QuantileMethod Maple;
    public static QuantileMethod Type1;
    public static QuantileMethod Type2;
    public static QuantileMethod Type3;
    public static QuantileMethod Type4;
    public static QuantileMethod Type5;
    public static QuantileMethod Type6;
    public static QuantileMethod Type7;
    public static QuantileMethod Type8;
    public static QuantileMethod Type9;
}
public enum Accord.Statistics.WeightType : Enum {
    public int value__;
    public static WeightType None;
    public static WeightType Repetition;
    public static WeightType Fraction;
    public static WeightType Automatic;
}
[ObsoleteAttribute("Please use Accord.Math.Normal instead.")]
public class AForge.Math.Gaussian : object {
    private double sigma;
    private double sqrSigma;
    public double Sigma { get; public set; }
    public Gaussian(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    [ObsoleteAttribute("Please use Normal.Gaussian instead.")]
public double Function(double x);
    [ObsoleteAttribute("Please use Normal.Gaussian2D instead.")]
public double Function2D(double x, double y);
    [ObsoleteAttribute("Please use Normal.Kernel instead.")]
public Double[] Kernel(int size);
    [ObsoleteAttribute("Please use Normal.Kernel2D instead.")]
public Double[0...,0...] Kernel2D(int size);
}
