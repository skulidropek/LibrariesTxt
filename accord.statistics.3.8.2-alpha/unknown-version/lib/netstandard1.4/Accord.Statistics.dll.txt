[SerializableAttribute]
public abstract class Accord.MachineLearning.BinaryClassifierBase`1 : ClassifierBase`2<TInput, bool> {
    private sealed virtual override double Accord.MachineLearning.IClassifier<TInput,System.Double>.Decide(TInput input);
    private sealed virtual override int Accord.MachineLearning.IClassifier<TInput,System.Int32>.Decide(TInput input);
    private sealed virtual override int Accord.MachineLearning.IMulticlassClassifier<TInput>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IMulticlassClassifier<TInput>.Decide(TInput[] input);
    private sealed virtual override Boolean[] Accord.MachineLearning.IClassifier<TInput,System.Boolean[]>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IClassifier<TInput,System.Int32[]>.Decide(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<TInput,System.Double>.Decide(TInput[] input);
    private sealed virtual override Int32[] Accord.MachineLearning.IClassifier<TInput,System.Int32>.Decide(TInput[] input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.IClassifier<TInput,System.Boolean[]>.Decide(TInput[] input);
    private sealed virtual override Double[][] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput[] input);
    private sealed virtual override Int32[][] Accord.MachineLearning.IClassifier<TInput,System.Int32[]>.Decide(TInput[] input);
    public sealed virtual Boolean[] Decide(TInput input, Boolean[] result);
    private sealed virtual override Int32[] Accord.MachineLearning.IMultilabelClassifier<TInput,System.Int32[]>.Decide(TInput input, Int32[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelClassifier<TInput,System.Double[]>.Decide(TInput input, Double[] result);
    private sealed virtual override Int32[] Accord.MachineLearning.IClassifier<TInput,System.Int32>.Decide(TInput[] input, Int32[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<TInput,System.Double>.Decide(TInput[] input, Double[] result);
    private sealed virtual override Boolean[][] Accord.MachineLearning.IClassifier<TInput,System.Boolean[]>.Decide(TInput[] input, Boolean[][] result);
    private sealed virtual override Int32[][] Accord.MachineLearning.IClassifier<TInput,System.Int32[]>.Decide(TInput[] input, Int32[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput[] input, Double[][] result);
    private sealed virtual override int Accord.MachineLearning.ICovariantTransform<TInput,System.Int32>.Transform(TInput input);
    private sealed virtual override double Accord.MachineLearning.ICovariantTransform<TInput,System.Double>.Transform(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<TInput,System.Double>.Transform(TInput[] input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<TInput,System.Double[]>.Transform(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.ICovariantTransform<TInput,System.Int32>.Transform(TInput[] input);
    private sealed virtual override Double[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Double[]>.Transform(TInput[] input);
    private sealed virtual override Boolean[] Accord.MachineLearning.ICovariantTransform<TInput,System.Boolean[]>.Transform(TInput input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Boolean[]>.Transform(TInput[] input);
    private sealed virtual override Int32[] Accord.MachineLearning.ICovariantTransform<TInput,System.Int32[]>.Transform(TInput input);
    private sealed virtual override Int32[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Int32[]>.Transform(TInput[] input);
    public virtual Boolean[] Transform(TInput input, Boolean[] result);
    public virtual Int32[] Transform(TInput input, Int32[] result);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Int32[] Transform(TInput[] input, Int32[] result);
    public virtual Double[] Transform(TInput[] input, Double[] result);
    public virtual Boolean[][] Transform(TInput[] input, Boolean[][] result);
    public virtual Int32[][] Transform(TInput[] input, Int32[][] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
    public sealed virtual IMulticlassClassifier`1<TInput> ToMulticlass();
    public sealed virtual IMulticlassClassifier`2<TInput, T> ToMulticlass();
    public sealed virtual IMultilabelClassifier`1<TInput> ToMultilabel();
}
public abstract class Accord.MachineLearning.BinaryLearningBase`2 : object {
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private TModel <Model>k__BackingField;
    public CancellationToken Token { get; public set; }
    public TModel Model { get; public set; }
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public virtual void set_Token(CancellationToken value);
    [CompilerGeneratedAttribute]
public TModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(TModel value);
    public TModel Learn(TInput[] x, Double[] y, Double[] weights);
    public sealed virtual TModel Learn(TInput[] x, Int32[] y, Double[] weights);
    public sealed virtual TModel Learn(TInput[] x, Int32[][] y, Double[] weights);
    public sealed virtual TModel Learn(TInput[] x, Boolean[][] y, Double[] weights);
    public abstract virtual TModel Learn(TInput[] x, Boolean[] y, Double[] weights);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.BinaryLikelihoodClassifierBase`1 : BinaryScoreClassifierBase`1<TInput> {
    internal static double PROBABILITY_DECISION_THRESHOLD;
    internal double LOGLIKELIHOOD_DECISION_THRESHOLD;
    public abstract virtual Double[] LogLikelihood(TInput[] input, Double[] result);
    public virtual Double[] Score(TInput[] input, Double[] result);
    private sealed virtual override double Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.LogLikelihood(TInput input, int classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.LogLikelihood(TInput[] input, int classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.LogLikelihood(TInput[] input, int classIndex, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.LogLikelihood(TInput[] input, Int32[] classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.LogLikelihood(TInput[] input, Int32[] classIndex, Double[] result);
    public sealed virtual double LogLikelihood(TInput input);
    public sealed virtual Double[] LogLikelihoods(TInput input);
    public sealed virtual Double[] LogLikelihood(TInput[] input);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double[] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[][] result);
    public sealed virtual double LogLikelihood(TInput input, Boolean& decision);
    public sealed virtual double LogLikelihood(TInput input, Double& decision);
    public sealed virtual double LogLikelihood(TInput input, Int32& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Boolean& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Boolean[]& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32[]& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double[]& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Boolean& decision, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double& decision, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32& decision, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Boolean[]& decision, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double[]& decision, Double[] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Int32[]& decision);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Double[]& decision);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Boolean[]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Boolean[]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Int32[]>.LogLikelihoods(TInput[] input, Int32[][]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Boolean[][]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[][]& decision);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Boolean[]& decision, Double[] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Double[]& decision, Double[] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Boolean[][]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[][]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[][]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Boolean[]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[]& decision, Double[][] result);
    public sealed virtual double Probability(TInput input);
    private sealed virtual override double Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.Probability(TInput input, int classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.Probability(TInput[] input, int classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.Probability(TInput[] input, int classIndex, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.Probability(TInput[] input, Int32[] classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelLikelihoodClassifier<TInput>.Probability(TInput[] input, Int32[] classIndex, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input);
    public sealed virtual Double[] Probability(TInput[] input);
    public sealed virtual Double[][] Probabilities(TInput[] input);
    public sealed virtual Double[] Probabilities(TInput input, Double[] result);
    public virtual Double[] Probability(TInput[] input, Double[] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[][] result);
    public sealed virtual double Probability(TInput input, Boolean& decision);
    public sealed virtual double Probability(TInput input, Double& decision);
    public sealed virtual double Probability(TInput input, Int32& decision);
    public sealed virtual Double[] Probabilities(TInput input, Boolean& decision);
    public sealed virtual Double[] Probabilities(TInput input, Int32& decision);
    public sealed virtual Double[] Probabilities(TInput input, Double& decision);
    public sealed virtual Double[] Probabilities(TInput input, Boolean[]& decision);
    public sealed virtual Double[] Probabilities(TInput input, Int32[]& decision);
    public sealed virtual Double[] Probabilities(TInput input, Double[]& decision);
    public sealed virtual Double[] Probabilities(TInput input, Boolean& decision, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input, Double& decision, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input, Int32& decision, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input, Boolean[]& decision, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input, Double[]& decision, Double[] result);
    public sealed virtual Double[] Probability(TInput[] input, Int32[]& decision);
    public sealed virtual Double[] Probability(TInput[] input, Double[]& decision);
    public sealed virtual Double[] Probability(TInput[] input, Boolean[]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Boolean[]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[][]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Boolean[][]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[][]& decision);
    public sealed virtual Double[] Probability(TInput[] input, Boolean[]& decision, Double[] result);
    public sealed virtual Double[] Probability(TInput[] input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] Probability(TInput[] input, Double[]& decision, Double[] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Boolean[][]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[][]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[][]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Boolean[]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[]& decision, Double[][] result);
    private sealed virtual override double Accord.MachineLearning.ICovariantTransform<TInput,System.Double>.Transform(TInput input);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
    public virtual Double[] Transform(TInput[] input, Double[] result);
    private sealed virtual override int Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.Decide(TInput[] input);
    public sealed virtual IMulticlassLikelihoodClassifier`1<TInput> ToMulticlass();
    public sealed virtual IMulticlassLikelihoodClassifier`2<TInput, T> ToMulticlass();
    public sealed virtual IMultilabelLikelihoodClassifier`1<TInput> ToMultilabel();
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.BinaryScoreClassifierBase`1 : BinaryClassifierBase`1<TInput> {
    internal static double SCORE_DECISION_THRESHOLD;
    internal static int CLASS_POSITIVE;
    internal static int CLASS_NEGATIVE;
    public abstract virtual Double[] Score(TInput[] input, Double[] result);
    public virtual Boolean[] Decide(TInput[] input, Boolean[] result);
    public virtual bool Decide(TInput input);
    private sealed virtual override double Accord.MachineLearning.IMultilabelScoreClassifier<TInput>.Score(TInput input, int classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelScoreClassifier<TInput>.Score(TInput[] input, Int32[] classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelScoreClassifier<TInput>.Score(TInput[] input, int classIndex);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelScoreClassifier<TInput>.Score(TInput[] input, Int32[] classIndex, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelScoreClassifier<TInput>.Score(TInput[] input, int classIndex, Double[] result);
    public sealed virtual double Score(TInput input);
    public sealed virtual Double[] Scores(TInput input);
    public sealed virtual Double[] Score(TInput[] input);
    public sealed virtual Double[][] Scores(TInput[] input);
    public sealed virtual Double[] Scores(TInput input, Double[] result);
    public sealed virtual Double[][] Scores(TInput[] input, Double[][] result);
    public sealed virtual double Score(TInput input, Boolean& decision);
    private sealed virtual override double Accord.MachineLearning.IMulticlassOutScoreClassifier<TInput,System.Double>.Score(TInput input, Double& decision);
    private sealed virtual override double Accord.MachineLearning.IMulticlassOutScoreClassifier<TInput,System.Int32>.Score(TInput input, Int32& decision);
    public sealed virtual Double[] Scores(TInput input, Boolean& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelOutScoreClassifier<TInput,System.Int32>.Scores(TInput input, Int32& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelOutScoreClassifier<TInput,System.Double>.Scores(TInput input, Double& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Boolean[]>.Scores(TInput input, Boolean[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Int32[]>.Scores(TInput input, Int32[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Double[]>.Scores(TInput input, Double[]& decision);
    public sealed virtual Double[] Scores(TInput input, Boolean& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelOutScoreClassifier<TInput,System.Double>.Scores(TInput input, Double& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelOutScoreClassifier<TInput,System.Int32>.Scores(TInput input, Int32& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Boolean[]>.Scores(TInput input, Boolean[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Int32[]>.Scores(TInput input, Int32[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Double[]>.Scores(TInput input, Double[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassScoreClassifierBase<TInput,System.Int32>.Score(TInput[] input, Int32[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassScoreClassifierBase<TInput,System.Double>.Score(TInput[] input, Double[]& decision);
    public sealed virtual Double[] Score(TInput[] input, Boolean[]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Int32>.Scores(TInput[] input, Int32[]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Double>.Scores(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] Scores(TInput[] input, Boolean[]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Int32[]>.Scores(TInput[] input, Int32[][]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Boolean[]>.Scores(TInput[] input, Boolean[][]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Double[]>.Scores(TInput[] input, Double[][]& decision);
    public sealed virtual Double[] Score(TInput[] input, Boolean[]& decision, Double[] result);
    public sealed virtual Double[] Score(TInput[] input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] Score(TInput[] input, Double[]& decision, Double[] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Boolean[]>.Scores(TInput[] input, Boolean[][]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Int32[]>.Scores(TInput[] input, Int32[][]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Double[]>.Scores(TInput[] input, Double[][]& decision, Double[][] result);
    public sealed virtual Double[][] Scores(TInput[] input, Boolean[]& decision, Double[][] result);
    public sealed virtual Double[][] Scores(TInput[] input, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] Scores(TInput[] input, Double[]& decision, Double[][] result);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
    public virtual Double[] Transform(TInput[] input, Double[] result);
    private sealed virtual override int Accord.MachineLearning.IMulticlassScoreClassifier<TInput>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IMulticlassScoreClassifier<TInput>.Decide(TInput[] input);
    public sealed virtual IMulticlassScoreClassifier`1<TInput> ToMulticlass();
    public sealed virtual IMulticlassScoreClassifier`2<TInput, T> ToMulticlass();
    public sealed virtual IMultilabelScoreClassifier`1<TInput> ToMultilabel();
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.ClassifierBase`2 : TransformBase`2<TInput, TClasses> {
    [CompilerGeneratedAttribute]
private int <NumberOfClasses>k__BackingField;
    public int NumberOfClasses { get; public set; }
    [CompilerGeneratedAttribute]
public virtual int get_NumberOfClasses();
    [CompilerGeneratedAttribute]
public virtual void set_NumberOfClasses(int value);
    public abstract virtual TClasses Decide(TInput input);
    public sealed virtual TClasses[] Decide(TInput[] input);
    public virtual TClasses[] Decide(TInput[] input, TClasses[] result);
    public virtual TClasses Transform(TInput input);
    public virtual TClasses[] Transform(TInput[] input, TClasses[] result);
    internal T[] create(TInput input);
    internal T[][] create(TInput[] input);
    internal T[] createOrReuse(TInput input, T[] decision);
    internal T[][] createOrReuse(TInput[] input, T[][] decision);
    internal T[] createOrReuse(TInput[] input, T[] decision);
}
public interface Accord.MachineLearning.IDescriptiveLearning`2 {
    public abstract virtual TModel Learn(TInput[] x);
}
public interface Accord.MachineLearning.ISupervisedBinaryLearning`1 {
}
public interface Accord.MachineLearning.ISupervisedBinaryLearning`2 {
}
public interface Accord.MachineLearning.ISupervisedLearning`3 {
    public CancellationToken Token { get; public set; }
    public abstract virtual CancellationToken get_Token();
    public abstract virtual void set_Token(CancellationToken value);
    public abstract virtual TModel Learn(TInput[] x, TOutput[] y, Double[] weights);
}
public interface Accord.MachineLearning.ISupervisedMulticlassLearning`1 {
}
public interface Accord.MachineLearning.ISupervisedMulticlassLearning`2 {
}
public interface Accord.MachineLearning.ISupervisedMultilabelLearning`1 {
}
public interface Accord.MachineLearning.ISupervisedMultilabelLearning`2 {
}
public interface Accord.MachineLearning.IUnsupervisedLearning`3 {
    public CancellationToken Token { get; public set; }
    public abstract virtual CancellationToken get_Token();
    public abstract virtual void set_Token(CancellationToken value);
    public abstract virtual TModel Learn(TInput[] x, Double[] weights);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.LikelihoodTaggerBase`1 : ScoreTaggerBase`1<TInput> {
    public abstract virtual Double[] LogLikelihood(TInput[][] sequences, Double[] result);
    public abstract virtual Double[] LogLikelihood(TInput[][] sequences, Int32[][]& decision, Double[] result);
    public abstract virtual Double[][] LogLikelihoods(TInput[] sequence, Double[][] result);
    public abstract virtual Double[][] LogLikelihoods(TInput[] sequence, Int32[]& decision, Double[][] result);
    public sealed virtual double Probability(TInput[] sequence);
    public sealed virtual double Probability(TInput[] sequence, Int32[]& decision);
    public sealed virtual Double[] Probability(TInput[][] sequences);
    public sealed virtual Double[] Probability(TInput[][] sequences, Int32[][]& decision);
    public virtual Double[] Probability(TInput[][] sequences, Double[] result);
    public virtual Double[] Probability(TInput[][] sequences, Int32[][]& decision, Double[] result);
    public sealed virtual double LogLikelihood(TInput[] sequence);
    public sealed virtual double LogLikelihood(TInput[] sequence, Int32[]& decision);
    public sealed virtual Double[] LogLikelihood(TInput[][] sequences);
    public sealed virtual Double[] LogLikelihood(TInput[][] sequences, Int32[][]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] sequence);
    public virtual Double[][] Probabilities(TInput[] sequence, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] sequence, Int32[]& decision);
    public virtual Double[][] Probabilities(TInput[] sequence, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] sequence);
    public sealed virtual Double[][] LogLikelihoods(TInput[] sequence, Int32[]& decision);
    public sealed virtual Double[][][] Probabilities(TInput[][] sequences);
    public virtual Double[][][] Probabilities(TInput[][] sequences, Double[][][] result);
    public sealed virtual Double[][][] Probabilities(TInput[][] sequences, Int32[][]& decision);
    public virtual Double[][][] Probabilities(TInput[][] sequences, Int32[][]& decision, Double[][][] result);
    public sealed virtual Double[][][] LogLikelihoods(TInput[][] sequences);
    public virtual Double[][][] LogLikelihoods(TInput[][] sequences, Double[][][] result);
    public virtual Double[][][] LogLikelihoods(TInput[][] sequences, Int32[][]& decision, Double[][][] result);
    public sealed virtual Double[][][] LogLikelihoods(TInput[][] sequences, Int32[][]& decision);
    public virtual Double[][][] Scores(TInput[][] sequences, Double[][][] result);
    public virtual Double[][][] Scores(TInput[][] sequences, Int32[][]& decision, Double[][][] result);
    private sealed virtual override double Accord.MachineLearning.ICovariantTransform<TInput[],System.Double>.Transform(TInput[] input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<TInput[],System.Double>.Transform(TInput[][] input);
    public sealed virtual Double[] Transform(TInput[][] input, Double[] result);
}
[SerializableAttribute]
public class Accord.MachineLearning.MinimumMeanDistanceClassifier : MulticlassScoreClassifierBase`1<Double[]> {
    [NonSerializedAttribute]
private CancellationToken token;
    private Double[][] means;
    private IDistance`1<Double[]> distance;
    public CancellationToken Token { get; public set; }
    public Double[][] Means { get; public set; }
    public IDistance`1<Double[]> Function { get; public set; }
    public MinimumMeanDistanceClassifier(Double[][] inputs, Int32[] outputs);
    public MinimumMeanDistanceClassifier(IDistance`1<Double[]> distance, Double[][] inputs, Int32[] outputs);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public Double[][] get_Means();
    public void set_Means(Double[][] value);
    public IDistance`1<Double[]> get_Function();
    public void set_Function(IDistance`1<Double[]> value);
    [ObsoleteAttribute("Please use Decide instead.")]
public int Compute(Double[] input, Double[]& distances);
    [ObsoleteAttribute("Please use Decide instead.")]
public int Compute(Double[] input);
    public virtual Double[] Scores(Double[] input, Double[] result);
    public virtual double Score(Double[] input, int classIndex);
    public sealed virtual MinimumMeanDistanceClassifier Learn(Double[][] x, Int32[] y, Double[] weights);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.MulticlassClassifierBase : MulticlassClassifierBase`1<Double[]> {
    public virtual int Decide(Int32[] input);
    public virtual int Decide(Single[] input);
    public sealed virtual Int32[] Decide(Int32[][] input);
    public sealed virtual Int32[] Decide(Single[][] input);
    private sealed virtual override double Accord.MachineLearning.IClassifier<System.Int32[],System.Double>.Decide(Int32[] input);
    private sealed virtual override double Accord.MachineLearning.IClassifier<System.Single[],System.Double>.Decide(Single[] input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<System.Int32[],System.Double>.Decide(Int32[][] input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<System.Single[],System.Double>.Decide(Single[][] input);
    private sealed virtual override Double[][] Accord.MachineLearning.IClassifier<System.Int32[],System.Double[]>.Decide(Int32[][] input);
    private sealed virtual override Double[][] Accord.MachineLearning.IClassifier<System.Single[],System.Double[]>.Decide(Single[][] input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.IClassifier<System.Int32[],System.Boolean[]>.Decide(Int32[][] input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.IClassifier<System.Single[],System.Boolean[]>.Decide(Single[][] input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<System.Int32[],System.Double[]>.Decide(Int32[] input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<System.Single[],System.Double[]>.Decide(Single[] input);
    private sealed virtual override Boolean[] Accord.MachineLearning.IClassifier<System.Int32[],System.Boolean[]>.Decide(Int32[] input);
    private sealed virtual override Boolean[] Accord.MachineLearning.IClassifier<System.Single[],System.Boolean[]>.Decide(Single[] input);
    public sealed virtual Int32[] Decide(Int32[][] input, Int32[] result);
    public sealed virtual Double[] Decide(Single[] input, Double[] result);
    public sealed virtual Double[] Decide(Int32[] input, Double[] result);
    public sealed virtual Boolean[] Decide(Single[] input, Boolean[] result);
    public sealed virtual Boolean[] Decide(Int32[] input, Boolean[] result);
    public sealed virtual Int32[] Decide(Single[][] input, Int32[] result);
    public sealed virtual Int32[][] Decide(Single[][] input, Int32[][] result);
    public sealed virtual Double[] Decide(Int32[][] input, Double[] result);
    public sealed virtual Double[] Decide(Single[][] input, Double[] result);
    public sealed virtual Int32[][] Decide(Int32[][] input, Int32[][] result);
    public sealed virtual Double[][] Decide(Single[][] input, Double[][] result);
    public sealed virtual Double[][] Decide(Int32[][] input, Double[][] result);
    public sealed virtual Boolean[][] Decide(Single[][] input, Boolean[][] result);
    public sealed virtual Boolean[][] Decide(Int32[][] input, Boolean[][] result);
    private sealed virtual override Int32[] Accord.MachineLearning.IClassifier<System.Single[],System.Int32[]>.Decide(Single[] input);
    private sealed virtual override Int32[] Accord.MachineLearning.IClassifier<System.Int32[],System.Int32[]>.Decide(Int32[] input);
    public sealed virtual Int32[] Decide(Single[] input, Int32[] result);
    public sealed virtual Int32[] Decide(Int32[] input, Int32[] result);
    private sealed virtual override Int32[][] Accord.MachineLearning.IClassifier<System.Single[],System.Int32[]>.Decide(Single[][] input);
    private sealed virtual override Int32[][] Accord.MachineLearning.IClassifier<System.Int32[],System.Int32[]>.Decide(Int32[][] input);
    public int Transform(Int32[] input);
    public Double[] Transform(Int32[] input, Double[] result);
    public sealed virtual Double[][] Transform(Int32[][] input, Double[][] result);
    public sealed virtual int Transform(Single[] input);
    public int Transform(Single[] input, int result);
    public sealed virtual Int32[] Transform(Single[][] input);
    public sealed virtual Int32[] Transform(Single[][] input, Int32[] result);
    public Double[] Transform(Single[] input, Double[] result);
    public sealed virtual Double[][] Transform(Single[][] input, Double[][] result);
    public Boolean[] Transform(Single[] input, Boolean[] result);
    public sealed virtual Boolean[][] Transform(Single[][] input, Boolean[][] result);
    public Int32[] Transform(Single[] input, Int32[] result);
    public sealed virtual Int32[][] Transform(Single[][] input, Int32[][] result);
    public sealed virtual Int32[][] Transform(Int32[][] input, Int32[][] result);
    public Int32[] Transform(Int32[] input, Int32[] result);
    public sealed virtual Int32[] Transform(Int32[][] input, Int32[] result);
    public sealed virtual Boolean[][] Transform(Int32[][] input, Boolean[][] result);
    public sealed virtual Double[] Transform(Int32[][] input, Double[] result);
    public sealed virtual Double[] Transform(Single[][] input, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Double[]>.Transform(Int32[] input);
    private sealed virtual override Double[][] Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Double[]>.Transform(Int32[][] input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<System.Single[],System.Double[]>.Transform(Single[] input);
    private sealed virtual override Double[][] Accord.MachineLearning.ICovariantTransform<System.Single[],System.Double[]>.Transform(Single[][] input);
    private sealed virtual override Boolean[] Accord.MachineLearning.ICovariantTransform<System.Single[],System.Boolean[]>.Transform(Single[] input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.ICovariantTransform<System.Single[],System.Boolean[]>.Transform(Single[][] input);
    private sealed virtual override Int32[] Accord.MachineLearning.ICovariantTransform<System.Single[],System.Int32[]>.Transform(Single[] input);
    private sealed virtual override Int32[][] Accord.MachineLearning.ICovariantTransform<System.Single[],System.Int32[]>.Transform(Single[][] input);
    private sealed virtual override Int32[] Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Int32[]>.Transform(Int32[] input);
    private sealed virtual override Int32[][] Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Int32[]>.Transform(Int32[][] input);
    private sealed virtual override Boolean[] Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Boolean[]>.Transform(Int32[] input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Boolean[]>.Transform(Int32[][] input);
    private sealed virtual override int Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Int32>.Transform(Int32[] input);
    private sealed virtual override Int32[] Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Int32>.Transform(Int32[][] input);
    private sealed virtual override double Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Double>.Transform(Int32[] input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<System.Int32[],System.Double>.Transform(Int32[][] input);
    private sealed virtual override double Accord.MachineLearning.ICovariantTransform<System.Single[],System.Double>.Transform(Single[] input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<System.Single[],System.Double>.Transform(Single[][] input);
    private sealed virtual override IMultilabelClassifier`1<Int32[]> Accord.MachineLearning.IMulticlassClassifier<System.Int32[]>.ToMultilabel();
    private sealed virtual override IMultilabelClassifier`1<Single[]> Accord.MachineLearning.IMulticlassClassifier<System.Single[]>.ToMultilabel();
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.MulticlassClassifierBase`1 : ClassifierBase`2<TInput, int> {
    private sealed virtual override double Accord.MachineLearning.IClassifier<TInput,System.Double>.Decide(TInput input);
    private sealed virtual override Boolean[] Accord.MachineLearning.IClassifier<TInput,System.Boolean[]>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IClassifier<TInput,System.Int32[]>.Decide(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<TInput,System.Double>.Decide(TInput[] input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.IClassifier<TInput,System.Boolean[]>.Decide(TInput[] input);
    private sealed virtual override Double[][] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput[] input);
    private sealed virtual override Int32[][] Accord.MachineLearning.IClassifier<TInput,System.Int32[]>.Decide(TInput[] input);
    public sealed virtual Boolean[] Decide(TInput input, Boolean[] result);
    public sealed virtual Int32[] Decide(TInput input, Int32[] result);
    public sealed virtual Double[] Decide(TInput input, Double[] result);
    public sealed virtual Double[] Decide(TInput[] input, Double[] result);
    private sealed virtual override Boolean[][] Accord.MachineLearning.IClassifier<TInput,System.Boolean[]>.Decide(TInput[] input, Boolean[][] result);
    private sealed virtual override Int32[][] Accord.MachineLearning.IClassifier<TInput,System.Int32[]>.Decide(TInput[] input, Int32[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput[] input, Double[][] result);
    private sealed virtual override double Accord.MachineLearning.ICovariantTransform<TInput,System.Double>.Transform(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<TInput,System.Double>.Transform(TInput[] input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<TInput,System.Double[]>.Transform(TInput input);
    private sealed virtual override Double[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Double[]>.Transform(TInput[] input);
    private sealed virtual override Boolean[] Accord.MachineLearning.ICovariantTransform<TInput,System.Boolean[]>.Transform(TInput input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Boolean[]>.Transform(TInput[] input);
    private sealed virtual override Int32[] Accord.MachineLearning.ICovariantTransform<TInput,System.Int32[]>.Transform(TInput input);
    private sealed virtual override Int32[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Int32[]>.Transform(TInput[] input);
    public virtual Boolean[] Transform(TInput input, Boolean[] result);
    public virtual Int32[] Transform(TInput input, Int32[] result);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Double[] Transform(TInput[] input, Double[] result);
    public virtual Boolean[][] Transform(TInput[] input, Boolean[][] result);
    public virtual Int32[][] Transform(TInput[] input, Int32[][] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
    public sealed virtual IMultilabelClassifier`1<TInput> ToMultilabel();
}
public abstract class Accord.MachineLearning.MulticlassLearningBase`1 : MulticlassLearningBase`2<TModel, Double[]> {
    public virtual TModel Learn(Int32[][] x, Int32[] y, Double[] weights);
    public virtual TModel Learn(Int32[][] x, Int32[][] y, Double[] weights);
    public virtual TModel Learn(Int32[][] x, Boolean[][] y, Double[] weights);
    public virtual TModel Learn(Single[][] x, Int32[] y, Double[] weights);
    public virtual TModel Learn(Single[][] x, Int32[][] y, Double[] weights);
    public virtual TModel Learn(Single[][] x, Boolean[][] y, Double[] weights);
}
public abstract class Accord.MachineLearning.MulticlassLearningBase`2 : object {
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    public CancellationToken Token { get; public set; }
    public TModel Model { get; public set; }
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public virtual void set_Token(CancellationToken value);
    public abstract virtual TModel get_Model();
    public abstract virtual void set_Model(TModel value);
    public abstract virtual TModel Learn(TInput[] x, Int32[] y, Double[] weights);
    public virtual TModel Learn(TInput[] x, Int32[][] y, Double[] weights);
    public virtual TModel Learn(TInput[] x, Boolean[][] y, Double[] weights);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.MulticlassLikelihoodClassifierBase`1 : MulticlassScoreClassifierBase`1<TInput> {
    public virtual double Score(TInput input, int classIndex);
    public virtual double LogLikelihood(TInput input, int classIndex);
    public virtual Double[] LogLikelihoods(TInput input, Int32& decision, Double[] result);
    public virtual Double[] LogLikelihoods(TInput input, Double[] result);
    public sealed virtual double Probability(TInput input, int classIndex);
    public sealed virtual Double[] Probability(TInput[] input, int classIndex);
    public sealed virtual Double[] Probability(TInput[] input, int classIndex, Double[] result);
    public sealed virtual Double[] Probability(TInput[] input, Int32[] classIndex);
    public sealed virtual Double[] Probability(TInput[] input, Int32[] classIndex, Double[] result);
    public virtual Double[] Probabilities(TInput input, Double[] result);
    public virtual Double[] Probabilities(TInput input, Int32& decision, Double[] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Int32[] classIndex);
    public virtual Double[] LogLikelihood(TInput[] input, Int32[] classIndex, Double[] result);
    public Double[] LogLikelihoods(TInput[] input, int classIndex);
    public Double[] LogLikelihoods(TInput[] input, int classIndex, Double[] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, int classIndex);
    public sealed virtual Double[] LogLikelihood(TInput[] input, int classIndex, Double[] result);
    public virtual double LogLikelihood(TInput input);
    public sealed virtual Double[] LogLikelihood(TInput[] input);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[][] result);
    public virtual double LogLikelihood(TInput input, Int32& decision);
    public sealed virtual double LogLikelihood(TInput input, Double& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Boolean[]>.LogLikelihoods(TInput input, Boolean[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Int32[]>.LogLikelihoods(TInput input, Int32[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Double[]>.LogLikelihoods(TInput input, Double[]& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Boolean[]>.LogLikelihoods(TInput input, Boolean[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Int32[]>.LogLikelihoods(TInput input, Int32[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Double[]>.LogLikelihoods(TInput input, Double[]& decision, Double[] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Int32[]& decision);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Int32[]>.LogLikelihoods(TInput[] input, Int32[][]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Boolean[]>.LogLikelihoods(TInput[] input, Boolean[][]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Double[]>.LogLikelihoods(TInput[] input, Double[][]& decision);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Double[]& decision, Double[] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Boolean[]>.LogLikelihoods(TInput[] input, Boolean[][]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Int32[]>.LogLikelihoods(TInput[] input, Int32[][]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Double[]>.LogLikelihoods(TInput[] input, Double[][]& decision, Double[][] result);
    public virtual double Probability(TInput input);
    public sealed virtual Double[] Probability(TInput[] input);
    public sealed virtual Double[] Probability(TInput[] input, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input);
    public sealed virtual Double[][] Probabilities(TInput[] input);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[][] result);
    public virtual double Probability(TInput input, Int32& decision);
    public sealed virtual double Probability(TInput input, Double& decision);
    public sealed virtual Double[] Probabilities(TInput input, Int32& decision);
    public sealed virtual Double[] Probabilities(TInput input, Double& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Boolean[]>.Probabilities(TInput input, Boolean[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Int32[]>.Probabilities(TInput input, Int32[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Double[]>.Probabilities(TInput input, Double[]& decision);
    private double Probability(TInput input, Double[]& decision);
    private double Probability(TInput input, Boolean[]& decision);
    private double Probability(TInput input, Int32[]& decision);
    public sealed virtual Double[] Probabilities(TInput input, Double& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Boolean[]>.Probabilities(TInput input, Boolean[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Int32[]>.Probabilities(TInput input, Int32[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefLikelihoodClassifier<TInput,System.Double[]>.Probabilities(TInput input, Double[]& decision, Double[] result);
    public sealed virtual Double[] Probability(TInput[] input, Int32[]& decision);
    public sealed virtual Double[] Probability(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Int32[]>.Probabilities(TInput[] input, Int32[][]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Boolean[]>.Probabilities(TInput[] input, Boolean[][]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Double[]>.Probabilities(TInput[] input, Double[][]& decision);
    public sealed virtual Double[] Probability(TInput[] input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] Probability(TInput[] input, Double[]& decision, Double[] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Boolean[]>.Probabilities(TInput[] input, Boolean[][]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Int32[]>.Probabilities(TInput[] input, Int32[][]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelLikelihoodClassifierBase<TInput,System.Double[]>.Probabilities(TInput[] input, Double[][]& decision, Double[][] result);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
    public sealed virtual IMultilabelLikelihoodClassifier`1<TInput> ToMultilabel();
    public sealed virtual IMulticlassLikelihoodClassifier`1<TInput> ToMulticlass();
    public sealed virtual IMulticlassLikelihoodClassifier`2<TInput, T> ToMulticlass();
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.MulticlassScoreClassifierBase`1 : MulticlassClassifierBase`1<TInput> {
    public virtual Double[] Scores(TInput input, Double[] result);
    public virtual Double[] Scores(TInput input, Int32& decision, Double[] result);
    public abstract virtual double Score(TInput input, int classIndex);
    public virtual int Decide(TInput input);
    public sealed virtual Double[] Score(TInput[] input, Int32[] classIndex);
    public sealed virtual Double[] Score(TInput[] input, Int32[] classIndex, Double[] result);
    public sealed virtual Double[] Score(TInput[] input, int classIndex);
    public sealed virtual Double[] Score(TInput[] input, int classIndex, Double[] result);
    public sealed virtual double Score(TInput input);
    public sealed virtual Double[] Score(TInput[] input);
    public sealed virtual Double[] Score(TInput[] input, Double[] result);
    public sealed virtual Double[] Scores(TInput input);
    public sealed virtual Double[][] Scores(TInput[] input);
    public virtual Double[][] Scores(TInput[] input, Double[][] result);
    public sealed virtual double Score(TInput input, Int32& decision);
    public sealed virtual double Score(TInput input, Double& decision);
    public sealed virtual Double[] Scores(TInput input, Int32& decision);
    public sealed virtual Double[] Scores(TInput input, Double& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Boolean[]>.Scores(TInput input, Boolean[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Int32[]>.Scores(TInput input, Int32[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Double[]>.Scores(TInput input, Double[]& decision);
    public sealed virtual Double[] Scores(TInput input, Double& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Boolean[]>.Scores(TInput input, Boolean[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Int32[]>.Scores(TInput input, Int32[]& decision, Double[] result);
    private sealed virtual override Double[] Accord.MachineLearning.IMultilabelRefScoreClassifier<TInput,System.Double[]>.Scores(TInput input, Double[]& decision, Double[] result);
    public sealed virtual Double[] Score(TInput[] input, Int32[]& decision);
    public sealed virtual Double[] Score(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] Scores(TInput[] input, Int32[]& decision);
    public sealed virtual Double[][] Scores(TInput[] input, Double[]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Int32[]>.Scores(TInput[] input, Int32[][]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Boolean[]>.Scores(TInput[] input, Boolean[][]& decision);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Double[]>.Scores(TInput[] input, Double[][]& decision);
    public sealed virtual Double[] Score(TInput[] input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] Score(TInput[] input, Double[]& decision, Double[] result);
    public sealed virtual Double[][] Scores(TInput[] input, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] Scores(TInput[] input, Double[]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Boolean[]>.Scores(TInput[] input, Boolean[][]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Int32[]>.Scores(TInput[] input, Int32[][]& decision, Double[][] result);
    private sealed virtual override Double[][] Accord.MachineLearning.IMultilabelScoreClassifierBase<TInput,System.Double[]>.Scores(TInput[] input, Double[][]& decision, Double[][] result);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
    public sealed virtual IMultilabelScoreClassifier`1<TInput> ToMultilabel();
    public sealed virtual IMulticlassScoreClassifier`1<TInput> ToMulticlass();
    public sealed virtual IMulticlassScoreClassifier`2<TInput, T> ToMulticlass();
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.MultilabelClassifierBase`1 : ClassifierBase`2<TInput, Boolean[]> {
    public abstract virtual bool Decide(TInput input, int classIndex);
    public virtual Boolean[] Decide(TInput input);
    public virtual Boolean[] Decide(TInput input, Boolean[] result);
    private sealed virtual override Int32[] Accord.MachineLearning.IClassifier<TInput,System.Int32[]>.Decide(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput input);
    private sealed virtual override Double[][] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput[] input);
    private sealed virtual override Int32[][] Accord.MachineLearning.IClassifier<TInput,System.Int32[]>.Decide(TInput[] input);
    public sealed virtual Int32[] Decide(TInput input, Int32[] result);
    public sealed virtual Double[] Decide(TInput input, Double[] result);
    public sealed virtual Int32[][] Decide(TInput[] input, Int32[][] result);
    public sealed virtual Double[][] Decide(TInput[] input, Double[][] result);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<TInput,System.Double[]>.Transform(TInput input);
    private sealed virtual override Double[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Double[]>.Transform(TInput[] input);
    private sealed virtual override Boolean[] Accord.MachineLearning.ICovariantTransform<TInput,System.Boolean[]>.Transform(TInput input);
    private sealed virtual override Boolean[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Boolean[]>.Transform(TInput[] input);
    private sealed virtual override Int32[] Accord.MachineLearning.ICovariantTransform<TInput,System.Int32[]>.Transform(TInput input);
    private sealed virtual override Int32[][] Accord.MachineLearning.ICovariantTransform<TInput,System.Int32[]>.Transform(TInput[] input);
    public virtual Boolean[] Transform(TInput input, Boolean[] result);
    public virtual Int32[] Transform(TInput input, Int32[] result);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Boolean[][] Transform(TInput[] input, Boolean[][] result);
    public virtual Int32[][] Transform(TInput[] input, Int32[][] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.MultilabelLikelihoodClassifierBase`1 : MultilabelScoreClassifierBase`1<TInput> {
    public abstract virtual double LogLikelihood(TInput input, int classIndex, Boolean& decision);
    public virtual Double[] Probabilities(TInput input, Boolean[]& decision, Double[] result);
    public virtual Double[] LogLikelihoods(TInput input, Boolean[]& decision, Double[] result);
    public virtual double LogLikelihood(TInput input, int classIndex);
    public sealed virtual Double[] LogLikelihoods(TInput input);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double[] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[][] result);
    public sealed virtual double Probability(TInput input, int classIndex);
    public sealed virtual Double[] Probability(TInput[] input, int classIndex);
    public sealed virtual Double[] Probability(TInput[] input, int classIndex, Double[] result);
    public sealed virtual Double[] Probability(TInput[] input, Int32[] classIndex);
    public sealed virtual Double[] Probability(TInput[] input, Int32[] classIndex, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input);
    public sealed virtual Double[] Probabilities(TInput input, Double[] result);
    public sealed virtual Double[][] Probabilities(TInput[] input);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[][] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Int32[] classIndex);
    public sealed virtual Double[] LogLikelihood(TInput[] input, Int32[] classIndex, Double[] result);
    public sealed virtual Double[] LogLikelihood(TInput[] input, int classIndex);
    public sealed virtual Double[] LogLikelihood(TInput[] input, int classIndex, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Boolean[]& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32[]& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double[]& decision);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double& decision, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32& decision, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] LogLikelihoods(TInput input, Double[]& decision, Double[] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[][]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Boolean[][]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[][]& decision);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Boolean[][]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Int32[][]& decision, Double[][] result);
    public sealed virtual Double[][] LogLikelihoods(TInput[] input, Double[][]& decision, Double[][] result);
    public sealed virtual Double[] Probabilities(TInput input, Double& decision);
    public sealed virtual Double[] Probabilities(TInput input, Int32& decision);
    public sealed virtual Double[] Probabilities(TInput input, Boolean[]& decision);
    public sealed virtual Double[] Probabilities(TInput input, Int32[]& decision);
    public sealed virtual Double[] Probabilities(TInput input, Double[]& decision);
    public sealed virtual Double[] Probabilities(TInput input, Double& decision, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input, Int32& decision, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] Probabilities(TInput input, Double[]& decision, Double[] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[][]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Boolean[][]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[][]& decision);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Boolean[][]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Int32[][]& decision, Double[][] result);
    public sealed virtual Double[][] Probabilities(TInput[] input, Double[][]& decision, Double[][] result);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
    public sealed virtual IMulticlassLikelihoodClassifier`1<TInput> ToMulticlass();
    public sealed virtual IMulticlassLikelihoodClassifier`2<TInput, T> ToMulticlass();
    private sealed virtual override int Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.Decide(TInput[] input);
    private sealed virtual override double Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.LogLikelihood(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.LogLikelihood(TInput[] input);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.LogLikelihood(TInput[] input, Double[] result);
    private sealed virtual override IMultilabelLikelihoodClassifier`1<TInput> Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.ToMultilabel();
    private sealed virtual override double Accord.MachineLearning.IMulticlassOutLikelihoodClassifier<TInput,System.Int32>.LogLikelihood(TInput input, Int32& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifierBase<TInput,System.Int32>.LogLikelihood(TInput[] input, Int32[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifierBase<TInput,System.Int32>.LogLikelihood(TInput[] input, Int32[]& decision, Double[] result);
    private sealed virtual override double Accord.MachineLearning.IMulticlassOutLikelihoodClassifier<TInput,System.Double>.LogLikelihood(TInput input, Double& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifierBase<TInput,System.Double>.LogLikelihood(TInput[] input, Double[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifierBase<TInput,System.Double>.LogLikelihood(TInput[] input, Double[]& decision, Double[] result);
    private sealed virtual override double Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.Probability(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.Probability(TInput[] input);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifier<TInput>.Probability(TInput[] input, Double[] result);
    private sealed virtual override double Accord.MachineLearning.IMulticlassOutLikelihoodClassifier<TInput,System.Int32>.Probability(TInput input, Int32& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifierBase<TInput,System.Int32>.Probability(TInput[] input, Int32[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifierBase<TInput,System.Int32>.Probability(TInput[] input, Int32[]& decision, Double[] result);
    private sealed virtual override double Accord.MachineLearning.IMulticlassOutLikelihoodClassifier<TInput,System.Double>.Probability(TInput input, Double& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifierBase<TInput,System.Double>.Probability(TInput[] input, Double[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassLikelihoodClassifierBase<TInput,System.Double>.Probability(TInput[] input, Double[]& decision, Double[] result);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.MultilabelScoreClassifierBase`1 : MultilabelClassifierBase`1<TInput> {
    public abstract virtual double Score(TInput input, int classIndex, Boolean& decision);
    public virtual double Score(TInput input, int classIndex);
    public virtual Double[] Scores(TInput input, Boolean[]& decision, Double[] result);
    public sealed virtual Double[] Score(TInput[] input, Int32[] classIndex);
    public sealed virtual Double[] Score(TInput[] input, Int32[] classIndex, Double[] result);
    public sealed virtual Double[] Score(TInput[] input, int classIndex);
    public sealed virtual Double[] Score(TInput[] input, int classIndex, Double[] result);
    public sealed virtual Double[] Scores(TInput input);
    public sealed virtual Double[][] Scores(TInput[] input);
    public sealed virtual Double[][] Scores(TInput[] input, Double[][] result);
    public sealed virtual Double[] Scores(TInput input, Double[] result);
    public sealed virtual Double[] Scores(TInput input, Boolean[]& decision);
    public sealed virtual Double[] Scores(TInput input, Int32[]& decision);
    public sealed virtual Double[] Scores(TInput input, Double[]& decision);
    public sealed virtual Double[] Scores(TInput input, Int32[]& decision, Double[] result);
    public sealed virtual Double[] Scores(TInput input, Double[]& decision, Double[] result);
    public sealed virtual Double[][] Scores(TInput[] input, Int32[][]& decision);
    public sealed virtual Double[][] Scores(TInput[] input, Boolean[][]& decision);
    public sealed virtual Double[][] Scores(TInput[] input, Double[][]& decision);
    public sealed virtual Double[][] Scores(TInput[] input, Boolean[][]& decision, Double[][] result);
    public sealed virtual Double[][] Scores(TInput[] input, Int32[][]& decision, Double[][] result);
    public sealed virtual Double[][] Scores(TInput[] input, Double[][]& decision, Double[][] result);
    private sealed virtual override int Accord.MachineLearning.IClassifier<TInput,System.Int32>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IClassifier<TInput,System.Int32>.Decide(TInput[] input);
    public virtual Int32[] Decide(TInput[] input, Int32[] result);
    public sealed virtual Double[] Scores(TInput input, Int32& decision);
    public sealed virtual Double[] Scores(TInput input, Int32& decision, Double[] result);
    public sealed virtual Double[][] Scores(TInput[] input, Int32[]& decision);
    public sealed virtual Double[][] Scores(TInput[] input, Int32[]& decision, Double[][] result);
    private sealed virtual override double Accord.MachineLearning.IClassifier<TInput,System.Double>.Decide(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<TInput,System.Double>.Decide(TInput[] input);
    private sealed virtual override Double[] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput input);
    private sealed virtual override Double[][] Accord.MachineLearning.IClassifier<TInput,System.Double[]>.Decide(TInput[] input);
    public sealed virtual Double[] Decide(TInput[] input, Double[] result);
    public sealed virtual Double[] Scores(TInput input, Double& decision);
    public sealed virtual Double[] Scores(TInput input, Double& decision, Double[] result);
    public sealed virtual Double[][] Scores(TInput[] input, Double[]& decision);
    public sealed virtual Double[][] Scores(TInput[] input, Double[]& decision, Double[][] result);
    private sealed virtual override int Accord.MachineLearning.ICovariantTransform<TInput,System.Int32>.Transform(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.ICovariantTransform<TInput,System.Int32>.Transform(TInput[] input);
    public virtual Int32[] Transform(TInput[] input, Int32[] result);
    private sealed virtual override double Accord.MachineLearning.ICovariantTransform<TInput,System.Double>.Transform(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<TInput,System.Double>.Transform(TInput[] input);
    public virtual Double[] Transform(TInput[] input, Double[] result);
    public virtual Double[] Transform(TInput input, Double[] result);
    public virtual Double[][] Transform(TInput[] input, Double[][] result);
    public sealed virtual IMulticlassScoreClassifier`1<TInput> ToMulticlass();
    public sealed virtual IMulticlassScoreClassifier`2<TInput, T> ToMulticlass();
    private sealed virtual override int Accord.MachineLearning.IMulticlassScoreClassifier<TInput>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IMulticlassScoreClassifier<TInput>.Decide(TInput[] input);
    private sealed virtual override double Accord.MachineLearning.IMulticlassScoreClassifier<TInput>.Score(TInput input);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassScoreClassifier<TInput>.Score(TInput[] input);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassScoreClassifier<TInput>.Score(TInput[] input, Double[] result);
    private sealed virtual override IMultilabelScoreClassifier`1<TInput> Accord.MachineLearning.IMulticlassScoreClassifier<TInput>.ToMultilabel();
    private sealed virtual override double Accord.MachineLearning.IMulticlassOutScoreClassifier<TInput,System.Int32>.Score(TInput input, Int32& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassScoreClassifierBase<TInput,System.Int32>.Score(TInput[] input, Int32[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassScoreClassifierBase<TInput,System.Int32>.Score(TInput[] input, Int32[]& decision, Double[] result);
    private sealed virtual override double Accord.MachineLearning.IMulticlassOutScoreClassifier<TInput,System.Double>.Score(TInput input, Double& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassScoreClassifierBase<TInput,System.Double>.Score(TInput[] input, Double[]& decision);
    private sealed virtual override Double[] Accord.MachineLearning.IMulticlassScoreClassifierBase<TInput,System.Double>.Score(TInput[] input, Double[]& decision, Double[] result);
    private sealed virtual override int Accord.MachineLearning.IMulticlassClassifier<TInput>.Decide(TInput input);
    private sealed virtual override Int32[] Accord.MachineLearning.IMulticlassClassifier<TInput>.Decide(TInput[] input);
    private sealed virtual override IMultilabelClassifier`1<TInput> Accord.MachineLearning.IMulticlassClassifier<TInput>.ToMultilabel();
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.MultipleTransformBase`2 : TransformBase`2<TInput, TOutput[]> {
    public virtual TOutput[] Transform(TInput input);
    public virtual TOutput[] Transform(TInput input, TOutput[] result);
    public virtual TOutput[][] Transform(TInput[] input);
    public virtual TOutput[][] Transform(TInput[] input, TOutput[][] result);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.ScoreTaggerBase`1 : TaggerBase`1<TInput> {
    public sealed virtual Double[][] Scores(TInput[] sequence);
    public sealed virtual Double[][] Scores(TInput[] sequence, Double[][] result);
    public sealed virtual Double[][] Scores(TInput[] sequence, Int32[]& decision);
    public sealed virtual Double[][] Scores(TInput[] sequence, Int32[]& decision, Double[][] result);
    public sealed virtual Double[][][] Scores(TInput[][] sequences);
    public sealed virtual Double[][][] Scores(TInput[][] sequences, Int32[][]& decision);
    public abstract virtual Double[][][] Scores(TInput[][] sequences, Double[][][] result);
    public abstract virtual Double[][][] Scores(TInput[][] sequences, Int32[][]& decision, Double[][][] result);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.TaggerBase`1 : TransformBase`2<TInput[], Int32[]> {
    public int NumberOfClasses { get; public set; }
    public virtual int get_NumberOfClasses();
    public virtual void set_NumberOfClasses(int value);
    public virtual Int32[] Decide(TInput[] input, Int32[] result);
    public sealed virtual Int32[] Decide(TInput[] input);
    public sealed virtual Int32[][] Decide(TInput[][] input);
    public abstract virtual Int32[][] Decide(TInput[][] input, Int32[][] result);
    public virtual Int32[] Transform(TInput[] input);
    internal Double[][] create(TInput[] input);
    internal Double[][][] create(TInput[][] input);
    internal T[][] create(TInput[][] input, T[][] decision);
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.TransformBase : TransformBase`1<Double[]> {
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.TransformBase`1 : TransformBase`2<TInput, double> {
}
[SerializableAttribute]
public abstract class Accord.MachineLearning.TransformBase`2 : object {
    private int inputs;
    private int outputs;
    public int NumberOfInputs { get; public set; }
    public int NumberOfOutputs { get; public set; }
    public virtual int get_NumberOfInputs();
    public virtual void set_NumberOfInputs(int value);
    public virtual int get_NumberOfOutputs();
    public virtual void set_NumberOfOutputs(int value);
    public abstract virtual TOutput Transform(TInput input);
    public virtual TOutput[] Transform(TInput[] input);
    public virtual TOutput[] Transform(TInput[] input, TOutput[] result);
}
[SerializableAttribute]
public class Accord.Math.Distances.Bhattacharyya : object {
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(GeneralDiscreteDistribution x, GeneralDiscreteDistribution y);
    public sealed virtual double Distance(UnivariateDiscreteDistribution x, UnivariateDiscreteDistribution y);
    public sealed virtual double Distance(Double[][] x, Double[][] y);
    public sealed virtual double Distance(Double[0...,0...] x, Double[0...,0...] y);
    public double Distance(Double[] meanX, Double[0...,0...] covX, Double[] meanY, Double[0...,0...] covY);
    public double Distance(Double[] meanX, Double[][] covX, Double[] meanY, Double[][] covY);
    public double Distance(Double[] meanX, Double[0...,0...] covX, double lnDetCovX, Double[] meanY, Double[0...,0...] covY, double lnDetCovY);
    public double Distance(Double[] meanX, Double[][] covX, double lnDetCovX, Double[] meanY, Double[][] covY, double lnDetCovY);
    public sealed virtual double Distance(MultivariateNormalDistribution x, MultivariateNormalDistribution y);
}
[SerializableAttribute]
public class Accord.Math.Distances.LogLikelihood`1 : object {
    public sealed virtual double Distance(Double[] x, T y);
    public sealed virtual double Distance(Double[] x, IMixtureComponent`1<T> y);
}
public enum Accord.Statistics.Analysis.AnalysisMethod : Enum {
    public int value__;
    public static AnalysisMethod Center;
    public static AnalysisMethod Standardize;
}
[SerializableAttribute]
public abstract class Accord.Statistics.Analysis.Base.BasePrincipalComponentAnalysis : MultipleTransformBase`2<Double[], double> {
    [NonSerializedAttribute]
private CancellationToken token;
    private Double[] columnMeans;
    private Double[] columnStdDev;
    private Double[][] eigenvectors;
    private Double[] eigenvalues;
    private Double[] singularValues;
    private Double[] componentProportions;
    private Double[] componentCumulative;
    private bool overwriteSourceMatrix;
    private PrincipalComponentMethod analysisMethod;
    private bool whiten;
    private PrincipalComponentCollection componentCollection;
    protected Double[0...,0...] source;
    protected Double[][] array;
    protected Double[0...,0...] result;
    protected bool onlyCovarianceMatrixAvailable;
    protected Double[0...,0...] covarianceMatrix;
    protected bool saveResult;
    public Double[] StandardDeviations { get; public set; }
    public Double[] Means { get; public set; }
    public PrincipalComponentMethod Method { get; public set; }
    public bool Overwrite { get; public set; }
    public bool Whiten { get; public set; }
    public int NumberOfOutputs { get; public set; }
    public int MaximumNumberOfOutputs { get; }
    public double ExplainedVariance { get; public set; }
    public Double[] SingularValues { get; protected set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; private set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Result { get; protected set; }
    [ObsoleteAttribute("Please use ComponentValues instead.")]
public Double[0...,0...] ComponentMatrix { get; }
    public Double[][] ComponentVectors { get; protected set; }
    public Double[] Eigenvalues { get; protected set; }
    public CancellationToken Token { get; public set; }
    public Double[] ComponentProportions { get; }
    public Double[] CumulativeProportions { get; }
    public PrincipalComponentCollection Components { get; }
    public Double[] get_StandardDeviations();
    public void set_StandardDeviations(Double[] value);
    public Double[] get_Means();
    public void set_Means(Double[] value);
    public PrincipalComponentMethod get_Method();
    public void set_Method(PrincipalComponentMethod value);
    public bool get_Overwrite();
    public void set_Overwrite(bool value);
    public bool get_Whiten();
    public void set_Whiten(bool value);
    public int get_NumberOfOutputs();
    public void set_NumberOfOutputs(int value);
    public int get_MaximumNumberOfOutputs();
    public double get_ExplainedVariance();
    public void set_ExplainedVariance(double value);
    public Double[] get_SingularValues();
    protected void set_SingularValues(Double[] value);
    public sealed virtual Double[0...,0...] get_Source();
    private void set_Source(Double[0...,0...] value);
    public Double[0...,0...] get_Result();
    protected void set_Result(Double[0...,0...] value);
    public Double[0...,0...] get_ComponentMatrix();
    public Double[][] get_ComponentVectors();
    protected void set_ComponentVectors(Double[][] value);
    public Double[] get_Eigenvalues();
    protected void set_Eigenvalues(Double[] value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public Double[] get_ComponentProportions();
    public Double[] get_CumulativeProportions();
    public PrincipalComponentCollection get_Components();
    public int GetNumberOfComponents(double threshold);
    protected void CreateComponents();
    public virtual Double[] Transform(Double[] input);
    public virtual Double[] Transform(Double[] input, Double[] result);
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public sealed virtual Double[0...,0...] Transform(Double[0...,0...] data);
    [ObsoleteAttribute("Please set NumberOfOutputs to the desired number of dimensions and call Transform()")]
public virtual Double[0...,0...] Transform(Double[0...,0...] data, int dimensions);
    [ObsoleteAttribute("Please set NumberOfOutputs to the desired number of dimensions and call Transform()")]
public Double[] Transform(Double[] data, int dimensions);
    [ObsoleteAttribute("Please set NumberOfOutputs to the desired number of dimensions and call Transform()")]
public virtual Double[][] Transform(Double[][] data, int dimensions);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Analysis.BaseDiscriminantAnalysis : TransformBase`2<Double[], Double[]> {
    [NonSerializedAttribute]
private CancellationToken token;
    private int numSamples;
    private int numClasses;
    private Double[] totalMeans;
    private Double[] totalStdDevs;
    private double threshold;
    internal Int32[] classCount;
    internal Double[][] classMeans;
    internal Double[][] classStdDevs;
    internal Double[][][] classScatter;
    internal Double[][] projectedMeans;
    private Double[][] eigenvectors;
    private Double[] eigenvalues;
    private Double[0...,0...] result;
    private Double[0...,0...] source;
    private Int32[] outputs;
    private Double[][] Sw;
    private Double[][] Sb;
    private Double[][] St;
    private Double[] discriminantProportions;
    private Double[] discriminantCumulative;
    private DiscriminantCollection discriminantCollection;
    private DiscriminantAnalysisClassCollection classCollection;
    public CancellationToken Token { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; protected set; }
    public double Threshold { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Result { get; protected set; }
    [ObsoleteAttribute("This property will be removed.")]
public Int32[] Classifications { get; protected set; }
    public int NumberOfSamples { get; protected set; }
    public int NumberOfClasses { get; protected set; }
    public Double[] Means { get; protected set; }
    public Double[] StandardDeviations { get; protected set; }
    public Double[][] ScatterWithinClass { get; protected set; }
    public Double[][] ScatterBetweenClass { get; protected set; }
    public Double[][] ScatterMatrix { get; protected set; }
    [ObsoleteAttribute("Please use DiscriminantVectors.Transpose() instead.")]
public Double[0...,0...] DiscriminantMatrix { get; }
    public Double[][] DiscriminantVectors { get; protected set; }
    public Double[] Eigenvalues { get; protected set; }
    public Double[] DiscriminantProportions { get; }
    public Double[] CumulativeProportions { get; }
    public DiscriminantCollection Discriminants { get; protected set; }
    public DiscriminantAnalysisClassCollection Classes { get; protected set; }
    protected Double[][][] ClassScatter { get; }
    protected Double[][] ClassMeans { get; }
    protected Double[][] ProjectionMeans { get; }
    protected Double[][] ClassStandardDeviations { get; }
    protected Int32[] ClassCount { get; }
    [ObsoleteAttribute]
protected void init(Double[0...,0...] inputs, Int32[] outputs);
    protected void Init(Double[][] inputs, Int32[] outputs);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public sealed virtual Double[0...,0...] get_Source();
    protected void set_Source(Double[0...,0...] value);
    public double get_Threshold();
    public void set_Threshold(double value);
    public Double[0...,0...] get_Result();
    protected void set_Result(Double[0...,0...] value);
    public sealed virtual Int32[] get_Classifications();
    protected void set_Classifications(Int32[] value);
    public int get_NumberOfSamples();
    protected void set_NumberOfSamples(int value);
    public int get_NumberOfClasses();
    protected void set_NumberOfClasses(int value);
    public Double[] get_Means();
    protected void set_Means(Double[] value);
    public Double[] get_StandardDeviations();
    protected void set_StandardDeviations(Double[] value);
    public Double[][] get_ScatterWithinClass();
    protected void set_ScatterWithinClass(Double[][] value);
    public Double[][] get_ScatterBetweenClass();
    protected void set_ScatterBetweenClass(Double[][] value);
    public Double[][] get_ScatterMatrix();
    protected void set_ScatterMatrix(Double[][] value);
    public Double[0...,0...] get_DiscriminantMatrix();
    public Double[][] get_DiscriminantVectors();
    protected void set_DiscriminantVectors(Double[][] value);
    public Double[] get_Eigenvalues();
    protected void set_Eigenvalues(Double[] value);
    public Double[] get_DiscriminantProportions();
    public Double[] get_CumulativeProportions();
    public DiscriminantCollection get_Discriminants();
    protected void set_Discriminants(DiscriminantCollection value);
    public DiscriminantAnalysisClassCollection get_Classes();
    protected void set_Classes(DiscriminantAnalysisClassCollection value);
    protected Double[][][] get_ClassScatter();
    protected Double[][] get_ClassMeans();
    protected Double[][] get_ProjectionMeans();
    protected Double[][] get_ClassStandardDeviations();
    protected Int32[] get_ClassCount();
    [ObsoleteAttribute("Please set NumberOfOutputs to the desired number of dimensions and call Transform()")]
public virtual Double[0...,0...] Transform(Double[0...,0...] data, int dimensions);
    [ObsoleteAttribute("Please set NumberOfOutputs to the desired number of dimensions and call Transform()")]
public virtual Double[][] Transform(Double[][] data, int dimensions);
    [ObsoleteAttribute("Please set NumberOfOutputs to the desired number of dimensions and call Transform()")]
public Double[] Transform(Double[] data, int discriminants);
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public sealed virtual Double[0...,0...] Transform(Double[0...,0...] data);
    public virtual Double[] Transform(Double[] input);
    public virtual Double[][] Transform(Double[][] input);
    public int GetNumberOfDimensions(double threshold);
    protected static int GetNonzeroEigenvalues(Double[] evals, double threshold);
    [ObsoleteAttribute("Please use Classifier.Decide() instead.")]
public abstract virtual int Classify(Double[] input);
    [ObsoleteAttribute("Please use Classifier.Decide() or Classifier.Scores() instead.")]
public abstract virtual int Classify(Double[] input, Double[]& responses);
    [ObsoleteAttribute("Please use Classifier.Decide() instead.")]
public abstract virtual Int32[] Classify(Double[][] inputs);
    public abstract virtual double DiscriminantFunction(Double[] input, int classIndex);
    protected void CreateDiscriminants();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.CircularDescriptiveAnalysis : object {
    private int samples;
    private int variables;
    private Double[][] angles;
    private Double[] lengths;
    private Double[] sums;
    private Double[] sin;
    private Double[] cos;
    private Double[] means;
    private Double[] standardDeviations;
    private Double[] standardErrors;
    private Double[] variances;
    private Double[] medians;
    private Double[] modes;
    private Double[] kurtosis;
    private Double[] skewness;
    private Int32[] distinct;
    private Double[] angularMeans;
    private Double[] angularMedians;
    private String[] columnNames;
    private QuantileMethod quantileMethod;
    private DoubleRange[] ranges;
    private DoubleRange[] quartiles;
    private DoubleRange[] innerFences;
    private DoubleRange[] outerFences;
    private DoubleRange[] confidences;
    private DoubleRange[] deviances;
    private Double[] concentration;
    private Double[0...,0...] sourceMatrix;
    private Double[][] sourceArray;
    private Double[] sourceRow;
    private CircularDescriptiveMeasureCollection measuresCollection;
    private bool useStrictRanges;
    private bool lazy;
    public bool UseStrictRanges { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[][] Array { get; }
    public QuantileMethod QuantileMethod { get; public set; }
    public bool Lazy { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[][] Angles { get; }
    public String[] ColumnNames { get; }
    public Double[] Lengths { get; }
    public Double[] Means { get; private set; }
    public Double[] Modes { get; }
    public Double[] StandardDeviations { get; }
    public Double[] StandardErrors { get; }
    public DoubleRange[] Confidence { get; }
    public DoubleRange[] Deviance { get; }
    public Double[] Medians { get; }
    public Double[] Variances { get; }
    public Int32[] Distinct { get; }
    public DoubleRange[] Ranges { get; }
    public DoubleRange[] Quartiles { get; }
    public DoubleRange[] InnerFences { get; }
    public DoubleRange[] OuterFences { get; }
    public Double[] Sums { get; }
    public Double[] CosineSum { get; }
    public Double[] SineSum { get; }
    public Double[] Concentration { get; }
    public Double[] Skewness { get; }
    public Double[] Kurtosis { get; }
    public int Samples { get; }
    public int Variables { get; }
    public CircularDescriptiveMeasureCollection Measures { get; }
    [ObsoleteAttribute("Please pass only the lengths and columnNames parameters and call the Learn() method passing the data to be analyzed.")]
public CircularDescriptiveAnalysis(Double[] data, double length, string columnName, bool inPlace);
    [ObsoleteAttribute("Please pass only the lengths and columnNames parameters and call the Learn() method passing the data to be analyzed.")]
public CircularDescriptiveAnalysis(Double[] data, double length, bool inPlace);
    [ObsoleteAttribute("Please pass only the lengths and columnNames parameters and call the Learn() method passing the data to be analyzed.")]
public CircularDescriptiveAnalysis(Double[0...,0...] data, Double[] length);
    [ObsoleteAttribute("Please pass only the lengths and columnNames parameters and call the Learn() method passing the data to be analyzed.")]
public CircularDescriptiveAnalysis(Double[0...,0...] data, Double[] length, String[] columnNames);
    [ObsoleteAttribute("Please pass only the lengths and columnNames parameters and call the Learn() method passing the data to be analyzed.")]
public CircularDescriptiveAnalysis(Double[][] data, Double[] length);
    [ObsoleteAttribute("Please pass only the lengths and columnNames parameters and call the Learn() method passing the data to be analyzed.")]
public CircularDescriptiveAnalysis(Double[][] data, Double[] length, String[] columnNames);
    public CircularDescriptiveAnalysis(Double[] length, String[] columnNames);
    public CircularDescriptiveAnalysis(Double[] length);
    private void compute(Double[] row, Double[0...,0...] matrix, Double[][] array, Double[] length, String[] columnNames, bool inPlace);
    [ObsoleteAttribute("Please use Learn() instead.")]
public sealed virtual void Compute();
    private void reset();
    public sealed virtual CircularDescriptiveAnalysis Learn(Double[][] x);
    public bool get_UseStrictRanges();
    public void set_UseStrictRanges(bool value);
    public sealed virtual Double[0...,0...] get_Source();
    public Double[][] get_Array();
    public QuantileMethod get_QuantileMethod();
    public void set_QuantileMethod(QuantileMethod value);
    public bool get_Lazy();
    public void set_Lazy(bool value);
    public Double[][] get_Angles();
    public String[] get_ColumnNames();
    public Double[] get_Lengths();
    public Double[] get_Means();
    private void set_Means(Double[] value);
    public Double[] get_Modes();
    public Double[] get_StandardDeviations();
    public Double[] get_StandardErrors();
    public DoubleRange[] get_Confidence();
    public DoubleRange[] get_Deviance();
    public Double[] get_Medians();
    public Double[] get_Variances();
    public Int32[] get_Distinct();
    public DoubleRange[] get_Ranges();
    public DoubleRange[] get_Quartiles();
    public DoubleRange[] get_InnerFences();
    public DoubleRange[] get_OuterFences();
    public Double[] get_Sums();
    public Double[] get_CosineSum();
    public Double[] get_SineSum();
    public Double[] get_Concentration();
    public Double[] get_Skewness();
    public Double[] get_Kurtosis();
    public int get_Samples();
    public int get_Variables();
    public CircularDescriptiveMeasureCollection get_Measures();
    public DoubleRange GetConfidenceInterval(int index, double percent);
    public DoubleRange GetDevianceInterval(int index, double percent);
    private void computeSums();
    private void computeMedians();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.CircularDescriptiveMeasureCollection : ReadOnlyKeyedCollection`2<string, CircularDescriptiveMeasures> {
    internal CircularDescriptiveMeasureCollection(CircularDescriptiveMeasures[] components);
    protected virtual string GetKeyForItem(CircularDescriptiveMeasures item);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.CircularDescriptiveMeasures : object {
    private CircularDescriptiveAnalysis analysis;
    private int index;
    [BrowsableAttribute("False")]
public CircularDescriptiveAnalysis Analysis { get; }
    public int Index { get; }
    public string Name { get; }
    public double Sum { get; }
    public double Mean { get; }
    public double StandardDeviation { get; }
    public double Median { get; }
    public double Mode { get; }
    public DoubleRange OuterFence { get; }
    public DoubleRange InnerFence { get; }
    public DoubleRange Quartiles { get; }
    public double Variance { get; }
    public double Max { get; }
    public double Min { get; }
    public double Length { get; }
    public int Distinct { get; }
    public int Count { get; }
    public double CosineSum { get; }
    public double SineSum { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Angles { get; }
    public double StandardError { get; }
    public DoubleRange Confidence { get; }
    public DoubleRange Deviance { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Samples { get; }
    public double Skewness { get; }
    public double Kurtosis { get; }
    internal CircularDescriptiveMeasures(CircularDescriptiveAnalysis analysis, int index);
    public CircularDescriptiveAnalysis get_Analysis();
    public sealed virtual int get_Index();
    public sealed virtual string get_Name();
    public sealed virtual double get_Sum();
    public sealed virtual double get_Mean();
    public sealed virtual double get_StandardDeviation();
    public sealed virtual double get_Median();
    public sealed virtual double get_Mode();
    public sealed virtual DoubleRange get_OuterFence();
    public sealed virtual DoubleRange get_InnerFence();
    public sealed virtual DoubleRange get_Quartiles();
    public sealed virtual double get_Variance();
    public sealed virtual double get_Max();
    public sealed virtual double get_Min();
    public sealed virtual double get_Length();
    public sealed virtual int get_Distinct();
    public sealed virtual int get_Count();
    public double get_CosineSum();
    public double get_SineSum();
    public Double[] get_Angles();
    public sealed virtual double get_StandardError();
    public sealed virtual DoubleRange get_Confidence();
    public sealed virtual DoubleRange get_Deviance();
    public sealed virtual Double[] get_Samples();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Kurtosis();
    public sealed virtual DoubleRange GetConfidenceInterval(double percent);
    public sealed virtual DoubleRange GetDevianceInterval(double percent);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.ConfusionMatrix : object {
    private int truePositives;
    private int falseNegatives;
    private int falsePositives;
    private int trueNegatives;
    private Nullable`1<double> kappaVariance;
    private Nullable`1<double> kappaStdError;
    private Nullable`1<double> kappaVariance0;
    private Nullable`1<double> kappaStdError0;
    private Nullable`1<double> chiSquare;
    public Int32[0...,0...] Matrix { get; }
    [DisplayNameAttribute("Row Totals")]
public Int32[] RowTotals { get; }
    [DisplayNameAttribute("Column Totals")]
public Int32[] ColumnTotals { get; }
    [DisplayNameAttribute("Number of samples")]
public int NumberOfSamples { get; }
    [DisplayNameAttribute("Number of classes")]
public int NumberOfClasses { get; }
    [ObsoleteAttribute("Please use NumberOfSamples instead.")]
[DisplayNameAttribute("Number of samples")]
public int Samples { get; }
    [DisplayNameAttribute("Actual Positives")]
public int ActualPositives { get; }
    [DisplayNameAttribute("Actual Negatives")]
public int ActualNegatives { get; }
    [DisplayNameAttribute("Predicted Positives")]
public int PredictedPositives { get; }
    [DisplayNameAttribute("Predicted Negatives")]
public int PredictedNegatives { get; }
    [DisplayNameAttribute("True Positives (TP)")]
public int TruePositives { get; }
    [DisplayNameAttribute("True Negatives (TN)")]
public int TrueNegatives { get; }
    [DisplayNameAttribute("False Positives (FP)")]
public int FalsePositives { get; }
    [DisplayNameAttribute("False Negatives (FN)")]
public int FalseNegatives { get; }
    public double Sensitivity { get; }
    public double Specificity { get; }
    public double Efficiency { get; }
    public int Errors { get; }
    public int Hits { get; }
    public double Accuracy { get; }
    public double Error { get; }
    public double Prevalence { get; }
    public Int32[] Diagonal { get; }
    [DisplayNameAttribute("Positive Predictive Value (PPV)")]
public double PositivePredictiveValue { get; }
    [DisplayNameAttribute("Negative Predictive Value (NPV)")]
public double NegativePredictiveValue { get; }
    [DisplayNameAttribute("False Positive Rate")]
public double FalsePositiveRate { get; }
    [DisplayNameAttribute("False Discovery Rate")]
public double FalseDiscoveryRate { get; }
    [DisplayNameAttribute("Mattews Correlation ()")]
public double MatthewsCorrelationCoefficient { get; }
    [DisplayNameAttribute("Pearson's C")]
public double Pearson { get; }
    [DisplayNameAttribute("Geometric Agreement")]
public double GeometricAgreement { get; }
    [DisplayNameAttribute("Odds Ratio")]
public double OddsRatio { get; }
    [DisplayNameAttribute("Overall Agreement")]
public double OverallAgreement { get; }
    [DisplayNameAttribute("Chance Agreement")]
public double ChanceAgreement { get; }
    [DisplayNameAttribute("Kappa Coefficient ()")]
public double Kappa { get; }
    [DisplayNameAttribute("Kappa () Std. Error")]
public double StandardError { get; }
    [DisplayNameAttribute("Kappa () Variance")]
public double Variance { get; }
    [DisplayNameAttribute("Kappa () H Variance")]
public double VarianceUnderNull { get; }
    [DisplayNameAttribute("Kappa () H Std. Error")]
public double StandardErrorUnderNull { get; }
    [DisplayNameAttribute("Overall Diagnostic Power")]
public double OverallDiagnosticPower { get; }
    [DisplayNameAttribute("Normalized Mutual Information")]
public double NormalizedMutualInformation { get; }
    public double Precision { get; }
    public double Recall { get; }
    [DisplayNameAttribute("F-Score")]
public double FScore { get; }
    [DisplayNameAttribute("Expected Values")]
public Double[0...,0...] ExpectedValues { get; }
    [DisplayNameAttribute("Chi-Square ()")]
public double ChiSquare { get; }
    public ConfusionMatrix(int truePositives, int falseNegatives, int falsePositives, int trueNegatives);
    public ConfusionMatrix(Int32[0...,0...] matrix);
    public ConfusionMatrix(Boolean[] predicted, Boolean[] expected);
    public ConfusionMatrix(Int32[] predicted, Int32[] expected);
    public ConfusionMatrix(Int32[] predicted, Int32[] expected, int positiveValue);
    public ConfusionMatrix(Int32[] predicted, Int32[] expected, int positiveValue, int negativeValue);
    private void compute(Int32[] predicted, Int32[] expected, int positiveValue);
    public Int32[0...,0...] get_Matrix();
    public Int32[] get_RowTotals();
    public Int32[] get_ColumnTotals();
    public int get_NumberOfSamples();
    public int get_NumberOfClasses();
    public int get_Samples();
    public int get_ActualPositives();
    public int get_ActualNegatives();
    public int get_PredictedPositives();
    public int get_PredictedNegatives();
    public int get_TruePositives();
    public int get_TrueNegatives();
    public int get_FalsePositives();
    public int get_FalseNegatives();
    public double get_Sensitivity();
    public double get_Specificity();
    public double get_Efficiency();
    public int get_Errors();
    public int get_Hits();
    public double get_Accuracy();
    public double get_Error();
    public double get_Prevalence();
    public Int32[] get_Diagonal();
    public double get_PositivePredictiveValue();
    public double get_NegativePredictiveValue();
    public double get_FalsePositiveRate();
    public double get_FalseDiscoveryRate();
    public double get_MatthewsCorrelationCoefficient();
    public double get_Pearson();
    public double get_GeometricAgreement();
    public double get_OddsRatio();
    public double get_OverallAgreement();
    public double get_ChanceAgreement();
    public double get_Kappa();
    public double get_StandardError();
    public double get_Variance();
    public double get_VarianceUnderNull();
    public double get_StandardErrorUnderNull();
    public double get_OverallDiagnosticPower();
    public double get_NormalizedMutualInformation();
    public double get_Precision();
    public double get_Recall();
    public double get_FScore();
    public Double[0...,0...] get_ExpectedValues();
    public double get_ChiSquare();
    public virtual string ToString();
    public GeneralConfusionMatrix ToGeneralMatrix();
    public static ConfusionMatrix Combine(ConfusionMatrix[] matrices);
    public static ConfusionMatrix Estimate(IClassifier`2<TInput, int> classifier, TInput[] inputs, Int32[] expected);
    public static ConfusionMatrix Estimate(IClassifier`2<TInput, bool> classifier, TInput[] inputs, Boolean[] expected);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.ContrastFunctions.Exponential : object {
    private double alpha;
    public double Alpha { get; }
    public Exponential(double alpha);
    public double get_Alpha();
    public sealed virtual void Evaluate(Double[] x, Double[] output, Double[] derivative);
}
public interface Accord.Statistics.Analysis.ContrastFunctions.IContrastFunction {
    public abstract virtual void Evaluate(Double[] x, Double[] output, Double[] derivative);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.ContrastFunctions.Kurtosis : object {
    public sealed virtual void Evaluate(Double[] x, Double[] output, Double[] derivative);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.ContrastFunctions.Logcosh : object {
    private double alpha;
    public double Alpha { get; }
    public Logcosh(double alpha);
    public double get_Alpha();
    public sealed virtual void Evaluate(Double[] x, Double[] output, Double[] derivative);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.DescriptiveAnalysis : object {
    private int samples;
    private int variables;
    private Double[] sums;
    private Double[] means;
    private Double[] standardDeviations;
    private Double[] variances;
    private Double[] medians;
    private Double[] modes;
    private Int32[] distinct;
    private String[] columnNames;
    private QuantileMethod quantileMethod;
    private DoubleRange[] ranges;
    private DoubleRange[] quartiles;
    private DoubleRange[] innerFences;
    private DoubleRange[] outerFences;
    private DoubleRange[] confidence;
    private DoubleRange[] deviance;
    private Double[] kurtosis;
    private Double[] skewness;
    private Double[] standardErrors;
    private Double[0...,0...] covarianceMatrix;
    private Double[0...,0...] correlationMatrix;
    private Double[0...,0...] zScores;
    private Double[0...,0...] dScores;
    private Double[0...,0...] sourceMatrix;
    private Double[][] sourceArray;
    private DescriptiveMeasureCollection measuresCollection;
    private bool lazy;
    public bool Lazy { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[][] Array { get; }
    public QuantileMethod QuantileMethod { get; public set; }
    public String[] ColumnNames { get; public set; }
    public Double[0...,0...] DeviationScores { get; }
    public Double[0...,0...] StandardScores { get; }
    public Double[0...,0...] CovarianceMatrix { get; }
    public Double[0...,0...] CorrelationMatrix { get; }
    public Double[] Means { get; }
    public Double[] StandardDeviations { get; }
    public Double[] StandardErrors { get; }
    public DoubleRange[] Confidence { get; }
    public DoubleRange[] Deviance { get; }
    public Double[] Modes { get; }
    public Double[] Medians { get; }
    public Double[] Variances { get; }
    public Int32[] Distinct { get; }
    public DoubleRange[] Ranges { get; }
    public DoubleRange[] Quartiles { get; }
    public DoubleRange[] InnerFences { get; }
    public DoubleRange[] OuterFences { get; }
    public Double[] Sums { get; }
    public Double[] Skewness { get; }
    public Double[] Kurtosis { get; }
    public int Samples { get; }
    public int Variables { get; }
    public DescriptiveMeasureCollection Measures { get; }
    public DescriptiveAnalysis(String[] columnNames);
    [ObsoleteAttribute("Please call the Learn() method passing the data to be analyzed.")]
public DescriptiveAnalysis(Double[] data);
    [ObsoleteAttribute("Please call the Learn() method passing the data to be analyzed.")]
public DescriptiveAnalysis(Double[0...,0...] data);
    [ObsoleteAttribute("Please pass only columnNames and call the Learn() method passing the data to be analyzed.")]
public DescriptiveAnalysis(Double[0...,0...] data, String[] columnNames);
    [ObsoleteAttribute("Please call the Learn() method passing the data to be analyzed.")]
public DescriptiveAnalysis(Double[][] data);
    [ObsoleteAttribute("Please pass only columnNames and call the Learn() method passing the data to be analyzed.")]
public DescriptiveAnalysis(Double[][] data, String[] columnNames);
    private void init(Double[0...,0...] matrix, Double[][] array, String[] columnNames);
    [ObsoleteAttribute("Please use Learn() instead.")]
public sealed virtual void Compute();
    private void reset();
    public sealed virtual DescriptiveAnalysis Learn(Double[][] x);
    public bool get_Lazy();
    public void set_Lazy(bool value);
    public sealed virtual Double[0...,0...] get_Source();
    public Double[][] get_Array();
    public QuantileMethod get_QuantileMethod();
    public void set_QuantileMethod(QuantileMethod value);
    public String[] get_ColumnNames();
    public void set_ColumnNames(String[] value);
    public Double[0...,0...] get_DeviationScores();
    public Double[0...,0...] get_StandardScores();
    public Double[0...,0...] get_CovarianceMatrix();
    public Double[0...,0...] get_CorrelationMatrix();
    public Double[] get_Means();
    public Double[] get_StandardDeviations();
    public Double[] get_StandardErrors();
    public DoubleRange[] get_Confidence();
    public DoubleRange[] get_Deviance();
    public Double[] get_Modes();
    public Double[] get_Medians();
    public Double[] get_Variances();
    public Int32[] get_Distinct();
    public DoubleRange[] get_Ranges();
    public DoubleRange[] get_Quartiles();
    public DoubleRange[] get_InnerFences();
    public DoubleRange[] get_OuterFences();
    public Double[] get_Sums();
    public Double[] get_Skewness();
    public Double[] get_Kurtosis();
    public int get_Samples();
    public int get_Variables();
    public DescriptiveMeasureCollection get_Measures();
    public DoubleRange GetConfidenceInterval(int index, double percent);
    public DoubleRange GetDevianceInterval(int index, double percent);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.DescriptiveMeasureCollection : ReadOnlyKeyedCollection`2<string, DescriptiveMeasures> {
    internal DescriptiveMeasureCollection(DescriptiveMeasures[] components);
    protected virtual string GetKeyForItem(DescriptiveMeasures item);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.DescriptiveMeasures : object {
    private DescriptiveAnalysis analysis;
    private int index;
    [BrowsableAttribute("False")]
public DescriptiveAnalysis Analysis { get; }
    public int Index { get; }
    public string Name { get; }
    public double Sum { get; }
    public double Mean { get; }
    public double StandardDeviation { get; }
    public double Median { get; }
    public DoubleRange OuterFence { get; }
    public DoubleRange InnerFence { get; }
    public DoubleRange Quartiles { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Skewness { get; }
    public double Kurtosis { get; }
    public double StandardError { get; }
    public double Max { get; }
    public double Min { get; }
    public double Length { get; }
    public int Distinct { get; }
    public int Count { get; }
    public DoubleRange Confidence { get; }
    public DoubleRange Deviance { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Samples { get; }
    internal DescriptiveMeasures(DescriptiveAnalysis analysis, int index);
    public DescriptiveAnalysis get_Analysis();
    public sealed virtual int get_Index();
    public sealed virtual string get_Name();
    public sealed virtual double get_Sum();
    public sealed virtual double get_Mean();
    public sealed virtual double get_StandardDeviation();
    public sealed virtual double get_Median();
    public sealed virtual DoubleRange get_OuterFence();
    public sealed virtual DoubleRange get_InnerFence();
    public sealed virtual DoubleRange get_Quartiles();
    public sealed virtual double get_Mode();
    public sealed virtual double get_Variance();
    public sealed virtual double get_Skewness();
    public sealed virtual double get_Kurtosis();
    public sealed virtual double get_StandardError();
    public sealed virtual double get_Max();
    public sealed virtual double get_Min();
    public sealed virtual double get_Length();
    public sealed virtual int get_Distinct();
    public sealed virtual int get_Count();
    public sealed virtual DoubleRange get_Confidence();
    public sealed virtual DoubleRange get_Deviance();
    public sealed virtual Double[] get_Samples();
    public sealed virtual DoubleRange GetConfidenceInterval(double percent);
    public sealed virtual DoubleRange GetDevianceInterval(double percent);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.Discriminant : object {
    private BaseDiscriminantAnalysis analysis;
    private int index;
    public int Index { get; }
    public Double[] Eigenvector { get; }
    public double Eigenvalue { get; }
    public double Proportion { get; }
    [DisplayNameAttribute("Cumulative")]
public double CumulativeProportion { get; }
    internal Discriminant(BaseDiscriminantAnalysis analysis, int index);
    public sealed virtual int get_Index();
    public Double[] get_Eigenvector();
    public double get_Eigenvalue();
    public sealed virtual double get_Proportion();
    public sealed virtual double get_CumulativeProportion();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.DiscriminantAnalysisClass : object {
    private BaseDiscriminantAnalysis analysis;
    private int classNumber;
    private int index;
    public int Index { get; }
    public int Number { get; }
    public double Prevalence { get; }
    public Double[] Mean { get; }
    public Double[] ProjectionMean { get; }
    public Double[] StandardDeviation { get; }
    public Double[][] Scatter { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Int32[] Indices { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Subset { get; }
    public int Count { get; }
    internal DiscriminantAnalysisClass(BaseDiscriminantAnalysis analysis, int index, int classNumber);
    public int get_Index();
    public int get_Number();
    public double get_Prevalence();
    public Double[] get_Mean();
    public Double[] get_ProjectionMean();
    public Double[] get_StandardDeviation();
    public Double[][] get_Scatter();
    public Int32[] get_Indices();
    public Double[0...,0...] get_Subset();
    public int get_Count();
    public double DiscriminantFunction(Double[] projection);
    [CompilerGeneratedAttribute]
private bool <get_Indices>b__19_0(int y);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.DiscriminantAnalysisClassCollection : ReadOnlyCollection`1<DiscriminantAnalysisClass> {
    internal DiscriminantAnalysisClassCollection(DiscriminantAnalysisClass[] components);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.DiscriminantCollection : ReadOnlyCollection`1<Discriminant> {
    internal DiscriminantCollection(Discriminant[] components);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.DistributionAnalysis : object {
    private Double[] data;
    [CompilerGeneratedAttribute]
private String[] <DistributionNames>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IFittableDistribution`1<double>> <Distributions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IFittableDistribution`1<double>, IFittingOptions> <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private KolmogorovSmirnovTest[] <KolmogorovSmirnov>k__BackingField;
    [CompilerGeneratedAttribute]
private ChiSquareTest[] <ChiSquare>k__BackingField;
    [CompilerGeneratedAttribute]
private AndersonDarlingTest[] <AndersonDarling>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <KolmogorovSmirnovRank>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ChiSquareRank>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <AndersonDarlingRank>k__BackingField;
    [CompilerGeneratedAttribute]
private GoodnessOfFitCollection <GoodnessOfFit>k__BackingField;
    public String[] DistributionNames { get; private set; }
    public List`1<IFittableDistribution`1<double>> Distributions { get; public set; }
    public Dictionary`2<IFittableDistribution`1<double>, IFittingOptions> Options { get; public set; }
    public KolmogorovSmirnovTest[] KolmogorovSmirnov { get; private set; }
    public ChiSquareTest[] ChiSquare { get; private set; }
    public AndersonDarlingTest[] AndersonDarling { get; private set; }
    public Int32[] KolmogorovSmirnovRank { get; private set; }
    public Int32[] ChiSquareRank { get; private set; }
    public Int32[] AndersonDarlingRank { get; private set; }
    public GoodnessOfFitCollection GoodnessOfFit { get; private set; }
    [ObsoleteAttribute("Please use the default parameterless constructor instead.")]
public DistributionAnalysis(Double[] observations);
    [CompilerGeneratedAttribute]
public String[] get_DistributionNames();
    [CompilerGeneratedAttribute]
private void set_DistributionNames(String[] value);
    [CompilerGeneratedAttribute]
public List`1<IFittableDistribution`1<double>> get_Distributions();
    [CompilerGeneratedAttribute]
public void set_Distributions(List`1<IFittableDistribution`1<double>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IFittableDistribution`1<double>, IFittingOptions> get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(Dictionary`2<IFittableDistribution`1<double>, IFittingOptions> value);
    [CompilerGeneratedAttribute]
public KolmogorovSmirnovTest[] get_KolmogorovSmirnov();
    [CompilerGeneratedAttribute]
private void set_KolmogorovSmirnov(KolmogorovSmirnovTest[] value);
    [CompilerGeneratedAttribute]
public ChiSquareTest[] get_ChiSquare();
    [CompilerGeneratedAttribute]
private void set_ChiSquare(ChiSquareTest[] value);
    [CompilerGeneratedAttribute]
public AndersonDarlingTest[] get_AndersonDarling();
    [CompilerGeneratedAttribute]
private void set_AndersonDarling(AndersonDarlingTest[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_KolmogorovSmirnovRank();
    [CompilerGeneratedAttribute]
private void set_KolmogorovSmirnovRank(Int32[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_ChiSquareRank();
    [CompilerGeneratedAttribute]
private void set_ChiSquareRank(Int32[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_AndersonDarlingRank();
    [CompilerGeneratedAttribute]
private void set_AndersonDarlingRank(Int32[] value);
    [CompilerGeneratedAttribute]
public GoodnessOfFitCollection get_GoodnessOfFit();
    [CompilerGeneratedAttribute]
private void set_GoodnessOfFit(GoodnessOfFitCollection value);
    [ObsoleteAttribute("Please use the Learn(x) method instead.")]
public void Compute();
    public GoodnessOfFitCollection Learn(Double[] x, Double[] weights);
    private void compute(Double[] data, Double[] weights);
    private static void run(Action a, int timeoutMilliseconds);
    private Int32[] getRank(Double[] ks);
    public static Type[] GetUnivariateDistributions();
    public static Type[] GetMultivariateDistributions();
    public static string GetName(Type distribution);
    public IFittableDistribution`1<double> GetFirstIndex(string name);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.GeneralConfusionMatrix : object {
    private Int32[0...,0...] matrix;
    private int samples;
    private int classes;
    private Nullable`1<double> kappa;
    private Nullable`1<double> kappaVariance;
    private Nullable`1<double> kappaStdError;
    private Nullable`1<double> kappaVarianceDeltaMethod;
    private Nullable`1<double> kappaStdErrorDeltaMethod;
    private Nullable`1<double> kappaVariance0;
    private Nullable`1<double> kappaStdError0;
    private Nullable`1<double> tau;
    private Nullable`1<double> chiSquare;
    private Int32[] diagonal;
    private Nullable`1<double> diagMax;
    private Nullable`1<double> diagMin;
    private Double[0...,0...] proportions;
    private Int32[] rowSum;
    private Int32[] colSum;
    private Int32[] rowErrors;
    private Int32[] colErrors;
    private Double[] rowProportion;
    private Double[] colProportion;
    private Double[] precision;
    private Double[] recall;
    private ConfusionMatrix[] matrices;
    [CompilerGeneratedAttribute]
private string <TitleAboveColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TitleOnTheLeftOfRows>k__BackingField;
    public string TitleAboveColumns { get; public set; }
    public string TitleOnTheLeftOfRows { get; public set; }
    public Int32[0...,0...] Matrix { get; }
    [DisplayNameAttribute("Number of samples")]
public int NumberOfSamples { get; }
    [DisplayNameAttribute("Number of classes")]
public int NumberOfClasses { get; }
    [DisplayNameAttribute("Number of samples")]
[ObsoleteAttribute("Please use NumberOfSamples instead.")]
public int Samples { get; }
    [DisplayNameAttribute("Number of classes")]
[ObsoleteAttribute("Please use NumberOfClasses instead.")]
public int Classes { get; }
    [DisplayNameAttribute("Row Totals")]
public Int32[] RowTotals { get; }
    [DisplayNameAttribute("Column Totals")]
public Int32[] ColumnTotals { get; }
    [DisplayNameAttribute("Row Errors")]
public Int32[] RowErrors { get; }
    [DisplayNameAttribute("Column Errors")]
public Int32[] ColumnErrors { get; }
    [DisplayNameAttribute("Row Proportions")]
public Double[] RowProportions { get; }
    [DisplayNameAttribute("Column Proportions")]
public Double[] ColumnProportions { get; }
    [DisplayNameAttribute("Precision")]
public Double[] Precision { get; }
    [DisplayNameAttribute("Recall")]
public Double[] Recall { get; }
    public Int32[] Diagonal { get; }
    [DisplayNameAttribute("Maximum Hits")]
public double Max { get; }
    [DisplayNameAttribute("Minimum Hits")]
public double Min { get; }
    [DisplayNameAttribute("Proportion Matrix")]
public Double[0...,0...] ProportionMatrix { get; }
    [DisplayNameAttribute("Kappa Coefficient ()")]
public double Kappa { get; }
    [DisplayNameAttribute("Kappa () Std. Error")]
public double StandardError { get; }
    [DisplayNameAttribute("Kappa () Variance")]
public double Variance { get; }
    [DisplayNameAttribute("Kappa () Variance (delta method)")]
public double VarianceDeltaMethod { get; }
    [DisplayNameAttribute("Kappa () H Variance")]
public double VarianceUnderNull { get; }
    [DisplayNameAttribute("Kappa () H Std. Error")]
public double StandardErrorUnderNull { get; }
    [DisplayNameAttribute("Tau Coefficient ()")]
public double Tau { get; }
    [DisplayNameAttribute("Pearson Correlation ()")]
public double Phi { get; }
    [DisplayNameAttribute("Chi-Square ()")]
public double ChiSquare { get; }
    [DisplayNameAttribute("Tschuprow's T")]
public double Tschuprow { get; }
    [DisplayNameAttribute("Pearson's C")]
public double Pearson { get; }
    [DisplayNameAttribute("Sakoda's V")]
public double Sakoda { get; }
    [DisplayNameAttribute("Cramr's V")]
public double Cramer { get; }
    [DisplayNameAttribute("Overall Agreement")]
public double OverallAgreement { get; }
    [DisplayNameAttribute("Accuracy")]
public double Accuracy { get; }
    [DisplayNameAttribute("Error")]
public double Error { get; }
    [DisplayNameAttribute("Geometric Agreement")]
public double GeometricAgreement { get; }
    [DisplayNameAttribute("Chance Agreement")]
public double ChanceAgreement { get; }
    [DisplayNameAttribute("Expected values")]
public Double[0...,0...] ExpectedValues { get; }
    public ConfusionMatrix[] PerClassMatrices { get; }
    public GeneralConfusionMatrix(Double[0...,0...] matrix, int samples);
    public GeneralConfusionMatrix(Int32[0...,0...] matrix);
    public GeneralConfusionMatrix(Int32[] expected, Int32[] predicted);
    public GeneralConfusionMatrix(int classes, Int32[] expected, Int32[] predicted);
    [CompilerGeneratedAttribute]
public string get_TitleAboveColumns();
    [CompilerGeneratedAttribute]
public void set_TitleAboveColumns(string value);
    [CompilerGeneratedAttribute]
public string get_TitleOnTheLeftOfRows();
    [CompilerGeneratedAttribute]
public void set_TitleOnTheLeftOfRows(string value);
    public Int32[0...,0...] get_Matrix();
    public int get_NumberOfSamples();
    public int get_NumberOfClasses();
    public int get_Samples();
    public int get_Classes();
    private void compute(int classes, Int32[] expected, Int32[] predicted);
    public Int32[] get_RowTotals();
    public Int32[] get_ColumnTotals();
    public Int32[] get_RowErrors();
    public Int32[] get_ColumnErrors();
    public Double[] get_RowProportions();
    public Double[] get_ColumnProportions();
    public Double[] get_Precision();
    public Double[] get_Recall();
    public Int32[] get_Diagonal();
    public double get_Max();
    public double get_Min();
    public Double[0...,0...] get_ProportionMatrix();
    public double get_Kappa();
    public double get_StandardError();
    public double get_Variance();
    public double get_VarianceDeltaMethod();
    public double get_VarianceUnderNull();
    public double get_StandardErrorUnderNull();
    public double get_Tau();
    public double get_Phi();
    public double get_ChiSquare();
    public double get_Tschuprow();
    public double get_Pearson();
    public double get_Sakoda();
    public double get_Cramer();
    public double get_OverallAgreement();
    public double get_Accuracy();
    public double get_Error();
    public double get_GeometricAgreement();
    public double get_ChanceAgreement();
    public Double[0...,0...] get_ExpectedValues();
    public ConfusionMatrix[] get_PerClassMatrices();
    public static GeneralConfusionMatrix Combine(GeneralConfusionMatrix[] matrices);
    public static GeneralConfusionMatrix Estimate(IClassifier`2<TInput, int> classifier, TInput[] inputs, Int32[] expected);
    public static GeneralConfusionMatrix Estimate(IClassifier`2<TInput, bool> classifier, TInput[] inputs, Boolean[] expected);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.GoodnessOfFit : object {
    private DistributionAnalysis analysis;
    private int index;
    [BrowsableAttribute("False")]
public DistributionAnalysis Analysis { get; }
    public int Index { get; }
    public string Name { get; }
    public IFittableDistribution`1<double> Distribution { get; }
    public double KolmogorovSmirnov { get; }
    public int KolmogorovSmirnovRank { get; }
    public double ChiSquare { get; }
    public int ChiSquareRank { get; }
    public double AndersonDarling { get; }
    public int AndersonDarlingRank { get; }
    internal GoodnessOfFit(DistributionAnalysis analysis, int index);
    public DistributionAnalysis get_Analysis();
    public int get_Index();
    public string get_Name();
    public IFittableDistribution`1<double> get_Distribution();
    public double get_KolmogorovSmirnov();
    public int get_KolmogorovSmirnovRank();
    public double get_ChiSquare();
    public int get_ChiSquareRank();
    public double get_AndersonDarling();
    public int get_AndersonDarlingRank();
    public sealed virtual int CompareTo(GoodnessOfFit other);
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.GoodnessOfFitCollection : ReadOnlyKeyedCollection`2<string, GoodnessOfFit> {
    internal GoodnessOfFitCollection(IList`1<GoodnessOfFit> components);
    protected virtual string GetKeyForItem(GoodnessOfFit item);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.HazardCoefficient : object {
    private ProportionalHazardsAnalysis analysis;
    private int index;
    public string Name { get; }
    [DisplayNameAttribute("Hazard ratio")]
public double HazardRatio { get; }
    [DisplayNameAttribute("Std. Error")]
public double StandardError { get; }
    [BrowsableAttribute("False")]
public DoubleRange Confidence { get; }
    [DisplayNameAttribute("Upper confidence limit")]
public double ConfidenceUpper { get; }
    [DisplayNameAttribute("Lower confidence limit")]
public double ConfidenceLower { get; }
    [DisplayNameAttribute("Value")]
public double Value { get; }
    [DisplayNameAttribute("Wald p-value")]
public WaldTest Wald { get; }
    [DisplayNameAttribute("Likelihood-Ratio p-value")]
public ChiSquareTest LikelihoodRatio { get; }
    internal HazardCoefficient(ProportionalHazardsAnalysis analysis, int index);
    public string get_Name();
    public double get_HazardRatio();
    public double get_StandardError();
    public DoubleRange get_Confidence();
    public double get_ConfidenceUpper();
    public double get_ConfidenceLower();
    public double get_Value();
    public WaldTest get_Wald();
    public ChiSquareTest get_LikelihoodRatio();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.HazardCoefficientCollection : ReadOnlyCollection`1<HazardCoefficient> {
    internal HazardCoefficientCollection(IList`1<HazardCoefficient> coefficients);
}
[ObsoleteAttribute]
public interface Accord.Statistics.Analysis.IAnalysis {
    public abstract virtual void Compute();
}
public interface Accord.Statistics.Analysis.IAnalysisComponent {
    public int Index { get; }
    public double Proportion { get; }
    public double CumulativeProportion { get; }
    public abstract virtual int get_Index();
    public abstract virtual double get_Proportion();
    public abstract virtual double get_CumulativeProportion();
}
public interface Accord.Statistics.Analysis.IDescriptiveMeasures {
    public int Index { get; }
    public string Name { get; }
    public double Sum { get; }
    public double Mean { get; }
    public double StandardDeviation { get; }
    public double Median { get; }
    public DoubleRange OuterFence { get; }
    public DoubleRange InnerFence { get; }
    public DoubleRange Quartiles { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Skewness { get; }
    public double Kurtosis { get; }
    public double StandardError { get; }
    public double Max { get; }
    public double Min { get; }
    public double Length { get; }
    public int Distinct { get; }
    public int Count { get; }
    public DoubleRange Confidence { get; }
    public DoubleRange Deviance { get; }
    public Double[] Samples { get; }
    public abstract virtual int get_Index();
    public abstract virtual string get_Name();
    public abstract virtual double get_Sum();
    public abstract virtual double get_Mean();
    public abstract virtual double get_StandardDeviation();
    public abstract virtual double get_Median();
    public abstract virtual DoubleRange get_OuterFence();
    public abstract virtual DoubleRange get_InnerFence();
    public abstract virtual DoubleRange get_Quartiles();
    public abstract virtual double get_Mode();
    public abstract virtual double get_Variance();
    public abstract virtual double get_Skewness();
    public abstract virtual double get_Kurtosis();
    public abstract virtual double get_StandardError();
    public abstract virtual double get_Max();
    public abstract virtual double get_Min();
    public abstract virtual double get_Length();
    public abstract virtual int get_Distinct();
    public abstract virtual int get_Count();
    public abstract virtual DoubleRange get_Confidence();
    public abstract virtual DoubleRange get_Deviance();
    public abstract virtual Double[] get_Samples();
    public abstract virtual DoubleRange GetConfidenceInterval(double percent);
    public abstract virtual DoubleRange GetDevianceInterval(double percent);
}
public interface Accord.Statistics.Analysis.IDiscriminantAnalysis {
    public Int32[] Classifications { get; }
    public abstract virtual Int32[] get_Classifications();
}
[ObsoleteAttribute]
public interface Accord.Statistics.Analysis.IMultivariateAnalysis {
    public Double[0...,0...] Source { get; }
    public abstract virtual Double[0...,0...] get_Source();
}
public interface Accord.Statistics.Analysis.IMultivariateRegressionAnalysis {
    public Double[0...,0...] Output { get; }
    public abstract virtual Double[0...,0...] get_Output();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.IndependentComponent : object {
    private int index;
    private IndependentComponentAnalysis analysis;
    public int Index { get; }
    public IndependentComponentAnalysis Analysis { get; }
    public Double[] MixingVector { get; }
    public Double[] DemixingVector { get; }
    public Double[] WhiteningVector { get; }
    internal IndependentComponent(IndependentComponentAnalysis analysis, int index);
    public int get_Index();
    public IndependentComponentAnalysis get_Analysis();
    public Double[] get_MixingVector();
    public Double[] get_DemixingVector();
    public Double[] get_WhiteningVector();
}
public enum Accord.Statistics.Analysis.IndependentComponentAlgorithm : Enum {
    public int value__;
    public static IndependentComponentAlgorithm Deflation;
    public static IndependentComponentAlgorithm Parallel;
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.IndependentComponentAnalysis : MultipleTransformBase`2<Double[], double> {
    private Double[0...,0...] sourceMatrix;
    private Double[][] whiteningMatrix;
    private Double[][] mixingMatrix;
    private Double[][] revertMatrix;
    private Double[0...,0...] resultMatrix;
    private AnalysisMethod analysisMethod;
    private bool overwriteSourceMatrix;
    private Double[] columnMeans;
    private Double[] columnStdDev;
    private int maxIterations;
    private double tolerance;
    private IndependentComponentAlgorithm algorithm;
    private IContrastFunction contrast;
    private IndependentComponentCollection componentCollection;
    [NonSerializedAttribute]
private ParallelOptions parallelOptions;
    private MultivariateLinearRegression mix;
    private MultivariateLinearRegression demix;
    public ParallelOptions ParallelOptions { get; public set; }
    public CancellationToken Token { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; }
    public int Iterations { get; public set; }
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Result { get; }
    public Double[][] MixingMatrix { get; }
    public Double[][] DemixingMatrix { get; }
    public Double[][] WhiteningMatrix { get; }
    public IndependentComponentCollection Components { get; }
    public bool Overwrite { get; public set; }
    public IndependentComponentAlgorithm Algorithm { get; public set; }
    public AnalysisMethod Method { get; public set; }
    public IContrastFunction Contrast { get; public set; }
    public Double[] Means { get; }
    public Double[] StandardDeviation { get; }
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public IndependentComponentAnalysis(Double[0...,0...] data);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public IndependentComponentAnalysis(Double[0...,0...] data, IndependentComponentAlgorithm algorithm);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public IndependentComponentAnalysis(Double[0...,0...] data, AnalysisMethod method);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public IndependentComponentAnalysis(Double[0...,0...] data, AnalysisMethod method, IndependentComponentAlgorithm algorithm);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public IndependentComponentAnalysis(Double[][] data, AnalysisMethod method, IndependentComponentAlgorithm algorithm);
    public IndependentComponentAnalysis(AnalysisMethod method, IndependentComponentAlgorithm algorithm);
    public sealed virtual ParallelOptions get_ParallelOptions();
    public sealed virtual void set_ParallelOptions(ParallelOptions value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public sealed virtual Double[0...,0...] get_Source();
    public int get_Iterations();
    public void set_Iterations(int value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public Double[0...,0...] get_Result();
    public Double[][] get_MixingMatrix();
    public Double[][] get_DemixingMatrix();
    public Double[][] get_WhiteningMatrix();
    public IndependentComponentCollection get_Components();
    public bool get_Overwrite();
    public void set_Overwrite(bool value);
    public IndependentComponentAlgorithm get_Algorithm();
    public void set_Algorithm(IndependentComponentAlgorithm value);
    public AnalysisMethod get_Method();
    public void set_Method(AnalysisMethod value);
    public IContrastFunction get_Contrast();
    public void set_Contrast(IContrastFunction value);
    public Double[] get_Means();
    public Double[] get_StandardDeviation();
    [ObsoleteAttribute("Please use Learn instead.")]
public sealed virtual void Compute();
    [ObsoleteAttribute("Please set NumberOfOutputs to the desired number of components and use Learn instead.")]
public void Compute(int components);
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public Double[0...,0...] Separate(Double[0...,0...] data);
    [ObsoleteAttribute("Please use Demix.Transform() instead.")]
public Single[][] Separate(Single[][] data);
    [ObsoleteAttribute("Please use Mix.Transform instead.")]
public Double[0...,0...] Combine(Double[0...,0...] data);
    [ObsoleteAttribute("Please use Mix.Transform instead.")]
public Single[][] Combine(Single[][] data);
    private Double[][] deflation(Double[][] X, int components, Double[][] init);
    private Double[][] parallel(Double[][] X, int components, Double[][] winit);
    private static double getMaximumAbsoluteChange(Double[][] W, Double[][] W0);
    private static double getMaximumAbsoluteChange(Double[] w, Double[] w0);
    public sealed virtual MultivariateLinearRegression Learn(Double[][] x, Double[] weights);
    private static MultivariateLinearRegression createRegression(Double[][] coef, Double[] means, Double[] stdDev, AnalysisMethod method);
    protected Single[][] Adjust(Single[][] matrix, bool inPlace);
    protected Double[][] Adjust(Double[][] matrix, bool inPlace);
    public virtual Double[] Transform(Double[] input, Double[] result);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.IndependentComponentCollection : ReadOnlyCollection`1<IndependentComponent> {
    internal IndependentComponentCollection(IndependentComponent[] components);
}
[ObsoleteAttribute]
public interface Accord.Statistics.Analysis.IProjectionAnalysis {
    public abstract virtual Double[0...,0...] Transform(Double[0...,0...] data);
    public abstract virtual Double[0...,0...] Transform(Double[0...,0...] data, int dimensions);
}
public interface Accord.Statistics.Analysis.IRegressionAnalysis {
    public Double[] Outputs { get; }
    public abstract virtual Double[] get_Outputs();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.KernelDiscriminantAnalysis : BaseDiscriminantAnalysis {
    private IKernel kernel;
    private double regularization;
    private Double[][] input;
    [CompilerGeneratedAttribute]
private Pipeline <Classifier>k__BackingField;
    public Pipeline Classifier { get; private set; }
    public Double[][] Input { get; public set; }
    public IKernel Kernel { get; public set; }
    public double Regularization { get; public set; }
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' parameters to the Learn method instead.")]
public KernelDiscriminantAnalysis(Double[0...,0...] inputs, Int32[] output, IKernel kernel);
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' parameters to the Learn method instead.")]
public KernelDiscriminantAnalysis(Double[][] inputs, Int32[] output, IKernel kernel);
    public KernelDiscriminantAnalysis(IKernel kernel);
    [CompilerGeneratedAttribute]
public Pipeline get_Classifier();
    [CompilerGeneratedAttribute]
private void set_Classifier(Pipeline value);
    public Double[][] get_Input();
    public void set_Input(Double[][] value);
    public IKernel get_Kernel();
    public void set_Kernel(IKernel value);
    public double get_Regularization();
    public void set_Regularization(double value);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public void Compute();
    private Pipeline CreateClassifier();
    public virtual Double[][] Transform(Double[][] input, Double[][] result);
    public sealed virtual Pipeline Learn(Double[][] x, Int32[] y, Double[] weights);
    [ObsoleteAttribute("Please use Classifier.Decide() instead.")]
public virtual int Classify(Double[] input);
    [ObsoleteAttribute("Please use Classifier.Decide() or Classifier.Scores() instead.")]
public virtual int Classify(Double[] input, Double[]& responses);
    [ObsoleteAttribute("Please use Classifier.Decide() instead.")]
public virtual Int32[] Classify(Double[][] inputs);
    public virtual double DiscriminantFunction(Double[] input, int classIndex);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.KernelPrincipalComponentAnalysis : BasePrincipalComponentAnalysis {
    private IKernel kernel;
    private Double[][] sourceCentered;
    private Double[] featureMean;
    private double featureGrandMean;
    private bool centerFeatureSpace;
    private double threshold;
    private bool allowReversion;
    public IKernel Kernel { get; public set; }
    public bool Center { get; public set; }
    [ObsoleteAttribute("Please set ExplainedVariance instead.")]
public double Threshold { get; public set; }
    public bool AllowReversion { get; public set; }
    public KernelPrincipalComponentAnalysis(IKernel kernel, PrincipalComponentMethod method, bool centerInFeatureSpace, int numberOfOutputs, bool whiten);
    [ObsoleteAttribute("Please pass the 'data' matrix to the Learn method instead.")]
public KernelPrincipalComponentAnalysis(Double[0...,0...] data, IKernel kernel, AnalysisMethod method, bool centerInFeatureSpace);
    [ObsoleteAttribute("Please pass the 'data' matrix to the Learn method instead.")]
public KernelPrincipalComponentAnalysis(Double[][] data, IKernel kernel, AnalysisMethod method, bool centerInFeatureSpace);
    [ObsoleteAttribute("Please pass the 'data' matrix to the Learn method instead.")]
public KernelPrincipalComponentAnalysis(Double[0...,0...] data, IKernel kernel, AnalysisMethod method);
    [ObsoleteAttribute("Please pass the 'data' matrix to the Learn method instead.")]
public KernelPrincipalComponentAnalysis(Double[][] data, IKernel kernel, AnalysisMethod method);
    [ObsoleteAttribute("Please pass the 'data' matrix to the Learn method instead.")]
public KernelPrincipalComponentAnalysis(Double[0...,0...] data, IKernel kernel);
    [ObsoleteAttribute("Please pass the 'data' matrix to the Learn method instead.")]
public KernelPrincipalComponentAnalysis(Double[][] data, IKernel kernel);
    public IKernel get_Kernel();
    public void set_Kernel(IKernel value);
    public bool get_Center();
    public void set_Center(bool value);
    public double get_Threshold();
    public void set_Threshold(double value);
    public bool get_AllowReversion();
    public void set_AllowReversion(bool value);
    [ObsoleteAttribute("Please use the Learn method instead.")]
public sealed virtual void Compute();
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public MultivariateKernelRegression Learn(Double[0...,0...] x);
    public sealed virtual MultivariateKernelRegression Learn(Double[][] x, Double[] weights);
    private MultivariateKernelRegression CreateRegression();
    [ObsoleteAttribute("Please set the desired number of components in the NumberOfOutputs property and call Learn.")]
public void Compute(int components);
    public virtual Double[][] Transform(Double[][] data, Double[][] result);
    [ObsoleteAttribute("Please use Jagged matrices instead.")]
public Double[0...,0...] Revert(Double[0...,0...] data);
    [ObsoleteAttribute("Please use Jagged matrices instead.")]
public Double[0...,0...] Revert(Double[0...,0...] data, int neighbors);
    public Double[][] Revert(Double[][] data, int neighbors);
    private sealed virtual override int Accord.MachineLearning.ITransform.get_NumberOfOutputs();
    private sealed virtual override void Accord.MachineLearning.ITransform.set_NumberOfOutputs(int value);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.LinearDiscriminantAnalysis : BaseDiscriminantAnalysis {
    [CompilerGeneratedAttribute]
private Pipeline <Classifier>k__BackingField;
    public Pipeline Classifier { get; private set; }
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' parameters to the Learn method instead.")]
public LinearDiscriminantAnalysis(Double[0...,0...] inputs, Int32[] outputs);
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' parameters to the Learn method instead.")]
public LinearDiscriminantAnalysis(Double[][] inputs, Int32[] outputs);
    [CompilerGeneratedAttribute]
public Pipeline get_Classifier();
    [CompilerGeneratedAttribute]
private void set_Classifier(Pipeline value);
    [ObsoleteAttribute("Please use the Learn method instead.")]
public virtual void Compute();
    public virtual Double[][] Transform(Double[][] input, Double[][] result);
    public sealed virtual Pipeline Learn(Double[][] x, Int32[] y, Double[] weights);
    private Pipeline CreateClassifier();
    [ObsoleteAttribute("Please use Classifier.Decide() instead.")]
public virtual int Classify(Double[] input);
    [ObsoleteAttribute("Please use Classifier.Decide() or Classifier.Scores() instead.")]
public virtual int Classify(Double[] input, Double[]& responses);
    [ObsoleteAttribute("Please use Classifier.Decide() instead.")]
public virtual Int32[] Classify(Double[][] inputs);
    public virtual double DiscriminantFunction(Double[] input, int classIndex);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.LinearRegressionCoefficient : object {
    private int index;
    private MultipleLinearRegressionAnalysis analysis;
    public int Index { get; }
    [BrowsableAttribute("False")]
public MultipleLinearRegressionAnalysis Analysis { get; }
    public string Name { get; }
    [DisplayNameAttribute("Intercept?")]
public bool IsIntercept { get; }
    [DisplayNameAttribute("Value")]
public double Value { get; }
    [DisplayNameAttribute("Std. Error")]
public double StandardError { get; }
    public TTest TTest { get; }
    public FTest FTest { get; }
    [BrowsableAttribute("False")]
public DoubleRange Confidence { get; }
    [DisplayNameAttribute("Upper confidence limit")]
public double ConfidenceUpper { get; }
    [DisplayNameAttribute("Lower confidence limit")]
public double ConfidenceLower { get; }
    internal LinearRegressionCoefficient(MultipleLinearRegressionAnalysis analysis, int index);
    public int get_Index();
    public MultipleLinearRegressionAnalysis get_Analysis();
    public string get_Name();
    public bool get_IsIntercept();
    public double get_Value();
    public double get_StandardError();
    public TTest get_TTest();
    public FTest get_FTest();
    public DoubleRange get_Confidence();
    public double get_ConfidenceUpper();
    public double get_ConfidenceLower();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.LinearRegressionCoefficientCollection : ReadOnlyCollection`1<LinearRegressionCoefficient> {
    private MultipleLinearRegressionAnalysis analysis;
    public double ConfidencePercent { get; public set; }
    internal LinearRegressionCoefficientCollection(MultipleLinearRegressionAnalysis analysis, LinearRegressionCoefficient[] components);
    public double get_ConfidencePercent();
    public void set_ConfidencePercent(double value);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.LogisticCoefficient : object {
    private LogisticRegressionAnalysis analysis;
    private int index;
    public string Name { get; }
    [DisplayNameAttribute("Odds ratio")]
public double OddsRatio { get; }
    [DisplayNameAttribute("Std. Error")]
public double StandardError { get; }
    [BrowsableAttribute("False")]
public DoubleRange Confidence { get; }
    [DisplayNameAttribute("Upper confidence limit")]
public double ConfidenceUpper { get; }
    [DisplayNameAttribute("Lower confidence limit")]
public double ConfidenceLower { get; }
    [DisplayNameAttribute("Value")]
public double Value { get; }
    [DisplayNameAttribute("Wald p-value")]
public WaldTest Wald { get; }
    [DisplayNameAttribute("Likelihood-Ratio p-value")]
public ChiSquareTest LikelihoodRatio { get; }
    internal LogisticCoefficient(LogisticRegressionAnalysis analysis, int index);
    public string get_Name();
    public double get_OddsRatio();
    public double get_StandardError();
    public DoubleRange get_Confidence();
    public double get_ConfidenceUpper();
    public double get_ConfidenceLower();
    public double get_Value();
    public WaldTest get_Wald();
    public ChiSquareTest get_LikelihoodRatio();
    public virtual string ToString();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.LogisticCoefficientCollection : ReadOnlyCollection`1<LogisticCoefficient> {
    internal LogisticCoefficientCollection(IList`1<LogisticCoefficient> coefficients);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.LogisticRegressionAnalysis : TransformBase`2<Double[], double> {
    [NonSerializedAttribute]
private CancellationToken token;
    private LogisticRegression regression;
    private Double[] coefficients;
    private Double[] standardErrors;
    private Double[] oddsRatios;
    private WaldTest[] waldTests;
    private ChiSquareTest[] ratioTests;
    private DoubleRange[] confidences;
    private double deviance;
    private double logLikelihood;
    private ChiSquareTest chiSquare;
    [ObsoleteAttribute]
private Double[][] inputData;
    [ObsoleteAttribute]
private Double[] outputData;
    [ObsoleteAttribute]
private Double[] weights;
    private String[] inputNames;
    private string outputName;
    [ObsoleteAttribute]
private Double[0...,0...] sourceMatrix;
    [ObsoleteAttribute]
private Double[] result;
    private double regularization;
    private LogisticCoefficientCollection coefficientCollection;
    private int iterations;
    private double tolerance;
    private bool innerComputed;
    [CompilerGeneratedAttribute]
private bool <ComputeInnerModels>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSamples>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[][] <InformationMatrix>k__BackingField;
    public CancellationToken Token { get; public set; }
    public int Iterations { get; public set; }
    public double Tolerance { get; public set; }
    public double Regularization { get; public set; }
    public bool ComputeInnerModels { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[][] Array { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Outputs { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Result { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Weights { get; }
    public LogisticRegression Regression { get; }
    public LogisticCoefficientCollection Coefficients { get; }
    public double LogLikelihood { get; }
    public ChiSquareTest ChiSquare { get; }
    public double Deviance { get; }
    public String[] Inputs { get; public set; }
    public string Output { get; public set; }
    public Double[] OddsRatios { get; }
    public Double[] StandardErrors { get; }
    public WaldTest[] WaldTests { get; }
    public ChiSquareTest[] LikelihoodRatioTests { get; }
    public Double[] CoefficientValues { get; }
    public DoubleRange[] Confidences { get; }
    public int NumberOfSamples { get; private set; }
    public Double[][] InformationMatrix { get; private set; }
    [ObsoleteAttribute("Please pass the inputs and outputs to the Learn method instead.")]
public LogisticRegressionAnalysis(Double[][] inputs, Double[] outputs);
    [ObsoleteAttribute("Please pass the inputs and outputs to the Learn method instead.")]
public LogisticRegressionAnalysis(Double[][] inputs, Double[] outputs, Double[] weights);
    [ObsoleteAttribute("Please pass the inputs and outputs to the Learn method instead.")]
public LogisticRegressionAnalysis(Double[][] inputs, Double[] outputs, String[] inputNames, string outputName);
    [ObsoleteAttribute("Please pass the inputs and outputs to the Learn method instead.")]
public LogisticRegressionAnalysis(Double[][] inputs, Double[] outputs, Double[] weights, String[] inputNames, string outputName);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    private void initialize(Double[][] inputs, Double[] outputs);
    public int get_Iterations();
    public void set_Iterations(int value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public double get_Regularization();
    public void set_Regularization(double value);
    [CompilerGeneratedAttribute]
public bool get_ComputeInnerModels();
    [CompilerGeneratedAttribute]
public void set_ComputeInnerModels(bool value);
    public sealed virtual Double[0...,0...] get_Source();
    public Double[][] get_Array();
    public sealed virtual Double[] get_Outputs();
    public Double[] get_Result();
    public Double[] get_Weights();
    public LogisticRegression get_Regression();
    public LogisticCoefficientCollection get_Coefficients();
    public double get_LogLikelihood();
    public ChiSquareTest get_ChiSquare();
    public double get_Deviance();
    public String[] get_Inputs();
    public void set_Inputs(String[] value);
    public string get_Output();
    public void set_Output(string value);
    public Double[] get_OddsRatios();
    public Double[] get_StandardErrors();
    public WaldTest[] get_WaldTests();
    public ChiSquareTest[] get_LikelihoodRatioTests();
    public Double[] get_CoefficientValues();
    public DoubleRange[] get_Confidences();
    [CompilerGeneratedAttribute]
public int get_NumberOfSamples();
    [CompilerGeneratedAttribute]
private void set_NumberOfSamples(int value);
    [CompilerGeneratedAttribute]
public Double[][] get_InformationMatrix();
    [CompilerGeneratedAttribute]
private void set_InformationMatrix(Double[][] value);
    [ObsoleteAttribute("This method will be removed.")]
public double GetLikelihoodRatio(GeneralizedLinearRegression model);
    public sealed virtual LogisticRegression Learn(Double[][] x, Double[] y, Double[] weights);
    public sealed virtual LogisticRegression Learn(Double[][] x, Int32[] y, Double[] weights);
    private LogisticRegression compute(Double[][] input, Double[] output, Double[] weights);
    [ObsoleteAttribute("Please use the Learn() method instead.")]
public bool Compute();
    [ObsoleteAttribute("Please use the Learn() method instead.")]
public void Compute(LogisticRegression regression);
    [ObsoleteAttribute("Please set up the Iterations and Tolerance properties and call Learn() instead.")]
public bool Compute(double limit, int maxIterations);
    [ObsoleteAttribute("Please use the Learn(x, positives, negatives) method instead.")]
public static LogisticRegressionAnalysis FromSummary(Double[][] data, Int32[] positives, Int32[] negatives);
    public LogisticRegression Learn(Double[][] x, Int32[] positives, Int32[] negatives);
    [ObsoleteAttribute]
private bool compute();
    private void computeInner(Double[][] inputData, Double[] outputData, Double[] weights);
    private void computeInformation(Double[][] inputData, Double[] outputData, Double[] weights);
    [ObsoleteAttribute("Please use the Learn method instead.")]
private sealed virtual override void Accord.Statistics.Analysis.IAnalysis.Compute();
    public virtual double Transform(Double[] input);
    public DoubleRange GetConfidenceInterval(Double[] input);
    public DoubleRange GetPredictionInterval(Double[] input);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.MultinomialCoefficient : object {
    private int index;
    private int category;
    private MultinomialLogisticRegressionAnalysis analysis;
    public int Index { get; }
    [BrowsableAttribute("False")]
public MultinomialLogisticRegressionAnalysis Analysis { get; }
    public string Class { get; }
    public string Name { get; }
    [DisplayNameAttribute("Value")]
public double Value { get; }
    [DisplayNameAttribute("Std. Error")]
public double StandardError { get; }
    [BrowsableAttribute("False")]
public DoubleRange Confidence { get; }
    [DisplayNameAttribute("Upper confidence limit")]
public double ConfidenceUpper { get; }
    [DisplayNameAttribute("Lower confidence limit")]
public double ConfidenceLower { get; }
    internal MultinomialCoefficient(MultinomialLogisticRegressionAnalysis analysis, int category, int index);
    public int get_Index();
    public MultinomialLogisticRegressionAnalysis get_Analysis();
    public string get_Class();
    public string get_Name();
    public double get_Value();
    public double get_StandardError();
    public DoubleRange get_Confidence();
    public double get_ConfidenceUpper();
    public double get_ConfidenceLower();
    public virtual string ToString();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.MultinomialCoefficientCollection : ReadOnlyCollection`1<MultinomialCoefficient> {
    internal MultinomialCoefficientCollection(MultinomialCoefficient[] components);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.MultinomialLogisticRegressionAnalysis : TransformBase`2<Double[], int> {
    [NonSerializedAttribute]
private CancellationToken token;
    private int inputCount;
    private int outputCount;
    private int coefficientCount;
    internal MultinomialLogisticRegression regression;
    private String[] inputNames;
    private String[] outputNames;
    [ObsoleteAttribute]
private Double[][] inputData;
    [ObsoleteAttribute]
private Double[][] outputData;
    [ObsoleteAttribute]
private Double[][] results;
    private Double[][] coefficients;
    private Double[][] standardErrors;
    private Double[][] oddsRatios;
    private WaldTest[][] waldTests;
    private double deviance;
    private double logLikelihood;
    private ChiSquareTest chiSquare;
    internal DoubleRange[][] confidences;
    internal double confidencePercent;
    private MultinomialCoefficientCollection coefficientCollection;
    private int iterations;
    private double tolerance;
    public CancellationToken Token { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[][] Array { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Output { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[][] Outputs { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[][] Results { get; }
    public int Iterations { get; public set; }
    public double Tolerance { get; public set; }
    public int OutputCount { get; }
    public Double[][] StandardErrors { get; }
    public MultinomialLogisticRegression Regression { get; }
    public Double[][] CoefficientValues { get; }
    public double LogLikelihood { get; }
    public ChiSquareTest ChiSquare { get; }
    public double Deviance { get; }
    public WaldTest[][] WaldTests { get; }
    [ObsoleteAttribute("Please use InputNames instead.")]
public String[] Inputs { get; public set; }
    public String[] InputNames { get; public set; }
    public String[] OutputNames { get; public set; }
    public DoubleRange[][] Confidences { get; }
    public MultinomialCoefficientCollection Coefficients { get; }
    [ObsoleteAttribute("Please pass the inputs and outputs to the Learn() method.")]
public MultinomialLogisticRegressionAnalysis(Double[][] inputs, Int32[] outputs);
    [ObsoleteAttribute("Please pass the inputs and outputs to the Learn() method.")]
public MultinomialLogisticRegressionAnalysis(Double[][] inputs, Double[][] outputs);
    [ObsoleteAttribute("Please pass the inputs and outputs to the Learn() method.")]
public MultinomialLogisticRegressionAnalysis(Double[][] inputs, Int32[] outputs, String[] inputNames, String[] outputNames);
    [ObsoleteAttribute("Please pass the inputs and outputs to the Learn() method.")]
public MultinomialLogisticRegressionAnalysis(Double[][] inputs, Double[][] outputs, String[] inputNames, String[] outputNames);
    public MultinomialLogisticRegressionAnalysis(String[] inputNames, String[] outputNames);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public Double[][] get_Array();
    public sealed virtual Double[0...,0...] get_Source();
    public sealed virtual Double[0...,0...] get_Output();
    public Double[][] get_Outputs();
    public Double[][] get_Results();
    public int get_Iterations();
    public void set_Iterations(int value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public int get_OutputCount();
    public Double[][] get_StandardErrors();
    public MultinomialLogisticRegression get_Regression();
    public Double[][] get_CoefficientValues();
    public double get_LogLikelihood();
    public ChiSquareTest get_ChiSquare();
    public double get_Deviance();
    public WaldTest[][] get_WaldTests();
    public String[] get_Inputs();
    public void set_Inputs(String[] value);
    public String[] get_InputNames();
    public void set_InputNames(String[] value);
    public String[] get_OutputNames();
    public void set_OutputNames(String[] value);
    public DoubleRange[][] get_Confidences();
    public MultinomialCoefficientCollection get_Coefficients();
    private void names(String[] inputNames, String[] outputNames);
    private void init(Double[][] inputs, Double[][] outputs);
    public MultinomialLogisticRegression Learn(Int32[][] x, Int32[][] y, Double[] weights);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Double[][] y, Double[] weights);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Int32[] y, Double[] weights);
    [ObsoleteAttribute("Please use the Learn method instead.")]
public bool Compute();
    private void computeInformation(Double[][] inputData, Double[][] outputData);
    [ObsoleteAttribute("Please use the Learn method instead.")]
private sealed virtual override void Accord.Statistics.Analysis.IAnalysis.Compute();
    public virtual int Transform(Double[] input);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.MultipleLinearRegressionAnalysis : TransformBase`2<Double[], double> {
    [NonSerializedAttribute]
private CancellationToken token;
    internal MultipleLinearRegression regression;
    private String[] inputNames;
    private string outputName;
    [ObsoleteAttribute]
private Double[][] inputData;
    [ObsoleteAttribute]
private Double[] outputData;
    [ObsoleteAttribute]
private Double[] results;
    private Double[][] informationMatrix;
    private double SSe;
    private double SSr;
    private double SSt;
    private double MSe;
    private double MSr;
    private double MSt;
    private int DFe;
    private int DFr;
    private int DFt;
    private double outputMean;
    private double stdError;
    private double rSquared;
    private double rAdjusted;
    private FTest ftest;
    private TTest ttest;
    private ZTest ztest;
    private ChiSquareTest chiSquareTest;
    internal Double[] standardErrors;
    internal DoubleRange[] confidences;
    internal double confidencePercent;
    internal TTest[] ttests;
    internal FTest[] ftests;
    private AnovaSourceCollection anovaTable;
    private LinearRegressionCoefficientCollection coefficientCollection;
    [CompilerGeneratedAttribute]
private Double[0...,0...] <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private OrdinaryLeastSquares <OrdinaryLeastSquares>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSamples>k__BackingField;
    public CancellationToken Token { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; private set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[][] Array { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Outputs { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Results { get; }
    public OrdinaryLeastSquares OrdinaryLeastSquares { get; public set; }
    public double StandardError { get; }
    public Double[][] InformationMatrix { get; }
    public double RSquared { get; }
    public int NumberOfSamples { get; private set; }
    public double RSquareAdjusted { get; }
    public FTest FTest { get; }
    public ZTest ZTest { get; }
    public ChiSquareTest ChiSquareTest { get; }
    public Double[] StandardErrors { get; }
    public MultipleLinearRegression Regression { get; }
    public Double[] CoefficientValues { get; }
    public String[] Inputs { get; public set; }
    public string Output { get; public set; }
    public DoubleRange[] Confidences { get; }
    public AnovaSourceCollection Table { get; }
    public LinearRegressionCoefficientCollection Coefficients { get; }
    public MultipleLinearRegressionAnalysis(bool intercept);
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' parameters to the Learn method instead.")]
public MultipleLinearRegressionAnalysis(Double[][] inputs, Double[] outputs, bool intercept);
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' parameters to the Learn method instead.")]
public MultipleLinearRegressionAnalysis(Double[][] inputs, Double[] outputs, String[] inputNames, string outputName, bool intercept);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    [CompilerGeneratedAttribute]
public sealed virtual Double[0...,0...] get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(Double[0...,0...] value);
    public Double[][] get_Array();
    public sealed virtual Double[] get_Outputs();
    public Double[] get_Results();
    [CompilerGeneratedAttribute]
public OrdinaryLeastSquares get_OrdinaryLeastSquares();
    [CompilerGeneratedAttribute]
public void set_OrdinaryLeastSquares(OrdinaryLeastSquares value);
    public double get_StandardError();
    public Double[][] get_InformationMatrix();
    public double get_RSquared();
    [CompilerGeneratedAttribute]
public int get_NumberOfSamples();
    [CompilerGeneratedAttribute]
private void set_NumberOfSamples(int value);
    public double get_RSquareAdjusted();
    public FTest get_FTest();
    public ZTest get_ZTest();
    public ChiSquareTest get_ChiSquareTest();
    public Double[] get_StandardErrors();
    public MultipleLinearRegression get_Regression();
    public Double[] get_CoefficientValues();
    public String[] get_Inputs();
    public void set_Inputs(String[] value);
    public string get_Output();
    public void set_Output(string value);
    public DoubleRange[] get_Confidences();
    public sealed virtual AnovaSourceCollection get_Table();
    public LinearRegressionCoefficientCollection get_Coefficients();
    private void init(Double[][] inputs, Double[] outputs);
    public sealed virtual MultipleLinearRegression Learn(Double[][] x, Double[] y, Double[] weights);
    [ObsoleteAttribute("Please use the Learn method instead.")]
public sealed virtual void Compute();
    private void compute(Double[][] x, Double[] y);
    internal void setConfidenceIntervals(double percent);
    public virtual double Transform(Double[] input);
    public DoubleRange GetPredictionInterval(Double[] input);
    public DoubleRange GetConfidenceInterval(Double[] input);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Analysis.NamespaceDoc : object {
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.NestedLogisticCoefficient : object {
    private StepwiseLogisticRegressionModel analysis;
    private int index;
    public string Name { get; }
    [DisplayNameAttribute("Odds ratio")]
public double OddsRatio { get; }
    [DisplayNameAttribute("Std. Error")]
public double StandardError { get; }
    [BrowsableAttribute("False")]
public DoubleRange Confidence { get; }
    [DisplayNameAttribute("Upper confidence limit")]
public double ConfidenceUpper { get; }
    [DisplayNameAttribute("Lower confidence limit")]
public double ConfidenceLower { get; }
    [DisplayNameAttribute("Value")]
public double Value { get; }
    [DisplayNameAttribute("Wald p-value")]
public WaldTest Wald { get; }
    [DisplayNameAttribute("Likelihood-Ratio p-value")]
public ChiSquareTest LikelihoodRatio { get; }
    internal NestedLogisticCoefficient(StepwiseLogisticRegressionModel analysis, int index);
    public string get_Name();
    public double get_OddsRatio();
    public double get_StandardError();
    public DoubleRange get_Confidence();
    public double get_ConfidenceUpper();
    public double get_ConfidenceLower();
    public double get_Value();
    public WaldTest get_Wald();
    public ChiSquareTest get_LikelihoodRatio();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.NestedLogisticCoefficientCollection : ReadOnlyCollection`1<NestedLogisticCoefficient> {
    internal NestedLogisticCoefficientCollection(IList`1<NestedLogisticCoefficient> coefficients);
}
public enum Accord.Statistics.Analysis.PartialLeastSquaresAlgorithm : Enum {
    public int value__;
    public static PartialLeastSquaresAlgorithm SIMPLS;
    public static PartialLeastSquaresAlgorithm NIPALS;
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.PartialLeastSquaresAnalysis : MultipleTransformBase`2<Double[], double> {
    [NonSerializedAttribute]
private CancellationToken token;
    [ObsoleteAttribute]
internal Double[0...,0...] sourceX;
    [ObsoleteAttribute]
internal Double[0...,0...] sourceY;
    internal Double[] meanX;
    internal Double[] meanY;
    internal Double[] stdDevX;
    internal Double[] stdDevY;
    internal Double[][] loadingsX;
    internal Double[][] loadingsY;
    internal Double[][] scoresX;
    internal Double[][] scoresY;
    private Double[][] weights;
    private Double[][] coeffbase;
    private Double[][] vip;
    internal Double[] componentProportionX;
    internal Double[] componentProportionY;
    internal Double[] cumulativeProportionX;
    internal Double[] cumulativeProportionY;
    private AnalysisMethod analysisMethod;
    private PartialLeastSquaresAlgorithm algorithm;
    private PartialLeastSquaresFactorCollection factorCollection;
    private PartialLeastSquaresVariables inputVariables;
    private PartialLeastSquaresVariables outputVariables;
    private bool overwriteSourceMatrix;
    private int numberOfFactors;
    [CompilerGeneratedAttribute]
private int <MaximumNumberOfFactors>k__BackingField;
    public CancellationToken Token { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Output { get; }
    public PartialLeastSquaresVariables Predictors { get; }
    public PartialLeastSquaresVariables Dependents { get; }
    public Double[][] Weights { get; }
    public PartialLeastSquaresFactorCollection Factors { get; }
    public PartialLeastSquaresAlgorithm Algorithm { get; public set; }
    public AnalysisMethod Method { get; public set; }
    public Double[][] Importance { get; }
    public bool Overwrite { get; public set; }
    public int NumberOfLatentFactors { get; public set; }
    public int NumberOfInputs { get; public set; }
    public int NumberOfOutputs { get; public set; }
    public int MaximumNumberOfFactors { get; private set; }
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' matrices to the Learn method instead.")]
public PartialLeastSquaresAnalysis(Double[0...,0...] inputs, Double[0...,0...] outputs);
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' matrices to the Learn method instead.")]
public PartialLeastSquaresAnalysis(Double[0...,0...] inputs, Double[0...,0...] outputs, PartialLeastSquaresAlgorithm algorithm);
    [ObsoleteAttribute("Please pass the 'inputs' and 'outputs' matrices to the Learn method instead.")]
public PartialLeastSquaresAnalysis(Double[0...,0...] inputs, Double[0...,0...] outputs, AnalysisMethod method, PartialLeastSquaresAlgorithm algorithm);
    public PartialLeastSquaresAnalysis(AnalysisMethod method, PartialLeastSquaresAlgorithm algorithm);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public sealed virtual Double[0...,0...] get_Source();
    public sealed virtual Double[0...,0...] get_Output();
    public PartialLeastSquaresVariables get_Predictors();
    public PartialLeastSquaresVariables get_Dependents();
    public Double[][] get_Weights();
    public PartialLeastSquaresFactorCollection get_Factors();
    public PartialLeastSquaresAlgorithm get_Algorithm();
    public void set_Algorithm(PartialLeastSquaresAlgorithm value);
    public AnalysisMethod get_Method();
    public void set_Method(AnalysisMethod value);
    public Double[][] get_Importance();
    public bool get_Overwrite();
    public void set_Overwrite(bool value);
    public int get_NumberOfLatentFactors();
    public void set_NumberOfLatentFactors(int value);
    public virtual int get_NumberOfInputs();
    public virtual void set_NumberOfInputs(int value);
    public virtual int get_NumberOfOutputs();
    public virtual void set_NumberOfOutputs(int value);
    [CompilerGeneratedAttribute]
public int get_MaximumNumberOfFactors();
    [CompilerGeneratedAttribute]
private void set_MaximumNumberOfFactors(int value);
    public sealed virtual MultivariateLinearRegression Learn(Double[][] x, Double[][] y, Double[] weights);
    [ObsoleteAttribute("Please use the Learn method instead.")]
public sealed virtual void Compute();
    [ObsoleteAttribute("Please set the NumberOfOutputs property and use the Learn method instead.")]
public void Compute(int factors);
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public sealed virtual Double[0...,0...] Transform(Double[0...,0...] data);
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public sealed virtual Double[0...,0...] Transform(Double[0...,0...] data, int dimensions);
    public virtual Double[][] Transform(Double[][] input, Double[][] result);
    public Double[][] TransformOutput(Double[][] outputs);
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public Double[0...,0...] TransformOutput(Double[0...,0...] outputs);
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public Double[0...,0...] TransformOutput(Double[0...,0...] outputs, int dimensions);
    public Double[][] TransformOutput(Double[][] outputs, int dimensions);
    public MultivariateLinearRegression CreateRegression();
    public MultivariateLinearRegression CreateRegression(int factors);
    private void nipals(Double[][] inputsX, Double[][] outputsY, int factors, double tolerance);
    private void simpls(Double[][] inputsX, Double[][] outputsY, int factors);
    protected Double[0...,0...] Adjust(Double[0...,0...] matrix, Double[] columnMeans, Double[] columnStdDev, bool inPlace);
    protected Double[][] Adjust(Double[][] matrix, Double[] columnMeans, Double[] columnStdDev, bool inPlace);
    private static int largest(Double[][] matrix);
    protected Double[][] ComputeVariableImportanceInProjection(int factors);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.PartialLeastSquaresFactor : object {
    private int index;
    private PartialLeastSquaresAnalysis analysis;
    public int Index { get; }
    public PartialLeastSquaresAnalysis Analysis { get; }
    public double PredictorProportion { get; }
    public double PredictorCumulativeProportion { get; }
    public double DependentProportion { get; }
    public double DependentCumulativeProportion { get; }
    public Double[] IndependentLatentVectors { get; }
    public Double[] DependentLatentVector { get; }
    public Double[] VariableImportance { get; }
    private double Accord.Statistics.Analysis.IAnalysisComponent.Proportion { get; }
    private double Accord.Statistics.Analysis.IAnalysisComponent.CumulativeProportion { get; }
    internal PartialLeastSquaresFactor(PartialLeastSquaresAnalysis analysis, int index);
    public sealed virtual int get_Index();
    public PartialLeastSquaresAnalysis get_Analysis();
    public double get_PredictorProportion();
    public double get_PredictorCumulativeProportion();
    public double get_DependentProportion();
    public double get_DependentCumulativeProportion();
    public Double[] get_IndependentLatentVectors();
    public Double[] get_DependentLatentVector();
    public Double[] get_VariableImportance();
    private sealed virtual override double Accord.Statistics.Analysis.IAnalysisComponent.get_Proportion();
    private sealed virtual override double Accord.Statistics.Analysis.IAnalysisComponent.get_CumulativeProportion();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.PartialLeastSquaresFactorCollection : ReadOnlyCollection`1<PartialLeastSquaresFactor> {
    internal PartialLeastSquaresFactorCollection(PartialLeastSquaresFactor[] components);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.PartialLeastSquaresVariables : object {
    private PartialLeastSquaresAnalysis analysis;
    private bool inputs;
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Result { get; }
    public Double[] Means { get; }
    public Double[] StandardDeviations { get; }
    public Double[][] FactorMatrix { get; }
    public Double[] FactorProportions { get; }
    public Double[] CumulativeProportions { get; }
    internal PartialLeastSquaresVariables(PartialLeastSquaresAnalysis analysis, bool inputs);
    public Double[0...,0...] get_Source();
    public Double[0...,0...] get_Result();
    public Double[] get_Means();
    public Double[] get_StandardDeviations();
    public Double[][] get_FactorMatrix();
    public Double[] get_FactorProportions();
    public Double[] get_CumulativeProportions();
    public Double[][] Transform(Double[][] data);
    [ObsoleteAttribute("Please set the analysis NumberOfOutputs to the desired number of factors.")]
public Double[][] Transform(Double[][] data, int factors);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.PrincipalComponent : object {
    private int index;
    private BasePrincipalComponentAnalysis principalComponentAnalysis;
    public int Index { get; }
    public BasePrincipalComponentAnalysis Analysis { get; }
    public double Proportion { get; }
    public double CumulativeProportion { get; }
    public double SingularValue { get; }
    public double Eigenvalue { get; }
    public Double[] Eigenvector { get; }
    internal PrincipalComponent(BasePrincipalComponentAnalysis analysis, int index);
    public sealed virtual int get_Index();
    public BasePrincipalComponentAnalysis get_Analysis();
    public sealed virtual double get_Proportion();
    public sealed virtual double get_CumulativeProportion();
    public double get_SingularValue();
    public double get_Eigenvalue();
    public Double[] get_Eigenvector();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.PrincipalComponentAnalysis : BasePrincipalComponentAnalysis {
    [ObsoleteAttribute("Please pass the 'data' matrix to the Learn method instead.")]
public PrincipalComponentAnalysis(Double[][] data, AnalysisMethod method);
    [ObsoleteAttribute("Please pass the 'data' matrix to the Learn method instead.")]
public PrincipalComponentAnalysis(Double[0...,0...] data, AnalysisMethod method);
    public PrincipalComponentAnalysis(PrincipalComponentMethod method, bool whiten, int numberOfOutputs);
    public sealed virtual MultivariateLinearRegression Learn(Double[][] x, Double[] weights);
    private MultivariateLinearRegression CreateRegression();
    [ObsoleteAttribute("Please use the Learn method instead.")]
public virtual void Compute();
    public virtual Double[][] Transform(Double[][] data, Double[][] result);
    [ObsoleteAttribute("Please use Jagged matrices instead.")]
public virtual Double[0...,0...] Revert(Double[0...,0...] data);
    public virtual Double[][] Revert(Double[][] data);
    [ObsoleteAttribute("This method is obsolete.")]
protected internal Double[0...,0...] Adjust(Double[0...,0...] matrix, bool inPlace);
    [ObsoleteAttribute("This method is obsolete.")]
protected internal Double[][] Adjust(Double[][] matrix, bool inPlace);
    public static PrincipalComponentAnalysis FromCovarianceMatrix(Double[] mean, Double[0...,0...] covariance);
    public static PrincipalComponentAnalysis FromCorrelationMatrix(Double[] mean, Double[] stdDev, Double[0...,0...] correlation);
    public static PrincipalComponentAnalysis FromGramMatrix(Double[] mean, Double[] stdDev, Double[0...,0...] kernelMatrix);
    public static Double[][] Reduce(Double[][] x, int dimensions);
    private sealed virtual override int Accord.MachineLearning.ITransform.get_NumberOfOutputs();
    private sealed virtual override void Accord.MachineLearning.ITransform.set_NumberOfOutputs(int value);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.PrincipalComponentCollection : ReadOnlyCollection`1<PrincipalComponent> {
    internal PrincipalComponentCollection(PrincipalComponent[] components);
}
public enum Accord.Statistics.Analysis.PrincipalComponentMethod : Enum {
    public int value__;
    public static PrincipalComponentMethod Center;
    public static PrincipalComponentMethod Standardize;
    public static PrincipalComponentMethod CorrelationMatrix;
    public static PrincipalComponentMethod CovarianceMatrix;
    public static PrincipalComponentMethod KernelMatrix;
}
public class Accord.Statistics.Analysis.ProcrustedDataset : object {
    [CompilerGeneratedAttribute]
private Double[0...,0...] <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[0...,0...] <Dataset>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Center>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[0...,0...] <RotationMatrix>k__BackingField;
    public Double[0...,0...] Source { get; public set; }
    public Double[0...,0...] Dataset { get; public set; }
    public Double[] Center { get; public set; }
    public double Scale { get; public set; }
    public Double[0...,0...] RotationMatrix { get; public set; }
    [CompilerGeneratedAttribute]
public Double[0...,0...] get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(Double[0...,0...] value);
    [CompilerGeneratedAttribute]
public Double[0...,0...] get_Dataset();
    [CompilerGeneratedAttribute]
public void set_Dataset(Double[0...,0...] value);
    [CompilerGeneratedAttribute]
public Double[] get_Center();
    [CompilerGeneratedAttribute]
public void set_Center(Double[] value);
    [CompilerGeneratedAttribute]
public double get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(double value);
    [CompilerGeneratedAttribute]
public Double[0...,0...] get_RotationMatrix();
    [CompilerGeneratedAttribute]
public void set_RotationMatrix(Double[0...,0...] value);
    public Double[0...,0...] Transform(ProcrustedDataset p_reference);
}
public class Accord.Statistics.Analysis.ProcrustesAnalysis : object {
    [CompilerGeneratedAttribute]
private Double[0...,0...][] <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[0...,0...] <ProcrustesDistances>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcrustedDataset[] <ProcrustedDatasets>k__BackingField;
    private Double[0...,0...][] Source { get; private set; }
    public Double[0...,0...] ProcrustesDistances { get; protected set; }
    public ProcrustedDataset[] ProcrustedDatasets { get; protected set; }
    public ProcrustesAnalysis(Double[0...,0...][] samples);
    private void CheckSampleDataArgument(Double[0...,0...][] samples);
    [CompilerGeneratedAttribute]
private Double[0...,0...][] get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(Double[0...,0...][] value);
    private Double[0...,0...] Translate(Double[0...,0...] samples);
    private Double[0...,0...] Translate(Double[0...,0...] samples, Double[] centroid);
    private Double[0...,0...] Scale(Double[0...,0...] samples);
    private double GetDatasetScale(Double[0...,0...] samples);
    private Double[0...,0...] Scale(Double[0...,0...] samples, double scale);
    private Double[0...,0...] Rotate(ProcrustedDataset p, ProcrustedDataset p_reference);
    private void UpdateProcrustesDistances(ProcrustedDataset[] p);
    private double ProcrustesDistance(Double[0...,0...] samples1, Double[0...,0...] samples2);
    [CompilerGeneratedAttribute]
public Double[0...,0...] get_ProcrustesDistances();
    [CompilerGeneratedAttribute]
protected void set_ProcrustesDistances(Double[0...,0...] value);
    [CompilerGeneratedAttribute]
public ProcrustedDataset[] get_ProcrustedDatasets();
    [CompilerGeneratedAttribute]
protected void set_ProcrustedDatasets(ProcrustedDataset[] value);
    private void ApplyTranslateScale(ProcrustedDataset p, Double[0...,0...] samples);
    public sealed virtual void Compute();
    public Double[0...,0...] Compute(Double[0...,0...][] samples);
    public Double[0...,0...] Compute(int reference_sample_index, Double[0...,0...][] samples);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.ProportionalHazardsAnalysis : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private ProportionalHazards regression;
    private int inputCount;
    private Double[] coefficients;
    private Double[] standardErrors;
    private Double[] hazardRatios;
    private WaldTest[] waldTests;
    private ChiSquareTest[] ratioTests;
    private DoubleRange[] confidences;
    private double deviance;
    private double logLikelihood;
    private ChiSquareTest chiSquare;
    private Double[][] inputData;
    private Double[] timeData;
    private SurvivalOutcome[] censorData;
    private String[] inputNames;
    private string timeName;
    private string censorName;
    private Double[0...,0...] source;
    private Double[] result;
    private HazardCoefficientCollection coefficientCollection;
    private int iterations;
    private double tolerance;
    private bool innerComputed;
    public CancellationToken Token { get; public set; }
    public int Iterations { get; public set; }
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[0...,0...] Source { get; }
    public Double[] TimeToEvent { get; }
    public SurvivalOutcome[] Events { get; }
    public Double[] Outputs { get; }
    [ObsoleteAttribute("This property will be removed.")]
public Double[] Result { get; }
    public ProportionalHazards Regression { get; }
    public ReadOnlyCollection`1<HazardCoefficient> Coefficients { get; }
    public double LogLikelihood { get; }
    public ChiSquareTest ChiSquare { get; }
    public double Deviance { get; }
    public String[] InputNames { get; public set; }
    public string TimeName { get; public set; }
    public string EventName { get; public set; }
    public Double[] HazardRatios { get; }
    public Double[] StandardErrors { get; }
    public WaldTest[] WaldTests { get; }
    public ChiSquareTest[] LikelihoodRatioTests { get; }
    public Double[] CoefficientValues { get; }
    public DoubleRange[] Confidences { get; }
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public ProportionalHazardsAnalysis(Double[0...,0...] inputs, Double[] times, Int32[] censor);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public ProportionalHazardsAnalysis(Double[][] inputs, Double[] times, Int32[] censor);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public ProportionalHazardsAnalysis(Double[][] inputs, Double[] times, Int32[] censor, String[] inputNames, string timeName, string censorName);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public ProportionalHazardsAnalysis(Double[0...,0...] inputs, Double[] times, SurvivalOutcome[] censor);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public ProportionalHazardsAnalysis(Double[][] inputs, Double[] times, SurvivalOutcome[] censor);
    [ObsoleteAttribute("Please do not pass data to this constructor, and use the Learn method instead.")]
public ProportionalHazardsAnalysis(Double[][] inputs, Double[] times, SurvivalOutcome[] censor, String[] inputNames, string timeName, string censorName);
    public ProportionalHazardsAnalysis(String[] inputNames, string timeName, string censorName);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    private void initialize(Double[][] inputs, Double[] outputs, SurvivalOutcome[] censor);
    public int get_Iterations();
    public void set_Iterations(int value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public sealed virtual Double[0...,0...] get_Source();
    public Double[] get_TimeToEvent();
    public SurvivalOutcome[] get_Events();
    public sealed virtual Double[] get_Outputs();
    public Double[] get_Result();
    public ProportionalHazards get_Regression();
    public ReadOnlyCollection`1<HazardCoefficient> get_Coefficients();
    public double get_LogLikelihood();
    public ChiSquareTest get_ChiSquare();
    public double get_Deviance();
    public String[] get_InputNames();
    public void set_InputNames(String[] value);
    public string get_TimeName();
    public void set_TimeName(string value);
    public string get_EventName();
    public void set_EventName(string value);
    public Double[] get_HazardRatios();
    public Double[] get_StandardErrors();
    public WaldTest[] get_WaldTests();
    public ChiSquareTest[] get_LikelihoodRatioTests();
    public Double[] get_CoefficientValues();
    public DoubleRange[] get_Confidences();
    public double GetLikelihoodRatio(ProportionalHazards model);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public void Compute(ProportionalHazards regression);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public bool Compute();
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public bool Compute(double limit, int maxIterations);
    private bool compute();
    private void computeInner();
    private void computeInformation();
    [ObsoleteAttribute("Please use the Learn method instead.")]
private sealed virtual override void Accord.Statistics.Analysis.IAnalysis.Compute();
    public ProportionalHazards Learn(Double[][] inputs, Double[] time, SurvivalOutcome[] censor, Double[] weights);
    public ProportionalHazards Learn(Double[][] inputs, Double[] time, Int32[] censor, Double[] weights);
    public sealed virtual ProportionalHazards Learn(Tuple`2[] x, Int32[] y, Double[] weights);
    public ProportionalHazards Learn(Tuple`2[] x, SurvivalOutcome[] y, Double[] weights);
    private ProportionalHazardsNewtonRaphson createLearner(ProportionalHazards model);
    private ProportionalHazards store();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.ReceiverOperatingCharacteristic : object {
    private double area;
    private double error;
    private Double[] measurement;
    private Double[] prediction;
    private Double[] positiveResults;
    private Double[] negativeResults;
    private Double[] positiveAccuracy;
    private Double[] negativeAccuracy;
    private int positiveCount;
    private int negativeCount;
    private double dtrue;
    private double dfalse;
    private double min;
    private double max;
    private ReceiverOperatingCharacteristicPointCollection collection;
    public ReceiverOperatingCharacteristicPointCollection Points { get; }
    public int Positives { get; }
    public int Negatives { get; }
    public int Observations { get; }
    public double Area { get; }
    public double StandardError { get; }
    public double Variance { get; }
    public Double[] Expected { get; }
    public Double[] Actual { get; }
    public Double[] PositiveResults { get; }
    public Double[] NegativeResults { get; }
    public Double[] PositiveAccuracies { get; }
    public Double[] NegativeAccuracies { get; }
    public ReceiverOperatingCharacteristic(Boolean[] expected, Int32[] actual);
    public ReceiverOperatingCharacteristic(Int32[] expected, Double[] actual);
    public ReceiverOperatingCharacteristic(Double[] expected, Double[] actual);
    private void init(Double[] expected, Double[] actual);
    public ReceiverOperatingCharacteristicPointCollection get_Points();
    public int get_Positives();
    public int get_Negatives();
    public int get_Observations();
    public double get_Area();
    public double get_StandardError();
    public double get_Variance();
    public Double[] get_Expected();
    public Double[] get_Actual();
    public Double[] get_PositiveResults();
    public Double[] get_NegativeResults();
    public Double[] get_PositiveAccuracies();
    public Double[] get_NegativeAccuracies();
    public void Compute(int points);
    public void Compute(double increment);
    public void Compute(double increment, bool forceOrigin);
    public void Compute(Double[] cutpoints);
    private static int order(ReceiverOperatingCharacteristicPoint a, ReceiverOperatingCharacteristicPoint b);
    public ReceiverOperatingCharacteristicPoint ComputePoint(double threshold);
    public Scatterplot GetScatterplot(bool includeRandom);
    public virtual string ToString();
    private double calculateAreaUnderCurve();
    private double calculateStandardError();
    private void calculatePlacements();
    private static double v(double x, Double[] y);
    [OnDeserializedAttribute]
private void onDeserialized(StreamingContext context);
    [OnDeserializingAttribute]
private void onDeserializing(StreamingContext context);
    public void Save(Stream stream);
    public static ReceiverOperatingCharacteristic Load(Stream stream);
    public static ReceiverOperatingCharacteristic Load(string path);
    public void Save(string path);
    [CompilerGeneratedAttribute]
private bool <calculatePlacements>b__55_0(double x);
    [CompilerGeneratedAttribute]
private bool <calculatePlacements>b__55_1(double x);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.ReceiverOperatingCharacteristicPoint : ConfusionMatrix {
    private double cutoff;
    public double Cutoff { get; }
    internal ReceiverOperatingCharacteristicPoint(double cutoff, int truePositives, int falseNegatives, int falsePositives, int trueNegatives);
    public double get_Cutoff();
    public virtual string ToString();
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.ReceiverOperatingCharacteristicPointCollection : ReadOnlyCollection`1<ReceiverOperatingCharacteristicPoint> {
    internal ReceiverOperatingCharacteristicPointCollection(ReceiverOperatingCharacteristicPoint[] points);
    public Double[][] GetXYValues();
    public Double[] GetOneMinusSpecificity();
    public Double[] GetSensitivity();
    public virtual string ToString();
}
public enum Accord.Statistics.Analysis.RocAreaMethod : Enum {
    public int value__;
    public static RocAreaMethod DeLong;
    public static RocAreaMethod HanleyMcNeil;
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.StepwiseLogisticRegressionAnalysis : object {
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    private Double[][] inputData;
    private Double[] outputData;
    private String[] inputNames;
    private string outputName;
    private Double[0...,0...] source;
    private Double[] result;
    private Int32[] resultVariables;
    private StepwiseLogisticRegressionModel currentModel;
    private StepwiseLogisticRegressionModel completeModel;
    private StepwiseLogisticRegressionModelCollection nestedModelCollection;
    private double fullLikelihood;
    private double threshold;
    private int iterations;
    private double tolerance;
    public CancellationToken Token { get; public set; }
    public int Iterations { get; public set; }
    public double Tolerance { get; public set; }
    public Double[0...,0...] Source { get; }
    public Double[] Outputs { get; }
    public Double[] Result { get; }
    public StepwiseLogisticRegressionModel Current { get; }
    public StepwiseLogisticRegressionModel Complete { get; }
    public StepwiseLogisticRegressionModelCollection Nested { get; }
    public String[] Inputs { get; public set; }
    public string Output { get; public set; }
    public double Threshold { get; public set; }
    public Int32[] Variables { get; }
    public StepwiseLogisticRegressionAnalysis(Double[][] inputs, Double[] outputs);
    public StepwiseLogisticRegressionAnalysis(Double[][] inputs, Double[] outputs, String[] inputNames, string outputName);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Token(CancellationToken value);
    public int get_Iterations();
    public void set_Iterations(int value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public sealed virtual Double[0...,0...] get_Source();
    public sealed virtual Double[] get_Outputs();
    public Double[] get_Result();
    public StepwiseLogisticRegressionModel get_Current();
    public StepwiseLogisticRegressionModel get_Complete();
    public StepwiseLogisticRegressionModelCollection get_Nested();
    public String[] get_Inputs();
    public void set_Inputs(String[] value);
    public string get_Output();
    public void set_Output(string value);
    public double get_Threshold();
    public void set_Threshold(double value);
    public Int32[] get_Variables();
    public sealed virtual LogisticRegression Learn(Double[][] x, Double[] y, Double[] weights);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual void Compute();
    public int DoStep();
    private bool fit(LogisticRegression regression, Double[][] input, Double[] output);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.StepwiseLogisticRegressionModel : object {
    [CompilerGeneratedAttribute]
private NestedLogisticCoefficientCollection <Coefficients>k__BackingField;
    [CompilerGeneratedAttribute]
private StepwiseLogisticRegressionAnalysis <Analysis>k__BackingField;
    [CompilerGeneratedAttribute]
private LogisticRegression <Regression>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Names>k__BackingField;
    [CompilerGeneratedAttribute]
private ChiSquareTest <ChiSquare>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <OddsRatios>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <StandardErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private WaldTest[] <WaldTests>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <CoefficientValues>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange[] <Confidences>k__BackingField;
    [CompilerGeneratedAttribute]
private ChiSquareTest[] <LikelihoodRatioTests>k__BackingField;
    [BrowsableAttribute("False")]
public NestedLogisticCoefficientCollection Coefficients { get; private set; }
    [BrowsableAttribute("False")]
public StepwiseLogisticRegressionAnalysis Analysis { get; private set; }
    [BrowsableAttribute("False")]
public LogisticRegression Regression { get; private set; }
    [BrowsableAttribute("False")]
public Int32[] Variables { get; private set; }
    [DisplayNameAttribute("Inputs")]
public string Names { get; private set; }
    [DisplayNameAttribute("Likelihood-ratio")]
public ChiSquareTest ChiSquare { get; private set; }
    [BrowsableAttribute("False")]
public String[] Inputs { get; private set; }
    [BrowsableAttribute("False")]
public Double[] OddsRatios { get; private set; }
    [BrowsableAttribute("False")]
public Double[] StandardErrors { get; internal set; }
    [BrowsableAttribute("False")]
public WaldTest[] WaldTests { get; internal set; }
    [BrowsableAttribute("False")]
public Double[] CoefficientValues { get; private set; }
    [BrowsableAttribute("False")]
public DoubleRange[] Confidences { get; private set; }
    [BrowsableAttribute("False")]
public ChiSquareTest[] LikelihoodRatioTests { get; private set; }
    internal StepwiseLogisticRegressionModel(StepwiseLogisticRegressionAnalysis analysis, LogisticRegression regression, Int32[] variables, ChiSquareTest chiSquare, ChiSquareTest[] tests);
    [CompilerGeneratedAttribute]
public NestedLogisticCoefficientCollection get_Coefficients();
    [CompilerGeneratedAttribute]
private void set_Coefficients(NestedLogisticCoefficientCollection value);
    [CompilerGeneratedAttribute]
public StepwiseLogisticRegressionAnalysis get_Analysis();
    [CompilerGeneratedAttribute]
private void set_Analysis(StepwiseLogisticRegressionAnalysis value);
    [CompilerGeneratedAttribute]
public LogisticRegression get_Regression();
    [CompilerGeneratedAttribute]
private void set_Regression(LogisticRegression value);
    [CompilerGeneratedAttribute]
public Int32[] get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(Int32[] value);
    [CompilerGeneratedAttribute]
public string get_Names();
    [CompilerGeneratedAttribute]
private void set_Names(string value);
    [CompilerGeneratedAttribute]
public ChiSquareTest get_ChiSquare();
    [CompilerGeneratedAttribute]
private void set_ChiSquare(ChiSquareTest value);
    [CompilerGeneratedAttribute]
public String[] get_Inputs();
    [CompilerGeneratedAttribute]
private void set_Inputs(String[] value);
    [CompilerGeneratedAttribute]
public Double[] get_OddsRatios();
    [CompilerGeneratedAttribute]
private void set_OddsRatios(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_StandardErrors();
    [CompilerGeneratedAttribute]
internal void set_StandardErrors(Double[] value);
    [CompilerGeneratedAttribute]
public WaldTest[] get_WaldTests();
    [CompilerGeneratedAttribute]
internal void set_WaldTests(WaldTest[] value);
    [CompilerGeneratedAttribute]
public Double[] get_CoefficientValues();
    [CompilerGeneratedAttribute]
private void set_CoefficientValues(Double[] value);
    [CompilerGeneratedAttribute]
public DoubleRange[] get_Confidences();
    [CompilerGeneratedAttribute]
private void set_Confidences(DoubleRange[] value);
    [CompilerGeneratedAttribute]
public ChiSquareTest[] get_LikelihoodRatioTests();
    [CompilerGeneratedAttribute]
private void set_LikelihoodRatioTests(ChiSquareTest[] value);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.StepwiseLogisticRegressionModelCollection : ReadOnlyCollection`1<StepwiseLogisticRegressionModel> {
    internal StepwiseLogisticRegressionModelCollection(StepwiseLogisticRegressionModel[] models);
}
[SerializableAttribute]
public class Accord.Statistics.Analysis.WeightedConfusionMatrix : GeneralConfusionMatrix {
    private Double[0...,0...] weights;
    private Double[] weightedRowProportion;
    private Double[] weightedColProportion;
    private Nullable`1<double> kappa;
    private Nullable`1<double> kappaStdError;
    private Nullable`1<double> kappaVariance;
    private Nullable`1<double> kappaStdError0;
    private Nullable`1<double> kappaVariance0;
    public Double[0...,0...] Weights { get; }
    [DisplayNameAttribute("Weighted Row Proportions")]
public Double[] WeightedRowProportions { get; }
    [DisplayNameAttribute("Weighted Column Proportions")]
public Double[] WeightedColumnProportions { get; }
    [DisplayNameAttribute("Kappa Coefficient ()")]
public double WeightedKappa { get; }
    [DisplayNameAttribute("Kappa () Std. Error")]
public double WeightedStandardError { get; }
    [DisplayNameAttribute("Kappa () Variance")]
public double WeightedVariance { get; }
    [DisplayNameAttribute("Kappa () H Variance")]
public double WeightedVarianceUnderNull { get; }
    [DisplayNameAttribute("Kappa () H Std. Error")]
public double WeightedStandardErrorUnderNull { get; }
    [DisplayNameAttribute("Overall Agreement")]
public double WeightedOverallAgreement { get; }
    [DisplayNameAttribute("Chance Agreement")]
public double WeightedChanceAgreement { get; }
    public WeightedConfusionMatrix(Double[0...,0...] matrix, Double[0...,0...] weights, int samples);
    public WeightedConfusionMatrix(Int32[0...,0...] matrix, Double[0...,0...] weights);
    public WeightedConfusionMatrix(Double[0...,0...] weights, Int32[] expected, Int32[] predicted);
    public Double[0...,0...] get_Weights();
    public Double[] get_WeightedRowProportions();
    public Double[] get_WeightedColumnProportions();
    public double get_WeightedKappa();
    public double get_WeightedStandardError();
    public double get_WeightedVariance();
    public double get_WeightedVarianceUnderNull();
    public double get_WeightedStandardErrorUnderNull();
    public double get_WeightedOverallAgreement();
    public double get_WeightedChanceAgreement();
    public static WeightedConfusionMatrix LinearWeighting(Int32[0...,0...] matrix);
    public static WeightedConfusionMatrix QuadraticWeighting(Int32[0...,0...] matrix);
}
[ExtensionAttribute]
public static class Accord.Statistics.Circular : object {
    [ExtensionAttribute]
public static Double[] ToRadians(Double[] samples, double length, bool inPlace);
    [ExtensionAttribute]
public static double ToRadians(double sample, double length);
    [ExtensionAttribute]
public static double ToCircular(double angle, double length, bool wrap);
    public static void Sum(Double[] angles, Double& cos, Double& sin);
    public static double Mean(Double[] angles);
    public static double Mean(Double[] samples, double length);
    public static double Mean(int samples, double cos, double sin);
    public static double Resultant(Double[] angles);
    public static double Resultant(Double[] samples, double length);
    public static double Resultant(int samples, double cos, double sin);
    public static double Variance(Double[] samples, double length);
    public static double Variance(Double[] angles);
    public static double Variance(int samples, double cos, double sin);
    public static double StandardDeviation(Double[] samples, double length);
    public static double StandardDeviation(Double[] angles);
    public static double StandardDeviation(int samples, double cos, double sin);
    public static double AngularDeviation(Double[] samples, double length);
    public static double AngularDeviation(Double[] angles);
    public static double AngularDeviation(int samples, double cos, double sin);
    public static double StandardError(Double[] samples, double length, double alpha);
    public static double StandardError(Double[] angles, double alpha);
    public static double StandardError(int samples, double cos, double sin, double alpha);
    public static double Distance(double x, double y);
    public static double Distance(double x, double y, double length);
    public static double Distance(double cosx, double sinx, double cosy, double siny);
    public static double Median(Double[] samples, double length);
    public static double Median(Double[] angles);
    public static double Quartiles(Double[] samples, double length, Double& q1, Double& q3, bool wrap, QuantileMethod type);
    public static double Quartiles(Double[] samples, double length, Double& q1, Double& q3, double median, bool wrap, QuantileMethod type);
    public static double Quartiles(Double[] angles, Double& q1, Double& q3, bool wrap, QuantileMethod type);
    public static double Quartiles(Double[] samples, double length, DoubleRange& range, bool wrap, QuantileMethod type);
    public static double Quartiles(Double[] samples, double length, DoubleRange& range, double median, bool wrap, QuantileMethod type);
    public static double Quartiles(Double[] angles, DoubleRange& range, bool wrap, QuantileMethod type);
    public static double Quartiles(Double[] angles, DoubleRange& range, double median, bool wrap, QuantileMethod type);
    public static double Quartiles(Double[] angles, Double& q1, Double& q3, double median, bool wrap, QuantileMethod type);
    public static double Concentration(Double[] angles);
    public static double Concentration(Double[] angles, double mean);
    public static double WeightedMean(Double[] angles, Double[] weights);
    public static double WeightedConcentration(Double[] angles, Double[] weights);
    public static double WeightedConcentration(Double[] angles, Double[] weights, double mean);
    private static double estimateKappa(double r);
    public static double Skewness(Double[] angles);
    public static double Kurtosis(Double[] angles);
    public static Complex CentralMoments(Double[] angles, int order);
    public static Complex NoncentralMoments(Double[] angles, int order);
}
public interface Accord.Statistics.Distances.IDivergence`1 {
}
public interface Accord.Statistics.Distances.IDivergence`2 {
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.DensityKernels.EpanechnikovKernel : object {
    private double constant;
    public double Constant { get; public set; }
    public EpanechnikovKernel(double constant);
    public EpanechnikovKernel(int dimension);
    public double get_Constant();
    public void set_Constant(double value);
    public sealed virtual double Function(Double[] x);
    public sealed virtual double Profile(double x);
    public sealed virtual double Derivative(double x);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.DensityKernels.GaussianKernel : object {
    private double constant;
    public double Constant { get; public set; }
    public GaussianKernel(int dimension);
    public GaussianKernel(double constant);
    public double get_Constant();
    public void set_Constant(double value);
    public sealed virtual double Function(Double[] x);
    public sealed virtual double Profile(double x);
    public sealed virtual double Derivative(double x);
}
public interface Accord.Statistics.Distributions.DensityKernels.IDensityKernel {
    public abstract virtual double Function(Double[] x);
}
public interface Accord.Statistics.Distributions.DensityKernels.IRadiallySymmetricKernel {
    public abstract virtual double Profile(double x);
    public abstract virtual double Derivative(double x);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Distributions.DensityKernels.NamespaceDoc : object {
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.DensityKernels.UniformKernel : object {
    private double constant;
    public double Constant { get; public set; }
    public UniformKernel(double constant);
    public double get_Constant();
    public void set_Constant(double value);
    public sealed virtual double Function(Double[] x);
    public sealed virtual double Profile(double x);
    public sealed virtual double Derivative(double x);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Distributions.DistributionBase : object {
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
    public abstract virtual object Clone();
}
public enum Accord.Statistics.Distributions.Fitting.BetaEstimationMethod : Enum {
    public int value__;
    public static BetaEstimationMethod Moments;
    public static BetaEstimationMethod MaximumLikelihood;
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.BetaOptions : object {
    [CompilerGeneratedAttribute]
private BetaEstimationMethod <Method>k__BackingField;
    public BetaEstimationMethod Method { get; public set; }
    [CompilerGeneratedAttribute]
public BetaEstimationMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(BetaEstimationMethod value);
    public sealed virtual object Clone();
}
public enum Accord.Statistics.Distributions.Fitting.BetaPertMethod : Enum {
    public int value__;
    public static BetaPertMethod Classic;
    public static BetaPertMethod Vose;
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.CauchyOptions : object {
    [CompilerGeneratedAttribute]
private bool <MaximumLikelihood>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EstimateScale>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EstimateLocation>k__BackingField;
    public bool MaximumLikelihood { get; public set; }
    public bool EstimateScale { get; public set; }
    public bool EstimateLocation { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_MaximumLikelihood();
    [CompilerGeneratedAttribute]
public void set_MaximumLikelihood(bool value);
    [CompilerGeneratedAttribute]
public bool get_EstimateScale();
    [CompilerGeneratedAttribute]
public void set_EstimateScale(bool value);
    [CompilerGeneratedAttribute]
public bool get_EstimateLocation();
    [CompilerGeneratedAttribute]
public void set_EstimateLocation(bool value);
    public sealed virtual object Clone();
}
public class Accord.Statistics.Distributions.Fitting.EmpiricalHazardOptions : SurvivalOptions {
    public static HazardEstimator DefaultEstimator;
    public static HazardTiesMethod DefaultTies;
    [CompilerGeneratedAttribute]
private HazardEstimator <Estimator>k__BackingField;
    [CompilerGeneratedAttribute]
private HazardTiesMethod <Ties>k__BackingField;
    public HazardEstimator Estimator { get; public set; }
    public HazardTiesMethod Ties { get; public set; }
    public EmpiricalHazardOptions(HazardEstimator estimator, SurvivalOutcome[] output);
    public EmpiricalHazardOptions(HazardEstimator estimator, Int32[] output);
    public EmpiricalHazardOptions(HazardEstimator estimator, HazardTiesMethod ties, SurvivalOutcome[] outcome);
    public EmpiricalHazardOptions(HazardEstimator estimator, HazardTiesMethod ties, Int32[] output);
    [CompilerGeneratedAttribute]
public HazardEstimator get_Estimator();
    [CompilerGeneratedAttribute]
public void set_Estimator(HazardEstimator value);
    [CompilerGeneratedAttribute]
public HazardTiesMethod get_Ties();
    [CompilerGeneratedAttribute]
public void set_Ties(HazardTiesMethod value);
    public virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.EmpiricalOptions : object {
    [CompilerGeneratedAttribute]
private SmoothingRule <SmoothingRule>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InPlace>k__BackingField;
    public SmoothingRule SmoothingRule { get; public set; }
    public bool InPlace { get; public set; }
    [CompilerGeneratedAttribute]
public SmoothingRule get_SmoothingRule();
    [CompilerGeneratedAttribute]
public void set_SmoothingRule(SmoothingRule value);
    [CompilerGeneratedAttribute]
public bool get_InPlace();
    [CompilerGeneratedAttribute]
public void set_InPlace(bool value);
    public sealed virtual object Clone();
}
public class Accord.Statistics.Distributions.Fitting.ExpectationMaximization`1 : ParallelLearningBase {
    [CompilerGeneratedAttribute]
private IFittingOptions <InnerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISingleValueConvergence <Convergence>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Coefficients>k__BackingField;
    [CompilerGeneratedAttribute]
private IFittableDistribution`1[] <Distributions>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[][] <Gamma>k__BackingField;
    public IFittingOptions InnerOptions { get; public set; }
    public ISingleValueConvergence Convergence { get; public set; }
    public Double[] Coefficients { get; private set; }
    public IFittableDistribution`1[] Distributions { get; private set; }
    public Double[][] Gamma { get; private set; }
    public ExpectationMaximization`1(Double[] coefficients, IFittableDistribution`1[] distributions);
    [CompilerGeneratedAttribute]
public IFittingOptions get_InnerOptions();
    [CompilerGeneratedAttribute]
public void set_InnerOptions(IFittingOptions value);
    [CompilerGeneratedAttribute]
public ISingleValueConvergence get_Convergence();
    [CompilerGeneratedAttribute]
public void set_Convergence(ISingleValueConvergence value);
    [CompilerGeneratedAttribute]
public Double[] get_Coefficients();
    [CompilerGeneratedAttribute]
private void set_Coefficients(Double[] value);
    [CompilerGeneratedAttribute]
public IFittableDistribution`1[] get_Distributions();
    [CompilerGeneratedAttribute]
private void set_Distributions(IFittableDistribution`1[] value);
    [CompilerGeneratedAttribute]
public Double[][] get_Gamma();
    [CompilerGeneratedAttribute]
private void set_Gamma(Double[][] value);
    public double Compute(TObservation[] observations);
    public double Compute(TObservation[] observations, Double[] weights);
    private double compute(TObservation[] observations, Double[] weights);
    public static double LogLikelihood(Double[] pi, IDistribution`1[] pdf, TObservation[] observations);
    public static double LogLikelihood(Double[] pi, IDistribution`1[] pdf, TObservation[] observations, ParallelOptions parallelOptions);
    public static double LogLikelihood(Double[] pi, IDistribution`1[] pdf, TObservation[] observations, Double[] weights, double weightSum);
    public static double LogLikelihood(Double[] pi, IDistribution`1[] pdf, TObservation[] observations, Double[] weights, double weightSum, ParallelOptions parallelOptions);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.GammaOptions : object {
    [CompilerGeneratedAttribute]
private double <Tolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    public double Tolerance { get; public set; }
    public int Iterations { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Tolerance();
    [CompilerGeneratedAttribute]
public void set_Tolerance(double value);
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public void set_Iterations(int value);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.GeneralDiscreteOptions : object {
    [CompilerGeneratedAttribute]
private double <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLaplaceRule>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Regularization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePreviousValuesAsPriors>k__BackingField;
    public double Minimum { get; public set; }
    public bool UseLaplaceRule { get; public set; }
    public double Regularization { get; public set; }
    public bool UsePreviousValuesAsPriors { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(double value);
    [CompilerGeneratedAttribute]
public bool get_UseLaplaceRule();
    [CompilerGeneratedAttribute]
public void set_UseLaplaceRule(bool value);
    [CompilerGeneratedAttribute]
public double get_Regularization();
    [CompilerGeneratedAttribute]
public void set_Regularization(double value);
    [CompilerGeneratedAttribute]
public bool get_UsePreviousValuesAsPriors();
    [CompilerGeneratedAttribute]
public void set_UsePreviousValuesAsPriors(bool value);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.GeneralizedBetaOptions : object {
    [CompilerGeneratedAttribute]
private int <MinIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private BetaEstimationMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSorted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixMax>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixMin>k__BackingField;
    public int MinIndex { get; public set; }
    public int MaxIndex { get; public set; }
    public BetaEstimationMethod Method { get; public set; }
    public bool IsSorted { get; public set; }
    public bool FixMax { get; public set; }
    public bool FixMin { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MinIndex();
    [CompilerGeneratedAttribute]
public void set_MinIndex(int value);
    [CompilerGeneratedAttribute]
public int get_MaxIndex();
    [CompilerGeneratedAttribute]
public void set_MaxIndex(int value);
    [CompilerGeneratedAttribute]
public BetaEstimationMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(BetaEstimationMethod value);
    [CompilerGeneratedAttribute]
public bool get_IsSorted();
    [CompilerGeneratedAttribute]
public void set_IsSorted(bool value);
    [CompilerGeneratedAttribute]
public bool get_FixMax();
    [CompilerGeneratedAttribute]
public void set_FixMax(bool value);
    [CompilerGeneratedAttribute]
public bool get_FixMin();
    [CompilerGeneratedAttribute]
public void set_FixMin(bool value);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.HiddenMarkovOptions : object {
    [CompilerGeneratedAttribute]
private Action`3<HiddenMarkovModel, Double[][], Double[]> <Learning>k__BackingField;
    public Action`3<HiddenMarkovModel, Double[][], Double[]> Learning { get; public set; }
    [CompilerGeneratedAttribute]
public Action`3<HiddenMarkovModel, Double[][], Double[]> get_Learning();
    [CompilerGeneratedAttribute]
public void set_Learning(Action`3<HiddenMarkovModel, Double[][], Double[]> value);
    public virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.HypergeometricOptions : object {
    [CompilerGeneratedAttribute]
private HypergeometricParameter <Parameter>k__BackingField;
    public HypergeometricParameter Parameter { get; public set; }
    [CompilerGeneratedAttribute]
public HypergeometricParameter get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(HypergeometricParameter value);
    public sealed virtual object Clone();
}
public enum Accord.Statistics.Distributions.Fitting.HypergeometricParameter : Enum {
    public int value__;
    public static HypergeometricParameter PopulationSize;
    public static HypergeometricParameter PopulationSuccesses;
}
public interface Accord.Statistics.Distributions.Fitting.IComponentOptions {
    public Action`2<IDistribution[], Double[]> Postprocessing { get; public set; }
    public abstract virtual Action`2<IDistribution[], Double[]> get_Postprocessing();
    public abstract virtual void set_Postprocessing(Action`2<IDistribution[], Double[]> value);
}
public interface Accord.Statistics.Distributions.Fitting.IFittingOptions {
}
public class Accord.Statistics.Distributions.Fitting.IndependentOptions : object {
    [CompilerGeneratedAttribute]
private IFittingOptions <InnerOption>k__BackingField;
    [CompilerGeneratedAttribute]
private IFittingOptions[] <InnerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Transposed>k__BackingField;
    public IFittingOptions InnerOption { get; public set; }
    public IFittingOptions[] InnerOptions { get; public set; }
    public bool Transposed { get; public set; }
    [CompilerGeneratedAttribute]
public IFittingOptions get_InnerOption();
    [CompilerGeneratedAttribute]
public void set_InnerOption(IFittingOptions value);
    [CompilerGeneratedAttribute]
public IFittingOptions[] get_InnerOptions();
    [CompilerGeneratedAttribute]
public void set_InnerOptions(IFittingOptions[] value);
    [CompilerGeneratedAttribute]
public bool get_Transposed();
    [CompilerGeneratedAttribute]
public void set_Transposed(bool value);
    public virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.IndependentOptions`1 : IndependentOptions {
    public TOptions InnerOption { get; public set; }
    public TOptions[] InnerOptions { get; public set; }
    public TOptions get_InnerOption();
    public void set_InnerOption(TOptions value);
    public TOptions[] get_InnerOptions();
    public void set_InnerOptions(TOptions[] value);
    public virtual object Clone();
}
public class Accord.Statistics.Distributions.Fitting.LogExpectationMaximization`1 : ParallelLearningBase {
    [CompilerGeneratedAttribute]
private IFittingOptions <InnerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISingleValueConvergence <Convergence>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Coefficients>k__BackingField;
    [CompilerGeneratedAttribute]
private IFittableDistribution`1[] <Distributions>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[][] <LogGamma>k__BackingField;
    public IFittingOptions InnerOptions { get; public set; }
    public ISingleValueConvergence Convergence { get; public set; }
    public Double[] Coefficients { get; private set; }
    public IFittableDistribution`1[] Distributions { get; private set; }
    public Double[][] LogGamma { get; private set; }
    public LogExpectationMaximization`1(Double[] coefficients, IFittableDistribution`1[] distributions);
    [CompilerGeneratedAttribute]
public IFittingOptions get_InnerOptions();
    [CompilerGeneratedAttribute]
public void set_InnerOptions(IFittingOptions value);
    [CompilerGeneratedAttribute]
public ISingleValueConvergence get_Convergence();
    [CompilerGeneratedAttribute]
public void set_Convergence(ISingleValueConvergence value);
    [CompilerGeneratedAttribute]
public Double[] get_Coefficients();
    [CompilerGeneratedAttribute]
private void set_Coefficients(Double[] value);
    [CompilerGeneratedAttribute]
public IFittableDistribution`1[] get_Distributions();
    [CompilerGeneratedAttribute]
private void set_Distributions(IFittableDistribution`1[] value);
    [CompilerGeneratedAttribute]
public Double[][] get_LogGamma();
    [CompilerGeneratedAttribute]
private void set_LogGamma(Double[][] value);
    public double Compute(TObservation[] observations);
    private double compute(TObservation[] observations);
    public static double LogLikelihood(Double[] lnpi, IDistribution`1[] pdf, TObservation[] observations, ParallelOptions parallelOptions);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.MixtureOptions : object {
    [CompilerGeneratedAttribute]
private double <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    [CompilerGeneratedAttribute]
private ParallelOptions <ParallelOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IFittingOptions <InnerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Logarithm>k__BackingField;
    public double Threshold { get; public set; }
    public int MaxIterations { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public ParallelOptions ParallelOptions { get; public set; }
    public IFittingOptions InnerOptions { get; public set; }
    public bool Logarithm { get; public set; }
    public MixtureOptions(double threshold);
    public MixtureOptions(double threshold, IFittingOptions innerOptions);
    [CompilerGeneratedAttribute]
public double get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(double value);
    public int get_MaxIterations();
    public void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public void set_Iterations(int value);
    [CompilerGeneratedAttribute]
public ParallelOptions get_ParallelOptions();
    [CompilerGeneratedAttribute]
public void set_ParallelOptions(ParallelOptions value);
    [CompilerGeneratedAttribute]
public IFittingOptions get_InnerOptions();
    [CompilerGeneratedAttribute]
public void set_InnerOptions(IFittingOptions value);
    [CompilerGeneratedAttribute]
public bool get_Logarithm();
    [CompilerGeneratedAttribute]
public void set_Logarithm(bool value);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.MultivariateEmpiricalOptions : object {
    [CompilerGeneratedAttribute]
private MultivariateSmoothingRule <SmoothingRule>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InPlace>k__BackingField;
    public MultivariateSmoothingRule SmoothingRule { get; public set; }
    public bool InPlace { get; public set; }
    [CompilerGeneratedAttribute]
public MultivariateSmoothingRule get_SmoothingRule();
    [CompilerGeneratedAttribute]
public void set_SmoothingRule(MultivariateSmoothingRule value);
    [CompilerGeneratedAttribute]
public bool get_InPlace();
    [CompilerGeneratedAttribute]
public void set_InPlace(bool value);
    public sealed virtual object Clone();
}
public class Accord.Statistics.Distributions.Fitting.MultivariateSmoothingRule : MulticastDelegate {
    public MultivariateSmoothingRule(object object, IntPtr method);
    public virtual Double[0...,0...] Invoke(Double[][] observations, Double[] weights, Int32[] repeats);
    public virtual IAsyncResult BeginInvoke(Double[][] observations, Double[] weights, Int32[] repeats, AsyncCallback callback, object object);
    public virtual Double[0...,0...] EndInvoke(IAsyncResult result);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Distributions.Fitting.NamespaceDoc : object {
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.NormalOptions : object {
    [CompilerGeneratedAttribute]
private double <Regularization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Diagonal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Robust>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Shared>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IDistribution[], Double[]> <Postprocessing>k__BackingField;
    public double Regularization { get; public set; }
    public bool Diagonal { get; public set; }
    public bool Robust { get; public set; }
    public bool Shared { get; public set; }
    public Action`2<IDistribution[], Double[]> Postprocessing { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Regularization();
    [CompilerGeneratedAttribute]
public void set_Regularization(double value);
    [CompilerGeneratedAttribute]
public bool get_Diagonal();
    [CompilerGeneratedAttribute]
public void set_Diagonal(bool value);
    [CompilerGeneratedAttribute]
public bool get_Robust();
    [CompilerGeneratedAttribute]
public void set_Robust(bool value);
    [CompilerGeneratedAttribute]
public bool get_Shared();
    [CompilerGeneratedAttribute]
public void set_Shared(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Action`2<IDistribution[], Double[]> get_Postprocessing();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Postprocessing(Action`2<IDistribution[], Double[]> value);
    public sealed virtual object Clone();
}
public class Accord.Statistics.Distributions.Fitting.SmoothingRule : MulticastDelegate {
    public SmoothingRule(object object, IntPtr method);
    public virtual double Invoke(Double[] observations, Double[] weights, Int32[] repeats);
    public virtual IAsyncResult BeginInvoke(Double[] observations, Double[] weights, Int32[] repeats, AsyncCallback callback, object object);
    public virtual double EndInvoke(IAsyncResult result);
}
public class Accord.Statistics.Distributions.Fitting.SurvivalOptions : object {
    public static SurvivalEstimator DefaultSurvival;
    [CompilerGeneratedAttribute]
private SurvivalOutcome[] <Outcome>k__BackingField;
    public SurvivalOutcome[] Outcome { get; public set; }
    [CompilerGeneratedAttribute]
public SurvivalOutcome[] get_Outcome();
    [CompilerGeneratedAttribute]
public void set_Outcome(SurvivalOutcome[] value);
    public virtual object Clone();
}
public enum Accord.Statistics.Distributions.Fitting.TriangularEstimationMethod : Enum {
    public int value__;
    public static TriangularEstimationMethod MeanMaxMin;
    public static TriangularEstimationMethod Standard;
    public static TriangularEstimationMethod Bisection;
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.TriangularOptions : object {
    [CompilerGeneratedAttribute]
private int <MinIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSorted>k__BackingField;
    [CompilerGeneratedAttribute]
private TriangularEstimationMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixMax>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixMin>k__BackingField;
    public int MinIndex { get; public set; }
    public int MaxIndex { get; public set; }
    public bool IsSorted { get; public set; }
    public TriangularEstimationMethod Method { get; public set; }
    public bool FixMax { get; public set; }
    public bool FixMin { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MinIndex();
    [CompilerGeneratedAttribute]
public void set_MinIndex(int value);
    [CompilerGeneratedAttribute]
public int get_MaxIndex();
    [CompilerGeneratedAttribute]
public void set_MaxIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_IsSorted();
    [CompilerGeneratedAttribute]
public void set_IsSorted(bool value);
    [CompilerGeneratedAttribute]
public TriangularEstimationMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(TriangularEstimationMethod value);
    [CompilerGeneratedAttribute]
public bool get_FixMax();
    [CompilerGeneratedAttribute]
public void set_FixMax(bool value);
    [CompilerGeneratedAttribute]
public bool get_FixMin();
    [CompilerGeneratedAttribute]
public void set_FixMin(bool value);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Fitting.VonMisesOptions : object {
    [CompilerGeneratedAttribute]
private bool <UseBiasCorrection>k__BackingField;
    public bool UseBiasCorrection { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UseBiasCorrection();
    [CompilerGeneratedAttribute]
public void set_UseBiasCorrection(bool value);
    public sealed virtual object Clone();
}
public interface Accord.Statistics.Distributions.IDistribution {
    public abstract virtual double DistributionFunction(Double[] x);
    public abstract virtual double ProbabilityFunction(Double[] x);
    public abstract virtual double LogProbabilityFunction(Double[] x);
    public abstract virtual double ComplementaryDistributionFunction(Double[] x);
    public abstract virtual void Fit(Array observations);
    public abstract virtual void Fit(Array observations, Double[] weights);
    public abstract virtual void Fit(Array observations, Int32[] weights);
    public abstract virtual void Fit(Array observations, IFittingOptions options);
    public abstract virtual void Fit(Array observations, Double[] weights, IFittingOptions options);
    public abstract virtual void Fit(Array observations, Int32[] weights, IFittingOptions options);
}
public interface Accord.Statistics.Distributions.IDistribution`1 {
    public abstract virtual double DistributionFunction(TObservation x);
    public abstract virtual double ProbabilityFunction(TObservation x);
    public abstract virtual double LogProbabilityFunction(TObservation x);
    public abstract virtual double ComplementaryDistributionFunction(TObservation x);
}
public interface Accord.Statistics.Distributions.IFittable`1 {
    public abstract virtual void Fit(TObservations[] observations);
    public abstract virtual void Fit(TObservations[] observations, Double[] weights);
}
public interface Accord.Statistics.Distributions.IFittable`2 {
    public abstract virtual void Fit(TObservations[] observations, Double[] weights, TOptions options);
}
public interface Accord.Statistics.Distributions.IFittableDistribution`1 {
}
public interface Accord.Statistics.Distributions.IFittableDistribution`2 {
}
public interface Accord.Statistics.Distributions.IMixture`1 {
    public Double[] Coefficients { get; }
    public TDistribution[] Components { get; }
    public abstract virtual Double[] get_Coefficients();
    public abstract virtual TDistribution[] get_Components();
}
public interface Accord.Statistics.Distributions.IMultivariateDistribution {
    public int Dimension { get; }
    public Double[] Mean { get; }
    public Double[] Median { get; }
    public Double[] Mode { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public abstract virtual int get_Dimension();
    public abstract virtual Double[] get_Mean();
    public abstract virtual Double[] get_Median();
    public abstract virtual Double[] get_Mode();
    public abstract virtual Double[] get_Variance();
    public abstract virtual Double[0...,0...] get_Covariance();
}
public interface Accord.Statistics.Distributions.IMultivariateDistribution`1 {
    public int Dimension { get; }
    public Double[] Mean { get; }
    public Double[] Median { get; }
    public Double[] Mode { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public abstract virtual int get_Dimension();
    public abstract virtual Double[] get_Mean();
    public abstract virtual Double[] get_Median();
    public abstract virtual Double[] get_Mode();
    public abstract virtual Double[] get_Variance();
    public abstract virtual Double[0...,0...] get_Covariance();
}
public interface Accord.Statistics.Distributions.ISampleableDistribution`1 {
    public abstract virtual TObservations Generate(TObservations result);
    public abstract virtual TObservations Generate(TObservations result, Random source);
    public abstract virtual TObservations[] Generate(int samples, Random source);
    public abstract virtual TObservations[] Generate(int samples, TObservations[] result, Random source);
    public abstract virtual TObservations Generate(Random source);
}
public interface Accord.Statistics.Distributions.IUnivariateDistribution {
    public double Mean { get; }
    public double Variance { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public DoubleRange Quartiles { get; }
    public abstract virtual double get_Mean();
    public abstract virtual double get_Variance();
    public abstract virtual double get_Median();
    public abstract virtual double get_Mode();
    public abstract virtual double get_Entropy();
    public abstract virtual DoubleRange get_Support();
    public abstract virtual DoubleRange get_Quartiles();
    public abstract virtual DoubleRange GetRange(double percentile);
    public abstract virtual double DistributionFunction(double x);
    public abstract virtual double DistributionFunction(double a, double b);
    public abstract virtual double ProbabilityFunction(double x);
    public abstract virtual double LogProbabilityFunction(double x);
    public abstract virtual double InverseDistributionFunction(double p);
    public abstract virtual double ComplementaryDistributionFunction(double x);
    public abstract virtual double HazardFunction(double x);
    public abstract virtual double CumulativeHazardFunction(double x);
    public abstract virtual double LogCumulativeHazardFunction(double x);
    public abstract virtual double QuantileDensityFunction(double p);
}
public interface Accord.Statistics.Distributions.IUnivariateDistribution`1 {
    public double Mean { get; }
    public double Variance { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public abstract virtual double get_Mean();
    public abstract virtual double get_Variance();
    public abstract virtual double get_Median();
    public abstract virtual double get_Mode();
    public abstract virtual double get_Entropy();
    public abstract virtual DoubleRange get_Support();
    public abstract virtual TObservation InverseDistributionFunction(double p);
    public abstract virtual double HazardFunction(TObservation x);
    public abstract virtual double CumulativeHazardFunction(TObservation x);
}
public interface Accord.Statistics.Distributions.IUnivariateFittableDistribution {
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.DirichletDistribution : MultivariateContinuousDistribution {
    private Double[] alphas;
    private Double[] mean;
    private Double[0...,0...] covariance;
    private Double[] variance;
    private double constant;
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public DirichletDistribution(int dimension, double concentration);
    public DirichletDistribution(Double[] concentrations);
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerDistributionFunction(Double[] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[] x);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
public class Accord.Statistics.Distributions.Multivariate.HiddenMarkovDistribution : MultivariateDiscreteDistribution {
    private HiddenMarkovModel model;
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public IntRange[] Support { get; }
    public HiddenMarkovDistribution(HiddenMarkovModel model);
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerDistributionFunction(Int32[] x);
    public virtual IntRange[] get_Support();
    protected internal virtual double InnerProbabilityMassFunction(Int32[] x);
    protected internal virtual double InnerLogProbabilityMassFunction(Int32[] x);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public void Fit(Double[][] observations, Double[] weights, HiddenMarkovOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
public interface Accord.Statistics.Distributions.Multivariate.IMixtureComponent`1 {
    public T Component { get; }
    public double Coefficient { get; }
    public abstract virtual T get_Component();
    public abstract virtual double get_Coefficient();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.Independent : Independent`1<IUnivariateDistribution> {
    public Independent(IUnivariateDistribution[] components);
    public virtual object Clone();
}
[DefaultMemberAttribute("Item")]
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.Independent`1 : MultivariateContinuousDistribution {
    private TDistribution[] components;
    private Double[] mean;
    private Double[] variance;
    private Double[0...,0...] covariance;
    public TDistribution Item { get; public set; }
    public TDistribution[] Components { get; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public Independent`1(int dimensions);
    public Independent`1(int dimensions, Func`1<TDistribution> initializer);
    public Independent`1(int dimensions, Func`2<int, TDistribution> initializer);
    public Independent`1(int dimensions, TDistribution component);
    public Independent`1(TDistribution[] components);
    public TDistribution get_Item(int i);
    public void set_Item(int i, TDistribution value);
    public TDistribution[] get_Components();
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerDistributionFunction(Double[] x);
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[] x);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[][] observations, Double[] weights, IndependentOptions options);
    protected void Reset();
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.Independent`2 : Independent`1<TDistribution> {
    public Independent`2(int dimensions, Func`2<int, TDistribution> initializer);
    public Independent`2(int dimensions, Func`1<TDistribution> initializer);
    public Independent`2(int dimensions, TDistribution component);
    public Independent`2(TDistribution[] components);
    public sealed virtual double ProbabilityFunction(TObservation[] x);
    public sealed virtual double DistributionFunction(TObservation[] x);
    public sealed virtual double ComplementaryDistributionFunction(TObservation[] x);
    public sealed virtual double LogProbabilityFunction(TObservation[] x);
    public sealed virtual void Fit(TObservation[][] observations);
    public sealed virtual void Fit(TObservation[][] observations, Double[] weights);
    public sealed virtual void Fit(TObservation[][] observations, Double[] weights, IndependentOptions options);
    public virtual object Clone();
    public sealed virtual TObservation[] Generate(TObservation[] result);
    public sealed virtual TObservation[] Generate(TObservation[] result, Random source);
    public sealed virtual TObservation[][] Generate(int samples, TObservation[][] result);
    public sealed virtual TObservation[][] Generate(int samples, TObservation[][] result, Random source);
    private sealed virtual override TObservation[][] Accord.Math.Random.IRandomNumberGenerator<TObservation[]>.Generate(int samples);
    private sealed virtual override TObservation[] Accord.Math.Random.IRandomNumberGenerator<TObservation[]>.Generate();
    private sealed virtual override TObservation[][] Accord.Statistics.Distributions.ISampleableDistribution<TObservation[]>.Generate(int samples, Random source);
    private sealed virtual override TObservation[] Accord.Statistics.Distributions.ISampleableDistribution<TObservation[]>.Generate(Random source);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.Independent`3 : Independent`2<TDistribution, TObservation> {
    public Independent`3(int dimensions, Func`1<TDistribution> initializer);
    public Independent`3(int dimensions, Func`2<int, TDistribution> initializer);
    public Independent`3(int dimensions, TDistribution component);
    public Independent`3(TDistribution[] components);
    public sealed virtual void Fit(TObservation[][] observations, Double[] weights, IndependentOptions`1<TOptions> options);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.InverseWishartDistribution : MatrixContinuousDistribution {
    private int size;
    private double v;
    private Double[0...,0...] inverseScaleMatrix;
    private double constant;
    private double power;
    private Double[0...,0...] mean;
    private Double[] variance;
    private Double[0...,0...] covariance;
    public Double[0...,0...] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public InverseWishartDistribution(double degreesOfFreedom, Double[0...,0...] inverseScale);
    public virtual Double[0...,0...] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerDistributionFunction(Double[0...,0...] x);
    protected internal virtual double InnerProbabilityDensityFunction(Double[0...,0...] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[0...,0...] x);
    public virtual void Fit(Double[0...,0...][] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[DefaultMemberAttribute("Item")]
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.JointDistribution : MultivariateDiscreteDistribution {
    private Double[] probabilities;
    private Int32[] start;
    private Int32[] symbols;
    private Int32[] positions;
    private Double[] mean;
    public Double[] Frequencies { get; }
    public Int32[] Minimum { get; }
    public Int32[] Maximum { get; }
    public Int32[] Lengths { get; }
    [ObsoleteAttribute("Please use Lengths instead.")]
public Int32[] Symbols { get; }
    public IntRange[] Support { get; }
    public double Item { get; public set; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public JointDistribution(Int32[] symbols);
    public JointDistribution(Int32[] starts, Int32[] symbols);
    public JointDistribution(Int32[] starts, Array probabilities);
    public JointDistribution(Array probabilities);
    private JointDistribution(int dimension);
    public Double[] get_Frequencies();
    public Int32[] get_Minimum();
    public Int32[] get_Maximum();
    public Int32[] get_Lengths();
    public Int32[] get_Symbols();
    public virtual IntRange[] get_Support();
    private void init(Int32[] starts, Int32[] symbols);
    private void init(Int32[] starts, Array array);
    public double get_Item(Int32[] indices);
    public void set_Item(Int32[] indices, double value);
    private int ravel(Int32[] indices);
    private int ravel(Double[] indices);
    public static JointDistribution Uniform(int dimensions, int a, int b);
    protected internal virtual double InnerProbabilityMassFunction(Int32[] x);
    protected internal virtual double InnerLogProbabilityMassFunction(Int32[] x);
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerDistributionFunction(Int32[] x);
    private static bool lessThanOrEqual(Int32[] x, Int32[] idx);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Int32[][] observations);
    public sealed virtual void Fit(Int32[][] observations, Double[] weights);
    public sealed virtual void Fit(Int32[][] observations, Double[] weights, GeneralDiscreteOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static JointDistribution Estimate(Int32[][] values);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Distributions.Multivariate.MatrixContinuousDistribution : DistributionBase {
    private int rows;
    private int cols;
    public int Dimension { get; }
    public int NumberOfRows { get; }
    public int NumberOfColumns { get; }
    public Double[0...,0...] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public Double[0...,0...] Mode { get; }
    public Double[0...,0...] Median { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution.Mean { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution.Median { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution.Mode { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[,]>.Mean { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[,]>.Median { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[,]>.Mode { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[]>.Mean { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[]>.Median { get; }
    private Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[]>.Mode { get; }
    protected MatrixContinuousDistribution(int rows, int cols);
    public sealed virtual int get_Dimension();
    public int get_NumberOfRows();
    public int get_NumberOfColumns();
    public abstract virtual Double[0...,0...] get_Mean();
    public abstract virtual Double[] get_Variance();
    public abstract virtual Double[0...,0...] get_Covariance();
    public virtual Double[0...,0...] get_Mode();
    public virtual Double[0...,0...] get_Median();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution.get_Mean();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution.get_Median();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution.get_Mode();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[,]>.get_Mean();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[,]>.get_Median();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[,]>.get_Mode();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[]>.get_Mean();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[]>.get_Median();
    private sealed virtual override Double[] Accord.Statistics.Distributions.IMultivariateDistribution<System.Double[]>.get_Mode();
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.LogProbabilityFunction(Double[] x);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights, IFittingOptions options);
    public sealed virtual double DistributionFunction(Double[0...,0...] x);
    protected internal abstract virtual double InnerDistributionFunction(Double[0...,0...] x);
    public double ProbabilityDensityFunction(Double[0...,0...] x);
    protected internal abstract virtual double InnerProbabilityDensityFunction(Double[0...,0...] x);
    public double LogProbabilityDensityFunction(Double[0...,0...] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[0...,0...] x);
    public sealed virtual double ComplementaryDistributionFunction(Double[0...,0...] x);
    protected internal virtual double InnerComplementaryDistributionFunction(Double[0...,0...] x);
    public virtual void Fit(Double[0...,0...][] observations);
    public virtual void Fit(Double[0...,0...][] observations, Double[] weights);
    public virtual void Fit(Double[0...,0...][] observations, Int32[] weights);
    public virtual void Fit(Double[0...,0...][] observations, IFittingOptions options);
    public virtual void Fit(Double[0...,0...][] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[0...,0...][] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual Double[0...,0...][] Generate(int samples);
    public sealed virtual Double[0...,0...][] Generate(int samples, Double[0...,0...][] result);
    public sealed virtual Double[0...,0...] Generate();
    public sealed virtual Double[0...,0...] Generate(Double[0...,0...] result);
    public sealed virtual Double[0...,0...][] Generate(int samples, Random source);
    public virtual Double[0...,0...][] Generate(int samples, Double[0...,0...][] result, Random source);
    public sealed virtual Double[0...,0...] Generate(Random source);
    public sealed virtual Double[0...,0...] Generate(Double[0...,0...] result, Random source);
    public virtual Double[] Generate(Double[] result);
    public sealed virtual Double[] Generate(Double[] result, Random source);
    private sealed virtual override Double[][] Accord.Statistics.Distributions.ISampleableDistribution<System.Double[]>.Generate(int samples, Random source);
    public sealed virtual Double[][] Generate(int samples, Double[][] result, Random source);
    private sealed virtual override Double[] Accord.Statistics.Distributions.ISampleableDistribution<System.Double[]>.Generate(Random source);
    private sealed virtual override Double[][] Accord.Math.Random.IRandomNumberGenerator<System.Double[]>.Generate(int samples);
    public sealed virtual Double[][] Generate(int samples, Double[][] result);
    private sealed virtual override Double[] Accord.Math.Random.IRandomNumberGenerator<System.Double[]>.Generate();
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[,]>.ProbabilityFunction(Double[0...,0...] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[,]>.LogProbabilityFunction(Double[0...,0...] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.LogProbabilityFunction(Double[] x);
    private Double[0...,0...] reshape(Double[] x);
    public sealed virtual double DistributionFunction(Double[] x);
    public sealed virtual double ComplementaryDistributionFunction(Double[] x);
    public sealed virtual void Fit(Double[][] observations);
    public virtual void Fit(Double[][] observations, Double[] weights);
    [CompilerGeneratedAttribute]
private Double[0...,0...] <Generate>b__63_0(double x);
    [CompilerGeneratedAttribute]
private Double[0...,0...] <Fit>b__83_0(Double[] x);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.MixtureComponent`1 : ValueType {
    private IMixture`1<T> mixture;
    private int index;
    public double Coefficient { get; }
    public T Component { get; }
    public MixtureComponent`1(IMixture`1<T> mixture, int index);
    public sealed virtual double get_Coefficient();
    public sealed virtual T get_Component();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.MultinomialDistribution : MultivariateDiscreteDistribution {
    private int N;
    private Double[] probabilities;
    private double lnfac;
    private Double[] mean;
    private Double[] variance;
    private Double[0...,0...] covariance;
    public Double[] Probabilities { get; }
    public int NumberOfTrials { get; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public IntRange[] Support { get; }
    public MultinomialDistribution(int numberOfTrials, Double[] probabilities);
    private void initialize(int n, Double[] prob);
    public Double[] get_Probabilities();
    public int get_NumberOfTrials();
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    public virtual IntRange[] get_Support();
    protected internal virtual double InnerDistributionFunction(Int32[] x);
    protected internal virtual double InnerProbabilityMassFunction(Int32[] x);
    protected internal virtual double InnerLogProbabilityMassFunction(Int32[] x);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Distributions.Multivariate.MultivariateContinuousDistribution : DistributionBase {
    private int dimension;
    [NonSerializedAttribute]
private MetropolisHasting`1<double> generator;
    public int Dimension { get; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public Double[] Mode { get; }
    public Double[] Median { get; }
    protected MultivariateContinuousDistribution(int dimension);
    public sealed virtual int get_Dimension();
    public abstract virtual Double[] get_Mean();
    public abstract virtual Double[] get_Variance();
    public abstract virtual Double[0...,0...] get_Covariance();
    public virtual Double[] get_Mode();
    public virtual Double[] get_Median();
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.LogProbabilityFunction(Double[] x);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights, IFittingOptions options);
    public virtual double DistributionFunction(Double[] x);
    protected internal virtual double InnerDistributionFunction(Double[] x);
    public virtual double ProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    public virtual double LogProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[] x);
    public virtual double ComplementaryDistributionFunction(Double[] x);
    protected internal virtual double InnerComplementaryDistributionFunction(Double[] x);
    public virtual void Fit(Double[][] observations);
    public virtual void Fit(Double[][] observations, Double[] weights);
    public virtual void Fit(Double[][] observations, Int32[] weights);
    public virtual void Fit(Double[][] observations, IFittingOptions options);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[][] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual Double[][] Generate(int samples);
    public sealed virtual Double[][] Generate(int samples, Double[][] result);
    public sealed virtual Double[] Generate();
    public sealed virtual Double[] Generate(Double[] result);
    public Int32[] Generate(Int32[] result);
    public Int32[][] Generate(int samples, Int32[][] result);
    public sealed virtual Double[][] Generate(int samples, Random source);
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
    public sealed virtual Double[] Generate(Random source);
    public sealed virtual Double[] Generate(Double[] result, Random source);
    public Int32[] Generate(Int32[] result, Random source);
    public Int32[][] Generate(int samples, Int32[][] result, Random source);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.LogProbabilityFunction(Double[] x);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Distributions.Multivariate.MultivariateDiscreteDistribution : DistributionBase {
    private int dimension;
    [NonSerializedAttribute]
private MetropolisHasting`1<int> generator;
    public int Dimension { get; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public Double[] Mode { get; }
    public Double[] Median { get; }
    public IntRange[] Support { get; }
    protected MultivariateDiscreteDistribution(int dimension);
    public sealed virtual int get_Dimension();
    public abstract virtual Double[] get_Mean();
    public abstract virtual Double[] get_Variance();
    public abstract virtual Double[0...,0...] get_Covariance();
    public virtual Double[] get_Mode();
    public virtual Double[] get_Median();
    public abstract virtual IntRange[] get_Support();
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.DistributionFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.LogProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.ComplementaryDistributionFunction(Double[] x);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights, IFittingOptions options);
    public virtual double DistributionFunction(Int32[] x);
    protected internal virtual double InnerDistributionFunction(Int32[] x);
    public virtual double ProbabilityMassFunction(Int32[] x);
    protected internal virtual double InnerProbabilityMassFunction(Int32[] x);
    public virtual double LogProbabilityMassFunction(Int32[] x);
    protected internal virtual double InnerLogProbabilityMassFunction(Int32[] x);
    public virtual Int32[] InverseDistributionFunction(double p);
    protected internal Int32[] InnerInverseDistributionFunction(double p);
    public virtual double ComplementaryDistributionFunction(Int32[] x);
    protected internal double InnerComplementaryDistributionFunction(Int32[] x);
    public Double[] MarginalDistributionFunction(int index);
    public double MarginalDistributionFunction(int index, int value);
    public virtual void Fit(Double[][] observations);
    public virtual void Fit(Double[][] observations, Double[] weights);
    public virtual void Fit(Double[][] observations, Int32[] weights);
    public virtual void Fit(Double[][] observations, IFittingOptions options);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[][] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual Int32[][] Generate(int samples);
    public sealed virtual Double[][] Generate(int samples, Double[][] result);
    public sealed virtual Int32[][] Generate(int samples, Int32[][] result);
    public sealed virtual Int32[] Generate();
    public sealed virtual Double[] Generate(Double[] result);
    public sealed virtual Int32[] Generate(Int32[] result);
    public sealed virtual Int32[][] Generate(int samples, Random source);
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
    public virtual Int32[][] Generate(int samples, Int32[][] result, Random source);
    public sealed virtual Int32[] Generate(Random source);
    public sealed virtual Double[] Generate(Double[] result, Random source);
    public sealed virtual Int32[] Generate(Int32[] result, Random source);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Int32[]>.ProbabilityFunction(Int32[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Int32[]>.LogProbabilityFunction(Int32[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.DistributionFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.LogProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.ComplementaryDistributionFunction(Double[] x);
    private sealed virtual override Double[] Accord.Math.Random.IRandomNumberGenerator<System.Double[]>.Generate();
    private sealed virtual override Double[][] Accord.Math.Random.IRandomNumberGenerator<System.Double[]>.Generate(int samples);
    private sealed virtual override Double[][] Accord.Statistics.Distributions.ISampleableDistribution<System.Double[]>.Generate(int samples, Random source);
    private sealed virtual override Double[] Accord.Statistics.Distributions.ISampleableDistribution<System.Double[]>.Generate(Random source);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.MultivariateEmpiricalDistribution : MultivariateContinuousDistribution {
    private Double[][] samples;
    private Double[0...,0...] smoothing;
    private double determinant;
    private WeightType type;
    private Double[] weights;
    private Int32[] repeats;
    private int numberOfSamples;
    private double sumOfWeights;
    private CholeskyDecomposition chol;
    private IDensityKernel kernel;
    private Double[] mean;
    private Double[] variance;
    private Double[0...,0...] covariance;
    public IDensityKernel Kernel { get; }
    public Double[][] Samples { get; }
    public Double[] Weights { get; }
    public Int32[] Counts { get; }
    public int Length { get; }
    public Double[0...,0...] Smoothing { get; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public MultivariateEmpiricalDistribution(Double[][] samples);
    public MultivariateEmpiricalDistribution(Double[][] samples, Double[] weights);
    public MultivariateEmpiricalDistribution(Double[][] samples, Int32[] weights);
    public MultivariateEmpiricalDistribution(IDensityKernel kernel, Double[][] samples);
    public MultivariateEmpiricalDistribution(IDensityKernel kernel, Double[][] samples, Double[] weights);
    public MultivariateEmpiricalDistribution(IDensityKernel kernel, Double[][] samples, Int32[] weights);
    public MultivariateEmpiricalDistribution(IDensityKernel kernel, Double[][] samples, Double[0...,0...] smoothing);
    public MultivariateEmpiricalDistribution(IDensityKernel kernel, Double[][] samples, Int32[] weights, Double[0...,0...] smoothing);
    public MultivariateEmpiricalDistribution(IDensityKernel kernel, Double[][] samples, Double[] weights, Double[0...,0...] smoothing);
    public MultivariateEmpiricalDistribution(Double[][] samples, Int32[] weights, Double[0...,0...] smoothing);
    public MultivariateEmpiricalDistribution(Double[][] samples, Double[] weights, Double[0...,0...] smoothing);
    private MultivariateEmpiricalDistribution(int dimension);
    public IDensityKernel get_Kernel();
    public Double[][] get_Samples();
    public Double[] get_Weights();
    public Int32[] get_Counts();
    public int get_Length();
    public Double[0...,0...] get_Smoothing();
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerDistributionFunction(Double[] x);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[][] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[][] observations, Double[] weights, MultivariateEmpiricalOptions options);
    public void Fit(Double[][] observations, Int32[] weights, MultivariateEmpiricalOptions options);
    private void initialize(IDensityKernel kernel, Double[][] observations, Double[] weights, Int32[] repeats, Double[0...,0...] smoothing);
    public virtual object Clone();
    public static Double[0...,0...] SilvermanRule(Double[][] observations);
    public static Double[0...,0...] SilvermanRule(Double[][] observations, Double[] weights);
    public static Double[0...,0...] SilvermanRule(Double[][] observations, Int32[] weights);
    public static Double[0...,0...] SilvermanRule(Double[][] observations, Double[] weights, Int32[] repeats);
    private static Double[0...,0...] silverman(Double[] sigma, double d, double n);
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.MultivariateMixture`1 : MultivariateContinuousDistribution {
    private Double[] coefficients;
    private T[] components;
    private Double[] mean;
    private Double[0...,0...] covariance;
    private Double[] variance;
    private IDistribution`1[] cache;
    private ISampleableDistribution`1[] sampleable;
    public T[] Components { get; }
    public Double[] Coefficients { get; }
    public Double[] Mean { get; }
    public Double[0...,0...] Covariance { get; }
    public Double[] Variance { get; }
    public MultivariateMixture`1(T[] components);
    public MultivariateMixture`1(Double[] coefficients, T[] components);
    private void initialize();
    public sealed virtual T[] get_Components();
    public sealed virtual Double[] get_Coefficients();
    public double ProbabilityDensityFunction(int componentIndex, Double[] x);
    public double LogProbabilityDensityFunction(int componentIndex, Double[] x);
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerDistributionFunction(Double[] x);
    public double DistributionFunction(int componentIndex, Double[] x);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[][] observations, Double[] weights, MixtureOptions options);
    public double LogLikelihood(Double[][] observations, Double[] weights);
    public double LogLikelihood(Double[][] observations);
    public virtual object Clone();
    public virtual Double[] get_Mean();
    public virtual Double[0...,0...] get_Covariance();
    public virtual Double[] get_Variance();
    public static MultivariateMixture`1<T> Estimate(Double[][] data, T[] components);
    public static MultivariateMixture`1<T> Estimate(Double[][] data, Double[] coefficients, T[] components);
    public static MultivariateMixture`1<T> Estimate(Double[][] data, double threshold, Double[] coefficients, T[] components);
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.MultivariateNormalDistribution : MultivariateContinuousDistribution {
    private Double[] mean;
    private Double[0...,0...] covariance;
    private CholeskyDecomposition chol;
    private SingularValueDecomposition svd;
    private double lnconstant;
    private Double[] variance;
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public MultivariateNormalDistribution(int dimension);
    private MultivariateNormalDistribution(int dimension, bool init);
    public MultivariateNormalDistribution(Double[] mean, Double[][] covariance);
    public MultivariateNormalDistribution(Double[] mean);
    public MultivariateNormalDistribution(Double[] mean, Double[0...,0...] covariance);
    private void initialize(Double[] m, Double[0...,0...] cov, CholeskyDecomposition cd, SingularValueDecomposition svd);
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerDistributionFunction(Double[] x);
    protected internal virtual double InnerComplementaryDistributionFunction(Double[] x);
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[] x);
    public double Mahalanobis(Double[] x);
    public virtual void Fit(Double[][] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[][] observations, Double[] weights, NormalOptions options);
    private static void decompose(NormalOptions options, Double[0...,0...] cov, CholeskyDecomposition& chol, SingularValueDecomposition& svd);
    public static MultivariateNormalDistribution Estimate(Double[][] observations);
    public static MultivariateNormalDistribution Estimate(Double[][] observations, NormalOptions options);
    public static MultivariateNormalDistribution Estimate(Double[][] observations, Double[] weights);
    public static MultivariateNormalDistribution Estimate(Double[][] observations, Double[] weights, NormalOptions options);
    public virtual object Clone();
    public Independent`1<NormalDistribution> ToIndependentNormalDistribution();
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
    public static MultivariateNormalDistribution Univariate(double mean, double stdDev);
    public static MultivariateNormalDistribution Bivariate(double mean1, double mean2, double stdDev1, double stdDev2, double rho);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static Double[][] Generate(int samples, Double[] mean, Double[0...,0...] covariance);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Distributions.Multivariate.NamespaceDoc : object {
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.UniformBallDistribution : MultivariateContinuousDistribution {
    private Double[] center;
    private double radius;
    private double volume;
    public double Radius { get; }
    public double Volume { get; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public UniformBallDistribution(int dimension);
    public UniformBallDistribution(Double[] mean, double radius);
    public double get_Radius();
    public double get_Volume();
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerDistributionFunction(Double[] x);
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[] x);
    public virtual object Clone();
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.UniformSphereDistribution : MultivariateContinuousDistribution {
    private static double rtol;
    private Double[] center;
    private double radius;
    private double surface;
    public double Radius { get; }
    public double Surface { get; }
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public UniformSphereDistribution(int dimension);
    public UniformSphereDistribution(Double[] mean, double radius);
    public double get_Radius();
    public double get_Surface();
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerDistributionFunction(Double[] x);
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[] x);
    public virtual object Clone();
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
    public static Double[][] Random(int samples, Double[] mean, double radius, Double[][] result);
    public static Double[][] Random(int samples, Double[] mean, double radius, Double[][] result, Random source);
    public static Double[][] Random(int samples, int dimension);
    public static Double[][] Random(int samples, int dimension, Random source);
    public static Double[][] Random(int samples, int dimension, Double[][] result);
    public static Double[][] Random(int samples, int dimension, Double[][] result, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.VonMisesFisherDistribution : MultivariateContinuousDistribution {
    private Double[] mean;
    private double kappa;
    private double constant;
    public Double[] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public VonMisesFisherDistribution(int dimension, double concentration);
    public VonMisesFisherDistribution(Double[] mean, double concentration);
    private VonMisesFisherDistribution(int dimension);
    public virtual Double[] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerDistributionFunction(Double[] x);
    protected internal virtual double InnerProbabilityDensityFunction(Double[] x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private VonMisesFisherDistribution Uniform(Double[] mean);
    private double density(double x);
    private Double[] randomDirection(int samples, double k, int dimensions, Random source);
    public virtual Double[][] Generate(int samples, Double[][] result, Random source);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Multivariate.WishartDistribution : MatrixContinuousDistribution {
    private int size;
    private int n;
    private Double[0...,0...] scaleMatrix;
    private double constant;
    private double lnconstant;
    private double power;
    private CholeskyDecomposition chol;
    private Double[0...,0...] mean;
    private Double[] variance;
    private Double[0...,0...] covariance;
    public double DegreesOfFreedom { get; }
    public Double[0...,0...] Mean { get; }
    public Double[] Variance { get; }
    public Double[0...,0...] Covariance { get; }
    public WishartDistribution(int dimension, int degreesOfFreedom);
    public WishartDistribution(int degreesOfFreedom, Double[0...,0...] scale);
    public double get_DegreesOfFreedom();
    public virtual Double[0...,0...] get_Mean();
    public virtual Double[] get_Variance();
    public virtual Double[0...,0...] get_Covariance();
    protected internal virtual double InnerProbabilityDensityFunction(Double[0...,0...] x);
    protected internal virtual double InnerLogProbabilityDensityFunction(Double[0...,0...] x);
    public virtual Double[0...,0...][] Generate(int samples, Double[0...,0...][] result, Random source);
    protected internal virtual double InnerDistributionFunction(Double[0...,0...] x);
    public virtual void Fit(Double[0...,0...][] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static Double[0...,0...] Random(int degreesOfFreedom, Double[0...,0...] scale);
    public static Double[0...,0...] Random(int degreesOfFreedom, Double[0...,0...] scale, Random source);
    public static Double[0...,0...][] Random(int samples, int degreesOfFreedom, Double[0...,0...] scale);
    public static Double[0...,0...][] Random(int samples, int degreesOfFreedom, Double[0...,0...] scale, Random source);
    public static Double[0...,0...][] Random(int samples, int degreesOfFreedom, Double[0...,0...] scale, Double[0...,0...][] result, Random source);
    private static void rnorm(Random random, Double& u1, Double& u2);
    private static void wshrt(Double[] d, int n, int np, Random seed, Double[] sa);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Distributions.NamespaceDoc : object {
}
public class Accord.Statistics.Distributions.Reflection.DistributionConstructorInfo : object {
    private Nullable`1<bool> isBuildable;
    private DistributionParameterInfo[] parameters;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ConstructorInfo>k__BackingField;
    public ConstructorInfo ConstructorInfo { get; private set; }
    public bool IsBuildable { get; }
    public DistributionConstructorInfo(ConstructorInfo constructor);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_ConstructorInfo();
    [CompilerGeneratedAttribute]
private void set_ConstructorInfo(ConstructorInfo value);
    public bool get_IsBuildable();
    public DistributionParameterInfo[] GetParameters();
}
public class Accord.Statistics.Distributions.Reflection.DistributionInfo : object {
    private Nullable`1<bool> isBuildable;
    [CompilerGeneratedAttribute]
private Type <DistributionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Type DistributionType { get; protected set; }
    public string Name { get; protected set; }
    public bool IsBuildable { get; }
    public bool IsDiscrete { get; }
    public bool IsContinuous { get; }
    public bool IsUnivariate { get; }
    public bool IsMultivariate { get; }
    public DistributionInfo(Type type);
    [CompilerGeneratedAttribute]
public Type get_DistributionType();
    [CompilerGeneratedAttribute]
protected void set_DistributionType(Type value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public bool get_IsBuildable();
    public bool get_IsDiscrete();
    public bool get_IsContinuous();
    public bool get_IsUnivariate();
    public bool get_IsMultivariate();
    public DistributionConstructorInfo[] GetConstructors();
    public IFittingOptions GetFittingOptions();
    public static string GetDistributionName(Type type);
    public static IFittingOptions GetFittingOptions(Type type);
    public static IFittingOptions GetFittingOptions();
    internal static Type[] GetDistributionsInheritingFromBaseType(Type baseType);
    public virtual string ToString();
}
public class Accord.Statistics.Distributions.Reflection.DistributionParameterInfo : object {
    [CompilerGeneratedAttribute]
private ParameterInfo <ParameterInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBuildable>k__BackingField;
    public ParameterInfo ParameterInfo { get; private set; }
    public string Name { get; }
    public int Position { get; }
    public DoubleRange Range { get; private set; }
    public double DefaultValue { get; private set; }
    public bool IsBuildable { get; private set; }
    public DistributionParameterInfo(ParameterInfo parameterInfo);
    [CompilerGeneratedAttribute]
public ParameterInfo get_ParameterInfo();
    [CompilerGeneratedAttribute]
private void set_ParameterInfo(ParameterInfo value);
    public string get_Name();
    public int get_Position();
    [CompilerGeneratedAttribute]
public DoubleRange get_Range();
    [CompilerGeneratedAttribute]
private void set_Range(DoubleRange value);
    [CompilerGeneratedAttribute]
public double get_DefaultValue();
    [CompilerGeneratedAttribute]
private void set_DefaultValue(double value);
    [CompilerGeneratedAttribute]
public bool get_IsBuildable();
    [CompilerGeneratedAttribute]
private void set_IsBuildable(bool value);
    public static bool TryGetRange(ParameterInfo parameter, DoubleRange& range);
    public static bool TryGetDefault(ParameterInfo parameter, Double& value);
    public virtual string ToString();
}
public class Accord.Statistics.Distributions.Reflection.UnivariateDistributionInfo : DistributionInfo {
    public UnivariateDistributionInfo(Type type);
    public static IEnumerable`1<UnivariateDistributionInfo> GetUnivariateDistributions(bool buildableOnly);
    public IUnivariateDistribution CreateInstance(Dictionary`2<DistributionParameterInfo, object> arguments);
    public static T CreateInstance();
}
public class Accord.Statistics.Distributions.Sampling.MetropolisHasting : MetropolisHasting`2<double, Independent`1<NormalDistribution>> {
    public MetropolisHasting(int dimensions, Func`2<Double[], double> logDensity, Independent`1<NormalDistribution> proposal);
    public MetropolisHasting(int dimensions, Func`2<Double[], double> logDensity);
    public static MetropolisHasting`2<double, Independent`1<NormalDistribution>> Continuous(int dimensions, Func`2<Double[], double> logDensity);
    public static MetropolisHasting`3<double, Independent`1<NormalDistribution>, T> Continuous(int dimensions, T distribution);
    public static MetropolisHasting`2<int, Independent`2<SymmetricGeometricDistribution, int>> Discrete(int dimensions, Func`2<Int32[], double> logDensity);
    public static MetropolisHasting`3<int, Independent`2<SymmetricGeometricDistribution, int>, T> Discrete(int dimensions, T distribution);
}
public class Accord.Statistics.Distributions.Sampling.MetropolisHasting`1 : object {
    private Func`2<T[], double> logPdf;
    private Func`3<T[], T[], T[]> proposal;
    private T[] current;
    private T[] next;
    private double currentLogProb;
    private int dimensions;
    private int discard;
    private long steps;
    private long accepts;
    private bool initialized;
    [CompilerGeneratedAttribute]
private Random <RandomSource>k__BackingField;
    public T[] Current { get; }
    public Random RandomSource { get; public set; }
    public double CurrentValue { get; }
    public Func`2<T[], double> LogProbabilityDensityFunction { get; }
    public Func`3<T[], T[], T[]> Proposal { get; }
    public double AcceptanceRate { get; }
    public int NumberOfInputs { get; }
    public int Discard { get; public set; }
    public MetropolisHasting`1(int dimensions, Func`2<T[], double> logDensity, Func`3<T[], T[], T[]> proposal);
    public T[] get_Current();
    [CompilerGeneratedAttribute]
public Random get_RandomSource();
    [CompilerGeneratedAttribute]
public void set_RandomSource(Random value);
    public double get_CurrentValue();
    public Func`2<T[], double> get_LogProbabilityDensityFunction();
    public Func`3<T[], T[], T[]> get_Proposal();
    public double get_AcceptanceRate();
    public int get_NumberOfInputs();
    public int get_Discard();
    public void set_Discard(int value);
    protected void Initialize(int dimensions, Func`2<T[], double> logDensity, Func`3<T[], T[], T[]> proposal);
    public bool TryGenerate(T[]& sample);
    public bool TryGenerate();
    public void WarmUp();
    public sealed virtual T[][] Generate(int samples);
    public sealed virtual T[][] Generate(int samples, T[][] result);
    public sealed virtual T[] Generate();
}
public class Accord.Statistics.Distributions.Sampling.MetropolisHasting`2 : MetropolisHasting`1<TObservation> {
    private TProposalDistribution proposal;
    public TProposalDistribution Proposal { get; }
    public MetropolisHasting`2(int dimensions, Func`2<TObservation[], double> logDensity, TProposalDistribution proposal);
    public TProposalDistribution get_Proposal();
    protected void Initialize(int dimensions, Func`2<TObservation[], double> logDensity, TProposalDistribution proposal);
    private TObservation[] generate(TObservation[] current, TObservation[] next);
}
public class Accord.Statistics.Distributions.Sampling.MetropolisHasting`3 : MetropolisHasting`2<TObservation, TProposalDistribution> {
    private TTargetDistribution target;
    public TTargetDistribution Target { get; }
    public MetropolisHasting`3(TTargetDistribution target, TProposalDistribution proposal);
    public TTargetDistribution get_Target();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.AndersonDarlingDistribution : UnivariateContinuousDistribution {
    [CompilerGeneratedAttribute]
private AndersonDarlingDistributionType <DistributionType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <NumberOfSamples>k__BackingField;
    public AndersonDarlingDistributionType DistributionType { get; private set; }
    public double NumberOfSamples { get; private set; }
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public AndersonDarlingDistribution(AndersonDarlingDistributionType type, double samples);
    [CompilerGeneratedAttribute]
public AndersonDarlingDistributionType get_DistributionType();
    [CompilerGeneratedAttribute]
private void set_DistributionType(AndersonDarlingDistributionType value);
    [CompilerGeneratedAttribute]
public double get_NumberOfSamples();
    [CompilerGeneratedAttribute]
private void set_NumberOfSamples(double value);
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private static double ad_normal(double x, double n);
    private static double ad_uniform(double z, double n);
    private static double adinf(double z);
    private static double errfix(double n, double x);
    private static double g1(double x);
    private static double g2(double x);
    private static double g3(double x);
}
public enum Accord.Statistics.Distributions.Univariate.AndersonDarlingDistributionType : Enum {
    public int value__;
    public static AndersonDarlingDistributionType Uniform;
    public static AndersonDarlingDistributionType Normal;
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.BernoulliDistribution : UnivariateDiscreteDistribution {
    private double probability;
    private double complement;
    private Nullable`1<double> entropy;
    public double Mean { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public BernoulliDistribution(double mean);
    private void initialize(double mean);
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected virtual int InnerInverseDistributionFunction(double p);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.InverseDistributionFunction(double p);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution<System.Double>.InverseDistributionFunction(double p);
    protected internal virtual double InnerComplementaryDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual Int32[] Generate(int samples, Int32[] result, Random source);
    public virtual int Generate(Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.BetaDistribution : UnivariateContinuousDistribution {
    private double alpha;
    private double beta;
    private double constant;
    private Nullable`1<double> entropy;
    public double Alpha { get; }
    public double Beta { get; }
    public double Successes { get; }
    public double Trials { get; }
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public double Mode { get; }
    public BetaDistribution(int successes, int trials);
    public BetaDistribution(double alpha, double beta);
    private void initialize(double alpha, double beta);
    public double get_Alpha();
    public double get_Beta();
    public double get_Successes();
    public double get_Trials();
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual double get_Mode();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, BetaOptions options);
    public void Fit(Double[] observations, Int32[] weights, BetaOptions options);
    private void fitMoments(double mean, double var);
    private void fitMLE(double sum1, double sum2, double n);
    public static Double[] Gradient(Double[] observations, double alpha, double beta);
    public static Double[] Gradient(double sum1, double sum2, double n, double alpha, double beta, Double[] g);
    public static double LogLikelihood(Double[] observations, double alpha, double beta);
    public static double LogLikelihood(double sum1, double sum2, double n, double alpha, double beta);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(double alpha, double beta, int samples);
    public static Double[] Random(double alpha, double beta, int samples, Random source);
    public static Double[] Random(double alpha, double beta, int samples, Double[] result);
    public static Double[] Random(double alpha, double beta, int samples, Double[] result, Random source);
    public static double Random(double alpha, double beta);
    public static double Random(double alpha, double beta, Random source);
    public static BetaDistribution Estimate(Double[] samples);
    public static BetaDistribution Estimate(Double[] samples, Double[] weights);
    public static BetaDistribution Estimate(Double[] samples, Double[] weights, BetaOptions options);
    public static BetaDistribution Estimate(Double[] samples, BetaOptions options);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.BetaPrimeDistribution : UnivariateContinuousDistribution {
    private double alpha;
    private double beta;
    public double Alpha { get; }
    public double Beta { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public BetaPrimeDistribution(double alpha, double beta);
    public double get_Alpha();
    public double get_Beta();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.BinomialDistribution : UnivariateDiscreteDistribution {
    private int numberOfTrials;
    private double probability;
    public int NumberOfTrials { get; }
    public double ProbabilityOfSuccess { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public BinomialDistribution(int trials);
    public BinomialDistribution(int trials, double probability);
    public int get_NumberOfTrials();
    public double get_ProbabilityOfSuccess();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected virtual int InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Int32[] observations, Double[] weights);
    public virtual void Fit(Int32[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.BirnbaumSaundersDistribution : UnivariateContinuousDistribution {
    private double location;
    private double shape;
    private double scale;
    public double Location { get; }
    public double Scale { get; }
    public double Shape { get; }
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public BirnbaumSaundersDistribution(double shape);
    public BirnbaumSaundersDistribution(double location, double scale, double shape);
    private void init(double location, double scale, double shape);
    public double get_Location();
    public double get_Scale();
    public double get_Shape();
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.CauchyDistribution : UnivariateContinuousDistribution {
    private double location;
    private double scale;
    private double lnconstant;
    private double constant;
    private bool immutable;
    private static CauchyDistribution standard;
    public double Location { get; }
    public double Scale { get; }
    public double Median { get; }
    public DoubleRange Support { get; }
    public double Mode { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public static CauchyDistribution Standard { get; }
    public CauchyDistribution(double location, double scale);
    private static CauchyDistribution();
    private void init(double location, double scale);
    public double get_Location();
    public double get_Scale();
    public virtual double get_Median();
    public virtual DoubleRange get_Support();
    public virtual double get_Mode();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, CauchyOptions options);
    public static CauchyDistribution get_Standard();
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static double Random(double location, double scale);
    public static Double[] Random(double location, double scale, int samples);
    public static Double[] Random(double location, double scale, int samples, Double[] result);
    public static double Random(double location, double scale, Random source);
    public static Double[] Random(double location, double scale, int samples, Random source);
    public static Double[] Random(double location, double scale, int samples, Double[] result, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.ChiSquareDistribution : UnivariateContinuousDistribution {
    private int degreesOfFreedom;
    private Nullable`1<double> entropy;
    public int DegreesOfFreedom { get; }
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public ChiSquareDistribution(int degreesOfFreedom);
    public int get_DegreesOfFreedom();
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(int degreesOfFreedom, int samples);
    public static double Random(int degreesOfFreedom);
    public static Double[] Random(int degreesOfFreedom, int samples, Random source);
    public static Double[] Random(int degreesOfFreedom, int samples, Double[] result, Random source);
    public static double Random(int degreesOfFreedom, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static double Inverse(double p, int degreesOfFreedom);
}
public enum Accord.Statistics.Distributions.Univariate.ContinuityCorrection : Enum {
    public int value__;
    public static ContinuityCorrection None;
    public static ContinuityCorrection Midpoint;
    public static ContinuityCorrection KeepInside;
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.DegenerateDistribution : UnivariateDiscreteDistribution {
    private int k0;
    public int Value { get; }
    public double Mean { get; }
    public double Median { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public DegenerateDistribution(int value);
    public int get_Value();
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected virtual int InnerInverseDistributionFunction(double p);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.EmpiricalDistribution : UnivariateContinuousDistribution {
    private Double[] samples;
    private double smoothing;
    private WeightType type;
    private Double[] weights;
    private Int32[] repeats;
    private double sumOfWeights;
    private int numberOfSamples;
    private Nullable`1<double> mean;
    private Nullable`1<double> variance;
    private Nullable`1<double> entropy;
    private Nullable`1<double> mode;
    private double constant;
    public Double[] Samples { get; }
    public Double[] Weights { get; }
    public Int32[] Counts { get; }
    public int Length { get; }
    public double Smoothing { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public EmpiricalDistribution(Double[] samples);
    public EmpiricalDistribution(Double[] samples, double smoothing);
    public EmpiricalDistribution(Double[] samples, Double[] weights);
    public EmpiricalDistribution(Double[] samples, Int32[] weights);
    public EmpiricalDistribution(Double[] samples, Double[] weights, double smoothing);
    public EmpiricalDistribution(Double[] samples, Int32[] weights, double smoothing);
    public Double[] get_Samples();
    public Double[] get_Weights();
    public Int32[] get_Counts();
    public int get_Length();
    public double get_Smoothing();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, EmpiricalOptions options);
    public void Fit(Double[] observations, Int32[] weights, EmpiricalOptions options);
    public virtual object Clone();
    private void initialize(Double[] observations, Double[] weights, Int32[] repeats, Nullable`1<double> smoothing);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static double SmoothingRule(Double[] observations);
    public static double SmoothingRule(Double[] observations, Double[] weights);
    public static double SmoothingRule(Double[] observations, Int32[] repeats);
    public static double SmoothingRule(Double[] observations, Double[] weights, Int32[] repeats);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.EmpiricalHazardDistribution : UnivariateContinuousDistribution {
    private Nullable`1<double> mean;
    private Nullable`1<double> variance;
    private Double[] times;
    private Double[] hazards;
    private Double[] survivals;
    private DoubleRange range;
    private SurvivalEstimator estimator;
    public Double[] Times { get; }
    public Double[] Hazards { get; }
    public Double[] Survivals { get; }
    public SurvivalEstimator Estimator { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public EmpiricalHazardDistribution(Double[] time, Double[] lambdas);
    public EmpiricalHazardDistribution(Double[] times, Double[] lambdas, SurvivalEstimator estimator);
    public EmpiricalHazardDistribution(SurvivalEstimator estimator);
    public Double[] get_Times();
    public Double[] get_Hazards();
    public Double[] get_Survivals();
    public SurvivalEstimator get_Estimator();
    private void init(Double[] times, Double[] hazards, SurvivalEstimator estimator);
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    public virtual double CumulativeHazardFunction(double x);
    public virtual double HazardFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerDistributionFunction(double x);
    public virtual object Clone();
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, EmpiricalHazardOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, SurvivalOptions options);
    public static Int32[] Sort(Double[]& time, SurvivalOutcome[]& output);
    public static Int32[] Sort(Double[]& time, SurvivalOutcome[]& output, Double[][]& inputs);
    public static Int32[] Sort(Double[]& time, SurvivalOutcome[]& output, Double[]& weights);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static EmpiricalHazardDistribution Estimate(Double[] time, Double[] weights, SurvivalEstimator survival, HazardEstimator hazard, HazardTiesMethod ties);
    public static EmpiricalHazardDistribution Estimate(Double[] time, Int32[] outcome, Double[] weights, SurvivalEstimator survival, HazardEstimator hazard, HazardTiesMethod ties);
    public static EmpiricalHazardDistribution Estimate(Double[] time, SurvivalOutcome[] outcome, Double[] weights, SurvivalEstimator survival, HazardEstimator hazard, HazardTiesMethod ties);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.ExponentialDistribution : UnivariateContinuousDistribution {
    private double lambda;
    private double lnlambda;
    public double Rate { get; }
    public double Mean { get; }
    public double Variance { get; }
    public DoubleRange Support { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public ExponentialDistribution(double rate);
    private void init(double rate);
    public double get_Rate();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual DoubleRange get_Support();
    public virtual double get_Median();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public static ExponentialDistribution Estimate(Double[] observations);
    public static ExponentialDistribution Estimate(Double[] observations, Double[] weights);
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(double lambda, int samples);
    public static Double[] Random(double lambda, int samples, Random source);
    public static Double[] Random(double lambda, int samples, Double[] result);
    public static Double[] Random(double lambda, int samples, Double[] result, Random source);
    public static double Random(double lambda);
    public static double Random(double lambda, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.FDistribution : UnivariateContinuousDistribution {
    private int d1;
    private int d2;
    private double b;
    private Nullable`1<double> mean;
    private Nullable`1<double> variance;
    public int DegreesOfFreedom1 { get; }
    public int DegreesOfFreedom2 { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public FDistribution(int degrees1, int degrees2);
    public int get_DegreesOfFreedom1();
    public int get_DegreesOfFreedom2();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(int d1, int d2, int samples);
    public static Double[] Random(int d1, int d2, int samples, Double[] result);
    public static double Random(int d1, int d2);
    public static Double[] Random(int d1, int d2, int samples, Random source);
    public static Double[] Random(int d1, int d2, int samples, Double[] result, Random source);
    public static double Random(int d1, int d2, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.FoldedNormalDistribution : UnivariateContinuousDistribution {
    private double mu;
    private double sigma2;
    private double sigma;
    public double Mean { get; }
    public double Variance { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public FoldedNormalDistribution(double mean);
    public FoldedNormalDistribution(double mean, double stdDev);
    public static FoldedNormalDistribution HalfNormal(double stdDev);
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double mu, double dev, double var);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.GammaDistribution : UnivariateContinuousDistribution {
    private double theta;
    private double k;
    private double lnconstant;
    private bool immutable;
    private static GammaDistribution standard;
    public double Scale { get; }
    public double Shape { get; }
    public double Rate { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public static GammaDistribution Standard { get; }
    public GammaDistribution(double theta, double k);
    private static GammaDistribution();
    public static GammaDistribution FromBayesian(double alpha, double beta);
    public static GammaDistribution FromMean(double alpha, double mean);
    private void init(double theta, double k);
    public double get_Scale();
    public double get_Shape();
    public double get_Rate();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, GammaOptions options);
    public static GammaDistribution Estimate(Double[] observations, Double[] weights, double tol, int iterations);
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(double shape, double scale, int samples);
    public static Double[] Random(double shape, double scale, int samples, Random source);
    public static Double[] Random(double shape, double scale, int samples, Double[] result);
    public static Double[] Random(double shape, double scale, int samples, Double[] result, Random source);
    public static double Random(double shape, double scale);
    public static double Random(double shape, double scale, Random source);
    public static double Marsaglia(double d, double c);
    public static double Marsaglia(double d, double c, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static GammaDistribution get_Standard();
}
public class Accord.Statistics.Distributions.Univariate.GeneralContinuousDistribution : UnivariateContinuousDistribution {
    private IUnivariateIntegration method;
    private Func`2<double, double> pdf;
    private Func`2<double, double> cdf;
    private DoubleRange support;
    private Nullable`1<double> mean;
    private Nullable`1<double> variance;
    private Nullable`1<double> entropy;
    private Nullable`1<double> mode;
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public double Mode { get; }
    public GeneralContinuousDistribution(DoubleRange support, Func`2<double, double> density, Func`2<double, double> distribution);
    public GeneralContinuousDistribution(UnivariateContinuousDistribution distribution);
    public static GeneralContinuousDistribution FromDistribution(UnivariateContinuousDistribution distribution);
    public static GeneralContinuousDistribution FromDensityFunction(Func`2<double, double> pdf);
    public static GeneralContinuousDistribution FromDensityFunction(DoubleRange support, Func`2<double, double> pdf);
    public static GeneralContinuousDistribution FromDistributionFunction(Func`2<double, double> cdf);
    public static GeneralContinuousDistribution FromDistributionFunction(DoubleRange support, Func`2<double, double> cdf);
    public static GeneralContinuousDistribution FromDensityFunction(DoubleRange support, Func`2<double, double> pdf, IUnivariateIntegration method);
    public static GeneralContinuousDistribution FromDistributionFunction(DoubleRange support, Func`2<double, double> cdf, IUnivariateIntegration method);
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual double get_Mode();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private static InfiniteAdaptiveGaussKronrod createDefaultIntegrationMethod();
    [CompilerGeneratedAttribute]
private double <get_Mean>b__20_0(double x);
    [CompilerGeneratedAttribute]
private double <get_Variance>b__22_0(double x);
    [CompilerGeneratedAttribute]
private double <get_Entropy>b__24_0(double x);
}
[DefaultMemberAttribute("Item")]
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.GeneralDiscreteDistribution : UnivariateDiscreteDistribution {
    private int start;
    private Double[] probabilities;
    private Nullable`1<double> mean;
    private Nullable`1<double> variance;
    private Nullable`1<double> entropy;
    private Nullable`1<int> mode;
    private bool log;
    public double Item { get; public set; }
    public int Minimum { get; }
    public int Maximum { get; }
    public int Length { get; }
    public Double[] Frequencies { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public GeneralDiscreteDistribution(bool logarithm, Double[] probabilities);
    public GeneralDiscreteDistribution(int start, Double[] probabilities);
    public GeneralDiscreteDistribution(int start, int symbols, bool logarithm);
    public GeneralDiscreteDistribution(Double[] probabilities);
    public GeneralDiscreteDistribution(int symbols, bool logarithm);
    public static GeneralDiscreteDistribution Uniform(int a, int b);
    public double get_Item(int i);
    public void set_Item(int i, double value);
    public int get_Minimum();
    public int get_Maximum();
    public int get_Length();
    public Double[] get_Frequencies();
    public void set_Frequencies(Double[] value);
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual int Generate(Random source);
    public virtual Int32[] Generate(int samples, Int32[] result, Random source);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Int32[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, GeneralDiscreteOptions options);
    public sealed virtual void Fit(Int32[] observations, Double[] weights);
    public virtual object Clone();
    private void initialize(int s, Double[] prob, bool logarithm);
    private void initialize(int s, int symbols, bool logarithm);
    private sealed virtual override Double[] Accord.Math.Random.IRandomNumberGenerator<System.Double>.Generate(int samples);
    private sealed virtual override double Accord.Math.Random.IRandomNumberGenerator<System.Double>.Generate();
    public static Int32[] Random(Double[] probabilities, int samples);
    public static Int32[] Random(Double[] probabilities, int samples, Random source);
    public static Int32[] Random(Double[] probabilities, int samples, Int32[] result, bool log);
    public static Int32[] Random(Double[] probabilities, int samples, Int32[] result, Random source, bool log);
    public static int Random(Double[] probabilities, bool log);
    public static int Random(Double[] probabilities, Random source, bool log);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual void Fit(Int32[] observations, Double[] weights, GeneralDiscreteOptions options);
    public sealed virtual void Fit(Double[][] observations, Double[] weights, GeneralDiscreteOptions options);
    public sealed virtual void Fit(Double[][] observations);
    public sealed virtual void Fit(Double[][] observations, Double[] weights);
    public static GeneralDiscreteDistribution[] FromMatrix(Double[0...,0...] probabilities, bool logarithm);
    public static GeneralDiscreteDistribution[] FromMatrix(Double[][] probabilities, bool logarithm);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.GeneralizedBetaDistribution : UnivariateContinuousDistribution {
    private double alpha;
    private double beta;
    private double min;
    private double max;
    private double constant;
    private Nullable`1<double> entropy;
    public double Min { get; }
    public double Max { get; }
    public double Alpha { get; }
    public double Beta { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public GeneralizedBetaDistribution(double alpha, double beta);
    public GeneralizedBetaDistribution(double alpha, double beta, double min, double max);
    public static GeneralizedBetaDistribution Vose(double min, double max, double mode);
    public static GeneralizedBetaDistribution Vose(double min, double max, double mode, double scale);
    public static GeneralizedBetaDistribution Pert(double min, double max, double mode);
    public static GeneralizedBetaDistribution Pert(double min, double max, double mode, double scale);
    public static GeneralizedBetaDistribution GolenkoGinzburg(double min, double max);
    public static GeneralizedBetaDistribution Standard(int successes, int trials);
    public double get_Min();
    public double get_Max();
    public double get_Alpha();
    public double get_Beta();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double min, double max, double alpha, double beta);
    private void fitMoments(double min, double max, double mean, double var);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, GeneralizedBetaOptions options);
    public void Fit(Double[] observations, Int32[] weights, GeneralizedBetaOptions options);
    private static double GetMean(Double[] observations, Double[] weights, int imin, int imax);
    private void fitMLE(double sum1, double sum2, double n);
    private static double GetVariance(Double[] observations, Double[] weights, double mean, int imin, int imax);
    private static double GetMean(Double[] observations, Int32[] weights, int imin, int imax);
    private static double GetVariance(Double[] observations, Int32[] weights, double mean, int imin, int imax);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(double alpha, double beta, double min, double max, int samples);
    public static Double[] Random(double alpha, double beta, double min, double max, int samples, Double[] result);
    public static double Random(double alpha, double beta, double min, double max);
    public static Double[] Random(double alpha, double beta, double min, double max, int samples, Random source);
    public static Double[] Random(double alpha, double beta, double min, double max, int samples, Double[] result, Random source);
    public static double Random(double alpha, double beta, double min, double max, Random source);
    public static GeneralizedBetaDistribution Estimate(Double[] samples, int min, int max);
    public static GeneralizedBetaDistribution Estimate(Double[] samples, int min, int max, Double[] weights);
    public static GeneralizedBetaDistribution Estimate(Double[] samples, int min, int max, Double[] weights, GeneralizedBetaOptions options);
    public static GeneralizedBetaDistribution Estimate(Double[] samples, int min, int max, GeneralizedBetaOptions options);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.GeneralizedNormalDistribution : UnivariateContinuousDistribution {
    private double mean;
    private double alpha;
    private double beta;
    public double Mean { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Variance { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public GeneralizedNormalDistribution(double location, double scale, double shape);
    public static GeneralizedNormalDistribution Laplace(double location, double scale);
    public static GeneralizedNormalDistribution Normal(double mean, double stdDev);
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double mu, double alpha, double beta);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.GeneralizedParetoDistribution : UnivariateContinuousDistribution {
    private double mu;
    private double sigma;
    private double ksi;
    public double Scale { get; }
    public double Shape { get; }
    public double Location { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Median { get; }
    public GeneralizedParetoDistribution(double location, double scale, double shape);
    private void init(double location, double scale, double shape);
    public double get_Scale();
    public double get_Shape();
    public double get_Location();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Median();
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.GeometricDistribution : UnivariateDiscreteDistribution {
    private double p;
    public double ProbabilityOfSuccess { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public GeometricDistribution(double probabilityOfSuccess);
    public double get_ProbabilityOfSuccess();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    protected virtual int InnerInverseDistributionFunction(double p);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual int Generate(Random source);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual Int32[] Generate(int samples, Int32[] result, Random source);
    public static double Random(double p);
    public static Double[] Random(double p, int samples, Double[] result);
    public static Int32[] Random(double p, int samples, Int32[] result);
    public static double Random(double p, Random source);
    public static Double[] Random(double p, int samples, Double[] result, Random source);
    public static Int32[] Random(double p, int samples, Int32[] result, Random source);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
public class Accord.Statistics.Distributions.Univariate.GompertzDistribution : UnivariateContinuousDistribution {
    private double eta;
    private double b;
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public GompertzDistribution(double eta, double b);
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Median();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.GrubbDistribution : UnivariateContinuousDistribution {
    private TDistribution tDistribution;
    [CompilerGeneratedAttribute]
private int <NumberOfSamples>k__BackingField;
    public int NumberOfSamples { get; private set; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public GrubbDistribution(int samples);
    [CompilerGeneratedAttribute]
public int get_NumberOfSamples();
    [CompilerGeneratedAttribute]
private void set_NumberOfSamples(int value);
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.GumbelDistribution : UnivariateContinuousDistribution {
    private double mean;
    private double beta;
    public double Location { get; }
    public double Shape { get; }
    public double Mean { get; }
    public double Variance { get; }
    public DoubleRange Support { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public GumbelDistribution(double location, double scale);
    private void init(double location, double scale);
    public double get_Location();
    public double get_Shape();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual DoubleRange get_Support();
    public virtual double get_Median();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    public virtual double CumulativeHazardFunction(double x);
    public virtual double HazardFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[] observations, Int32[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
public enum Accord.Statistics.Distributions.Univariate.HazardEstimator : Enum {
    public int value__;
    public static HazardEstimator BreslowNelsonAalen;
    public static HazardEstimator KaplanMeier;
}
public enum Accord.Statistics.Distributions.Univariate.HazardTiesMethod : Enum {
    public int value__;
    public static HazardTiesMethod Efron;
    public static HazardTiesMethod Breslow;
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.HyperbolicSecantDistribution : UnivariateContinuousDistribution {
    public double Mean { get; }
    public double Median { get; }
    public double Variance { get; }
    public double StandardDeviation { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_StandardDeviation();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.HypergeometricDistribution : UnivariateDiscreteDistribution {
    private int N;
    private int n;
    private int m;
    public int PopulationSize { get; }
    public int SampleSize { get; }
    public int PopulationSuccess { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public double Mode { get; }
    public IntRange Support { get; }
    public HypergeometricDistribution(int populationSize, int successes, int samples);
    public int get_PopulationSize();
    public int get_SampleSize();
    public int get_PopulationSuccess();
    public static HypergeometricDistribution FromSuccessCounts(int successes, int failures, int samples);
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual double get_Mode();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, HypergeometricOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.InverseChiSquareDistribution : UnivariateContinuousDistribution {
    private int degreesOfFreedom;
    public int DegreesOfFreedom { get; }
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public InverseChiSquareDistribution(int degreesOfFreedom);
    public int get_DegreesOfFreedom();
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerDistributionFunction(double x);
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.InverseGammaDistribution : UnivariateContinuousDistribution {
    private double a;
    private double b;
    private double constant;
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public InverseGammaDistribution(double shape, double scale);
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.InverseGaussianDistribution : UnivariateContinuousDistribution {
    private double mean;
    private double lambda;
    public double Shape { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public InverseGaussianDistribution(double mean, double shape);
    private void init(double mean, double shape);
    public double get_Shape();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public static InverseGaussianDistribution Estimate(Double[] observations);
    public static InverseGaussianDistribution Estimate(Double[] observations, Double[] weights);
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static double Random(double mean, double shape);
    public static double Random(double mean, double shape, Random source);
    public static Double[] Random(double mean, double shape, int samples);
    public static Double[] Random(double mean, double shape, int samples, Random source);
    public static Double[] Random(double mean, double shape, int samples, Double[] result);
    public static Double[] Random(double mean, double shape, int samples, Double[] result, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.KolmogorovSmirnovDistribution : UnivariateContinuousDistribution {
    [CompilerGeneratedAttribute]
private double <NumberOfSamples>k__BackingField;
    public double NumberOfSamples { get; private set; }
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public KolmogorovSmirnovDistribution(double samples);
    [CompilerGeneratedAttribute]
public double get_NumberOfSamples();
    [CompilerGeneratedAttribute]
private void set_NumberOfSamples(double value);
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    public double OneSideDistributionFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static double CumulativeFunction(double n, double x);
    public static double ComplementaryDistributionFunction(double n, double x);
    public static double PelzGood(double n, double x);
    public static double OneSideUpperTail(double n, double x);
    public static double Pomeranz(int n, double x);
    public static double Durbin(int n, double d);
    private static void matrixPower(Double[0...,0...] A, int eA, Double[0...,0...] V, Int32& eV, int m, int n, Double[0...,0...] B);
    private static double computeLimits(double t, Double[] floors, Double[] ceilings);
    private static void computeA(int n, Double[] A, double z);
    private static double computeH(int n, Double[] A, Double[][] H);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.KumaraswamyDistribution : UnivariateContinuousDistribution {
    private double a;
    private double b;
    public double A { get; }
    public double B { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public KumaraswamyDistribution(double a, double b);
    public double get_A();
    public double get_B();
    public virtual double get_Mean();
    public virtual double get_Variance();
    private static double momentGeneratingFunction(int n, double a, double b);
    public virtual double get_Median();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
public class Accord.Statistics.Distributions.Univariate.LaplaceDistribution : UnivariateContinuousDistribution {
    private double u;
    private double b;
    private double constant;
    public double Mean { get; }
    public double Mode { get; }
    public double Median { get; }
    public double Variance { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public LaplaceDistribution(double location, double scale);
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.LevyDistribution : UnivariateContinuousDistribution {
    private double location;
    private double scale;
    private Nullable`1<double> median;
    public double Location { get; }
    public double Scale { get; }
    public double Mean { get; }
    public double Median { get; }
    public double Variance { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public LevyDistribution(double location);
    public LevyDistribution(double location, double scale);
    public double get_Location();
    public double get_Scale();
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double mu, double c);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.LogisticDistribution : UnivariateContinuousDistribution {
    private double mu;
    private double s;
    public double Location { get; }
    public double Mean { get; }
    public double Scale { get; }
    public double Median { get; }
    public double Variance { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public LogisticDistribution(double location);
    public LogisticDistribution(double location, double scale);
    public double get_Location();
    public virtual double get_Mean();
    public double get_Scale();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual double QuantileDensityFunction(double p);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double mean, double scale);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.LogLogisticDistribution : UnivariateContinuousDistribution {
    private double alpha;
    private double beta;
    public double Scale { get; }
    public double Shape { get; }
    public double Mean { get; }
    public double Median { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public LogLogisticDistribution(double alpha);
    public LogLogisticDistribution(double alpha, double beta);
    public double get_Scale();
    public double get_Shape();
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual double QuantileDensityFunction(double p);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    public virtual double HazardFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double scale, double shape);
    public static LogLogisticDistribution FromLocationShape(double location, double shape);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.LognormalDistribution : UnivariateContinuousDistribution {
    private double location;
    private double shape;
    private Nullable`1<double> mean;
    private Nullable`1<double> variance;
    private Nullable`1<double> entropy;
    private double shape2;
    private double constant;
    private bool immutable;
    private static LognormalDistribution standard;
    public double Shape { get; }
    public double Shape2 { get; }
    public double Location { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public static LognormalDistribution Standard { get; }
    public LognormalDistribution(double location);
    public LognormalDistribution(double location, double shape);
    private static LognormalDistribution();
    public double get_Shape();
    public double get_Shape2();
    public double get_Location();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public static LognormalDistribution get_Standard();
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, NormalOptions options);
    public virtual object Clone();
    private void initialize(double mu, double dev, double var);
    public static LognormalDistribution Estimate(Double[] observations);
    public static LognormalDistribution Estimate(Double[] observations, NormalOptions options);
    public static LognormalDistribution Estimate(Double[] observations, Double[] weights, NormalOptions options);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static double Random(double location, double shape);
    public static Double[] Random(double location, double shape, int samples);
    public static Double[] Random(double location, double shape, int samples, Double[] result);
    public static double Random(double location, double shape, Random source);
    public static Double[] Random(double location, double shape, int samples, Random source);
    public static Double[] Random(double location, double shape, int samples, Double[] result, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.MannWhitneyDistribution : UnivariateContinuousDistribution {
    private bool exact;
    private Double[] table;
    private int n1;
    private int n2;
    private NormalDistribution approximation;
    [CompilerGeneratedAttribute]
private ContinuityCorrection <Correction>k__BackingField;
    public int NumberOfSamples1 { get; }
    public int NumberOfSamples2 { get; }
    public ContinuityCorrection Correction { get; public set; }
    public bool Exact { get; }
    public Double[] Table { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public MannWhitneyDistribution(int n1, int n2);
    public MannWhitneyDistribution(Double[] ranks, int n1, int n2, Nullable`1<bool> exact);
    public MannWhitneyDistribution(Double[] ranks1, Double[] ranks2, Nullable`1<bool> exact);
    public int get_NumberOfSamples1();
    public int get_NumberOfSamples2();
    [CompilerGeneratedAttribute]
public ContinuityCorrection get_Correction();
    [CompilerGeneratedAttribute]
public void set_Correction(ContinuityCorrection value);
    public bool get_Exact();
    public Double[] get_Table();
    private void init(int n1, int n2, Double[] ranks, Nullable`1<bool> exact);
    private static double correction(Double[] ranks);
    private void initExactMethod(Double[] ranks);
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    private double distributionFunction(double x);
    private double complementaryDistributionFunction(double x);
    public static double MannWhitneyU(Double[] ranks);
    public virtual object Clone();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
private void <initExactMethod>b__22_1(Tuple`2<Double[], long> i);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.Mixture`1 : UnivariateContinuousDistribution {
    private Double[] coefficients;
    private T[] components;
    private Nullable`1<double> mean;
    private Nullable`1<double> variance;
    private Nullable`1<DoubleRange> range;
    private IDistribution`1[] cache;
    private ISampleableDistribution`1[] sampleable;
    public T[] Components { get; }
    public Double[] Coefficients { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public Mixture`1(T[] components);
    public Mixture`1(Double[] coefficients, T[] components);
    private void initialize();
    public sealed virtual T[] get_Components();
    public sealed virtual Double[] get_Coefficients();
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public double ProbabilityDensityFunction(int componentIndex, double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public double LogProbabilityDensityFunction(int componentIndex, double x);
    protected internal virtual double InnerDistributionFunction(double x);
    public double DistributionFunction(int componentIndex, double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, MixtureOptions options);
    public double LogLikelihood(Double[] observations, Double[] weights);
    public double LogLikelihood(Double[] observations);
    public virtual object Clone();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    public static Mixture`1<T> Estimate(Double[] data, T[] components);
    public static Mixture`1<T> Estimate(Double[] data, Double[] coefficients, T[] components);
    public static Mixture`1<T> Estimate(Double[] data, double threshold, Double[] coefficients, T[] components);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.NakagamiDistribution : UnivariateContinuousDistribution {
    private double mu;
    private double omega;
    private Nullable`1<double> mean;
    private Nullable`1<double> variance;
    private double constant;
    private double nratio;
    private double twoMu1;
    public double Shape { get; }
    public double Spread { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public NakagamiDistribution(double shape, double spread);
    private void init(double shape, double spread);
    public double get_Shape();
    public double get_Spread();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public static NakagamiDistribution Estimate(Double[] observations);
    public static NakagamiDistribution Estimate(Double[] observations, Double[] weights);
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(double shape, double spread, int samples);
    public static Double[] Random(double shape, double spread, int samples, Double[] result);
    public static double Random(double shape, double spread);
    public static Double[] Random(double shape, double spread, int samples, Random source);
    public static Double[] Random(double shape, double spread, int samples, Double[] result, Random source);
    public static double Random(double shape, double spread, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Distributions.Univariate.NamespaceDoc : object {
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.NegativeBinomialDistribution : UnivariateDiscreteDistribution {
    private int r;
    private double p;
    public double NumberOfFailures { get; }
    public double ProbabilityOfSuccess { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public NegativeBinomialDistribution(int failures, double probability);
    public double get_NumberOfFailures();
    public double get_ProbabilityOfSuccess();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual object Clone();
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.NoncentralTDistribution : UnivariateContinuousDistribution {
    private double v;
    private double u;
    private Nullable`1<double> mode;
    public double DegreesOfFreedom { get; }
    public double Noncentrality { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public NoncentralTDistribution(double degreesOfFreedom, double noncentrality);
    public double get_DegreesOfFreedom();
    public double get_Noncentrality();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private static double distributionFunctionLowerTail(double t, double df, double delta);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.NormalDistribution : UnivariateContinuousDistribution {
    private double mean;
    private double stdDev;
    private Nullable`1<double> entropy;
    private double variance;
    private double lnconstant;
    private bool immutable;
    private static double p95;
    private static NormalDistribution standard;
    [ThreadStaticAttribute]
private static bool useSecond;
    [ThreadStaticAttribute]
private static double secondValue;
    public double Mean { get; }
    public double Median { get; }
    public double Variance { get; }
    public double StandardDeviation { get; }
    public double Mode { get; }
    public double Skewness { get; }
    public double Kurtosis { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public static NormalDistribution Standard { get; }
    public NormalDistribution(double mean);
    public NormalDistribution(double mean, double stdDev);
    private static NormalDistribution();
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_StandardDeviation();
    public virtual double get_Mode();
    public double get_Skewness();
    public double get_Kurtosis();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public double ZScore(double x);
    public static NormalDistribution get_Standard();
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, NormalOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double mu, double dev, double var);
    public static NormalDistribution Estimate(Double[] observations);
    public static NormalDistribution Estimate(Double[] observations, NormalOptions options);
    public static NormalDistribution Estimate(Double[] observations, Double[] weights, NormalOptions options);
    public MultivariateNormalDistribution ToMultivariateDistribution();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static double Random(double mean, double stdDev);
    public static double Random(double mean, double stdDev, Random source);
    public static Double[] Random(double mean, double stdDev, int samples);
    public static Double[] Random(double mean, double stdDev, int samples, Random source);
    public static Double[] Random(double mean, double stdDev, int samples, Double[] result);
    public static Double[] Random(double mean, double stdDev, int samples, Double[] result, Random source);
    public static Double[] Random(int samples, Double[] result);
    public static Double[] Random(int samples, Double[] result, Random source);
    public static double Random();
    public static double Random(Random source);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.ParetoDistribution : UnivariateContinuousDistribution {
    private double xm;
    private double alpha;
    public double Scale { get; }
    public double Alpha { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public double Mode { get; }
    public double Median { get; }
    public ParetoDistribution(double scale, double shape);
    private void init(double scale, double shape);
    public double get_Scale();
    public double get_Alpha();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    public virtual double get_Mode();
    public virtual double get_Median();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.PoissonDistribution : UnivariateDiscreteDistribution {
    private double lambda;
    private double epml;
    private Nullable`1<double> entropy;
    private bool immutable;
    private static PoissonDistribution standard;
    public double Lambda { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public static PoissonDistribution Standard { get; }
    public PoissonDistribution(double lambda);
    private static PoissonDistribution();
    private void initialize(double lm);
    public double get_Lambda();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual Int32[] Generate(int samples, Int32[] result, Random source);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual int Generate(Random source);
    private static int knuth(Random random, double lambda);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static PoissonDistribution get_Standard();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.PowerLognormalDistribution : UnivariateContinuousDistribution {
    private double power;
    private double sigma;
    public double Power { get; }
    public double Shape { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double StandardDeviation { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public PowerLognormalDistribution(double power, double shape);
    public double get_Power();
    public double get_Shape();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_StandardDeviation();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual double HazardFunction(double x);
    public virtual double CumulativeHazardFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double power, double sigma);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.PowerNormalDistribution : UnivariateContinuousDistribution {
    private double power;
    public double Power { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double StandardDeviation { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public PowerNormalDistribution(double power);
    public double get_Power();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_StandardDeviation();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double power);
}
public class Accord.Statistics.Distributions.Univariate.RademacherDistribution : UnivariateDiscreteDistribution {
    public double Mean { get; }
    public double Variance { get; }
    public double Median { get; }
    public double Entropy { get; }
    public double Mode { get; }
    public IntRange Support { get; }
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Median();
    public virtual double get_Entropy();
    public virtual double get_Mode();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.RayleighDistribution : UnivariateContinuousDistribution {
    private double sigma;
    public double Mean { get; }
    public double Scale { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public RayleighDistribution(double sigma);
    public virtual double get_Mean();
    public double get_Scale();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public static RayleighDistribution Estimate(Double[] observations);
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(double sigma, int samples);
    public static Double[] Random(double sigma, int samples, Random source);
    public static Double[] Random(double sigma, int samples, Double[] result);
    public static Double[] Random(double sigma, int samples, Double[] result, Random source);
    public static double Random(double sigma);
    public static double Random(double sigma, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.ShapiroWilkDistribution : UnivariateContinuousDistribution {
    private Func`2<double, double> g;
    private Func`2<double, double> h;
    private NormalDistribution normal;
    [CompilerGeneratedAttribute]
private int <NumberOfSamples>k__BackingField;
    public int NumberOfSamples { get; private set; }
    public DoubleRange Support { get; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public double Median { get; }
    public double Entropy { get; }
    public ShapiroWilkDistribution(int samples);
    [CompilerGeneratedAttribute]
public int get_NumberOfSamples();
    [CompilerGeneratedAttribute]
private void set_NumberOfSamples(int value);
    public virtual DoubleRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual double get_Median();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.ShiftedLogLogisticDistribution : UnivariateContinuousDistribution {
    private double mu;
    private double sigma;
    private double ksi;
    public double Mean { get; }
    public double Location { get; }
    public double Scale { get; }
    public double Shape { get; }
    public double Median { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public ShiftedLogLogisticDistribution(double location);
    public ShiftedLogLogisticDistribution(double location, double scale);
    public ShiftedLogLogisticDistribution(double location, double scale, double shape);
    public virtual double get_Mean();
    public double get_Location();
    public double get_Scale();
    public double get_Shape();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double mean, double scale, double shape);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.SkewNormalDistribution : UnivariateContinuousDistribution {
    private double ksi;
    private double omega;
    private double alpha;
    private double delta;
    public double Location { get; }
    public double Scale { get; }
    public double Shape { get; }
    public double Entropy { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Skewness { get; }
    public double Kurtosis { get; }
    public DoubleRange Support { get; }
    public SkewNormalDistribution(double location);
    public SkewNormalDistribution(double location, double scale);
    public SkewNormalDistribution(double location, double scale, double shape);
    public double get_Location();
    public double get_Scale();
    public double get_Shape();
    public virtual double get_Entropy();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public double get_Skewness();
    public double get_Kurtosis();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double location, double scale, double shape);
    public static SkewNormalDistribution Normal(int mean, double stdDev);
}
public enum Accord.Statistics.Distributions.Univariate.SurvivalEstimator : Enum {
    public int value__;
    public static SurvivalEstimator FlemingHarrington;
    public static SurvivalEstimator KaplanMeier;
}
public enum Accord.Statistics.Distributions.Univariate.SurvivalOutcome : Enum {
    public int value__;
    public static SurvivalOutcome Started;
    public static SurvivalOutcome Failed;
    public static SurvivalOutcome Censored;
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.SymmetricGeometricDistribution : UnivariateDiscreteDistribution {
    private double p;
    private double lnconstant;
    public double ProbabilityOfSuccess { get; }
    public IntRange Support { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public SymmetricGeometricDistribution(double probabilityOfSuccess);
    public double get_ProbabilityOfSuccess();
    public virtual IntRange get_Support();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual int Generate(Random source);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual Int32[] Generate(int samples, Int32[] result, Random source);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.TDistribution : UnivariateContinuousDistribution {
    private double lnconstant;
    [CompilerGeneratedAttribute]
private double <DegreesOfFreedom>k__BackingField;
    public double DegreesOfFreedom { get; private set; }
    public double Mean { get; }
    public double Mode { get; }
    public double Variance { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public TDistribution(double degreesOfFreedom);
    [CompilerGeneratedAttribute]
public double get_DegreesOfFreedom();
    [CompilerGeneratedAttribute]
private void set_DegreesOfFreedom(double value);
    public virtual double get_Mean();
    public virtual double get_Mode();
    public virtual double get_Variance();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private static double inverseDistributionLeftTail(double df, double p);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.TrapezoidalDistribution : UnivariateContinuousDistribution {
    private double a;
    private double b;
    private double c;
    private double d;
    private double n1;
    private double n3;
    private double alpha;
    private double constant;
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public TrapezoidalDistribution(double a, double b, double c, double d);
    public TrapezoidalDistribution(double a, double b, double c, double d, double n1, double n3);
    public TrapezoidalDistribution(double a, double b, double c, double d, double n1, double n3, double alpha);
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.TriangularDistribution : UnivariateContinuousDistribution {
    private double a;
    private double b;
    private double c;
    public double Min { get; }
    public double Max { get; }
    public double Mean { get; }
    public double Median { get; }
    public double Variance { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public TriangularDistribution(double min, double max, double mode);
    public double get_Min();
    public double get_Max();
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double min, double max, double mode);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, TriangularOptions options);
    public void Fit(Double[] observations, Int32[] weights, TriangularOptions options);
    public static double GetMin(Double[] observations, Double[] weights, Int32& imin);
    public static double GetMax(Double[] observations, Double[] weights, Int32& imax);
    public static int FindMax(Double[] observations, double max);
    public static int FindMin(Double[] observations, double min);
    public static double GetMin(Double[] observations, Int32[] weights, Int32& imin);
    public static double GetMax(Double[] observations, Int32[] weights, Int32& imax);
    private static double GetMode(Double[] observations, Double[] weights, TriangularEstimationMethod method, double min, double max, int imax, int imin);
    private static double GetMode(Double[] observations, Int32[] weights, TriangularEstimationMethod method, double min, double max, int imax, int imin);
    private static double WeightedMode(Double[] observations, Double[] weights, int imax, int imin);
    private static double WeightedMode(Double[] observations, Int32[] weights, int imax, int imin);
    private static double MeanMaxMin(Double[] observations, Double[] weights, double min, double max, int imax, int imin);
    private static double MeanMaxMin(Double[] observations, Int32[] weights, double min, double max, int imax, int imin);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.TukeyLambdaDistribution : UnivariateContinuousDistribution {
    private double lambda;
    public double Lambda { get; }
    public double Mean { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public double Variance { get; }
    public DoubleRange Support { get; }
    public TukeyLambdaDistribution(double lambda);
    public double get_Lambda();
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual double get_Variance();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual double QuantileDensityFunction(double p);
    public double LogQuantileDensityFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    private void initialize(double lambda);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.UniformContinuousDistribution : UnivariateContinuousDistribution {
    private double a;
    private double b;
    private bool immutable;
    private static UniformContinuousDistribution standard;
    public double Minimum { get; }
    public double Maximum { get; }
    public double Length { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public static UniformContinuousDistribution Standard { get; }
    public UniformContinuousDistribution(DoubleRange range);
    public UniformContinuousDistribution(double a, double b);
    private static UniformContinuousDistribution();
    public double get_Minimum();
    public double get_Maximum();
    public double get_Length();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public static UniformContinuousDistribution get_Standard();
    public static UniformContinuousDistribution Estimate(Double[] observations);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(double a, double b, int samples);
    public static Double[] Random(double a, double b, int samples, Random source);
    public static Double[] Random(double a, double b, int samples, Double[] result);
    public static Double[] Random(double a, double b, int samples, Double[] result, Random source);
    public static Double[] Random(int samples);
    public static Double[] Random(int samples, Double[] result);
    public static Double[] Random(int samples, Double[] result, Random source);
    public static double Random();
    public static double Random(Random source);
    public static double Random(double a, double b);
    public static double Random(double a, double b, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.UniformDiscreteDistribution : UnivariateDiscreteDistribution {
    private int a;
    private int b;
    private int n;
    public double Minimum { get; }
    public double Maximum { get; }
    public double Length { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public UniformDiscreteDistribution(int a, int b);
    public double get_Minimum();
    public double get_Maximum();
    public double get_Length();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual IntRange get_Support();
    protected internal virtual double InnerDistributionFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public static Int32[] Random(int a, int b, int samples);
    public static Int32[] Random(int a, int b, int samples, Int32[] result);
    public static Int32[] Random(int samples);
    public static Int32[] Random(int samples, Int32[] result);
    public static int Random();
    public static int Random(int a, int b);
    public static Int32[] Random(int a, int b, int samples, Random source);
    public static Int32[] Random(int a, int b, int samples, Int32[] result, Random source);
    public static Int32[] Random(int samples, Random source);
    public static Int32[] Random(int samples, Int32[] result, Random source);
    public static int Random(Random source);
    public static int Random(int a, int b, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int Generate(Random source);
    public virtual Int32[] Generate(int samples, Int32[] result, Random source);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Distributions.Univariate.UnivariateContinuousDistribution : DistributionBase {
    [NonSerializedAttribute]
private Nullable`1<double> median;
    [NonSerializedAttribute]
private Nullable`1<double> stdDev;
    [NonSerializedAttribute]
private Nullable`1<double> mode;
    [NonSerializedAttribute]
private Nullable`1<DoubleRange> quartiles;
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public double Mode { get; }
    public DoubleRange Quartiles { get; }
    public double Median { get; }
    public double StandardDeviation { get; }
    public abstract virtual double get_Mean();
    public abstract virtual double get_Variance();
    public abstract virtual double get_Entropy();
    public abstract virtual DoubleRange get_Support();
    public virtual double get_Mode();
    public virtual DoubleRange get_Quartiles();
    public virtual DoubleRange GetRange(double percentile);
    public virtual double get_Median();
    public virtual double get_StandardDeviation();
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.DistributionFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.ComplementaryDistributionFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.ProbabilityFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.LogProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.LogProbabilityFunction(double x);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights, IFittingOptions options);
    public virtual double DistributionFunction(double x);
    protected internal virtual double InnerDistributionFunction(double x);
    public virtual double DistributionFunction(double a, double b);
    public virtual double ComplementaryDistributionFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    public sealed virtual double InverseDistributionFunction(double p);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    public virtual double QuantileDensityFunction(double p);
    public virtual double ProbabilityDensityFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual double LogProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual double HazardFunction(double x);
    public virtual double CumulativeHazardFunction(double x);
    public virtual double LogCumulativeHazardFunction(double x);
    public sealed virtual void Fit(Double[] observations);
    public sealed virtual void Fit(Double[] observations, Double[] weights);
    public void Fit(Double[] observations, Int32[] weights);
    public void Fit(Double[] observations, IFittingOptions options);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual Double[] Generate(int samples);
    public sealed virtual Double[] Generate(int samples, Double[] result);
    public sealed virtual double Generate();
    public sealed virtual Double[] Generate(int samples, Random source);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    private sealed virtual override double Accord.Statistics.Distributions.ISampleableDistribution<System.Double>.Generate(double result);
    private sealed virtual override double Accord.Statistics.Distributions.ISampleableDistribution<System.Double>.Generate(double result, Random source);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double>.ProbabilityFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double>.LogProbabilityFunction(double x);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Distributions.Univariate.UnivariateDiscreteDistribution : DistributionBase {
    private Nullable`1<double> median;
    private Nullable`1<double> stdDev;
    private Nullable`1<DoubleRange> quartiles;
    public double Mean { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public IntRange Support { get; }
    public double Mode { get; }
    public double Median { get; }
    public double StandardDeviation { get; }
    public DoubleRange Quartiles { get; }
    private DoubleRange Accord.Statistics.Distributions.IUnivariateDistribution.Support { get; }
    private DoubleRange Accord.Statistics.Distributions.IUnivariateDistribution<System.Int32>.Support { get; }
    private DoubleRange Accord.Statistics.Distributions.IUnivariateDistribution<System.Double>.Support { get; }
    public abstract virtual double get_Mean();
    public abstract virtual double get_Variance();
    public abstract virtual double get_Entropy();
    public abstract virtual IntRange get_Support();
    public virtual double get_Mode();
    public virtual double get_Median();
    public virtual double get_StandardDeviation();
    public virtual DoubleRange get_Quartiles();
    public virtual IntRange GetRange(double percentile);
    private sealed virtual override DoubleRange Accord.Statistics.Distributions.IUnivariateDistribution.get_Support();
    private sealed virtual override DoubleRange Accord.Statistics.Distributions.IUnivariateDistribution<System.Int32>.get_Support();
    private sealed virtual override DoubleRange Accord.Statistics.Distributions.IUnivariateDistribution<System.Double>.get_Support();
    private sealed virtual override DoubleRange Accord.Statistics.Distributions.IUnivariateDistribution.GetRange(double percentile);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.DistributionFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.DistributionFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.DistributionFunction(double a, double b);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.InverseDistributionFunction(double p);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.ComplementaryDistributionFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution.LogProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.ProbabilityFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.LogProbabilityFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.ComplementaryDistributionFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.HazardFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.CumulativeHazardFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution.LogCumulativeHazardFunction(double x);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Double[] weights, IFittingOptions options);
    private sealed virtual override void Accord.Statistics.Distributions.IDistribution.Fit(Array observations, Int32[] weights, IFittingOptions options);
    public virtual double DistributionFunction(int k);
    protected internal virtual double InnerDistributionFunction(int k);
    public virtual double DistributionFunction(int k, bool inclusive);
    public virtual double DistributionFunction(int a, int b);
    public sealed virtual int InverseDistributionFunction(double p);
    protected virtual int InnerInverseDistributionFunction(double p);
    protected int BaseInverseDistributionFunction(double p);
    private int UnboundedBaseInverseDistributionFunction(double p, int lower, int upper, int start);
    protected double BaseDistributionFunction(int k);
    public virtual double QuantileDensityFunction(double p);
    public virtual double ComplementaryDistributionFunction(int k, bool inclusive);
    public virtual double ComplementaryDistributionFunction(int k);
    protected internal virtual double InnerComplementaryDistributionFunction(int k);
    public virtual double ProbabilityMassFunction(int k);
    protected internal virtual double InnerProbabilityMassFunction(int k);
    public virtual double LogProbabilityMassFunction(int k);
    protected internal virtual double InnerLogProbabilityMassFunction(int k);
    public virtual double HazardFunction(int x);
    public virtual double CumulativeHazardFunction(int x);
    public virtual double LogCumulativeHazardFunction(int x);
    public virtual void Fit(Double[] observations);
    public virtual void Fit(Double[] observations, Double[] weights);
    public virtual void Fit(Double[] observations, Int32[] weights);
    public virtual void Fit(Double[] observations, IFittingOptions options);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Double[] observations, Int32[] weights, IFittingOptions options);
    public virtual void Fit(Int32[] observations);
    public virtual void Fit(Int32[] observations, IFittingOptions options);
    public virtual void Fit(Int32[] observations, Double[] weights, IFittingOptions options);
    public virtual void Fit(Int32[] observations, Int32[] weights, IFittingOptions options);
    public sealed virtual Int32[] Generate(int samples);
    public sealed virtual Int32[] Generate(int samples, Int32[] result);
    public sealed virtual Double[] Generate(int samples, Double[] result);
    public sealed virtual int Generate();
    public sealed virtual Int32[] Generate(int samples, Random source);
    public virtual Int32[] Generate(int samples, Int32[] result, Random source);
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual int Generate(Random source);
    private sealed virtual override Double[] Accord.Math.Random.IRandomNumberGenerator<System.Double>.Generate(int samples);
    private sealed virtual override Double[] Accord.Statistics.Distributions.ISampleableDistribution<System.Double>.Generate(int samples, Random source);
    private sealed virtual override double Accord.Statistics.Distributions.ISampleableDistribution<System.Double>.Generate(double result);
    private sealed virtual override int Accord.Statistics.Distributions.ISampleableDistribution<System.Int32>.Generate(int result);
    private sealed virtual override double Accord.Statistics.Distributions.ISampleableDistribution<System.Double>.Generate(double result, Random source);
    private sealed virtual override int Accord.Statistics.Distributions.ISampleableDistribution<System.Int32>.Generate(int result, Random source);
    private sealed virtual override double Accord.Math.Random.IRandomNumberGenerator<System.Double>.Generate();
    private sealed virtual override double Accord.Statistics.Distributions.ISampleableDistribution<System.Double>.Generate(Random source);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Int32>.ProbabilityFunction(int x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Int32>.LogProbabilityFunction(int x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.DistributionFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.ProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.LogProbabilityFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double[]>.ComplementaryDistributionFunction(Double[] x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double>.DistributionFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double>.ProbabilityFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double>.LogProbabilityFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IDistribution<System.Double>.ComplementaryDistributionFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution<System.Double>.InverseDistributionFunction(double p);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution<System.Double>.HazardFunction(double x);
    private sealed virtual override double Accord.Statistics.Distributions.IUnivariateDistribution<System.Double>.CumulativeHazardFunction(double x);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.UQuadraticDistribution : UnivariateContinuousDistribution {
    private double a;
    private double b;
    private double alpha;
    private double beta;
    public double Mean { get; }
    public double Median { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public UQuadraticDistribution(double a, double b);
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.VonMisesDistribution : UnivariateContinuousDistribution {
    private double mean;
    private double kappa;
    private Nullable`1<double> variance;
    private Nullable`1<double> entropy;
    private double constant;
    public double Mean { get; }
    public double Median { get; }
    public double Mode { get; }
    public double Concentration { get; }
    public double Variance { get; }
    public double Entropy { get; }
    public DoubleRange Support { get; }
    public VonMisesDistribution(double concentration);
    public VonMisesDistribution(double mean, double concentration);
    private void initialize(double m, double k);
    public virtual double get_Mean();
    public virtual double get_Median();
    public virtual double get_Mode();
    public double get_Concentration();
    public virtual double get_Variance();
    public virtual double get_Entropy();
    public virtual DoubleRange get_Support();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, VonMisesOptions options);
    public static VonMisesDistribution CircularUniform(double mean);
    public virtual object Clone();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public static VonMisesDistribution Estimate(Double[] angles);
    public static VonMisesDistribution Estimate(Double[] angles, VonMisesOptions options);
    public static VonMisesDistribution Estimate(Double[] angles, Double[] weights, VonMisesOptions options);
    public static double DistributionFunction(double x, double mu, double kappa);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.WeibullDistribution : UnivariateContinuousDistribution {
    private double k;
    private double lambda;
    public double Shape { get; }
    public double Scale { get; }
    public double Mean { get; }
    public double Variance { get; }
    public double Median { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public WeibullDistribution(double shape, double scale);
    public double get_Shape();
    public double get_Scale();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Median();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual double HazardFunction(double x);
    public virtual double CumulativeHazardFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    public double InverseComplementaryDistributionFunction(double p);
    public virtual void Fit(Double[] observations, Double[] weights, IFittingOptions options);
    public virtual object Clone();
    public virtual Double[] Generate(int samples, Double[] result, Random source);
    public virtual double Generate(Random source);
    public static Double[] Random(double shape, double scale, int samples);
    public static Double[] Random(double shape, double scale, int samples, Random source);
    public static Double[] Random(double shape, double scale, int samples, Double[] result);
    public static Double[] Random(double shape, double scale, int samples, Double[] result, Random source);
    public static double Random(double shape, double scale);
    public static double Random(double shape, double scale, Random source);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[SerializableAttribute]
public class Accord.Statistics.Distributions.Univariate.WilcoxonDistribution : UnivariateContinuousDistribution {
    private bool exact;
    private Double[] table;
    private int n;
    private NormalDistribution approximation;
    [CompilerGeneratedAttribute]
private ContinuityCorrection <Correction>k__BackingField;
    public int NumberOfSamples { get; }
    public bool Exact { get; }
    public Double[] Table { get; }
    public ContinuityCorrection Correction { get; public set; }
    public double Mean { get; }
    public double Variance { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public WilcoxonDistribution(int n);
    public WilcoxonDistribution(Double[] ranks, Nullable`1<bool> exact);
    public int get_NumberOfSamples();
    public bool get_Exact();
    public Double[] get_Table();
    [CompilerGeneratedAttribute]
public ContinuityCorrection get_Correction();
    [CompilerGeneratedAttribute]
public void set_Correction(ContinuityCorrection value);
    private void init(int n, Double[] ranks, Nullable`1<bool> exact);
    private void initExactMethod(Double[] ranks);
    public static double WPositive(Int32[] signs, Double[] ranks);
    public static double WNegative(Int32[] signs, Double[] ranks);
    public static double WMinimum(Int32[] signs, Double[] ranks);
    public virtual object Clone();
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerComplementaryDistributionFunction(double x);
    protected internal virtual double InnerInverseDistributionFunction(double p);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    internal static double exactMethod(double x, Double[] table);
    internal static double exactComplement(double x, Double[] table);
    internal static int count(double x, Double[] table);
}
public class Accord.Statistics.Distributions.Univariate.WrappedCauchyDistribution : UnivariateContinuousDistribution {
    private double mu;
    private double gamma;
    public double Mean { get; }
    public double Variance { get; }
    public double Median { get; }
    public double Mode { get; }
    public DoubleRange Support { get; }
    public double Entropy { get; }
    public WrappedCauchyDistribution(double mu, double gamma);
    public virtual double get_Mean();
    public virtual double get_Variance();
    public virtual double get_Median();
    public virtual double get_Mode();
    public virtual DoubleRange get_Support();
    public virtual double get_Entropy();
    protected internal virtual double InnerDistributionFunction(double x);
    protected internal virtual double InnerProbabilityDensityFunction(double x);
    protected internal virtual double InnerLogProbabilityDensityFunction(double x);
    public virtual object Clone();
    public void Fit(Double[] observations, Int32[] weights, CauchyOptions options);
    public sealed virtual void Fit(Double[] observations, Double[] weights, CauchyOptions options);
    public virtual string ToString(string format, IFormatProvider formatProvider);
}
[DefaultMemberAttribute("Item")]
[SerializableAttribute]
public abstract class Accord.Statistics.Filters.BaseFilter`2 : object {
    [NonSerializedAttribute]
private CancellationToken token;
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnOptionCollection`2<TOptions, TFilter> <Columns>k__BackingField;
    [DescriptionAttribute("Gets or sets whether this filter is active.")]
public bool Active { get; public set; }
    [DescriptionAttribute("Gets or sets processing options for the columns in the source DataTables")]
public ColumnOptionCollection`2<TOptions, TFilter> Columns { get; private set; }
    public CancellationToken Token { get; public set; }
    public TOptions Item { get; }
    public TOptions Item { get; }
    public int NumberOfInputs { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Active();
    [CompilerGeneratedAttribute]
public void set_Active(bool value);
    [CompilerGeneratedAttribute]
public ColumnOptionCollection`2<TOptions, TFilter> get_Columns();
    [CompilerGeneratedAttribute]
private void set_Columns(ColumnOptionCollection`2<TOptions, TFilter> value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public TOptions get_Item(string columnName);
    public TOptions get_Item(int index);
    public sealed virtual int get_NumberOfInputs();
    public sealed virtual void set_NumberOfInputs(int value);
    public sealed virtual IEnumerator`1<TOptions> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(TOptions options);
    private void Columns_AddingNew(object sender, TOptions e);
    protected virtual void OnAddingOptions(TOptions options);
}
[SerializableAttribute]
public class Accord.Statistics.Filters.Codification : Codification`1<string> {
    public Codification(string columnName, String[] values);
    public Codification(String[] columnNames, String[][] values);
    public Codification(string columnName, String[][] values);
    public Int32[] Transform(String[0...,0...] values);
    [ObsoleteAttribute("Please use Transform(columnName, value) instead.")]
public int Translate(string columnName, string value);
    [ObsoleteAttribute("Please use Transform(data) instead.")]
public Int32[] Translate(String[] data);
    [ObsoleteAttribute("Please use Transform(columnNames, values) instead.")]
public Int32[] Translate(String[] columnNames, String[] values);
    [ObsoleteAttribute("Please use Transform(columnName, value) instead.")]
public Int32[] Translate(string columnName, String[] values);
    [ObsoleteAttribute("Please use Transform(columnName, values) instead.")]
public Int32[][] Translate(string columnName, String[][] values);
    [ObsoleteAttribute("Please use Revert(columnName, codeword) instead.")]
public string Translate(string columnName, int codeword);
    [ObsoleteAttribute("Please use Revert(columnName, codewords) instead.")]
public String[] Translate(string columnName, Int32[] codewords);
    [ObsoleteAttribute("Please use Revert(columnNames, codewords) instead.")]
public String[] Translate(String[] columnNames, Int32[] codewords);
    public void Detect(string columnName, String[] values);
    public void Detect(string columnName, String[][] values);
    public void Detect(String[] columnNames, String[][] values);
}
[SerializableAttribute]
public class Accord.Statistics.Filters.Codification`1 : BaseFilter`2<Options<T>, Codification`1<T>> {
    private object defaultMissingValueReplacement;
    public int NumberOfOutputs { get; }
    public object DefaultMissingValueReplacement { get; public set; }
    private int Accord.MachineLearning.ITransform.NumberOfOutputs { get; private set; }
    public Codification`1(string columnName, T[] values);
    public Codification`1(String[] columnNames, T[][] values);
    public Codification`1(string columnName, T[][] values);
    public int get_NumberOfOutputs();
    public object get_DefaultMissingValueReplacement();
    public void set_DefaultMissingValueReplacement(object value);
    private sealed virtual override int Accord.MachineLearning.ITransform.get_NumberOfOutputs();
    private sealed virtual override void Accord.MachineLearning.ITransform.set_NumberOfOutputs(int value);
    public int Transform(string columnName, T value);
    public sealed virtual Int32[] Transform(T[] data);
    public Int32[] Transform(String[] columnNames, T[] values);
    public Int32[] Transform(string columnName, T[] values);
    public Int32[][] Transform(string columnName, T[][] values);
    public sealed virtual Int32[][] Transform(T[][] input);
    public sealed virtual Int32[][] Transform(T[][] input, Int32[][] result);
    private sealed virtual override Double[] Accord.MachineLearning.ICovariantTransform<T[],System.Double[]>.Transform(T[] input);
    private sealed virtual override Double[][] Accord.MachineLearning.ICovariantTransform<T[],System.Double[]>.Transform(T[][] input);
    public sealed virtual Double[][] Transform(T[][] input, Double[][] result);
    public T Revert(string columnName, int codeword);
    public T[] Revert(Int32[] codewords);
    public T[] Revert(string columnName, Int32[] codewords);
    public T[] Revert(String[] columnNames, Int32[] codewords);
    private static string getFactorName(Options<T> options, T name);
    public Codification`1<T> Learn(T[] x, Double[] weights);
    public sealed virtual Codification`1<T> Learn(T[][] x, Double[] weights);
    public ITransform`2<T[], Double[]> ToDouble();
    public void Add(CodificationVariable codificationVariable);
    public void Add(string name, CodificationVariable codificationVariable);
    public void Add(string name, CodificationVariable codificationVariable, T baseline);
    public void Add(string name, CodificationVariable codificationVariable, T[] order);
    protected virtual void OnAddingOptions(Options<T> options);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
}
public enum Accord.Statistics.Filters.CodificationVariable : Enum {
    public int value__;
    public static CodificationVariable Default;
    public static CodificationVariable Ordinal;
    public static CodificationVariable Categorical;
    public static CodificationVariable CategoricalWithBaseline;
    public static CodificationVariable Continuous;
    public static CodificationVariable Discrete;
}
[SerializableAttribute]
public class Accord.Statistics.Filters.ColumnOptionCollection`2 : KeyedCollection`2<string, TOptions> {
    [CompilerGeneratedAttribute]
private EventHandler`1<TOptions> AddingNew;
    [CompilerGeneratedAttribute]
public void add_AddingNew(EventHandler`1<TOptions> value);
    [CompilerGeneratedAttribute]
public void remove_AddingNew(EventHandler`1<TOptions> value);
    protected virtual string GetKeyForItem(TOptions item);
    public TOptions Add(TOptions options);
    public bool TryGetValue(string columnName, TOptions& options);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Filters.ColumnOptionsBase`1 : object {
    [NonSerializedAttribute]
private CancellationToken token;
    [CompilerGeneratedAttribute]
private TFilter <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    public TFilter Owner { get; public set; }
    public string ColumnName { get; internal set; }
    public object Tag { get; public set; }
    public CancellationToken Token { get; public set; }
    protected ColumnOptionsBase`1(string column);
    [CompilerGeneratedAttribute]
public TFilter get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(TFilter value);
    [CompilerGeneratedAttribute]
public string get_ColumnName();
    [CompilerGeneratedAttribute]
internal void set_ColumnName(string value);
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public virtual string ToString();
}
[SerializableAttribute]
public class Accord.Statistics.Filters.Discretization`2 : BaseFilter`2<Options<TInput, TOutput>, Discretization`2<TInput, TOutput>> {
    public int NumberOfOutputs { get; public set; }
    public Discretization`2(String[] columns);
    public Discretization`2(String[] columns, Object[][] data);
    public Discretization`2(String[] columns, TInput[][] data);
    public sealed virtual int get_NumberOfOutputs();
    public sealed virtual void set_NumberOfOutputs(int value);
    public TOutput Transform(string columnName, TInput value);
    public TOutput[][] Transform(Object[][] data);
    public TOutput[] Transform(Object[] data);
    public sealed virtual TOutput[] Transform(TInput[] data);
    public TOutput[] Transform(String[] columnNames, TInput[] values);
    public TOutput[] Transform(string columnName, TInput[] values);
    public TOutput[][] Transform(string columnName, TInput[][] values);
    public sealed virtual TOutput[][] Transform(TInput[][] input);
    public sealed virtual TOutput[][] Transform(TInput[][] input, TOutput[][] result);
    public Discretization`2<TInput, TOutput> Learn(TInput[] x, Double[] weights);
    public sealed virtual Discretization`2<TInput, TOutput> Learn(TInput[][] x, Double[] weights);
    public void Add(string columnName, Expression`1<Func`2<TInput, bool>> rule, TOutput output);
    public void Add(string columnName, Expression`1<Func`2<TInput, bool>> rule, Expression`1<Func`2<TInput, TOutput>> output);
}
[SerializableAttribute]
public class Accord.Statistics.Filters.FiltersSequence : Collection`1<IFilter> {
    public FiltersSequence(IFilter[] filters);
}
public interface Accord.Statistics.Filters.IAutoConfigurableColumn {
}
public interface Accord.Statistics.Filters.IAutoConfigurableFilter {
}
public interface Accord.Statistics.Filters.IFilter {
}
public interface Accord.Statistics.Filters.IInPlaceFilter {
}
[SerializableAttribute]
public class Accord.Statistics.Filters.Imputation : Imputation`1<object> {
    public Imputation(String[] names, Object[][] data);
    public Imputation(Object[][] data);
    public Imputation(String[] columns);
}
[SerializableAttribute]
public class Accord.Statistics.Filters.Imputation`1 : BaseFilter`2<Options<T>, Imputation`1<T>> {
    public int NumberOfOutputs { get; }
    private int Accord.MachineLearning.ITransform.NumberOfOutputs { get; private set; }
    public Imputation`1(T[][] data);
    public Imputation`1(String[] columnNames, T[][] data);
    public Imputation`1(String[] columnNames);
    public int get_NumberOfOutputs();
    public sealed virtual T[] Transform(T[] input);
    public sealed virtual T[][] Transform(T[][] input);
    public sealed virtual T[][] Transform(T[][] input, T[][] result);
    public sealed virtual Imputation`1<T> Learn(T[][] x, Double[] weights);
    private sealed virtual override int Accord.MachineLearning.ITransform.get_NumberOfOutputs();
    private sealed virtual override void Accord.MachineLearning.ITransform.set_NumberOfOutputs(int value);
}
public enum Accord.Statistics.Filters.ImputationStrategy : Enum {
    public int value__;
    public static ImputationStrategy FixedValue;
    public static ImputationStrategy Mean;
    public static ImputationStrategy Mode;
    public static ImputationStrategy Median;
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Additive : KernelBase {
    private IKernel[] kernels;
    private Double[] weights;
    public IKernel[] Kernels { get; }
    public Double[] Weights { get; }
    public Additive(IKernel[] kernels);
    public Additive(IKernel[] kernels, Double[] weights);
    public IKernel[] get_Kernels();
    public Double[] get_Weights();
    public virtual double Function(Double[] x, Double[] y);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Anova : KernelBase {
    private int n;
    private int p;
    private Double[0...,0...,0...] K;
    public Anova(int vectorLength, int subsequenceLength);
    public virtual double Function(Double[] x, Double[] y);
    private double kernel(Double[] x, int ni, Double[] y, int mi, int pi);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Bessel : KernelBase {
    private int order;
    private double sigma;
    public int Order { get; public set; }
    public double Sigma { get; public set; }
    public Bessel(int order, double sigma);
    public int get_Order();
    public void set_Order(int value);
    public double get_Sigma();
    public void set_Sigma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.BSpline : KernelBase {
    private int order;
    public int Order { get; public set; }
    public BSpline(int order);
    public int get_Order();
    public void set_Order(int value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Cauchy : KernelBase {
    private double sigma;
    public double Sigma { get; public set; }
    public Cauchy(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double Distance(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.ChiSquare : KernelBase {
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Circular : KernelBase {
    private static double c2dPI;
    private double sigma;
    public double Sigma { get; public set; }
    public Circular(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Custom : KernelBase {
    private Func`3<Double[], Double[], double> func;
    public Custom(Func`3<Double[], Double[], double> function);
    public virtual double Function(Double[] x, Double[] y);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Dirichlet : KernelBase {
    private int N;
    public int Dimension { get; public set; }
    public Dirichlet(int dimension);
    public int get_Dimension();
    public void set_Dimension(int value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.DynamicTimeWarping : ValueType {
    private double alpha;
    private int length;
    private int degree;
    [NonSerializedAttribute]
private ThreadLocal`1<Locals> locals;
    public int Length { get; public set; }
    public double Alpha { get; public set; }
    public int Degree { get; public set; }
    public DynamicTimeWarping(int length);
    public DynamicTimeWarping(int length, double alpha);
    public DynamicTimeWarping(int length, double alpha, int degree);
    public DynamicTimeWarping(double alpha, int degree);
    public int get_Length();
    public void set_Length(int value);
    public double get_Alpha();
    public void set_Alpha(double value);
    public int get_Degree();
    public void set_Degree(int value);
    public sealed virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(Double[][] x, Double[][] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(Double[][] x, Double[][] y);
    internal double k(Double[] x, Double[] y);
    internal double k(Double[][] x, Double[][] y);
    private double D(Locals locals, Double[] sequence1, Double[] sequence2);
    private double D(Locals locals, Double[][] sequence1, Double[][] sequence2);
    private Double[] snorm(Double[] input);
    private Double[][] snorm(Double[][] input);
    public sealed virtual object Clone();
    [OnDeserializedAttribute]
private void onDeserialized(StreamingContext context);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.DynamicTimeWarping`2 : ValueType {
    private double sigma;
    private double gamma;
    private TDistance distance;
    [NonSerializedAttribute]
private ThreadLocal`1<Locals<TDistance, TInput>> locals;
    public double Sigma { get; public set; }
    public double SigmaSquared { get; public set; }
    public double Gamma { get; public set; }
    public DynamicTimeWarping`2(TDistance innerKernel);
    public DynamicTimeWarping`2(TDistance innerKernel, double sigma);
    public DynamicTimeWarping`2(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public double get_SigmaSquared();
    public void set_SigmaSquared(double value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public sealed virtual double Function(TInput[] x, TInput[] y);
    public sealed virtual double Distance(TInput[] x, TInput[] y);
    internal double k(TInput[] x, TInput[] y);
    private double D(Locals<TDistance, TInput> locals, TInput[] sequence1, TInput[] sequence2);
    public sealed virtual object Clone();
    [OnDeserializedAttribute]
private void onDeserialized(StreamingContext context);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Gaussian : ValueType {
    private double sigma;
    private double gamma;
    public double Sigma { get; public set; }
    public double SigmaSquared { get; public set; }
    public double Gamma { get; public set; }
    public Gaussian(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public double get_SigmaSquared();
    public void set_SigmaSquared(double value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public sealed virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double Function(double z);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double ReverseDistance(Double[] x, Double[] y);
    public double ReverseDistance(double df);
    public static Gaussian FromGamma(double gamma);
    public static Gaussian Estimate(Double[][] inputs);
    public static Gaussian Estimate(Double[][] inputs, DoubleRange& range);
    public static Gaussian Estimate(Double[][] inputs, int samples);
    public static Gaussian Estimate(Double[][] inputs, int samples, DoubleRange& range);
    public static Gaussian Estimate(Sparse`1[] inputs);
    public static Gaussian Estimate(Sparse`1[] inputs, DoubleRange& range);
    public static Gaussian Estimate(Sparse`1[] inputs, int samples);
    public static Gaussian Estimate(Sparse`1[] inputs, int samples, DoubleRange& range);
    public static Gaussian Estimate(TInput[] inputs, TDistance distance);
    public static Gaussian Estimate(TInput[] inputs, TDistance distance, DoubleRange& range);
    public static Gaussian Estimate(TInput[] inputs, int samples, TDistance distance);
    public static Gaussian Estimate(TInput[] inputs, int samples, TDistance distance, DoubleRange& range);
    public static Double[] Distances(Double[][] inputs, int samples);
    public static Double[] Distances(Sparse`1[] inputs, int samples);
    public static Double[] Distances(TInput[] inputs, int samples, TDistance distance);
    private sealed virtual override void Accord.Statistics.Kernels.IEstimable<System.Double[]>.Estimate(Double[][] inputs);
    private sealed virtual override void Accord.Statistics.Kernels.IEstimable<Accord.Math.Sparse<System.Double>>.Estimate(Sparse`1[] inputs);
    public sealed virtual object Clone();
    public static Gaussian`1<T> Estimate(T kernel, Double[][] inputs);
    public static Gaussian`1<T> Estimate(T kernel, Double[][] inputs, DoubleRange& range);
    public static Gaussian`1<T> Estimate(T kernel, Double[][] inputs, int samples);
    public static Gaussian`1<T> Estimate(T kernel, Double[][] inputs, int samples, DoubleRange& range);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Gaussian`1 : KernelBase {
    private double sigma;
    private double gamma;
    private TDistance distance;
    public double Sigma { get; public set; }
    public double SigmaSquared { get; public set; }
    public double Gamma { get; public set; }
    public Gaussian`1(TDistance innerKernel);
    public Gaussian`1(TDistance innerKernel, double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public double get_SigmaSquared();
    public void set_SigmaSquared(double value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public virtual double Function(Double[] x, Double[] y);
    private sealed virtual override void Accord.Statistics.Kernels.IEstimable<System.Double[]>.Estimate(Double[][] inputs);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Gaussian`2 : ValueType {
    private double sigma;
    private double gamma;
    private TDistance distance;
    public double Sigma { get; public set; }
    public double SigmaSquared { get; public set; }
    public double Gamma { get; public set; }
    public Gaussian`2(TDistance innerKernel);
    public Gaussian`2(TDistance innerKernel, double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public double get_SigmaSquared();
    public void set_SigmaSquared(double value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public sealed virtual double Function(TInput x, TInput y);
    public sealed virtual double Distance(TInput x, TInput y);
    private sealed virtual override void Accord.Statistics.Kernels.IEstimable<TInput>.Estimate(TInput[] inputs);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Hellinger : KernelBase {
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.HistogramIntersection : KernelBase {
    private double alpha;
    private double beta;
    public HistogramIntersection(double alpha, double beta);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Hypersecant : KernelBase {
    private double gamma;
    public double Gamma { get; public set; }
    public Hypersecant(double gamma);
    public double get_Gamma();
    public void set_Gamma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
public interface Accord.Statistics.Kernels.IEstimable {
}
public interface Accord.Statistics.Kernels.IEstimable`1 {
    public abstract virtual void Estimate(TInput[] inputs);
}
public interface Accord.Statistics.Kernels.IKernel {
}
public interface Accord.Statistics.Kernels.IKernel`1 {
    public abstract virtual double Function(T x, T y);
}
public interface Accord.Statistics.Kernels.ILinear {
}
public interface Accord.Statistics.Kernels.ILinear`1 {
    public abstract virtual void Add(T a, Double[] b, Double[] result);
    public abstract virtual void Product(double a, T b, Double[] accumulate);
    public abstract virtual void Product(Double[] a, T b, Double[] accumulate);
    public abstract virtual T Compress(Double[] weights, T[] supportVectors, Double& c);
    public abstract virtual double Function(Double[] y, T x);
    public abstract virtual int GetLength(T[] inputs);
    public abstract virtual T CreateVector(Double[] values);
    public abstract virtual Double[][] ToDouble(T[] input);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.InverseMultiquadric : KernelBase {
    private double constant;
    public double Constant { get; public set; }
    public InverseMultiquadric(double constant);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
public interface Accord.Statistics.Kernels.IRadialBasisKernel {
    public abstract virtual double Function(double z);
}
public interface Accord.Statistics.Kernels.IReverseDistance {
    public abstract virtual double ReverseDistance(Double[] x, Double[] y);
}
public interface Accord.Statistics.Kernels.ITransform {
}
public interface Accord.Statistics.Kernels.ITransform`1 {
    public abstract virtual Double[] Transform(TInput input);
    public abstract virtual Double[][] Transform(TInput[] input);
}
[ExtensionAttribute]
public static class Accord.Statistics.Kernels.Kernel : object {
    [ExtensionAttribute]
public static Double[0...,0...] ToMatrix(TKernel kernel, TInput[] x, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[0...,0...] ToMatrix2(TKernel kernel, TInput[] x, TInput[] y, Double[0...,0...] result);
    [ExtensionAttribute]
public static Double[][] ToJagged(TKernel kernel, TInput[] x, Double[][] result);
    [ExtensionAttribute]
public static Double[][] ToJagged2(TKernel kernel, TInput[] x, TInput[] y, Double[][] result);
    [ExtensionAttribute]
public static double EstimateComplexity(TKernel kernel, TInput[] inputs);
    [ExtensionAttribute]
public static Tuple`2<double, double> EstimateComplexity(TKernel kernel, TInput[] inputs, Int32[] outputs);
    public static double EstimateComplexity(Double[][] inputs);
    public static Tuple`2<double, double> EstimateComplexity(Double[][] inputs, Int32[] outputs);
    [ExtensionAttribute]
public static Double[] Distances(T kernel, Double[][] inputs, int samples);
    [ExtensionAttribute]
public static Double[] Distances(TKernel kernel, TData[] inputs, int samples);
    public static Double[0...,0...] Center(Double[0...,0...] kernelMatrix, Double[0...,0...] result);
    public static Double[][] Center(Double[][] kernelMatrix, Double[]& rowMean, Double& mean, Double[][] result);
    public static Double[0...,0...] Center(Double[0...,0...] kernelMatrix, Double[] rowMean, double mean, Double[0...,0...] result);
    public static Double[][] Center(Double[][] kernelMatrix, Double[] rowMean, double mean, Double[][] result);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Kernels.KernelBase : KernelBase`1<Double[]> {
}
[SerializableAttribute]
public abstract class Accord.Statistics.Kernels.KernelBase`1 : object {
    public virtual double Distance(TInput x, TInput y);
    public abstract virtual double Function(TInput x, TInput y);
}
public class Accord.Statistics.Kernels.KernelFunctionCache : KernelFunctionCache`2<IKernel, Double[]> {
    public KernelFunctionCache(IKernel kernel, Double[][] inputs);
    public KernelFunctionCache(IKernel kernel, Double[][] inputs, int cacheSize);
    public static int GetNumberOfRowsForMaximumSizeInBytes(int bytes);
    public static int GetNumberOfRowsForMaximumSizeInMegaBytes(double megaBytes);
    public static int GetNumberOfRowsForMaximumSizeInGigaBytes(double gigaBytes);
}
[DefaultMemberAttribute("Item")]
public class Accord.Statistics.Kernels.KernelFunctionCache`2 : object {
    private int maxNumberOfRows;
    private Dictionary`2<int, Double[]> rows;
    private LinkedList`1<int> lruIndices;
    private Dictionary`2<int, LinkedListNode`1<int>> lruIndicesLookupTable;
    private Double[] diagonal;
    private TInput[] inputs;
    private TKernel kernel;
    private int misses;
    private int hits;
    private Double[][] matrix;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    private bool disposedValue;
    public int Size { get; }
    public int Count { get; }
    public int MaximumBytes { get; }
    public int MinimumBytes { get; }
    public int Hits { get; }
    public int Misses { get; }
    public double Usage { get; }
    public bool Enabled { get; private set; }
    public double Item { get; }
    public double Item { get; }
    public KernelFunctionCache`2(TKernel kernel, TInput[] inputs);
    public KernelFunctionCache`2(TKernel kernel, TInput[] inputs, int cacheSize);
    public int get_Size();
    public int get_Count();
    public int get_MaximumBytes();
    public int get_MinimumBytes();
    public int get_Hits();
    public int get_Misses();
    public double get_Usage();
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
private void set_Enabled(bool value);
    public double GetOrCompute(int i);
    public double GetOrCompute(int i, int j);
    public double get_Item(int i);
    public double get_Item(int i, int j);
    public void Clear();
    public void Reset();
    public int GetKeyFromIndex(int i, int j);
    public IDictionary`2<Tuple`2<int, int>, double> GetDataCache();
    public IList`1<Tuple`2<int, int>> GetLeastRecentlyUsedList();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Laplacian : KernelBase {
    private double sigma;
    private double gamma;
    public double Sigma { get; public set; }
    public double Gamma { get; public set; }
    public Laplacian(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double Function(double z);
    public virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double ReverseDistance(Double[] x, Double[] y);
    public double ReverseDistance(double df);
    public static Laplacian Estimate(Double[][] inputs);
    public static Laplacian Estimate(Double[][] inputs, int samples, DoubleRange& range);
    public sealed virtual object Clone();
    private sealed virtual override void Accord.Statistics.Kernels.IEstimable<System.Double[]>.Estimate(Double[][] inputs);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Linear : ValueType {
    private double constant;
    public double Constant { get; public set; }
    public Linear(double constant);
    public double get_Constant();
    public void set_Constant(double value);
    public sealed virtual double Function(Double[] x, Double[] y);
    public double Function(double z);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double ReverseDistance(Double[] x, Double[] y);
    public sealed virtual void Add(Double[] a, Double[] b, Double[] result);
    public sealed virtual object Clone();
    public sealed virtual void Product(double a, Double[] b, Double[] accumulate);
    public sealed virtual Double[] Compress(Double[] weights, Double[][] supportVectors, Double& c);
    public sealed virtual Double[] Transform(Double[] input);
    public sealed virtual Double[][] Transform(Double[][] inputs);
    public static Double[] Transform(Double[] input, double constant);
    public sealed virtual double Function(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double Function(Double[] y, Sparse`1<double> x);
    public sealed virtual void Add(Sparse`1<double> a, Double[] b, Double[] result);
    public sealed virtual void Product(double a, Sparse`1<double> b, Double[] accumulate);
    public sealed virtual Sparse`1<double> Compress(Double[] weights, Sparse`1[] supportVectors, Double& c);
    public sealed virtual int GetLength(Double[][] inputs);
    public sealed virtual int GetLength(Sparse`1[] inputs);
    public sealed virtual Double[] CreateVector(Double[] values);
    public Double[] CreateVector(int dimensions);
    private sealed virtual override Sparse`1<double> Accord.Statistics.Kernels.ILinear<Accord.Math.Sparse<System.Double>>.CreateVector(Double[] values);
    public sealed virtual void Product(Double[] a, Sparse`1<double> b, Double[] accumulate);
    public sealed virtual void Product(Double[] a, Double[] b, Double[] accumulate);
    public sealed virtual Double[][] ToDouble(Double[][] input);
    public sealed virtual Double[][] ToDouble(Sparse`1[] input);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Log : KernelBase {
    private double degree;
    public double Degree { get; public set; }
    public Log(int degree);
    public Log(double degree);
    public double get_Degree();
    public void set_Degree(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Multiquadric : KernelBase {
    private double constant;
    public double Constant { get; public set; }
    public Multiquadric(double constant);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Normalized`1 : KernelBase {
    private TKernel kernel;
    private double power;
    public TKernel Kernel { get; public set; }
    public double Power { get; public set; }
    public Normalized`1(TKernel kernel, double power);
    public TKernel get_Kernel();
    public void set_Kernel(TKernel value);
    public double get_Power();
    public void set_Power(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Normalized`2 : KernelBase`1<TInput> {
    private TKernel kernel;
    private double power;
    public TKernel Kernel { get; public set; }
    public double Power { get; public set; }
    public Normalized`2(TKernel kernel, double power);
    public TKernel get_Kernel();
    public void set_Kernel(TKernel value);
    public double get_Power();
    public void set_Power(double value);
    public virtual double Function(TInput x, TInput y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.NormalizedPolynomial : KernelBase {
    private int degree;
    private double constant;
    public int Degree { get; public set; }
    public double Constant { get; public set; }
    public NormalizedPolynomial(int degree, double constant);
    public NormalizedPolynomial(int degree);
    public int get_Degree();
    public void set_Degree(int value);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Pearson : KernelBase {
    private double omega;
    private double sigma;
    private double constant;
    public double Omega { get; public set; }
    public double Sigma { get; public set; }
    public Pearson(double omega, double sigma);
    public double get_Omega();
    public void set_Omega(double value);
    public double get_Sigma();
    public void set_Sigma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Polynomial : ValueType {
    private int degree;
    private double constant;
    public int Degree { get; public set; }
    public double Constant { get; public set; }
    public Polynomial(int degree, double constant);
    public Polynomial(int degree);
    public int get_Degree();
    public void set_Degree(int value);
    public double get_Constant();
    public void set_Constant(double value);
    public sealed virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(Sparse`1<double> x, Sparse`1<double> y);
    public double Function(double z);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double ReverseDistance(Double[] x, Double[] y);
    public sealed virtual object Clone();
    public sealed virtual Double[] Transform(Double[] input);
    public sealed virtual Double[][] Transform(Double[][] inputs);
    public static Double[] Transform(Double[] input, int degree, double constant);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Power : KernelBase {
    private double degree;
    public double Degree { get; public set; }
    public Power(int degree);
    public Power(double degree);
    public double get_Degree();
    public void set_Degree(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Precomputed : ValueType {
    private Double[][] matrix;
    [ObsoleteAttribute("Please use the Values property instead.")]
public Double[0...,0...] Matrix { get; public set; }
    public Double[][] Values { get; public set; }
    public Int32[] Indices { get; }
    public int NumberOfBasisVectors { get; }
    public int NumberOfSamples { get; }
    [ObsoleteAttribute("Please use jagged matrices instead.")]
public Precomputed(Double[0...,0...] matrix);
    public Precomputed(Double[][] matrix);
    public Double[0...,0...] get_Matrix();
    public void set_Matrix(Double[0...,0...] value);
    public Double[][] get_Values();
    public void set_Values(Double[][] value);
    public Int32[] get_Indices();
    public int get_NumberOfBasisVectors();
    public int get_NumberOfSamples();
    public sealed virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(int x, int y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Quadratic : KernelBase {
    private double constant;
    public double Constant { get; public set; }
    public Quadratic(double constant);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
    public double Function(double z);
    public virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double ReverseDistance(Double[] x, Double[] y);
    public sealed virtual object Clone();
    public sealed virtual Double[] Transform(Double[] input);
    public sealed virtual Double[][] Transform(Double[][] inputs);
    public static Double[] Transform(Double[] input, double constant);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.RationalQuadratic : KernelBase {
    private double constant;
    public double Constant { get; public set; }
    public RationalQuadratic(double constant);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Sigmoid : KernelBase {
    private double alpha;
    private double constant;
    public double Alpha { get; public set; }
    public double Constant { get; public set; }
    public Sigmoid(double alpha, double constant);
    public static Sigmoid Estimate(Double[][] inputs);
    public static Sigmoid Estimate(Double[][] inputs, int samples, DoubleRange& range);
    public static Double[] Products(Double[][] inputs, int samples);
    public double get_Alpha();
    public void set_Alpha(double value);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(Sparse`1<double> x, Sparse`1<double> y);
    public sealed virtual double Distance(Sparse`1<double> x, Sparse`1<double> y);
    public double Function(double z);
    public sealed virtual object Clone();
    private sealed virtual override void Accord.Statistics.Kernels.IEstimable<System.Double[]>.Estimate(Double[][] inputs);
}
[SerializableAttribute]
[ObsoleteAttribute("Please use the Cauchy kernel with Sparse<double> instead.")]
public class Accord.Statistics.Kernels.Sparse.SparseCauchy : KernelBase {
    private double sigma;
    public double Sigma { get; public set; }
    public SparseCauchy(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public virtual double Function(Double[] x, Double[] y);
}
[SerializableAttribute]
[ObsoleteAttribute("Please use the Gaussian kernel with Sparse<double> instead.")]
public class Accord.Statistics.Kernels.Sparse.SparseGaussian : KernelBase {
    private double sigma;
    private double gamma;
    public double Sigma { get; public set; }
    public double Gamma { get; public set; }
    public SparseGaussian(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double ReverseDistance(Double[] x, Double[] y);
    public static SparseGaussian Estimate(Double[][] inputs, int samples, DoubleRange& range);
}
[SerializableAttribute]
[ObsoleteAttribute("Please use the Laplacian kernel with Sparse<double> instead.")]
public class Accord.Statistics.Kernels.Sparse.SparseLaplacian : KernelBase {
    private double sigma;
    private double gamma;
    public double Sigma { get; public set; }
    public double Gamma { get; public set; }
    public SparseLaplacian(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public virtual double Distance(Double[] x, Double[] y);
    public static SparseLaplacian Estimate(Double[][] inputs, int samples, DoubleRange& range);
}
[SerializableAttribute]
[ObsoleteAttribute("Please use the Linear kernel with Sparse<double> instead.")]
public class Accord.Statistics.Kernels.Sparse.SparseLinear : KernelBase {
    private double constant;
    public double Constant { get; public set; }
    public SparseLinear(double constant);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
    public virtual double Distance(Double[] x, Double[] y);
    public static double Product(Double[] x, Double[] y);
    public static double SquaredEuclidean(Double[] x, Double[] y);
    public object Clone();
}
[SerializableAttribute]
[ObsoleteAttribute("Please use Polynomial<Sparse<double>> instead.")]
public class Accord.Statistics.Kernels.Sparse.SparsePolynomial : KernelBase {
    private int degree;
    private double constant;
    public int Degree { get; public set; }
    public double Constant { get; public set; }
    public SparsePolynomial(int degree, double constant);
    public SparsePolynomial(int degree);
    public int get_Degree();
    public void set_Degree(int value);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
}
[SerializableAttribute]
[ObsoleteAttribute("Please use the Sigmoid kernel with Sparse<double> instead.")]
public class Accord.Statistics.Kernels.Sparse.SparseSigmoid : KernelBase {
    private double gamma;
    private double constant;
    public double Gamma { get; public set; }
    public double Constant { get; public set; }
    public SparseSigmoid(double alpha, double constant);
    public double get_Gamma();
    public void set_Gamma(double value);
    public double get_Constant();
    public void set_Constant(double value);
    public virtual double Function(Double[] x, Double[] y);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Spherical : KernelBase {
    private double sigma;
    public double Sigma { get; public set; }
    public Spherical(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Spline : KernelBase {
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.SquaredSinc : KernelBase {
    private double gamma;
    public double Gamma { get; public set; }
    public SquaredSinc(double gamma);
    public double get_Gamma();
    public void set_Gamma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.StringSubsequence : KernelBase`1<string> {
    private int k;
    private double lambda;
    private double normalizationPower;
    public StringSubsequence(int k, double lambda, double normalizationPower);
    public virtual double Function(string x, string y);
    private double K(int n, string s, int slen, string t, int tlen);
    private double Kp(int i, string s, int slen, string t, int tlen);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.SymmetricTriangle : KernelBase {
    private double gamma;
    public double Gamma { get; public set; }
    public SymmetricTriangle(double gamma);
    public double get_Gamma();
    public void set_Gamma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.TaylorGaussian : ValueType {
    private Gaussian gaussian;
    private Linear linear;
    private Double[] coefficients;
    public int Degree { get; public set; }
    public Gaussian Gaussian { get; public set; }
    public TaylorGaussian(double sigma, int degree);
    public TaylorGaussian(Gaussian gaussian, int degree);
    public int get_Degree();
    public void set_Degree(int value);
    public Gaussian get_Gaussian();
    public void set_Gaussian(Gaussian value);
    public sealed virtual double Function(Double[] x, Double[] y);
    public sealed virtual Double[] Transform(Double[] input);
    public sealed virtual Double[][] Transform(Double[][] inputs);
    private void createCoefficients(int degree);
    public sealed virtual object Clone();
    public sealed virtual void Product(double a, Double[] b, Double[] result);
    public sealed virtual Double[] Compress(Double[] weights, Double[][] supportVectors, Double& c);
    public sealed virtual double ReverseDistance(Double[] x, Double[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual void Add(Double[] a, Double[] b, Double[] result);
    public sealed virtual int GetLength(Double[][] inputs);
    public sealed virtual Double[] CreateVector(Double[] values);
    public sealed virtual void Product(Double[] a, Double[] b, Double[] accumulate);
    public sealed virtual Double[][] ToDouble(Double[][] input);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Tensor`1 : ValueType {
    private T[] kernels;
    public T[] Kernels { get; public set; }
    public Tensor`1(T[] kernels);
    public T[] get_Kernels();
    public void set_Kernels(T[] value);
    public double Function(Double[] x, Double[] y);
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.ThinSplinePlate : KernelBase {
    private double sigma;
    public double Sigma { get; public set; }
    public ThinSplinePlate(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.TStudent : KernelBase {
    private int degree;
    public int Degree { get; public set; }
    public TStudent(int degree);
    public int get_Degree();
    public void set_Degree(int value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Wave : KernelBase {
    private double sigma;
    public double Sigma { get; public set; }
    public Wave(double sigma);
    public double get_Sigma();
    public void set_Sigma(double value);
    public virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(double z);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Kernels.Wavelet : ValueType {
    private Func`2<double, double> h;
    private double dilation;
    private double translation;
    private bool invariant;
    public Func`2<double, double> Mother { get; public set; }
    public double Dilation { get; public set; }
    public double Translation { get; public set; }
    public bool Invariant { get; public set; }
    public Wavelet(bool invariant);
    public Wavelet(bool invariant, double dilation);
    public Wavelet(bool invariant, double dilation, Func`2<double, double> mother);
    public Wavelet(double translation, double dilation);
    public Wavelet(double translation, double dilation, Func`2<double, double> mother);
    private static double mother(double x);
    public Func`2<double, double> get_Mother();
    public void set_Mother(Func`2<double, double> value);
    public double get_Dilation();
    public void set_Dilation(double value);
    public double get_Translation();
    public void set_Translation(double value);
    public bool get_Invariant();
    public void set_Invariant(bool value);
    public sealed virtual double Function(Double[] x, Double[] y);
    public sealed virtual double Function(Int32[] x, Int32[] y);
    public sealed virtual double Distance(Double[] x, Double[] y);
    public sealed virtual double Distance(Int32[] x, Int32[] y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.AbsoluteLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double B { get; public set; }
    public AbsoluteLinkFunction(double beta);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
public void set_B(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.CauchitLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double A { get; private set; }
    public double B { get; private set; }
    public CauchitLinkFunction(double beta, double constant);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
private void set_A(double value);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
private void set_B(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.IdentityLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double A { get; private set; }
    public double B { get; private set; }
    public IdentityLinkFunction(double beta, double constant);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
private void set_A(double value);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
private void set_B(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
public interface Accord.Statistics.Links.ILinkFunction {
    public abstract virtual double Function(double x);
    public abstract virtual double Inverse(double x);
    public abstract virtual double Log(double x);
    public abstract virtual double Derivative(double x);
    public abstract virtual double Derivative2(double y);
}
[SerializableAttribute]
public class Accord.Statistics.Links.InverseLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double A { get; private set; }
    public double B { get; private set; }
    public InverseLinkFunction(double beta, double constant);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
private void set_A(double value);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
private void set_B(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.InverseSquaredLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double A { get; private set; }
    public double B { get; private set; }
    public InverseSquaredLinkFunction(double beta, double constant);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
private void set_A(double value);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
private void set_B(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.LogitLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double A { get; private set; }
    public double B { get; private set; }
    public LogitLinkFunction(double beta, double constant);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
private void set_A(double value);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
private void set_B(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.LogLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double A { get; private set; }
    public double B { get; private set; }
    public LogLinkFunction(double beta, double constant);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
private void set_A(double value);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
private void set_B(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.LogLogLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double A { get; private set; }
    public double B { get; private set; }
    public LogLogLinkFunction(double beta, double constant);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
private void set_A(double value);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
private void set_B(double value);
    public static LogLogLinkFunction Complementary();
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.ProbitLinkFunction : object {
    private static double lnconstant;
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.SinLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <B>k__BackingField;
    public double A { get; private set; }
    public double B { get; private set; }
    public SinLinkFunction(double beta, double constant);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
private void set_A(double value);
    [CompilerGeneratedAttribute]
public double get_B();
    [CompilerGeneratedAttribute]
private void set_B(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Links.ThresholdLinkFunction : object {
    [CompilerGeneratedAttribute]
private double <Threshold>k__BackingField;
    public double Threshold { get; public set; }
    public ThresholdLinkFunction(double threshold);
    [CompilerGeneratedAttribute]
public double get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(double value);
    public sealed virtual double Function(double x);
    public sealed virtual double Inverse(double x);
    public sealed virtual double Log(double x);
    public sealed virtual double Derivative(double x);
    public sealed virtual double Derivative2(double y);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.ConditionalRandomField`1 : TaggerBase`1<T> {
    [CompilerGeneratedAttribute]
private int <States>k__BackingField;
    [CompilerGeneratedAttribute]
private IPotentialFunction`1<T> <Function>k__BackingField;
    public int States { get; private set; }
    public IPotentialFunction`1<T> Function { get; private set; }
    public ConditionalRandomField`1(int states, IPotentialFunction`1<T> function);
    [CompilerGeneratedAttribute]
public int get_States();
    [CompilerGeneratedAttribute]
private void set_States(int value);
    [CompilerGeneratedAttribute]
public IPotentialFunction`1<T> get_Function();
    [CompilerGeneratedAttribute]
private void set_Function(IPotentialFunction`1<T> value);
    public double Partition(T[] observations);
    public double LogPartition(T[] observations);
    public double LogLikelihood(T[] observations, Int32[] labels);
    public Int32[] Compute(T[] observations, Double& logLikelihood);
    private Int32[] viterbi(FactorPotential`1<T> factor, T[] observations, Double& logLikelihood);
    public double LogLikelihood(T[][] observations, Int32[][] labels);
    [ObsoleteAttribute("Please use Accord.Serializer instead.")]
public void Save(Stream stream);
    [ObsoleteAttribute("Please use Accord.Serializer instead.")]
public void Save(string path);
    [ObsoleteAttribute("Please use Accord.Serializer instead.")]
public static ConditionalRandomField`1<T> Load(Stream stream);
    [ObsoleteAttribute("Please use Accord.Serializer instead.")]
public static ConditionalRandomField`1<T> Load(string path);
    public object Clone();
    public virtual Int32[][] Decide(T[][] input, Int32[][] result);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.EmissionFeature : FeatureBase`1<int> {
    private int state;
    private int symbol;
    public EmissionFeature(IPotentialFunction`1<int> owner, int factorIndex, int state, int symbol);
    public virtual double Compute(int previousState, int currentState, Int32[] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, Int32[] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, Int32[] x, int y);
    public sealed virtual IFeature`1<int> Clone(IPotentialFunction`1<int> newOwner);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Models.Fields.Features.FeatureBase`1 : object {
    [CompilerGeneratedAttribute]
private IPotentialFunction`1<T> <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FactorIndex>k__BackingField;
    public IPotentialFunction`1<T> Owner { get; protected set; }
    public int FactorIndex { get; private set; }
    protected FeatureBase`1(IPotentialFunction`1<T> owner, int factorIndex);
    [CompilerGeneratedAttribute]
public sealed virtual IPotentialFunction`1<T> get_Owner();
    [CompilerGeneratedAttribute]
protected void set_Owner(IPotentialFunction`1<T> value);
    [CompilerGeneratedAttribute]
public int get_FactorIndex();
    [CompilerGeneratedAttribute]
private void set_FactorIndex(int value);
    public virtual double Compute(Int32[] states, T[] observations, int output);
    public abstract virtual double Compute(int previousState, int currentState, T[] observations, int observationIndex, int outputClass);
    public abstract virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, T[] x, int y);
    public abstract virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, T[] x, int y);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.FirstMomentFeature : FeatureBase`1<double> {
    private int state;
    public FirstMomentFeature(IPotentialFunction`1<double> owner, int factorIndex, int state);
    public virtual double Compute(int previousState, int currentState, Double[] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, Double[] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, Double[] x, int y);
    public sealed virtual IFeature`1<double> Clone(IPotentialFunction`1<double> newOwner);
}
public interface Accord.Statistics.Models.Fields.Features.IFeature`1 {
    public IPotentialFunction`1<TObservation> Owner { get; }
    public abstract virtual IPotentialFunction`1<TObservation> get_Owner();
    public abstract virtual double Compute(int previousState, int currentState, TObservation[] observations, int observationIndex, int outputClass);
    public abstract virtual double Compute(Int32[] states, TObservation[] observations, int output);
    public abstract virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, TObservation[] x, int y);
    public abstract virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, TObservation[] x, int y);
    public abstract virtual IFeature`1<TObservation> Clone(IPotentialFunction`1<TObservation> newOwner);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.InitialFeature`1 : FeatureBase`1<T> {
    private int current;
    public InitialFeature`1(IPotentialFunction`1<T> owner, int factorIndex, int state);
    public virtual double Compute(int previousState, int currentState, T[] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, T[] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, T[] x, int y);
    public sealed virtual IFeature`1<T> Clone(IPotentialFunction`1<T> newOwner);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.MultivariateEmissionFeature : FeatureBase`1<Double[]> {
    private int state;
    private int symbol;
    private int dimension;
    public MultivariateEmissionFeature(IPotentialFunction`1<Double[]> owner, int factorIndex, int state, int symbol, int dimension);
    public virtual double Compute(int previousState, int currentState, Double[][] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, Double[][] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, Double[][] x, int y);
    public sealed virtual IFeature`1<Double[]> Clone(IPotentialFunction`1<Double[]> newOwner);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.MultivariateFirstMomentFeature : FeatureBase`1<Double[]> {
    private int state;
    private int dimension;
    public MultivariateFirstMomentFeature(IPotentialFunction`1<Double[]> owner, int factorIndex, int state, int dimension);
    public virtual double Compute(int previousState, int currentState, Double[][] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, Double[][] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, Double[][] x, int y);
    public sealed virtual IFeature`1<Double[]> Clone(IPotentialFunction`1<Double[]> newOwner);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.MultivariateSecondMomentFeature : FeatureBase`1<Double[]> {
    private int state;
    private int dimension;
    public MultivariateSecondMomentFeature(IPotentialFunction`1<Double[]> owner, int factorIndex, int state, int dimension);
    public virtual double Compute(int previousState, int currentState, Double[][] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, Double[][] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, Double[][] x, int y);
    public sealed virtual IFeature`1<Double[]> Clone(IPotentialFunction`1<Double[]> newOwner);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.OccupancyFeature`1 : FeatureBase`1<T> {
    private int current;
    public OccupancyFeature`1(IPotentialFunction`1<T> owner, int factorIndex, int state);
    public virtual double Compute(int previousState, int currentState, T[] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, T[] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, T[] x, int y);
    public sealed virtual IFeature`1<T> Clone(IPotentialFunction`1<T> newOwner);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.OutputFeature`1 : FeatureBase`1<T> {
    private int classSymbol;
    public OutputFeature`1(IPotentialFunction`1<T> owner, int factorIndex, int classSymbol);
    public virtual double Compute(int previousState, int currentState, T[] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, T[] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, T[] x, int y);
    public sealed virtual IFeature`1<T> Clone(IPotentialFunction`1<T> newOwner);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.SecondMomentFeature : FeatureBase`1<double> {
    private int state;
    public SecondMomentFeature(IPotentialFunction`1<double> owner, int factorIndex, int state);
    public virtual double Compute(int previousState, int currentState, Double[] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, Double[] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, Double[] x, int y);
    public sealed virtual IFeature`1<double> Clone(IPotentialFunction`1<double> newOwner);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Features.TransitionFeature`1 : FeatureBase`1<T> {
    private int previous;
    private int current;
    public TransitionFeature`1(IPotentialFunction`1<T> owner, int factorIndex, int previous, int current);
    public virtual double Compute(int previousState, int currentState, T[] observations, int observationIndex, int outputClass);
    public virtual double Marginal(Double[0...,0...] fwd, Double[0...,0...] bwd, T[] x, int y);
    public virtual double LogMarginal(Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, T[] x, int y);
    public sealed virtual IFeature`1<T> Clone(IPotentialFunction`1<T> newOwner);
}
public static class Accord.Statistics.Models.Fields.ForwardBackwardAlgorithm : object {
    public static void Forward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double[] scaling, Double[0...,0...] fwd);
    public static Double[0...,0...] Forward(FactorPotential`1<TObservation> function, TObservation[] observations, int output);
    public static Double[0...,0...] Forward(FactorPotential`1<TObservation> function, TObservation[] observations, Double[0...,0...] fwd, int output);
    public static Double[0...,0...] Forward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double& logLikelihood);
    public static Double[0...,0...] Forward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double[]& scaling);
    public static Double[0...,0...] Forward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double[]& scaling, Double& logLikelihood);
    public static void Backward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double[] scaling, Double[0...,0...] bwd);
    public static Double[0...,0...] Backward(FactorPotential`1<TObservation> function, TObservation[] observations, int output);
    public static Double[0...,0...] Backward(FactorPotential`1<TObservation> function, TObservation[] observations, Double[0...,0...] bwd, int output);
    public static Double[0...,0...] Backward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double[] scaling);
    public static Double[0...,0...] Backward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double& logLikelihood);
    public static void LogForward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double[0...,0...] lnFwd);
    public static Double[0...,0...] LogForward(FactorPotential`1<TObservation> function, TObservation[] observations, int output);
    public static Double[0...,0...] LogForward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double& logLikelihood);
    public static void LogBackward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double[0...,0...] lnBwd);
    public static Double[0...,0...] LogBackward(FactorPotential`1<TObservation> function, TObservation[] observations, int output);
    public static Double[0...,0...] LogBackward(FactorPotential`1<TObservation> function, TObservation[] observations, int output, Double& logLikelihood);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Functions.FactorPotential`1 : object {
    [CompilerGeneratedAttribute]
private IPotentialFunction`1<T> <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private int <States>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private ArraySegment`1<double> <FactorParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ArraySegment`1<double> <EdgeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ArraySegment`1<double> <StateParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ArraySegment`1<double> <OutputParameters>k__BackingField;
    public IPotentialFunction`1<T> Owner { get; private set; }
    public int States { get; private set; }
    public int Index { get; private set; }
    public ArraySegment`1<double> FactorParameters { get; private set; }
    public ArraySegment`1<double> EdgeParameters { get; private set; }
    public ArraySegment`1<double> StateParameters { get; private set; }
    public ArraySegment`1<double> OutputParameters { get; private set; }
    public FactorPotential`1(IPotentialFunction`1<T> owner, int states, int factorIndex, int edgeIndex, int edgeCount, int stateIndex, int stateCount, int classIndex, int classCount);
    public FactorPotential`1(IPotentialFunction`1<T> owner, int states, int factorIndex);
    [CompilerGeneratedAttribute]
public IPotentialFunction`1<T> get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(IPotentialFunction`1<T> value);
    [CompilerGeneratedAttribute]
public int get_States();
    [CompilerGeneratedAttribute]
private void set_States(int value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [CompilerGeneratedAttribute]
public ArraySegment`1<double> get_FactorParameters();
    [CompilerGeneratedAttribute]
private void set_FactorParameters(ArraySegment`1<double> value);
    [CompilerGeneratedAttribute]
public ArraySegment`1<double> get_EdgeParameters();
    [CompilerGeneratedAttribute]
private void set_EdgeParameters(ArraySegment`1<double> value);
    [CompilerGeneratedAttribute]
public ArraySegment`1<double> get_StateParameters();
    [CompilerGeneratedAttribute]
private void set_StateParameters(ArraySegment`1<double> value);
    [CompilerGeneratedAttribute]
public ArraySegment`1<double> get_OutputParameters();
    [CompilerGeneratedAttribute]
private void set_OutputParameters(ArraySegment`1<double> value);
    public double Compute(Int32[] states, T[] observations, int output);
    public virtual Double[] GetFeatureVector(Int32[] states, T[] observations, int output);
    public virtual double Compute(int previousState, int currentState, T[] observations, int index, int outputClass);
    [IteratorStateMachineAttribute("Accord.Statistics.Models.Fields.Functions.FactorPotential`1/<GetEnumerator>d__33")]
public sealed virtual IEnumerator`1<IFeature`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public FactorPotential`1<T> Clone(IPotentialFunction`1<T> newOwner);
}
public interface Accord.Statistics.Models.Fields.Functions.IPotentialFunction`1 {
    public FactorPotential`1[] Factors { get; }
    public int Outputs { get; }
    public Double[] Weights { get; public set; }
    public IFeature`1[] Features { get; }
    public abstract virtual FactorPotential`1[] get_Factors();
    public abstract virtual int get_Outputs();
    public abstract virtual Double[] get_Weights();
    public abstract virtual void set_Weights(Double[] value);
    public abstract virtual IFeature`1[] get_Features();
    public abstract virtual Double[] GetFeatureVector(Int32[] states, T[] observations, int output);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Functions.MarkovContinuousFunction : PotentialFunctionBase`1<double> {
    [ObsoleteAttribute("Obsolete due the use of HiddenMarkovClassifier<NormalDistribution>. Please use HiddenMarkovClassifier<NormalDistribution, double> instead.")]
public MarkovContinuousFunction(HiddenMarkovClassifier`1<NormalDistribution> classifier);
    public MarkovContinuousFunction(HiddenMarkovClassifier`2<NormalDistribution, double> classifier);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Functions.MarkovDiscreteFunction : PotentialFunctionBase`1<int> {
    [CompilerGeneratedAttribute]
private int <Symbols>k__BackingField;
    public int Symbols { get; private set; }
    public MarkovDiscreteFunction(int states, int symbols, int outputClasses);
    public MarkovDiscreteFunction(HiddenMarkovClassifier classifier, bool includePriors);
    public MarkovDiscreteFunction(HiddenMarkovClassifier`2<GeneralDiscreteDistribution, int> classifier, bool includePriors);
    public MarkovDiscreteFunction(int states, int symbols, IRandomNumberGenerator`1<double> initialization);
    public MarkovDiscreteFunction(HiddenMarkovModel model);
    [CompilerGeneratedAttribute]
public int get_Symbols();
    [CompilerGeneratedAttribute]
private void set_Symbols(int value);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Functions.MarkovMultivariateFunction : PotentialFunctionBase`1<Double[]> {
    [CompilerGeneratedAttribute]
private int <Dimensions>k__BackingField;
    public int Dimensions { get; private set; }
    [ObsoleteAttribute("Obsolete due the use of HiddenMarkovClassifier<MultivariateNormalDistribution>. Please use HiddenMarkovClassifier<MultivariateNormalDistribution, double[]> instead.")]
public MarkovMultivariateFunction(HiddenMarkovClassifier`1<MultivariateNormalDistribution> classifier, bool includePriors);
    public MarkovMultivariateFunction(HiddenMarkovClassifier`2<MultivariateNormalDistribution, Double[]> classifier, bool includePriors);
    [ObsoleteAttribute("Obsolete due the use of HiddenMarkovClassifier<Independent<NormalDistribution>>. Please use HiddenMarkovClassifier<Independent<NormalDistribution, double>, double[]> instead.")]
public MarkovMultivariateFunction(HiddenMarkovClassifier`1<Independent`1<NormalDistribution>> classifier, bool includePriors);
    public MarkovMultivariateFunction(HiddenMarkovClassifier`2<Independent`2<NormalDistribution, double>, Double[]> classifier, bool includePriors);
    public MarkovMultivariateFunction(HiddenMarkovClassifier`2<Independent`1<NormalDistribution>, Double[]> classifier, bool includePriors);
    [ObsoleteAttribute("Obsolete due the use of HiddenMarkovModel<MultivariateNormalDistribution>. Please use HiddenMarkovModel<MultivariateNormalDistribution, double[]> instead.")]
public MarkovMultivariateFunction(HiddenMarkovModel`1<MultivariateNormalDistribution> model);
    public MarkovMultivariateFunction(HiddenMarkovModel`2<MultivariateNormalDistribution, Double[]> model);
    [ObsoleteAttribute("Obsolete due the use of HiddenMarkovClassifier<Independent>. Please use HiddenMarkovClassifier<Independent, double[]> instead.")]
public MarkovMultivariateFunction(HiddenMarkovClassifier`1<Independent> classifier, bool includePriors);
    public MarkovMultivariateFunction(HiddenMarkovClassifier`2<Independent, Double[]> classifier, bool includePriors);
    [CompilerGeneratedAttribute]
public int get_Dimensions();
    [CompilerGeneratedAttribute]
private void set_Dimensions(int value);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public abstract class Accord.Statistics.Models.Fields.Functions.PotentialFunctionBase`1 : object {
    [CompilerGeneratedAttribute]
private FactorPotential`1[] <Factors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Outputs>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Weights>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeature`1[] <Features>k__BackingField;
    public FactorPotential`1[] Factors { get; protected set; }
    public int Outputs { get; protected set; }
    public Double[] Weights { get; public set; }
    public IFeature`1[] Features { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual FactorPotential`1[] get_Factors();
    [CompilerGeneratedAttribute]
protected void set_Factors(FactorPotential`1[] value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Outputs();
    [CompilerGeneratedAttribute]
protected void set_Outputs(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Double[] get_Weights();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Weights(Double[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IFeature`1[] get_Features();
    [CompilerGeneratedAttribute]
protected void set_Features(IFeature`1[] value);
    public virtual Double[] GetFeatureVector(Int32[] states, T[] observations, int output);
    internal void Deoptimize();
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Functions.Specialized.MarkovDiscreteFactor : FactorPotential`1<int> {
    [CompilerGeneratedAttribute]
private int <Symbols>k__BackingField;
    public int Symbols { get; private set; }
    public MarkovDiscreteFactor(IPotentialFunction`1<int> owner, int states, int factorIndex, int symbols, int edgeIndex, int edgeCount, int stateIndex, int stateCount, int classIndex, int classCount);
    [CompilerGeneratedAttribute]
public int get_Symbols();
    [CompilerGeneratedAttribute]
private void set_Symbols(int value);
    public virtual double Compute(int previousState, int currentState, Int32[] observations, int index, int outputClass);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Functions.Specialized.MarkovIndependentFactor : FactorPotential`1<Double[]> {
    private Int32[][] stateTable;
    public MarkovIndependentFactor(IPotentialFunction`1<Double[]> owner, int states, int factorIndex, Int32[][] stateTable, int edgeIndex, int edgeCount, int stateIndex, int stateCount, int classIndex, int classCount);
    public virtual double Compute(int previousState, int currentState, Double[][] observations, int index, int outputClass);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Functions.Specialized.MarkovMultivariateNormalFactor : FactorPotential`1<Double[]> {
    private int dimensions;
    public MarkovMultivariateNormalFactor(IPotentialFunction`1<Double[]> owner, int states, int factorIndex, int dimensions, int edgeIndex, int edgeCount, int stateIndex, int stateCount, int classIndex, int classCount);
    public virtual double Compute(int previousState, int currentState, Double[][] observations, int index, int outputClass);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.Functions.Specialized.MarkovNormalFactor : FactorPotential`1<double> {
    public MarkovNormalFactor(IPotentialFunction`1<double> owner, int states, int factorIndex, int edgeIndex, int edgeCount, int stateIndex, int stateCount, int classIndex, int classCount);
    public virtual double Compute(int previousState, int currentState, Double[] observations, int index, int outputClass);
}
public static class Accord.Statistics.Models.Fields.HiddenConditionalRandomField : object {
    public static HiddenConditionalRandomField`1<int> FromHiddenMarkov(HiddenMarkovClassifier classifier);
    public static HiddenConditionalRandomField`1<int> FromHiddenMarkov(HiddenMarkovClassifier`2<GeneralDiscreteDistribution, int> classifier);
    public static HiddenConditionalRandomField`1<double> FromHiddenMarkov(HiddenMarkovClassifier`2<NormalDistribution, double> classifier);
    public static HiddenConditionalRandomField`1<Double[]> FromHiddenMarkov(HiddenMarkovClassifier`2<Independent`1<NormalDistribution>, Double[]> classifier);
    public static HiddenConditionalRandomField`1<Double[]> FromHiddenMarkov(HiddenMarkovClassifier`2<Independent`2<NormalDistribution, double>, Double[]> classifier);
    public static HiddenConditionalRandomField`1<Double[]> FromHiddenMarkov(HiddenMarkovClassifier`2<MultivariateNormalDistribution, Double[]> classifier);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Fields.HiddenConditionalRandomField`1 : MulticlassClassifierBase`1<T[]> {
    private IPotentialFunction`1<T> function;
    [ObsoleteAttribute("Please use NumberOfOutputs instead.")]
public int Outputs { get; }
    public IPotentialFunction`1<T> Function { get; public set; }
    public HiddenConditionalRandomField`1(IPotentialFunction`1<T> function);
    public int get_Outputs();
    public IPotentialFunction`1<T> get_Function();
    public void set_Function(IPotentialFunction`1<T> value);
    [ObsoleteAttribute("Please use the Decide() method instead.")]
public int Compute(T[] observations);
    [ObsoleteAttribute("Please use the Decide() method instead.")]
public int Compute(T[] observations, Double[]& logLikelihoods);
    private int compute(T[] observations, Double[]& logLikelihoods);
    [ObsoleteAttribute("Please use the Decide() method instead.")]
public int Compute(T[] observations, Double& logLikelihood);
    public Int32[] Decode(T[] observations, int output);
    public Int32[] Decode(T[] observations, int output, Double& logLikelihood);
    public double LogLikelihood(T[] observations, int output);
    public double LogLikelihood(T[] observations, int output, Double[]& logLikelihoods);
    public double LogLikelihood(T[][] observations, Int32[] output);
    public double LogLikelihood(T[][] observations, Int32[] output, Double[][]& logLikelihoods);
    public double Partition(T[] x, int y);
    public double LogPartition(T[] x, int y);
    public double Partition(T[] x);
    public double LogPartition(T[] x);
    public Double[][] LogLikelihood(T[][] observations);
    public Double[] LogLikelihood(T[] observations);
    public sealed virtual object Clone();
    public virtual int Decide(T[] input);
}
public interface Accord.Statistics.Models.Fields.IHiddenRandomFieldGradient {
    public abstract virtual Double[] Gradient();
    public abstract virtual double Objective();
}
public abstract class Accord.Statistics.Models.Fields.Learning.BaseHiddenConditionalRandomFieldLearning`1 : object {
    [NonSerializedAttribute]
private CancellationToken token;
    [CompilerGeneratedAttribute]
private IPotentialFunction`1<T> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private HiddenConditionalRandomField`1<T> <Model>k__BackingField;
    public CancellationToken Token { get; public set; }
    public IPotentialFunction`1<T> Function { get; public set; }
    public HiddenConditionalRandomField`1<T> Model { get; public set; }
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    [CompilerGeneratedAttribute]
public IPotentialFunction`1<T> get_Function();
    [CompilerGeneratedAttribute]
public void set_Function(IPotentialFunction`1<T> value);
    [CompilerGeneratedAttribute]
public HiddenConditionalRandomField`1<T> get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(HiddenConditionalRandomField`1<T> value);
    public sealed virtual HiddenConditionalRandomField`1<T> Learn(T[][] x, Int32[] y, Double[] weights);
    protected virtual HiddenConditionalRandomField`1<T> Create(T[][] x, Int32[] y);
    protected abstract virtual double InnerRun(T[][] x, Int32[] y);
}
public abstract class Accord.Statistics.Models.Fields.Learning.BaseHiddenGradientOptimizationLearning`2 : BaseHiddenConditionalRandomFieldLearning`1<TData> {
    private TOptimizer optimizer;
    private ForwardBackwardGradient`1<TData> calculator;
    [CompilerGeneratedAttribute]
private double <Tolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConverged>k__BackingField;
    public TOptimizer Optimizer { get; }
    public double Regularization { get; public set; }
    public double Tolerance { get; public set; }
    public int MaxIterations { get; public set; }
    public bool HasConverged { get; private set; }
    public ParallelOptions ParallelOptions { get; public set; }
    public TOptimizer get_Optimizer();
    public double get_Regularization();
    public void set_Regularization(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Tolerance();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Tolerance(double value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxIterations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxIterations(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConverged();
    [CompilerGeneratedAttribute]
private void set_HasConverged(bool value);
    public sealed virtual ParallelOptions get_ParallelOptions();
    public sealed virtual void set_ParallelOptions(ParallelOptions value);
    protected abstract virtual TOptimizer CreateOptimizer();
    protected virtual double InnerRun(TData[][] observations, Int32[] outputs);
    public sealed virtual double Run(TData[] observations, int output);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual double Run(TData[][] observations, Int32[] outputs);
    [ObsoleteAttribute("Use Run(T[][], int[]) instead.")]
public sealed virtual double RunEpoch(TData[][] observations, Int32[] output);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public class Accord.Statistics.Models.Fields.Learning.ForwardBackwardGradient`1 : ParallelLearningBase {
    private HiddenConditionalRandomField`1<T> model;
    private IPotentialFunction`1<T> function;
    private double sigma;
    private ThreadLocal`1<T[][]> inputs;
    private ThreadLocal`1<Int32[]> outputs;
    private ThreadLocal`1<Double[][]> logLikelihoods;
    private ThreadLocal`1<Double[]> gradient;
    private ThreadLocal`1<Double[]> lnZx;
    private ThreadLocal`1<Double[]> lnZxy;
    private ThreadLocal`1<double> error;
    public T[][] Inputs { get; public set; }
    public Int32[] Outputs { get; public set; }
    public Double[] Parameters { get; public set; }
    public double LastError { get; }
    public double Regularization { get; public set; }
    public HiddenConditionalRandomField`1<T> Model { get; public set; }
    public ForwardBackwardGradient`1(HiddenConditionalRandomField`1<T> model);
    public T[][] get_Inputs();
    public void set_Inputs(T[][] value);
    public Int32[] get_Outputs();
    public void set_Outputs(Int32[] value);
    public Double[] get_Parameters();
    public void set_Parameters(Double[] value);
    public double get_LastError();
    public double get_Regularization();
    public void set_Regularization(double value);
    public HiddenConditionalRandomField`1<T> get_Model();
    public void set_Model(HiddenConditionalRandomField`1<T> value);
    public Double[] Gradient(Double[] parameters, T[] input, int output);
    public Double[] Gradient(Double[] parameters, T[][] inputs, Int32[] outputs);
    public Double[] Gradient(Double[] parameters);
    public sealed virtual Double[] Gradient();
    private void InnerGradient(FactorPotential`1<T> factor, T[][] inputs, Int32[] outputs, Double[] lnZx, Double[] lnZxy, Double[] gradient);
    public double Objective(Double[] parameters, T[][] inputs, Int32[] outputs);
    public double Objective(Double[] parameters);
    public sealed virtual double Objective();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public class Accord.Statistics.Models.Fields.Learning.HiddenConjugateGradientLearning`1 : BaseHiddenGradientOptimizationLearning`2<T, ConjugateGradient> {
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressChangedEventArgs> ProgressChanged;
    [ObsoleteAttribute("Please use HasConverged instead.")]
public bool Converged { get; }
    private int Accord.Statistics.Models.IConvergenceLearning.Iterations { get; private set; }
    public int CurrentIteration { get; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public HiddenConjugateGradientLearning`1(HiddenConditionalRandomField`1<T> model);
    public bool get_Converged();
    private sealed virtual override int Accord.Statistics.Models.IConvergenceLearning.get_Iterations();
    private sealed virtual override void Accord.Statistics.Models.IConvergenceLearning.set_Iterations(int value);
    public sealed virtual int get_CurrentIteration();
    public int get_Iterations();
    public void set_Iterations(int value);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    protected virtual ConjugateGradient CreateOptimizer();
    private void progressChanged(object sender, OptimizationProgressEventArgs e);
}
public class Accord.Statistics.Models.Fields.Learning.HiddenGradientDescentLearning`1 : BaseHiddenConditionalRandomFieldLearning`1<T> {
    private double learningRate;
    private ISingleValueConvergence convergence;
    private double stepSize;
    private bool stochastic;
    private Double[] gradient;
    private ForwardBackwardGradient`1<T> calculator;
    private object lockObj;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressChangedEventArgs> ProgressChanged;
    public double LearningRate { get; public set; }
    public double Tolerance { get; public set; }
    public int MaxIterations { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public bool Stochastic { get; public set; }
    public double Regularization { get; public set; }
    public ParallelOptions ParallelOptions { get; public set; }
    public HiddenGradientDescentLearning`1(HiddenConditionalRandomField`1<T> model);
    public double get_LearningRate();
    public void set_LearningRate(double value);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_CurrentIteration();
    public sealed virtual bool get_HasConverged();
    public bool get_Stochastic();
    public void set_Stochastic(bool value);
    public double get_Regularization();
    public void set_Regularization(double value);
    public sealed virtual ParallelOptions get_ParallelOptions();
    public sealed virtual void set_ParallelOptions(ParallelOptions value);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    private void init();
    public void Reset();
    public sealed virtual double RunEpoch(T[][] observations, Int32[] outputs);
    private void iterate(T[][] observations, Int32[] outputs, int i, Double& error, Int32& progress);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual double Run(T[][] observations, Int32[] outputs);
    protected virtual double InnerRun(T[][] observations, Int32[] outputs);
    public sealed virtual double Run(T[] observations, int output);
    protected void OnProgressChanged(ProgressChangedEventArgs args);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public class Accord.Statistics.Models.Fields.Learning.HiddenQuasiNewtonLearning`1 : BaseHiddenGradientOptimizationLearning`2<T, BoundedBroydenFletcherGoldfarbShanno> {
    private int Accord.Statistics.Models.IConvergenceLearning.Iterations { get; private set; }
    public int CurrentIteration { get; }
    public HiddenQuasiNewtonLearning`1(HiddenConditionalRandomField`1<T> model);
    private sealed virtual override int Accord.Statistics.Models.IConvergenceLearning.get_Iterations();
    private sealed virtual override void Accord.Statistics.Models.IConvergenceLearning.set_Iterations(int value);
    public sealed virtual int get_CurrentIteration();
    protected virtual BoundedBroydenFletcherGoldfarbShanno CreateOptimizer();
}
public class Accord.Statistics.Models.Fields.Learning.HiddenResilientGradientLearning`1 : BaseHiddenConditionalRandomFieldLearning`1<T> {
    private ForwardBackwardGradient`1<T> calculator;
    private ISingleValueConvergence convergence;
    private double initialStep;
    private double deltaMax;
    private double deltaMin;
    private double etaMinus;
    private double etaPlus;
    private bool stochastic;
    private Double[] gradient;
    private Double[] previousGradient;
    private object lockObj;
    private Double[] weightsUpdates;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressChangedEventArgs> ProgressChanged;
    public bool Stochastic { get; public set; }
    public double Regularization { get; public set; }
    public double UpdateUpperBound { get; public set; }
    public double UpdateLowerBound { get; public set; }
    public double DecreaseFactor { get; public set; }
    public double IncreaseFactor { get; public set; }
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public ParallelOptions ParallelOptions { get; public set; }
    public HiddenResilientGradientLearning`1(HiddenConditionalRandomField`1<T> model);
    public bool get_Stochastic();
    public void set_Stochastic(bool value);
    public double get_Regularization();
    public void set_Regularization(double value);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<ProgressChangedEventArgs> value);
    public double get_UpdateUpperBound();
    public void set_UpdateUpperBound(double value);
    public double get_UpdateLowerBound();
    public void set_UpdateLowerBound(double value);
    public double get_DecreaseFactor();
    public void set_DecreaseFactor(double value);
    public double get_IncreaseFactor();
    public void set_IncreaseFactor(double value);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_CurrentIteration();
    public sealed virtual bool get_HasConverged();
    public sealed virtual ParallelOptions get_ParallelOptions();
    public sealed virtual void set_ParallelOptions(ParallelOptions value);
    private void init();
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual double Run(T[][] observations, Int32[] outputs);
    protected virtual double InnerRun(T[][] observations, Int32[] outputs);
    public sealed virtual double RunEpoch(T[][] observations, Int32[] outputs);
    public sealed virtual double Run(T[] observations, int output);
    protected void OnProgressChanged(ProgressChangedEventArgs args);
    public void Reset(double rate);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Please use ISupervisedLearning<ConditionalRandomField<T>, T[], int[]> instead.")]
public interface Accord.Statistics.Models.Fields.Learning.IConditionalRandomFieldLearning`1 {
    public abstract virtual double Run(T[][] observations, Int32[][] labels);
}
[ObsoleteAttribute("Please use ISupervisedLearning<HiddenConditionalRandomField<T>, T[], int> instead.")]
public interface Accord.Statistics.Models.Fields.Learning.IHiddenConditionalRandomFieldLearning`1 {
    public abstract virtual double Run(T[] observations, int output);
    public abstract virtual double RunEpoch(T[][] observations, Int32[] outputs);
    public abstract virtual double Run(T[][] observations, Int32[] outputs);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Models.Fields.Learning.NamespaceDoc : object {
}
public class Accord.Statistics.Models.Fields.Learning.QuasiNewtonLearning`1 : ParallelLearningBase {
    private BoundedBroydenFletcherGoldfarbShanno lbfgs;
    [CompilerGeneratedAttribute]
private ConditionalRandomField`1<T> <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private IPotentialFunction`1<T> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Tolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIterations>k__BackingField;
    public ConditionalRandomField`1<T> Model { get; public set; }
    public IPotentialFunction`1<T> Function { get; public set; }
    public double Tolerance { get; public set; }
    private int Accord.Statistics.Models.IConvergenceLearning.Iterations { get; private set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public QuasiNewtonLearning`1(ConditionalRandomField`1<T> model);
    [CompilerGeneratedAttribute]
public ConditionalRandomField`1<T> get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(ConditionalRandomField`1<T> value);
    [CompilerGeneratedAttribute]
public IPotentialFunction`1<T> get_Function();
    [CompilerGeneratedAttribute]
public void set_Function(IPotentialFunction`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Tolerance();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Tolerance(double value);
    private sealed virtual override int Accord.Statistics.Models.IConvergenceLearning.get_Iterations();
    private sealed virtual override void Accord.Statistics.Models.IConvergenceLearning.set_Iterations(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxIterations();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_CurrentIteration();
    public sealed virtual bool get_HasConverged();
    private void init();
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual double Run(T[][] observations, Int32[][] labels);
    private double run(T[][] observations, Int32[][] labels);
    private Double[] gradient(T[][] observations, Int32[][] labels, Double[] g);
    private static double p(int previous, int next, T[] x, int t, Double[0...,0...] fwd, Double[0...,0...] bwd, IPotentialFunction`1<T> function);
    private double partition(Double[0...,0...] fwd, T[] x);
    public sealed virtual ConditionalRandomField`1<T> Learn(T[][] x, Int32[][] y, Double[] weights);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Models.Fields.NamespaceDoc : object {
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("This class will be removed.")]
[SerializableAttribute]
public abstract class Accord.Statistics.Models.Markov.BaseHiddenMarkovClassifier`1 : object {
    private TModel[] models;
    private Double[] classPriors;
    private TModel threshold;
    private double weight;
    public TModel Threshold { get; public set; }
    public double Sensitivity { get; public set; }
    public TModel[] Models { get; }
    public TModel Item { get; }
    public int Classes { get; }
    public Double[] Priors { get; }
    protected BaseHiddenMarkovClassifier`1(int classes);
    protected BaseHiddenMarkovClassifier`1(TModel[] models);
    public TModel get_Threshold();
    public void set_Threshold(TModel value);
    public double get_Sensitivity();
    public void set_Sensitivity(double value);
    public TModel[] get_Models();
    public TModel get_Item(int label);
    public sealed virtual int get_Classes();
    public Double[] get_Priors();
    protected int Compute(Array sequence);
    protected int Compute(Array sequence, Double& response);
    protected int Compute(Array sequence, Double[]& responsibilities);
    private int compute(Array sequence, Double[]& logLikelihoods, Double& rejectionValue, Double& maxValue);
    protected double LogLikelihood(Array sequence, int output);
    protected double LogLikelihood(Array sequence);
    protected double LogLikelihood(Array[] sequences, Int32[] outputs);
    [OnDeserializingAttribute]
private void setSerializationDefaults(StreamingContext sc);
    [IteratorStateMachineAttribute("Accord.Statistics.Models.Markov.BaseHiddenMarkovClassifier`1/<GetEnumerator>d__28")]
public sealed virtual IEnumerator`1<TModel> GetEnumerator();
    [IteratorStateMachineAttribute("Accord.Statistics.Models.Markov.BaseHiddenMarkovClassifier`1/<System-Collections-IEnumerable-GetEnumerator>d__29")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[SerializableAttribute]
public abstract class Accord.Statistics.Models.Markov.BaseHiddenMarkovClassifier`3 : MulticlassLikelihoodClassifierBase`1<TObservation[]> {
    private TModel[] models;
    private Double[] classPriors;
    private TModel threshold;
    private double weight;
    public TModel Threshold { get; public set; }
    public double Sensitivity { get; public set; }
    public TModel[] Models { get; public set; }
    public TModel Item { get; }
    [ObsoleteAttribute("Please use NumberOfClasses instead.")]
public int Classes { get; }
    public Double[] Priors { get; }
    protected BaseHiddenMarkovClassifier`3(int classes);
    protected BaseHiddenMarkovClassifier`3(TModel[] models);
    public TModel get_Threshold();
    public void set_Threshold(TModel value);
    public double get_Sensitivity();
    public void set_Sensitivity(double value);
    public TModel[] get_Models();
    public void set_Models(TModel[] value);
    public TModel get_Item(int label);
    public sealed virtual int get_Classes();
    public Double[] get_Priors();
    public virtual double LogLikelihood(TObservation[] input);
    public virtual double Probability(TObservation[] input);
    public virtual double LogLikelihood(TObservation[] input, Int32& decision);
    public virtual double Probability(TObservation[] input, Int32& decision);
    public virtual double LogLikelihood(TObservation[] input, int classIndex);
    public virtual Double[] Probabilities(TObservation[] input, Int32& decision, Double[] result);
    public virtual Double[] LogLikelihoods(TObservation[] input, Int32& decision, Double[] result);
    public virtual int Decide(TObservation[] input);
    [IteratorStateMachineAttribute("Accord.Statistics.Models.Markov.BaseHiddenMarkovClassifier`3/<GetEnumerator>d__29")]
public sealed virtual IEnumerator`1<TModel> GetEnumerator();
    [IteratorStateMachineAttribute("Accord.Statistics.Models.Markov.BaseHiddenMarkovClassifier`3/<System-Collections-IEnumerable-GetEnumerator>d__30")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[SerializableAttribute]
public abstract class Accord.Statistics.Models.Markov.BaseHiddenMarkovModel : object {
    private int states;
    private object tag;
    private Double[][] logA;
    private Double[] logPi;
    public int States { get; }
    [ObsoleteAttribute("Please use the Initial property instead.")]
public Double[] Probabilities { get; }
    public Double[] LogInitial { get; }
    [ObsoleteAttribute("Please use LogTransitions instead.")]
public Double[0...,0...] Transitions { get; }
    public Double[][] LogTransitions { get; }
    public object Tag { get; public set; }
    protected BaseHiddenMarkovModel(ITopology topology);
    public sealed virtual int get_States();
    public sealed virtual Double[] get_Probabilities();
    public sealed virtual Double[] get_LogInitial();
    public sealed virtual Double[0...,0...] get_Transitions();
    public sealed virtual Double[][] get_LogTransitions();
    public sealed virtual object get_Tag();
    public sealed virtual void set_Tag(object value);
}
public static class Accord.Statistics.Models.Markov.ForwardBackwardAlgorithm : object {
    public static void Forward(HiddenMarkovModel model, Int32[] observations, Double[] scaling, Double[0...,0...] fwd);
    public static Double[0...,0...] Forward(HiddenMarkovModel model, Int32[] observations);
    public static Double[0...,0...] Forward(HiddenMarkovModel model, Int32[] observations, Double& logLikelihood);
    public static Double[0...,0...] Forward(HiddenMarkovModel model, Int32[] observations, Double[]& scaling);
    public static Double[0...,0...] Forward(HiddenMarkovModel model, Int32[] observations, Double[]& scaling, Double& logLikelihood);
    public static void Forward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double[] scaling, Double[0...,0...] fwd);
    public static Double[0...,0...] Forward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double& logLikelihood);
    public static Double[0...,0...] Forward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double[]& scaling);
    public static Double[0...,0...] Forward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double[]& scaling, Double& logLikelihood);
    public static void Backward(HiddenMarkovModel model, Int32[] observations, Double[] scaling, Double[0...,0...] bwd);
    public static Double[0...,0...] Backward(HiddenMarkovModel model, Int32[] observations);
    public static Double[0...,0...] Backward(HiddenMarkovModel model, Int32[] observations, Double[] scaling);
    public static Double[0...,0...] Backward(HiddenMarkovModel model, Int32[] observations, Double& logLikelihood);
    public static void Backward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double[] scaling, Double[0...,0...] bwd);
    public static Double[0...,0...] Backward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double[] scaling);
    public static void LogForward(HiddenMarkovModel model, Int32[] observations, Double[0...,0...] lnFwd);
    public static Double[0...,0...] LogForward(HiddenMarkovModel model, Int32[] observations, Double& logLikelihood);
    public static Double[0...,0...] LogForward(HiddenMarkovModel model, Int32[] observations);
    public static void LogForward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double[0...,0...] lnFwd);
    public static Double[0...,0...] LogForward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double& logLikelihood);
    public static Double[0...,0...] LogForward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations);
    public static void LogBackward(HiddenMarkovModel model, Int32[] observations, Double[0...,0...] lnBwd);
    public static Double[0...,0...] LogBackward(HiddenMarkovModel model, Int32[] observations);
    public static Double[0...,0...] LogBackward(HiddenMarkovModel model, Int32[] observations, Double& logLikelihood);
    public static void LogBackward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double[0...,0...] lnBwd);
    public static Double[0...,0...] LogBackward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations);
    public static Double[0...,0...] LogBackward(HiddenMarkovModel`1<TDistribution> model, Double[][] observations, Double& logLikelihood);
    public static void Forward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double[] scaling, Double[0...,0...] fwd);
    public static Double[0...,0...] Forward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double& logLikelihood);
    public static Double[0...,0...] Forward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double[]& scaling);
    public static Double[0...,0...] Forward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double[]& scaling, Double& logLikelihood);
    public static void Backward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double[] scaling, Double[0...,0...] bwd);
    public static Double[0...,0...] Backward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double[] scaling);
    public static void LogForward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double[0...,0...] lnFwd);
    public static Double[0...,0...] LogForward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double& logLikelihood);
    public static Double[0...,0...] LogForward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations);
    public static void LogBackward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double[0...,0...] lnBwd);
    public static Double[0...,0...] LogBackward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations);
    public static Double[0...,0...] LogBackward(HiddenMarkovModel`2<TDistribution, TObservation> model, TObservation[] observations, Double& logLikelihood);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Markov.HiddenMarkovClassifier : BaseHiddenMarkovClassifier`3<HiddenMarkovModel, GeneralDiscreteDistribution, int> {
    [ObsoleteAttribute("Please use NumberOfSymbols instead.")]
public int Symbols { get; }
    public int NumberOfSymbols { get; }
    public HiddenMarkovClassifier(int classes);
    public HiddenMarkovClassifier(int classes, ITopology topology, int symbols, String[] names);
    public HiddenMarkovClassifier(int classes, ITopology topology, int symbols);
    public HiddenMarkovClassifier(int classes, ITopology[] topology, int symbols);
    public HiddenMarkovClassifier(int classes, ITopology[] topology, int symbols, String[] names);
    public HiddenMarkovClassifier(int classes, Int32[] states, int symbols, String[] names);
    public HiddenMarkovClassifier(int classes, Int32[] states, int symbols);
    public int get_Symbols();
    public int get_NumberOfSymbols();
    [ObsoleteAttribute("Please use Decide(input) instead.")]
public int Compute(Int32[] sequence);
    [ObsoleteAttribute("Please use Decide(input) or Probability(input) instead.")]
public int Compute(Int32[] sequence, Double& response);
    [ObsoleteAttribute("Please use Decide(input) instead.")]
public int Compute(Int32[] sequence, Double[]& responsibilities);
    public double LogLikelihood(Int32[][] sequences, Int32[] outputs);
    public static HiddenMarkovClassifier`1<GeneralDiscreteDistribution> CreateGeneric(int classes, Int32[] states, int symbols);
    public static HiddenMarkovClassifier`2<GeneralDiscreteDistribution, int> CreateGeneric2(int classes, Int32[] states, int symbols);
    private sealed virtual override int Accord.Statistics.Models.Markov.IHiddenMarkovClassifier.Compute(Array sequence, Double[]& likelihoods);
    [ObsoleteAttribute("Please use Accord.Serializer.Save instead.")]
public void Save(Stream stream);
    [ObsoleteAttribute("Please use Accord.Serializer.Save instead.")]
public void Save(string path);
    [ObsoleteAttribute("Please use Accord.Serializer.Load instead.")]
public static HiddenMarkovClassifier Load(Stream stream);
    [ObsoleteAttribute("Please use Accord.Serializer.Load instead.")]
public static HiddenMarkovClassifier Load(string path);
    [ObsoleteAttribute("Please use Accord.Serializer.Load instead.")]
public static HiddenMarkovClassifier`1<TDistribution> Load(Stream stream);
    [ObsoleteAttribute("Please use Accord.Serializer.Load instead.")]
public static HiddenMarkovClassifier`1<TDistribution> Load(string path);
}
[SerializableAttribute]
[ObsoleteAttribute("Please use HiddenMarkovClassifier<TDistribution, TObservation> instead.")]
public class Accord.Statistics.Models.Markov.HiddenMarkovClassifier`1 : BaseHiddenMarkovClassifier`1<HiddenMarkovModel`1<TDistribution>> {
    public int Dimension { get; }
    public HiddenMarkovClassifier`1(int classes, Int32[] states, TDistribution initial);
    public HiddenMarkovClassifier`1(int classes, ITopology topology, TDistribution initial);
    public HiddenMarkovClassifier`1(int classes, ITopology topology, TDistribution[] initial);
    public HiddenMarkovClassifier`1(int classes, ITopology[] topology, TDistribution[] initial);
    public HiddenMarkovClassifier`1(int classes, ITopology[] topology, TDistribution initial);
    public HiddenMarkovClassifier`1(int classes, ITopology[] topology, TDistribution initial, String[] names);
    public HiddenMarkovClassifier`1(HiddenMarkovModel`1[] models);
    public HiddenMarkovClassifier`1(int classes, ITopology topology, TDistribution initial, String[] names);
    public int get_Dimension();
    public int Compute(Array sequence);
    public int Compute(Array sequence, Double& response);
    public sealed virtual int Compute(Array sequence, Double[]& responsibilities);
    public double LogLikelihood(Array sequence, int output);
    public double LogLikelihood(Array sequence);
    public double LogLikelihood(Array[] sequences, Int32[] outputs);
    [ObsoleteAttribute("Please use Accord.Serializer.Save instead.")]
public void Save(Stream stream);
    [ObsoleteAttribute("Please use Accord.Serializer.Save instead.")]
public void Save(string path);
    [ObsoleteAttribute("Please use Accord.Serializer.Load instead.")]
public static HiddenMarkovClassifier`1<TDistribution> Load(Stream stream);
    [ObsoleteAttribute("Please use Accord.Serializer.Load instead.")]
public static HiddenMarkovClassifier`1<TDistribution> Load(string path);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Markov.HiddenMarkovClassifier`2 : BaseHiddenMarkovClassifier`3<HiddenMarkovModel`2<TDistribution, TObservation>, TDistribution, TObservation> {
    public HiddenMarkovClassifier`2(int classes);
    public HiddenMarkovClassifier`2(int classes, Int32[] states, Func`3<int, int, TDistribution> initial);
    public HiddenMarkovClassifier`2(int classes, ITopology topology, Func`3<int, int, TDistribution> initial);
    public HiddenMarkovClassifier`2(int classes, Int32[] states, TDistribution initial);
    public HiddenMarkovClassifier`2(int classes, ITopology topology, TDistribution initial);
    public HiddenMarkovClassifier`2(int classes, ITopology topology, TDistribution[] initial);
    public HiddenMarkovClassifier`2(int classes, ITopology[] topology, TDistribution[] initial);
    public HiddenMarkovClassifier`2(int classes, ITopology[] topology, TDistribution initial);
    public HiddenMarkovClassifier`2(int classes, ITopology[] topology, TDistribution initial, String[] names);
    public HiddenMarkovClassifier`2(HiddenMarkovModel`2[] models);
    public HiddenMarkovClassifier`2(int classes, ITopology topology, TDistribution initial, String[] names);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Markov.HiddenMarkovModel : HiddenMarkovModel`2<GeneralDiscreteDistribution, int> {
    private Double[][] logB;
    private int symbols;
    [ObsoleteAttribute("Please use LogTransitions instead.")]
public Double[0...,0...] Transitions { get; }
    [ObsoleteAttribute("Please use LogInitial instead.")]
public Double[] Probabilities { get; }
    [ObsoleteAttribute("Please use NumberOfSymbols instead.")]
public int Symbols { get; }
    public int NumberOfSymbols { get; }
    [ObsoleteAttribute("Please use LogEmissions instead.")]
public Double[0...,0...] Emissions { get; }
    public Double[][] LogEmissions { get; }
    public HiddenMarkovModel(ITopology topology, Double[0...,0...] emissions, bool logarithm);
    public HiddenMarkovModel(ITopology topology, Double[][] emissions, bool logarithm);
    public HiddenMarkovModel(ITopology topology, int symbols);
    public HiddenMarkovModel(ITopology topology, int symbols, bool random);
    public HiddenMarkovModel(Double[0...,0...] transitions, Double[0...,0...] emissions, Double[] initial, bool logarithm);
    public HiddenMarkovModel(Double[][] transitions, Double[][] emissions, Double[] initial, bool logarithm);
    public HiddenMarkovModel(int states, int symbols);
    public HiddenMarkovModel(int states, int symbols, bool random);
    public sealed virtual Double[0...,0...] get_Transitions();
    public sealed virtual Double[] get_Probabilities();
    public int get_Symbols();
    public int get_NumberOfSymbols();
    public Double[0...,0...] get_Emissions();
    public Double[][] get_LogEmissions();
    public virtual Int32[] Predict(Int32[] observations, int next);
    public Int32[] Predict(Int32[] observations, int next, Double[][]& logLikelihoods);
    public int Predict(Int32[] observations, Double[]& logLikelihoods);
    public Int32[] Predict(Int32[] observations, int next, Double& logLikelihood, Double[][]& logLikelihoods);
    [ObsoleteAttribute("Please use ToGenericModel instead.")]
public HiddenMarkovModel`1<GeneralDiscreteDistribution> ToContinuousModel();
    public HiddenMarkovModel`2<GeneralDiscreteDistribution, int> ToGenericModel();
    public static HiddenMarkovModel`1<GeneralDiscreteDistribution> op_Explicit(HiddenMarkovModel model);
    [ObsoleteAttribute("Please use CreateDiscrete() instead.")]
public static HiddenMarkovModel`1<GeneralDiscreteDistribution> CreateGeneric(Double[0...,0...] transitions, Double[0...,0...] emissions, Double[] probabilities, bool logarithm);
    [ObsoleteAttribute("Please use CreateDiscrete() instead.")]
public static HiddenMarkovModel`1<GeneralDiscreteDistribution> CreateGeneric(ITopology topology, int symbols);
    [ObsoleteAttribute("Please use CreateDiscrete() instead.")]
public static HiddenMarkovModel`1<GeneralDiscreteDistribution> CreateGeneric(ITopology topology, int symbols, bool random);
    [ObsoleteAttribute("Please use CreateDiscrete() instead.")]
public static HiddenMarkovModel`1<GeneralDiscreteDistribution> CreateGeneric(int states, int symbols);
    [ObsoleteAttribute("Please use CreateDiscrete() instead.")]
public static HiddenMarkovModel`1<GeneralDiscreteDistribution> CreateGeneric(int states, int symbols, bool random);
    public static HiddenMarkovModel`2<GeneralDiscreteDistribution, int> CreateDiscrete(Double[0...,0...] transitions, Double[0...,0...] emissions, Double[] probabilities, bool logarithm);
    public static HiddenMarkovModel`2<GeneralDiscreteDistribution, int> CreateDiscrete(ITopology topology, int symbols);
    public static HiddenMarkovModel`2<GeneralDiscreteDistribution, int> CreateDiscrete(ITopology topology, int symbols, bool random);
    public static HiddenMarkovModel`2<GeneralDiscreteDistribution, int> CreateDiscrete(int states, int symbols);
    public static HiddenMarkovModel`2<GeneralDiscreteDistribution, int> CreateDiscrete(int states, int symbols, bool random);
    private sealed virtual override Int32[] Accord.Statistics.Models.Markov.IHiddenMarkovModel.Decode(Array sequence, Double& logLikelihood);
    private sealed virtual override double Accord.Statistics.Models.Markov.IHiddenMarkovModel.Evaluate(Array sequence);
    private sealed virtual override Double[][] Accord.Statistics.Models.Markov.IHiddenMarkovModel.Posterior(Array observations);
    private sealed virtual override Double[][] Accord.Statistics.Models.Markov.IHiddenMarkovModel.Posterior(Array observations, Int32[]& path);
    public virtual object Clone();
    [ObsoleteAttribute("Please use the Accord.Serializer class instead.")]
public void Save(Stream stream);
    [ObsoleteAttribute("Please use the Accord.Serializer class instead.")]
public void Save(string path);
    [ObsoleteAttribute("Please use the Accord.Serializer class instead.")]
public static HiddenMarkovModel Load(Stream stream);
    [ObsoleteAttribute("Please use the Accord.Serializer class instead.")]
public static HiddenMarkovModel Load(string path);
    [ObsoleteAttribute("Please use the Accord.Serializer class instead.")]
public static HiddenMarkovModel`1<TDistribution> Load(Stream stream);
    [ObsoleteAttribute("Please use the Accord.Serializer class instead.")]
public static HiddenMarkovModel`1<TDistribution> Load(string path);
    private void checkObservations(IndexOutOfRangeException ex, Int32[] observations);
}
[SerializableAttribute]
[ObsoleteAttribute("Please use HiddenMarkovModel<TDistribution, TObservation> instead.")]
public class Accord.Statistics.Models.Markov.HiddenMarkovModel`1 : BaseHiddenMarkovModel {
    private TDistribution[] B;
    private int dimension;
    private bool multivariate;
    public int Dimension { get; }
    public TDistribution[] Emissions { get; }
    public HiddenMarkovModel`1(ITopology topology, TDistribution emissions);
    public HiddenMarkovModel`1(ITopology topology, TDistribution[] emissions);
    public HiddenMarkovModel`1(Double[0...,0...] transitions, TDistribution[] emissions, Double[] probabilities, bool logarithm);
    public HiddenMarkovModel`1(int states, TDistribution emissions);
    public int get_Dimension();
    public TDistribution[] get_Emissions();
    public Int32[] Decode(Array observations);
    public sealed virtual Int32[] Decode(Array observations, Double& logLikelihood);
    private Int32[] viterbi(Double[][] x, Double& logLikelihood);
    public sealed virtual Double[][] Posterior(Array observations);
    public sealed virtual Double[][] Posterior(Array observations, Int32[]& path);
    public sealed virtual double Evaluate(Array observations);
    public double Evaluate(Array observations, Int32[] path);
    public Double[] Predict(Double[][] observations);
    public double Predict(Double[] observations);
    public Double[] Predict(Double[][] observations, Double& logLikelihood);
    public double Predict(Double[] observations, Double& logLikelihood);
    public Double[] Predict(Double[][] observations, Double& logLikelihood, MultivariateMixture`1& probabilities);
    public Double[] Predict(Double[][] observations, MultivariateMixture`1& probabilities);
    public double Predict(Double[] observations, Mixture`1& probabilities);
    public double Predict(Double[] observations, Double& logLikelihood, Mixture`1& probabilities);
    public Double[][] Predict(Double[][] observations, int next, Double& logLikelihood);
    public Double[] Predict(Double[] observations, int next, Double& logLikelihood);
    public Array Generate(int samples);
    public Array Generate(int samples, Int32[]& path, Double& logLikelihood);
    private Double[][] predict(Double[][] observations, Double& logLikelihood, MultivariateMixture`1& probabilities);
    private Double[] predict(Double[] observations, Double& logLikelihood, Mixture`1& probabilities);
    private Double[][] predict(Double[][] observations, int next, Double& logLikelihood, Double[][]& lnFuture);
    private static Double[] getMode(TDistribution dist);
    private void checkHiddenStates(IndexOutOfRangeException ex, Int32[] path);
    public sealed virtual object Clone();
    public void Save(Stream stream);
    public void Save(string path);
    public static HiddenMarkovModel`1<TDistribution> Load(Stream stream);
    public static HiddenMarkovModel`1<TDistribution> Load(string path);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Markov.HiddenMarkovModel`2 : LikelihoodTaggerBase`1<TObservation> {
    private TDistribution[] B;
    private Double[][] logA;
    private Double[] logPi;
    private int states;
    private object tag;
    [CompilerGeneratedAttribute]
private HiddenMarkovModelAlgorithm <Algorithm>k__BackingField;
    public HiddenMarkovModelAlgorithm Algorithm { get; public set; }
    [ObsoleteAttribute("Please use 'NumberOfStates instead.")]
public int States { get; }
    public int NumberOfStates { get; }
    public Double[] LogInitial { get; }
    public Double[][] LogTransitions { get; }
    public object Tag { get; public set; }
    public TDistribution[] Emissions { get; protected set; }
    protected HiddenMarkovModel`2(ITopology topology);
    public HiddenMarkovModel`2(ITopology topology, Func`2<int, TDistribution> emissions);
    public HiddenMarkovModel`2(ITopology topology, TDistribution emissions);
    public HiddenMarkovModel`2(ITopology topology, TDistribution[] emissions);
    public HiddenMarkovModel`2(Double[][] transitions, TDistribution[] emissions, Double[] probabilities, bool logarithm);
    public HiddenMarkovModel`2(Double[0...,0...] transitions, TDistribution[] emissions, Double[] probabilities, bool logarithm);
    public HiddenMarkovModel`2(int states, TDistribution emissions);
    public HiddenMarkovModel`2(int states, Func`2<int, TDistribution> emissions);
    [CompilerGeneratedAttribute]
public HiddenMarkovModelAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(HiddenMarkovModelAlgorithm value);
    public sealed virtual int get_States();
    public int get_NumberOfStates();
    public sealed virtual Double[] get_LogInitial();
    public sealed virtual Double[][] get_LogTransitions();
    public sealed virtual object get_Tag();
    public sealed virtual void set_Tag(object value);
    public TDistribution[] get_Emissions();
    protected void set_Emissions(TDistribution[] value);
    private void emissions(TObservation[] x, Double[0...,0...] output);
    private void viterbiDecode(TObservation[] x, Double& logLikelihood, Double[0...,0...] lnFwd, Int32[0...,0...] s, Int32[]& path);
    private double viterbiLikelihood(TObservation[] x, Double[0...,0...] lnFwd, Int32[0...,0...] s, Int32& maxState);
    private double viterbiLikelihood(TObservation[] observations, Int32[] path);
    private void viterbiPosterior(TObservation[] x, Double[0...,0...] lnFwd, Int32[0...,0...] s, Double[][] result);
    private void forwardPosterior(TObservation[] observations, Double[0...,0...] lnFwd, Double[0...,0...] lnBwd, Double[][] result);
    private double forwardLikelihood(TObservation[] observations, Double[0...,0...] lnFwd);
    [ObsoleteAttribute("Please set Algorithm to Viterbi and call Decide() instead.")]
public Int32[] Decode(TObservation[] observations);
    [ObsoleteAttribute("Please set Algorithm to Viterbi and call Decide() instead.")]
public Int32[] Decode(TObservation[] observations, Double& logLikelihood);
    [ObsoleteAttribute("Please set Algorithm to Forward and call LogLikelihoods() instead.")]
public Double[][] Posterior(TObservation[] observations);
    [ObsoleteAttribute("Please set Algorithm to Forward and call LogLikelihoods() instead.")]
public Double[][] Posterior(TObservation[] observations, Int32[]& path);
    [ObsoleteAttribute("Please set Algorithm to Forward and call LogLikelihood() instead.")]
public double Evaluate(TObservation[] observations);
    [ObsoleteAttribute("Please use LogLikelihood(observations, path) instead.")]
public double Evaluate(TObservation[] observations, Int32[] path);
    public TObservation Predict(TObservation[] observations);
    public TObservation Predict(TObservation[] observations, Double& logLikelihood);
    public TObservation Predict(TObservation[] observations, Double& logLikelihood, MultivariateMixture`1& probabilities);
    public TObservation Predict(TObservation[] observations, MultivariateMixture`1& probabilities);
    public TObservation Predict(TObservation[] observations, Mixture`1& probabilities);
    public TObservation Predict(TObservation[] observations, Double& logLikelihood, Mixture`1& probabilities);
    public virtual TObservation[] Predict(TObservation[] observations, int next);
    public TObservation[] Predict(TObservation[] observations, int next, Double& logLikelihood);
    public TObservation[] Generate(int samples);
    public TObservation[] Generate(int samples, Int32[]& path, Double& logLikelihood);
    private TObservation[] predict(TObservation[] observations, Double& logLikelihood, MultivariateMixture`1& probabilities);
    private TObservation[] predict(TObservation[] observations, Double& logLikelihood, Mixture`1& probabilities);
    private TObservation[] predict(TObservation[] observations, int next, Double& logLikelihood, Double[][]& lnFuture);
    private static TObservation getMode(TDistribution dist);
    private void checkHiddenStates(IndexOutOfRangeException ex, Int32[] path);
    public virtual object Clone();
    public double LogLikelihood(TObservation[] sequences, Int32[] path);
    public Double[] LogLikelihood(TObservation[][] sequences, Int32[][] path);
    public Double[] LogLikelihood(TObservation[][] sequences, Int32[][] path, Double[] result);
    public virtual Double[] LogLikelihood(TObservation[][] sequences, Double[] result);
    public virtual Double[] LogLikelihood(TObservation[][] sequences, Int32[][]& decision, Double[] result);
    public virtual Double[][] LogLikelihoods(TObservation[] sequence, Double[][] result);
    public virtual Double[][] LogLikelihoods(TObservation[] sequence, Int32[]& decision, Double[][] result);
    public virtual Int32[][] Decide(TObservation[][] input, Int32[][] result);
    public virtual Int32[] Decide(TObservation[] input, Int32[] result);
}
public enum Accord.Statistics.Models.Markov.HiddenMarkovModelAlgorithm : Enum {
    public int value__;
    public static HiddenMarkovModelAlgorithm Viterbi;
    public static HiddenMarkovModelAlgorithm Forward;
}
public class Accord.Statistics.Models.Markov.Hybrid.GeneralMarkovFunction : MulticastDelegate {
    public GeneralMarkovFunction(object object, IntPtr method);
    public virtual Double[] Invoke(int previous, Double[] observation);
    public virtual IAsyncResult BeginInvoke(int previous, Double[] observation, AsyncCallback callback, object object);
    public virtual Double[] EndInvoke(IAsyncResult result);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Markov.Hybrid.HybridMarkovClassifier : object {
    [CompilerGeneratedAttribute]
private IHybridMarkovModel[] <Models>k__BackingField;
    public IHybridMarkovModel[] Models { get; private set; }
    public int Dimension { get; }
    public HybridMarkovClassifier(IEnumerable`1<IHybridMarkovModel> models);
    [CompilerGeneratedAttribute]
public IHybridMarkovModel[] get_Models();
    [CompilerGeneratedAttribute]
private void set_Models(IHybridMarkovModel[] value);
    public int get_Dimension();
    public int Compute(Double[][] sequence);
    public int Compute(Double[][] sequence, Double& response);
    public int Compute(Double[][] sequence, Double[]& responsibilities);
}
public class Accord.Statistics.Models.Markov.Hybrid.HybridMarkovModel : object {
    [CompilerGeneratedAttribute]
private GeneralMarkovFunction <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private int <States>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Dimension>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    public GeneralMarkovFunction Function { get; private set; }
    public int States { get; private set; }
    public int Dimension { get; private set; }
    public object Tag { get; public set; }
    public HybridMarkovModel(GeneralMarkovFunction function, int states, int dimension);
    [CompilerGeneratedAttribute]
public GeneralMarkovFunction get_Function();
    [CompilerGeneratedAttribute]
private void set_Function(GeneralMarkovFunction value);
    [CompilerGeneratedAttribute]
public int get_States();
    [CompilerGeneratedAttribute]
private void set_States(int value);
    [CompilerGeneratedAttribute]
public int get_Dimension();
    [CompilerGeneratedAttribute]
private void set_Dimension(int value);
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
    public Int32[] Decode(Double[][] observations, Double& logLikelihood);
    public double Evaluate(Double[][] observations);
}
public interface Accord.Statistics.Models.Markov.Hybrid.IHybridMarkovModel {
    public int Dimension { get; }
    public int States { get; }
    public object Tag { get; public set; }
    public abstract virtual Int32[] Decode(Double[][] observations, Double& logLikelihood);
    public abstract virtual double Evaluate(Double[][] observations);
    public abstract virtual int get_Dimension();
    public abstract virtual int get_States();
    public abstract virtual object get_Tag();
    public abstract virtual void set_Tag(object value);
}
[ObsoleteAttribute("Please use IMulticlassClassifier from Accord.MachineLearning namespace.")]
public interface Accord.Statistics.Models.Markov.IHiddenMarkovClassifier {
    public int Classes { get; }
    public abstract virtual int Compute(Array sequence, Double[]& responsibilities);
    public abstract virtual int get_Classes();
}
public interface Accord.Statistics.Models.Markov.IHiddenMarkovModel {
    public int States { get; }
    [ObsoleteAttribute("Please use the LogInitial property instead.")]
public Double[] Probabilities { get; }
    public Double[] LogInitial { get; }
    [ObsoleteAttribute("Please use the LogTransitions property instead.")]
public Double[0...,0...] Transitions { get; }
    public Double[][] LogTransitions { get; }
    public object Tag { get; public set; }
    public abstract virtual Int32[] Decode(Array observations, Double& logLikelihood);
    public abstract virtual double Evaluate(Array observations);
    public abstract virtual int get_States();
    public abstract virtual Double[] get_Probabilities();
    public abstract virtual Double[] get_LogInitial();
    public abstract virtual Double[0...,0...] get_Transitions();
    public abstract virtual Double[][] get_LogTransitions();
    public abstract virtual object get_Tag();
    public abstract virtual void set_Tag(object value);
    public abstract virtual Double[][] Posterior(Array observations);
    public abstract virtual Double[][] Posterior(Array observations, Int32[]& path);
}
[ObsoleteAttribute("This class will be removed")]
public abstract class Accord.Statistics.Models.Markov.Learning.BaseBaumWelchLearning : object {
    private AbsoluteConvergence convergence;
    private IHiddenMarkovModel model;
    [CompilerGeneratedAttribute]
private Double[0...,0...][][] <LogKsi>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[0...,0...][] <LogGamma>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <LogWeights>k__BackingField;
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public Double[0...,0...][][] LogKsi { get; protected set; }
    public Double[0...,0...][] LogGamma { get; protected set; }
    public Double[] LogWeights { get; protected set; }
    protected BaseBaumWelchLearning(IHiddenMarkovModel model);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_CurrentIteration();
    public sealed virtual bool get_HasConverged();
    [CompilerGeneratedAttribute]
public Double[0...,0...][][] get_LogKsi();
    [CompilerGeneratedAttribute]
protected void set_LogKsi(Double[0...,0...][][] value);
    [CompilerGeneratedAttribute]
public Double[0...,0...][] get_LogGamma();
    [CompilerGeneratedAttribute]
protected void set_LogGamma(Double[0...,0...][] value);
    [CompilerGeneratedAttribute]
public Double[] get_LogWeights();
    [CompilerGeneratedAttribute]
protected void set_LogWeights(Double[] value);
    protected double Run(Array[] observations);
    protected double Run(Array[] observations, Double[] weights);
    private double run(Array[] observations);
    protected abstract virtual void ComputeForwardBackward(int index, Double[0...,0...] lnFwd, Double[0...,0...] lnBwd);
    protected abstract virtual void ComputeKsi(int index, Double[0...,0...] lnFwd, Double[0...,0...] lnBwd);
    protected abstract virtual void UpdateEmissions();
}
public abstract class Accord.Statistics.Models.Markov.Learning.BaseBaumWelchLearning`4 : BaseHiddenMarkovModelLearning`2<TModel, TObservation> {
    private RelativeConvergence convergence;
    private TObservation[][] vectorObservations;
    private TObservation[] samples;
    private Double[0...,0...] lnFwd;
    private Double[0...,0...] lnBwd;
    private Double[] sampleWeights;
    [CompilerGeneratedAttribute]
private TOptions <FittingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LogLikelihood>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<int, TDistribution> <Emissions>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[0...,0...][][] <LogKsi>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[0...,0...][] <LogGamma>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <LogWeights>k__BackingField;
    protected TObservation[][] Observations { get; }
    public IConvergence Convergence { get; }
    public TOptions FittingOptions { get; public set; }
    public double LogLikelihood { get; public set; }
    public Func`2<int, TDistribution> Emissions { get; public set; }
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; public set; }
    public bool HasConverged { get; }
    public Double[0...,0...][][] LogKsi { get; protected set; }
    public Double[0...,0...][] LogGamma { get; protected set; }
    public Double[] LogWeights { get; protected set; }
    public BaseBaumWelchLearning`4(TModel model);
    protected TObservation[][] get_Observations();
    public IConvergence get_Convergence();
    [CompilerGeneratedAttribute]
public TOptions get_FittingOptions();
    [CompilerGeneratedAttribute]
public void set_FittingOptions(TOptions value);
    [CompilerGeneratedAttribute]
public double get_LogLikelihood();
    [CompilerGeneratedAttribute]
public void set_LogLikelihood(double value);
    [CompilerGeneratedAttribute]
public Func`2<int, TDistribution> get_Emissions();
    [CompilerGeneratedAttribute]
public void set_Emissions(Func`2<int, TDistribution> value);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_CurrentIteration();
    public void set_CurrentIteration(int value);
    public sealed virtual bool get_HasConverged();
    [CompilerGeneratedAttribute]
public Double[0...,0...][][] get_LogKsi();
    [CompilerGeneratedAttribute]
protected void set_LogKsi(Double[0...,0...][][] value);
    [CompilerGeneratedAttribute]
public Double[0...,0...][] get_LogGamma();
    [CompilerGeneratedAttribute]
protected void set_LogGamma(Double[0...,0...][] value);
    [CompilerGeneratedAttribute]
public Double[] get_LogWeights();
    [CompilerGeneratedAttribute]
protected void set_LogWeights(Double[] value);
    public sealed virtual TModel Learn(TObservation[][] x, Double[] weights);
    private double Expectation(TObservation[][] x, int maxLength);
    private static void CheckArgs(TObservation[][] observations, Double[] weights);
    protected void ComputeKsi(int index, Double[0...,0...] lnFwd, Double[0...,0...] lnBwd);
    protected void UpdateEmissions();
    protected virtual void Fit(int index, TObservation[] values, Double[] weights);
    protected void ComputeForwardBackward(int index, Double[0...,0...] lnFwd, Double[0...,0...] lnBwd);
}
public abstract class Accord.Statistics.Models.Markov.Learning.BaseBaumWelchLearningOptions`4 : BaseBaumWelchLearning`4<TModel, TDistribution, TObservation, TOptions> {
    public BaseBaumWelchLearningOptions`4(TModel model);
    protected virtual void Fit(int index, TObservation[] values, Double[] weights);
}
public abstract class Accord.Statistics.Models.Markov.Learning.BaseHiddenMarkovClassifierLearning`2 : object {
    [CompilerGeneratedAttribute]
private TClassifier <Classifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ClassifierLearningAlgorithmConfiguration <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Rejection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Empirical>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<GenerativeLearningEventArgs> ClassModelLearningStarted;
    [CompilerGeneratedAttribute]
private EventHandler`1<GenerativeLearningEventArgs> ClassModelLearningFinished;
    public TClassifier Classifier { get; private set; }
    public ClassifierLearningAlgorithmConfiguration Algorithm { get; public set; }
    public bool Rejection { get; public set; }
    public bool Empirical { get; public set; }
    [ObsoleteAttribute("Please set the learning algorithm using the Learner property.")]
protected BaseHiddenMarkovClassifierLearning`2(TClassifier classifier, ClassifierLearningAlgorithmConfiguration algorithm);
    protected BaseHiddenMarkovClassifierLearning`2(TClassifier classifier);
    [CompilerGeneratedAttribute]
public TClassifier get_Classifier();
    [CompilerGeneratedAttribute]
private void set_Classifier(TClassifier value);
    [CompilerGeneratedAttribute]
public ClassifierLearningAlgorithmConfiguration get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(ClassifierLearningAlgorithmConfiguration value);
    [CompilerGeneratedAttribute]
public bool get_Rejection();
    [CompilerGeneratedAttribute]
public void set_Rejection(bool value);
    [CompilerGeneratedAttribute]
public bool get_Empirical();
    [CompilerGeneratedAttribute]
public void set_Empirical(bool value);
    [CompilerGeneratedAttribute]
public void add_ClassModelLearningStarted(EventHandler`1<GenerativeLearningEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClassModelLearningStarted(EventHandler`1<GenerativeLearningEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClassModelLearningFinished(EventHandler`1<GenerativeLearningEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClassModelLearningFinished(EventHandler`1<GenerativeLearningEventArgs> value);
    [ObsoleteAttribute("Please use the Learn method.")]
protected double Run(T[] inputs, Int32[] outputs);
    public abstract virtual TModel Threshold();
    protected ITopology CreateThresholdTopology();
    private static void check(Double[0...,0...] transitions, int index);
    protected void OnGenerativeClassModelLearningFinished(GenerativeLearningEventArgs args);
    protected void OnGenerativeClassModelLearningStarted(GenerativeLearningEventArgs args);
}
public abstract class Accord.Statistics.Models.Markov.Learning.BaseHiddenMarkovClassifierLearning`4 : object {
    [CompilerGeneratedAttribute]
private ParallelOptions <ParallelOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private TClassifier <Classifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ClassifierLearningAlgorithmConfiguration <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<int, IUnsupervisedLearning`3<TModel, TObservation[], Int32[]>> <Learner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Rejection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Empirical>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LogLikelihood>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<GenerativeLearningEventArgs> ClassModelLearningStarted;
    [CompilerGeneratedAttribute]
private EventHandler`1<GenerativeLearningEventArgs> ClassModelLearningFinished;
    public ParallelOptions ParallelOptions { get; public set; }
    public CancellationToken Token { get; public set; }
    public TClassifier Classifier { get; private set; }
    [ObsoleteAttribute("Please use the Learner property instead.")]
public ClassifierLearningAlgorithmConfiguration Algorithm { get; public set; }
    public Func`2<int, IUnsupervisedLearning`3<TModel, TObservation[], Int32[]>> Learner { get; public set; }
    public bool Rejection { get; public set; }
    public bool Empirical { get; public set; }
    public double LogLikelihood { get; public set; }
    [ObsoleteAttribute("Please set the learning algorithm using the Learner property.")]
protected BaseHiddenMarkovClassifierLearning`4(TClassifier classifier, ClassifierLearningAlgorithmConfiguration algorithm);
    protected BaseHiddenMarkovClassifierLearning`4(TClassifier classifier, Func`2<int, IUnsupervisedLearning`3<TModel, TObservation[], Int32[]>> learner);
    protected BaseHiddenMarkovClassifierLearning`4(TClassifier classifier);
    [CompilerGeneratedAttribute]
public sealed virtual ParallelOptions get_ParallelOptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ParallelOptions(ParallelOptions value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    [CompilerGeneratedAttribute]
public TClassifier get_Classifier();
    [CompilerGeneratedAttribute]
private void set_Classifier(TClassifier value);
    [CompilerGeneratedAttribute]
public ClassifierLearningAlgorithmConfiguration get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(ClassifierLearningAlgorithmConfiguration value);
    [CompilerGeneratedAttribute]
public Func`2<int, IUnsupervisedLearning`3<TModel, TObservation[], Int32[]>> get_Learner();
    [CompilerGeneratedAttribute]
public void set_Learner(Func`2<int, IUnsupervisedLearning`3<TModel, TObservation[], Int32[]>> value);
    [CompilerGeneratedAttribute]
public bool get_Rejection();
    [CompilerGeneratedAttribute]
public void set_Rejection(bool value);
    [CompilerGeneratedAttribute]
public bool get_Empirical();
    [CompilerGeneratedAttribute]
public void set_Empirical(bool value);
    [CompilerGeneratedAttribute]
public double get_LogLikelihood();
    [CompilerGeneratedAttribute]
public void set_LogLikelihood(double value);
    [CompilerGeneratedAttribute]
public void add_ClassModelLearningStarted(EventHandler`1<GenerativeLearningEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClassModelLearningStarted(EventHandler`1<GenerativeLearningEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClassModelLearningFinished(EventHandler`1<GenerativeLearningEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClassModelLearningFinished(EventHandler`1<GenerativeLearningEventArgs> value);
    [ObsoleteAttribute("Please use the Learn(x, y) method instead.")]
protected double Run(T[] inputs, Int32[] outputs);
    public abstract virtual TModel Threshold();
    protected ITopology CreateThresholdTopology();
    private static void check(Double[0...,0...] transitions, int index);
    protected void OnGenerativeClassModelLearningFinished(GenerativeLearningEventArgs args);
    protected void OnGenerativeClassModelLearningStarted(GenerativeLearningEventArgs args);
    public sealed virtual TClassifier Learn(TObservation[][] x, Int32[] y, Double[] weights);
    private void LearnInner(TObservation[][] x, Int32[] y, int i, int classes, Double[] logLikelihood, Int32[] classCounts);
    protected abstract virtual TClassifier Create(TObservation[][] x, Int32[] y, int numberOfClasses);
}
public abstract class Accord.Statistics.Models.Markov.Learning.BaseHiddenMarkovModelLearning`2 : ParallelLearningBase {
    private int numberOfStates;
    private ITopology topology;
    [CompilerGeneratedAttribute]
private TModel <Model>k__BackingField;
    public int NumberOfStates { get; public set; }
    public ITopology Topology { get; public set; }
    public TModel Model { get; public set; }
    public BaseHiddenMarkovModelLearning`2(TModel model);
    public int get_NumberOfStates();
    public void set_NumberOfStates(int value);
    public ITopology get_Topology();
    public void set_Topology(ITopology value);
    [CompilerGeneratedAttribute]
public TModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(TModel value);
    protected abstract virtual TModel Create(TObservation[][] x);
}
public abstract class Accord.Statistics.Models.Markov.Learning.BaseMaximumLikelihoodLearning`4 : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private TModel model;
    private bool useLaplaceRule;
    private bool useWeights;
    private TOptions fittingOptions;
    [CompilerGeneratedAttribute]
private Func`2<int, TDistribution> <Emissions>k__BackingField;
    public CancellationToken Token { get; public set; }
    public TModel Model { get; public set; }
    public bool UseWeights { get; public set; }
    public bool UseLaplaceRule { get; public set; }
    public Func`2<int, TDistribution> Emissions { get; public set; }
    public TOptions FittingOptions { get; public set; }
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public TModel get_Model();
    public void set_Model(TModel value);
    public bool get_UseWeights();
    public void set_UseWeights(bool value);
    public bool get_UseLaplaceRule();
    public void set_UseLaplaceRule(bool value);
    [CompilerGeneratedAttribute]
public Func`2<int, TDistribution> get_Emissions();
    [CompilerGeneratedAttribute]
public void set_Emissions(Func`2<int, TDistribution> value);
    public TOptions get_FittingOptions();
    public void set_FittingOptions(TOptions value);
    public sealed virtual TModel Learn(TObservation[][] x, Int32[][] y, Double[] weights);
    protected abstract virtual TModel Create(TObservation[][] x, int numberOfClasses);
}
public abstract class Accord.Statistics.Models.Markov.Learning.BaseViterbiLearning`1 : object {
    private RelativeConvergence convergence;
    private int batches;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    public CancellationToken Token { get; public set; }
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public int Batches { get; public set; }
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public virtual void set_Token(CancellationToken value);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_CurrentIteration();
    public sealed virtual bool get_HasConverged();
    public int get_Batches();
    public void set_Batches(int value);
    public double Run(T[] observations);
    protected abstract virtual double ComputeLogLikelihood(T[] observations);
    protected abstract virtual void RunEpoch(T[] inputs, Int32[][] outputs);
}
public class Accord.Statistics.Models.Markov.Learning.BaumWelchLearning : BaseBaumWelchLearningOptions`4<HiddenMarkovModel, GeneralDiscreteDistribution, int, GeneralDiscreteOptions> {
    [CompilerGeneratedAttribute]
private int <NumberOfSymbols>k__BackingField;
    public int NumberOfSymbols { get; public set; }
    public BaumWelchLearning(HiddenMarkovModel model);
    [CompilerGeneratedAttribute]
public int get_NumberOfSymbols();
    [CompilerGeneratedAttribute]
public void set_NumberOfSymbols(int value);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Int32[] observations);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Int32[][] observations);
    public static BaumWelchLearning`1<Mixture`1<NormalDistribution>> FromMixtureModel(HiddenMarkovModel`1<Mixture`1<NormalDistribution>> model, NormalOptions options);
    public static BaumWelchLearning`1<MultivariateMixture`1<MultivariateNormalDistribution>> FromMixtureModel(HiddenMarkovModel`1<MultivariateMixture`1<MultivariateNormalDistribution>> model, NormalOptions options);
    protected virtual HiddenMarkovModel Create(Int32[][] x);
}
[ObsoleteAttribute("Please use BaumWelchLearning<TDistribution, TObservation> instead.")]
public class Accord.Statistics.Models.Markov.Learning.BaumWelchLearning`1 : BaseBaumWelchLearning {
    private HiddenMarkovModel`1<TDistribution> model;
    private IFittingOptions fittingOptions;
    private Double[][][] vectorObservations;
    private Array samples;
    private Double[] weights;
    public HiddenMarkovModel`1<TDistribution> Model { get; }
    public IFittingOptions FittingOptions { get; public set; }
    public BaumWelchLearning`1(HiddenMarkovModel`1<TDistribution> model);
    public HiddenMarkovModel`1<TDistribution> get_Model();
    public IFittingOptions get_FittingOptions();
    public void set_FittingOptions(IFittingOptions value);
    public sealed virtual double Run(Array[] observations);
    protected virtual void ComputeKsi(int index, Double[0...,0...] lnFwd, Double[0...,0...] lnBwd);
    protected virtual void UpdateEmissions();
    protected virtual void ComputeForwardBackward(int index, Double[0...,0...] lnFwd, Double[0...,0...] lnBwd);
}
public class Accord.Statistics.Models.Markov.Learning.BaumWelchLearning`2 : BaseBaumWelchLearning`4<HiddenMarkovModel`2<TDistribution, TObservation>, TDistribution, TObservation, IFittingOptions> {
    public BaumWelchLearning`2(HiddenMarkovModel`2<TDistribution, TObservation> model);
    protected virtual HiddenMarkovModel`2<TDistribution, TObservation> Create(TObservation[][] x);
}
public class Accord.Statistics.Models.Markov.Learning.BaumWelchLearning`3 : BaseBaumWelchLearningOptions`4<HiddenMarkovModel`2<TDistribution, TObservation>, TDistribution, TObservation, TOptions> {
    public BaumWelchLearning`3(HiddenMarkovModel`2<TDistribution, TObservation> model);
    protected virtual HiddenMarkovModel`2<TDistribution, TObservation> Create(TObservation[][] x);
}
public class Accord.Statistics.Models.Markov.Learning.ClassifierLearningAlgorithmConfiguration : MulticastDelegate {
    public ClassifierLearningAlgorithmConfiguration(object object, IntPtr method);
    public virtual IUnsupervisedLearning Invoke(int modelIndex);
    public virtual IAsyncResult BeginInvoke(int modelIndex, AsyncCallback callback, object object);
    public virtual IUnsupervisedLearning EndInvoke(IAsyncResult result);
}
public class Accord.Statistics.Models.Markov.Learning.GenerativeLearningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Class>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Total>k__BackingField;
    public int Class { get; public set; }
    public int Total { get; public set; }
    public GenerativeLearningEventArgs(int classLabel, int classes);
    [CompilerGeneratedAttribute]
public int get_Class();
    [CompilerGeneratedAttribute]
public void set_Class(int value);
    [CompilerGeneratedAttribute]
public int get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(int value);
}
public class Accord.Statistics.Models.Markov.Learning.HiddenMarkovClassifierLearning : BaseHiddenMarkovClassifierLearning`4<HiddenMarkovClassifier, HiddenMarkovModel, GeneralDiscreteDistribution, int> {
    private int smoothingKernelSize;
    private double smoothingSigma;
    private Double[] gaussianKernel;
    public double Smoothing { get; public set; }
    public HiddenMarkovClassifierLearning(HiddenMarkovClassifier classifier, Func`2<int, IUnsupervisedLearning`3<HiddenMarkovModel, Int32[], Int32[]>> learner);
    public double get_Smoothing();
    public void set_Smoothing(double value);
    protected virtual HiddenMarkovClassifier Create(Int32[][] x, Int32[] y, int numberOfClasses);
    [ObsoleteAttribute("Please use the Learn(x, y) method instead.")]
public double Run(Int32[][] inputs, Int32[] outputs);
    public double ComputeError(Int32[][] inputs, Int32[] outputs);
    public virtual HiddenMarkovModel Threshold();
    private void createSmoothingKernel();
}
[ObsoleteAttribute("Please use HiddenMarkovClassifierLearning<TDistribution, TObservation> instead.")]
public class Accord.Statistics.Models.Markov.Learning.HiddenMarkovClassifierLearning`1 : BaseHiddenMarkovClassifierLearning`2<HiddenMarkovClassifier`1<TDistribution>, HiddenMarkovModel`1<TDistribution>> {
    public HiddenMarkovClassifierLearning`1(HiddenMarkovClassifier`1<TDistribution> classifier, ClassifierLearningAlgorithmConfiguration algorithm);
    public double Run(Array[] inputs, Int32[] outputs);
    public double ComputeError(Array[] inputs, Int32[] outputs);
    public virtual HiddenMarkovModel`1<TDistribution> Threshold();
}
public class Accord.Statistics.Models.Markov.Learning.HiddenMarkovClassifierLearning`2 : BaseHiddenMarkovClassifierLearning`4<HiddenMarkovClassifier`2<TDistribution, TObservation>, HiddenMarkovModel`2<TDistribution, TObservation>, TDistribution, TObservation> {
    [ObsoleteAttribute("Please set the learning algorithm using the Learner property.")]
public HiddenMarkovClassifierLearning`2(HiddenMarkovClassifier`2<TDistribution, TObservation> classifier, ClassifierLearningAlgorithmConfiguration algorithm);
    public HiddenMarkovClassifierLearning`2(HiddenMarkovClassifier`2<TDistribution, TObservation> classifier);
    protected virtual HiddenMarkovClassifier`2<TDistribution, TObservation> Create(TObservation[][] x, Int32[] y, int numberOfClasses);
    public virtual HiddenMarkovModel`2<TDistribution, TObservation> Threshold();
}
[ObsoleteAttribute("Please use Accord.MachineLearning.ISupervisedLearning instead.")]
public interface Accord.Statistics.Models.Markov.Learning.ISupervisedLearning {
    public abstract virtual double Run(Array[] observations, Int32[][] paths);
}
[ObsoleteAttribute("Please use Accord.MachineLearning.IUnsupervisedLearning instead.")]
public interface Accord.Statistics.Models.Markov.Learning.IUnsupervisedLearning {
    public abstract virtual double Run(Array[] observations);
}
[ObsoleteAttribute("Please use Accord.MachineLearning.IUnsupervisedLearning instead.")]
public interface Accord.Statistics.Models.Markov.Learning.IUnsupervisedLearning`1 {
    public abstract virtual double Run(T[] observations);
}
[ObsoleteAttribute("Please use Accord.MachineLearning.IUnsupervisedLearning instead.")]
public interface Accord.Statistics.Models.Markov.Learning.IWeightedUnsupervisedLearning {
    public abstract virtual double Run(Array[] observations, Double[] weights);
}
public class Accord.Statistics.Models.Markov.Learning.MaximumLikelihoodLearning : BaseMaximumLikelihoodLearning`4<HiddenMarkovModel, GeneralDiscreteDistribution, int, GeneralDiscreteOptions> {
    public MaximumLikelihoodLearning(HiddenMarkovModel model);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Int32[][] observations, Int32[][] paths);
    private void run(Int32[][] observations, Int32[][] paths);
    private sealed virtual override double Accord.Statistics.Models.Markov.Learning.ISupervisedLearning.Run(Array[] observations, Int32[][] paths);
    protected virtual HiddenMarkovModel Create(Int32[][] x, int numberOfClasses);
}
[ObsoleteAttribute("Please use MaximumLikelihoodLearning<TDistribution, TObservation> instead.")]
public class Accord.Statistics.Models.Markov.Learning.MaximumLikelihoodLearning`1 : object {
    private HiddenMarkovModel`1<TDistribution> model;
    private bool useLaplaceRule;
    private bool useWeights;
    private Int32[] initial;
    private Int32[0...,0...] transitions;
    private IFittingOptions fittingOptions;
    public HiddenMarkovModel`1<TDistribution> Model { get; }
    public bool UseWeights { get; public set; }
    public bool UseLaplaceRule { get; public set; }
    public IFittingOptions FittingOptions { get; public set; }
    public MaximumLikelihoodLearning`1(HiddenMarkovModel`1<TDistribution> model);
    public HiddenMarkovModel`1<TDistribution> get_Model();
    public bool get_UseWeights();
    public void set_UseWeights(bool value);
    public bool get_UseLaplaceRule();
    public void set_UseLaplaceRule(bool value);
    public IFittingOptions get_FittingOptions();
    public void set_FittingOptions(IFittingOptions value);
    public double Run(Array[] observations, Int32[][] paths);
    private sealed virtual override double Accord.Statistics.Models.Markov.Learning.ISupervisedLearning.Run(Array[] observations, Int32[][] paths);
    private static Double[][] convert(Array array, int dimension);
}
public class Accord.Statistics.Models.Markov.Learning.MaximumLikelihoodLearning`2 : BaseMaximumLikelihoodLearning`4<HiddenMarkovModel`2<TDistribution, TObservation>, TDistribution, TObservation, IFittingOptions> {
    public MaximumLikelihoodLearning`2(HiddenMarkovModel`2<TDistribution, TObservation> model);
    protected virtual HiddenMarkovModel`2<TDistribution, TObservation> Create(TObservation[][] x, int numberOfClasses);
}
public class Accord.Statistics.Models.Markov.Learning.ViterbiLearning : BaseViterbiLearning`1<Int32[]> {
    private MaximumLikelihoodLearning mle;
    public HiddenMarkovModel Model { get; }
    public bool UseLaplaceRule { get; public set; }
    public ViterbiLearning(HiddenMarkovModel model);
    public HiddenMarkovModel get_Model();
    public bool get_UseLaplaceRule();
    public void set_UseLaplaceRule(bool value);
    public sealed virtual HiddenMarkovModel Learn(Int32[][] x, Double[] weights);
    protected virtual void RunEpoch(Int32[][] inputs, Int32[][] outputs);
    protected virtual double ComputeLogLikelihood(Int32[][] observations);
    private sealed virtual override double Accord.Statistics.Models.Markov.Learning.IUnsupervisedLearning.Run(Array[] observations);
}
[ObsoleteAttribute("Please use ViterbiLearning<TDistribution, TObservation> instead.")]
public class Accord.Statistics.Models.Markov.Learning.ViterbiLearning`1 : BaseViterbiLearning`1<Double[][]> {
    private MaximumLikelihoodLearning`1<TDistribution> mle;
    public HiddenMarkovModel`1<TDistribution> Model { get; }
    public IFittingOptions FittingOptions { get; public set; }
    public bool UseLaplaceRule { get; public set; }
    public ViterbiLearning`1(HiddenMarkovModel`1<TDistribution> model);
    public HiddenMarkovModel`1<TDistribution> get_Model();
    public IFittingOptions get_FittingOptions();
    public void set_FittingOptions(IFittingOptions value);
    public bool get_UseLaplaceRule();
    public void set_UseLaplaceRule(bool value);
    public sealed virtual double Run(Array[] observations);
    protected virtual void RunEpoch(Double[][][] inputs, Int32[][] outputs);
    protected virtual double ComputeLogLikelihood(Double[][][] observations);
    private static Double[][] convert(Array array, int dimension);
}
public class Accord.Statistics.Models.Markov.Learning.ViterbiLearning`2 : BaseViterbiLearning`1<TObservation[]> {
    private MaximumLikelihoodLearning`2<TDistribution, TObservation> mle;
    public HiddenMarkovModel`2<TDistribution, TObservation> Model { get; }
    public IFittingOptions FittingOptions { get; public set; }
    public bool UseLaplaceRule { get; public set; }
    public CancellationToken Token { get; public set; }
    public ViterbiLearning`2(HiddenMarkovModel`2<TDistribution, TObservation> model);
    public HiddenMarkovModel`2<TDistribution, TObservation> get_Model();
    public IFittingOptions get_FittingOptions();
    public void set_FittingOptions(IFittingOptions value);
    public bool get_UseLaplaceRule();
    public void set_UseLaplaceRule(bool value);
    public virtual CancellationToken get_Token();
    public virtual void set_Token(CancellationToken value);
    public sealed virtual HiddenMarkovModel`2<TDistribution, TObservation> Learn(TObservation[][] x, Double[] weights);
    protected virtual void RunEpoch(TObservation[][] inputs, Int32[][] outputs);
    protected virtual double ComputeLogLikelihood(TObservation[][] observations);
}
internal static class Accord.Statistics.Models.Markov.MarkovHelperMethods : object {
    internal static Double[][] convertNoCheck(Array array, int dimension);
    internal static Double[][] checkAndConvert(Array observations, int dimension);
    internal static void CheckObservationDimensions(TObservation[][] x, HiddenMarkovModel`2<TDistribution, TObservation> hmm);
    internal static void checkArgs(Int32[][] observations, int symbols);
    public static int GetObservationDimensions(T[][] x);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Markov.Topology.Custom : object {
    private int states;
    private Double[] pi;
    private Double[0...,0...] A;
    public int States { get; public set; }
    public Double[] Initial { get; }
    public Double[0...,0...] Transitions { get; }
    public Custom(Double[][] transitions, Double[] initial);
    public Custom(Double[][] transitions, Double[] initial, bool logarithm);
    public Custom(Double[0...,0...] transitions, Double[] initial);
    public Custom(Double[0...,0...] transitions, Double[] initial, bool logarithm);
    public sealed virtual int get_States();
    public sealed virtual void set_States(int value);
    public Double[] get_Initial();
    public Double[0...,0...] get_Transitions();
    public sealed virtual int Create(bool logarithm, Double[0...,0...]& transitionMatrix, Double[]& initialState);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Markov.Topology.Ergodic : object {
    private int states;
    private bool random;
    private Double[] pi;
    public int States { get; public set; }
    public bool Random { get; public set; }
    public Ergodic(int states);
    public Ergodic(int states, bool random);
    public sealed virtual int get_States();
    public sealed virtual void set_States(int value);
    public bool get_Random();
    public void set_Random(bool value);
    public sealed virtual int Create(bool logarithm, Double[0...,0...]& transitionMatrix, Double[]& initialState);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Markov.Topology.Forward : object {
    private int states;
    private int deepness;
    private bool random;
    private Double[] pi;
    public int States { get; public set; }
    public int Deepness { get; public set; }
    public bool Random { get; public set; }
    public Double[] Initial { get; }
    public Forward(int states);
    public Forward(int states, int deepness);
    public Forward(int states, bool random);
    public Forward(int states, int deepness, bool random);
    public sealed virtual int get_States();
    public sealed virtual void set_States(int value);
    public int get_Deepness();
    public void set_Deepness(int value);
    public bool get_Random();
    public void set_Random(bool value);
    public Double[] get_Initial();
    public sealed virtual int Create(bool logarithm, Double[0...,0...]& transitionMatrix, Double[]& initialState);
}
public interface Accord.Statistics.Models.Markov.Topology.ITopology {
    public int States { get; public set; }
    public abstract virtual int get_States();
    public abstract virtual void set_States(int value);
    public abstract virtual int Create(bool logarithm, Double[0...,0...]& transitionMatrix, Double[]& initialState);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Models.NamespaceDoc : object {
}
[ObsoleteAttribute("Please use ISupervisedLearning instead.")]
internal interface Accord.Statistics.Models.Regression.Fitting.IMultipleRegressionFitting {
    public abstract virtual double Run(Double[][] inputs, Double[][] outputs);
}
[ObsoleteAttribute("Please use ISupervisedLearning instead.")]
internal interface Accord.Statistics.Models.Regression.Fitting.IRegressionFitting {
    public abstract virtual double Run(Double[][] inputs, Double[] outputs);
}
[ObsoleteAttribute("Please use ISupervisedLearning instead.")]
internal interface Accord.Statistics.Models.Regression.Fitting.ISurvivalFitting {
    public abstract virtual double Run(Double[][] inputs, Double[] time, SurvivalOutcome[] censor);
    public abstract virtual double Run(Double[][] inputs, Double[] time, Int32[] censor);
}
public class Accord.Statistics.Models.Regression.Fitting.IterativeReweightedLeastSquares : IterativeReweightedLeastSquares`1<GeneralizedLinearRegression> {
    public IterativeReweightedLeastSquares(LogisticRegression regression);
    public IterativeReweightedLeastSquares(GeneralizedLinearRegression regression);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Double[][] inputs, Int32[] outputs);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Double[][] inputs, Int32[] outputs, Double[] weights);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Double[][] inputs, Int32[][] outputs);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Double[][] inputs, Int32[][] outputs, Double[] sampleWeight);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Double[][] inputs, Double[][] outputs);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual double Run(Double[][] inputs, Double[] outputs);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Double[][] inputs, Double[] outputs, Double[] sampleWeights);
    [ObsoleteAttribute("Please use the LogLikelihoodLoss class instead.")]
public double ComputeError(Double[][] inputs, Double[] outputs);
}
public class Accord.Statistics.Models.Regression.Fitting.IterativeReweightedLeastSquares`1 : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private TModel regression;
    private int parameterCount;
    private Double[][] hessian;
    private Double[] gradient;
    private Double[] previous;
    private Double[] deltas;
    private double lambda;
    private bool computeStandardErrors;
    private ISolverArrayDecomposition`1<double> decomposition;
    private RelativeConvergence convergence;
    public TModel Model { get; public set; }
    public Double[] Previous { get; }
    public Double[] Updates { get; }
    public Double[] Solution { get; }
    public Double[][] Hessian { get; }
    public Double[] Gradient { get; }
    public int Parameters { get; }
    public CancellationToken Token { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public double Tolerance { get; public set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public bool ComputeStandardErrors { get; public set; }
    public double Regularization { get; public set; }
    protected void Initialize(TModel regression);
    public TModel get_Model();
    public void set_Model(TModel value);
    public Double[] get_Previous();
    public Double[] get_Updates();
    public Double[] get_Solution();
    public Double[][] get_Hessian();
    public Double[] get_Gradient();
    public int get_Parameters();
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_CurrentIteration();
    public sealed virtual bool get_HasConverged();
    public bool get_ComputeStandardErrors();
    public void set_ComputeStandardErrors(bool value);
    public double get_Regularization();
    public void set_Regularization(double value);
    public sealed virtual TModel Learn(Double[][] x, Int32[] y, Double[] weights);
    public sealed virtual TModel Learn(Double[][] x, Boolean[] y, Double[] weights);
    public sealed virtual TModel Learn(Double[][] x, Double[] y, Double[] weights);
    public Double[][] GetInformationMatrix();
}
public class Accord.Statistics.Models.Regression.Fitting.LogisticGradientDescent : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private LogisticRegression regression;
    private int parameterCount;
    private bool stochastic;
    private RelativeParameterConvergence convergence;
    private double rate;
    private Double[] gradient;
    private Double[] previous;
    private Double[] deltas;
    public Double[] Previous { get; }
    public Double[] Solution { get; }
    public Double[] Gradient { get; }
    public int Parameters { get; }
    public bool Stochastic { get; public set; }
    public double LearningRate { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public double Tolerance { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public CancellationToken Token { get; public set; }
    public LogisticGradientDescent(LogisticRegression regression);
    public Double[] get_Previous();
    public Double[] get_Solution();
    public Double[] get_Gradient();
    public int get_Parameters();
    public bool get_Stochastic();
    public void set_Stochastic(bool value);
    public double get_LearningRate();
    public void set_LearningRate(double value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_CurrentIteration();
    public sealed virtual bool get_HasConverged();
    private void init(LogisticRegression regression);
    [ObsoleteAttribute("Please use the Learn(x, y) method instead.")]
public double Run(Double[][] inputs, Double[][] outputs);
    [ObsoleteAttribute("Please use the Learn(x, y) method instead.")]
public double Run(Double[] input, double output);
    [ObsoleteAttribute("Please use the Learn(x, y) method instead.")]
public sealed virtual double Run(Double[][] inputs, Double[] outputs);
    [ObsoleteAttribute("Please use the LogLikelihoodLoss class instead.")]
public double ComputeError(Double[][] inputs, Double[] outputs);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public sealed virtual LogisticRegression Learn(Double[][] x, Int32[] y, Double[] weights);
    public sealed virtual LogisticRegression Learn(Double[][] x, Boolean[] y, Double[] weights);
    public sealed virtual LogisticRegression Learn(Double[][] x, Double[] y, Double[] weights);
}
public class Accord.Statistics.Models.Regression.Fitting.LowerBoundNewtonRaphson : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private MultinomialLogisticRegression regression;
    private Double[] previous;
    private Double[] solution;
    private Double[] deltas;
    private Double[] errors;
    private Double[] output;
    private Double[0...,0...] weights;
    private Double[0...,0...] lowerBound;
    private Double[] gradient;
    private Double[0...,0...] xxt;
    private int K;
    private int M;
    private int parameterCount;
    private bool computeStandardErrors;
    private bool updateLowerBound;
    private ISolverMatrixDecomposition`1<double> decomposition;
    private IConvergence`1<double> convergence;
    public Double[] Previous { get; }
    public Double[] Solution { get; }
    public bool UpdateLowerBound { get; public set; }
    public Double[0...,0...] HessianLowerBound { get; }
    public Double[] Gradient { get; }
    public int Parameters { get; }
    public bool ComputeStandardErrors { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public double Tolerance { get; public set; }
    public int CurrentIteration { get; }
    public bool HasConverged { get; }
    public Double[] ParameterChange { get; }
    public double MaximumChange { get; }
    public CancellationToken Token { get; public set; }
    public LowerBoundNewtonRaphson(MultinomialLogisticRegression regression);
    public Double[] get_Previous();
    public Double[] get_Solution();
    public bool get_UpdateLowerBound();
    public void set_UpdateLowerBound(bool value);
    public Double[0...,0...] get_HessianLowerBound();
    public Double[] get_Gradient();
    public int get_Parameters();
    public bool get_ComputeStandardErrors();
    public void set_ComputeStandardErrors(bool value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_CurrentIteration();
    public sealed virtual bool get_HasConverged();
    public Double[] get_ParameterChange();
    public double get_MaximumChange();
    private void init(MultinomialLogisticRegression regression);
    [ObsoleteAttribute("Please use the Learn() method instead.")]
public double Run(Double[][] inputs, Int32[] classes);
    [ObsoleteAttribute("Please use the Learn() method instead.")]
public sealed virtual double Run(Double[][] inputs, Double[][] outputs);
    private void compute(Double[] x, Double[] responses);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Int32[] y, Double[] weights);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Int32[][] y, Double[] weights);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Double[][] y, Double[] weights);
}
public class Accord.Statistics.Models.Regression.Fitting.MultinomialLogisticLearning`1 : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private MultinomialLogisticRegression regression;
    private TMethod method;
    private Double[][] inputs;
    private Int32[] outputs;
    private Double[] gradient;
    private Double[] log_y_hat;
    private int miniBatchSize;
    private IntRange[] miniBatches;
    private int current;
    public CancellationToken Token { get; public set; }
    public TMethod Method { get; public set; }
    public int MiniBatchSize { get; public set; }
    public MultinomialLogisticLearning`1(MultinomialLogisticRegression regression);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public TMethod get_Method();
    public void set_Method(TMethod value);
    public int get_MiniBatchSize();
    public void set_MiniBatchSize(int value);
    private void init(MultinomialLogisticRegression regression);
    private void compute(Double[] w, Double[] x, Double[] log_responses);
    internal double crossEntropy(Double[] w);
    internal Double[] crossEntropyGradient(Double[] w);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Int32[][] y, Double[] weights);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Double[][] y, Double[] weights);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Boolean[][] y, Double[] weights);
    public sealed virtual MultinomialLogisticRegression Learn(Double[][] x, Int32[] y, Double[] weights);
}
public class Accord.Statistics.Models.Regression.Fitting.NonlinearLeastSquares : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private ILeastSquaresMethod solver;
    private NonlinearRegression regression;
    private bool computeStandardErrors;
    private int numberOfParameters;
    private RegressionFunction function;
    private RegressionGradientFunction gradient;
    [CompilerGeneratedAttribute]
private Double[] <StartValues>k__BackingField;
    public bool ComputeStandardErrors { get; public set; }
    public ILeastSquaresMethod Algorithm { get; public set; }
    public int NumberOfParameters { get; public set; }
    public RegressionFunction Function { get; public set; }
    public RegressionGradientFunction Gradient { get; public set; }
    public Double[] StartValues { get; public set; }
    public CancellationToken Token { get; public set; }
    public NonlinearLeastSquares(NonlinearRegression regression);
    public NonlinearLeastSquares(NonlinearRegression regression, ILeastSquaresMethod algorithm);
    public bool get_ComputeStandardErrors();
    public void set_ComputeStandardErrors(bool value);
    public ILeastSquaresMethod get_Algorithm();
    public void set_Algorithm(ILeastSquaresMethod value);
    public int get_NumberOfParameters();
    public void set_NumberOfParameters(int value);
    public RegressionFunction get_Function();
    public void set_Function(RegressionFunction value);
    public RegressionGradientFunction get_Gradient();
    public void set_Gradient(RegressionGradientFunction value);
    [CompilerGeneratedAttribute]
public Double[] get_StartValues();
    [CompilerGeneratedAttribute]
public void set_StartValues(Double[] value);
    [ObsoleteAttribute("Please use the Learn() method instead.")]
public sealed virtual double Run(Double[][] inputs, Double[] outputs);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public sealed virtual NonlinearRegression Learn(Double[][] x, Double[] y, Double[] weights);
}
public class Accord.Statistics.Models.Regression.Fitting.NonNegativeLeastSquares : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private MultipleLinearRegression regression;
    private List`1<int> p;
    private List`1<int> r;
    private Double[] s;
    private double tolerance;
    private Double[][] scatter;
    private Double[] vector;
    private Double[] W;
    private Double[][] X;
    private int cols;
    private int maxIter;
    public Double[] Coefficients { get; }
    public int MaxIterations { get; public set; }
    public double Tolerance { get; public set; }
    public CancellationToken Token { get; public set; }
    public NonNegativeLeastSquares(MultipleLinearRegression regression);
    public Double[] get_Coefficients();
    public int get_MaxIterations();
    public void set_MaxIterations(int value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    private void init(MultipleLinearRegression regression);
    [ObsoleteAttribute("Please use the Learn() method instead.")]
public sealed virtual double Run(Double[][] inputs, Double[] outputs);
    public sealed virtual MultipleLinearRegression Learn(Double[][] x, Double[] y, Double[] weights);
    private void InnerLoop(Double[] x);
    private void ComputeWeights(Double[] x);
    private void GetSP();
    private static Double[] GetElements(Double[] vector, List`1<int> elementsIndex);
}
public class Accord.Statistics.Models.Regression.Fitting.ProportionalHazardsNewtonRaphson : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private ProportionalHazards regression;
    private int parameterCount;
    private Double[0...,0...] hessian;
    private Double[] gradient;
    private Double[] partialGradient;
    private Double[0...,0...] partialHessian;
    private bool computeStandardErrors;
    private bool computeBaselineFunction;
    private bool normalize;
    private ISolverMatrixDecomposition`1<double> decomposition;
    private RelativeParameterConvergence convergence;
    [CompilerGeneratedAttribute]
private HazardEstimator <Estimator>k__BackingField;
    [CompilerGeneratedAttribute]
private HazardTiesMethod <Ties>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Lambda>k__BackingField;
    public double Tolerance { get; public set; }
    [ObsoleteAttribute("Please use MaxIterations instead.")]
public int Iterations { get; public set; }
    public int MaxIterations { get; public set; }
    public int CurrentIteration { get; public set; }
    public bool HasConverged { get; }
    public HazardEstimator Estimator { get; public set; }
    public HazardTiesMethod Ties { get; public set; }
    public Double[] Previous { get; }
    public Double[] Solution { get; }
    public Double[0...,0...] Hessian { get; }
    public Double[] Gradient { get; }
    public int Parameters { get; }
    public ProportionalHazards Model { get; public set; }
    public bool ComputeStandardErrors { get; public set; }
    public bool ComputeBaselineFunction { get; public set; }
    public bool Normalize { get; public set; }
    public CancellationToken Token { get; public set; }
    public double Lambda { get; public set; }
    public ProportionalHazardsNewtonRaphson(ProportionalHazards hazards);
    public sealed virtual double get_Tolerance();
    public sealed virtual void set_Tolerance(double value);
    public sealed virtual int get_Iterations();
    public sealed virtual void set_Iterations(int value);
    public sealed virtual int get_MaxIterations();
    public sealed virtual void set_MaxIterations(int value);
    public sealed virtual int get_CurrentIteration();
    public void set_CurrentIteration(int value);
    public sealed virtual bool get_HasConverged();
    [CompilerGeneratedAttribute]
public HazardEstimator get_Estimator();
    [CompilerGeneratedAttribute]
public void set_Estimator(HazardEstimator value);
    [CompilerGeneratedAttribute]
public HazardTiesMethod get_Ties();
    [CompilerGeneratedAttribute]
public void set_Ties(HazardTiesMethod value);
    public Double[] get_Previous();
    public Double[] get_Solution();
    public Double[0...,0...] get_Hessian();
    public Double[] get_Gradient();
    public int get_Parameters();
    public ProportionalHazards get_Model();
    public void set_Model(ProportionalHazards value);
    public bool get_ComputeStandardErrors();
    public void set_ComputeStandardErrors(bool value);
    public bool get_ComputeBaselineFunction();
    public void set_ComputeBaselineFunction(bool value);
    public bool get_Normalize();
    public void set_Normalize(bool value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    [CompilerGeneratedAttribute]
public double get_Lambda();
    [CompilerGeneratedAttribute]
public void set_Lambda(double value);
    private void init(ProportionalHazards hazards);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual double Run(Double[][] inputs, Double[] time);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual double Run(Double[][] inputs, Double[] time, Int32[] censor);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public sealed virtual double Run(Double[][] inputs, Double[] time, SurvivalOutcome[] censor);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Double[] time, Int32[] censor);
    [ObsoleteAttribute("Please use Learn(x, y) instead.")]
public double Run(Double[] time, SurvivalOutcome[] censor);
    private void createBaseline(Double[] time, SurvivalOutcome[] censor, Double[] output);
    public sealed virtual ProportionalHazards Learn(Tuple`2[] x, Boolean[] y, Double[] weights);
    public sealed virtual ProportionalHazards Learn(Tuple`2[] x, Int32[] y, Double[] weights);
    public ProportionalHazards Learn(Tuple`2[] x, SurvivalOutcome[] y, Double[] weights);
    public ProportionalHazards Learn(Double[][] inputs, Double[] time, Int32[] censor, Double[] weights);
    public ProportionalHazards Learn(Double[][] inputs, Double[] time, SurvivalOutcome[] censor, Double[] weights);
    private ProportionalHazards innerLearn(Double[][] inputs, Double[] time, SurvivalOutcome[] censor, Double[] weights);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.GeneralizedLinearRegression : BinaryLikelihoodClassifierBase`1<Double[]> {
    private MultipleLinearRegression linear;
    private ILinkFunction linkFunction;
    [ObsoleteAttribute]
private Double[] coefficients;
    private Double[] standardErrors;
    public int NumberOfInputs { get; public set; }
    [ObsoleteAttribute("Please use Weights and Intercept instead.")]
public Double[] Coefficients { get; }
    public int NumberOfParameters { get; }
    public Double[] Weights { get; public set; }
    public Double[] StandardErrors { get; public set; }
    [ObsoleteAttribute("Please use NumberOfInputs instead.")]
public int Inputs { get; }
    public ILinkFunction Link { get; protected set; }
    public MultipleLinearRegression Linear { get; protected set; }
    public double Intercept { get; public set; }
    public GeneralizedLinearRegression(ILinkFunction function);
    [ObsoleteAttribute("Please use the default constructor and set the NumberOfInputs property instead.")]
public GeneralizedLinearRegression(ILinkFunction function, int inputs);
    [ObsoleteAttribute("Please use the default constructor and set the NumberofInputs and Intercept properties instead.")]
public GeneralizedLinearRegression(ILinkFunction function, int inputs, double intercept);
    [ObsoleteAttribute("Please use the default constructor and set the Weights and StandardErrors properties instead.")]
public GeneralizedLinearRegression(ILinkFunction function, Double[] coefficients, Double[] standardErrors);
    public virtual int get_NumberOfInputs();
    public virtual void set_NumberOfInputs(int value);
    public Double[] get_Coefficients();
    public int get_NumberOfParameters();
    public Double[] get_Weights();
    public void set_Weights(Double[] value);
    public Double[] get_StandardErrors();
    public void set_StandardErrors(Double[] value);
    public int get_Inputs();
    public ILinkFunction get_Link();
    protected void set_Link(ILinkFunction value);
    public MultipleLinearRegression get_Linear();
    protected void set_Linear(MultipleLinearRegression value);
    public double get_Intercept();
    public void set_Intercept(double value);
    public double GetCoefficient(int index);
    public void SetCoefficient(int index, double value);
    [ObsoleteAttribute("Please use the Probability method instead.")]
public double Compute(Double[] input);
    [ObsoleteAttribute("Please use the Probability method instead.")]
public Double[] Compute(Double[][] input);
    public WaldTest GetWaldTest(int index);
    public double GetLogLikelihood(Double[][] input, Double[] output);
    public double GetLogLikelihood(Double[][] input, Double[] output, Double[] weights);
    public double GetDeviance(Double[][] input, Double[] output);
    public double GetDeviance(Double[][] input, Double[] output, Double[] weights);
    public double GetLogLikelihoodRatio(Double[][] input, Double[] output, GeneralizedLinearRegression regression);
    public double GetLogLikelihoodRatio(Double[][] input, Double[] output, Double[] weights, GeneralizedLinearRegression regression);
    public ChiSquareTest ChiSquare(Double[][] input, Double[] output);
    public ChiSquareTest ChiSquare(Double[][] input, Double[] output, Double[] weights);
    public double GetDegreesOfFreedom(int numberOfSamples);
    public Double[] GetStandardErrors(Double[][] informationMatrix);
    public double GetStandardError(Double[] input, Double[][] informationMatrix);
    public double GetPredictionStandardError(Double[] input, Double[][] informationMatrix);
    public DoubleRange GetConfidenceInterval(Double[] input, int numberOfSamples, Double[][] informationMatrix, double percent);
    public DoubleRange GetPredictionInterval(Double[] input, int numberOfSamples, Double[][] informationMatrix, double percent);
    private static double predictionVariance(Double[] input, Double[][] im);
    private DoubleRange computeInterval(Double[] input, int numberOfSamples, double percent, double se);
    public sealed virtual object Clone();
    [ObsoleteAttribute("Simply cast the logistic regression to a GeneralizedLinearRegression instead, using Clone() if necessary.")]
public static GeneralizedLinearRegression FromLogisticRegression(LogisticRegression regression, bool makeCopy);
    public virtual Double[] Score(Double[][] input, Double[] result);
    public virtual Double[] LogLikelihood(Double[][] input, Double[] result);
    public virtual Double[] Probability(Double[][] input, Double[] result);
    [OnDeserializedAttribute]
private void SetValuesOnDeserialized(StreamingContext context);
}
[ObsoleteAttribute("Please use ITransform instead.")]
public interface Accord.Statistics.Models.Regression.Linear.ILinearRegression {
    public abstract virtual Double[] Compute(Double[] inputs);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.Linear.MultipleLinearRegression : TransformBase`2<Double[], double> {
    private Double[] coefficients;
    [ObsoleteAttribute]
private bool addIntercept;
    private double intercept;
    [ObsoleteAttribute("Please use Weights instead.")]
public Double[] Coefficients { get; }
    public int NumberOfInputs { get; public set; }
    public Double[] Weights { get; public set; }
    public int NumberOfParameters { get; }
    [ObsoleteAttribute("Please use NumberOfInputs instead.")]
public int Inputs { get; }
    [ObsoleteAttribute("Please check the Intercept value instead.")]
public bool HasIntercept { get; }
    public double Intercept { get; public set; }
    [ObsoleteAttribute("Please use the default constructor and set NumberOfInputs instead.")]
public MultipleLinearRegression(int inputs);
    [ObsoleteAttribute("Please do not pass a boolean value as the intercept value.")]
public MultipleLinearRegression(int inputs, bool intercept);
    [ObsoleteAttribute("Please use the default constructor and set NumberOfInputs instead.")]
public MultipleLinearRegression(int inputs, double intercept);
    public Double[] get_Coefficients();
    public virtual int get_NumberOfInputs();
    public virtual void set_NumberOfInputs(int value);
    public Double[] get_Weights();
    public void set_Weights(Double[] value);
    public int get_NumberOfParameters();
    public int get_Inputs();
    public bool get_HasIntercept();
    public double get_Intercept();
    public void set_Intercept(double value);
    [ObsoleteAttribute("Please use the OrdinaryLeastSquares class instead.")]
public virtual double Regress(Double[][] inputs, Double[] outputs, bool robust);
    [ObsoleteAttribute("Please use the OrdinaryLeastSquares class instead.")]
public virtual double Regress(Double[][] inputs, Double[] outputs);
    [ObsoleteAttribute("Please use the OrdinaryLeastSquares class instead.")]
public double Regress(Double[][] inputs, Double[] outputs, Double[0...,0...]& informationMatrix, bool robust);
    [ObsoleteAttribute]
private double regress(Double[][] inputs, Double[] outputs, Double[0...,0...]& designMatrix, bool robust);
    public double CoefficientOfDetermination(Double[][] inputs, Double[] outputs, bool adjust, Double[] weights);
    public double GetStandardError(Double[][] inputs, Double[] outputs);
    public double GetDegreesOfFreedom(int numberOfSamples);
    public Double[] GetStandardErrors(double mse, Double[][] informationMatrix);
    public double GetStandardError(Double[] input, double mse, Double[][] informationMatrix);
    public double GetPredictionStandardError(Double[] input, double mse, Double[][] informationMatrix);
    public DoubleRange GetConfidenceInterval(Double[] input, double mse, int numberOfSamples, Double[][] informationMatrix, double percent);
    public DoubleRange GetPredictionInterval(Double[] input, double mse, int numberOfSamples, Double[][] informationMatrix, double percent);
    private static double predictionVariance(Double[] input, Double[][] im);
    private DoubleRange computeInterval(Double[] input, int numberOfSamples, double percent, double se);
    [ObsoleteAttribute("Please use Transform instead.")]
public double Compute(Double[] input);
    [ObsoleteAttribute("Please use Transform instead.")]
public Double[] Compute(Double[][] input);
    public virtual string ToString();
    public static MultipleLinearRegression FromData(Double[][] x, Double[] y);
    [ObsoleteAttribute("Please use the parameterless constructor and set Weights and Intercept directly.")]
public static MultipleLinearRegression FromCoefficients(Double[] coefficients, bool intercept);
    [ObsoleteAttribute("Please use Transform instead.")]
private sealed virtual override Double[] Accord.Statistics.Models.Regression.Linear.ILinearRegression.Compute(Double[] inputs);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual double Transform(Double[] input);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.Linear.MultivariateLinearRegression : MultipleTransformBase`2<Double[], double> {
    private Double[][] weights;
    private Double[0...,0...] coefficients;
    private Double[] intercepts;
    private bool insertConstant;
    [ObsoleteAttribute("Please use Weights instead.")]
public Double[0...,0...] Coefficients { get; }
    public Double[][] Weights { get; public set; }
    public Double[] Intercepts { get; public set; }
    public int NumberOfParameters { get; }
    [ObsoleteAttribute("Please use NumberOfInputs instead.")]
public int Inputs { get; }
    [ObsoleteAttribute("Please use NumberOfOutputs instead.")]
public int Outputs { get; }
    [ObsoleteAttribute("Please use the parameterless constructor instead.")]
public MultivariateLinearRegression(int inputs, int outputs);
    [ObsoleteAttribute("Please use the parameterless constructor instead.")]
public MultivariateLinearRegression(int inputs, int outputs, bool intercept);
    [ObsoleteAttribute("Please use the parameterless constructor instead.")]
public MultivariateLinearRegression(Double[0...,0...] coefficients, Double[] intercepts, bool insertConstant);
    [ObsoleteAttribute("Please use the parameterless constructor instead.")]
public MultivariateLinearRegression(Double[][] coefficients, Double[] intercepts, bool insertConstant);
    public Double[0...,0...] get_Coefficients();
    public Double[][] get_Weights();
    public void set_Weights(Double[][] value);
    public Double[] get_Intercepts();
    public void set_Intercepts(Double[] value);
    public int get_NumberOfParameters();
    public int get_Inputs();
    public int get_Outputs();
    [ObsoleteAttribute("Please use the LeastSquares class instead.")]
public virtual double Regress(Double[][] inputs, Double[][] outputs);
    public Double[] CoefficientOfDetermination(Double[][] inputs, Double[][] outputs, Double[] weights);
    public Double[] CoefficientOfDetermination(Double[][] inputs, Double[][] outputs, bool adjust, Double[] weights);
    [ObsoleteAttribute("Please use Transform() instead.")]
public Double[] Compute(Double[] input);
    [ObsoleteAttribute("Please use Transform() instead.")]
public Double[][] Compute(Double[][] input);
    public static MultivariateLinearRegression FromData(Double[][] x, Double[][] y);
    [ObsoleteAttribute("Please use the parameterless constructor and set Weights and Intercept directly.")]
public static MultivariateLinearRegression FromCoefficients(Double[][] coefficients, Double[] intercept);
    public MultivariateLinearRegression Inverse();
    [ObsoleteAttribute("Please use Transform instead.")]
private sealed virtual override Double[] Accord.Statistics.Models.Regression.Linear.ILinearRegression.Compute(Double[] inputs);
    public virtual Double[][] Transform(Double[][] input, Double[][] result);
    public Double[] GetStandardError(Double[][] inputs, Double[][] outputs);
    public double GetDegreesOfFreedom(int numberOfSamples);
    public Double[][] GetStandardErrors(Double[] mse, Double[][] informationMatrix);
    public Double[] GetStandardError(Double[] input, Double[] mse, Double[][] informationMatrix);
    public Double[] GetPredictionStandardError(Double[] input, Double[] mse, Double[][] informationMatrix);
    public DoubleRange[] GetConfidenceInterval(Double[] input, Double[] mse, int numberOfSamples, Double[][] informationMatrix, double percent);
    public DoubleRange[] GetPredictionInterval(Double[] input, Double[] mse, int numberOfSamples, Double[][] informationMatrix, double percent);
    private static double predictionVariance(Double[] input, Double[][] im);
    private DoubleRange[] createInterval(Double[] input, int numberOfSamples, double percent, Double[] se);
}
public class Accord.Statistics.Models.Regression.Linear.OrdinaryLeastSquares : object {
    [NonSerializedAttribute]
private CancellationToken token;
    private ISolverArrayDecomposition`1<double> decomposition;
    [CompilerGeneratedAttribute]
private bool <UseIntercept>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRobust>k__BackingField;
    public bool UseIntercept { get; public set; }
    public bool IsRobust { get; public set; }
    public CancellationToken Token { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UseIntercept();
    [CompilerGeneratedAttribute]
public void set_UseIntercept(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRobust();
    [CompilerGeneratedAttribute]
public void set_IsRobust(bool value);
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    public sealed virtual SimpleLinearRegression Learn(Double[] x, Double[] y, Double[] weights);
    public sealed virtual MultipleLinearRegression Learn(Double[][] x, Double[] y, Double[] weights);
    public sealed virtual MultivariateLinearRegression Learn(Double[][] x, Double[][] y, Double[] weights);
    public Double[][] GetInformationMatrix();
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.Linear.PolynomialLeastSquares : object {
    private int degree;
    [NonSerializedAttribute]
private CancellationToken token;
    [CompilerGeneratedAttribute]
private bool <IsRobust>k__BackingField;
    public CancellationToken Token { get; public set; }
    public bool IsRobust { get; public set; }
    public int Degree { get; public set; }
    public sealed virtual CancellationToken get_Token();
    public sealed virtual void set_Token(CancellationToken value);
    [CompilerGeneratedAttribute]
public bool get_IsRobust();
    [CompilerGeneratedAttribute]
public void set_IsRobust(bool value);
    public int get_Degree();
    public void set_Degree(int value);
    public sealed virtual PolynomialRegression Learn(Double[] x, Double[] y, Double[] weights);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.Linear.PolynomialRegression : TransformBase`2<double, double> {
    private MultipleLinearRegression regression;
    public int Degree { get; }
    [ObsoleteAttribute("Please use Weights instead.")]
public Double[] Coefficients { get; }
    public Double[] Weights { get; public set; }
    public double Intercept { get; public set; }
    public PolynomialRegression(int degree);
    public PolynomialRegression(MultipleLinearRegression regression);
    public int get_Degree();
    public Double[] get_Coefficients();
    public Double[] get_Weights();
    public void set_Weights(Double[] value);
    public double get_Intercept();
    public void set_Intercept(double value);
    [ObsoleteAttribute("Please use the OrdinaryLeastSquares class instead.")]
public double Regress(Double[] inputs, Double[] outputs);
    [ObsoleteAttribute("Please use Transform instead.")]
public Double[] Compute(Double[] input);
    [ObsoleteAttribute("Please use Transform instead.")]
public double Compute(double input);
    public double CoefficientOfDetermination(Double[] inputs, Double[] outputs, Double[] weights);
    public double CoefficientOfDetermination(Double[] inputs, Double[] outputs, bool adjust, Double[] weights);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static PolynomialRegression FromData(int degree, Double[] x, Double[] y);
    [ObsoleteAttribute("Please use Transform instead.")]
private sealed virtual override Double[] Accord.Statistics.Models.Regression.Linear.ILinearRegression.Compute(Double[] inputs);
    public virtual double Transform(double input);
    public virtual Double[] Transform(Double[] input, Double[] result);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.Linear.SimpleLinearRegression : TransformBase`2<double, double> {
    [ObsoleteAttribute]
private MultipleLinearRegression regression;
    private double slope;
    private double intercept;
    public double Slope { get; public set; }
    public double Intercept { get; public set; }
    public int NumberOfParameters { get; }
    public double get_Slope();
    public void set_Slope(double value);
    public double get_Intercept();
    public void set_Intercept(double value);
    public int get_NumberOfParameters();
    [ObsoleteAttribute("Please use the OrdinaryLeastSquares class.")]
public double Regress(Double[] inputs, Double[] outputs);
    [ObsoleteAttribute("Please use Transform instead.")]
public Double[] Compute(Double[] input);
    [ObsoleteAttribute("Please use Transform instead.")]
public double Compute(double input);
    public double CoefficientOfDetermination(Double[] inputs, Double[] outputs, bool adjust, Double[] weights);
    public double CoefficientOfDetermination(Double[] inputs, Double[] outputs, Double[] weights);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format, IFormatProvider formatProvider);
    public static SimpleLinearRegression FromData(Double[] x, Double[] y);
    [ObsoleteAttribute("Please use Transform instead.")]
private sealed virtual override Double[] Accord.Statistics.Models.Regression.Linear.ILinearRegression.Compute(Double[] inputs);
    public virtual double Transform(double input);
    public double GetDegreesOfFreedom(int numberOfSamples);
    public double GetStandardError(Double[] inputs, Double[] outputs);
    public double GetStandardError(double input, Double[] inputs, Double[] outputs);
    public double GetPredictionStandardError(double input, Double[] inputs, Double[] outputs);
    public DoubleRange GetConfidenceInterval(double input, Double[] inputs, Double[] outputs, double percent);
    public DoubleRange GetPredictionInterval(double input, Double[] inputs, Double[] outputs, double percent);
    private DoubleRange createInterval(double input, Double[] inputs, double percent, double se);
    private static double predictionVariance(double input, Double[] inputs, Double[] outputs);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.LogisticRegression : GeneralizedLinearRegression {
    [ObsoleteAttribute("Please use the default constructor and set NumberOfInputs instead.")]
public LogisticRegression(int inputs);
    [ObsoleteAttribute("Please use the default constructor and set NumberOfInputs instead.")]
public LogisticRegression(int inputs, double intercept);
    public DoubleRange GetConfidenceInterval(int index);
    public double GetOddsRatio(int index);
    public static LogisticRegression FromWeights(Double[] weights);
    public static LogisticRegression FromWeights(Double[] weights, double intercept);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.MultinomialLogisticRegression : MulticlassLikelihoodClassifierBase`1<Double[]> {
    [ObsoleteAttribute]
private int inputs;
    [ObsoleteAttribute]
private int categories;
    private Double[][] coefficients;
    private Double[][] standardErrors;
    public Double[][] Coefficients { get; public set; }
    public int NumberOfParameters { get; }
    public Double[][] StandardErrors { get; }
    [ObsoleteAttribute("Please use NumberOfOutputs instead.")]
public int Categories { get; }
    [ObsoleteAttribute("Please use NumberOfInputs instead.")]
public int Inputs { get; }
    public MultinomialLogisticRegression(int inputs, int categories);
    public MultinomialLogisticRegression(int inputs, int categories, Double[] intercepts);
    public Double[][] get_Coefficients();
    public void set_Coefficients(Double[][] value);
    public int get_NumberOfParameters();
    public Double[][] get_StandardErrors();
    public int get_Categories();
    public int get_Inputs();
    [ObsoleteAttribute("Please use Probabilities() instead.")]
public Double[] Compute(Double[] input);
    [ObsoleteAttribute("Please use Probabilities() instead.")]
public Double[][] Compute(Double[][] input);
    public virtual double LogLikelihood(Double[] input, int classIndex);
    public virtual Double[] LogLikelihoods(Double[] input, Int32& decision, Double[] result);
    public ChiSquareTest ChiSquare(Double[][] input, Double[][] output);
    public ChiSquareTest ChiSquare(Double[][] input, Int32[] classes);
    public DoubleRange GetConfidenceInterval(int category, int coefficient);
    public DoubleRange[] GetConfidenceInterval(int category);
    public double GetOddsRatio(int category, int coefficient);
    public Double[] GetOddsRatio(int category);
    public WaldTest GetWaldTest(int category, int coefficient);
    public WaldTest[] GetWaldTest(int category);
    public double GetDeviance(Double[][] input, Double[][] output);
    public double GetDeviance(Double[][] inputs, Int32[] classes);
    public double GetLogLikelihood(Double[][] inputs, Int32[] classes);
    public double GetLogLikelihood(Double[][] input, Double[][] output);
    public double GetLogLikelihoodRatio(Double[][] input, Double[][] output, MultinomialLogisticRegression regression);
    [OnDeserializedAttribute]
private void onDeserialized(StreamingContext context);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.MultivariateKernelRegression : MultivariateKernelRegression`1<IKernel> {
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.MultivariateKernelRegression`1 : MultipleTransformBase`2<Double[], double> {
    [CompilerGeneratedAttribute]
private TKernel <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[][] <BasisVectors>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[][] <Weights>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Intercept>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Means>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <StandardDeviations>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <FeatureMeans>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FeatureGrandMean>k__BackingField;
    public TKernel Kernel { get; public set; }
    public Double[][] BasisVectors { get; public set; }
    public Double[][] Weights { get; public set; }
    [ObsoleteAttribute]
public Double[] Intercept { get; public set; }
    public Double[] Means { get; public set; }
    public Double[] StandardDeviations { get; public set; }
    public Double[] FeatureMeans { get; public set; }
    public double FeatureGrandMean { get; public set; }
    [CompilerGeneratedAttribute]
public TKernel get_Kernel();
    [CompilerGeneratedAttribute]
public void set_Kernel(TKernel value);
    [CompilerGeneratedAttribute]
public Double[][] get_BasisVectors();
    [CompilerGeneratedAttribute]
public void set_BasisVectors(Double[][] value);
    [CompilerGeneratedAttribute]
public Double[][] get_Weights();
    [CompilerGeneratedAttribute]
public void set_Weights(Double[][] value);
    [CompilerGeneratedAttribute]
public Double[] get_Intercept();
    [CompilerGeneratedAttribute]
public void set_Intercept(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Means();
    [CompilerGeneratedAttribute]
public void set_Means(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_StandardDeviations();
    [CompilerGeneratedAttribute]
public void set_StandardDeviations(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_FeatureMeans();
    [CompilerGeneratedAttribute]
public void set_FeatureMeans(Double[] value);
    [CompilerGeneratedAttribute]
public double get_FeatureGrandMean();
    [CompilerGeneratedAttribute]
public void set_FeatureGrandMean(double value);
    public virtual Double[][] Transform(Double[][] input, Double[][] result);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.NonlinearRegression : TransformBase`2<Double[], double> {
    private Double[] coefficients;
    private Double[] standardErrors;
    private RegressionFunction function;
    private RegressionGradientFunction gradient;
    public Double[] Coefficients { get; }
    public Double[] StandardErrors { get; }
    public RegressionFunction Function { get; }
    public RegressionGradientFunction Gradient { get; public set; }
    public NonlinearRegression(int parameters, RegressionFunction function);
    public NonlinearRegression(int parameters, RegressionFunction function, RegressionGradientFunction gradient);
    public Double[] get_Coefficients();
    public Double[] get_StandardErrors();
    public RegressionFunction get_Function();
    public RegressionGradientFunction get_Gradient();
    public void set_Gradient(RegressionGradientFunction value);
    [ObsoleteAttribute("Please use Transform instead.")]
public double Compute(Double[] inputs);
    public sealed virtual object Clone();
    public virtual double Transform(Double[] input);
}
[SerializableAttribute]
public class Accord.Statistics.Models.Regression.ProportionalHazards : BinaryLikelihoodClassifierBase`1<Tuple`2<Double[], double>> {
    [CompilerGeneratedAttribute]
private Double[] <Offsets>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Intercept>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Coefficients>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <StandardErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private IUnivariateDistribution <BaselineHazard>k__BackingField;
    [ObsoleteAttribute("Please use Intercept instead.")]
public Double[] Offsets { get; private set; }
    public double Intercept { get; public set; }
    public Double[] Coefficients { get; private set; }
    public Double[] StandardErrors { get; private set; }
    public IUnivariateDistribution BaselineHazard { get; private set; }
    [ObsoleteAttribute("Please use NumberOfInputs instead.")]
public int Inputs { get; }
    public ProportionalHazards(int inputs);
    public ProportionalHazards(int inputs, IUnivariateDistribution baseline);
    [CompilerGeneratedAttribute]
public Double[] get_Offsets();
    [CompilerGeneratedAttribute]
private void set_Offsets(Double[] value);
    [CompilerGeneratedAttribute]
public double get_Intercept();
    [CompilerGeneratedAttribute]
public void set_Intercept(double value);
    [CompilerGeneratedAttribute]
public Double[] get_Coefficients();
    [CompilerGeneratedAttribute]
private void set_Coefficients(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_StandardErrors();
    [CompilerGeneratedAttribute]
private void set_StandardErrors(Double[] value);
    [CompilerGeneratedAttribute]
public IUnivariateDistribution get_BaselineHazard();
    [CompilerGeneratedAttribute]
private void set_BaselineHazard(IUnivariateDistribution value);
    public int get_Inputs();
    [ObsoleteAttribute("Please use the Probability(input) method instead.")]
public double Compute(Double[] input);
    [ObsoleteAttribute("Please use the Probability(input) method instead.")]
public Double[] Compute(Double[][] input);
    [ObsoleteAttribute("Please use the Probability(input) method instead.")]
public double Compute(Double[] input, double time);
    [ObsoleteAttribute("Please use the Probability(input) method instead.")]
public double Compute(double time);
    public double Survival(double time);
    [ObsoleteAttribute("Please use Probability() instead.")]
public Double[] Compute(Double[][] input, Double[] time);
    public double GetLogHazardRatio(Double[] x, Double[] y);
    public double GetDeviance(Double[][] inputs, Double[] time, SurvivalOutcome[] output);
    public double GetPartialLogLikelihood(Double[][] inputs, Double[] time, Int32[] output);
    public double GetPartialLogLikelihood(Double[][] inputs, Double[] time, SurvivalOutcome[] output);
    public double GetPartialLogLikelihood(Double[] time, Int32[] output);
    public double GetPartialLogLikelihood(Double[] time, SurvivalOutcome[] output);
    public DoubleRange GetConfidenceInterval(int index);
    public WaldTest GetWaldTest(int index);
    public double GetLogLikelihoodRatio(Double[][] input, Double[] time, SurvivalOutcome[] output, ProportionalHazards hazards);
    public ChiSquareTest ChiSquare(Double[][] input, Double[] time, Int32[] output);
    public ChiSquareTest ChiSquare(Double[][] input, Double[] time, SurvivalOutcome[] output);
    public object Clone();
    public double GetHazardRatio(int index);
    public virtual Double[] LogLikelihood(Tuple`2[] input, Double[] result);
    public SurvivalOutcome Decide(Double[] input, double time);
    public SurvivalOutcome[] Decide(Double[][] input, Double[] time);
    public double Score(Double[] input, double time);
    public Double[] Score(Double[][] input, Double[] time);
    public double Probability(Double[] input, double time);
    public Double[] Probability(Double[][] input, Double[] time);
    public double LogLikelihood(Double[] input, double time);
    public Double[] LogLikelihood(Double[][] input, Double[] time);
    public SurvivalOutcome Decide(Double[] input);
    public SurvivalOutcome[] Decide(Double[][] input);
    public double Score(Double[] input);
    public Double[] Score(Double[][] input);
    public double Probability(Double[] input);
    public Double[] Probability(Double[][] input);
    public double LogLikelihood(Double[] input);
    public Double[] LogLikelihood(Double[][] input);
    public double Probability(double time);
    public double LogLikelihood(double time);
}
public class Accord.Statistics.Models.Regression.RegressionFunction : MulticastDelegate {
    public RegressionFunction(object object, IntPtr method);
    public virtual double Invoke(Double[] coefficients, Double[] input);
    public virtual IAsyncResult BeginInvoke(Double[] coefficients, Double[] input, AsyncCallback callback, object object);
    public virtual double EndInvoke(IAsyncResult result);
}
public class Accord.Statistics.Models.Regression.RegressionGradientFunction : MulticastDelegate {
    public RegressionGradientFunction(object object, IntPtr method);
    public virtual void Invoke(Double[] coefficients, Double[] input, Double[] result);
    public virtual IAsyncResult BeginInvoke(Double[] coefficients, Double[] input, Double[] result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface Accord.Statistics.Moving.IMoving`1 {
    public int Window { get; }
    public int Count { get; }
    public abstract virtual int get_Window();
    public abstract virtual int get_Count();
}
public interface Accord.Statistics.Moving.IMovingStatistics {
}
[SerializableAttribute]
public class Accord.Statistics.Moving.MovingCircularStatistics : object {
    private Queue`1<double> sines;
    private Queue`1<double> cosines;
    [CompilerGeneratedAttribute]
private double <SumOfSines>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SumOfCosines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Window>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Rho>k__BackingField;
    public double SumOfSines { get; private set; }
    public double SumOfCosines { get; private set; }
    public int Window { get; private set; }
    public int Count { get; }
    public double Mean { get; private set; }
    public double Variance { get; private set; }
    public double StandardDeviation { get; private set; }
    public double Rho { get; private set; }
    public MovingCircularStatistics(int windowSize);
    [CompilerGeneratedAttribute]
public double get_SumOfSines();
    [CompilerGeneratedAttribute]
private void set_SumOfSines(double value);
    [CompilerGeneratedAttribute]
public double get_SumOfCosines();
    [CompilerGeneratedAttribute]
private void set_SumOfCosines(double value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Window();
    [CompilerGeneratedAttribute]
private void set_Window(int value);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Mean();
    [CompilerGeneratedAttribute]
private void set_Mean(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Variance();
    [CompilerGeneratedAttribute]
private void set_Variance(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_StandardDeviation();
    [CompilerGeneratedAttribute]
private void set_StandardDeviation(double value);
    [CompilerGeneratedAttribute]
public double get_Rho();
    [CompilerGeneratedAttribute]
private void set_Rho(double value);
    public sealed virtual void Push(double value);
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Moving.MovingNormalStatistics : object {
    private Queue`1<double> values;
    private Queue`1<double> squares;
    [CompilerGeneratedAttribute]
private double <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SumOfSquares>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Window>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance>k__BackingField;
    public double Sum { get; private set; }
    public double SumOfSquares { get; private set; }
    public int Window { get; private set; }
    public int Count { get; }
    public double Mean { get; private set; }
    public double Variance { get; private set; }
    public double StandardDeviation { get; }
    public MovingNormalStatistics(int windowSize);
    [CompilerGeneratedAttribute]
public double get_Sum();
    [CompilerGeneratedAttribute]
private void set_Sum(double value);
    [CompilerGeneratedAttribute]
public double get_SumOfSquares();
    [CompilerGeneratedAttribute]
private void set_SumOfSquares(double value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Window();
    [CompilerGeneratedAttribute]
private void set_Window(int value);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Mean();
    [CompilerGeneratedAttribute]
private void set_Mean(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Variance();
    [CompilerGeneratedAttribute]
private void set_Variance(double value);
    public sealed virtual double get_StandardDeviation();
    public sealed virtual void Push(double value);
    public sealed virtual IEnumerator`1<double> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Moving.MovingRangeStatistics : object {
    private Queue`1<double> values;
    [CompilerGeneratedAttribute]
private int <Window>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    public int Window { get; private set; }
    public int Count { get; }
    public double Min { get; private set; }
    public double Max { get; private set; }
    public MovingRangeStatistics(int windowSize);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Window();
    [CompilerGeneratedAttribute]
private void set_Window(int value);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(double value);
    public sealed virtual void Push(double value);
    public sealed virtual IEnumerator`1<double> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Clear();
}
[SerializableAttribute]
internal class Accord.Statistics.Running.BaseRunningMarkovStatistics : object {
    private bool started;
    private Double[] current;
    private Nullable`1<int> currentState;
    private Nullable`1<double> logViterbi;
    private Nullable`1<double> logForward;
    public bool Started { get; public set; }
    public Double[] Current { get; }
    public int CurrentState { get; }
    public double LogViterbi { get; }
    public double LogForward { get; }
    public BaseRunningMarkovStatistics(IHiddenMarkovModel model);
    public bool get_Started();
    public void set_Started(bool value);
    public Double[] get_Current();
    public int get_CurrentState();
    public double get_LogViterbi();
    public double get_LogForward();
    public void Clear();
    public void Invalidate();
}
public interface Accord.Statistics.Running.IRunning`1 {
    public abstract virtual void Push(TValue value);
    public abstract virtual void Clear();
}
public interface Accord.Statistics.Running.IRunningMarkovStatistics {
    public bool Started { get; public set; }
    public Double[] Current { get; }
    public int CurrentState { get; }
    public double LogViterbi { get; }
    public double LogForward { get; }
    public abstract virtual bool get_Started();
    public abstract virtual void set_Started(bool value);
    public abstract virtual Double[] get_Current();
    public abstract virtual int get_CurrentState();
    public abstract virtual double get_LogViterbi();
    public abstract virtual double get_LogForward();
    public abstract virtual void Clear();
}
public interface Accord.Statistics.Running.IRunningStatistics {
    public double Mean { get; }
    public double Variance { get; }
    public double StandardDeviation { get; }
    public abstract virtual double get_Mean();
    public abstract virtual double get_Variance();
    public abstract virtual double get_StandardDeviation();
}
[SerializableAttribute]
public class Accord.Statistics.Running.KalmanFilter2D : object {
    private double samplingRate;
    private double acceleration;
    private double accelStdDev;
    private Double[0...,0...] Q_estimate;
    private Double[0...,0...] A;
    private Double[0...,0...] B;
    private Double[0...,0...] C;
    private Double[0...,0...] Ez;
    private Double[0...,0...] Ex;
    private Double[0...,0...] P;
    private Double[0...,0...] K;
    private Double[0...,0...] Aux;
    private static Double[0...,0...] diagonal;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double XAxisVelocity { get; public set; }
    public double YAxisVelocity { get; public set; }
    public double NoiseX { get; public set; }
    public double NoiseY { get; public set; }
    public KalmanFilter2D(double samplingRate, double acceleration, double accelerationStdDev);
    private static KalmanFilter2D();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_XAxisVelocity();
    public void set_XAxisVelocity(double value);
    public double get_YAxisVelocity();
    public void set_YAxisVelocity(double value);
    public double get_NoiseX();
    public void set_NoiseX(double value);
    public double get_NoiseY();
    public void set_NoiseY(double value);
    private void initialize();
    public sealed virtual void Push(Double[] value);
    public sealed virtual void Push(DoublePoint value);
    public void Push(double x, double y);
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Running.RunningCircularStatistics : object {
    private int count;
    [CompilerGeneratedAttribute]
private double <SumOfSines>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SumOfCosines>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Rho>k__BackingField;
    public double SumOfSines { get; private set; }
    public double SumOfCosines { get; private set; }
    public double Mean { get; private set; }
    public double Variance { get; private set; }
    public double StandardDeviation { get; private set; }
    public double Rho { get; private set; }
    public int Count { get; }
    [CompilerGeneratedAttribute]
public double get_SumOfSines();
    [CompilerGeneratedAttribute]
private void set_SumOfSines(double value);
    [CompilerGeneratedAttribute]
public double get_SumOfCosines();
    [CompilerGeneratedAttribute]
private void set_SumOfCosines(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Mean();
    [CompilerGeneratedAttribute]
private void set_Mean(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Variance();
    [CompilerGeneratedAttribute]
private void set_Variance(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_StandardDeviation();
    [CompilerGeneratedAttribute]
private void set_StandardDeviation(double value);
    [CompilerGeneratedAttribute]
public double get_Rho();
    [CompilerGeneratedAttribute]
private void set_Rho(double value);
    public int get_Count();
    public sealed virtual void Push(double value);
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Running.RunningMarkovClassifier : object {
    private RunningMarkovStatistics[] models;
    private RunningMarkovStatistics threshold;
    [CompilerGeneratedAttribute]
private HiddenMarkovClassifier <Classifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Responses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Classification>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Threshold>k__BackingField;
    public HiddenMarkovClassifier Classifier { get; private set; }
    public Double[] Responses { get; private set; }
    public int Classification { get; private set; }
    public double Threshold { get; private set; }
    public RunningMarkovClassifier(HiddenMarkovClassifier model);
    [CompilerGeneratedAttribute]
public HiddenMarkovClassifier get_Classifier();
    [CompilerGeneratedAttribute]
private void set_Classifier(HiddenMarkovClassifier value);
    [CompilerGeneratedAttribute]
public Double[] get_Responses();
    [CompilerGeneratedAttribute]
private void set_Responses(Double[] value);
    [CompilerGeneratedAttribute]
public int get_Classification();
    [CompilerGeneratedAttribute]
private void set_Classification(int value);
    [CompilerGeneratedAttribute]
public double get_Threshold();
    [CompilerGeneratedAttribute]
private void set_Threshold(double value);
    public sealed virtual void Push(int value);
    public int Peek(int value, Double& logLikelihood);
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Running.RunningMarkovClassifier`1 : object {
    private RunningMarkovStatistics`1[] models;
    private RunningMarkovStatistics`1<TDistribution> threshold;
    [CompilerGeneratedAttribute]
private HiddenMarkovClassifier`1<TDistribution> <Classifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Responses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Classification>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Threshold>k__BackingField;
    public HiddenMarkovClassifier`1<TDistribution> Classifier { get; private set; }
    public Double[] Responses { get; private set; }
    public int Classification { get; private set; }
    public double Threshold { get; private set; }
    public RunningMarkovClassifier`1(HiddenMarkovClassifier`1<TDistribution> model);
    [CompilerGeneratedAttribute]
public HiddenMarkovClassifier`1<TDistribution> get_Classifier();
    [CompilerGeneratedAttribute]
private void set_Classifier(HiddenMarkovClassifier`1<TDistribution> value);
    [CompilerGeneratedAttribute]
public Double[] get_Responses();
    [CompilerGeneratedAttribute]
private void set_Responses(Double[] value);
    [CompilerGeneratedAttribute]
public int get_Classification();
    [CompilerGeneratedAttribute]
private void set_Classification(int value);
    [CompilerGeneratedAttribute]
public double get_Threshold();
    [CompilerGeneratedAttribute]
private void set_Threshold(double value);
    public void Push(double value);
    public sealed virtual void Push(Double[] value);
    public int Peek(double value, Double& logLikelihood);
    public int Peek(Double[] value, Double& logLikelihood);
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Running.RunningMarkovStatistics : object {
    private BaseRunningMarkovStatistics _base;
    private Double[] previous;
    private Double[] next;
    [CompilerGeneratedAttribute]
private HiddenMarkovModel <Model>k__BackingField;
    public HiddenMarkovModel Model { get; private set; }
    public bool Started { get; public set; }
    public Double[] Current { get; }
    public int CurrentState { get; }
    public double LogViterbi { get; }
    public double LogForward { get; }
    public RunningMarkovStatistics(HiddenMarkovModel model);
    [CompilerGeneratedAttribute]
public HiddenMarkovModel get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(HiddenMarkovModel value);
    public sealed virtual void Push(int value);
    public double Peek(int value);
    public sealed virtual bool get_Started();
    public sealed virtual void set_Started(bool value);
    public sealed virtual Double[] get_Current();
    public sealed virtual int get_CurrentState();
    public sealed virtual double get_LogViterbi();
    public sealed virtual double get_LogForward();
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Running.RunningMarkovStatistics`1 : object {
    private BaseRunningMarkovStatistics _base;
    private Double[] previous;
    private Double[] next;
    [CompilerGeneratedAttribute]
private HiddenMarkovModel`1<TDistribution> <Model>k__BackingField;
    public HiddenMarkovModel`1<TDistribution> Model { get; private set; }
    public bool Started { get; public set; }
    public Double[] Current { get; }
    public int CurrentState { get; }
    public double LogViterbi { get; }
    public double LogForward { get; }
    public RunningMarkovStatistics`1(HiddenMarkovModel`1<TDistribution> model);
    [CompilerGeneratedAttribute]
public HiddenMarkovModel`1<TDistribution> get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(HiddenMarkovModel`1<TDistribution> value);
    public sealed virtual void Push(Double[] value);
    public double Peek(Double[] value);
    public sealed virtual bool get_Started();
    public sealed virtual void set_Started(bool value);
    public sealed virtual Double[] get_Current();
    public sealed virtual int get_CurrentState();
    public sealed virtual double get_LogViterbi();
    public sealed virtual double get_LogForward();
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Running.RunningNormalStatistics : object {
    private int count;
    private double mean;
    private double sigma;
    private double lastMean;
    private double lastSigma;
    public double Mean { get; }
    public double Variance { get; }
    public double StandardDeviation { get; }
    public int Count { get; }
    public sealed virtual double get_Mean();
    public sealed virtual double get_Variance();
    public sealed virtual double get_StandardDeviation();
    public int get_Count();
    public sealed virtual void Push(double value);
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Running.RunningRangeStatistics : object {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    public int Count { get; private set; }
    public double Min { get; private set; }
    public double Max { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(double value);
    public sealed virtual void Push(double value);
    public sealed virtual void Clear();
}
[SerializableAttribute]
public class Accord.Statistics.Testing.AndersonDarlingTest : HypothesisTest`1<AndersonDarlingDistribution> {
    [CompilerGeneratedAttribute]
private IUnivariateDistribution`1<double> <TheoreticalDistribution>k__BackingField;
    public IUnivariateDistribution`1<double> TheoreticalDistribution { get; private set; }
    public AndersonDarlingTest(Double[] sample, IUnivariateDistribution`1<double> hypothesizedDistribution);
    [CompilerGeneratedAttribute]
public IUnivariateDistribution`1<double> get_TheoreticalDistribution();
    [CompilerGeneratedAttribute]
private void set_TheoreticalDistribution(IUnivariateDistribution`1<double> value);
    public static double GetStatistic(Double[] sortedSamples, IUnivariateDistribution`1<double> distribution);
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.AnovaSourceCollection : ReadOnlyCollection`1<AnovaVariationSource> {
    internal AnovaSourceCollection(AnovaVariationSource[] rows);
    internal AnovaSourceCollection(IList`1<AnovaVariationSource> rows);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.AnovaVariationSource : object {
    private IAnova anova;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SumOfSquares>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DegreesOfFreedom>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MeanSquares>k__BackingField;
    [CompilerGeneratedAttribute]
private FTest <Significance>k__BackingField;
    [BrowsableAttribute("False")]
public IAnova Anova { get; }
    [DisplayNameAttribute("Source")]
public string Source { get; private set; }
    [DisplayNameAttribute("Sum of Squares")]
public double SumOfSquares { get; private set; }
    [DisplayNameAttribute("Degrees of Freedom")]
public int DegreesOfFreedom { get; private set; }
    [DisplayNameAttribute("Mean Squares")]
public double MeanSquares { get; private set; }
    [DisplayNameAttribute("P-Value")]
public FTest Significance { get; private set; }
    [DisplayNameAttribute("F-Statistic")]
public Nullable`1<double> Statistic { get; }
    public AnovaVariationSource(IAnova anova, string source);
    public AnovaVariationSource(IAnova anova, string source, double sumOfSquares, int degreesOfFreedom);
    public AnovaVariationSource(IAnova anova, string source, double sumOfSquares, int degreesOfFreedom, double meanSquares);
    public AnovaVariationSource(IAnova anova, string source, double sumOfSquares, int degreesOfFreedom, FTest test);
    public AnovaVariationSource(IAnova anova, string source, double sumOfSquares, int degreesOfFreedom, double meanSquares, FTest test);
    public IAnova get_Anova();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    [CompilerGeneratedAttribute]
public double get_SumOfSquares();
    [CompilerGeneratedAttribute]
private void set_SumOfSquares(double value);
    [CompilerGeneratedAttribute]
public int get_DegreesOfFreedom();
    [CompilerGeneratedAttribute]
private void set_DegreesOfFreedom(int value);
    [CompilerGeneratedAttribute]
public double get_MeanSquares();
    [CompilerGeneratedAttribute]
private void set_MeanSquares(double value);
    [CompilerGeneratedAttribute]
public FTest get_Significance();
    [CompilerGeneratedAttribute]
private void set_Significance(FTest value);
    public Nullable`1<double> get_Statistic();
}
[SerializableAttribute]
public class Accord.Statistics.Testing.AverageKappaTest : ChiSquareTest {
    [CompilerGeneratedAttribute]
private double <OverallKappa>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OverallVariance>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Variances>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <EstimatedValues>k__BackingField;
    public double OverallKappa { get; private set; }
    public double OverallVariance { get; private set; }
    public Double[] Variances { get; private set; }
    public Double[] EstimatedValues { get; private set; }
    public AverageKappaTest(Double[] kappas, Double[] variances);
    public AverageKappaTest(GeneralConfusionMatrix[] matrices);
    [CompilerGeneratedAttribute]
public double get_OverallKappa();
    [CompilerGeneratedAttribute]
private void set_OverallKappa(double value);
    [CompilerGeneratedAttribute]
public double get_OverallVariance();
    [CompilerGeneratedAttribute]
private void set_OverallVariance(double value);
    [CompilerGeneratedAttribute]
public Double[] get_Variances();
    [CompilerGeneratedAttribute]
private void set_Variances(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_EstimatedValues();
    [CompilerGeneratedAttribute]
private void set_EstimatedValues(Double[] value);
    protected void Compute(Double[] kappas, Double[] variances);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.BartlettTest : ChiSquareTest {
    public BartlettTest(Double[][] samples);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.BhapkarTest : ChiSquareTest {
    private Double[] d;
    private Double[0...,0...] S;
    private Double[0...,0...] invS;
    public Double[] Delta { get; }
    public Double[0...,0...] Covariance { get; }
    public Double[0...,0...] Precision { get; }
    public BhapkarTest(GeneralConfusionMatrix matrix);
    public Double[] get_Delta();
    public Double[0...,0...] get_Covariance();
    public Double[0...,0...] get_Precision();
}
[SerializableAttribute]
public class Accord.Statistics.Testing.BinomialTest : HypothesisTest`1<BinomialDistribution> {
    [CompilerGeneratedAttribute]
private OneSampleHypothesis <Hypothesis>k__BackingField;
    public OneSampleHypothesis Hypothesis { get; protected set; }
    public BinomialTest(Boolean[] trials, double hypothesizedProbability, OneSampleHypothesis alternate);
    public BinomialTest(int successes, int trials, double hypothesizedProbability, OneSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public OneSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(OneSampleHypothesis value);
    protected void Compute(double statistic, int m, double p, OneSampleHypothesis alternate);
    public virtual double StatisticToPValue(double x);
    public virtual double PValueToStatistic(double p);
    private double wilsonSterne(double x);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.BowkerTest : ChiSquareTest {
    public BowkerTest(GeneralConfusionMatrix matrix);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.ChiSquareTest : HypothesisTest`1<ChiSquareDistribution> {
    public int DegreesOfFreedom { get; }
    public ChiSquareTest(double statistic, int degreesOfFreedom);
    public ChiSquareTest(Double[] expected, Double[] observed, int degreesOfFreedom);
    public ChiSquareTest(ConfusionMatrix matrix, bool yatesCorrection);
    public ChiSquareTest(GeneralConfusionMatrix matrix, bool yatesCorrection);
    public ChiSquareTest(Double[] observations, IUnivariateDistribution`1<double> hypothesizedDistribution);
    public int get_DegreesOfFreedom();
    protected void Compute(double statistic, int degreesOfFreedom);
    public virtual double StatisticToPValue(double x);
    public virtual double PValueToStatistic(double p);
    private static double compute(Double[] expected, Double[] observed);
    private static double compute(Int32[0...,0...] values, Int32[] row, Int32[] col, int samples, bool yatesCorrection);
}
public enum Accord.Statistics.Testing.DistributionTail : Enum {
    public int value__;
    public static DistributionTail TwoTail;
    public static DistributionTail OneUpper;
    public static DistributionTail OneLower;
}
[SerializableAttribute]
public class Accord.Statistics.Testing.FisherExactTest : HypothesisTest`1<HypergeometricDistribution> {
    [CompilerGeneratedAttribute]
private OneSampleHypothesis <Hypothesis>k__BackingField;
    public OneSampleHypothesis Hypothesis { get; protected set; }
    public FisherExactTest(ConfusionMatrix matrix, OneSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public OneSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(OneSampleHypothesis value);
    protected void Compute(double statistic, int populationSize, int n, int m, OneSampleHypothesis alternate);
    public virtual double StatisticToPValue(double x);
    public virtual double PValueToStatistic(double p);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.FTest : HypothesisTest`1<FDistribution> {
    [CompilerGeneratedAttribute]
private TwoSampleHypothesis <Hypothesis>k__BackingField;
    public TwoSampleHypothesis Hypothesis { get; private set; }
    public int DegreesOfFreedom1 { get; }
    public int DegreesOfFreedom2 { get; }
    public FTest(double var1, double var2, int d1, int d2, TwoSampleHypothesis alternate);
    public FTest(double statistic, int d1, int d2, TwoSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public TwoSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
private void set_Hypothesis(TwoSampleHypothesis value);
    public int get_DegreesOfFreedom1();
    public int get_DegreesOfFreedom2();
    protected void Compute(double statistic, int d1, int d2, TwoSampleHypothesis alternate);
    public virtual double StatisticToPValue(double x);
    public virtual double PValueToStatistic(double p);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.GrubbTest : HypothesisTest`1<GrubbDistribution> {
    private double min;
    private double max;
    private double abs;
    [CompilerGeneratedAttribute]
private int <NumberOfSamples>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private GrubbTestHypothesis <Hypothesis>k__BackingField;
    public int NumberOfSamples { get; private set; }
    public double Mean { get; private set; }
    public double StandardDeviation { get; private set; }
    public double Min { get; }
    public double Max { get; }
    public double Abs { get; }
    public GrubbTestHypothesis Hypothesis { get; private set; }
    public GrubbTest(Double[] samples, GrubbTestHypothesis hypothesis);
    [CompilerGeneratedAttribute]
public int get_NumberOfSamples();
    [CompilerGeneratedAttribute]
private void set_NumberOfSamples(int value);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
private void set_Mean(double value);
    [CompilerGeneratedAttribute]
public double get_StandardDeviation();
    [CompilerGeneratedAttribute]
private void set_StandardDeviation(double value);
    public double get_Min();
    public double get_Max();
    public double get_Abs();
    [CompilerGeneratedAttribute]
public GrubbTestHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
private void set_Hypothesis(GrubbTestHypothesis value);
    private double g(GrubbTestHypothesis hypothesis);
    public virtual double StatisticToPValue(double x);
    public virtual double PValueToStatistic(double p);
}
public enum Accord.Statistics.Testing.GrubbTestHypothesis : Enum {
    public int value__;
    public static GrubbTestHypothesis ThereAreOutliers;
    public static GrubbTestHypothesis TheMaximumIsAnOutlier;
    public static GrubbTestHypothesis TheMinimumIsAnOutlier;
}
[SerializableAttribute]
public abstract class Accord.Statistics.Testing.HypothesisTest`1 : object {
    private double alpha;
    [CompilerGeneratedAttribute]
private TDistribution <StatisticDistribution>k__BackingField;
    [CompilerGeneratedAttribute]
private double <PValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Statistic>k__BackingField;
    [CompilerGeneratedAttribute]
private DistributionTail <Tail>k__BackingField;
    public TDistribution StatisticDistribution { get; protected set; }
    public double PValue { get; protected set; }
    public double Statistic { get; protected set; }
    public DistributionTail Tail { get; protected set; }
    public double Size { get; public set; }
    public bool Significant { get; }
    public double CriticalValue { get; }
    [CompilerGeneratedAttribute]
public sealed virtual TDistribution get_StatisticDistribution();
    [CompilerGeneratedAttribute]
protected void set_StatisticDistribution(TDistribution value);
    [CompilerGeneratedAttribute]
public double get_PValue();
    [CompilerGeneratedAttribute]
protected void set_PValue(double value);
    [CompilerGeneratedAttribute]
public double get_Statistic();
    [CompilerGeneratedAttribute]
protected void set_Statistic(double value);
    [CompilerGeneratedAttribute]
public sealed virtual DistributionTail get_Tail();
    [CompilerGeneratedAttribute]
protected void set_Tail(DistributionTail value);
    public double get_Size();
    public void set_Size(double value);
    public sealed virtual bool get_Significant();
    public virtual double get_CriticalValue();
    public abstract virtual double StatisticToPValue(double x);
    public abstract virtual double PValueToStatistic(double p);
    protected virtual void OnSizeChanged();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
}
public interface Accord.Statistics.Testing.IAnova {
    public AnovaSourceCollection Table { get; }
    public abstract virtual AnovaSourceCollection get_Table();
}
public interface Accord.Statistics.Testing.IHypothesisTest {
    public DistributionTail Tail { get; }
    public bool Significant { get; }
    public abstract virtual DistributionTail get_Tail();
    public abstract virtual bool get_Significant();
    public abstract virtual double StatisticToPValue(double x);
    public abstract virtual double PValueToStatistic(double p);
}
public interface Accord.Statistics.Testing.IHypothesisTest`1 {
    public TDistribution StatisticDistribution { get; }
    public abstract virtual TDistribution get_StatisticDistribution();
}
[SerializableAttribute]
public class Accord.Statistics.Testing.KappaTest : ZTest {
    [CompilerGeneratedAttribute]
private double <Variance>k__BackingField;
    public double Variance { get; private set; }
    public KappaTest(double sampleKappa, double standardError, OneSampleHypothesis alternate);
    public KappaTest(double sampleKappa, double standardError, double hypothesizedKappa, OneSampleHypothesis alternate);
    public KappaTest(GeneralConfusionMatrix matrix, OneSampleHypothesis alternate);
    public KappaTest(GeneralConfusionMatrix matrix, double hypothesizedKappa, OneSampleHypothesis alternate);
    public KappaTest(WeightedConfusionMatrix matrix, double hypothesizedWeightedKappa, OneSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public double get_Variance();
    [CompilerGeneratedAttribute]
private void set_Variance(double value);
    public static double DeltaMethodKappaVariance(GeneralConfusionMatrix matrix);
    public static double DeltaMethodKappaVariance(GeneralConfusionMatrix matrix, Double& stdDev);
    public static double AsymptoticKappaVariance(GeneralConfusionMatrix matrix);
    public static double AsymptoticKappaVariance(GeneralConfusionMatrix matrix, Double& stdDev, bool nullHypothesis);
    public static double AsymptoticKappaVariance(WeightedConfusionMatrix matrix, Double& stdDev, bool nullHypothesis);
    private static double square(double x);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.KolmogorovSmirnovTest : HypothesisTest`1<KolmogorovSmirnovDistribution> {
    [CompilerGeneratedAttribute]
private KolmogorovSmirnovTestHypothesis <Hypothesis>k__BackingField;
    [CompilerGeneratedAttribute]
private IDistribution`1<double> <TheoreticalDistribution>k__BackingField;
    [CompilerGeneratedAttribute]
private EmpiricalDistribution <EmpiricalDistribution>k__BackingField;
    public KolmogorovSmirnovTestHypothesis Hypothesis { get; private set; }
    public IDistribution`1<double> TheoreticalDistribution { get; private set; }
    public EmpiricalDistribution EmpiricalDistribution { get; private set; }
    public KolmogorovSmirnovTest(Double[] sample, IDistribution`1<double> hypothesizedDistribution);
    public KolmogorovSmirnovTest(Double[] sample, IDistribution`1<double> hypothesizedDistribution, KolmogorovSmirnovTestHypothesis alternate);
    [CompilerGeneratedAttribute]
public KolmogorovSmirnovTestHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
private void set_Hypothesis(KolmogorovSmirnovTestHypothesis value);
    [CompilerGeneratedAttribute]
public IDistribution`1<double> get_TheoreticalDistribution();
    [CompilerGeneratedAttribute]
private void set_TheoreticalDistribution(IDistribution`1<double> value);
    [CompilerGeneratedAttribute]
public EmpiricalDistribution get_EmpiricalDistribution();
    [CompilerGeneratedAttribute]
private void set_EmpiricalDistribution(EmpiricalDistribution value);
    public static double GetStatistic(Double[] sortedSamples, IDistribution`1<double> distribution, KolmogorovSmirnovTestHypothesis alternate);
    public static double OneSideLower(Double[] sortedSamples, IDistribution`1<double> distribution);
    public static double OneSideUpper(Double[] sortedSamples, IDistribution`1<double> distribution);
    public static double TwoSide(Double[] sortedSamples, IDistribution`1<double> distribution);
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
}
public enum Accord.Statistics.Testing.KolmogorovSmirnovTestHypothesis : Enum {
    public int value__;
    public static KolmogorovSmirnovTestHypothesis SampleIsDifferent;
    public static KolmogorovSmirnovTestHypothesis SampleIsGreater;
    public static KolmogorovSmirnovTestHypothesis SampleIsSmaller;
}
[SerializableAttribute]
public class Accord.Statistics.Testing.LeveneTest : FTest {
    [CompilerGeneratedAttribute]
private LeveneTestMethod <Method>k__BackingField;
    public LeveneTestMethod Method { get; private set; }
    public LeveneTest(Double[][] samples, bool median);
    public LeveneTest(Double[][] samples, double percent);
    [CompilerGeneratedAttribute]
public LeveneTestMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(LeveneTestMethod value);
    private void compute(Double[][] samples, LeveneTestMethod method, double percent);
}
public enum Accord.Statistics.Testing.LeveneTestMethod : Enum {
    public int value__;
    public static LeveneTestMethod Mean;
    public static LeveneTestMethod Median;
    public static LeveneTestMethod TruncatedMean;
}
[SerializableAttribute]
public class Accord.Statistics.Testing.LillieforsTest : HypothesisTest`1<EmpiricalDistribution> {
    [CompilerGeneratedAttribute]
private KolmogorovSmirnovTestHypothesis <Hypothesis>k__BackingField;
    [CompilerGeneratedAttribute]
private ISampleableDistribution`1<double> <TheoreticalDistribution>k__BackingField;
    [CompilerGeneratedAttribute]
private EmpiricalDistribution <EmpiricalDistribution>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSamples>k__BackingField;
    public KolmogorovSmirnovTestHypothesis Hypothesis { get; private set; }
    public ISampleableDistribution`1<double> TheoreticalDistribution { get; private set; }
    public EmpiricalDistribution EmpiricalDistribution { get; private set; }
    public int NumberOfSamples { get; private set; }
    public LillieforsTest(Double[] sample, ISampleableDistribution`1<double> hypothesizedDistribution, KolmogorovSmirnovTestHypothesis alternate, int iterations, bool reestimate);
    [CompilerGeneratedAttribute]
public KolmogorovSmirnovTestHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
private void set_Hypothesis(KolmogorovSmirnovTestHypothesis value);
    [CompilerGeneratedAttribute]
public ISampleableDistribution`1<double> get_TheoreticalDistribution();
    [CompilerGeneratedAttribute]
private void set_TheoreticalDistribution(ISampleableDistribution`1<double> value);
    [CompilerGeneratedAttribute]
public EmpiricalDistribution get_EmpiricalDistribution();
    [CompilerGeneratedAttribute]
private void set_EmpiricalDistribution(EmpiricalDistribution value);
    [CompilerGeneratedAttribute]
public int get_NumberOfSamples();
    [CompilerGeneratedAttribute]
private void set_NumberOfSamples(int value);
    private EmpiricalDistribution GetSimulatedDistribution(ISampleableDistribution`1<double> hypothesizedDistribution, bool reestimate, int iterations, KolmogorovSmirnovTestHypothesis alternate);
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
    public static LillieforsTest GoodnessOfFit(Double[] samples);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.MannWhitneyWilcoxonTest : HypothesisTest`1<MannWhitneyDistribution> {
    private bool hasTies;
    [CompilerGeneratedAttribute]
private TwoSampleHypothesis <Hypothesis>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSamples1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSamples2>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Rank1>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Rank2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RankSum1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RankSum2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Statistic1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Statistic2>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExact>k__BackingField;
    public TwoSampleHypothesis Hypothesis { get; protected set; }
    public int NumberOfSamples1 { get; protected set; }
    public int NumberOfSamples2 { get; protected set; }
    public Double[] Rank1 { get; protected set; }
    public Double[] Rank2 { get; protected set; }
    public double RankSum1 { get; protected set; }
    public double RankSum2 { get; protected set; }
    public double Statistic1 { get; protected set; }
    public double Statistic2 { get; protected set; }
    public bool HasTies { get; }
    public bool IsExact { get; private set; }
    public MannWhitneyWilcoxonTest(Double[] sample1, Double[] sample2, TwoSampleHypothesis alternate, Nullable`1<bool> exact, bool adjustForTies);
    [CompilerGeneratedAttribute]
public TwoSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(TwoSampleHypothesis value);
    [CompilerGeneratedAttribute]
public int get_NumberOfSamples1();
    [CompilerGeneratedAttribute]
protected void set_NumberOfSamples1(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfSamples2();
    [CompilerGeneratedAttribute]
protected void set_NumberOfSamples2(int value);
    [CompilerGeneratedAttribute]
public Double[] get_Rank1();
    [CompilerGeneratedAttribute]
protected void set_Rank1(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Rank2();
    [CompilerGeneratedAttribute]
protected void set_Rank2(Double[] value);
    [CompilerGeneratedAttribute]
public double get_RankSum1();
    [CompilerGeneratedAttribute]
protected void set_RankSum1(double value);
    [CompilerGeneratedAttribute]
public double get_RankSum2();
    [CompilerGeneratedAttribute]
protected void set_RankSum2(double value);
    [CompilerGeneratedAttribute]
public double get_Statistic1();
    [CompilerGeneratedAttribute]
protected void set_Statistic1(double value);
    [CompilerGeneratedAttribute]
public double get_Statistic2();
    [CompilerGeneratedAttribute]
protected void set_Statistic2(double value);
    public bool get_HasTies();
    [CompilerGeneratedAttribute]
public bool get_IsExact();
    [CompilerGeneratedAttribute]
private void set_IsExact(bool value);
    public virtual double StatisticToPValue(double x);
    public virtual double PValueToStatistic(double p);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.McNemarTest : ChiSquareTest {
    public McNemarTest(ConfusionMatrix matrix, bool yatesCorrection);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.MultinomialTest : ChiSquareTest {
    [CompilerGeneratedAttribute]
private Double[] <ObservedProportions>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <HypothesizedProportions>k__BackingField;
    public Double[] ObservedProportions { get; private set; }
    public Double[] HypothesizedProportions { get; private set; }
    public MultinomialTest(Double[] sampleProportions, int sampleSize);
    public MultinomialTest(Int32[] sampleCounts);
    public MultinomialTest(Int32[] sampleCounts, Double[] hypothesizedProportions);
    public MultinomialTest(Double[] sampleProportions, int sampleSize, Double[] hypothesizedProportions);
    public MultinomialTest(Int32[] sample, int categories);
    public MultinomialTest(Int32[] sample, int categories, Double[] hypothesizedProportions);
    [CompilerGeneratedAttribute]
public Double[] get_ObservedProportions();
    [CompilerGeneratedAttribute]
private void set_ObservedProportions(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_HypothesizedProportions();
    [CompilerGeneratedAttribute]
private void set_HypothesizedProportions(Double[] value);
    protected void Compute(int sampleSize, Double[] observed, Double[] expected);
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Testing.NamespaceDoc : object {
}
public enum Accord.Statistics.Testing.OneSampleHypothesis : Enum {
    public int value__;
    public static OneSampleHypothesis ValueIsDifferentFromHypothesis;
    public static OneSampleHypothesis ValueIsGreaterThanHypothesis;
    public static OneSampleHypothesis ValueIsSmallerThanHypothesis;
}
[SerializableAttribute]
public class Accord.Statistics.Testing.OneWayAnova : object {
    private int groupCount;
    private Int32[] sizes;
    private int totalSize;
    private Double[] means;
    private double totalMean;
    private double SSb;
    private double SSw;
    private double SSt;
    private double MSb;
    private double MSw;
    private int DFb;
    private int DFw;
    private int DFt;
    [CompilerGeneratedAttribute]
private FTest <FTest>k__BackingField;
    [CompilerGeneratedAttribute]
private AnovaSourceCollection <Table>k__BackingField;
    public FTest FTest { get; private set; }
    public AnovaSourceCollection Table { get; private set; }
    public OneWayAnova(Double[] samples, Int32[] labels);
    public OneWayAnova(Double[][] samples);
    [CompilerGeneratedAttribute]
public FTest get_FTest();
    [CompilerGeneratedAttribute]
private void set_FTest(FTest value);
    [CompilerGeneratedAttribute]
public sealed virtual AnovaSourceCollection get_Table();
    [CompilerGeneratedAttribute]
private void set_Table(AnovaSourceCollection value);
    private void initialize(Double[][] samples);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.PairedTTest : HypothesisTest`1<TDistribution> {
    [CompilerGeneratedAttribute]
private TwoSampleHypothesis <Hypothesis>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ObservedDifference>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleSize>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange <Confidence>k__BackingField;
    public TwoSampleHypothesis Hypothesis { get; private set; }
    public double Mean1 { get; private set; }
    public double Mean2 { get; private set; }
    public double ObservedDifference { get; private set; }
    public double StandardError { get; private set; }
    public int SampleSize { get; private set; }
    public DoubleRange Confidence { get; protected set; }
    public PairedTTest(Double[] sample1, Double[] sample2, TwoSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public TwoSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
private void set_Hypothesis(TwoSampleHypothesis value);
    [CompilerGeneratedAttribute]
public double get_Mean1();
    [CompilerGeneratedAttribute]
private void set_Mean1(double value);
    [CompilerGeneratedAttribute]
public double get_Mean2();
    [CompilerGeneratedAttribute]
private void set_Mean2(double value);
    [CompilerGeneratedAttribute]
public double get_ObservedDifference();
    [CompilerGeneratedAttribute]
private void set_ObservedDifference(double value);
    [CompilerGeneratedAttribute]
public double get_StandardError();
    [CompilerGeneratedAttribute]
private void set_StandardError(double value);
    [CompilerGeneratedAttribute]
public int get_SampleSize();
    [CompilerGeneratedAttribute]
private void set_SampleSize(int value);
    [CompilerGeneratedAttribute]
public DoubleRange get_Confidence();
    [CompilerGeneratedAttribute]
protected void set_Confidence(DoubleRange value);
    public DoubleRange GetConfidenceInterval(double percent);
    protected virtual void OnSizeChanged();
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Testing.Power.BaseOneSamplePowerAnalysis : object {
    [CompilerGeneratedAttribute]
private DistributionTail <Tail>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Power>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Samples>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Effect>k__BackingField;
    public DistributionTail Tail { get; public set; }
    public double Power { get; public set; }
    public double Size { get; public set; }
    public double Samples { get; public set; }
    public double Effect { get; public set; }
    protected BaseOneSamplePowerAnalysis(DistributionTail tail);
    [CompilerGeneratedAttribute]
public sealed virtual DistributionTail get_Tail();
    [CompilerGeneratedAttribute]
public void set_Tail(DistributionTail value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Power();
    [CompilerGeneratedAttribute]
public void set_Power(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Samples();
    [CompilerGeneratedAttribute]
public void set_Samples(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Effect();
    [CompilerGeneratedAttribute]
public void set_Effect(double value);
    public abstract virtual void ComputePower();
    public virtual void ComputeEffect();
    public virtual void ComputeSamples();
    public sealed virtual object Clone();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public double GetDiferentiableUnits(double standardDeviation);
    [CompilerGeneratedAttribute]
private double <ComputeSamples>b__23_0(double n);
}
[SerializableAttribute]
public abstract class Accord.Statistics.Testing.Power.BaseTwoSamplePowerAnalysis : object {
    [CompilerGeneratedAttribute]
private DistributionTail <Tail>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Power>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Samples1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Samples2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Effect>k__BackingField;
    public DistributionTail Tail { get; public set; }
    public double Power { get; public set; }
    public double Size { get; public set; }
    public double Samples1 { get; public set; }
    public double Samples2 { get; public set; }
    private double Accord.Statistics.Testing.Power.IPowerAnalysis.Samples { get; }
    public double TotalSamples { get; }
    public double Effect { get; public set; }
    protected BaseTwoSamplePowerAnalysis(DistributionTail tail);
    [CompilerGeneratedAttribute]
public sealed virtual DistributionTail get_Tail();
    [CompilerGeneratedAttribute]
public void set_Tail(DistributionTail value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Power();
    [CompilerGeneratedAttribute]
public void set_Power(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Samples1();
    [CompilerGeneratedAttribute]
public void set_Samples1(double value);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Samples2();
    [CompilerGeneratedAttribute]
public void set_Samples2(double value);
    private sealed virtual override double Accord.Statistics.Testing.Power.IPowerAnalysis.get_Samples();
    public double get_TotalSamples();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Effect();
    [CompilerGeneratedAttribute]
public void set_Effect(double value);
    public abstract virtual void ComputePower();
    public virtual void ComputeEffect();
    public virtual void ComputeSize();
    public virtual void ComputeSamples(double proportion);
    public sealed virtual object Clone();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public double GetDiferentiableUnits(double standardDeviation);
    public double GetDiferentiableUnits(double var1, double var2);
}
public interface Accord.Statistics.Testing.Power.IPowerAnalysis {
    public DistributionTail Tail { get; }
    public double Power { get; }
    public double Size { get; }
    public double Samples { get; }
    public double Effect { get; }
    public abstract virtual DistributionTail get_Tail();
    public abstract virtual double get_Power();
    public abstract virtual double get_Size();
    public abstract virtual double get_Samples();
    public abstract virtual double get_Effect();
}
public interface Accord.Statistics.Testing.Power.ITwoSamplePowerAnalysis {
    public double Samples1 { get; }
    public double Samples2 { get; }
    public abstract virtual double get_Samples1();
    public abstract virtual double get_Samples2();
}
[CompilerGeneratedAttribute]
internal class Accord.Statistics.Testing.Power.NamespaceDoc : object {
}
[SerializableAttribute]
public class Accord.Statistics.Testing.Power.TTestPowerAnalysis : BaseOneSamplePowerAnalysis {
    public TTestPowerAnalysis(OneSampleHypothesis hypothesis);
    public TTestPowerAnalysis(TwoSampleTTest test);
    public virtual void ComputePower();
    public static TTestPowerAnalysis GetSampleSize(double delta, double standardDeviation, double power, double alpha, OneSampleHypothesis hypothesis);
    public static TTestPowerAnalysis GetEffectSize(int sampleSize, double power, double alpha, OneSampleHypothesis hypothesis);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.Power.TwoSampleTTestPowerAnalysis : BaseTwoSamplePowerAnalysis {
    public TwoSampleTTestPowerAnalysis(TwoSampleHypothesis hypothesis);
    public TwoSampleTTestPowerAnalysis(TwoSampleTTest test);
    public virtual void ComputePower();
    public static TwoSampleTTestPowerAnalysis GetSampleSize(double delta, double standardDeviation, double proportion, double power, double alpha, TwoSampleHypothesis hypothesis);
    public static TwoSampleTTestPowerAnalysis GetSampleSize(double delta, double variance1, double variance2, double proportion, double power, double alpha, TwoSampleHypothesis hypothesis);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.Power.TwoSampleZTestPowerAnalysis : BaseTwoSamplePowerAnalysis {
    public TwoSampleZTestPowerAnalysis(TwoSampleHypothesis hypothesis);
    public TwoSampleZTestPowerAnalysis(TwoSampleZTest test);
    public virtual void ComputePower();
    public virtual void ComputeSamples(double proportion);
    public virtual void ComputeEffect();
    public static TwoSampleZTestPowerAnalysis GetSampleSize(double delta, double standardDeviation, double proportion, double power, double alpha, TwoSampleHypothesis hypothesis);
    public static TwoSampleZTestPowerAnalysis GetEffectSize(int sampleSize1, int sampleSize2, double power, double alpha, TwoSampleHypothesis hypothesis);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.Power.ZTestPowerAnalysis : BaseOneSamplePowerAnalysis {
    public ZTestPowerAnalysis(OneSampleHypothesis hypothesis);
    public ZTestPowerAnalysis(TwoSampleZTest test);
    public virtual void ComputePower();
    public virtual void ComputeSamples();
    public virtual void ComputeEffect();
    public static ZTestPowerAnalysis GetSampleSize(double delta, double standardDeviation, double power, double alpha, OneSampleHypothesis hypothesis);
    public static ZTestPowerAnalysis GetEffectSize(int sampleSize, double power, double alpha, OneSampleHypothesis hypothesis);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.ReceiverOperatingCurveTest : ZTest {
    [CompilerGeneratedAttribute]
private ReceiverOperatingCharacteristic <Curve>k__BackingField;
    public ReceiverOperatingCharacteristic Curve { get; private set; }
    public ReceiverOperatingCurveTest(ReceiverOperatingCharacteristic curve, double hypothesizedValue, OneSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public ReceiverOperatingCharacteristic get_Curve();
    [CompilerGeneratedAttribute]
private void set_Curve(ReceiverOperatingCharacteristic value);
    public static double HanleyMcNealVariance(double area, int positiveCount, int negativeCount);
    public static double DeLongVariance(Double[] positiveAccuracies, Double[] negativeAccuracies);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.ShapiroWilkTest : HypothesisTest`1<ShapiroWilkDistribution> {
    public ShapiroWilkTest(Double[] sample);
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.SignTest : BinomialTest {
    [CompilerGeneratedAttribute]
private OneSampleHypothesis <Hypothesis>k__BackingField;
    public OneSampleHypothesis Hypothesis { get; protected set; }
    public SignTest(int positiveSamples, int totalSamples, OneSampleHypothesis alternate);
    public SignTest(Double[] sample, double hypothesizedMedian, OneSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public OneSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(OneSampleHypothesis value);
    protected void Compute(int positive, int total, OneSampleHypothesis alternate);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.StuartMaxwellTest : ChiSquareTest {
    private Double[] d;
    private Double[0...,0...] S;
    private Double[0...,0...] invS;
    public Double[] Delta { get; }
    public Double[0...,0...] Covariance { get; }
    public Double[0...,0...] Precision { get; }
    public StuartMaxwellTest(GeneralConfusionMatrix matrix);
    public Double[] get_Delta();
    public Double[0...,0...] get_Covariance();
    public Double[0...,0...] get_Precision();
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TTest : HypothesisTest`1<TDistribution> {
    private TTestPowerAnalysis powerAnalysis;
    [CompilerGeneratedAttribute]
private double <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EstimatedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <HypothesizedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange <Confidence>k__BackingField;
    [CompilerGeneratedAttribute]
private OneSampleHypothesis <Hypothesis>k__BackingField;
    public IPowerAnalysis Analysis { get; }
    public double StandardError { get; private set; }
    public double EstimatedValue { get; private set; }
    public double HypothesizedValue { get; private set; }
    public DoubleRange Confidence { get; protected set; }
    public OneSampleHypothesis Hypothesis { get; protected set; }
    public TTest(double statistic, double degreesOfFreedom, OneSampleHypothesis hypothesis);
    public TTest(double estimatedValue, double standardError, double degreesOfFreedom, double hypothesizedValue, OneSampleHypothesis alternate);
    public TTest(Double[] sample, double hypothesizedMean, OneSampleHypothesis alternate);
    public TTest(double mean, double stdDev, int samples, double hypothesizedMean, OneSampleHypothesis alternate);
    public IPowerAnalysis get_Analysis();
    [CompilerGeneratedAttribute]
public double get_StandardError();
    [CompilerGeneratedAttribute]
private void set_StandardError(double value);
    [CompilerGeneratedAttribute]
public double get_EstimatedValue();
    [CompilerGeneratedAttribute]
private void set_EstimatedValue(double value);
    [CompilerGeneratedAttribute]
public double get_HypothesizedValue();
    [CompilerGeneratedAttribute]
private void set_HypothesizedValue(double value);
    [CompilerGeneratedAttribute]
public DoubleRange get_Confidence();
    [CompilerGeneratedAttribute]
protected void set_Confidence(DoubleRange value);
    [CompilerGeneratedAttribute]
public OneSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(OneSampleHypothesis value);
    public DoubleRange GetConfidenceInterval(double percent);
    protected void Compute(int n, double mean, double hypothesizedMean, double stdError, OneSampleHypothesis hypothesis);
    protected void Compute(double statistic, double df, OneSampleHypothesis alternate);
    private void Compute(double estimatedValue, double stdError, double degreesOfFreedom, double hypothesizedValue, OneSampleHypothesis alternate);
    private void power(double stdDev, int samples);
    protected virtual void OnSizeChanged();
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
    public static double StatisticToPValue(double t, TDistribution distribution, DistributionTail type);
    public static double PValueToStatistic(double p, TDistribution distribution, DistributionTail type);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoAverageKappaTest : TwoSampleTTest {
    [CompilerGeneratedAttribute]
private double <Variance1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance2>k__BackingField;
    public double Variance1 { get; private set; }
    public double Variance2 { get; private set; }
    public TwoAverageKappaTest(double meanKappa1, double varKappa1, int kappaSamples1, double meanKappa2, double varKappa2, int kappaSamples2, double hypothesizedDifference, bool assumeEqualVariances, TwoSampleHypothesis alternate);
    public TwoAverageKappaTest(GeneralConfusionMatrix[] matrices1, GeneralConfusionMatrix[] matrices2, double hypothesizedDifference, bool assumeEqualVariances, TwoSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public double get_Variance1();
    [CompilerGeneratedAttribute]
private void set_Variance1(double value);
    [CompilerGeneratedAttribute]
public double get_Variance2();
    [CompilerGeneratedAttribute]
private void set_Variance2(double value);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoMatrixKappaTest : TwoSampleZTest {
    [CompilerGeneratedAttribute]
private double <OverallVariance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance2>k__BackingField;
    public double OverallVariance { get; private set; }
    public double Variance1 { get; private set; }
    public double Variance2 { get; private set; }
    public TwoMatrixKappaTest(double kappa1, double var1, double kappa2, double var2, double hypothesizedDifference, TwoSampleHypothesis alternate);
    public TwoMatrixKappaTest(GeneralConfusionMatrix matrix1, GeneralConfusionMatrix matrix2, double hypothesizedDifference, TwoSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public double get_OverallVariance();
    [CompilerGeneratedAttribute]
private void set_OverallVariance(double value);
    [CompilerGeneratedAttribute]
public double get_Variance1();
    [CompilerGeneratedAttribute]
private void set_Variance1(double value);
    [CompilerGeneratedAttribute]
public double get_Variance2();
    [CompilerGeneratedAttribute]
private void set_Variance2(double value);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoProportionZTest : TwoSampleZTest {
    public TwoProportionZTest(double proportion1, int sampleSize1, double proportion2, int sampleSize2, TwoSampleHypothesis alternate);
    public TwoProportionZTest(int successes1, int trials1, int successes2, int trials2, TwoSampleHypothesis alternate);
    protected void Compute(int successes1, int trials1, int successes2, int trials2, TwoSampleHypothesis alternate);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoReceiverOperatingCurveTest : TwoSampleZTest {
    [CompilerGeneratedAttribute]
private ReceiverOperatingCharacteristic <Curve1>k__BackingField;
    [CompilerGeneratedAttribute]
private ReceiverOperatingCharacteristic <Curve2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OverallVariance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance2>k__BackingField;
    public ReceiverOperatingCharacteristic Curve1 { get; private set; }
    public ReceiverOperatingCharacteristic Curve2 { get; private set; }
    public double OverallVariance { get; private set; }
    public double Variance1 { get; private set; }
    public double Variance2 { get; private set; }
    public TwoReceiverOperatingCurveTest(ReceiverOperatingCharacteristic curve1, ReceiverOperatingCharacteristic curve2, double hypothesizedDifference, TwoSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public ReceiverOperatingCharacteristic get_Curve1();
    [CompilerGeneratedAttribute]
private void set_Curve1(ReceiverOperatingCharacteristic value);
    [CompilerGeneratedAttribute]
public ReceiverOperatingCharacteristic get_Curve2();
    [CompilerGeneratedAttribute]
private void set_Curve2(ReceiverOperatingCharacteristic value);
    [CompilerGeneratedAttribute]
public double get_OverallVariance();
    [CompilerGeneratedAttribute]
private void set_OverallVariance(double value);
    [CompilerGeneratedAttribute]
public double get_Variance1();
    [CompilerGeneratedAttribute]
private void set_Variance1(double value);
    [CompilerGeneratedAttribute]
public double get_Variance2();
    [CompilerGeneratedAttribute]
private void set_Variance2(double value);
}
public enum Accord.Statistics.Testing.TwoSampleHypothesis : Enum {
    public int value__;
    public static TwoSampleHypothesis ValuesAreDifferent;
    public static TwoSampleHypothesis FirstValueIsGreaterThanSecond;
    public static TwoSampleHypothesis FirstValueIsSmallerThanSecond;
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoSampleKolmogorovSmirnovTest : HypothesisTest`1<KolmogorovSmirnovDistribution> {
    [CompilerGeneratedAttribute]
private TwoSampleKolmogorovSmirnovTestHypothesis <Hypothesis>k__BackingField;
    [CompilerGeneratedAttribute]
private EmpiricalDistribution <EmpiricalDistribution1>k__BackingField;
    [CompilerGeneratedAttribute]
private EmpiricalDistribution <EmpiricalDistribution2>k__BackingField;
    public TwoSampleKolmogorovSmirnovTestHypothesis Hypothesis { get; private set; }
    public EmpiricalDistribution EmpiricalDistribution1 { get; private set; }
    public EmpiricalDistribution EmpiricalDistribution2 { get; private set; }
    public TwoSampleKolmogorovSmirnovTest(Double[] sample1, Double[] sample2);
    public TwoSampleKolmogorovSmirnovTest(Double[] sample1, Double[] sample2, TwoSampleKolmogorovSmirnovTestHypothesis alternate);
    [CompilerGeneratedAttribute]
public TwoSampleKolmogorovSmirnovTestHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
private void set_Hypothesis(TwoSampleKolmogorovSmirnovTestHypothesis value);
    [CompilerGeneratedAttribute]
public EmpiricalDistribution get_EmpiricalDistribution1();
    [CompilerGeneratedAttribute]
private void set_EmpiricalDistribution1(EmpiricalDistribution value);
    [CompilerGeneratedAttribute]
public EmpiricalDistribution get_EmpiricalDistribution2();
    [CompilerGeneratedAttribute]
private void set_EmpiricalDistribution2(EmpiricalDistribution value);
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
}
public enum Accord.Statistics.Testing.TwoSampleKolmogorovSmirnovTestHypothesis : Enum {
    public int value__;
    public static TwoSampleKolmogorovSmirnovTestHypothesis SamplesDistributionsAreUnequal;
    public static TwoSampleKolmogorovSmirnovTestHypothesis FirstSampleIsLargerThanSecond;
    public static TwoSampleKolmogorovSmirnovTestHypothesis FirstSampleIsSmallerThanSecond;
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoSampleSignTest : BinomialTest {
    [CompilerGeneratedAttribute]
private TwoSampleHypothesis <Hypothesis>k__BackingField;
    public TwoSampleHypothesis Hypothesis { get; protected set; }
    public TwoSampleSignTest(int positiveSamples, int totalSamples, TwoSampleHypothesis alternate);
    public TwoSampleSignTest(Double[] sample1, Double[] sample2, TwoSampleHypothesis alternate);
    [CompilerGeneratedAttribute]
public TwoSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(TwoSampleHypothesis value);
    protected void Compute(int positive, int total, TwoSampleHypothesis alternate);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoSampleTTest : HypothesisTest`1<TDistribution> {
    private TwoSampleTTestPowerAnalysis powerAnalysis;
    [CompilerGeneratedAttribute]
private TwoSampleHypothesis <Hypothesis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssumeEqualVariance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EstimatedValue1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EstimatedValue2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <HypothesizedDifference>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ObservedDifference>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange <Confidence>k__BackingField;
    public ITwoSamplePowerAnalysis Analysis { get; }
    public TwoSampleHypothesis Hypothesis { get; private set; }
    public bool AssumeEqualVariance { get; private set; }
    public double StandardError { get; protected set; }
    public double Variance { get; protected set; }
    public double EstimatedValue1 { get; protected set; }
    public double EstimatedValue2 { get; protected set; }
    public double HypothesizedDifference { get; protected set; }
    public double ObservedDifference { get; protected set; }
    public double DegreesOfFreedom { get; }
    public DoubleRange Confidence { get; protected set; }
    public TwoSampleTTest(Double[] sample1, Double[] sample2, bool assumeEqualVariances, double hypothesizedDifference, TwoSampleHypothesis alternate);
    public TwoSampleTTest(double mean1, double var1, int samples1, double mean2, double var2, int samples2, bool assumeEqualVariances, double hypothesizedDifference, TwoSampleHypothesis alternate);
    public ITwoSamplePowerAnalysis get_Analysis();
    [CompilerGeneratedAttribute]
public TwoSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
private void set_Hypothesis(TwoSampleHypothesis value);
    [CompilerGeneratedAttribute]
public bool get_AssumeEqualVariance();
    [CompilerGeneratedAttribute]
private void set_AssumeEqualVariance(bool value);
    [CompilerGeneratedAttribute]
public double get_StandardError();
    [CompilerGeneratedAttribute]
protected void set_StandardError(double value);
    [CompilerGeneratedAttribute]
public double get_Variance();
    [CompilerGeneratedAttribute]
protected void set_Variance(double value);
    [CompilerGeneratedAttribute]
public double get_EstimatedValue1();
    [CompilerGeneratedAttribute]
protected void set_EstimatedValue1(double value);
    [CompilerGeneratedAttribute]
public double get_EstimatedValue2();
    [CompilerGeneratedAttribute]
protected void set_EstimatedValue2(double value);
    [CompilerGeneratedAttribute]
public double get_HypothesizedDifference();
    [CompilerGeneratedAttribute]
protected void set_HypothesizedDifference(double value);
    [CompilerGeneratedAttribute]
public double get_ObservedDifference();
    [CompilerGeneratedAttribute]
protected void set_ObservedDifference(double value);
    public double get_DegreesOfFreedom();
    [CompilerGeneratedAttribute]
public DoubleRange get_Confidence();
    [CompilerGeneratedAttribute]
protected void set_Confidence(DoubleRange value);
    public DoubleRange GetConfidenceInterval(double percent);
    protected void Compute(double x1, double s1, int n1, double x2, double s2, int n2, double hypothesizedDifference, bool equalVar, TwoSampleHypothesis alternate);
    private void power(double var1, double var2, int n1, int n2);
    protected virtual void OnSizeChanged();
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
}
public class Accord.Statistics.Testing.TwoSampleWilcoxonSignedRankTest : WilcoxonTest {
    [CompilerGeneratedAttribute]
private TwoSampleHypothesis <Hypothesis>k__BackingField;
    public TwoSampleHypothesis Hypothesis { get; protected set; }
    public TwoSampleWilcoxonSignedRankTest(Double[] sample1, Double[] sample2, TwoSampleHypothesis alternate, Nullable`1<bool> exact, bool adjustForTies);
    [CompilerGeneratedAttribute]
public TwoSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(TwoSampleHypothesis value);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoSampleZTest : HypothesisTest`1<NormalDistribution> {
    private TwoSampleZTestPowerAnalysis powerAnalysis;
    [CompilerGeneratedAttribute]
private TwoSampleHypothesis <Hypothesis>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EstimatedValue1>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EstimatedValue2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <HypothesizedDifference>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ObservedDifference>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange <Confidence>k__BackingField;
    public ITwoSamplePowerAnalysis Analysis { get; }
    public TwoSampleHypothesis Hypothesis { get; private set; }
    public double StandardError { get; protected set; }
    public double EstimatedValue1 { get; protected set; }
    public double EstimatedValue2 { get; protected set; }
    public double HypothesizedDifference { get; protected set; }
    public double ObservedDifference { get; protected set; }
    public DoubleRange Confidence { get; protected set; }
    public TwoSampleZTest(Double[] sample1, Double[] sample2, double hypothesizedDifference, TwoSampleHypothesis alternate);
    public TwoSampleZTest(double mean1, double var1, int samples1, double mean2, double var2, int samples2, double hypothesizedDifference, TwoSampleHypothesis alternate);
    public ITwoSamplePowerAnalysis get_Analysis();
    [CompilerGeneratedAttribute]
public TwoSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
private void set_Hypothesis(TwoSampleHypothesis value);
    [CompilerGeneratedAttribute]
public double get_StandardError();
    [CompilerGeneratedAttribute]
protected void set_StandardError(double value);
    [CompilerGeneratedAttribute]
public double get_EstimatedValue1();
    [CompilerGeneratedAttribute]
protected void set_EstimatedValue1(double value);
    [CompilerGeneratedAttribute]
public double get_EstimatedValue2();
    [CompilerGeneratedAttribute]
protected void set_EstimatedValue2(double value);
    [CompilerGeneratedAttribute]
public double get_HypothesizedDifference();
    [CompilerGeneratedAttribute]
protected void set_HypothesizedDifference(double value);
    [CompilerGeneratedAttribute]
public double get_ObservedDifference();
    [CompilerGeneratedAttribute]
protected void set_ObservedDifference(double value);
    [CompilerGeneratedAttribute]
public DoubleRange get_Confidence();
    [CompilerGeneratedAttribute]
protected void set_Confidence(DoubleRange value);
    public DoubleRange GetConfidenceInterval(double percent);
    protected void Compute(double value1, double value2, double squareStdError1, double squareStdError2, double hypothesizedDifference, TwoSampleHypothesis alternate);
    protected void Compute(double observedDifference, double hypothesizedDifference, double standardError, TwoSampleHypothesis alternate);
    protected void Compute(double statistic, TwoSampleHypothesis alternate);
    private void power(double var1, double var2, int n1, int n2);
    protected virtual void OnSizeChanged();
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoWayAnova : object {
    private double totalMean;
    private Double[0...,0...] cellMeans;
    private Double[] aMean;
    private Double[] bMean;
    [CompilerGeneratedAttribute]
private int <Observations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstFactorSamples>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SecondFactorSamples>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Replications>k__BackingField;
    [CompilerGeneratedAttribute]
private TwoWayAnovaVariationSources <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private AnovaSourceCollection <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private TwoWayAnovaModel <ModelType>k__BackingField;
    public int Observations { get; private set; }
    public int FirstFactorSamples { get; private set; }
    public int SecondFactorSamples { get; private set; }
    public int Replications { get; private set; }
    public TwoWayAnovaVariationSources Sources { get; private set; }
    public AnovaSourceCollection Table { get; private set; }
    public TwoWayAnovaModel ModelType { get; private set; }
    public TwoWayAnova(Double[] samples, Int32[] firstFactorLabels, Int32[] secondFactorLabels, TwoWayAnovaModel type);
    public TwoWayAnova(Double[0...,0...,0...] samples, TwoWayAnovaModel type);
    public TwoWayAnova(Double[][][] samples, TwoWayAnovaModel type);
    [CompilerGeneratedAttribute]
public int get_Observations();
    [CompilerGeneratedAttribute]
private void set_Observations(int value);
    [CompilerGeneratedAttribute]
public int get_FirstFactorSamples();
    [CompilerGeneratedAttribute]
private void set_FirstFactorSamples(int value);
    [CompilerGeneratedAttribute]
public int get_SecondFactorSamples();
    [CompilerGeneratedAttribute]
private void set_SecondFactorSamples(int value);
    [CompilerGeneratedAttribute]
public int get_Replications();
    [CompilerGeneratedAttribute]
private void set_Replications(int value);
    [CompilerGeneratedAttribute]
public TwoWayAnovaVariationSources get_Sources();
    [CompilerGeneratedAttribute]
private void set_Sources(TwoWayAnovaVariationSources value);
    [CompilerGeneratedAttribute]
public sealed virtual AnovaSourceCollection get_Table();
    [CompilerGeneratedAttribute]
private void set_Table(AnovaSourceCollection value);
    [CompilerGeneratedAttribute]
public TwoWayAnovaModel get_ModelType();
    [CompilerGeneratedAttribute]
private void set_ModelType(TwoWayAnovaModel value);
    private void initialize(Double[][][] samples, TwoWayAnovaModel type);
    private static Double[][][] jagged(Double[0...,0...,0...] samples);
}
public enum Accord.Statistics.Testing.TwoWayAnovaModel : Enum {
    public int value__;
    public static TwoWayAnovaModel Fixed;
    public static TwoWayAnovaModel Random;
    public static TwoWayAnovaModel Mixed;
}
[SerializableAttribute]
public class Accord.Statistics.Testing.TwoWayAnovaVariationSources : object {
    [CompilerGeneratedAttribute]
private AnovaVariationSource <FactorA>k__BackingField;
    [CompilerGeneratedAttribute]
private AnovaVariationSource <FactorB>k__BackingField;
    [CompilerGeneratedAttribute]
private AnovaVariationSource <Interaction>k__BackingField;
    [CompilerGeneratedAttribute]
private AnovaVariationSource <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private AnovaVariationSource <Cells>k__BackingField;
    [CompilerGeneratedAttribute]
private AnovaVariationSource <Total>k__BackingField;
    public AnovaVariationSource FactorA { get; internal set; }
    public AnovaVariationSource FactorB { get; internal set; }
    public AnovaVariationSource Interaction { get; internal set; }
    public AnovaVariationSource Error { get; internal set; }
    public AnovaVariationSource Cells { get; internal set; }
    public AnovaVariationSource Total { get; internal set; }
    [CompilerGeneratedAttribute]
public AnovaVariationSource get_FactorA();
    [CompilerGeneratedAttribute]
internal void set_FactorA(AnovaVariationSource value);
    [CompilerGeneratedAttribute]
public AnovaVariationSource get_FactorB();
    [CompilerGeneratedAttribute]
internal void set_FactorB(AnovaVariationSource value);
    [CompilerGeneratedAttribute]
public AnovaVariationSource get_Interaction();
    [CompilerGeneratedAttribute]
internal void set_Interaction(AnovaVariationSource value);
    [CompilerGeneratedAttribute]
public AnovaVariationSource get_Error();
    [CompilerGeneratedAttribute]
internal void set_Error(AnovaVariationSource value);
    [CompilerGeneratedAttribute]
public AnovaVariationSource get_Cells();
    [CompilerGeneratedAttribute]
internal void set_Cells(AnovaVariationSource value);
    [CompilerGeneratedAttribute]
public AnovaVariationSource get_Total();
    [CompilerGeneratedAttribute]
internal void set_Total(AnovaVariationSource value);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.WaldTest : ZTest {
    public WaldTest(double statistic);
    public WaldTest(double estimatedValue, double hypothesizedValue, double standardError);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.WilcoxonSignedRankTest : WilcoxonTest {
    [CompilerGeneratedAttribute]
private OneSampleHypothesis <Hypothesis>k__BackingField;
    public OneSampleHypothesis Hypothesis { get; protected set; }
    public WilcoxonSignedRankTest(Double[] sample, double hypothesizedMedian, OneSampleHypothesis alternate, Nullable`1<bool> exact, bool adjustForTies);
    [CompilerGeneratedAttribute]
public OneSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(OneSampleHypothesis value);
}
public class Accord.Statistics.Testing.WilcoxonTest : HypothesisTest`1<WilcoxonDistribution> {
    private bool hasTies;
    [CompilerGeneratedAttribute]
private Int32[] <Signs>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Ranks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasZeros>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExact>k__BackingField;
    public int NumberOfSamples { get; }
    public Int32[] Signs { get; protected set; }
    public Double[] Delta { get; protected set; }
    public Double[] Ranks { get; protected set; }
    public bool HasZeros { get; private set; }
    public bool HasTies { get; }
    public bool IsExact { get; private set; }
    public WilcoxonTest(Int32[] signs, Double[] diffs, DistributionTail tail);
    public int get_NumberOfSamples();
    [CompilerGeneratedAttribute]
public Int32[] get_Signs();
    [CompilerGeneratedAttribute]
protected void set_Signs(Int32[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Delta();
    [CompilerGeneratedAttribute]
protected void set_Delta(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Ranks();
    [CompilerGeneratedAttribute]
protected void set_Ranks(Double[] value);
    [CompilerGeneratedAttribute]
public bool get_HasZeros();
    [CompilerGeneratedAttribute]
private void set_HasZeros(bool value);
    public bool get_HasTies();
    [CompilerGeneratedAttribute]
public bool get_IsExact();
    [CompilerGeneratedAttribute]
private void set_IsExact(bool value);
    protected void Compute(Int32[] signs, Double[] diffs, DistributionTail tail, Nullable`1<bool> exact, bool adjustForTies);
    protected void Compute(double statistic, Double[] ranks, DistributionTail tail, Nullable`1<bool> exact);
    public virtual double StatisticToPValue(double x);
    public virtual double PValueToStatistic(double p);
}
[SerializableAttribute]
public class Accord.Statistics.Testing.ZTest : HypothesisTest`1<NormalDistribution> {
    private ZTestPowerAnalysis powerAnalysis;
    [CompilerGeneratedAttribute]
private double <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EstimatedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <HypothesizedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private DoubleRange <Confidence>k__BackingField;
    [CompilerGeneratedAttribute]
private OneSampleHypothesis <Hypothesis>k__BackingField;
    public IPowerAnalysis Analysis { get; }
    public double StandardError { get; protected set; }
    public double EstimatedValue { get; protected set; }
    public double HypothesizedValue { get; protected set; }
    public DoubleRange Confidence { get; protected set; }
    public OneSampleHypothesis Hypothesis { get; protected set; }
    public ZTest(Double[] samples, double hypothesizedMean, OneSampleHypothesis alternate);
    public ZTest(double sampleMean, double standardError, double hypothesizedMean, OneSampleHypothesis alternate);
    public ZTest(double sampleMean, double sampleStdDev, int samples, double hypothesizedMean, OneSampleHypothesis alternate);
    public ZTest(double statistic, OneSampleHypothesis alternate);
    public IPowerAnalysis get_Analysis();
    [CompilerGeneratedAttribute]
public double get_StandardError();
    [CompilerGeneratedAttribute]
protected void set_StandardError(double value);
    [CompilerGeneratedAttribute]
public double get_EstimatedValue();
    [CompilerGeneratedAttribute]
protected void set_EstimatedValue(double value);
    [CompilerGeneratedAttribute]
public double get_HypothesizedValue();
    [CompilerGeneratedAttribute]
protected void set_HypothesizedValue(double value);
    [CompilerGeneratedAttribute]
public DoubleRange get_Confidence();
    [CompilerGeneratedAttribute]
protected void set_Confidence(DoubleRange value);
    [CompilerGeneratedAttribute]
public OneSampleHypothesis get_Hypothesis();
    [CompilerGeneratedAttribute]
protected void set_Hypothesis(OneSampleHypothesis value);
    public DoubleRange GetConfidenceInterval(double percent);
    protected void Compute(double estimatedValue, double hypothesizedValue, double stdError, OneSampleHypothesis alternate);
    protected void Compute(double statistic, OneSampleHypothesis alternate);
    private void power(double stdDev, int samples);
    protected virtual void OnSizeChanged();
    public virtual double PValueToStatistic(double p);
    public virtual double StatisticToPValue(double x);
    public static double StatisticToPValue(double z, DistributionTail type);
    public static double PValueToStatistic(double p, DistributionTail type);
}
public static class Accord.Statistics.TimeSeries.TimeSeriesTools : object {
    public static Double[] AutoCorrelationFunction(Double[] vector, int nlag);
    public static Double[] Periodogram(Double[] vector);
}
[ExtensionAttribute]
public static class Accord.Statistics.Tools : object {
    [ObsoleteAttribute("Please use Classes.GetRatio instead.")]
public static Double[] Proportions(Int32[] positives, Int32[] negatives);
    [ObsoleteAttribute("Please use Classes.GetRatio instead.")]
public static Double[] Proportions(Int32[][] data, int positiveColumn, int negativeColumn);
    [ObsoleteAttribute("Please use Classes.Summarize instead.")]
public static Int32[][] Group(Int32[][] data, int labelColumn, int dataColumn);
    [ObsoleteAttribute("Please use Classes.Expand instead.")]
public static Int32[][] Expand(Int32[] data, Int32[] positives, Int32[] negatives);
    [ObsoleteAttribute("Please use Classes.Expand instead.")]
public static Int32[][] Expand(Int32[][] data, int labelColumn, int positiveColumn, int negativeColumn);
    [ObsoleteAttribute("Please use Jagged.OneHot instead.")]
public static Double[][] Expand(Int32[] labels);
    [ObsoleteAttribute("Please use Jagged.OneHot instead.")]
public static Double[][] Expand(Int32[] labels, double negative, double positive);
    [ObsoleteAttribute("Please use Jagged.OneHot instead.")]
public static Double[][] Expand(Int32[] labels, int classes);
    [ObsoleteAttribute("Please use Jagged.OneHot instead.")]
public static Double[][] Expand(Int32[] labels, int classes, double negative, double positive);
    public static double Determination(Double[] actual, Double[] expected);
    [ObsoleteAttribute("Please use Vector.Sample instead.")]
public static Int32[] RandomSample(int n, int k);
    [ObsoleteAttribute("Please use Classes.Random instead.")]
public static Int32[] RandomGroups(int size, int groups);
    [ObsoleteAttribute("Please use Classes.Random instead.")]
public static Int32[] RandomGroups(int size, double proportion);
    [ObsoleteAttribute("Please use Classes.Random instead.")]
public static Int32[] RandomGroups(Int32[] labels, int classes, int groups);
    [ObsoleteAttribute("Please use Vector.Sample instead.")]
public static Int32[] Random(int n);
    [ObsoleteAttribute("Please use Vector.Shuffle instead.")]
public static void Shuffle(T[] array);
    [ObsoleteAttribute("Please use Vector.Shuffle instead.")]
public static void Shuffle(IList`1<T> array);
    public static Double[0...,0...] Whitening(Double[0...,0...] value, Double[0...,0...]& transformMatrix);
    public static Double[][] Whitening(Double[][] value, Double[][]& transformMatrix);
    [ExtensionAttribute]
public static TDistribution Fit(Double[] observations, Double[] weights);
    [ExtensionAttribute]
public static TDistribution Fit(Double[][] observations, Double[] weights);
    [ExtensionAttribute]
public static TDistribution Fit(Double[] observations, TOptions options, Double[] weights);
    [ExtensionAttribute]
public static TDistribution Fit(Double[][] observations, TOptions options, Double[] weights);
    [ExtensionAttribute]
public static TDistribution FitNew(TDistribution distribution, TObservations[] observations, Double[] weights);
    [ExtensionAttribute]
public static TDistribution FitNew(TDistribution distribution, TObservations[] observations, TOptions options, Double[] weights);
    [ExtensionAttribute]
public static DoubleRange InnerFence(DoubleRange quartiles);
    [ExtensionAttribute]
public static DoubleRange OuterFence(DoubleRange quartiles);
    [ExtensionAttribute]
public static Double[] Rank(Double[] samples, bool alreadySorted, bool adjustForTies);
    [ExtensionAttribute]
public static Double[] Rank(Double[] samples, Boolean& hasTies, bool alreadySorted, bool adjustForTies);
    [ExtensionAttribute]
public static Int32[] Ties(Double[] ranks);
    [ExtensionAttribute]
public static Int32[] Ties(Double[] ranks, SortedDictionary`2& counts);
    public static Double[0...,0...] RandomCovariance(int size, double minValue, double maxValue);
    [ExtensionAttribute]
public static double Distance(IKernel kernel, Double[] x, Double[] y);
    [ExtensionAttribute]
public static Double[0...,0...] ZScores(Double[0...,0...] matrix);
    [ExtensionAttribute]
public static Double[0...,0...] ZScores(Double[0...,0...] matrix, Double[] means, Double[] standardDeviations);
    [ExtensionAttribute]
public static Double[][] ZScores(Double[][] matrix);
    [ExtensionAttribute]
public static Double[][] ZScores(Double[][] matrix, Double[] means, Double[] standardDeviations);
    [ExtensionAttribute]
public static Double[] Center(Double[] observation, Double[] result);
    [ExtensionAttribute]
public static Double[] Center(Double[] values, double mean, Double[] result);
    [ExtensionAttribute]
public static Double[0...,0...] Center(Double[0...,0...] matrix, bool inPlace);
    [ExtensionAttribute]
public static Double[0...,0...] Center(Double[0...,0...] matrix, Double[] means, bool inPlace);
    [ExtensionAttribute]
public static Double[][] Center(Double[][] matrix, bool inPlace);
    [ExtensionAttribute]
public static Double[][] Center(Double[][] matrix, Double[] means, bool inPlace);
    [ExtensionAttribute]
public static Double[] Standardize(Double[] values, bool inPlace);
    [ExtensionAttribute]
public static Double[] Standardize(Double[] values, double standardDeviation, bool inPlace);
    [ExtensionAttribute]
public static Double[0...,0...] Standardize(Double[0...,0...] matrix, bool inPlace);
    [ExtensionAttribute]
public static Double[0...,0...] Standardize(Double[0...,0...] matrix, Double[] standardDeviations, bool inPlace, double tol);
    [ExtensionAttribute]
public static Double[][] Standardize(Double[][] matrix, bool inPlace);
    [ExtensionAttribute]
public static Double[][] Standardize(Double[][] matrix, Double[] standardDeviations, bool inPlace, double tol);
}
public enum Accord.Statistics.Visualizations.BinAdjustmentRule : Enum {
    public int value__;
    public static BinAdjustmentRule None;
    public static BinAdjustmentRule Scott;
    public static BinAdjustmentRule Sturges;
    public static BinAdjustmentRule SquareRoot;
}
[DefaultMemberAttribute("Item")]
[SerializableAttribute]
public class Accord.Statistics.Visualizations.Histogram : object {
    private Int32[] values;
    private Double[] ranges;
    private bool cumulative;
    private bool inclusiveUpperBound;
    private HistogramBinCollection binCollection;
    private BinAdjustmentRule rule;
    private bool uniform;
    private Nullable`1<double> mean;
    private Nullable`1<double> stdDev;
    private Nullable`1<int> median;
    private Nullable`1<int> min;
    private Nullable`1<int> max;
    private Nullable`1<long> total;
    public int Item { get; public set; }
    public Int32[] Values { get; }
    public DoubleRange Range { get; }
    public Double[] Edges { get; }
    public HistogramBinCollection Bins { get; }
    public bool Cumulative { get; public set; }
    public BinAdjustmentRule AutoAdjustmentRule { get; public set; }
    public double Mean { get; }
    public double StdDev { get; }
    public int Median { get; }
    public int Min { get; }
    public int Max { get; }
    public long TotalCount { get; }
    public bool InclusiveUpperBound { get; public set; }
    [ObsoleteAttribute("Please use Histogram.FromData instead.")]
public Histogram(Double[] values);
    public Histogram(Int32[] values);
    private void initialize(int numberOfBins);
    private void initialize(double startValue, double width);
    public void Update();
    public int get_Item(int index);
    public void set_Item(int index, int value);
    public Int32[] get_Values();
    public DoubleRange get_Range();
    public Double[] get_Edges();
    public HistogramBinCollection get_Bins();
    public bool get_Cumulative();
    public void set_Cumulative(bool value);
    public BinAdjustmentRule get_AutoAdjustmentRule();
    public void set_AutoAdjustmentRule(BinAdjustmentRule value);
    public double get_Mean();
    public double get_StdDev();
    public int get_Median();
    public int get_Min();
    public int get_Max();
    public long get_TotalCount();
    public bool get_InclusiveUpperBound();
    public void set_InclusiveUpperBound(bool value);
    public IntRange GetRange(double percent);
    public void Compute(Double[] values, double binWidth);
    public void Compute(Double[] values, int numberOfBins);
    public void Compute(Double[] values, int numberOfBins, bool extraUpperBin);
    public void Compute(Double[] values, int numberOfBins, double binWidth);
    public void Compute(Double[] values);
    private void compute(Double[] values);
    public static int NumberOfBins(Double[] values, DoubleRange range, BinAdjustmentRule rule);
    public static Int32[] op_Implicit(Histogram value);
    public Int32[] ToArray();
    public Histogram FromData(Double[] values);
    public Histogram Subtract(Histogram histogram);
    public Histogram Subtract(Int32[] histogram);
    public Histogram Add(Histogram histogram);
    public Histogram Add(Int32[] histogram);
    public Histogram Multiply(Int32[] histogram);
    public Histogram Multiply(int value);
    public Histogram Add(int value);
    public Histogram Subtract(int value);
    public sealed virtual object Clone();
}
[SerializableAttribute]
public class Accord.Statistics.Visualizations.HistogramBin : object {
    private int index;
    private Histogram histogram;
    public DoubleRange Range { get; }
    public double Width { get; }
    public int Value { get; public set; }
    internal HistogramBin(Histogram histogram, int index);
    public DoubleRange get_Range();
    public double get_Width();
    public int get_Value();
    public void set_Value(int value);
    public bool Contains(double value);
}
[SerializableAttribute]
public class Accord.Statistics.Visualizations.HistogramBinCollection : ReadOnlyCollection`1<HistogramBin> {
    internal HistogramBinCollection(HistogramBin[] objects);
    public HistogramBin Search(double value);
    public int SearchIndex(double value);
}
[SerializableAttribute]
public class Accord.Statistics.Visualizations.Scatterplot : object {
    private string title;
    private string xAxisTitle;
    private string yAxisTitle;
    private string labelTitle;
    [CompilerGeneratedAttribute]
private Double[] <XAxis>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <YAxis>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <LabelAxis>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <LabelValues>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <LabelNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ScatterplotClassValueCollection> <Classes>k__BackingField;
    public string Title { get; public set; }
    public string XAxisTitle { get; public set; }
    public string YAxisTitle { get; public set; }
    public string LabelAxisTitle { get; public set; }
    public Double[] XAxis { get; private set; }
    public Double[] YAxis { get; private set; }
    public Int32[] LabelAxis { get; private set; }
    internal Int32[] LabelValues { get; private set; }
    public String[] LabelNames { get; private set; }
    public ReadOnlyCollection`1<ScatterplotClassValueCollection> Classes { get; private set; }
    public Scatterplot(string title);
    public Scatterplot(string title, string xAxisTitle, string yAxisTitle);
    public Scatterplot(string title, string xAxisTitle, string yAxisTitle, string labelTitle);
    public string get_Title();
    public void set_Title(string value);
    public string get_XAxisTitle();
    public void set_XAxisTitle(string value);
    public string get_YAxisTitle();
    public void set_YAxisTitle(string value);
    public string get_LabelAxisTitle();
    public void set_LabelAxisTitle(string value);
    [CompilerGeneratedAttribute]
public Double[] get_XAxis();
    [CompilerGeneratedAttribute]
private void set_XAxis(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_YAxis();
    [CompilerGeneratedAttribute]
private void set_YAxis(Double[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_LabelAxis();
    [CompilerGeneratedAttribute]
private void set_LabelAxis(Int32[] value);
    [CompilerGeneratedAttribute]
internal Int32[] get_LabelValues();
    [CompilerGeneratedAttribute]
private void set_LabelValues(Int32[] value);
    [CompilerGeneratedAttribute]
public String[] get_LabelNames();
    [CompilerGeneratedAttribute]
private void set_LabelNames(String[] value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ScatterplotClassValueCollection> get_Classes();
    [CompilerGeneratedAttribute]
private void set_Classes(ReadOnlyCollection`1<ScatterplotClassValueCollection> value);
    private void initialize(Double[] x, Double[] y, Int32[] z);
    public void Compute(Double[] values);
    public void Compute(Double[] x, Double[] y);
    public void Compute(Double[] x, Double[] y, Int32[] labels);
    public void Compute(Double[][] data);
    public void Compute(Double[][] data, Int32[] labels);
    public void Compute(Double[0...,0...] data);
    public void Compute(Double[0...,0...] data, Int32[] labels);
    private void compute(Double[0...,0...] data, Int32[] labels);
    private void compute(Double[][] data, Int32[] labels);
}
[SerializableAttribute]
public class Accord.Statistics.Visualizations.ScatterplotClassValueCollection : object {
    private Scatterplot parent;
    private int index;
    public int Label { get; }
    public Int32[] Indices { get; }
    public Double[] XAxis { get; }
    public Double[] YAxis { get; }
    public string Text { get; public set; }
    internal ScatterplotClassValueCollection(Scatterplot parent, int index);
    public int get_Label();
    public Int32[] get_Indices();
    public Double[] get_XAxis();
    public Double[] get_YAxis();
    public string get_Text();
    public void set_Text(string value);
    [IteratorStateMachineAttribute("Accord.Statistics.Visualizations.ScatterplotClassValueCollection/<GetEnumerator>d__14")]
public sealed virtual IEnumerator`1<DoublePoint> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private bool <get_Indices>b__5_0(int x);
}
