public class Aerospike.Client.AdminCommand : object {
    private static byte AUTHENTICATE;
    private static byte CREATE_USER;
    private static byte DROP_USER;
    private static byte SET_PASSWORD;
    private static byte CHANGE_PASSWORD;
    private static byte GRANT_ROLES;
    private static byte REVOKE_ROLES;
    private static byte QUERY_USERS;
    private static byte CREATE_ROLE;
    private static byte DROP_ROLE;
    private static byte GRANT_PRIVILEGES;
    private static byte REVOKE_PRIVILEGES;
    private static byte SET_WHITELIST;
    private static byte SET_QUOTAS;
    private static byte QUERY_ROLES;
    private static byte LOGIN;
    private static byte USER;
    private static byte PASSWORD;
    private static byte OLD_PASSWORD;
    private static byte CREDENTIAL;
    private static byte CLEAR_PASSWORD;
    private static byte SESSION_TOKEN;
    private static byte SESSION_TTL;
    private static byte ROLES;
    private static byte ROLE;
    private static byte PRIVILEGES;
    private static byte WHITELIST;
    private static byte READ_QUOTA;
    private static byte WRITE_QUOTA;
    private static byte READ_INFO;
    private static byte WRITE_INFO;
    private static byte CONNECTIONS;
    private static ulong MSG_VERSION;
    private static ulong MSG_TYPE;
    private static int FIELD_HEADER_SIZE;
    private static int HEADER_SIZE;
    private static int HEADER_REMAINING;
    private static int RESULT_CODE;
    private static int QUERY_END;
    private Byte[] dataBuffer;
    private int dataOffset;
    private int dataBegin;
    public AdminCommand(Byte[] dataBuffer, int dataOffset);
    public void Login(Cluster cluster, Connection conn, Byte[]& sessionToken, Nullable`1& sessionExpiration);
    public static bool Authenticate(Cluster cluster, Connection conn, Byte[] sessionToken);
    public bool AuthenticateSession(Cluster cluster, Connection conn, Byte[] sessionToken);
    public int SetAuthenticate(Cluster cluster, Byte[] sessionToken);
    public void CreateUser(Cluster cluster, AdminPolicy policy, string user, string password, IList`1<string> roles);
    public void DropUser(Cluster cluster, AdminPolicy policy, string user);
    public void SetPassword(Cluster cluster, AdminPolicy policy, Byte[] user, string password);
    public void ChangePassword(Cluster cluster, AdminPolicy policy, Byte[] user, string password);
    public void GrantRoles(Cluster cluster, AdminPolicy policy, string user, IList`1<string> roles);
    public void RevokeRoles(Cluster cluster, AdminPolicy policy, string user, IList`1<string> roles);
    public void CreateRole(Cluster cluster, AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public void CreateRole(Cluster cluster, AdminPolicy policy, string roleName, IList`1<Privilege> privileges, IList`1<string> whitelist, int readQuota, int writeQuota);
    public void DropRole(Cluster cluster, AdminPolicy policy, string roleName);
    public void GrantPrivileges(Cluster cluster, AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public void RevokePrivileges(Cluster cluster, AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public void SetWhitelist(Cluster cluster, AdminPolicy policy, string roleName, IList`1<string> whitelist);
    public void setQuotas(Cluster cluster, AdminPolicy policy, string roleName, int readQuota, int writeQuota);
    private void WriteRoles(IList`1<string> roles);
    private void WritePrivileges(IList`1<Privilege> privileges);
    private void WriteWhitelist(IList`1<string> whitelist);
    private void WriteSize();
    private void WriteHeader(byte command, byte fieldCount);
    private void WriteField(byte id, string str);
    private void WriteField(byte id, Byte[] bytes);
    private void WriteField(byte id, int val);
    private void WriteFieldHeader(byte id, int size);
    private void ExecuteCommand(Cluster cluster, AdminPolicy policy);
    private void ExecuteQuery(Cluster cluster, AdminPolicy policy);
    private int ReadBlocks(Connection conn);
    public static string HashPassword(string password);
    internal virtual int ParseBlock(int receiveSize);
}
public class Aerospike.Client.AdminPolicy : object {
    public int timeout;
    public AdminPolicy(AdminPolicy other);
}
public class Aerospike.Client.AerospikeClient : object {
    protected internal Cluster cluster;
    public Policy readPolicyDefault;
    public WritePolicy writePolicyDefault;
    public ScanPolicy scanPolicyDefault;
    public QueryPolicy queryPolicyDefault;
    public BatchPolicy batchPolicyDefault;
    public BatchPolicy batchParentPolicyWriteDefault;
    public BatchWritePolicy batchWritePolicyDefault;
    public BatchDeletePolicy batchDeletePolicyDefault;
    public BatchUDFPolicy batchUDFPolicyDefault;
    public InfoPolicy infoPolicyDefault;
    protected WritePolicy operatePolicyReadDefault;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public Policy ReadPolicyDefault { get; public set; }
    public WritePolicy WritePolicyDefault { get; public set; }
    public ScanPolicy ScanPolicyDefault { get; public set; }
    public QueryPolicy QueryPolicyDefault { get; public set; }
    public BatchPolicy BatchPolicyDefault { get; public set; }
    public BatchPolicy BatchParentPolicyWriteDefault { get; public set; }
    public BatchWritePolicy BatchWritePolicyDefault { get; public set; }
    public BatchDeletePolicy BatchDeletePolicyDefault { get; public set; }
    public BatchUDFPolicy BatchUDFPolicyDefault { get; public set; }
    public InfoPolicy InfoPolicyDefault { get; public set; }
    public bool Disposed { get; private set; }
    public bool Connected { get; }
    public Cluster Cluster { get; }
    public Node[] Nodes { get; }
    public AerospikeClient(string hostname, int port);
    public AerospikeClient(ClientPolicy policy, string hostname, int port);
    public AerospikeClient(ClientPolicy policy, Host[] hosts);
    protected internal AerospikeClient(ClientPolicy policy);
    public sealed virtual Policy get_ReadPolicyDefault();
    public sealed virtual void set_ReadPolicyDefault(Policy value);
    public sealed virtual WritePolicy get_WritePolicyDefault();
    public sealed virtual void set_WritePolicyDefault(WritePolicy value);
    public sealed virtual ScanPolicy get_ScanPolicyDefault();
    public sealed virtual void set_ScanPolicyDefault(ScanPolicy value);
    public sealed virtual QueryPolicy get_QueryPolicyDefault();
    public sealed virtual void set_QueryPolicyDefault(QueryPolicy value);
    public sealed virtual BatchPolicy get_BatchPolicyDefault();
    public sealed virtual void set_BatchPolicyDefault(BatchPolicy value);
    public sealed virtual BatchPolicy get_BatchParentPolicyWriteDefault();
    public sealed virtual void set_BatchParentPolicyWriteDefault(BatchPolicy value);
    public sealed virtual BatchWritePolicy get_BatchWritePolicyDefault();
    public sealed virtual void set_BatchWritePolicyDefault(BatchWritePolicy value);
    public sealed virtual BatchDeletePolicy get_BatchDeletePolicyDefault();
    public sealed virtual void set_BatchDeletePolicyDefault(BatchDeletePolicy value);
    public sealed virtual BatchUDFPolicy get_BatchUDFPolicyDefault();
    public sealed virtual void set_BatchUDFPolicyDefault(BatchUDFPolicy value);
    public sealed virtual InfoPolicy get_InfoPolicyDefault();
    public sealed virtual void set_InfoPolicyDefault(InfoPolicy value);
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual bool get_Connected();
    public sealed virtual Cluster get_Cluster();
    public sealed virtual Node[] get_Nodes();
    public sealed virtual void EnableMetrics(MetricsPolicy metricsPolicy);
    public sealed virtual void DisableMetrics();
    public sealed virtual ClusterStats GetClusterStats();
    public sealed virtual void Put(WritePolicy policy, Key key, Bin[] bins);
    public sealed virtual void Append(WritePolicy policy, Key key, Bin[] bins);
    public sealed virtual void Prepend(WritePolicy policy, Key key, Bin[] bins);
    public sealed virtual void Add(WritePolicy policy, Key key, Bin[] bins);
    public sealed virtual bool Delete(WritePolicy policy, Key key);
    public sealed virtual BatchResults Delete(BatchPolicy batchPolicy, BatchDeletePolicy deletePolicy, Key[] keys);
    public sealed virtual void Truncate(InfoPolicy policy, string ns, string set, Nullable`1<DateTime> beforeLastUpdate);
    public sealed virtual void Touch(WritePolicy policy, Key key);
    public sealed virtual bool Exists(Policy policy, Key key);
    public sealed virtual Boolean[] Exists(BatchPolicy policy, Key[] keys);
    public sealed virtual Record Get(Policy policy, Key key);
    public sealed virtual Record Get(Policy policy, Key key, String[] binNames);
    public sealed virtual Record GetHeader(Policy policy, Key key);
    public sealed virtual bool Get(BatchPolicy policy, List`1<BatchRead> records);
    public sealed virtual Record[] Get(BatchPolicy policy, Key[] keys);
    public sealed virtual Record[] Get(BatchPolicy policy, Key[] keys, String[] binNames);
    public sealed virtual Record[] Get(BatchPolicy policy, Key[] keys, Operation[] ops);
    public sealed virtual Record[] GetHeader(BatchPolicy policy, Key[] keys);
    public sealed virtual Record Join(BatchPolicy policy, Key key, String[] binNames, Join[] joins);
    public sealed virtual Record Join(BatchPolicy policy, Key key, Join[] joins);
    public sealed virtual Record Operate(WritePolicy policy, Key key, Operation[] operations);
    public sealed virtual bool Operate(BatchPolicy policy, List`1<BatchRecord> records);
    public sealed virtual BatchResults Operate(BatchPolicy batchPolicy, BatchWritePolicy writePolicy, Key[] keys, Operation[] ops);
    public sealed virtual void ScanAll(ScanPolicy policy, string ns, string setName, ScanCallback callback, String[] binNames);
    public sealed virtual void ScanNode(ScanPolicy policy, string nodeName, string ns, string setName, ScanCallback callback, String[] binNames);
    public sealed virtual void ScanNode(ScanPolicy policy, Node node, string ns, string setName, ScanCallback callback, String[] binNames);
    public sealed virtual void ScanPartitions(ScanPolicy policy, PartitionFilter partitionFilter, string ns, string setName, ScanCallback callback, String[] binNames);
    public sealed virtual RegisterTask Register(Policy policy, string clientPath, string serverPath, Language language);
    public sealed virtual RegisterTask Register(Policy policy, Assembly resourceAssembly, string resourcePath, string serverPath, Language language);
    public sealed virtual RegisterTask RegisterUdfString(Policy policy, string code, string serverPath, Language language);
    public sealed virtual void RemoveUdf(InfoPolicy policy, string serverPath);
    public sealed virtual object Execute(WritePolicy policy, Key key, string packageName, string functionName, Value[] args);
    public sealed virtual BatchResults Execute(BatchPolicy batchPolicy, BatchUDFPolicy udfPolicy, Key[] keys, string packageName, string functionName, Value[] functionArgs);
    public sealed virtual ExecuteTask Execute(WritePolicy policy, Statement statement, string packageName, string functionName, Value[] functionArgs);
    public sealed virtual ExecuteTask Execute(WritePolicy policy, Statement statement, Operation[] operations);
    public sealed virtual void Query(QueryPolicy policy, Statement statement, Action`2<Key, Record> action);
    public sealed virtual RecordSet Query(QueryPolicy policy, Statement statement);
    public sealed virtual void Query(QueryPolicy policy, Statement statement, QueryListener listener);
    public sealed virtual void Query(QueryPolicy policy, Statement statement, PartitionFilter partitionFilter, QueryListener listener);
    public sealed virtual RecordSet QueryPartitions(QueryPolicy policy, Statement statement, PartitionFilter partitionFilter);
    public sealed virtual ResultSet QueryAggregate(QueryPolicy policy, Statement statement, string packageName, string functionName, Value[] functionArgs);
    public sealed virtual void QueryAggregate(QueryPolicy policy, Statement statement, Action`1<object> action);
    public sealed virtual ResultSet QueryAggregate(QueryPolicy policy, Statement statement);
    public sealed virtual IndexTask CreateIndex(Policy policy, string ns, string setName, string indexName, string binName, IndexType indexType);
    public sealed virtual IndexTask CreateIndex(Policy policy, string ns, string setName, string indexName, string binName, IndexType indexType, IndexCollectionType indexCollectionType, CTX[] ctx);
    public sealed virtual IndexTask DropIndex(Policy policy, string ns, string setName, string indexName);
    public sealed virtual void SetXDRFilter(InfoPolicy policy, string datacenter, string ns, Expression filter);
    public sealed virtual void CreateUser(AdminPolicy policy, string user, string password, IList`1<string> roles);
    public sealed virtual void DropUser(AdminPolicy policy, string user);
    public sealed virtual void ChangePassword(AdminPolicy policy, string user, string password);
    public sealed virtual void GrantRoles(AdminPolicy policy, string user, IList`1<string> roles);
    public sealed virtual void RevokeRoles(AdminPolicy policy, string user, IList`1<string> roles);
    public sealed virtual void CreateRole(AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public sealed virtual void CreateRole(AdminPolicy policy, string roleName, IList`1<Privilege> privileges, IList`1<string> whitelist);
    public sealed virtual void CreateRole(AdminPolicy policy, string roleName, IList`1<Privilege> privileges, IList`1<string> whitelist, int readQuota, int writeQuota);
    public sealed virtual void DropRole(AdminPolicy policy, string roleName);
    public sealed virtual void GrantPrivileges(AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public sealed virtual void RevokePrivileges(AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public sealed virtual void SetWhitelist(AdminPolicy policy, string roleName, IList`1<string> whitelist);
    public sealed virtual void SetQuotas(AdminPolicy policy, string roleName, int readQuota, int writeQuota);
    public sealed virtual User QueryUser(AdminPolicy policy, string user);
    public sealed virtual List`1<User> QueryUsers(AdminPolicy policy);
    public sealed virtual Role QueryRole(AdminPolicy policy, string roleName);
    public sealed virtual List`1<Role> QueryRoles(AdminPolicy policy);
    private string SendInfoCommand(Policy policy, string command);
    private void ParseInfoError(string prefix, string response);
    private void JoinRecords(BatchPolicy policy, Record record, Join[] joins);
}
public class Aerospike.Client.AerospikeException : Exception {
    protected Node node;
    protected Policy policy;
    protected int resultCode;
    protected int iteration;
    protected bool inDoubt;
    public string Message { get; }
    public string BaseMessage { get; }
    public Node Node { get; public set; }
    public Policy Policy { get; public set; }
    public int Result { get; }
    public int Iteration { get; public set; }
    public bool InDoubt { get; }
    public AerospikeException(int resultCode, string message, Exception inner);
    public AerospikeException(int resultCode, Exception e);
    public AerospikeException(int resultCode);
    public AerospikeException(int resultCode, bool inDoubt, Exception inner);
    public AerospikeException(string message, Exception e);
    public AerospikeException(string message);
    public AerospikeException(Exception e);
    public virtual string get_Message();
    public string get_BaseMessage();
    public bool KeepConnection();
    public Node get_Node();
    public void set_Node(Node value);
    public bool ShouldSerializeNode();
    public Policy get_Policy();
    public void set_Policy(Policy value);
    public int get_Result();
    public int get_Iteration();
    public void set_Iteration(int value);
    public bool get_InDoubt();
    internal void SetInDoubt(bool isWrite, int commandSentCounter);
    internal AerospikeException SetInDoubt(bool inDoubt);
}
internal class Aerospike.Client.AsyncBatch : object {
    internal static void OnRecord(Cluster cluster, BatchRecordSequenceListener listener, BatchRecord record, int index);
}
public abstract class Aerospike.Client.AsyncBatchCommand : AsyncMultiCommand {
    internal AsyncBatchExecutor parent;
    internal BatchNode batch;
    internal BatchPolicy batchPolicy;
    internal UInt32 sequenceAP;
    internal UInt32 sequenceSC;
    public AsyncBatchCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, bool isOperation);
    public AsyncBatchCommand(AsyncBatchCommand other);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual bool RetryBatch();
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
    internal virtual void SetInDoubt(bool inDoubt);
    internal abstract virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal abstract virtual List`1<BatchNode> GenerateBatchNodes();
}
public abstract class Aerospike.Client.AsyncBatchExecutor : object {
    private AerospikeException exception;
    private int max;
    private int count;
    private bool hasResultCode;
    private bool error;
    public AsyncBatchExecutor(AsyncCluster cluster, bool hasResultCode);
    public void Execute(AsyncBatchCommand[] commands);
    public void Retry(AsyncMultiCommand[] commands);
    public void ChildSuccess(AsyncNode node);
    public void ChildFailure(AerospikeException ae);
    private void Finish();
    public virtual void BatchKeyError(Cluster cluster, Key key, int index, AerospikeException ae, bool inDoubt, bool hasWrite);
    public sealed virtual void BatchKeyError(AerospikeException ae);
    public void SetRowError();
    public bool GetStatus();
    protected internal abstract virtual void OnSuccess();
    protected internal abstract virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchExistsArrayCommand : AsyncBatchCommand {
    private Key[] keys;
    private Boolean[] existsArray;
    public AsyncBatchExistsArrayCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, Boolean[] existsArray);
    public AsyncBatchExistsArrayCommand(AsyncBatchExistsArrayCommand other);
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchExistsArrayExecutor : AsyncBatchExecutor {
    private Key[] keys;
    private Boolean[] existsArray;
    private ExistsArrayListener listener;
    public AsyncBatchExistsArrayExecutor(AsyncCluster cluster, BatchPolicy policy, Key[] keys, ExistsArrayListener listener);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchExistsSequenceCommand : AsyncBatchCommand {
    private Key[] keys;
    private ExistsSequenceListener listener;
    public AsyncBatchExistsSequenceCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, ExistsSequenceListener listener);
    public AsyncBatchExistsSequenceCommand(AsyncBatchExistsSequenceCommand other);
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchExistsSequenceExecutor : AsyncBatchExecutor {
    private ExistsSequenceListener listener;
    public AsyncBatchExistsSequenceExecutor(AsyncCluster cluster, BatchPolicy policy, Key[] keys, ExistsSequenceListener listener);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchGetArrayCommand : AsyncBatchCommand {
    private Key[] keys;
    private String[] binNames;
    private Operation[] ops;
    private Record[] records;
    private int readAttr;
    public AsyncBatchGetArrayCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, String[] binNames, Operation[] ops, Record[] records, int readAttr, bool isOperation);
    public AsyncBatchGetArrayCommand(AsyncBatchGetArrayCommand other);
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchGetArrayExecutor : AsyncBatchExecutor {
    private Key[] keys;
    private Record[] records;
    private RecordArrayListener listener;
    public AsyncBatchGetArrayExecutor(AsyncCluster cluster, BatchPolicy policy, RecordArrayListener listener, Key[] keys, String[] binNames, Operation[] ops, int readAttr, bool isOperation);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchGetSequenceCommand : AsyncBatchCommand {
    private Key[] keys;
    private String[] binNames;
    private Operation[] ops;
    private RecordSequenceListener listener;
    private int readAttr;
    public AsyncBatchGetSequenceCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, String[] binNames, Operation[] ops, RecordSequenceListener listener, int readAttr, bool isOperation);
    public AsyncBatchGetSequenceCommand(AsyncBatchGetSequenceCommand other);
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchGetSequenceExecutor : AsyncBatchExecutor {
    private RecordSequenceListener listener;
    public AsyncBatchGetSequenceExecutor(AsyncCluster cluster, BatchPolicy policy, RecordSequenceListener listener, Key[] keys, String[] binNames, Operation[] ops, int readAttr, bool isOperation);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchOperateListCommand : AsyncBatchCommand {
    internal List`1<BatchRecord> records;
    public AsyncBatchOperateListCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, List`1<BatchRecord> records);
    public AsyncBatchOperateListCommand(AsyncBatchOperateListCommand other);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchOperateListExecutor : AsyncBatchExecutor {
    internal BatchOperateListListener listener;
    internal List`1<BatchRecord> records;
    public AsyncBatchOperateListExecutor(AsyncCluster cluster, BatchPolicy policy, BatchOperateListListener listener, List`1<BatchRecord> records);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchOperateRecordArrayCommand : AsyncBatchCommand {
    internal Key[] keys;
    internal Operation[] ops;
    internal BatchRecord[] records;
    internal BatchAttr attr;
    public AsyncBatchOperateRecordArrayCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, Operation[] ops, BatchRecord[] records, BatchAttr attr);
    public AsyncBatchOperateRecordArrayCommand(AsyncBatchOperateRecordArrayCommand other);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchOperateRecordArrayExecutor : AsyncBatchExecutor {
    internal BatchRecordArrayListener listener;
    internal BatchRecord[] records;
    public AsyncBatchOperateRecordArrayExecutor(AsyncCluster cluster, BatchPolicy policy, BatchRecordArrayListener listener, Key[] keys, Operation[] ops, BatchAttr attr);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchOperateRecordSequenceCommand : AsyncBatchCommand {
    internal Key[] keys;
    internal Operation[] ops;
    internal Boolean[] sent;
    internal BatchRecordSequenceListener listener;
    internal BatchAttr attr;
    public AsyncBatchOperateRecordSequenceCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, Operation[] ops, Boolean[] sent, BatchRecordSequenceListener listener, BatchAttr attr);
    public AsyncBatchOperateRecordSequenceCommand(AsyncBatchOperateRecordSequenceCommand other);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchOperateRecordSequenceExecutor : AsyncBatchExecutor {
    internal BatchRecordSequenceListener listener;
    private Boolean[] sent;
    public AsyncBatchOperateRecordSequenceExecutor(AsyncCluster cluster, BatchPolicy policy, BatchRecordSequenceListener listener, Key[] keys, Operation[] ops, BatchAttr attr);
    public virtual void BatchKeyError(Cluster cluster, Key key, int index, AerospikeException ae, bool inDoubt, bool hasWrite);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchOperateSequenceCommand : AsyncBatchCommand {
    internal BatchRecordSequenceListener listener;
    internal List`1<BatchRecord> records;
    public AsyncBatchOperateSequenceCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, BatchRecordSequenceListener listener, List`1<BatchRecord> records);
    public AsyncBatchOperateSequenceCommand(AsyncBatchOperateSequenceCommand other);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchOperateSequenceExecutor : AsyncBatchExecutor {
    internal BatchRecordSequenceListener listener;
    public AsyncBatchOperateSequenceExecutor(AsyncCluster cluster, BatchPolicy policy, BatchRecordSequenceListener listener, List`1<BatchRecord> records);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchReadListCommand : AsyncBatchCommand {
    private List`1<BatchRead> records;
    public AsyncBatchReadListCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, List`1<BatchRead> records);
    public AsyncBatchReadListCommand(AsyncBatchReadListCommand other);
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchReadListExecutor : AsyncBatchExecutor {
    private BatchListListener listener;
    private List`1<BatchRead> records;
    public AsyncBatchReadListExecutor(AsyncCluster cluster, BatchPolicy policy, BatchListListener listener, List`1<BatchRead> records);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchReadSequenceCommand : AsyncBatchCommand {
    private BatchSequenceListener listener;
    private List`1<BatchRead> records;
    public AsyncBatchReadSequenceCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, BatchSequenceListener listener, List`1<BatchRead> records);
    public AsyncBatchReadSequenceCommand(AsyncBatchReadSequenceCommand other);
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchReadSequenceExecutor : AsyncBatchExecutor {
    private BatchSequenceListener listener;
    public AsyncBatchReadSequenceExecutor(AsyncCluster cluster, BatchPolicy policy, BatchSequenceListener listener, List`1<BatchRead> records);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.AsyncBatchUDFArrayCommand : AsyncBatchCommand {
    internal Key[] keys;
    internal string packageName;
    internal string functionName;
    internal Byte[] argBytes;
    internal BatchRecord[] records;
    internal BatchAttr attr;
    public AsyncBatchUDFArrayCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, string packageName, string functionName, Byte[] argBytes, BatchRecord[] records, BatchAttr attr);
    public AsyncBatchUDFArrayCommand(AsyncBatchUDFArrayCommand other);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchUDFArrayExecutor : AsyncBatchExecutor {
    internal BatchRecordArrayListener listener;
    internal BatchRecord[] recordArray;
    public AsyncBatchUDFArrayExecutor(AsyncCluster cluster, BatchPolicy policy, BatchRecordArrayListener listener, Key[] keys, string packageName, string functionName, Byte[] argBytes, BatchAttr attr);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.AsyncBatchUDFSequenceCommand : AsyncBatchCommand {
    internal Key[] keys;
    internal string packageName;
    internal string functionName;
    internal Byte[] argBytes;
    internal Boolean[] sent;
    internal BatchRecordSequenceListener listener;
    internal BatchAttr attr;
    public AsyncBatchUDFSequenceCommand(AsyncBatchExecutor parent, AsyncCluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, string packageName, string functionName, Byte[] argBytes, Boolean[] sent, BatchRecordSequenceListener listener, BatchAttr attr);
    public AsyncBatchUDFSequenceCommand(AsyncBatchUDFSequenceCommand other);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual AsyncCommand CloneCommand();
    internal virtual AsyncBatchCommand CreateCommand(BatchNode batchNode);
    internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.AsyncBatchUDFSequenceExecutor : AsyncBatchExecutor {
    internal BatchRecordSequenceListener listener;
    private Boolean[] sent;
    public AsyncBatchUDFSequenceExecutor(AsyncCluster cluster, BatchPolicy policy, BatchRecordSequenceListener listener, Key[] keys, string packageName, string functionName, Byte[] argBytes, BatchAttr attr);
    public virtual void BatchKeyError(Cluster cluster, Key key, int index, AerospikeException ae, bool inDoubt, bool hasWrite);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.AsyncClient : AerospikeClient {
    private AsyncCluster cluster;
    public AsyncClient(string hostname, int port);
    public AsyncClient(AsyncClientPolicy policy, string hostname, int port);
    public AsyncClient(AsyncClientPolicy policy, Host[] hosts);
    public sealed virtual Task Put(WritePolicy policy, CancellationToken token, Key key, Bin[] bins);
    public sealed virtual void Put(WritePolicy policy, WriteListener listener, Key key, Bin[] bins);
    public sealed virtual Task Append(WritePolicy policy, CancellationToken token, Key key, Bin[] bins);
    public sealed virtual void Append(WritePolicy policy, WriteListener listener, Key key, Bin[] bins);
    public sealed virtual Task Prepend(WritePolicy policy, CancellationToken token, Key key, Bin[] bins);
    public sealed virtual void Prepend(WritePolicy policy, WriteListener listener, Key key, Bin[] bins);
    public sealed virtual Task Add(WritePolicy policy, CancellationToken token, Key key, Bin[] bins);
    public sealed virtual void Add(WritePolicy policy, WriteListener listener, Key key, Bin[] bins);
    public sealed virtual Task`1<bool> Delete(WritePolicy policy, CancellationToken token, Key key);
    public sealed virtual void Delete(WritePolicy policy, DeleteListener listener, Key key);
    public sealed virtual Task`1<BatchResults> Delete(BatchPolicy batchPolicy, BatchDeletePolicy deletePolicy, CancellationToken token, Key[] keys);
    public sealed virtual void Delete(BatchPolicy batchPolicy, BatchDeletePolicy deletePolicy, BatchRecordArrayListener listener, Key[] keys);
    public sealed virtual void Delete(BatchPolicy batchPolicy, BatchDeletePolicy deletePolicy, BatchRecordSequenceListener listener, Key[] keys);
    public sealed virtual Task Touch(WritePolicy policy, CancellationToken token, Key key);
    public sealed virtual void Touch(WritePolicy policy, WriteListener listener, Key key);
    public sealed virtual Task`1<bool> Exists(Policy policy, CancellationToken token, Key key);
    public sealed virtual void Exists(Policy policy, ExistsListener listener, Key key);
    public sealed virtual Task`1<Boolean[]> Exists(BatchPolicy policy, CancellationToken token, Key[] keys);
    public sealed virtual void Exists(BatchPolicy policy, ExistsArrayListener listener, Key[] keys);
    public sealed virtual void Exists(BatchPolicy policy, ExistsSequenceListener listener, Key[] keys);
    public sealed virtual Task`1<Record> Get(Policy policy, CancellationToken token, Key key);
    public sealed virtual void Get(Policy policy, RecordListener listener, Key key);
    public sealed virtual Task`1<Record> Get(Policy policy, CancellationToken token, Key key, String[] binNames);
    public sealed virtual void Get(Policy policy, RecordListener listener, Key key, String[] binNames);
    public sealed virtual Task`1<Record> GetHeader(Policy policy, CancellationToken token, Key key);
    public sealed virtual void GetHeader(Policy policy, RecordListener listener, Key key);
    public sealed virtual Task`1<List`1<BatchRead>> Get(BatchPolicy policy, CancellationToken token, List`1<BatchRead> records);
    public sealed virtual void Get(BatchPolicy policy, BatchListListener listener, List`1<BatchRead> records);
    public sealed virtual void Get(BatchPolicy policy, BatchSequenceListener listener, List`1<BatchRead> records);
    public sealed virtual Task`1<Record[]> Get(BatchPolicy policy, CancellationToken token, Key[] keys);
    public sealed virtual void Get(BatchPolicy policy, RecordArrayListener listener, Key[] keys);
    public sealed virtual void Get(BatchPolicy policy, RecordSequenceListener listener, Key[] keys);
    public sealed virtual Task`1<Record[]> Get(BatchPolicy policy, CancellationToken token, Key[] keys, String[] binNames);
    public sealed virtual void Get(BatchPolicy policy, RecordArrayListener listener, Key[] keys, String[] binNames);
    public sealed virtual void Get(BatchPolicy policy, RecordSequenceListener listener, Key[] keys, String[] binNames);
    public sealed virtual Task`1<Record[]> Get(BatchPolicy policy, CancellationToken token, Key[] keys, Operation[] ops);
    public sealed virtual void Get(BatchPolicy policy, RecordArrayListener listener, Key[] keys, Operation[] ops);
    public sealed virtual void Get(BatchPolicy policy, RecordSequenceListener listener, Key[] keys, Operation[] ops);
    public sealed virtual Task`1<Record[]> GetHeader(BatchPolicy policy, CancellationToken token, Key[] keys);
    public sealed virtual void GetHeader(BatchPolicy policy, RecordArrayListener listener, Key[] keys);
    public sealed virtual void GetHeader(BatchPolicy policy, RecordSequenceListener listener, Key[] keys);
    public sealed virtual Task`1<Record> Operate(WritePolicy policy, CancellationToken token, Key key, Operation[] ops);
    public sealed virtual void Operate(WritePolicy policy, RecordListener listener, Key key, Operation[] ops);
    public sealed virtual Task`1<bool> Operate(BatchPolicy policy, CancellationToken token, List`1<BatchRecord> records);
    public sealed virtual void Operate(BatchPolicy policy, BatchOperateListListener listener, List`1<BatchRecord> records);
    public sealed virtual void Operate(BatchPolicy policy, BatchRecordSequenceListener listener, List`1<BatchRecord> records);
    public sealed virtual Task`1<BatchResults> Operate(BatchPolicy batchPolicy, BatchWritePolicy writePolicy, CancellationToken token, Key[] keys, Operation[] ops);
    public sealed virtual void Operate(BatchPolicy batchPolicy, BatchWritePolicy writePolicy, BatchRecordArrayListener listener, Key[] keys, Operation[] ops);
    public sealed virtual void Operate(BatchPolicy batchPolicy, BatchWritePolicy writePolicy, BatchRecordSequenceListener listener, Key[] keys, Operation[] ops);
    public sealed virtual void ScanAll(ScanPolicy policy, RecordSequenceListener listener, string ns, string setName, String[] binNames);
    public sealed virtual void ScanPartitions(ScanPolicy policy, RecordSequenceListener listener, PartitionFilter partitionFilter, string ns, string setName, String[] binNames);
    public sealed virtual Task`1<object> Execute(WritePolicy policy, CancellationToken token, Key key, string packageName, string functionName, Value[] functionArgs);
    public sealed virtual void Execute(WritePolicy policy, ExecuteListener listener, Key key, string packageName, string functionName, Value[] functionArgs);
    public sealed virtual Task`1<BatchResults> Execute(BatchPolicy batchPolicy, BatchUDFPolicy udfPolicy, CancellationToken token, Key[] keys, string packageName, string functionName, Value[] functionArgs);
    public sealed virtual void Execute(BatchPolicy batchPolicy, BatchUDFPolicy udfPolicy, BatchRecordArrayListener listener, Key[] keys, string packageName, string functionName, Value[] functionArgs);
    public sealed virtual void Execute(BatchPolicy batchPolicy, BatchUDFPolicy udfPolicy, BatchRecordSequenceListener listener, Key[] keys, string packageName, string functionName, Value[] functionArgs);
    public sealed virtual void Query(QueryPolicy policy, RecordSequenceListener listener, Statement statement);
    public sealed virtual void QueryPartitions(QueryPolicy policy, RecordSequenceListener listener, Statement statement, PartitionFilter partitionFilter);
}
public class Aerospike.Client.AsyncClientPolicy : ClientPolicy {
    public MaxCommandAction asyncMaxCommandAction;
    public int asyncMaxCommands;
    public int asyncMaxCommandsInQueue;
    public int asyncMinConnsPerNode;
    public int asyncMaxConnsPerNode;
    public int asyncBufferSize;
    public AsyncClientPolicy(AsyncClientPolicy other);
}
public class Aerospike.Client.AsyncCluster : Cluster {
    private AsyncScheduler scheduler;
    private BufferPool bufferPool;
    internal int maxCommands;
    internal int asyncMinConnsPerNode;
    internal int asyncMaxConnsPerNode;
    public AsyncCluster(AsyncClientPolicy policy, Host[] hosts);
    protected internal virtual Node CreateNode(NodeValidator nv, bool createMinConn);
    public void ScheduleCommandExecution(AsyncCommand command);
    public void ReleaseBuffer(BufferSegment segment);
}
public abstract class Aerospike.Client.AsyncCommand : Command {
    private static int ErrorCount;
    private static int IN_PROGRESS;
    private static int SUCCESS;
    private static int RETRY;
    private static int FAIL_TOTAL_TIMEOUT;
    private static int FAIL_NETWORK_INIT;
    private static int FAIL_NETWORK_ERROR;
    private static int FAIL_APPLICATION_INIT;
    private static int FAIL_APPLICATION_ERROR;
    private static int FAIL_SOCKET_TIMEOUT;
    private static int FAIL_QUEUE_ERROR;
    protected internal AsyncCluster cluster;
    protected internal Policy policy;
    private AsyncConnection conn;
    protected internal AsyncNode node;
    private BufferSegment segmentOrig;
    private BufferSegment segment;
    private ValueStopwatch socketWatch;
    private ValueStopwatch totalWatch;
    protected internal int dataLength;
    private int iteration;
    protected internal int commandSentCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) eventReceived;
    private bool compressed;
    private bool inAuthenticate;
    private bool inHeader;
    private ValueStopwatch metricsWatch;
    private bool metricsEnabled;
    public AsyncCommand(AsyncCluster cluster, Policy policy);
    public AsyncCommand(AsyncCluster cluster, Policy policy, int socketTimeout, int totalTimeout);
    public AsyncCommand(AsyncCommand other);
    public void SetBatchRetry(AsyncCommand other);
    public void Execute();
    public void ExecuteBatchRetry();
    internal void ExecuteInline(BufferSegment segment);
    internal void ExecuteAsync(BufferSegment segment);
    private void ExecuteCore();
    private void ExecuteCommand();
    public sealed virtual void OnConnected();
    private void ConnectionReady();
    protected internal sealed virtual int SizeBuffer();
    private void ResizeBuffer(int size);
    protected internal sealed virtual void End();
    protected internal sealed virtual void SetLength(int length);
    protected internal void EndInfo();
    public sealed virtual void SendComplete();
    public sealed virtual void ReceiveComplete();
    public void ReceiveNext();
    public sealed virtual void OnError(Exception e);
    public sealed virtual void OnSocketError(SocketError se);
    private void ConnectionFailed(AerospikeException ae);
    private void RetryServerError(AerospikeException ae);
    private void Backoff(AerospikeException ae);
    private bool ShouldRetry();
    private void Retry(AerospikeException ae);
    public sealed virtual bool CheckTimeout();
    protected internal void Finish();
    private void FailOnApplicationError(AerospikeException ae);
    internal void FailOnQueueError(AerospikeException ae);
    private void AlreadyCompleted(int status);
    private void FailCommand(AerospikeException ae);
    private void NotifyFailure(AerospikeException ae);
    private void CloseConnection();
    internal void ReleaseBuffer();
    protected internal virtual bool RetryBatch();
    protected internal virtual bool IsWrite();
    protected internal abstract virtual Node GetNode(Cluster cluster);
    protected abstract virtual LatencyType GetLatencyType();
    protected internal abstract virtual void WriteBuffer();
    protected internal abstract virtual AsyncCommand CloneCommand();
    protected internal abstract virtual void ParseCommand();
    protected internal abstract virtual bool PrepareRetry(bool timeout);
    protected internal abstract virtual void OnSuccess();
    protected internal abstract virtual void OnFailure(AerospikeException ae);
}
public abstract class Aerospike.Client.AsyncConnection : object {
    private static bool ZeroBuffers;
    protected Socket socket;
    protected AsyncNode node;
    protected IAsyncCommand command;
    private DateTime lastUsed;
    public IAsyncCommand Command { get; public set; }
    public DateTime LastUsed { get; }
    public AsyncConnection(AsyncNode node, IAsyncCommand command);
    private static AsyncConnection();
    protected void InitError(AsyncNode node);
    public IAsyncCommand get_Command();
    public void set_Command(IAsyncCommand value);
    public abstract virtual void Connect(IPEndPoint address);
    public abstract virtual void Send(Byte[] buffer, int offset, int count);
    public abstract virtual void Receive(Byte[] buffer, int offset, int count);
    public bool IsValid();
    public DateTime get_LastUsed();
    public void UpdateLastUsed();
    public abstract virtual void Reset();
    public virtual void Close();
}
public class Aerospike.Client.AsyncConnectionArgs : AsyncConnection {
    private SocketAsyncEventArgs args;
    public AsyncConnectionArgs(AsyncNode node, IAsyncCommand command);
    private void AsyncCompleted(object sender, SocketAsyncEventArgs args);
    public virtual void Connect(IPEndPoint address);
    private void ConnectEvent(SocketAsyncEventArgs args);
    public virtual void Send(Byte[] buffer, int offset, int count);
    private void Send();
    private void SendEvent(SocketAsyncEventArgs args);
    public virtual void Receive(Byte[] buffer, int offset, int count);
    private void Receive();
    private void ReceiveEvent(SocketAsyncEventArgs args);
    public virtual void Reset();
    public virtual void Close();
}
public class Aerospike.Client.AsyncConnectionTls : AsyncConnection {
    private static int READ;
    private static int COMPLETE;
    private static int ERROR;
    private AsyncCallback writeHandler;
    private AsyncCallback readHandler;
    private SslStream sslStream;
    private Exception error;
    private Byte[] buffer;
    private int offset;
    private int count;
    private int state;
    public AsyncConnectionTls(AsyncNode node, IAsyncCommand command);
    public virtual void Connect(IPEndPoint address);
    private void ConnectComplete(object sender, SocketAsyncEventArgs args);
    private void ConnectEvent(SocketAsyncEventArgs args);
    private bool ValidateServerCertificate(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    private void HandshakeEvent(IAsyncResult result);
    public virtual void Send(Byte[] buffer, int offset, int count);
    private void SendEvent(IAsyncResult result);
    public virtual void Receive(Byte[] buffer, int offset, int count);
    private void Receive();
    private void ReceiveEvent(IAsyncResult result);
    public virtual void Reset();
    public virtual void Close();
}
public class Aerospike.Client.AsyncConnector : object {
    private AsyncCluster cluster;
    private AsyncNode node;
    private ConnectorListener listener;
    private Byte[] sessionToken;
    private Byte[] dataBuffer;
    private Stopwatch watch;
    private AsyncConnection conn;
    private int state;
    private bool inHeader;
    public AsyncConnector(AsyncCluster cluster, AsyncNode node, ConnectorListener listener);
    public sealed virtual void OnConnected();
    public sealed virtual void SendComplete();
    public sealed virtual void ReceiveComplete();
    private void ConnectionReady();
    public sealed virtual bool CheckTimeout();
    public sealed virtual void OnSocketError(SocketError se);
    public sealed virtual void OnError(Exception e);
    private void Fail(string msg);
}
public class Aerospike.Client.AsyncConnectorExecutor : object {
    private AsyncCluster cluster;
    private AsyncNode node;
    private int maxConnections;
    private int maxConcurrent;
    private int countConnections;
    private bool wait;
    private bool completed;
    public AsyncConnectorExecutor(AsyncCluster cluster, AsyncNode node, int maxConnections, int maxConcurrent, bool wait);
    public sealed virtual void OnSuccess();
    public sealed virtual void OnFailure(string error);
    private void Complete();
    private void WaitTillComplete();
    private void NotifyCompleted();
}
public class Aerospike.Client.AsyncDelete : AsyncSingleCommand {
    private WritePolicy writePolicy;
    private DeleteListener listener;
    private Key key;
    private Partition partition;
    private bool existed;
    public AsyncDelete(AsyncCluster cluster, WritePolicy writePolicy, Key key, DeleteListener listener);
    public AsyncDelete(AsyncDelete other);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
}
public class Aerospike.Client.AsyncExecute : AsyncRead {
    private WritePolicy writePolicy;
    private ExecuteListener executeListener;
    private string packageName;
    private string functionName;
    private Value[] args;
    public AsyncExecute(AsyncCluster cluster, WritePolicy writePolicy, ExecuteListener listener, Key key, string packageName, string functionName, Value[] args);
    public AsyncExecute(AsyncExecute other);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void HandleNotFound(int resultCode);
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
    private object ParseEndResult();
}
public class Aerospike.Client.AsyncExists : AsyncSingleCommand {
    private ExistsListener listener;
    private Key key;
    private Partition partition;
    private bool exists;
    public AsyncExists(AsyncCluster cluster, Policy policy, Key key, ExistsListener listener);
    public AsyncExists(AsyncExists other);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
}
public class Aerospike.Client.AsyncInfo : AsyncCommand {
    private InfoListener listener;
    private Node serverNode;
    private String[] commands;
    private Dictionary`2<string, string> map;
    public AsyncInfo(AsyncCluster cluster, InfoPolicy policy, InfoListener listener, AsyncNode node, String[] commands);
    public AsyncInfo(AsyncInfo other);
    private static Policy CreatePolicy(InfoPolicy policy);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal sealed virtual void ParseCommand();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
}
public abstract class Aerospike.Client.AsyncMultiCommand : AsyncCommand {
    protected internal AsyncNode serverNode;
    protected internal int info3;
    protected internal int resultCode;
    protected internal int generation;
    protected internal int expiration;
    protected internal int batchIndex;
    protected internal int fieldCount;
    protected internal int opCount;
    protected internal bool isOperation;
    protected internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) valid;
    public AsyncMultiCommand(AsyncCluster cluster, Policy policy, AsyncNode node, bool isOperation);
    public AsyncMultiCommand(AsyncCluster cluster, Policy policy, AsyncNode node, int socketTimeout, int totalTimeout);
    public AsyncMultiCommand(AsyncMultiCommand other);
    protected internal sealed virtual void ParseCommand();
    protected internal virtual Node GetNode(Cluster cluster);
    protected internal virtual bool PrepareRetry(bool timeout);
    private bool ParseGroup();
    protected internal abstract virtual void ParseRow();
    protected internal Record ParseRecord();
    protected internal void Stop();
}
public abstract class Aerospike.Client.AsyncMultiExecutor : object {
    internal AsyncCluster cluster;
    private AsyncMultiCommand[] commands;
    private string ns;
    private ulong clusterKey;
    private int maxConcurrent;
    private int completedCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) done;
    public AsyncMultiExecutor(AsyncCluster cluster);
    public void Execute(AsyncMultiCommand[] commands, int maxConcurrent);
    public void ExecuteValidate(AsyncMultiCommand[] commands, int maxConcurrent, string ns);
    public bool IsDone();
    private void ExecuteValidateCommand(AsyncMultiCommand command);
    public void ChildSuccess(AsyncNode node);
    private void QueryComplete();
    public void ChildFailure(AerospikeException ae);
    internal void Reset();
    protected internal abstract virtual void OnSuccess();
    protected internal abstract virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.AsyncNode : Node {
    private Pool`1<AsyncConnection> asyncConnQueue;
    private AsyncCluster cluster;
    private int asyncConnsOpened;
    private int asyncConnsClosed;
    public AsyncNode(AsyncCluster cluster, NodeValidator nv);
    public virtual void CreateMinConnections();
    public AsyncConnection CreateAsyncConnection(IAsyncCommand command);
    public AsyncConnection GetAsyncConnection();
    public void PutAsyncConnection(AsyncConnection conn);
    public virtual void BalanceConnections();
    private void CloseIdleAsyncConnections(int count);
    protected internal virtual void CloseConnections();
    internal void CloseAsyncConnOnError(AsyncConnection conn);
    private void CloseAsyncConn(AsyncConnection conn);
    internal void IncrAsyncConnTotal();
    internal void DecrAsyncConnTotal();
    internal void IncrAsyncConnOpened();
    internal void IncrAsyncConnClosed();
    public void IncrBytesReceived(long bytesReceived);
    public void IncrBytesSent(long bytesSent);
    public ConnectionStats GetAsyncConnectionStats();
}
public class Aerospike.Client.AsyncOperate : AsyncRead {
    private OperateArgs args;
    public AsyncOperate(AsyncCluster cluster, RecordListener listener, Key key, OperateArgs args);
    public AsyncOperate(AsyncOperate other);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void HandleNotFound(int resultCode);
    protected internal virtual bool PrepareRetry(bool timeout);
}
public class Aerospike.Client.AsyncQuery : AsyncMultiCommand {
    private AsyncMultiExecutor parent;
    private RecordSequenceListener listener;
    private Statement statement;
    private ulong taskId;
    public AsyncQuery(AsyncMultiExecutor parent, AsyncCluster cluster, AsyncNode node, QueryPolicy policy, RecordSequenceListener listener, Statement statement, ulong taskId);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
}
public class Aerospike.Client.AsyncQueryExecutor : AsyncMultiExecutor {
    private RecordSequenceListener listener;
    public AsyncQueryExecutor(AsyncCluster cluster, QueryPolicy policy, RecordSequenceListener listener, Statement statement, Node[] nodes);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.AsyncQueryPartition : AsyncMultiCommand {
    private AsyncMultiExecutor parent;
    private RecordSequenceListener listener;
    private Statement statement;
    private ulong taskId;
    private PartitionTracker tracker;
    private NodePartitions nodePartitions;
    public AsyncQueryPartition(AsyncMultiExecutor parent, AsyncCluster cluster, QueryPolicy policy, RecordSequenceListener listener, Statement statement, ulong taskId, PartitionTracker tracker, NodePartitions nodePartitions);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.AsyncQueryPartitionExecutor : AsyncMultiExecutor {
    private QueryPolicy policy;
    private RecordSequenceListener listener;
    private Statement statement;
    private PartitionTracker tracker;
    private ulong taskId;
    public AsyncQueryPartitionExecutor(AsyncCluster cluster, QueryPolicy policy, RecordSequenceListener listener, Statement statement, PartitionTracker tracker);
    private void QueryPartitions();
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.AsyncQueryValidate : object {
    public static void ValidateBegin(AsyncCluster cluster, BeginListener listener, AsyncNode node, string ns);
    public static void Validate(AsyncCluster cluster, Listener listener, AsyncNode node, string ns, ulong expectedKey);
}
public class Aerospike.Client.AsyncRead : AsyncSingleCommand {
    private RecordListener listener;
    protected internal Key key;
    private String[] binNames;
    private bool isOperation;
    protected Partition partition;
    protected Record record;
    public AsyncRead(AsyncCluster cluster, Policy policy, RecordListener listener, Key key, String[] binNames);
    public AsyncRead(AsyncCluster cluster, WritePolicy policy, Key key);
    public AsyncRead(AsyncCluster cluster, Policy policy, RecordListener listener, Key key, Partition partition, bool isOperation);
    public AsyncRead(AsyncRead other);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal sealed virtual void ParseResult();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void HandleNotFound(int resultCode);
    private void HandleUdfError(int resultCode);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
}
public class Aerospike.Client.AsyncReadHeader : AsyncSingleCommand {
    private RecordListener listener;
    private Key key;
    private Partition partition;
    private Record record;
    public AsyncReadHeader(AsyncCluster cluster, Policy policy, RecordListener listener, Key key);
    public AsyncReadHeader(AsyncReadHeader other);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
}
public class Aerospike.Client.AsyncScanPartition : AsyncMultiCommand {
    private AsyncMultiExecutor parent;
    private ScanPolicy scanPolicy;
    private RecordSequenceListener listener;
    private string ns;
    private string setName;
    private String[] binNames;
    private ulong taskId;
    private PartitionTracker tracker;
    private NodePartitions nodePartitions;
    public AsyncScanPartition(AsyncMultiExecutor parent, AsyncCluster cluster, ScanPolicy scanPolicy, RecordSequenceListener listener, string ns, string setName, String[] binNames, ulong taskId, PartitionTracker tracker, NodePartitions nodePartitions);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseRow();
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.AsyncScanPartitionExecutor : AsyncMultiExecutor {
    private ScanPolicy policy;
    private RecordSequenceListener listener;
    private string ns;
    private string setName;
    private String[] binNames;
    private PartitionTracker tracker;
    public AsyncScanPartitionExecutor(AsyncCluster cluster, ScanPolicy policy, RecordSequenceListener listener, string ns, string setName, String[] binNames, PartitionTracker tracker);
    private void ScanPartitions();
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException ae);
}
public interface Aerospike.Client.AsyncScheduler {
    public abstract virtual void Schedule(AsyncCommand command);
    public abstract virtual void Release(BufferSegment segment);
}
public abstract class Aerospike.Client.AsyncSingleCommand : AsyncCommand {
    public AsyncSingleCommand(AsyncCluster cluster, Policy policy);
    public AsyncSingleCommand(AsyncSingleCommand other);
    protected internal sealed virtual void ParseCommand();
    protected internal abstract virtual void ParseResult();
}
public class Aerospike.Client.AsyncTimeoutQueue : object {
    public static int MaxWeakRefPoolCount;
    private static int MaxInterval;
    private static int MinInterval;
    internal static AsyncTimeoutQueue Instance;
    private ConcurrentQueue`1<WeakReference`1<ITimeout>> weakRefPool;
    private ConcurrentQueue`1<WeakReference`1<ITimeout>> queue;
    private LinkedList`1<WeakReference`1<ITimeout>> list;
    private Thread thread;
    private CancellationTokenSource cancel;
    private CancellationToken cancelToken;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) weakRefPoolCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) sleepInterval;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) valid;
    private static AsyncTimeoutQueue();
    public void Add(ITimeout command, int timeout);
    private void Run();
    private void RegisterCommands();
    private void CheckTimeouts();
    private WeakReference`1<ITimeout> GetWeakRef(ITimeout command);
    private void PutWeakRef(WeakReference`1<ITimeout> commandRef);
    public void Stop();
}
public class Aerospike.Client.AsyncTouch : AsyncSingleCommand {
    private WritePolicy writePolicy;
    private WriteListener listener;
    private Key key;
    private Partition partition;
    public AsyncTouch(AsyncCluster cluster, WritePolicy writePolicy, WriteListener listener, Key key);
    public AsyncTouch(AsyncTouch other);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
}
public class Aerospike.Client.AsyncWrite : AsyncSingleCommand {
    private WritePolicy writePolicy;
    private WriteListener listener;
    private Key key;
    private Partition partition;
    private Bin[] bins;
    private Type operation;
    public AsyncWrite(AsyncCluster cluster, WritePolicy writePolicy, WriteListener listener, Key key, Bin[] bins, Type operation);
    public AsyncWrite(AsyncWrite other);
    protected internal virtual AsyncCommand CloneCommand();
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode(Cluster cluster);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void OnSuccess();
    protected internal virtual void OnFailure(AerospikeException e);
}
public enum Aerospike.Client.AuthMode : Enum {
    public int value__;
    public static AuthMode INTERNAL;
    public static AuthMode EXTERNAL;
    public static AuthMode EXTERNAL_INSECURE;
    public static AuthMode PKI;
}
public abstract class Aerospike.Client.BaseTask : object {
    public static int NOT_FOUND;
    public static int IN_PROGRESS;
    public static int COMPLETE;
    protected internal Cluster cluster;
    protected internal InfoPolicy policy;
    private bool done;
    public BaseTask(Cluster cluster, Policy policy);
    public void Wait();
    public void Wait(int sleepInterval);
    public void Wait(int sleepInterval, int timeout);
    private void TaskWait(int sleepInterval);
    public bool IsDone();
    public abstract virtual int QueryStatus();
}
public class Aerospike.Client.BatchAttr : object {
    public Expression filterExp;
    public int readAttr;
    public int writeAttr;
    public int infoAttr;
    public int expiration;
    public short generation;
    public bool hasWrite;
    public bool sendKey;
    public BatchAttr(Policy policy, int rattr);
    public BatchAttr(Policy policy, int rattr, Operation[] ops);
    public BatchAttr(BatchPolicy rp, BatchWritePolicy wp, Operation[] ops);
    public void SetRead(Policy rp);
    public void SetRead(BatchReadPolicy rp);
    public void AdjustRead(Operation[] ops);
    public void AdjustRead(bool readAllBins);
    public void SetWrite(Policy wp);
    public void SetWrite(BatchWritePolicy wp);
    public void AdjustWrite(Operation[] ops);
    public void SetUDF(Policy up);
    public void SetUDF(BatchUDFPolicy up);
    public void SetDelete(Policy dp);
    public void SetDelete(BatchDeletePolicy dp);
}
public abstract class Aerospike.Client.BatchCommand : MultiCommand {
    internal BatchNode batch;
    internal BatchPolicy batchPolicy;
    internal BatchStatus status;
    internal BatchExecutor parent;
    internal UInt32 sequenceAP;
    internal UInt32 sequenceSC;
    internal bool splitRetry;
    public BatchCommand(Cluster cluster, BatchNode batch, BatchPolicy batchPolicy, BatchStatus status, bool isOperation);
    public void Run(object obj);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual bool RetryBatch(Cluster cluster, int socketTimeout, int totalTimeout, DateTime deadline, int iteration, int commandSentCounter);
    protected internal virtual void SetInDoubt(bool inDoubt);
    protected internal abstract virtual BatchCommand CreateCommand(BatchNode batchNode);
    protected internal abstract virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.BatchDelete : BatchRecord {
    public BatchDeletePolicy policy;
    public BatchDelete(Key key);
    public BatchDelete(BatchDeletePolicy policy, Key key);
    public virtual Type GetBatchType();
    public virtual bool Equals(BatchRecord obj);
    public virtual int Size(Policy parentPolicy);
}
public class Aerospike.Client.BatchDeletePolicy : object {
    public Expression filterExp;
    public CommitLevel commitLevel;
    public GenerationPolicy generationPolicy;
    public int generation;
    public bool durableDelete;
    public bool sendKey;
    public BatchDeletePolicy(BatchDeletePolicy other);
}
public class Aerospike.Client.BatchExecutor : object {
    private BatchStatus status;
    private int maxConcurrentThreads;
    private BatchCommand[] commands;
    private int completedCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) done;
    private bool completed;
    private BatchExecutor(BatchPolicy policy, BatchCommand[] commands, BatchStatus status);
    public static void Execute(Cluster cluster, BatchPolicy policy, BatchCommand[] commands, BatchStatus status);
    public static void Execute(BatchCommand command, BatchStatus status);
    internal void Execute();
    internal void OnComplete();
    internal bool IsDone();
    private void WaitTillComplete();
    private void NotifyCompleted();
}
public class Aerospike.Client.BatchExistsArrayCommand : BatchCommand {
    private Key[] keys;
    private Boolean[] existsArray;
    public BatchExistsArrayCommand(Cluster cluster, BatchNode batch, BatchPolicy policy, Key[] keys, Boolean[] existsArray, BatchStatus status);
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
    protected internal virtual BatchCommand CreateCommand(BatchNode batchNode);
    protected internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.BatchGetArrayCommand : BatchCommand {
    private Key[] keys;
    private String[] binNames;
    private Operation[] ops;
    private Record[] records;
    private int readAttr;
    public BatchGetArrayCommand(Cluster cluster, BatchNode batch, BatchPolicy policy, Key[] keys, String[] binNames, Operation[] ops, Record[] records, int readAttr, bool isOperation, BatchStatus status);
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
    protected internal virtual BatchCommand CreateCommand(BatchNode batchNode);
    protected internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public interface Aerospike.Client.BatchListListener {
    public abstract virtual void OnSuccess(List`1<BatchRead> records);
    public abstract virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.BatchListListenerAdapter : ListenerAdapter`1<List`1<BatchRead>> {
    public BatchListListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(List`1<BatchRead> records);
}
public class Aerospike.Client.BatchNode : object {
    public Node node;
    public Int32[] offsets;
    public int offsetsSize;
    public BatchNode(Node node, int capacity, int offset);
    public BatchNode(Node node, Key[] keys);
    public BatchNode(BatchRecord[] records);
    public static List`1<BatchNode> GenerateList(Cluster cluster, BatchPolicy policy, Key[] keys, BatchRecord[] records, bool hasWrite, IBatchStatus status);
    public static List`1<BatchNode> GenerateList(Cluster cluster, BatchPolicy policy, Key[] keys, BatchRecord[] records, UInt32 sequenceAP, UInt32 sequenceSC, BatchNode batchSeed, bool hasWrite, IBatchStatus status);
    public static List`1<BatchNode> GenerateList(Cluster cluster, BatchPolicy policy, Key[] keys, Boolean[] sent, UInt32 sequenceAP, UInt32 sequenceSC, BatchNode batchSeed, bool hasWrite, IBatchStatus status);
    public static List`1<BatchNode> GenerateList(Cluster cluster, BatchPolicy policy, Key[] keys, UInt32 sequenceAP, UInt32 sequenceSC, BatchNode batchSeed, bool hasWrite, IBatchStatus status);
    public static List`1<BatchNode> GenerateList(Cluster cluster, BatchPolicy policy, IList records, IBatchStatus status);
    public static List`1<BatchNode> GenerateList(Cluster cluster, BatchPolicy policy, IList records, UInt32 sequenceAP, UInt32 sequenceSC, BatchNode batchSeed, IBatchStatus status);
    private static BatchNode FindBatchNode(IList`1<BatchNode> nodes, Node node);
    public void AddKey(int offset);
}
public class Aerospike.Client.BatchOperateArrayCommand : BatchCommand {
    private Key[] keys;
    private Operation[] ops;
    private BatchRecord[] records;
    private BatchAttr attr;
    public BatchOperateArrayCommand(Cluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, Operation[] ops, BatchRecord[] records, BatchAttr attr, BatchStatus status);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
    protected internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual BatchCommand CreateCommand(BatchNode batchNode);
    protected internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.BatchOperateListCommand : BatchCommand {
    private IList`1<BatchRecord> records;
    public BatchOperateListCommand(Cluster cluster, BatchNode batch, BatchPolicy policy, IList`1<BatchRecord> records, BatchStatus status);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
    protected internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual BatchCommand CreateCommand(BatchNode batchNode);
    protected internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public interface Aerospike.Client.BatchOperateListListener {
    public abstract virtual void OnSuccess(List`1<BatchRecord> records, bool status);
    public abstract virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.BatchOperateListListenerAdapter : ListenerAdapter`1<bool> {
    public BatchOperateListListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(List`1<BatchRecord> records, bool status);
}
public class Aerospike.Client.BatchPolicy : Policy {
    public int maxConcurrentThreads;
    public bool allowInline;
    public bool allowInlineSSD;
    public bool allowProleReads;
    public bool respondAllKeys;
    [ObsoleteAttribute("Deprecated. The set name is now always sent.")]
public bool sendSetName;
    public BatchPolicy(BatchPolicy other);
    public BatchPolicy(Policy other);
    public static BatchPolicy ReadDefault();
    public static BatchPolicy WriteDefault();
}
public class Aerospike.Client.BatchRead : BatchRecord {
    public BatchReadPolicy policy;
    public String[] binNames;
    public Operation[] ops;
    public bool readAllBins;
    public BatchRead(Key key, String[] binNames);
    public BatchRead(Key key, bool readAllBins);
    public BatchRead(Key key, Operation[] ops);
    public BatchRead(BatchReadPolicy policy, Key key, String[] binNames);
    public BatchRead(BatchReadPolicy policy, Key key, bool readAllBins);
    public BatchRead(BatchReadPolicy policy, Key key, Operation[] ops);
    public virtual Type GetBatchType();
    public virtual bool Equals(BatchRecord obj);
    public virtual int Size(Policy parentPolicy);
}
public class Aerospike.Client.BatchReadListCommand : BatchCommand {
    private List`1<BatchRead> records;
    public BatchReadListCommand(Cluster cluster, BatchNode batch, BatchPolicy policy, List`1<BatchRead> records, BatchStatus status);
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
    protected internal virtual BatchCommand CreateCommand(BatchNode batchNode);
    protected internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.BatchReadPolicy : object {
    public Expression filterExp;
    public ReadModeAP readModeAP;
    public ReadModeSC readModeSC;
    public int readTouchTtlPercent;
    public BatchReadPolicy(BatchReadPolicy other);
}
public class Aerospike.Client.BatchRecord : object {
    public Key key;
    public Record record;
    public int resultCode;
    public bool inDoubt;
    public bool hasWrite;
    public BatchRecord(Key key, bool hasWrite);
    public BatchRecord(Key key, Record record, bool hasWrite);
    public BatchRecord(Key key, Record record, int resultCode, bool inDoubt, bool hasWrite);
    public void Prepare();
    public void SetRecord(Record record);
    public void SetError(int resultCode, bool inDoubt);
    public virtual string ToString();
    public virtual Type GetBatchType();
    public virtual bool Equals(BatchRecord other);
    public virtual int Size(Policy parentPolicy);
}
public interface Aerospike.Client.BatchRecordArrayListener {
    public abstract virtual void OnSuccess(BatchRecord[] records, bool status);
    public abstract virtual void OnFailure(BatchRecord[] records, AerospikeException ae);
}
internal class Aerospike.Client.BatchRecordArrayListenerAdapter : ListenerAdapter`1<BatchResults> {
    public BatchRecordArrayListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(BatchRecord[] records, bool status);
    public sealed virtual void OnFailure(BatchRecord[] records, AerospikeException ae);
}
public interface Aerospike.Client.BatchRecordSequenceListener {
    public abstract virtual void OnRecord(BatchRecord record, int index);
    public abstract virtual void OnSuccess();
    public abstract virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.BatchResults : object {
    public BatchRecord[] records;
    public bool status;
    public BatchResults(BatchRecord[] records, bool status);
}
public interface Aerospike.Client.BatchSequenceListener {
    public abstract virtual void OnRecord(BatchRead record);
    public abstract virtual void OnSuccess();
    public abstract virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.BatchStatus : object {
    private Exception exception;
    private bool error;
    private bool hasResultCode;
    public BatchStatus(bool hasResultCode);
    public sealed virtual void BatchKeyError(Cluster cluster, Key key, int index, AerospikeException ae, bool inDoubt, bool hasWrite);
    public sealed virtual void BatchKeyError(AerospikeException e);
    public void SetRowError();
    public bool GetStatus();
    public void SetException(Exception e);
    public void CheckException();
}
public class Aerospike.Client.BatchUDF : BatchRecord {
    public BatchUDFPolicy policy;
    public string packageName;
    public string functionName;
    public Value[] functionArgs;
    public Byte[] argBytes;
    public BatchUDF(Key key, string packageName, string functionName, Value[] functionArgs);
    public BatchUDF(BatchUDFPolicy policy, Key key, string packageName, string functionName, Value[] functionArgs);
    public virtual Type GetBatchType();
    public virtual bool Equals(BatchRecord obj);
    public virtual int Size(Policy parentPolicy);
}
public class Aerospike.Client.BatchUDFCommand : BatchCommand {
    private Key[] keys;
    private string packageName;
    private string functionName;
    private Byte[] argBytes;
    private BatchRecord[] records;
    private BatchAttr attr;
    public BatchUDFCommand(Cluster cluster, BatchNode batch, BatchPolicy batchPolicy, Key[] keys, string packageName, string functionName, Byte[] argBytes, BatchRecord[] records, BatchAttr attr, BatchStatus status);
    protected internal virtual bool IsWrite();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
    protected internal virtual void SetInDoubt(bool inDoubt);
    protected internal virtual BatchCommand CreateCommand(BatchNode batchNode);
    protected internal virtual List`1<BatchNode> GenerateBatchNodes();
}
public class Aerospike.Client.BatchUDFPolicy : object {
    public Expression filterExp;
    public CommitLevel commitLevel;
    public int expiration;
    public bool durableDelete;
    public bool sendKey;
    public BatchUDFPolicy(BatchUDFPolicy other);
}
public class Aerospike.Client.BatchWrite : BatchRecord {
    public BatchWritePolicy policy;
    public Operation[] ops;
    public BatchWrite(Key key, Operation[] ops);
    public BatchWrite(BatchWritePolicy policy, Key key, Operation[] ops);
    public virtual Type GetBatchType();
    public virtual bool Equals(BatchRecord obj);
    public virtual int Size(Policy parentPolicy);
}
public class Aerospike.Client.BatchWritePolicy : object {
    public Expression filterExp;
    public RecordExistsAction recordExistsAction;
    public CommitLevel commitLevel;
    public GenerationPolicy generationPolicy;
    public int generation;
    public int expiration;
    public bool durableDelete;
    public bool sendKey;
    public BatchWritePolicy(BatchWritePolicy other);
}
public class Aerospike.Client.BCrypt : object {
    private static int GENSALT_DEFAULT_LOG2_ROUNDS;
    private static int BCRYPT_SALT_LEN;
    private static int BLOWFISH_NUM_ROUNDS;
    private static UInt32[] _POrig;
    private static UInt32[] _SOrig;
    private static UInt32[] _BfCryptCiphertext;
    private static Char[] _Base64Code;
    private static Int32[] _Index64;
    private UInt32[] _P;
    private UInt32[] _S;
    private static BCrypt();
    public static string HashString(string source);
    public static string HashString(string source, int workFactor);
    public static string HashPassword(string input);
    public static string HashPassword(string input, int workFactor);
    public static string HashPassword(string input, string salt);
    public static string GenerateSalt(int workFactor);
    public static string GenerateSalt();
    public static bool Verify(string text, string hash);
    private static string EncodeBase64(Byte[] byteArray, int length);
    private static Byte[] DecodeBase64(string encodedstring, int maximumBytes);
    private static int Char64(char character);
    private void Encipher(UInt32[] blockArray, int offset);
    private static UInt32 StreamToWord(Byte[] data, Int32& offset);
    private void InitializeKey();
    private void Key(Byte[] keyBytes);
    private void EKSKey(Byte[] saltBytes, Byte[] inputBytes);
    private Byte[] CryptRaw(Byte[] inputBytes, Byte[] saltBytes, int logRounds);
}
public class Aerospike.Client.Bin : ValueType {
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private Value <value>k__BackingField;
    public string name { get; }
    public Value value { get; }
    public Bin(string name, Value value);
    public Bin(string name, string value);
    public Bin(string name, Byte[] value);
    public Bin(string name, Byte[] value, int offset, int length);
    public Bin(string name, double value);
    public Bin(string name, float value);
    public Bin(string name, long value);
    public Bin(string name, ulong value);
    public Bin(string name, int value);
    public Bin(string name, UInt32 value);
    public Bin(string name, short value);
    public Bin(string name, ushort value);
    public Bin(string name, bool value);
    public Bin(string name, byte value);
    public Bin(string name, sbyte value);
    public Bin(string name, IList value);
    public Bin(string name, IDictionary value);
    public Bin(string name, IDictionary value, MapOrder mapOrder);
    public Bin(string name, object value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Value get_value();
    public static Bin AsNull(string name);
    public static Bin AsGeoJSON(string name, string value);
    public virtual string ToString();
}
public class Aerospike.Client.BitExp : object {
    private static int MODULE;
    public static Exp Resize(BitPolicy policy, Exp byteSize, int resizeFlags, Exp bin);
    public static Exp Insert(BitPolicy policy, Exp byteOffset, Exp value, Exp bin);
    public static Exp Remove(BitPolicy policy, Exp byteOffset, Exp byteSize, Exp bin);
    public static Exp Set(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp value, Exp bin);
    public static Exp Or(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp value, Exp bin);
    public static Exp Xor(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp value, Exp bin);
    public static Exp And(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp value, Exp bin);
    public static Exp Not(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp bin);
    public static Exp Lshift(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp shift, Exp bin);
    public static Exp Rshift(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp shift, Exp bin);
    public static Exp Add(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp value, bool signed, BitOverflowAction action, Exp bin);
    public static Exp Subtract(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp value, bool signed, BitOverflowAction action, Exp bin);
    public static Exp SetInt(BitPolicy policy, Exp bitOffset, Exp bitSize, Exp value, Exp bin);
    public static Exp Get(Exp bitOffset, Exp bitSize, Exp bin);
    public static Exp Count(Exp bitOffset, Exp bitSize, Exp bin);
    public static Exp Lscan(Exp bitOffset, Exp bitSize, Exp value, Exp bin);
    public static Exp Rscan(Exp bitOffset, Exp bitSize, Exp value, Exp bin);
    public static Exp GetInt(Exp bitOffset, Exp bitSize, bool signed, Exp bin);
    private static Byte[] PackMath(int command, BitPolicy policy, Exp bitOffset, Exp bitSize, Exp value, bool signed, BitOverflowAction action);
    private static Byte[] PackGetInt(Exp bitOffset, Exp bitSize, bool signed);
    private static Exp AddWrite(Exp bin, Byte[] bytes);
    private static Exp AddRead(Exp bin, Byte[] bytes, Type retType);
}
public class Aerospike.Client.BitOperation : object {
    internal static int RESIZE;
    internal static int INSERT;
    internal static int REMOVE;
    internal static int SET;
    internal static int OR;
    internal static int XOR;
    internal static int AND;
    internal static int NOT;
    internal static int LSHIFT;
    internal static int RSHIFT;
    internal static int ADD;
    internal static int SUBTRACT;
    internal static int SET_INT;
    internal static int GET;
    internal static int COUNT;
    internal static int LSCAN;
    internal static int RSCAN;
    internal static int GET_INT;
    internal static int INT_FLAGS_SIGNED;
    public static Operation Resize(BitPolicy policy, string binName, int byteSize, BitResizeFlags resizeFlags);
    public static Operation Insert(BitPolicy policy, string binName, int byteOffset, Byte[] value);
    public static Operation Remove(BitPolicy policy, string binName, int byteOffset, int byteSize);
    public static Operation Set(BitPolicy policy, string binName, int bitOffset, int bitSize, Byte[] value);
    public static Operation Or(BitPolicy policy, string binName, int bitOffset, int bitSize, Byte[] value);
    public static Operation Xor(BitPolicy policy, string binName, int bitOffset, int bitSize, Byte[] value);
    public static Operation And(BitPolicy policy, string binName, int bitOffset, int bitSize, Byte[] value);
    public static Operation Not(BitPolicy policy, string binName, int bitOffset, int bitSize);
    public static Operation Lshift(BitPolicy policy, string binName, int bitOffset, int bitSize, int shift);
    public static Operation Rshift(BitPolicy policy, string binName, int bitOffset, int bitSize, int shift);
    public static Operation Add(BitPolicy policy, string binName, int bitOffset, int bitSize, long value, bool signed, BitOverflowAction action);
    public static Operation Subtract(BitPolicy policy, string binName, int bitOffset, int bitSize, long value, bool signed, BitOverflowAction action);
    public static Operation SetInt(BitPolicy policy, string binName, int bitOffset, int bitSize, long value);
    public static Operation Get(string binName, int bitOffset, int bitSize);
    public static Operation Count(string binName, int bitOffset, int bitSize);
    public static Operation Lscan(string binName, int bitOffset, int bitSize, bool value);
    public static Operation Rscan(string binName, int bitOffset, int bitSize, bool value);
    public static Operation GetInt(string binName, int bitOffset, int bitSize, bool signed);
    private static Byte[] PackMath(int command, BitPolicy policy, int bitOffset, int bitSize, long value, bool signed, BitOverflowAction action);
    private static Byte[] PackGetInt(int bitOffset, int bitSize, bool signed);
}
public enum Aerospike.Client.BitOverflowAction : Enum {
    public int value__;
    public static BitOverflowAction FAIL;
    public static BitOverflowAction SATURATE;
    public static BitOverflowAction WRAP;
}
public class Aerospike.Client.BitPolicy : object {
    public static BitPolicy Default;
    internal int flags;
    public BitPolicy(BitWriteFlags flags);
    private static BitPolicy();
}
[FlagsAttribute]
public enum Aerospike.Client.BitResizeFlags : Enum {
    public int value__;
    public static BitResizeFlags DEFAULT;
    public static BitResizeFlags FROM_FRONT;
    public static BitResizeFlags GROW_ONLY;
    public static BitResizeFlags SHRINK_ONLY;
}
[FlagsAttribute]
public enum Aerospike.Client.BitWriteFlags : Enum {
    public int value__;
    public static BitWriteFlags DEFAULT;
    public static BitWriteFlags CREATE_ONLY;
    public static BitWriteFlags UPDATE_ONLY;
    public static BitWriteFlags NO_FAIL;
    public static BitWriteFlags PARTIAL;
}
public class Aerospike.Client.BlockScheduler : object {
    private BlockingCollection`1<BufferSegment> bufferQueue;
    public BlockScheduler(AsyncClientPolicy policy, BufferPool pool);
    public sealed virtual void Schedule(AsyncCommand command);
    public sealed virtual void Release(BufferSegment segment);
}
public class Aerospike.Client.Buffer : object {
    private static int MAX_BUFFER_SIZE;
    [CompilerGeneratedAttribute]
private Byte[] <DataBuffer>k__BackingField;
    public int Offset;
    public Byte[] DataBuffer { get; public set; }
    public Buffer(int length);
    [CompilerGeneratedAttribute]
public Byte[] get_DataBuffer();
    [CompilerGeneratedAttribute]
public void set_DataBuffer(Byte[] value);
    public void Resize(int length);
}
public class Aerospike.Client.BufferPool : object {
    public Byte[] buffer;
    public int bufferSize;
    public BufferPool(int maxCommands, int size);
}
public class Aerospike.Client.BufferSegment : object {
    public Byte[] buffer;
    public int index;
    public int offset;
    public int size;
    public BufferSegment(BufferPool pool, int index);
    public BufferSegment(int index, int size);
}
public class Aerospike.Client.ByteUtil : object {
    public static Value BytesToKeyValue(ParticleType type, Byte[] buf, int offset, int len);
    public static object BytesToParticle(ParticleType type, Byte[] buf, int offset, int len);
    public static int EstimateSizeUtf8(string s);
    public static Byte[] StringToUtf8(string s);
    public static int StringToUtf8(string s, Byte[] buf, int offset);
    public static string Utf8ToString(Byte[] buf, int offset, int length);
    public static UInt32 Utf8DigitsToInt(Byte[] buf, int begin, int end);
    public static string BytesToHexString(Byte[] buf);
    public static string BytesToHexString(Byte[] buf, int offset, int len);
    public static object BytesToObject(Byte[] buf, int offset, int len);
    public static object BytesToGeoJSON(Byte[] buf, int offset, int len);
    public static object BytesToHLL(Byte[] buf, int offset, int len);
    public static object BytesToNumber(Byte[] buf, int offset, int len);
    public static Value BytesToLongValue(Byte[] buf, int offset, int len);
    public static object BytesToBigInteger(Byte[] buf, int offset, int len);
    public static bool BytesToBool(Byte[] buf, int offset, int len);
    public static int DoubleToBytes(double v, Byte[] buf, int offset);
    public static double BytesToDouble(Byte[] buf, int offset);
    public static int FloatToBytes(float v, Byte[] buf, int offset);
    public static float BytesToFloat(Byte[] buf, int offset);
    public static int LongToBytes(ulong v, Byte[] buf, int offset);
    public static int LongToLittleBytes(ulong v, Byte[] buf, int offset);
    public static long BytesToLong(Byte[] buf, int offset);
    public static long LittleBytesToLong(Byte[] buf, int offset);
    public static int IntToBytes(UInt32 v, Byte[] buf, int offset);
    public static int IntToLittleBytes(UInt32 v, Byte[] buf, int offset);
    public static int BytesToInt(Byte[] buf, int offset);
    public static int LittleBytesToInt(Byte[] buf, int offset);
    public static UInt32 BytesToUInt(Byte[] buf, int offset);
    public static int ShortToBytes(ushort v, Byte[] buf, int offset);
    public static int ShortToLittleBytes(ushort v, Byte[] buf, int offset);
    public static int BytesToShort(Byte[] buf, int offset);
    public static int LittleBytesToShort(Byte[] buf, int offset);
    public static int IntToVarBytes(UInt32 v, Byte[] buf, int offset);
    public static int VarBytesToInt(Byte[] buf, int offset, Int32& size);
    public static int Compress(Byte[] srcBuf, int srcSize, Byte[] trgBuf, int trgOffset, int trgSize);
    public static void Decompress(Byte[] srcBuf, int srcOffset, int srcSize, Byte[] trgBuf, int trgSize);
}
public class Aerospike.Client.CDT : object {
    internal static Byte[] PackRangeOperation(int command, int returnType, Value begin, Value end, CTX[] ctx);
    internal static void Init(Packer packer, CTX[] ctx, int command, int count, int flag);
}
public class Aerospike.Client.ClientPolicy : object {
    public string user;
    public string password;
    public string clusterName;
    public AuthMode authMode;
    public int timeout;
    public int loginTimeout;
    public int minConnsPerNode;
    public int maxConnsPerNode;
    public int connPoolsPerNode;
    public int maxSocketIdle;
    public int maxErrorRate;
    public int errorRateWindow;
    public int tendInterval;
    public bool failIfNotConnected;
    public Policy readPolicyDefault;
    public WritePolicy writePolicyDefault;
    public ScanPolicy scanPolicyDefault;
    public QueryPolicy queryPolicyDefault;
    public BatchPolicy batchPolicyDefault;
    public BatchPolicy batchParentPolicyWriteDefault;
    public BatchWritePolicy batchWritePolicyDefault;
    public BatchDeletePolicy batchDeletePolicyDefault;
    public BatchUDFPolicy batchUDFPolicyDefault;
    public InfoPolicy infoPolicyDefault;
    public TlsPolicy tlsPolicy;
    public Dictionary`2<string, string> ipMap;
    public bool useServicesAlternate;
    public bool rackAware;
    public int rackId;
    public List`1<int> rackIds;
    public ClientPolicy(ClientPolicy other);
}
public class Aerospike.Client.Cluster : object {
    protected internal string clusterName;
    private Host[] modreq(System.Runtime.CompilerServices.IsVolatile) seeds;
    protected internal Dictionary`2<Host, Node> aliases;
    protected internal Dictionary`2<string, Node> nodesMap;
    private Node[] modreq(System.Runtime.CompilerServices.IsVolatile) nodes;
    protected internal Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) partitionMap;
    protected internal Dictionary`2<string, string> ipMap;
    protected internal TlsPolicy tlsPolicy;
    internal Context context;
    protected internal AuthMode authMode;
    protected internal Byte[] user;
    protected internal Byte[] password;
    protected internal Byte[] passwordHash;
    private int nodeIndex;
    internal int replicaIndex;
    private int recoverCount;
    private Pool`1<ConnectionRecover> recoverQueue;
    internal int minConnsPerNode;
    internal int maxConnsPerNode;
    protected internal int connPoolsPerNode;
    internal int maxErrorRate;
    internal int errorRateWindow;
    protected internal int connectionTimeout;
    protected internal int loginTimeout;
    private double maxSocketIdleMillisTran;
    private double maxSocketIdleMillisTrim;
    public Int32[] rackIds;
    private int invalidNodeCount;
    private int tendInterval;
    private int tendCount;
    private Thread tendThread;
    private CancellationTokenSource cancel;
    private CancellationToken cancelToken;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) tendValid;
    protected internal bool useServicesAlternate;
    internal bool rackAware;
    public bool authEnabled;
    internal bool hasPartitionQuery;
    public bool MetricsEnabled;
    public MetricsPolicy MetricsPolicy;
    private IMetricsListener modreq(System.Runtime.CompilerServices.IsVolatile) metricsListener;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) retryCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) tranCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) delayQueueTimeoutCount;
    public bool Connected { get; }
    public bool HasClusterName { get; }
    public Node[] Nodes { get; }
    public int InvalidNodeCount { get; }
    public Cluster(ClientPolicy policy, Host[] hosts);
    public virtual void InitTendThread(bool failIfNotConnected);
    public void AddSeeds(Host[] hosts);
    private bool FindSeed(Host search);
    private void WaitTillStabilized(bool failIfNotConnected);
    public void Run();
    private void Tend(bool failIfNotConnected, bool isInit);
    private bool SeedNode(Peers peers, bool failIfNotConnected);
    private void AddSeedAndPeers(Node seed, Peers peers);
    private void RefreshPeers(Peers peers);
    protected internal virtual Node CreateNode(NodeValidator nv, bool createMinConn);
    private List`1<Node> FindNodesToRemove(int refreshCount);
    private bool FindNodeInPartitionMap(Node filter);
    private void AddNodes(Node seed, Peers peers);
    private void AddNodes(Dictionary`2<string, Node> nodesToAdd);
    private void AddNode(Node node);
    private void RemoveNodes(List`1<Node> nodesToRemove);
    private void RemoveNodesCopy(List`1<Node> nodesToRemove);
    private static bool FindNode(Node search, List`1<Node> nodeList);
    internal bool IsConnCurrentTran(DateTime lastUsed);
    internal bool IsConnCurrentTrim(DateTime lastUsed);
    internal bool UseTls();
    public void RecoverConnection(ConnectionRecover cs);
    private void ProcessRecoverQueue();
    public void EnableMetrics(MetricsPolicy policy);
    public void DisableMetrics();
    public ClusterStats GetStats();
    public bool get_Connected();
    public bool get_HasClusterName();
    public Node GetRandomNode();
    public Node[] get_Nodes();
    public Node[] ValidateNodes();
    public Node GetNode(string nodeName);
    private Node FindNode(string nodeName);
    public void PrintPartitionMap();
    protected internal void ChangePassword(Byte[] user, Byte[] password, Byte[] passwordHash);
    public void SetMaxErrorRate(int rate);
    public void SetErrorRateWindow(int window);
    private static bool SupportsPartitionQuery(Node[] nodes);
    public void AddTran();
    public int GetTranCount();
    public void AddRetry();
    public void AddRetries(int count);
    public int GetRetryCount();
    public void AddDelayQueueTimeout();
    public long GetDelayQueueTimeoutCount();
    public int GetRecoverQueueSize();
    public int get_InvalidNodeCount();
    public void InterruptTendSleep();
    public void Close();
}
public class Aerospike.Client.ClusterStats : object {
    public NodeStats[] nodes;
    public int threadsInUse;
    public int RecoverQueueSize;
    public int completionPortsInUse;
    public int invalidNodeCount;
    public long RetryCount;
    public ClusterStats(Cluster cluster, NodeStats[] nodes);
    public virtual string ToString();
}
public abstract class Aerospike.Client.Command : object {
    public static int INFO1_READ;
    public static int INFO1_GET_ALL;
    public static int INFO1_SHORT_QUERY;
    public static int INFO1_BATCH;
    public static int INFO1_NOBINDATA;
    public static int INFO1_READ_MODE_AP_ALL;
    public static int INFO1_COMPRESS_RESPONSE;
    public static int INFO2_WRITE;
    public static int INFO2_DELETE;
    public static int INFO2_GENERATION;
    public static int INFO2_GENERATION_GT;
    public static int INFO2_DURABLE_DELETE;
    public static int INFO2_CREATE_ONLY;
    public static int INFO2_RELAX_AP_LONG_QUERY;
    public static int INFO2_RESPOND_ALL_OPS;
    public static int INFO3_LAST;
    public static int INFO3_COMMIT_MASTER;
    public static int INFO3_PARTITION_DONE;
    public static int INFO3_UPDATE_ONLY;
    public static int INFO3_CREATE_OR_REPLACE;
    public static int INFO3_REPLACE_ONLY;
    public static int INFO3_SC_READ_TYPE;
    public static int INFO3_SC_READ_RELAX;
    public static byte STATE_READ_AUTH_HEADER;
    public static byte STATE_READ_HEADER;
    public static byte STATE_READ_DETAIL;
    public static byte STATE_COMPLETE;
    public static byte BATCH_MSG_READ;
    public static byte BATCH_MSG_REPEAT;
    public static byte BATCH_MSG_INFO;
    public static byte BATCH_MSG_GEN;
    public static byte BATCH_MSG_TTL;
    public static int MSG_TOTAL_HEADER_SIZE;
    public static int FIELD_HEADER_SIZE;
    public static int OPERATION_HEADER_SIZE;
    public static int MSG_REMAINING_HEADER_SIZE;
    public static int DIGEST_SIZE;
    public static int COMPRESS_THRESHOLD;
    public static ulong CL_MSG_VERSION;
    public static ulong AS_MSG_TYPE;
    public static ulong MSG_TYPE_COMPRESSED;
    internal Byte[] dataBuffer;
    internal int dataOffset;
    internal int maxRetries;
    internal int serverTimeout;
    internal int socketTimeout;
    internal int totalTimeout;
    public Command(int socketTimeout, int totalTimeout, int maxRetries);
    private static Command();
    public virtual void SetWrite(WritePolicy policy, Type operation, Key key, Bin[] bins);
    public virtual void SetDelete(WritePolicy policy, Key key);
    public virtual void SetTouch(WritePolicy policy, Key key);
    public virtual void SetExists(Policy policy, Key key);
    public virtual void SetRead(Policy policy, Key key);
    public virtual void SetRead(Policy policy, Key key, String[] binNames);
    public virtual void SetReadHeader(Policy policy, Key key);
    public virtual void SetOperate(WritePolicy policy, Key key, OperateArgs args);
    public virtual void SetUdf(WritePolicy policy, Key key, string packageName, string functionName, Value[] args);
    public virtual void SetBatchRead(BatchPolicy policy, List`1<BatchRead> records, BatchNode batch);
    public virtual void SetBatchRead(BatchPolicy policy, Key[] keys, BatchNode batch, String[] binNames, Operation[] ops, int readAttr);
    public virtual void SetBatchOperate(BatchPolicy policy, IList records, BatchNode batch);
    public virtual void SetBatchOperate(BatchPolicy policy, Key[] keys, BatchNode batch, String[] binNames, Operation[] ops, BatchAttr attr);
    public virtual void SetBatchUDF(BatchPolicy policy, Key[] keys, BatchNode batch, string packageName, string functionName, Byte[] argBytes, BatchAttr attr);
    private static Expression GetBatchExpression(Policy policy, BatchAttr attr);
    private static byte GetBatchFlags(BatchPolicy policy);
    private void WriteBatchHeader(Policy policy, int timeout, int fieldCount);
    private void WriteBatchBinNames(Key key, String[] binNames, BatchAttr attr, Expression filter);
    private void WriteBatchOperations(Key key, Operation[] ops, BatchAttr attr, Expression filter);
    private void WriteBatchRead(Key key, BatchAttr attr, Expression filter, int opCount);
    private void WriteBatchWrite(Key key, BatchAttr attr, Expression filter, int fieldCount, int opCount);
    private void WriteBatchFields(Key key, Expression filter, int fieldCount, int opCount);
    private void WriteBatchFields(Key key, int fieldCount, int opCount);
    public virtual void SetScan(Cluster cluster, ScanPolicy policy, string ns, string setName, String[] binNames, ulong taskId, NodePartitions nodePartitions);
    protected internal virtual void SetQuery(Cluster cluster, Policy policy, Statement statement, ulong taskId, bool background, NodePartitions nodePartitions);
    private int EstimateKeySize(Policy policy, Key key);
    private int EstimateUdfSize(string packageName, string functionName, Byte[] bytes);
    private void EstimateOperationSize(Bin bin);
    private void EstimateOperationSize(Operation operation);
    private void EstimateReadOperationSize(Operation operation);
    private void EstimateOperationSize(string binName);
    private void EstimateOperationSize();
    private void WriteHeaderWrite(WritePolicy policy, int writeAttr, int fieldCount, int operationCount);
    private void WriteHeaderReadWrite(WritePolicy policy, OperateArgs args, int fieldCount);
    private void WriteHeaderRead(Policy policy, int timeout, int readAttr, int writeAttr, int infoAttr, int fieldCount, int operationCount);
    private void WriteHeaderReadHeader(Policy policy, int readAttr, int fieldCount, int operationCount);
    private void WriteKey(Policy policy, Key key);
    private int WriteReadOnlyOperations(Operation[] ops, int readAttr);
    private void WriteOperation(Bin bin, Type operationType);
    private void WriteOperation(Operation operation);
    private void WriteOperation(string name, Type operationType);
    private void WriteOperation(Type operationType);
    private void WriteField(Value value, int type);
    private void WriteField(string str, int type);
    private void WriteField(Byte[] bytes, int type);
    private void WriteField(int val, int type);
    private void WriteField(ulong val, int type);
    private void WriteFieldHeader(int size, int type);
    internal virtual void WriteExpHeader(int size);
    private void Begin();
    private bool SizeBuffer(Policy policy);
    private void End(bool compress);
    protected internal abstract virtual int SizeBuffer();
    protected internal abstract virtual void End();
    protected internal abstract virtual void SetLength(int length);
    internal virtual void SkipKey(int fieldCount);
    internal virtual Key ParseKey(int fieldCount, UInt64& bval);
    public static bool BatchInDoubt(bool isWrite, int commandSentCounter);
}
public enum Aerospike.Client.CommitLevel : Enum {
    public int value__;
    public static CommitLevel COMMIT_ALL;
    public static CommitLevel COMMIT_MASTER;
}
public class Aerospike.Client.Connection : object {
    protected internal Socket socket;
    protected internal Pool`1<Connection> pool;
    private DateTime lastUsed;
    public DateTime LastUsed { get; }
    public Connection(IPEndPoint address, int timeoutMillis, Pool`1<Connection> pool);
    public Connection(IPEndPoint address, int timeoutMillis, Node node, Pool`1<Connection> pool);
    public sealed virtual void SetTimeout(int timeoutMillis);
    public virtual void Write(Byte[] buffer, int length);
    public virtual void ReadFully(Byte[] buffer, int length);
    public sealed virtual void ReadFully(Byte[] buffer, int length, byte state);
    public int Read(Byte[] buffer, int pos, int length);
    public virtual Stream GetStream();
    public sealed virtual bool IsClosed();
    public DateTime get_LastUsed();
    public sealed virtual void UpdateLastUsed();
    public virtual void Close();
    public static IPAddress[] GetHostAddresses(string host, int timeoutMillis);
}
public class Aerospike.Client.ConnectionRecover : object {
    private Connection conn;
    private Node node;
    private Byte[] headerBuf;
    private int timeoutDelay;
    private int offset;
    private int length;
    private bool isSingle;
    private bool checkReturnCode;
    private bool lastGroup;
    private byte state;
    public ConnectionRecover(Connection conn, Node node, int timeoutDelay, ReadTimeout crt, bool isSingle);
    public bool Drain(Byte[] buf);
    public bool IsComplete();
    public void Abort();
    private void Recover();
    private void DrainHeader(Byte[] buf);
    private void DrainDetail(Byte[] buf);
    private void CopyHeaderBuf(Byte[] buf);
    private int GetSize(Byte[] buf);
    private void ParseProto(Byte[] buf, int bytesRead);
}
public class Aerospike.Client.ConnectionStats : object {
    public int inPool;
    public int inUse;
    public int opened;
    public int closed;
    public long BytesReceived;
    public long BytesSent;
    public ConnectionStats(int inPool, int inUse, int opened, int closed);
    public ConnectionStats(int inPool, int inUse, int opened, int closed, long bytesReceived, long bytesSent);
    public virtual string ToString();
}
public interface Aerospike.Client.ConnectorListener {
    public abstract virtual void OnSuccess();
    public abstract virtual void OnFailure(string error);
}
public class Aerospike.Client.CTX : object {
    public int id;
    public Value value;
    private CTX(int id, Value value);
    public static CTX ListIndex(int index);
    public static CTX ListIndexCreate(int index, ListOrder order, bool pad);
    public static CTX ListRank(int rank);
    public static CTX ListValue(Value key);
    public static CTX MapIndex(int index);
    public static CTX MapRank(int rank);
    public static CTX MapKey(Value key);
    public static CTX MapKeyCreate(Value key, MapOrder order);
    public static CTX MapValue(Value key);
    public static Byte[] ToBytes(CTX[] ctx);
    public static CTX[] FromBytes(Byte[] bytes);
    public static string ToBase64(CTX[] ctx);
    public static CTX[] FromBase64(string base64);
    internal static int GetFlag(ListOrder order, bool pad);
    internal static int GetFlag(MapOrder order);
}
public class Aerospike.Client.DelayScheduler : object {
    private ConcurrentQueue`1<BufferSegment> bufferQueue;
    private ConcurrentQueue`1<AsyncCommand> delayQueue;
    private WaitCallback jobCallback;
    private int delayQueueMax;
    private int delayQueueCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) jobScheduled;
    public DelayScheduler(AsyncClientPolicy policy, BufferPool pool);
    public sealed virtual void Schedule(AsyncCommand command);
    public sealed virtual void Release(BufferSegment segment);
    private void ProcessDelayQueue();
    private void ProcessQueueExclusive(object state);
    private void CommandFailed(AsyncCommand command, BufferSegment segment, Exception e);
}
public class Aerospike.Client.DeleteCommand : SyncCommand {
    private WritePolicy writePolicy;
    private Key key;
    private Partition partition;
    private bool existed;
    public DeleteCommand(Cluster cluster, WritePolicy writePolicy, Key key);
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult(IConnection conn);
    protected internal virtual bool PrepareRetry(bool timeout);
    public bool Existed();
}
public interface Aerospike.Client.DeleteListener {
    public abstract virtual void OnSuccess(Key key, bool existed);
    public abstract virtual void OnFailure(AerospikeException exception);
}
internal class Aerospike.Client.DeleteListenerAdapter : ListenerAdapter`1<bool> {
    public DeleteListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(Key key, bool existed);
}
public class Aerospike.Client.ExecuteCommand : ReadCommand {
    private WritePolicy writePolicy;
    private string packageName;
    private string functionName;
    private Value[] args;
    public ExecuteCommand(Cluster cluster, WritePolicy writePolicy, Key key, string packageName, string functionName, Value[] args);
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void HandleNotFound(int resultCode);
    protected internal virtual bool PrepareRetry(bool timeout);
}
public interface Aerospike.Client.ExecuteListener {
    public abstract virtual void OnSuccess(Key key, object obj);
    public abstract virtual void OnFailure(AerospikeException exception);
}
internal class Aerospike.Client.ExecuteListenerAdapter : ListenerAdapter`1<object> {
    public ExecuteListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(Key key, object obj);
}
public class Aerospike.Client.ExecuteTask : BaseTask {
    protected ulong taskId;
    protected bool scan;
    public ExecuteTask(Cluster cluster, Policy policy, Statement statement, ulong taskId);
    public ulong GetTaskId();
    public virtual int QueryStatus();
}
public class Aerospike.Client.Executor : object {
    private List`1<ExecutorThread> threads;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) exception;
    private int maxConcurrentThreads;
    private int completedCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) done;
    private bool completed;
    public Executor(int capacity);
    public void AddCommand(MultiCommand command);
    public void Execute(int maxConcurrent);
    public void ThreadCompleted();
    public void StopThreads(Exception cause);
    public bool IsDone();
    private void WaitTillComplete();
    private void NotifyCompleted();
}
public class Aerospike.Client.ExecutorThread : object {
    private Executor parent;
    private MultiCommand command;
    public ExecutorThread(Executor parent, MultiCommand command);
    public void Run(object obj);
    public void Stop();
}
public interface Aerospike.Client.ExistsArrayListener {
    public abstract virtual void OnSuccess(Key[] keys, Boolean[] exists);
    public abstract virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.ExistsArrayListenerAdapter : ListenerAdapter`1<Boolean[]> {
    public ExistsArrayListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(Key[] keys, Boolean[] exists);
}
public class Aerospike.Client.ExistsCommand : SyncCommand {
    private Key key;
    private Partition partition;
    private bool exists;
    public ExistsCommand(Cluster cluster, Policy policy, Key key);
    protected internal virtual Node GetNode();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult(IConnection conn);
    protected internal virtual bool PrepareRetry(bool timeout);
    public bool Exists();
}
public interface Aerospike.Client.ExistsListener {
    public abstract virtual void OnSuccess(Key key, bool exists);
    public abstract virtual void OnFailure(AerospikeException exception);
}
internal class Aerospike.Client.ExistsListenerAdapter : ListenerAdapter`1<bool> {
    public ExistsListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(Key key, bool exists);
}
public interface Aerospike.Client.ExistsSequenceListener {
    public abstract virtual void OnExists(Key key, bool exists);
    public abstract virtual void OnSuccess();
    public abstract virtual void OnFailure(AerospikeException exception);
}
public abstract class Aerospike.Client.Exp : object {
    private static int UNKNOWN;
    private static int CMD_EQ;
    private static int CMD_NE;
    private static int CMD_GT;
    private static int CMD_GE;
    private static int CMD_LT;
    private static int CMD_LE;
    private static int REGEX;
    private static int GEO;
    private static int AND;
    private static int OR;
    private static int NOT;
    private static int EXCLUSIVE;
    private static int ADD;
    private static int SUB;
    private static int MUL;
    private static int DIV;
    private static int POW;
    private static int LOG;
    private static int MOD;
    private static int ABS;
    private static int FLOOR;
    private static int CEIL;
    private static int TO_INT;
    private static int TO_FLOAT;
    private static int INT_AND;
    private static int INT_OR;
    private static int INT_XOR;
    private static int INT_NOT;
    private static int INT_LSHIFT;
    private static int INT_RSHIFT;
    private static int INT_ARSHIFT;
    private static int INT_COUNT;
    private static int INT_LSCAN;
    private static int INT_RSCAN;
    private static int MIN;
    private static int MAX;
    private static int DIGEST_MODULO;
    private static int DEVICE_SIZE;
    private static int LAST_UPDATE;
    private static int SINCE_UPDATE;
    private static int VOID_TIME;
    private static int CMD_TTL;
    private static int SET_NAME;
    private static int KEY_EXISTS;
    private static int IS_TOMBSTONE;
    private static int MEMORY_SIZE;
    private static int RECORD_SIZE;
    private static int KEY;
    private static int BIN;
    private static int BIN_TYPE;
    private static int COND;
    private static int VAR;
    private static int LET;
    private static int QUOTED;
    private static int CALL;
    public static int MODIFY;
    public static Expression Build(Exp exp);
    public static Exp Key(Type type);
    public static Exp KeyExists();
    public static Exp Bin(string name, Type type);
    public static Exp IntBin(string name);
    public static Exp FloatBin(string name);
    public static Exp StringBin(string name);
    public static Exp BoolBin(string name);
    public static Exp BlobBin(string name);
    public static Exp GeoBin(string name);
    public static Exp ListBin(string name);
    public static Exp MapBin(string name);
    public static Exp HLLBin(string name);
    public static Exp BinExists(string name);
    public static Exp BinType(string name);
    public static Exp RecordSize();
    public static Exp SetName();
    public static Exp DeviceSize();
    public static Exp MemorySize();
    public static Exp LastUpdate();
    public static Exp SinceUpdate();
    public static Exp VoidTime();
    public static Exp TTL();
    public static Exp IsTombstone();
    public static Exp DigestModulo(int mod);
    public static Exp RegexCompare(string regex, UInt32 flags, Exp bin);
    public static Exp GeoCompare(Exp left, Exp right);
    public static Exp Geo(string val);
    public static Exp Val(bool val);
    public static Exp Val(long val);
    public static Exp Val(ulong val);
    public static Exp Val(DateTime val);
    public static Exp Val(double val);
    public static Exp Val(string val);
    public static Exp Val(Byte[] val);
    public static Exp Val(IList list);
    public static Exp Val(IDictionary map, MapOrder order);
    public static Exp Nil();
    public static Exp Not(Exp exp);
    public static Exp And(Exp[] exps);
    public static Exp Or(Exp[] exps);
    public static Exp Exclusive(Exp[] exps);
    public static Exp EQ(Exp left, Exp right);
    public static Exp NE(Exp left, Exp right);
    public static Exp GT(Exp left, Exp right);
    public static Exp GE(Exp left, Exp right);
    public static Exp LT(Exp left, Exp right);
    public static Exp LE(Exp left, Exp right);
    public static Exp Add(Exp[] exps);
    public static Exp Sub(Exp[] exps);
    public static Exp Mul(Exp[] exps);
    public static Exp Div(Exp[] exps);
    public static Exp Pow(Exp base, Exp exponent);
    public static Exp Log(Exp num, Exp base);
    public static Exp Mod(Exp numerator, Exp denominator);
    public static Exp Abs(Exp value);
    public static Exp Floor(Exp num);
    public static Exp Ceil(Exp num);
    public static Exp ToInt(Exp num);
    public static Exp ToFloat(Exp num);
    public static Exp IntAnd(Exp[] exps);
    public static Exp IntOr(Exp[] exps);
    public static Exp IntXor(Exp[] exps);
    public static Exp IntNot(Exp exp);
    public static Exp Lshift(Exp value, Exp shift);
    public static Exp Rshift(Exp value, Exp shift);
    public static Exp ARshift(Exp value, Exp shift);
    public static Exp Count(Exp exp);
    public static Exp Lscan(Exp value, Exp search);
    public static Exp Rscan(Exp value, Exp search);
    public static Exp Min(Exp[] exps);
    public static Exp Max(Exp[] exps);
    public static Exp Cond(Exp[] exps);
    public static Exp Let(Exp[] exps);
    public static Exp Def(string name, Exp value);
    public static Exp Var(string name);
    public static Exp Unknown();
    public static Exp Expr(Expression e);
    public abstract virtual void Pack(Packer packer);
}
public class Aerospike.Client.ExpOperation : object {
    public static Operation Write(string binName, Expression exp, ExpWriteFlags flags);
    public static Operation Read(string name, Expression exp, ExpReadFlags flags);
    private static Operation CreateOperation(Type type, string name, Expression exp, int flags);
}
[FlagsAttribute]
public enum Aerospike.Client.ExpReadFlags : Enum {
    public int value__;
    public static ExpReadFlags DEFAULT;
    public static ExpReadFlags EVAL_NO_FAIL;
}
public class Aerospike.Client.Expression : object {
    private Byte[] bytes;
    public Byte[] Bytes { get; }
    internal Expression(Exp exp);
    internal Expression(Byte[] bytes);
    public static Expression FromBytes(Byte[] bytes);
    public static Expression FromBase64(Char[] chars);
    public static Expression FromBase64(string s);
    public Byte[] get_Bytes();
    public string GetBase64();
    public int Size();
    public void Write(Command cmd);
    public void Write(Command cmd, Buffer buffer);
}
[FlagsAttribute]
public enum Aerospike.Client.ExpWriteFlags : Enum {
    public int value__;
    public static ExpWriteFlags DEFAULT;
    public static ExpWriteFlags CREATE_ONLY;
    public static ExpWriteFlags UPDATE_ONLY;
    public static ExpWriteFlags ALLOW_DELETE;
    public static ExpWriteFlags POLICY_NO_FAIL;
    public static ExpWriteFlags EVAL_NO_FAIL;
}
public class Aerospike.Client.FieldType : object {
    public static int NAMESPACE;
    public static int TABLE;
    public static int KEY;
    public static int DIGEST_RIPE;
    public static int TRAN_ID;
    public static int SOCKET_TIMEOUT;
    public static int RECORDS_PER_SECOND;
    public static int PID_ARRAY;
    public static int DIGEST_ARRAY;
    public static int MAX_RECORDS;
    public static int BVAL_ARRAY;
    public static int INDEX_RANGE;
    public static int INDEX_CONTEXT;
    public static int INDEX_TYPE;
    public static int UDF_PACKAGE_NAME;
    public static int UDF_FUNCTION;
    public static int UDF_ARGLIST;
    public static int UDF_OP;
    public static int QUERY_BINLIST;
    public static int BATCH_INDEX;
    public static int FILTER_EXP;
}
public class Aerospike.Client.Filter : object {
    private string name;
    private IndexCollectionType colType;
    private Byte[] packedCtx;
    private ParticleType valType;
    private Value begin;
    private Value end;
    public string Name { get; }
    public IndexCollectionType ColType { get; }
    public Value Begin { get; }
    public Value End { get; }
    public int ValType { get; }
    internal IndexCollectionType CollectionType { get; }
    internal Byte[] PackedCtx { get; }
    private Filter(string name, IndexCollectionType colType, int valType, Value begin, Value end, Byte[] packedCtx);
    private Filter(string name, IndexCollectionType colType, ParticleType valType, Value begin, Value end, CTX[] ctx);
    public static Filter Equal(string name, long value, CTX[] ctx);
    public static Filter Equal(string name, string value, CTX[] ctx);
    public static Filter Equal(string name, Byte[] value, CTX[] ctx);
    public static Filter Contains(string name, IndexCollectionType type, long value, CTX[] ctx);
    public static Filter Contains(string name, IndexCollectionType type, string value, CTX[] ctx);
    public static Filter Contains(string name, IndexCollectionType type, Byte[] value, CTX[] ctx);
    public static Filter Range(string name, long begin, long end, CTX[] ctx);
    public static Filter Range(string name, IndexCollectionType type, long begin, long end, CTX[] ctx);
    public static Filter GeoWithinRegion(string name, string region, CTX[] ctx);
    public static Filter GeoWithinRegion(string name, IndexCollectionType type, string region, CTX[] ctx);
    public static Filter GeoWithinRadius(string name, double lng, double lat, double radius, CTX[] ctx);
    public static Filter GeoWithinRadius(string name, IndexCollectionType type, double lng, double lat, double radius, CTX[] ctx);
    public static Filter GeoContains(string name, string point, CTX[] ctx);
    public static Filter GeoContains(string name, IndexCollectionType type, string point, CTX[] ctx);
    internal int EstimateSize();
    internal int Write(Byte[] buf, int offset);
    public string get_Name();
    public IndexCollectionType get_ColType();
    public Value get_Begin();
    public Value get_End();
    public int get_ValType();
    internal IndexCollectionType get_CollectionType();
    internal Byte[] get_PackedCtx();
}
public enum Aerospike.Client.GenerationPolicy : Enum {
    public int value__;
    public static GenerationPolicy NONE;
    public static GenerationPolicy EXPECT_GEN_EQUAL;
    public static GenerationPolicy EXPECT_GEN_GT;
}
public class Aerospike.Client.Hash : object {
    public static Byte[] ComputeHash(Byte[] buffer, int length);
}
public class Aerospike.Client.HLLExp : object {
    private static int MODULE;
    public static Exp Init(HLLPolicy policy, Exp indexBitCount, Exp bin);
    public static Exp Init(HLLPolicy policy, Exp indexBitCount, Exp minHashBitCount, Exp bin);
    public static Exp Add(HLLPolicy policy, Exp list, Exp bin);
    public static Exp Add(HLLPolicy policy, Exp list, Exp indexBitCount, Exp bin);
    public static Exp Add(HLLPolicy policy, Exp list, Exp indexBitCount, Exp minHashBitCount, Exp bin);
    public static Exp GetCount(Exp bin);
    public static Exp GetUnion(Exp list, Exp bin);
    public static Exp GetUnionCount(Exp list, Exp bin);
    public static Exp GetIntersectCount(Exp list, Exp bin);
    public static Exp GetSimilarity(Exp list, Exp bin);
    public static Exp Describe(Exp bin);
    public static Exp MayContain(Exp list, Exp bin);
    private static Exp AddWrite(Exp bin, Byte[] bytes);
    private static Exp AddRead(Exp bin, Byte[] bytes, Type retType);
}
public class Aerospike.Client.HLLOperation : object {
    internal static int INIT;
    internal static int ADD;
    internal static int SET_UNION;
    internal static int SET_COUNT;
    internal static int FOLD;
    internal static int COUNT;
    internal static int UNION;
    internal static int UNION_COUNT;
    internal static int INTERSECT_COUNT;
    internal static int SIMILARITY;
    internal static int DESCRIBE;
    internal static int MAY_CONTAIN;
    public static Operation Init(HLLPolicy policy, string binName, int indexBitCount);
    public static Operation Init(HLLPolicy policy, string binName, int indexBitCount, int minHashBitCount);
    public static Operation Add(HLLPolicy policy, string binName, IList list);
    public static Operation Add(HLLPolicy policy, string binName, IList list, int indexBitCount);
    public static Operation Add(HLLPolicy policy, string binName, IList list, int indexBitCount, int minHashBitCount);
    public static Operation SetUnion(HLLPolicy policy, string binName, IList`1<HLLValue> list);
    public static Operation RefreshCount(string binName);
    public static Operation Fold(string binName, int indexBitCount);
    public static Operation GetCount(string binName);
    public static Operation GetUnion(string binName, IList`1<HLLValue> list);
    public static Operation GetUnionCount(string binName, IList`1<HLLValue> list);
    public static Operation GetIntersectCount(string binName, IList`1<HLLValue> list);
    public static Operation GetSimilarity(string binName, IList`1<HLLValue> list);
    public static Operation Describe(string binName);
    private static Byte[] PackList(int command, IList`1<HLLValue> list);
    public static Byte[] PackListInt(int command, IList`1<HLLValue> list, int v1);
}
public class Aerospike.Client.HLLPolicy : object {
    public static HLLPolicy Default;
    internal int flags;
    public HLLPolicy(HLLWriteFlags flags);
    private static HLLPolicy();
}
[FlagsAttribute]
public enum Aerospike.Client.HLLWriteFlags : Enum {
    public int value__;
    public static HLLWriteFlags DEFAULT;
    public static HLLWriteFlags CREATE_ONLY;
    public static HLLWriteFlags UPDATE_ONLY;
    public static HLLWriteFlags NO_FAIL;
    public static HLLWriteFlags ALLOW_FOLD;
}
public class Aerospike.Client.Host : object {
    public string name;
    public string tlsName;
    public int port;
    public Host(string name, int port);
    public Host(string name, string tlsName, int port);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static Host[] ParseHosts(string str, string defaultTlsName, int defaultPort);
    public static List`1<Host> ParseServiceHosts(string str);
}
public interface Aerospike.Client.IAerospikeClient {
    public Policy ReadPolicyDefault { get; public set; }
    public WritePolicy WritePolicyDefault { get; public set; }
    public ScanPolicy ScanPolicyDefault { get; public set; }
    public QueryPolicy QueryPolicyDefault { get; public set; }
    public BatchPolicy BatchPolicyDefault { get; public set; }
    public BatchPolicy BatchParentPolicyWriteDefault { get; public set; }
    public BatchWritePolicy BatchWritePolicyDefault { get; public set; }
    public BatchDeletePolicy BatchDeletePolicyDefault { get; public set; }
    public BatchUDFPolicy BatchUDFPolicyDefault { get; public set; }
    public InfoPolicy InfoPolicyDefault { get; public set; }
    public bool Connected { get; }
    public Cluster Cluster { get; }
    public Node[] Nodes { get; }
    public abstract virtual Policy get_ReadPolicyDefault();
    public abstract virtual void set_ReadPolicyDefault(Policy value);
    public abstract virtual WritePolicy get_WritePolicyDefault();
    public abstract virtual void set_WritePolicyDefault(WritePolicy value);
    public abstract virtual ScanPolicy get_ScanPolicyDefault();
    public abstract virtual void set_ScanPolicyDefault(ScanPolicy value);
    public abstract virtual QueryPolicy get_QueryPolicyDefault();
    public abstract virtual void set_QueryPolicyDefault(QueryPolicy value);
    public abstract virtual BatchPolicy get_BatchPolicyDefault();
    public abstract virtual void set_BatchPolicyDefault(BatchPolicy value);
    public abstract virtual BatchPolicy get_BatchParentPolicyWriteDefault();
    public abstract virtual void set_BatchParentPolicyWriteDefault(BatchPolicy value);
    public abstract virtual BatchWritePolicy get_BatchWritePolicyDefault();
    public abstract virtual void set_BatchWritePolicyDefault(BatchWritePolicy value);
    public abstract virtual BatchDeletePolicy get_BatchDeletePolicyDefault();
    public abstract virtual void set_BatchDeletePolicyDefault(BatchDeletePolicy value);
    public abstract virtual BatchUDFPolicy get_BatchUDFPolicyDefault();
    public abstract virtual void set_BatchUDFPolicyDefault(BatchUDFPolicy value);
    public abstract virtual InfoPolicy get_InfoPolicyDefault();
    public abstract virtual void set_InfoPolicyDefault(InfoPolicy value);
    public abstract virtual void Close();
    public abstract virtual bool get_Connected();
    public abstract virtual Cluster get_Cluster();
    public abstract virtual Node[] get_Nodes();
    public abstract virtual void EnableMetrics(MetricsPolicy metricsPolicy);
    public abstract virtual void DisableMetrics();
    public abstract virtual ClusterStats GetClusterStats();
    public abstract virtual void Put(WritePolicy policy, Key key, Bin[] bins);
    public abstract virtual void Append(WritePolicy policy, Key key, Bin[] bins);
    public abstract virtual void Prepend(WritePolicy policy, Key key, Bin[] bins);
    public abstract virtual void Add(WritePolicy policy, Key key, Bin[] bins);
    public abstract virtual bool Delete(WritePolicy policy, Key key);
    public abstract virtual BatchResults Delete(BatchPolicy batchPolicy, BatchDeletePolicy deletePolicy, Key[] keys);
    public abstract virtual void Truncate(InfoPolicy policy, string ns, string set, Nullable`1<DateTime> beforeLastUpdate);
    public abstract virtual void Touch(WritePolicy policy, Key key);
    public abstract virtual bool Exists(Policy policy, Key key);
    public abstract virtual Boolean[] Exists(BatchPolicy policy, Key[] keys);
    public abstract virtual Record Get(Policy policy, Key key);
    public abstract virtual Record Get(Policy policy, Key key, String[] binNames);
    public abstract virtual Record GetHeader(Policy policy, Key key);
    public abstract virtual bool Get(BatchPolicy policy, List`1<BatchRead> records);
    public abstract virtual Record[] Get(BatchPolicy policy, Key[] keys);
    public abstract virtual Record[] Get(BatchPolicy policy, Key[] keys, String[] binNames);
    public abstract virtual Record[] Get(BatchPolicy policy, Key[] keys, Operation[] ops);
    public abstract virtual Record[] GetHeader(BatchPolicy policy, Key[] keys);
    public abstract virtual Record Join(BatchPolicy policy, Key key, String[] binNames, Join[] joins);
    public abstract virtual Record Join(BatchPolicy policy, Key key, Join[] joins);
    public abstract virtual Record Operate(WritePolicy policy, Key key, Operation[] operations);
    public abstract virtual bool Operate(BatchPolicy policy, List`1<BatchRecord> records);
    public abstract virtual BatchResults Operate(BatchPolicy batchPolicy, BatchWritePolicy writePolicy, Key[] keys, Operation[] ops);
    public abstract virtual void ScanAll(ScanPolicy policy, string ns, string setName, ScanCallback callback, String[] binNames);
    public abstract virtual void ScanNode(ScanPolicy policy, string nodeName, string ns, string setName, ScanCallback callback, String[] binNames);
    public abstract virtual void ScanNode(ScanPolicy policy, Node node, string ns, string setName, ScanCallback callback, String[] binNames);
    public abstract virtual void ScanPartitions(ScanPolicy policy, PartitionFilter partitionFilter, string ns, string setName, ScanCallback callback, String[] binNames);
    public abstract virtual RegisterTask Register(Policy policy, string clientPath, string serverPath, Language language);
    public abstract virtual RegisterTask Register(Policy policy, Assembly resourceAssembly, string resourcePath, string serverPath, Language language);
    public abstract virtual RegisterTask RegisterUdfString(Policy policy, string code, string serverPath, Language language);
    public abstract virtual void RemoveUdf(InfoPolicy policy, string serverPath);
    public abstract virtual object Execute(WritePolicy policy, Key key, string packageName, string functionName, Value[] args);
    public abstract virtual BatchResults Execute(BatchPolicy batchPolicy, BatchUDFPolicy udfPolicy, Key[] keys, string packageName, string functionName, Value[] functionArgs);
    public abstract virtual ExecuteTask Execute(WritePolicy policy, Statement statement, string packageName, string functionName, Value[] functionArgs);
    public abstract virtual ExecuteTask Execute(WritePolicy policy, Statement statement, Operation[] operations);
    public abstract virtual void Query(QueryPolicy policy, Statement statement, Action`2<Key, Record> action);
    public abstract virtual RecordSet Query(QueryPolicy policy, Statement statement);
    public abstract virtual void Query(QueryPolicy policy, Statement statement, QueryListener listener);
    public abstract virtual void Query(QueryPolicy policy, Statement statement, PartitionFilter partitionFilter, QueryListener listener);
    public abstract virtual RecordSet QueryPartitions(QueryPolicy policy, Statement statement, PartitionFilter partitionFilter);
    public abstract virtual ResultSet QueryAggregate(QueryPolicy policy, Statement statement, string packageName, string functionName, Value[] functionArgs);
    public abstract virtual void QueryAggregate(QueryPolicy policy, Statement statement, Action`1<object> action);
    public abstract virtual ResultSet QueryAggregate(QueryPolicy policy, Statement statement);
    public abstract virtual IndexTask CreateIndex(Policy policy, string ns, string setName, string indexName, string binName, IndexType indexType);
    public abstract virtual IndexTask CreateIndex(Policy policy, string ns, string setName, string indexName, string binName, IndexType indexType, IndexCollectionType indexCollectionType, CTX[] ctx);
    public abstract virtual IndexTask DropIndex(Policy policy, string ns, string setName, string indexName);
    public abstract virtual void SetXDRFilter(InfoPolicy policy, string datacenter, string ns, Expression filter);
    public abstract virtual void CreateUser(AdminPolicy policy, string user, string password, IList`1<string> roles);
    public abstract virtual void DropUser(AdminPolicy policy, string user);
    public abstract virtual void ChangePassword(AdminPolicy policy, string user, string password);
    public abstract virtual void GrantRoles(AdminPolicy policy, string user, IList`1<string> roles);
    public abstract virtual void RevokeRoles(AdminPolicy policy, string user, IList`1<string> roles);
    public abstract virtual void CreateRole(AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public abstract virtual void CreateRole(AdminPolicy policy, string roleName, IList`1<Privilege> privileges, IList`1<string> whitelist);
    public abstract virtual void CreateRole(AdminPolicy policy, string roleName, IList`1<Privilege> privileges, IList`1<string> whitelist, int readQuota, int writeQuota);
    public abstract virtual void DropRole(AdminPolicy policy, string roleName);
    public abstract virtual void GrantPrivileges(AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public abstract virtual void RevokePrivileges(AdminPolicy policy, string roleName, IList`1<Privilege> privileges);
    public abstract virtual void SetWhitelist(AdminPolicy policy, string roleName, IList`1<string> whitelist);
    public abstract virtual void SetQuotas(AdminPolicy policy, string roleName, int readQuota, int writeQuota);
    public abstract virtual User QueryUser(AdminPolicy policy, string user);
    public abstract virtual List`1<User> QueryUsers(AdminPolicy policy);
    public abstract virtual Role QueryRole(AdminPolicy policy, string roleName);
    public abstract virtual List`1<Role> QueryRoles(AdminPolicy policy);
}
public interface Aerospike.Client.IAsyncClient {
    public abstract virtual Task Put(WritePolicy policy, CancellationToken token, Key key, Bin[] bins);
    public abstract virtual void Put(WritePolicy policy, WriteListener listener, Key key, Bin[] bins);
    public abstract virtual Task Append(WritePolicy policy, CancellationToken token, Key key, Bin[] bins);
    public abstract virtual void Append(WritePolicy policy, WriteListener listener, Key key, Bin[] bins);
    public abstract virtual Task Prepend(WritePolicy policy, CancellationToken token, Key key, Bin[] bins);
    public abstract virtual void Prepend(WritePolicy policy, WriteListener listener, Key key, Bin[] bins);
    public abstract virtual Task Add(WritePolicy policy, CancellationToken token, Key key, Bin[] bins);
    public abstract virtual void Add(WritePolicy policy, WriteListener listener, Key key, Bin[] bins);
    public abstract virtual Task`1<bool> Delete(WritePolicy policy, CancellationToken token, Key key);
    public abstract virtual void Delete(WritePolicy policy, DeleteListener listener, Key key);
    public abstract virtual Task`1<BatchResults> Delete(BatchPolicy batchPolicy, BatchDeletePolicy deletePolicy, CancellationToken token, Key[] keys);
    public abstract virtual void Delete(BatchPolicy batchPolicy, BatchDeletePolicy deletePolicy, BatchRecordArrayListener listener, Key[] keys);
    public abstract virtual void Delete(BatchPolicy batchPolicy, BatchDeletePolicy deletePolicy, BatchRecordSequenceListener listener, Key[] keys);
    public abstract virtual Task Touch(WritePolicy policy, CancellationToken token, Key key);
    public abstract virtual void Touch(WritePolicy policy, WriteListener listener, Key key);
    public abstract virtual Task`1<bool> Exists(Policy policy, CancellationToken token, Key key);
    public abstract virtual void Exists(Policy policy, ExistsListener listener, Key key);
    public abstract virtual Task`1<Boolean[]> Exists(BatchPolicy policy, CancellationToken token, Key[] keys);
    public abstract virtual void Exists(BatchPolicy policy, ExistsArrayListener listener, Key[] keys);
    public abstract virtual void Exists(BatchPolicy policy, ExistsSequenceListener listener, Key[] keys);
    public abstract virtual Task`1<Record> Get(Policy policy, CancellationToken token, Key key);
    public abstract virtual void Get(Policy policy, RecordListener listener, Key key);
    public abstract virtual Task`1<Record> Get(Policy policy, CancellationToken token, Key key, String[] binNames);
    public abstract virtual void Get(Policy policy, RecordListener listener, Key key, String[] binNames);
    public abstract virtual Task`1<Record> GetHeader(Policy policy, CancellationToken token, Key key);
    public abstract virtual void GetHeader(Policy policy, RecordListener listener, Key key);
    public abstract virtual Task`1<List`1<BatchRead>> Get(BatchPolicy policy, CancellationToken token, List`1<BatchRead> records);
    public abstract virtual void Get(BatchPolicy policy, BatchListListener listener, List`1<BatchRead> records);
    public abstract virtual void Get(BatchPolicy policy, BatchSequenceListener listener, List`1<BatchRead> records);
    public abstract virtual Task`1<Record[]> Get(BatchPolicy policy, CancellationToken token, Key[] keys);
    public abstract virtual void Get(BatchPolicy policy, RecordArrayListener listener, Key[] keys);
    public abstract virtual void Get(BatchPolicy policy, RecordSequenceListener listener, Key[] keys);
    public abstract virtual Task`1<Record[]> Get(BatchPolicy policy, CancellationToken token, Key[] keys, String[] binNames);
    public abstract virtual void Get(BatchPolicy policy, RecordArrayListener listener, Key[] keys, String[] binNames);
    public abstract virtual void Get(BatchPolicy policy, RecordSequenceListener listener, Key[] keys, String[] binNames);
    public abstract virtual Task`1<Record[]> Get(BatchPolicy policy, CancellationToken token, Key[] keys, Operation[] ops);
    public abstract virtual void Get(BatchPolicy policy, RecordArrayListener listener, Key[] keys, Operation[] ops);
    public abstract virtual void Get(BatchPolicy policy, RecordSequenceListener listener, Key[] keys, Operation[] ops);
    public abstract virtual Task`1<Record[]> GetHeader(BatchPolicy policy, CancellationToken token, Key[] keys);
    public abstract virtual void GetHeader(BatchPolicy policy, RecordArrayListener listener, Key[] keys);
    public abstract virtual void GetHeader(BatchPolicy policy, RecordSequenceListener listener, Key[] keys);
    public abstract virtual Task`1<Record> Operate(WritePolicy policy, CancellationToken token, Key key, Operation[] ops);
    public abstract virtual void Operate(WritePolicy policy, RecordListener listener, Key key, Operation[] ops);
    public abstract virtual Task`1<bool> Operate(BatchPolicy policy, CancellationToken token, List`1<BatchRecord> records);
    public abstract virtual void Operate(BatchPolicy policy, BatchOperateListListener listener, List`1<BatchRecord> records);
    public abstract virtual void Operate(BatchPolicy policy, BatchRecordSequenceListener listener, List`1<BatchRecord> records);
    public abstract virtual Task`1<BatchResults> Operate(BatchPolicy batchPolicy, BatchWritePolicy writePolicy, CancellationToken token, Key[] keys, Operation[] ops);
    public abstract virtual void Operate(BatchPolicy batchPolicy, BatchWritePolicy writePolicy, BatchRecordArrayListener listener, Key[] keys, Operation[] ops);
    public abstract virtual void Operate(BatchPolicy batchPolicy, BatchWritePolicy writePolicy, BatchRecordSequenceListener listener, Key[] keys, Operation[] ops);
    public abstract virtual void ScanAll(ScanPolicy policy, RecordSequenceListener listener, string ns, string setName, String[] binNames);
    public abstract virtual void ScanPartitions(ScanPolicy policy, RecordSequenceListener listener, PartitionFilter partitionFilter, string ns, string setName, String[] binNames);
    public abstract virtual Task`1<object> Execute(WritePolicy policy, CancellationToken token, Key key, string packageName, string functionName, Value[] functionArgs);
    public abstract virtual void Execute(WritePolicy policy, ExecuteListener listener, Key key, string packageName, string functionName, Value[] functionArgs);
    public abstract virtual Task`1<BatchResults> Execute(BatchPolicy batchPolicy, BatchUDFPolicy udfPolicy, CancellationToken token, Key[] keys, string packageName, string functionName, Value[] functionArgs);
    public abstract virtual void Execute(BatchPolicy batchPolicy, BatchUDFPolicy udfPolicy, BatchRecordArrayListener listener, Key[] keys, string packageName, string functionName, Value[] functionArgs);
    public abstract virtual void Execute(BatchPolicy batchPolicy, BatchUDFPolicy udfPolicy, BatchRecordSequenceListener listener, Key[] keys, string packageName, string functionName, Value[] functionArgs);
    public abstract virtual void Query(QueryPolicy policy, RecordSequenceListener listener, Statement statement);
    public abstract virtual void QueryPartitions(QueryPolicy policy, RecordSequenceListener listener, Statement statement, PartitionFilter partitionFilter);
}
public interface Aerospike.Client.IAsyncCommand {
    public abstract virtual void OnConnected();
    public abstract virtual void SendComplete();
    public abstract virtual void ReceiveComplete();
    public abstract virtual void OnSocketError(SocketError se);
    public abstract virtual void OnError(Exception e);
}
public interface Aerospike.Client.IBatchStatus {
    public abstract virtual void BatchKeyError(Cluster cluster, Key key, int index, AerospikeException ae, bool inDoubt, bool hasWrite);
    public abstract virtual void BatchKeyError(AerospikeException ae);
}
public interface Aerospike.Client.IConnection {
    public abstract virtual void SetTimeout(int timeoutMillis);
    public abstract virtual void Write(Byte[] buffer, int length);
    public abstract virtual void ReadFully(Byte[] buffer, int length);
    public abstract virtual void ReadFully(Byte[] buffer, int length, byte state);
    public abstract virtual Stream GetStream();
    public abstract virtual bool IsClosed();
    public abstract virtual void UpdateLastUsed();
    public abstract virtual void Close();
}
public interface Aerospike.Client.IMetricsListener {
    public abstract virtual void OnEnable(Cluster cluster, MetricsPolicy policy);
    public abstract virtual void OnSnapshot(Cluster cluster);
    public abstract virtual void OnNodeClose(Node node);
    public abstract virtual void OnDisable(Cluster cluster);
}
public enum Aerospike.Client.IndexCollectionType : Enum {
    public int value__;
    public static IndexCollectionType DEFAULT;
    public static IndexCollectionType LIST;
    public static IndexCollectionType MAPKEYS;
    public static IndexCollectionType MAPVALUES;
}
public class Aerospike.Client.IndexTask : BaseTask {
    private string ns;
    private string indexName;
    private bool isCreate;
    private string statusCommand;
    private string existsCommand;
    public IndexTask(Cluster cluster, Policy policy, string ns, string indexName, bool isCreate);
    public virtual int QueryStatus();
    public static string BuildStatusCommand(string ns, string indexName);
    public static int ParseStatusResponse(string command, string response, bool isCreate);
    public static string BuildExistsCommand(string ns, string indexName);
    public static int ParseExistsResponse(string command, string response);
}
public enum Aerospike.Client.IndexType : Enum {
    public int value__;
    public static IndexType NUMERIC;
    public static IndexType STRING;
    public static IndexType BLOB;
    public static IndexType GEO2DSPHERE;
}
public class Aerospike.Client.Info : object {
    private static int DEFAULT_TIMEOUT;
    public Byte[] buffer;
    public int length;
    public int offset;
    public Info(Connection conn, string command);
    public Info(Connection conn, String[] commands);
    public Info(Connection conn, List`1<string> commands);
    public Info(Connection conn);
    public Info(Byte[] buffer, int length, int offset);
    public static string Request(Node node, string name);
    public static string Request(InfoPolicy policy, Node node, string name);
    public static Dictionary`2<string, string> Request(InfoPolicy policy, Node node, String[] names);
    public static Dictionary`2<string, string> Request(InfoPolicy policy, Node node);
    public static string Request(string hostname, int port, string name);
    public static Dictionary`2<string, string> Request(string hostname, int port, String[] names);
    public static Dictionary`2<string, string> Request(string hostname, int port);
    public static string Request(IPEndPoint socketAddress, string name);
    public static Dictionary`2<string, string> Request(IPEndPoint socketAddress, String[] names);
    public static Dictionary`2<string, string> Request(IPEndPoint socketAddress);
    public static string Request(Connection conn, string name);
    public static Dictionary`2<string, string> Request(Connection conn, String[] names);
    public static Dictionary`2<string, string> Request(Connection conn, List`1<string> names);
    public static Dictionary`2<string, string> Request(Connection conn);
    private void SendCommand(Connection conn);
    private void ResizeBuffer(int size);
    private string ParseSingleResponse(string name);
    public Dictionary`2<string, string> ParseMultiResponse();
    public void ParseName(string name);
    private void CheckError();
    public string GetValue();
    public NameValueParser GetNameValueParser();
    public void SkipToValue();
    public void SkipDelimiter(char stop);
    public int ParseInt();
    public string ParseString(char stop);
    public string ParseString(char stop1, char stop2, char stop3);
    public void Expect(char expected);
    public string GetTruncatedResponse();
}
public interface Aerospike.Client.InfoListener {
    public abstract virtual void OnSuccess(Dictionary`2<string, string> map);
    public abstract virtual void OnFailure(AerospikeException ae);
}
public class Aerospike.Client.InfoPolicy : object {
    public int timeout;
    public InfoPolicy(InfoPolicy other);
    public InfoPolicy(Policy other);
}
public interface Aerospike.Client.IQueryExecutor {
    public abstract virtual bool StopThreads(Exception cause);
    public abstract virtual void CheckForException();
}
public interface Aerospike.Client.IRecordParser {
    public abstract virtual Record ParseRecord(Byte[] dataBuffer, Int32& dataOffset, int opCount, int generation, int expiration, bool isOperation);
}
public interface Aerospike.Client.IRecordSet {
    public Key Key { get; }
    public Record Record { get; }
    public CancellationToken CancelToken { get; }
    public abstract virtual bool Next();
    public abstract virtual void Dispose();
    public abstract virtual void Close();
    public abstract virtual Key get_Key();
    public abstract virtual Record get_Record();
    public abstract virtual CancellationToken get_CancelToken();
    public abstract virtual bool Put(KeyRecord record);
}
public interface Aerospike.Client.IResultSet {
    public object Object { get; }
    public CancellationToken CancelToken { get; }
    public abstract virtual bool Next();
    public abstract virtual void Dispose();
    public abstract virtual void Close();
    public abstract virtual object get_Object();
    public abstract virtual CancellationToken get_CancelToken();
    public abstract virtual bool Put(object obj);
}
public interface Aerospike.Client.ITimeout {
    public abstract virtual bool CheckTimeout();
}
public class Aerospike.Client.Join : object {
    internal string leftKeysBinName;
    internal string rightNamespace;
    internal string rightSetName;
    internal String[] rightBinNames;
    public Join(string leftKeysBinName, string rightNamespace, string rightSetName);
    public Join(string leftKeysBinName, string rightNamespace, string rightSetName, String[] rightBinNames);
}
public class Aerospike.Client.Key : object {
    public string ns;
    public string setName;
    public Byte[] digest;
    public Value userKey;
    public Key(string ns, string setName, Value key);
    public Key(string ns, string setName, string key);
    public Key(string ns, string setName, Byte[] key);
    public Key(string ns, string setName, Byte[] key, int offset, int length);
    public Key(string ns, string setName, long key);
    public Key(string ns, string setName, ulong key);
    public Key(string ns, string setName, int key);
    public Key(string ns, string setName, UInt32 key);
    public Key(string ns, string setName, short key);
    public Key(string ns, string setName, ushort key);
    public Key(string ns, string setName, bool key);
    public Key(string ns, string setName, byte key);
    public Key(string ns, string setName, sbyte key);
    public Key(string ns, Byte[] digest, string setName, Value userKey);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public static Byte[] ComputeDigest(string setName, Value key);
}
public class Aerospike.Client.KeyRecord : object {
    public Key key;
    public Record record;
    public KeyRecord(Key key, Record record);
}
public enum Aerospike.Client.Language : Enum {
    public int value__;
    public static Language LUA;
}
public static class Aerospike.Client.Latency : object {
    public static int GetMax();
    public static string LatencyTypeToString(LatencyType type);
}
public class Aerospike.Client.LatencyBuckets : object {
    private static long NS_TO_MS;
    private Int32[] modreq(System.Runtime.CompilerServices.IsVolatile) buckets;
    private int latencyShift;
    public LatencyBuckets(int latencyColumns, int latencyShift);
    public int GetMax();
    public long GetBucket(int i);
    public void Add(long elapsed);
    private int GetIndex(long elapsedNanos);
}
internal abstract class Aerospike.Client.ListenerAdapter`1 : object {
    private TaskCompletionSource`1<T> tcs;
    private CancellationTokenRegistration ctr;
    public Task`1<T> Task { get; }
    public ListenerAdapter`1(CancellationToken token);
    protected void SetResult(T result);
    public sealed virtual void OnFailure(AerospikeException exception);
    public Task`1<T> get_Task();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0();
}
public class Aerospike.Client.ListExp : object {
    private static int MODULE;
    public static Exp Append(ListPolicy policy, Exp value, Exp bin, CTX[] ctx);
    public static Exp AppendItems(ListPolicy policy, Exp list, Exp bin, CTX[] ctx);
    public static Exp Insert(ListPolicy policy, Exp index, Exp value, Exp bin, CTX[] ctx);
    public static Exp InsertItems(ListPolicy policy, Exp index, Exp list, Exp bin, CTX[] ctx);
    public static Exp Increment(ListPolicy policy, Exp index, Exp value, Exp bin, CTX[] ctx);
    public static Exp Set(ListPolicy policy, Exp index, Exp value, Exp bin, CTX[] ctx);
    public static Exp Clear(Exp bin, CTX[] ctx);
    public static Exp Sort(ListSortFlags sortFlags, Exp bin, CTX[] ctx);
    public static Exp RemoveByValue(ListReturnType returnType, Exp value, Exp bin, CTX[] ctx);
    public static Exp RemoveByValueList(ListReturnType returnType, Exp values, Exp bin, CTX[] ctx);
    public static Exp RemoveByValueRange(ListReturnType returnType, Exp valueBegin, Exp valueEnd, Exp bin, CTX[] ctx);
    public static Exp RemoveByValueRelativeRankRange(ListReturnType returnType, Exp value, Exp rank, Exp bin, CTX[] ctx);
    public static Exp RemoveByValueRelativeRankRange(ListReturnType returnType, Exp value, Exp rank, Exp count, Exp bin, CTX[] ctx);
    public static Exp RemoveByIndex(Exp index, Exp bin, CTX[] ctx);
    public static Exp RemoveByIndexRange(ListReturnType returnType, Exp index, Exp bin, CTX[] ctx);
    public static Exp RemoveByIndexRange(ListReturnType returnType, Exp index, Exp count, Exp bin, CTX[] ctx);
    public static Exp RemoveByRank(Exp rank, Exp bin, CTX[] ctx);
    public static Exp RemoveByRankRange(ListReturnType returnType, Exp rank, Exp bin, CTX[] ctx);
    public static Exp RemoveByRankRange(ListReturnType returnType, Exp rank, Exp count, Exp bin, CTX[] ctx);
    public static Exp Size(Exp bin, CTX[] ctx);
    public static Exp GetByValue(ListReturnType returnType, Exp value, Exp bin, CTX[] ctx);
    public static Exp GetByValueRange(ListReturnType returnType, Exp valueBegin, Exp valueEnd, Exp bin, CTX[] ctx);
    public static Exp GetByValueList(ListReturnType returnType, Exp values, Exp bin, CTX[] ctx);
    public static Exp GetByValueRelativeRankRange(ListReturnType returnType, Exp value, Exp rank, Exp bin, CTX[] ctx);
    public static Exp GetByValueRelativeRankRange(ListReturnType returnType, Exp value, Exp rank, Exp count, Exp bin, CTX[] ctx);
    public static Exp GetByIndex(ListReturnType returnType, Type valueType, Exp index, Exp bin, CTX[] ctx);
    public static Exp GetByIndexRange(ListReturnType returnType, Exp index, Exp bin, CTX[] ctx);
    public static Exp GetByIndexRange(ListReturnType returnType, Exp index, Exp count, Exp bin, CTX[] ctx);
    public static Exp GetByRank(ListReturnType returnType, Type valueType, Exp rank, Exp bin, CTX[] ctx);
    public static Exp GetByRankRange(ListReturnType returnType, Exp rank, Exp bin, CTX[] ctx);
    public static Exp GetByRankRange(ListReturnType returnType, Exp rank, Exp count, Exp bin, CTX[] ctx);
    private static Exp AddWrite(Exp bin, Byte[] bytes, CTX[] ctx);
    private static Exp AddRead(Exp bin, Byte[] bytes, Type retType);
    private static Type GetValueType(ListReturnType returnType);
    internal static Byte[] PackRangeOperation(int command, int returnType, Exp begin, Exp end, CTX[] ctx);
}
public class Aerospike.Client.ListOperation : object {
    internal static int SET_TYPE;
    internal static int APPEND;
    internal static int APPEND_ITEMS;
    internal static int INSERT;
    internal static int INSERT_ITEMS;
    internal static int POP;
    internal static int POP_RANGE;
    internal static int REMOVE;
    internal static int REMOVE_RANGE;
    internal static int SET;
    internal static int TRIM;
    internal static int CLEAR;
    internal static int INCREMENT;
    internal static int SORT;
    internal static int SIZE;
    internal static int GET;
    internal static int GET_RANGE;
    internal static int GET_BY_INDEX;
    internal static int GET_BY_RANK;
    internal static int GET_BY_VALUE;
    internal static int GET_BY_VALUE_LIST;
    internal static int GET_BY_INDEX_RANGE;
    internal static int GET_BY_VALUE_INTERVAL;
    internal static int GET_BY_RANK_RANGE;
    internal static int GET_BY_VALUE_REL_RANK_RANGE;
    internal static int REMOVE_BY_INDEX;
    internal static int REMOVE_BY_RANK;
    internal static int REMOVE_BY_VALUE;
    internal static int REMOVE_BY_VALUE_LIST;
    internal static int REMOVE_BY_INDEX_RANGE;
    internal static int REMOVE_BY_VALUE_INTERVAL;
    internal static int REMOVE_BY_RANK_RANGE;
    internal static int REMOVE_BY_VALUE_REL_RANK_RANGE;
    public static Operation Create(string binName, ListOrder order, bool pad, CTX[] ctx);
    public static Operation SetOrder(string binName, ListOrder order, CTX[] ctx);
    public static Operation Append(string binName, Value value, CTX[] ctx);
    public static Operation Append(ListPolicy policy, string binName, Value value, CTX[] ctx);
    public static Operation AppendItems(string binName, IList list, CTX[] ctx);
    public static Operation AppendItems(ListPolicy policy, string binName, IList list, CTX[] ctx);
    public static Operation Insert(string binName, int index, Value value, CTX[] ctx);
    public static Operation Insert(ListPolicy policy, string binName, int index, Value value, CTX[] ctx);
    public static Operation InsertItems(string binName, int index, IList list, CTX[] ctx);
    public static Operation InsertItems(ListPolicy policy, string binName, int index, IList list, CTX[] ctx);
    public static Operation Increment(string binName, int index, CTX[] ctx);
    public static Operation Increment(ListPolicy policy, string binName, int index, CTX[] ctx);
    public static Operation Increment(string binName, int index, Value value, CTX[] ctx);
    public static Operation Increment(ListPolicy policy, string binName, int index, Value value, CTX[] ctx);
    public static Operation Pop(string binName, int index, CTX[] ctx);
    public static Operation PopRange(string binName, int index, int count, CTX[] ctx);
    public static Operation PopRange(string binName, int index, CTX[] ctx);
    public static Operation Remove(string binName, int index, CTX[] ctx);
    public static Operation RemoveRange(string binName, int index, int count, CTX[] ctx);
    public static Operation RemoveRange(string binName, int index, CTX[] ctx);
    public static Operation Set(string binName, int index, Value value, CTX[] ctx);
    public static Operation Set(ListPolicy policy, string binName, int index, Value value, CTX[] ctx);
    public static Operation Trim(string binName, int index, int count, CTX[] ctx);
    public static Operation Clear(string binName, CTX[] ctx);
    public static Operation Sort(string binName, ListSortFlags sortFlags, CTX[] ctx);
    public static Operation RemoveByValue(string binName, Value value, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValueList(string binName, IList values, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValueRange(string binName, Value valueBegin, Value valueEnd, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValueRelativeRankRange(string binName, Value value, int rank, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValueRelativeRankRange(string binName, Value value, int rank, int count, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByIndex(string binName, int index, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByIndexRange(string binName, int index, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByIndexRange(string binName, int index, int count, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByRank(string binName, int rank, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByRankRange(string binName, int rank, ListReturnType returnType, CTX[] ctx);
    public static Operation RemoveByRankRange(string binName, int rank, int count, ListReturnType returnType, CTX[] ctx);
    public static Operation Size(string binName, CTX[] ctx);
    public static Operation Get(string binName, int index, CTX[] ctx);
    public static Operation GetRange(string binName, int index, int count, CTX[] ctx);
    public static Operation GetRange(string binName, int index, CTX[] ctx);
    public static Operation GetByValue(string binName, Value value, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByValueRange(string binName, Value valueBegin, Value valueEnd, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByValueList(string binName, IList values, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByValueRelativeRankRange(string binName, Value value, int rank, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByValueRelativeRankRange(string binName, Value value, int rank, int count, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByIndex(string binName, int index, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByIndexRange(string binName, int index, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByIndexRange(string binName, int index, int count, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByRank(string binName, int rank, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByRankRange(string binName, int rank, ListReturnType returnType, CTX[] ctx);
    public static Operation GetByRankRange(string binName, int rank, int count, ListReturnType returnType, CTX[] ctx);
}
public enum Aerospike.Client.ListOrder : Enum {
    public int value__;
    public static ListOrder UNORDERED;
    public static ListOrder ORDERED;
}
public class Aerospike.Client.ListPolicy : object {
    public static ListPolicy Default;
    internal int attributes;
    internal int flags;
    public ListPolicy(ListOrder order, ListWriteFlags flags);
    private static ListPolicy();
}
[FlagsAttribute]
public enum Aerospike.Client.ListReturnType : Enum {
    public int value__;
    public static ListReturnType NONE;
    public static ListReturnType INDEX;
    public static ListReturnType REVERSE_INDEX;
    public static ListReturnType RANK;
    public static ListReturnType REVERSE_RANK;
    public static ListReturnType COUNT;
    public static ListReturnType VALUE;
    public static ListReturnType EXISTS;
    public static ListReturnType INVERTED;
}
public enum Aerospike.Client.ListSortFlags : Enum {
    public int value__;
    public static ListSortFlags DEFAULT;
    public static ListSortFlags DROP_DUPLICATES;
}
[FlagsAttribute]
public enum Aerospike.Client.ListWriteFlags : Enum {
    public int value__;
    public static ListWriteFlags DEFAULT;
    public static ListWriteFlags ADD_UNIQUE;
    public static ListWriteFlags INSERT_BOUNDED;
    public static ListWriteFlags NO_FAIL;
    public static ListWriteFlags PARTIAL;
}
public class Aerospike.Client.Log : object {
    private static Level LogLevel;
    private static Callback LogCallback;
    private static ContextCallback LogContextCallback;
    private static bool LogEnabled;
    private static bool LogSet;
    private static Log();
    public static void SetLevel(Level level);
    public static void SetCallback(Callback callback);
    public static void SetContextCallback(ContextCallback callback);
    public static void SetCallbackStandard();
    public static void Disable();
    public static bool IsSet();
    public static bool WarnEnabled();
    public static bool InfoEnabled();
    public static bool DebugEnabled();
    public static void Error(string message);
    public static void Error(Context context, string message);
    public static void Warn(string message);
    public static void Warn(Context context, string message);
    public static void Info(string message);
    public static void Info(Context context, string message);
    public static void Debug(string message);
    public static void Debug(Context context, string message);
    public static void LogMessage(Level level, string message);
    public static void LogMessage(Context context, Level level, string message);
}
public class Aerospike.Client.LuaAerospike : object {
    public static void log(int level, string message);
    public static void LoadLibrary(LuaInstance lua);
}
[DefaultMemberAttribute("Item")]
public class Aerospike.Client.LuaBytes : object {
    private Byte[] bytes;
    private int length;
    private int type;
    public byte Item { get; public set; }
    public LuaBytes(Byte[] bytes);
    public LuaBytes(int capacity);
    public bool SetBigInt16(ushort value, int offset);
    public bool SetLittleInt16(ushort value, int offset);
    public bool SetBigInt32(UInt32 value, int offset);
    public bool SetLittleInt32(UInt32 value, int offset);
    public bool SetBigInt64(ulong value, int offset);
    public bool SetLittleInt64(ulong value, int offset);
    public int SetVarInt(UInt32 value, int offset);
    public bool SetString(string value, int offset);
    public bool SetBytes(LuaBytes value, int offset, int len);
    public bool SetByte(byte value, int offset);
    public string GetString(int offset, int len);
    public Byte[] GetBytes(int offset, int len);
    public byte GetByte(int offset);
    public int GetShortBig(int offset);
    public int GetShortLittle(int offset);
    public int GetIntBig(int offset);
    public int GetIntLittle(int offset);
    public long GetLongBig(int offset);
    public long GetLongLittle(int offset);
    private void EnsureCapacity(int capacity);
    private void ResetSize(int capacity);
    public void SetCapacity(int capacity);
    public byte get_Item(int offset);
    public void set_Item(int offset, byte value);
    public sealed virtual object LuaToObject();
    public virtual string ToString();
    public static int size(LuaBytes bytes);
    public static bool set_size(LuaBytes bytes, int capacity);
    public static int get_type(LuaBytes bytes);
    public static bool set_type(LuaBytes bytes, int type);
    public static string get_string(LuaBytes bytes, int offset, int len);
    public static LuaBytes get_bytes(LuaBytes bytes, int offset, int len);
    public static byte get_byte(LuaBytes bytes, int offset);
    public static int get_int16(LuaBytes bytes, int offset);
    public static int get_int16_be(LuaBytes bytes, int offset);
    public static int get_int16_le(LuaBytes bytes, int offset);
    public static int get_int32(LuaBytes bytes, int offset);
    public static int get_int32_be(LuaBytes bytes, int offset);
    public static int get_int32_le(LuaBytes bytes, int offset);
    public static long get_int64(LuaBytes bytes, int offset);
    public static long get_int64_be(LuaBytes bytes, int offset);
    public static long get_int64_le(LuaBytes bytes, int offset);
    public static int get_var_int(LuaBytes bytes, int offset, Int32& size);
    public static bool set_string(LuaBytes bytes, int offset, string value);
    public static bool set_bytes(LuaBytes bytes, int offset, LuaBytes src, int length);
    public static bool set_byte(LuaBytes bytes, int offset, byte value);
    public static bool set_int16(LuaBytes bytes, int offset, ushort value);
    public static bool set_int16_be(LuaBytes bytes, int offset, ushort value);
    public static bool set_int16_le(LuaBytes bytes, int offset, ushort value);
    public static bool set_int32(LuaBytes bytes, int offset, UInt32 value);
    public static bool set_int32_be(LuaBytes bytes, int offset, UInt32 value);
    public static bool set_int32_le(LuaBytes bytes, int offset, UInt32 value);
    public static bool set_int64(LuaBytes bytes, int offset, ulong value);
    public static bool set_int64_be(LuaBytes bytes, int offset, ulong value);
    public static bool set_int64_le(LuaBytes bytes, int offset, ulong value);
    public static int set_var_int(LuaBytes bytes, int offset, UInt32 value);
    public static bool append_string(LuaBytes bytes, string value);
    public static bool append_bytes(LuaBytes bytes, LuaBytes src, int length);
    public static bool append_byte(LuaBytes bytes, byte value);
    public static bool append_int16(LuaBytes bytes, ushort value);
    public static bool append_int16_be(LuaBytes bytes, ushort value);
    public static bool append_int16_le(LuaBytes bytes, ushort value);
    public static bool append_int32(LuaBytes bytes, UInt32 value);
    public static bool append_int32_be(LuaBytes bytes, UInt32 value);
    public static bool append_int32_le(LuaBytes bytes, UInt32 value);
    public static bool append_int64(LuaBytes bytes, ulong value);
    public static bool append_int64_be(LuaBytes bytes, ulong value);
    public static bool append_int64_le(LuaBytes bytes, ulong value);
    public static int append_var_int(LuaBytes bytes, UInt32 value);
}
public class Aerospike.Client.LuaCache : object {
    private static ConcurrentQueue`1<LuaInstance> InstanceQueue;
    private static int InstanceCount;
    private static LuaCache();
    public static LuaInstance GetInstance();
    public static void PutInstance(LuaInstance instance);
}
public class Aerospike.Client.LuaConfig : object {
    public static string PackagePath;
    public static int InstancePoolSize;
    private static LuaConfig();
}
public interface Aerospike.Client.LuaData {
    public abstract virtual object LuaToObject();
}
public class Aerospike.Client.LuaGeoJSON : object {
    private string value;
    public LuaGeoJSON(string value);
    public sealed virtual object LuaToObject();
    public virtual string ToString();
    public static int size(LuaGeoJSON value);
}
public class Aerospike.Client.LuaInputStream : LuaStream {
    private BlockingCollection`1<object> queue;
    private CancellationToken cancelToken;
    public LuaInputStream(BlockingCollection`1<object> queue, CancellationToken cancelToken);
    public virtual object Read();
    public virtual void Write(object value);
    public virtual bool Readable();
    public virtual bool Writeable();
    public virtual string ToString();
}
public class Aerospike.Client.LuaInstance : object {
    private Lua lua;
    private LuaGlobal global;
    private HashSet`1<string> packages;
    public bool debug;
    public void Close();
    public void LoadPackage(Statement statement);
    private void LoadSystemPackage(Assembly assembly, string packageName);
    private void LoadPackageFromResource(Assembly assembly, string resourcePath, string packageName);
    private void LoadPackageFromFile(string packageName);
    private void LoadPackageFromString(string packageName, string packageContents);
    private string FindFile(string packageName);
    public void ClearPackages();
    public void Call(string functionName, Object[] args);
    public object GetFunction(string functionName);
    public void Register(string name, object value);
    public static object BytesToLua(ParticleType type, Byte[] buf, int offset, int len);
    public static object LuaToObject(object source);
}
[DefaultMemberAttribute("Item")]
public class Aerospike.Client.LuaList : object {
    protected internal List`1<object> list;
    public object Item { get; public set; }
    public LuaList(List`1<object> list);
    public LuaList(LuaTable table);
    public static LuaList create(int capacity);
    public static int size(LuaList list);
    public static Func`1<object> iterator(LuaList list);
    public static void insert(LuaList list, int index, object obj);
    public static void append(LuaList list, object obj);
    public static void prepend(LuaList list, object obj);
    public static LuaList take(LuaList list, int count);
    public static void remove(LuaList list, int index);
    public static LuaList drop(LuaList list, int count);
    public static void trim(LuaList list, int index);
    public static LuaList clone(LuaList list);
    public static void concat(LuaList list1, LuaList list2);
    public static LuaList merge(LuaList list1, LuaList list2);
    public object get_Item(int index);
    public void set_Item(int index, object value);
    public virtual string ToString();
    public sealed virtual object LuaToObject();
}
public class Aerospike.Client.LuaListIterator : object {
    protected internal Enumerator<object> iter;
    public LuaListIterator(Enumerator<object> iter);
    public object next();
}
public class Aerospike.Client.LuaMap : LuaTable {
    protected internal IDictionary`2<object, object> map;
    public LuaMap(IDictionary`2<object, object> map);
    public LuaMap(LuaTable table);
    public static LuaMap create(int capacity);
    public static int size(LuaMap map);
    public static bool remove(LuaMap map, object key);
    public static LuaMap clone(LuaMap map);
    public static LuaMap merge(LuaMap map1, LuaMap map2, Func`3<object, object, LuaResult> func);
    public static LuaMap diff(LuaMap map1, LuaMap map2);
    public static Func`1<Object[]> pairs(LuaMap map);
    public static Func`1<object> keys(LuaMap map);
    public static Func`1<object> values(LuaMap map);
    protected virtual object OnIndex(object key);
    protected virtual bool OnNewIndex(object key, object value);
    public virtual string ToString();
    public sealed virtual object LuaToObject();
}
public class Aerospike.Client.LuaMapIterator : object {
    protected internal IEnumerator iter;
    public LuaMapIterator(IEnumerator iter);
    public Object[] NextPair();
    public object NextKey();
    public object NextValue();
}
public class Aerospike.Client.LuaOutputStream : LuaStream {
    private ResultSet resultSet;
    public LuaOutputStream(ResultSet resultSet);
    public virtual object Read();
    public virtual void Write(object obj);
    public virtual bool Readable();
    public virtual bool Writeable();
    public virtual string ToString();
}
public abstract class Aerospike.Client.LuaStream : object {
    public static void LoadLibrary(LuaInstance lua);
    public static object read(LuaStream stream);
    public static void write(LuaStream stream, object obj);
    public static bool readable(LuaStream stream);
    public static bool writeable(LuaStream stream);
    public abstract virtual object Read();
    public abstract virtual void Write(object obj);
    public abstract virtual bool Readable();
    public abstract virtual bool Writeable();
}
public class Aerospike.Client.MapExp : object {
    private static int MODULE;
    public static Exp Put(MapPolicy policy, Exp key, Exp value, Exp bin, CTX[] ctx);
    public static Exp PutItems(MapPolicy policy, Exp map, Exp bin, CTX[] ctx);
    public static Exp Increment(MapPolicy policy, Exp key, Exp incr, Exp bin, CTX[] ctx);
    public static Exp Clear(Exp bin, CTX[] ctx);
    public static Exp RemoveByKey(Exp key, Exp bin, CTX[] ctx);
    public static Exp RemoveByKeyList(MapReturnType returnType, Exp keys, Exp bin, CTX[] ctx);
    public static Exp RemoveByKeyRange(MapReturnType returnType, Exp keyBegin, Exp keyEnd, Exp bin, CTX[] ctx);
    public static Exp RemoveByKeyRelativeIndexRange(MapReturnType returnType, Exp key, Exp index, Exp bin, CTX[] ctx);
    public static Exp RemoveByKeyRelativeIndexRange(MapReturnType returnType, Exp key, Exp index, Exp count, Exp bin, CTX[] ctx);
    public static Exp RemoveByValue(MapReturnType returnType, Exp value, Exp bin, CTX[] ctx);
    public static Exp RemoveByValueList(MapReturnType returnType, Exp values, Exp bin, CTX[] ctx);
    public static Exp RemoveByValueRange(MapReturnType returnType, Exp valueBegin, Exp valueEnd, Exp bin, CTX[] ctx);
    public static Exp RemoveByValueRelativeRankRange(MapReturnType returnType, Exp value, Exp rank, Exp bin, CTX[] ctx);
    public static Exp RemoveByValueRelativeRankRange(MapReturnType returnType, Exp value, Exp rank, Exp count, Exp bin, CTX[] ctx);
    public static Exp RemoveByIndex(Exp index, Exp bin, CTX[] ctx);
    public static Exp RemoveByIndexRange(MapReturnType returnType, Exp index, Exp bin, CTX[] ctx);
    public static Exp RemoveByIndexRange(MapReturnType returnType, Exp index, Exp count, Exp bin, CTX[] ctx);
    public static Exp RemoveByRank(Exp rank, Exp bin, CTX[] ctx);
    public static Exp RemoveByRankRange(MapReturnType returnType, Exp rank, Exp bin, CTX[] ctx);
    public static Exp RemoveByRankRange(MapReturnType returnType, Exp rank, Exp count, Exp bin, CTX[] ctx);
    public static Exp Size(Exp bin, CTX[] ctx);
    public static Exp GetByKey(MapReturnType returnType, Type valueType, Exp key, Exp bin, CTX[] ctx);
    public static Exp GetByKeyRange(MapReturnType returnType, Exp keyBegin, Exp keyEnd, Exp bin, CTX[] ctx);
    public static Exp GetByKeyList(MapReturnType returnType, Exp keys, Exp bin, CTX[] ctx);
    public static Exp GetByKeyRelativeIndexRange(MapReturnType returnType, Exp key, Exp index, Exp bin, CTX[] ctx);
    public static Exp GetByKeyRelativeIndexRange(MapReturnType returnType, Exp key, Exp index, Exp count, Exp bin, CTX[] ctx);
    public static Exp GetByValue(MapReturnType returnType, Exp value, Exp bin, CTX[] ctx);
    public static Exp GetByValueRange(MapReturnType returnType, Exp valueBegin, Exp valueEnd, Exp bin, CTX[] ctx);
    public static Exp GetByValueList(MapReturnType returnType, Exp values, Exp bin, CTX[] ctx);
    public static Exp GetByValueRelativeRankRange(MapReturnType returnType, Exp value, Exp rank, Exp bin, CTX[] ctx);
    public static Exp GetByValueRelativeRankRange(MapReturnType returnType, Exp value, Exp rank, Exp count, Exp bin, CTX[] ctx);
    public static Exp GetByIndex(MapReturnType returnType, Type valueType, Exp index, Exp bin, CTX[] ctx);
    public static Exp GetByIndexRange(MapReturnType returnType, Exp index, Exp bin, CTX[] ctx);
    public static Exp GetByIndexRange(MapReturnType returnType, Exp index, Exp count, Exp bin, CTX[] ctx);
    public static Exp GetByRank(MapReturnType returnType, Type valueType, Exp rank, Exp bin, CTX[] ctx);
    public static Exp GetByRankRange(MapReturnType returnType, Exp rank, Exp bin, CTX[] ctx);
    public static Exp GetByRankRange(MapReturnType returnType, Exp rank, Exp count, Exp bin, CTX[] ctx);
    private static Exp AddWrite(Exp bin, Byte[] bytes, CTX[] ctx);
    private static Exp AddRead(Exp bin, Byte[] bytes, Type retType);
    private static Type GetValueType(MapReturnType returnType);
}
public class Aerospike.Client.MapOperation : object {
    internal static int SET_TYPE;
    internal static int ADD;
    internal static int ADD_ITEMS;
    internal static int PUT;
    internal static int PUT_ITEMS;
    internal static int REPLACE;
    internal static int REPLACE_ITEMS;
    internal static int INCREMENT;
    internal static int DECREMENT;
    internal static int CLEAR;
    internal static int REMOVE_BY_KEY;
    internal static int REMOVE_BY_INDEX;
    internal static int REMOVE_BY_RANK;
    internal static int REMOVE_BY_KEY_LIST;
    internal static int REMOVE_BY_VALUE;
    internal static int REMOVE_BY_VALUE_LIST;
    internal static int REMOVE_BY_KEY_INTERVAL;
    internal static int REMOVE_BY_INDEX_RANGE;
    internal static int REMOVE_BY_VALUE_INTERVAL;
    internal static int REMOVE_BY_RANK_RANGE;
    internal static int REMOVE_BY_KEY_REL_INDEX_RANGE;
    internal static int REMOVE_BY_VALUE_REL_RANK_RANGE;
    internal static int SIZE;
    internal static int GET_BY_KEY;
    internal static int GET_BY_INDEX;
    internal static int GET_BY_RANK;
    internal static int GET_BY_VALUE;
    internal static int GET_BY_KEY_INTERVAL;
    internal static int GET_BY_INDEX_RANGE;
    internal static int GET_BY_VALUE_INTERVAL;
    internal static int GET_BY_RANK_RANGE;
    internal static int GET_BY_KEY_LIST;
    internal static int GET_BY_VALUE_LIST;
    internal static int GET_BY_KEY_REL_INDEX_RANGE;
    internal static int GET_BY_VALUE_REL_RANK_RANGE;
    public static Operation Create(string binName, MapOrder order, CTX[] ctx);
    public static Operation Create(string binName, MapOrder order, bool persistIndex, CTX[] ctx);
    public static Operation SetMapPolicy(MapPolicy policy, string binName, CTX[] ctx);
    public static Operation Put(MapPolicy policy, string binName, Value key, Value value, CTX[] ctx);
    public static Operation PutItems(MapPolicy policy, string binName, IDictionary map, CTX[] ctx);
    public static Operation Increment(MapPolicy policy, string binName, Value key, Value incr, CTX[] ctx);
    [ObsoleteAttribute("Decrement is deprecated. Use Increment with a negative value instead.")]
public static Operation Decrement(MapPolicy policy, string binName, Value key, Value decr, CTX[] ctx);
    public static Operation Clear(string binName, CTX[] ctx);
    public static Operation RemoveByKey(string binName, Value key, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByKeyList(string binName, IList keys, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByKeyRange(string binName, Value keyBegin, Value keyEnd, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByKeyRelativeIndexRange(string binName, Value key, int index, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByKeyRelativeIndexRange(string binName, Value key, int index, int count, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValue(string binName, Value value, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValueList(string binName, IList values, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValueRange(string binName, Value valueBegin, Value valueEnd, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValueRelativeRankRange(string binName, Value value, int rank, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByValueRelativeRankRange(string binName, Value value, int rank, int count, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByIndex(string binName, int index, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByIndexRange(string binName, int index, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByIndexRange(string binName, int index, int count, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByRank(string binName, int rank, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByRankRange(string binName, int rank, MapReturnType returnType, CTX[] ctx);
    public static Operation RemoveByRankRange(string binName, int rank, int count, MapReturnType returnType, CTX[] ctx);
    public static Operation Size(string binName, CTX[] ctx);
    public static Operation GetByKey(string binName, Value key, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByKeyRange(string binName, Value keyBegin, Value keyEnd, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByKeyList(string binName, IList keys, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByKeyRelativeIndexRange(string binName, Value key, int index, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByKeyRelativeIndexRange(string binName, Value key, int index, int count, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByValue(string binName, Value value, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByValueRange(string binName, Value valueBegin, Value valueEnd, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByValueList(string binName, IList values, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByValueRelativeRankRange(string binName, Value value, int rank, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByValueRelativeRankRange(string binName, Value value, int rank, int count, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByIndex(string binName, int index, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByIndexRange(string binName, int index, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByIndexRange(string binName, int index, int count, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByRank(string binName, int rank, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByRankRange(string binName, int rank, MapReturnType returnType, CTX[] ctx);
    public static Operation GetByRankRange(string binName, int rank, int count, MapReturnType returnType, CTX[] ctx);
}
public enum Aerospike.Client.MapOrder : Enum {
    public int value__;
    public static MapOrder UNORDERED;
    public static MapOrder KEY_ORDERED;
    public static MapOrder KEY_VALUE_ORDERED;
}
public class Aerospike.Client.MapPolicy : object {
    public static MapPolicy Default;
    internal int attributes;
    internal int flags;
    internal int itemCommand;
    internal int itemsCommand;
    public MapPolicy(MapOrder order, MapWriteMode writeMode);
    public MapPolicy(MapOrder order, MapWriteFlags flags);
    public MapPolicy(MapOrder order, MapWriteFlags flags, bool persistIndex);
    private static MapPolicy();
}
[FlagsAttribute]
public enum Aerospike.Client.MapReturnType : Enum {
    public int value__;
    public static MapReturnType NONE;
    public static MapReturnType INDEX;
    public static MapReturnType REVERSE_INDEX;
    public static MapReturnType RANK;
    public static MapReturnType REVERSE_RANK;
    public static MapReturnType COUNT;
    public static MapReturnType KEY;
    public static MapReturnType VALUE;
    public static MapReturnType KEY_VALUE;
    public static MapReturnType EXISTS;
    public static MapReturnType UNORDERED_MAP;
    public static MapReturnType ORDERED_MAP;
    public static MapReturnType INVERTED;
}
[FlagsAttribute]
public enum Aerospike.Client.MapWriteFlags : Enum {
    public int value__;
    public static MapWriteFlags DEFAULT;
    public static MapWriteFlags CREATE_ONLY;
    public static MapWriteFlags UPDATE_ONLY;
    public static MapWriteFlags NO_FAIL;
    public static MapWriteFlags PARTIAL;
}
public enum Aerospike.Client.MapWriteMode : Enum {
    public int value__;
    public static MapWriteMode UPDATE;
    public static MapWriteMode UPDATE_ONLY;
    public static MapWriteMode CREATE_ONLY;
}
public enum Aerospike.Client.MaxCommandAction : Enum {
    public int value__;
    public static MaxCommandAction REJECT;
    public static MaxCommandAction BLOCK;
    public static MaxCommandAction DELAY;
}
public class Aerospike.Client.MetricsPolicy : object {
    public IMetricsListener Listener;
    public string ReportDir;
    public long ReportSizeLimit;
    public int Interval;
    public int LatencyColumns;
    public int LatencyShift;
    public MetricsPolicy(MetricsPolicy other);
    public void SetListener(IMetricsListener listener);
    public void SetReportDir(string reportDir);
    public void SetReportSizeLimit(long reportSizeLimit);
    public void SetInterval(int interval);
    public void SetLatencyColumns(int latencyColumns);
    public void SetLatencyShift(int latencyShift);
}
public class Aerospike.Client.MetricsWriter : object {
    private static string filenameFormat;
    private static string timestampFormat;
    private static int minFileSize;
    private string dir;
    private StringBuilder sb;
    private StreamWriter writer;
    private long size;
    private long maxSize;
    private int latencyColumns;
    private int latencyShift;
    private bool enabled;
    private DateTime prevTime;
    private TimeSpan prevCpuUsage;
    public MetricsWriter(string dir);
    private static MetricsWriter();
    public sealed virtual void OnEnable(Cluster cluster, MetricsPolicy policy);
    public sealed virtual void OnSnapshot(Cluster cluster);
    public sealed virtual void OnNodeClose(Node node);
    public sealed virtual void OnDisable(Cluster cluster);
    private void Open();
    private void WriteCluster(Cluster cluster);
    private void WriteNode(Node node);
    private void WriteConn(ConnectionStats cs);
    private void WriteLine();
    private void GetCpuMemoryUsage(Double& cpu, Int64& memory);
}
public abstract class Aerospike.Client.MultiCommand : SyncCommand {
    private static int MAX_BUFFER_SIZE;
    private Node node;
    protected internal string ns;
    private ulong clusterKey;
    protected internal int info3;
    protected internal int resultCode;
    protected internal int generation;
    protected internal int expiration;
    protected internal int batchIndex;
    protected internal int fieldCount;
    protected internal int opCount;
    protected internal bool isOperation;
    private bool first;
    protected internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) valid;
    protected internal MultiCommand(Cluster cluster, Policy policy, Node node, bool isOperation);
    protected internal MultiCommand(Cluster cluster, Policy policy, Node node, string ns, int socketTimeout, int totalTimeout);
    protected internal MultiCommand(Cluster cluster, Policy policy, Node node, string ns, ulong clusterKey, bool first);
    public void ExecuteAndValidate();
    protected virtual bool IsSingle();
    protected internal virtual Node GetNode();
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal sealed virtual void ParseResult(IConnection conn);
    private bool ParseGroup(int receiveSize);
    protected internal abstract virtual bool ParseRow();
    protected internal Record ParseRecord();
    public void Stop();
    public bool IsValid();
}
public class Aerospike.Client.Node : object {
    public static int PARTITIONS;
    public static int HAS_PARTITION_SCAN;
    public static int HAS_QUERY_SHOW;
    public static int HAS_BATCH_ANY;
    public static int HAS_PARTITION_QUERY;
    private static String[] INFO_PERIODIC;
    private static String[] INFO_PERIODIC_REB;
    protected internal Cluster cluster;
    private string name;
    protected internal Host host;
    protected internal List`1<Host> aliases;
    protected internal IPEndPoint address;
    private Connection tendConnection;
    private Byte[] sessionToken;
    private Nullable`1<DateTime> sessionExpiration;
    private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) racks;
    private NodeMetrics modreq(System.Runtime.CompilerServices.IsVolatile) metrics;
    protected bool metricsEnabled;
    private Pool`1[] connectionPools;
    protected UInt32 connectionIter;
    protected internal int connsOpened;
    protected internal int connsClosed;
    protected internal long bytesReceived;
    protected internal long bytesSent;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) errorRateCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) errorCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) timeoutCount;
    protected internal int peersGeneration;
    protected internal int partitionGeneration;
    protected internal int rebalanceGeneration;
    protected internal int peersCount;
    protected internal int referenceCount;
    protected internal int failures;
    protected internal UInt32 features;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) performLogin;
    protected internal bool partitionChanged;
    protected internal bool rebalanceChanged;
    protected internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) active;
    public Host Host { get; }
    public bool Active { get; }
    public string Name { get; }
    public Byte[] SessionToken { get; }
    public bool HasQueryShow { get; }
    public bool HasBatchAny { get; }
    public bool HasPartitionQuery { get; }
    public Cluster Cluster { get; }
    public IPEndPoint NodeAddress { get; }
    public Node(Cluster cluster, NodeValidator nv);
    private static Node();
    protected virtual override void Finalize();
    public virtual void CreateMinConnections();
    public void Refresh(Peers peers);
    private bool ShouldLogin();
    private void Login();
    public void SignalLogin();
    private void VerifyNodeName(Dictionary`2<string, string> infoMap);
    private void VerifyPeersGeneration(Dictionary`2<string, string> infoMap, Peers peers);
    private void Restart();
    private void VerifyPartitionGeneration(Dictionary`2<string, string> infoMap);
    private void VerifyRebalanceGeneration(Dictionary`2<string, string> infoMap);
    protected internal void RefreshPeers(Peers peers);
    private static bool FindPeerNode(Cluster cluster, Peers peers, string nodeName);
    protected internal void RefreshPartitions(Peers peers);
    protected internal void RefreshRacks();
    private void RefreshFailed(Exception e);
    private void CreateConnections(Pool`1<Connection> pool, int count);
    private Connection CreateConnection(Pool`1<Connection> pool);
    public Connection GetConnection(int timeoutMillis);
    public Connection GetConnection(int timeoutMillis, int timeoutDelay);
    private Connection CreateConnection(int timeout, Pool`1<Connection> pool);
    public void PutConnection(Connection conn);
    public void CloseConnectionOnError(Connection conn);
    public void CloseConnection(Connection conn);
    public virtual void BalanceConnections();
    private void CloseIdleConnections(Pool`1<Connection> pool, int count);
    public ConnectionStats GetConnectionStats();
    public void EnableMetrics(MetricsPolicy policy);
    public NodeMetrics GetMetrics();
    public void DisableMetrics();
    public void AddLatency(LatencyType type, double elapsedMs);
    public void IncrErrorRate();
    public void ResetErrorRate();
    public bool ErrorRateWithinLimit();
    public void ValidateErrorCount();
    public void AddError();
    public void AddTimeout();
    public int GetErrorCount();
    public int GetTimeoutCount();
    public bool HasRack(string ns, int rackId);
    public Host get_Host();
    public bool get_Active();
    public string get_Name();
    public Byte[] get_SessionToken();
    public bool get_HasQueryShow();
    public bool get_HasBatchAny();
    public bool get_HasPartitionQuery();
    public sealed virtual string ToString();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public void Close();
    protected internal virtual void CloseConnections();
    public Cluster get_Cluster();
    public IPEndPoint get_NodeAddress();
}
public class Aerospike.Client.NodeMetrics : object {
    private LatencyBuckets[] latency;
    private static long MS_TO_NS;
    public NodeMetrics(MetricsPolicy policy);
    public void AddLatency(LatencyType type, double elapsedMs);
    public LatencyBuckets GetLatencyBuckets(int type);
}
public class Aerospike.Client.NodePartitions : object {
    public Node node;
    public List`1<PartitionStatus> partsFull;
    public List`1<PartitionStatus> partsPartial;
    public long recordCount;
    public long recordMax;
    public int partsUnavailable;
    public NodePartitions(Node node, int capacity);
    public void AddPartition(PartitionStatus part);
}
public class Aerospike.Client.NodeStats : object {
    public Node node;
    public ConnectionStats syncStats;
    public ConnectionStats asyncStats;
    public long ErrorCount;
    public long TimeoutCount;
    public NodeStats(Node node);
    public virtual string ToString();
}
public class Aerospike.Client.NodeValidator : object {
    internal Node fallback;
    internal string name;
    internal List`1<Host> aliases;
    internal Host primaryHost;
    internal IPEndPoint primaryAddress;
    internal Connection primaryConn;
    internal Byte[] sessionToken;
    internal Nullable`1<DateTime> sessionExpiration;
    internal UInt32 features;
    public Node SeedNode(Cluster cluster, Host host, Peers peers);
    private bool ValidatePeers(Peers peers, Node node);
    public void ValidateNode(Cluster cluster, Host host);
    private void ValidateAddress(Cluster cluster, IPAddress address, string tlsName, int port, bool detectLoadBalancer);
    private void ValidateNode(Dictionary`2<string, string> map);
    private void ValidatePartitionGeneration(Dictionary`2<string, string> map);
    private void SetFeatures(Dictionary`2<string, string> map);
    private void ValidateClusterName(Cluster cluster, Dictionary`2<string, string> map);
    private void SetAddress(Cluster cluster, Dictionary`2<string, string> map, string addressCommand, string tlsName);
    private void SetAliases(IPAddress address, string tlsName, int port);
}
public class Aerospike.Client.OperateArgs : object {
    public WritePolicy writePolicy;
    public Operation[] operations;
    public int size;
    public int readAttr;
    public int writeAttr;
    public bool hasWrite;
    public OperateArgs(WritePolicy policy, WritePolicy writeDefault, WritePolicy readDefault, Key key, Operation[] operations);
    public Partition GetPartition(Cluster cluster, Key key);
}
public class Aerospike.Client.OperateCommand : ReadCommand {
    private OperateArgs args;
    public OperateCommand(Cluster cluster, Key key, OperateArgs args);
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void HandleNotFound(int resultCode);
    protected internal virtual bool PrepareRetry(bool timeout);
}
public class Aerospike.Client.Operation : object {
    private static Byte[] ProtocolTypes;
    private static Boolean[] IsWrites;
    public Type type;
    public string binName;
    public Value value;
    public Operation(Type type, string binName, Value value);
    private Operation(Type type, string binName);
    private Operation(Type type);
    private static Operation();
    public static Operation Get(string binName);
    public static Operation Get();
    public static Operation GetHeader();
    public static Operation Put(Bin bin);
    public static Operation Append(Bin bin);
    public static Operation Prepend(Bin bin);
    public static Operation Add(Bin bin);
    public static Operation Touch();
    public static Operation Delete();
    public static Operation[] Array(Operation[] ops);
    public static byte GetProtocolType(Type type);
    public static bool IsWrite(Type type);
}
public class Aerospike.Client.Packer : object {
    private Byte[] buffer;
    private int offset;
    private List`1<BufferItem> bufferList;
    public static Byte[] Pack(Value[] val);
    public static Byte[] Pack(IList val);
    public static Byte[] Pack(IDictionary val, MapOrder order);
    public void PackValueArray(Value[] values);
    public void PackList(IList list);
    public void PackArrayBegin(int size);
    public void PackMap(IDictionary map);
    public void PackMap(IDictionary map, MapOrder order);
    private void PackMapBegin(int size, MapOrder order);
    private void PackMapBegin(int size);
    public void PackBytes(Byte[] b);
    public void PackParticleBytes(Byte[] b);
    public void PackParticleBytes(Byte[] b, int offset, int length);
    public void PackBlob(object val);
    public void PackGeoJSON(string val);
    private void PackByteArrayBegin(int size);
    private void PackObject(object obj);
    public void PackNumber(long val);
    public void PackNumber(ulong val);
    public void PackBoolean(bool val);
    public void PackString(string val);
    public void PackParticleString(string val);
    private void PackStringBegin(int size);
    public void PackByteArray(Byte[] src, int srcOffset, int srcLength);
    public void PackDouble(double val);
    public void PackFloat(float val);
    private void PackLong(int type, ulong val);
    public void PackInt(int type, UInt32 val);
    private void PackShort(int type, ushort val);
    public void PackRawShort(int val);
    private void PackByte(int type, byte val);
    public void PackNil();
    public void PackInfinity();
    public void PackWildcard();
    private void PackByte(byte val);
    private void Resize(int size);
    public Byte[] ToByteArray();
}
public class Aerospike.Client.PackUtil : object {
    public static Byte[] Pack(int command, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, int v2, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, int v2, int v3, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, int v2, int v3, int v4, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, int v2, long v3, int v4, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, int v2, bool v3, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, int v2, Byte[] v3, int v4, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, Byte[] v2, int v3, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, Value v2, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, Value v2, int v3, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, Value v2, int v3, int v4, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, IList list, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, IList v2, int v3, CTX[] ctx);
    public static Byte[] Pack(int command, Value value, CTX[] ctx);
    public static Byte[] Pack(int command, Value value, int v1, int v2, CTX[] ctx);
    public static Byte[] Pack(int command, Value v1, Value v2, int v3, CTX[] ctx);
    public static Byte[] Pack(int command, IList list, int v1, int v2, CTX[] ctx);
    public static Byte[] Pack(int command, IList list, int v1, int v2, int v3, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, Exp v2, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, Exp v2, Exp v3, CTX[] ctx);
    public static Byte[] Pack(int command, int v1, Exp v2, Exp v3, Exp v4, CTX[] ctx);
    public static Byte[] Pack(int command, Exp v1);
    public static Byte[] Pack(int command, Exp v1, int v2, int v3, CTX[] ctx);
    public static Byte[] Pack(int command, Exp v1, Exp v2, CTX[] ctx);
    public static Byte[] Pack(int command, Exp v1, Exp v2, int v3, CTX[] ctx);
    public static Byte[] Pack(int command, Exp v1, Exp v2, int v3, int v4, CTX[] ctx);
    public static Byte[] Pack(int command, Exp v1, Exp v2, Exp v3, CTX[] ctx);
    public static Byte[] Pack(int command, Exp v1, Exp v2, Exp v3, int v4, CTX[] ctx);
    public static void Init(Packer packer, CTX[] ctx);
    public static Byte[] Pack(CTX[] ctx);
}
public enum Aerospike.Client.ParticleType : Enum {
    public int value__;
    public static ParticleType NULL;
    public static ParticleType INTEGER;
    public static ParticleType DOUBLE;
    public static ParticleType STRING;
    public static ParticleType BLOB;
    public static ParticleType CSHARP_BLOB;
    public static ParticleType BOOL;
    public static ParticleType HLL;
    public static ParticleType MAP;
    public static ParticleType LIST;
    public static ParticleType GEOJSON;
}
public class Aerospike.Client.Partition : object {
    private Partitions partitions;
    private string ns;
    private Node prevNode;
    private Replica replica;
    public UInt32 partitionId;
    private UInt32 sequence;
    private bool linearize;
    private Partition(Partitions partitions, Key key, Replica replica, Node prevNode, bool linearize);
    public Partition(string ns, Replica replica);
    public static Partition Write(Cluster cluster, Policy policy, Key key);
    public static Partition Read(Cluster cluster, Policy policy, Key key);
    public static Replica GetReplicaSC(Policy policy);
    public static Node GetNodeBatchWrite(Cluster cluster, Key key, Replica replica, Node prevNode, UInt32 sequence);
    public static Node GetNodeBatchRead(Cluster cluster, Key key, Replica replica, Replica replicaSC, Node prevNode, UInt32 sequence, UInt32 sequenceSC);
    public static UInt32 GetPartitionId(Byte[] digest);
    public Node GetNodeQuery(Cluster cluster, Partitions partitions, PartitionStatus ps);
    public Node GetNodeRead(Cluster cluster);
    public Node GetNodeWrite(Cluster cluster);
    public void PrepareRetryRead(bool timeout);
    public void PrepareRetryWrite(bool timeout);
    public Node GetSequenceNode(Cluster cluster);
    private Node GetRackNode(Cluster cluster);
    public Node GetMasterNode(Cluster cluster);
    public Node GetMasterProlesNode(Cluster cluster);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Aerospike.Client.PartitionFilter : object {
    internal int begin;
    internal int count;
    internal Byte[] digest;
    internal PartitionStatus[] partitions;
    internal bool done;
    internal bool retry;
    public int Begin { get; }
    public int Count { get; }
    public Byte[] Digest { get; }
    public PartitionStatus[] Partitions { get; public set; }
    public bool Done { get; }
    public bool Retry { get; }
    private PartitionFilter(int begin, int count);
    private PartitionFilter(Byte[] digest);
    public static PartitionFilter All();
    public static PartitionFilter Id(int id);
    public static PartitionFilter After(Key key);
    public static PartitionFilter Range(int begin, int count);
    public int get_Begin();
    public int get_Count();
    public Byte[] get_Digest();
    public PartitionStatus[] get_Partitions();
    public void set_Partitions(PartitionStatus[] value);
    public bool get_Done();
    public bool get_Retry();
}
public class Aerospike.Client.PartitionParser : Info {
    internal static string PartitionGeneration;
    internal static string Replicas;
    private Dictionary`2<string, Partitions> map;
    private int partitionCount;
    private int generation;
    private bool copied;
    private bool regimeError;
    public int Generation { get; }
    public bool IsPartitionMapCopied { get; }
    public Dictionary`2<string, Partitions> PartitionMap { get; }
    public PartitionParser(Connection conn, Node node, Dictionary`2<string, Partitions> map, int partitionCount);
    public int get_Generation();
    public bool get_IsPartitionMapCopied();
    public Dictionary`2<string, Partitions> get_PartitionMap();
    public int ParseGeneration();
    private void ParseReplicasAll(Node node, string command);
    private void DecodeBitmap(Node node, Partitions partitions, int index, int regime, int begin);
    private void CopyPartitionMap();
}
public class Aerospike.Client.Partitions : object {
    internal Node[][] replicas;
    internal Int32[] regimes;
    internal bool scMode;
    public Partitions(int partitionCount, int replicaCount, bool scMode);
    public Partitions(Partitions other, int replicaCount);
}
public class Aerospike.Client.PartitionStatus : object {
    public ulong bval;
    public Byte[] digest;
    public int id;
    public Node node;
    public int sequence;
    public bool retry;
    public PartitionStatus(int id);
}
public class Aerospike.Client.PartitionTracker : object {
    private PartitionStatus[] partitions;
    private int partitionsCapacity;
    private int partitionBegin;
    private int nodeCapacity;
    private Node nodeFilter;
    private PartitionFilter partitionFilter;
    private Replica replica;
    private List`1<NodePartitions> nodePartitionsList;
    private List`1<AerospikeException> exceptions;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) recordCount;
    private long maxRecords;
    private int sleepBetweenRetries;
    public int socketTimeout;
    public int totalTimeout;
    public int iteration;
    private DateTime deadline;
    unknown int SleepBetweenRetries {public set; }
    public PartitionTracker(ScanPolicy policy, Node[] nodes);
    public PartitionTracker(QueryPolicy policy, Statement stmt, Node[] nodes);
    private PartitionTracker(Policy policy, Node[] nodes);
    public PartitionTracker(ScanPolicy policy, Node nodeFilter);
    public PartitionTracker(QueryPolicy policy, Statement stmt, Node nodeFilter);
    private PartitionTracker(Policy policy, Node nodeFilter);
    public PartitionTracker(ScanPolicy policy, Node[] nodes, PartitionFilter filter);
    public PartitionTracker(QueryPolicy policy, Statement stmt, Node[] nodes, PartitionFilter filter);
    private PartitionTracker(Policy policy, Node[] nodes, PartitionFilter filter, long maxRecords);
    private void SetMaxRecords(QueryPolicy policy, Statement stmt);
    private void SetMaxRecords(long maxRecords);
    private PartitionStatus[] InitPartitions(int partitionCount, Byte[] digest);
    private void Init(Policy policy);
    public void set_SleepBetweenRetries(int value);
    public List`1<NodePartitions> AssignPartitionsToNodes(Cluster cluster, string ns);
    private NodePartitions FindNode(List`1<NodePartitions> list, Node node);
    public void PartitionUnavailable(NodePartitions nodePartitions, int partitionId);
    public void SetDigest(NodePartitions nodePartitions, Key key);
    public void SetLast(NodePartitions nodePartitions, Key key, ulong bval);
    public bool AllowRecord();
    public bool IsClusterComplete(Cluster cluster, Policy policy);
    public bool IsComplete(bool hasPartitionQuery, Policy policy, List`1<NodePartitions> nodePartitionsList);
    public bool ShouldRetry(NodePartitions nodePartitions, AerospikeException ae);
    private void AddException(Node node, AerospikeException ae);
    private void MarkRetrySequence(NodePartitions nodePartitions);
    private void MarkRetry(NodePartitions nodePartitions);
    public void PartitionError();
}
public class Aerospike.Client.Peer : object {
    internal string nodeName;
    internal string tlsName;
    internal List`1<Host> hosts;
}
public class Aerospike.Client.PeerParser : object {
    private Cluster cluster;
    private Info parser;
    private string tlsName;
    private int portDefault;
    public int generation;
    public PeerParser(Cluster cluster, Connection conn, List`1<Peer> peers);
    private Peer ParsePeer();
    private List`1<Host> ParseHosts();
    private Host ParseHost();
}
public class Aerospike.Client.Peers : object {
    public List`1<Peer> peers;
    public Dictionary`2<string, Node> nodes;
    private HashSet`1<Host> invalidHosts;
    public int refreshCount;
    public bool genChanged;
    public int InvalidCount { get; }
    public Peers(int peerCapacity);
    public bool HasFailed(Host host);
    public void Fail(Host host);
    public int get_InvalidCount();
    public void ClusterInitError();
}
public class Aerospike.Client.Policy : object {
    public ReadModeAP readModeAP;
    public ReadModeSC readModeSC;
    public Replica replica;
    public Expression filterExp;
    public int socketTimeout;
    public int totalTimeout;
    public int TimeoutDelay;
    public int maxRetries;
    public int sleepBetweenRetries;
    public int readTouchTtlPercent;
    public bool sendKey;
    public bool compress;
    public bool failOnFilteredOut;
    public IRecordParser recordParser;
    public Policy(Policy other);
    public void SetTimeout(int timeout);
    public void SetTimeouts(int socketTimeout, int totalTimeout);
}
public class Aerospike.Client.Pool`1 : object {
    private T[] items;
    private int head;
    private int tail;
    private int size;
    internal int minSize;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) total;
    public int Count { get; }
    public int Capacity { get; }
    public int Total { get; }
    public Pool`1(int minSize, int maxSize);
    public bool Enqueue(T item);
    public bool EnqueueLast(T item);
    public bool TryDequeue(T& item);
    public T PeekFirst();
    public bool TryDequeueLast(T& item);
    public T PeekLast();
    public int get_Count();
    public int get_Capacity();
    public int Excess();
    public int IncrTotal();
    public int DecrTotal();
    public int get_Total();
}
public class Aerospike.Client.Privilege : object {
    public PrivilegeCode code;
    public string ns;
    public string setName;
    public PrivilegeCode Code { get; public set; }
    public string CodeString { get; }
    public string Namespace { get; public set; }
    public string SetName { get; public set; }
    public bool CanScope();
    public PrivilegeCode get_Code();
    public void set_Code(PrivilegeCode value);
    public string get_CodeString();
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_SetName();
    public void set_SetName(string value);
    public Privilege Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string PrivilegeCodeToString();
}
public enum Aerospike.Client.PrivilegeCode : Enum {
    public int value__;
    public static PrivilegeCode USER_ADMIN;
    public static PrivilegeCode SYS_ADMIN;
    public static PrivilegeCode DATA_ADMIN;
    public static PrivilegeCode UDF_ADMIN;
    public static PrivilegeCode SINDEX_ADMIN;
    public static PrivilegeCode READ;
    public static PrivilegeCode READ_WRITE;
    public static PrivilegeCode READ_WRITE_UDF;
    public static PrivilegeCode WRITE;
    public static PrivilegeCode TRUNCATE;
}
public class Aerospike.Client.QueryAggregateCommand : MultiCommand {
    private Statement statement;
    private ulong taskId;
    private BlockingCollection`1<object> inputQueue;
    private CancellationToken cancelToken;
    public QueryAggregateCommand(Cluster cluster, Node node, QueryPolicy policy, Statement statement, ulong taskId, BlockingCollection`1<object> inputQueue, CancellationToken cancelToken, ulong clusterKey, bool first);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
}
public class Aerospike.Client.QueryAggregateExecutor : QueryExecutor {
    private BlockingCollection`1<object> inputQueue;
    private ResultSet resultSet;
    public ResultSet ResultSet { get; }
    public QueryAggregateExecutor(Cluster cluster, QueryPolicy policy, Statement statement, Node[] nodes);
    public void Execute();
    public void Run(object obj);
    private void HandleException(Exception e);
    protected internal virtual MultiCommand CreateCommand(Node node, ulong clusterKey, bool first);
    protected internal virtual void SendCancel();
    protected internal virtual void SendCompleted();
    public ResultSet get_ResultSet();
}
public enum Aerospike.Client.QueryDuration : Enum {
    public int value__;
    public static QueryDuration LONG;
    public static QueryDuration SHORT;
    public static QueryDuration LONG_RELAX_AP;
}
public abstract class Aerospike.Client.QueryExecutor : object {
    protected internal Cluster cluster;
    protected internal QueryPolicy policy;
    protected internal Statement statement;
    protected internal ulong taskId;
    private Node[] nodes;
    private QueryThread[] threads;
    protected internal CancellationTokenSource cancel;
    protected Exception modreq(System.Runtime.CompilerServices.IsVolatile) exception;
    private int maxConcurrentNodes;
    private int completedCount;
    private int done;
    public QueryExecutor(Cluster cluster, QueryPolicy policy, Statement statement, Node[] nodes);
    protected internal void InitializeThreads();
    protected internal void StartThreads();
    private void ThreadCompleted();
    public sealed virtual bool StopThreads(Exception cause);
    public sealed virtual void CheckForException();
    protected internal abstract virtual MultiCommand CreateCommand(Node node, ulong clusterKey, bool first);
    protected internal abstract virtual void SendCancel();
    protected internal abstract virtual void SendCompleted();
}
public class Aerospike.Client.QueryListener : MulticastDelegate {
    public QueryListener(object object, IntPtr method);
    public virtual void Invoke(Key key, Record record);
    public virtual IAsyncResult BeginInvoke(Key key, Record record, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Aerospike.Client.QueryListenerCommand : MultiCommand {
    private Statement statement;
    private ulong taskId;
    private QueryListener listener;
    private PartitionTracker tracker;
    private NodePartitions nodePartitions;
    public QueryListenerCommand(Cluster cluster, Policy policy, Statement statement, ulong taskId, QueryListener listener, PartitionTracker tracker, NodePartitions nodePartitions);
    public virtual void Execute();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
}
public class Aerospike.Client.QueryListenerExecutor : object {
    public static void execute(Cluster cluster, QueryPolicy policy, Statement statement, QueryListener listener, PartitionTracker tracker);
}
public class Aerospike.Client.QueryPartitionCommand : MultiCommand {
    private Statement statement;
    private ulong taskId;
    private RecordSet recordSet;
    private PartitionTracker tracker;
    private NodePartitions nodePartitions;
    public QueryPartitionCommand(Cluster cluster, Policy policy, Statement statement, ulong taskId, RecordSet recordSet, PartitionTracker tracker, NodePartitions nodePartitions);
    public virtual void Execute();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
}
public class Aerospike.Client.QueryPartitionExecutor : object {
    private Cluster cluster;
    private QueryPolicy policy;
    private Statement statement;
    private List`1<QueryThread> threads;
    private CancellationTokenSource cancel;
    private PartitionTracker tracker;
    private RecordSet recordSet;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) exception;
    private int maxConcurrentThreads;
    private int completedCount;
    private int done;
    private bool threadsComplete;
    public RecordSet RecordSet { get; }
    public QueryPartitionExecutor(Cluster cluster, QueryPolicy policy, Statement statement, int nodeCapacity, PartitionTracker tracker);
    public void Run(object obj);
    private void Execute();
    private void WaitTillComplete();
    private void NotifyCompleted();
    private void ThreadCompleted();
    public sealed virtual bool StopThreads(Exception cause);
    public sealed virtual void CheckForException();
    public RecordSet get_RecordSet();
}
public class Aerospike.Client.QueryPolicy : Policy {
    public QueryDuration expectedDuration;
    [ObsoleteAttribute("Use 'Statement.MaxRecords' instead.")]
public long maxRecords;
    public int maxConcurrentNodes;
    public int recordQueueSize;
    public bool includeBinData;
    public bool failOnClusterChange;
    [ObsoleteAttribute("Use 'expectedDuration' instead.")]
public bool shortQuery;
    public UInt32 infoTimeout;
    public QueryPolicy(QueryPolicy other);
    public QueryPolicy(Policy other);
}
public class Aerospike.Client.QueryRecordCommand : MultiCommand {
    private Statement statement;
    private RecordSet recordSet;
    private ulong taskId;
    public QueryRecordCommand(Cluster cluster, Node node, QueryPolicy policy, Statement statement, ulong taskId, RecordSet recordSet, ulong clusterKey, bool first);
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
}
public class Aerospike.Client.QueryRecordExecutor : QueryExecutor {
    private RecordSet recordSet;
    public RecordSet RecordSet { get; }
    public QueryRecordExecutor(Cluster cluster, QueryPolicy policy, Statement statement, Node[] nodes);
    public void Execute();
    protected internal virtual MultiCommand CreateCommand(Node node, ulong clusterKey, bool first);
    protected internal virtual void SendCancel();
    protected internal virtual void SendCompleted();
    public RecordSet get_RecordSet();
}
public class Aerospike.Client.QueryValidate : object {
    public static ulong ValidateBegin(Node node, string ns);
    public static void Validate(Node node, string ns, ulong expectedKey);
}
public class Aerospike.Client.RackParser : Info {
    internal static string RebalanceGeneration;
    internal static string RackIds;
    private Dictionary`2<string, int> racks;
    private int generation;
    public int Generation { get; }
    public Dictionary`2<string, int> Racks { get; }
    public RackParser(Connection conn);
    public int get_Generation();
    public Dictionary`2<string, int> get_Racks();
    private int ParseGeneration();
    private void ParseRacks();
}
public class Aerospike.Client.RandomShift : object {
    [ThreadStaticAttribute]
private static RandomShift RandomShiftLocal;
    private ulong seed0;
    private ulong seed1;
    public static RandomShift ThreadLocalInstance { get; }
    public static RandomShift get_ThreadLocalInstance();
    public string NextString(int size);
    public void NextBytes(Byte[] bytes);
    public int Next(int begin, int end);
    public UInt32 Next();
    public ulong NextLong();
}
public class Aerospike.Client.ReadCommand : SyncCommand {
    protected Key key;
    protected Partition partition;
    private String[] binNames;
    private bool isOperation;
    private Record record;
    public Record Record { get; }
    public ReadCommand(Cluster cluster, Policy policy, Key key);
    public ReadCommand(Cluster cluster, Policy policy, Key key, String[] binNames);
    public ReadCommand(Cluster cluster, Policy policy, Key key, Partition partition, bool isOperation);
    protected internal virtual Node GetNode();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult(IConnection conn);
    protected internal virtual bool PrepareRetry(bool timeout);
    protected internal virtual void HandleNotFound(int resultCode);
    private void HandleUdfError(int resultCode);
    public Record get_Record();
}
public class Aerospike.Client.ReadHeaderCommand : SyncCommand {
    private Key key;
    private Partition partition;
    private Record record;
    public Record Record { get; }
    public ReadHeaderCommand(Cluster cluster, Policy policy, Key key);
    protected internal virtual Node GetNode();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult(IConnection conn);
    protected internal virtual bool PrepareRetry(bool timeout);
    public Record get_Record();
}
public enum Aerospike.Client.ReadModeAP : Enum {
    public int value__;
    public static ReadModeAP ONE;
    public static ReadModeAP ALL;
}
public enum Aerospike.Client.ReadModeSC : Enum {
    public int value__;
    public static ReadModeSC SESSION;
    public static ReadModeSC LINEARIZE;
    public static ReadModeSC ALLOW_REPLICA;
    public static ReadModeSC ALLOW_UNAVAILABLE;
}
public class Aerospike.Client.Record : object {
    private static DateTime Epoch;
    public Dictionary`2<string, object> bins;
    public int generation;
    public int expiration;
    public int TimeToLive { get; }
    public Record(Dictionary`2<string, object> bins, int generation, int expiration);
    private static Record();
    public object GetValue(string name);
    public string GetString(string name);
    public double GetDouble(string name);
    public float GetFloat(string name);
    public long GetLong(string name);
    public ulong GetULong(string name);
    public int GetInt(string name);
    public UInt32 GetUInt(string name);
    public short GetShort(string name);
    public ushort GetUShort(string name);
    public byte GetByte(string name);
    public sbyte GetSBytes(string name);
    public bool GetBool(string name);
    public IList GetList(string name);
    public IDictionary GetMap(string name);
    public object GetUDFResult();
    public string GetUDFError();
    public string GetGeoJSON(string name);
    public HLLValue GetHLLValue(string name);
    public int get_TimeToLive();
    public virtual string ToString();
    private bool ObjectToString(object obj, StringBuilder sb);
}
public interface Aerospike.Client.RecordArrayListener {
    public abstract virtual void OnSuccess(Key[] keys, Record[] records);
    public abstract virtual void OnFailure(AerospikeException ae);
}
internal class Aerospike.Client.RecordArrayListenerAdapter : ListenerAdapter`1<Record[]> {
    public RecordArrayListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(Key[] keys, Record[] records);
}
public enum Aerospike.Client.RecordExistsAction : Enum {
    public int value__;
    public static RecordExistsAction UPDATE;
    public static RecordExistsAction UPDATE_ONLY;
    public static RecordExistsAction REPLACE;
    public static RecordExistsAction REPLACE_ONLY;
    public static RecordExistsAction CREATE_ONLY;
}
public interface Aerospike.Client.RecordListener {
    public abstract virtual void OnSuccess(Key key, Record record);
    public abstract virtual void OnFailure(AerospikeException exception);
}
internal class Aerospike.Client.RecordListenerAdapter : ListenerAdapter`1<Record> {
    public RecordListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(Key key, Record record);
}
public class Aerospike.Client.RecordParser : object {
    public static RecordParser Instance;
    private static RecordParser();
    public sealed virtual Record ParseRecord(Byte[] dataBuffer, Int32& dataOffsetRef, int opCount, int generation, int expiration, bool isOperation);
    public static int ExtractBinValue(Byte[] dataBuffer, int dataOffset, String& binName, Byte& valueType, Int32& valueOffset, Int32& valueSize);
}
public interface Aerospike.Client.RecordSequenceListener {
    public abstract virtual void OnRecord(Key key, Record record);
    public abstract virtual void OnSuccess();
    public abstract virtual void OnFailure(AerospikeException exception);
}
public class Aerospike.Client.RecordSet : object {
    public static KeyRecord END;
    private IQueryExecutor executor;
    private BlockingCollection`1<KeyRecord> queue;
    private CancellationToken cancelToken;
    private KeyRecord record;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) valid;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public bool Disposed { get; private set; }
    public Key Key { get; }
    public Record Record { get; }
    public CancellationToken CancelToken { get; }
    public RecordSet(IQueryExecutor executor, int capacity, CancellationToken cancelToken);
    private static RecordSet();
    public sealed virtual bool Next();
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual Key get_Key();
    public sealed virtual Record get_Record();
    public sealed virtual CancellationToken get_CancelToken();
    public sealed virtual bool Put(KeyRecord record);
    internal void Abort();
}
public class Aerospike.Client.RegexFlag : object {
    public static UInt32 NONE;
    public static UInt32 EXTENDED;
    public static UInt32 ICASE;
    public static UInt32 NOSUB;
    public static UInt32 NEWLINE;
}
public class Aerospike.Client.RegisterCommand : object {
    public static RegisterTask Register(Cluster cluster, Policy policy, string content, string serverPath, Language language);
}
public class Aerospike.Client.RegisterTask : BaseTask {
    private string packageName;
    public RegisterTask(Cluster cluster, Policy policy, string packageName);
    public virtual int QueryStatus();
}
public class Aerospike.Client.RejectScheduler : object {
    private ConcurrentQueue`1<BufferSegment> bufferQueue;
    public RejectScheduler(AsyncClientPolicy policy, BufferPool pool);
    public sealed virtual void Schedule(AsyncCommand command);
    public sealed virtual void Release(BufferSegment segment);
}
public enum Aerospike.Client.Replica : Enum {
    public int value__;
    public static Replica MASTER;
    public static Replica MASTER_PROLES;
    public static Replica SEQUENCE;
    public static Replica PREFER_RACK;
    public static Replica RANDOM;
}
public class Aerospike.Client.ResultCode : object {
    public static int BATCH_FAILED;
    public static int NO_RESPONSE;
    public static int MAX_ERROR_RATE;
    public static int MAX_RETRIES_EXCEEDED;
    public static int SERIALIZE_ERROR;
    public static int SERVER_NOT_AVAILABLE;
    public static int NO_MORE_CONNECTIONS;
    public static int COMMAND_REJECTED;
    public static int QUERY_TERMINATED;
    public static int SCAN_TERMINATED;
    public static int INVALID_NODE_ERROR;
    public static int PARSE_ERROR;
    public static int CLIENT_ERROR;
    public static int OK;
    public static int SERVER_ERROR;
    public static int KEY_NOT_FOUND_ERROR;
    public static int GENERATION_ERROR;
    public static int PARAMETER_ERROR;
    public static int KEY_EXISTS_ERROR;
    public static int BIN_EXISTS_ERROR;
    public static int CLUSTER_KEY_MISMATCH;
    public static int SERVER_MEM_ERROR;
    public static int TIMEOUT;
    public static int ALWAYS_FORBIDDEN;
    public static int PARTITION_UNAVAILABLE;
    public static int BIN_TYPE_ERROR;
    public static int RECORD_TOO_BIG;
    public static int KEY_BUSY;
    public static int SCAN_ABORT;
    public static int UNSUPPORTED_FEATURE;
    public static int BIN_NOT_FOUND;
    public static int DEVICE_OVERLOAD;
    public static int KEY_MISMATCH;
    public static int INVALID_NAMESPACE;
    public static int BIN_NAME_TOO_LONG;
    public static int FAIL_FORBIDDEN;
    public static int ELEMENT_NOT_FOUND;
    public static int ELEMENT_EXISTS;
    public static int ENTERPRISE_ONLY;
    public static int OP_NOT_APPLICABLE;
    public static int FILTERED_OUT;
    public static int LOST_CONFLICT;
    public static int QUERY_END;
    public static int SECURITY_NOT_SUPPORTED;
    public static int SECURITY_NOT_ENABLED;
    public static int SECURITY_SCHEME_NOT_SUPPORTED;
    public static int INVALID_COMMAND;
    public static int INVALID_FIELD;
    public static int ILLEGAL_STATE;
    public static int INVALID_USER;
    public static int USER_ALREADY_EXISTS;
    public static int INVALID_PASSWORD;
    public static int EXPIRED_PASSWORD;
    public static int FORBIDDEN_PASSWORD;
    public static int INVALID_CREDENTIAL;
    public static int EXPIRED_SESSION;
    public static int INVALID_ROLE;
    public static int ROLE_ALREADY_EXISTS;
    public static int INVALID_PRIVILEGE;
    public static int INVALID_WHITELIST;
    public static int QUOTAS_NOT_ENABLED;
    public static int INVALID_QUOTA;
    public static int NOT_AUTHENTICATED;
    public static int ROLE_VIOLATION;
    public static int NOT_WHITELISTED;
    public static int QUOTA_EXCEEDED;
    public static int UDF_BAD_RESPONSE;
    public static int BATCH_DISABLED;
    public static int BATCH_MAX_REQUESTS_EXCEEDED;
    public static int BATCH_QUEUES_FULL;
    public static int INDEX_ALREADY_EXISTS;
    public static int INDEX_FOUND;
    public static int INDEX_NOTFOUND;
    public static int INDEX_OOM;
    public static int INDEX_NOTREADABLE;
    public static int INDEX_GENERIC;
    public static int INDEX_NAME_MAXLEN;
    public static int INDEX_MAXCOUNT;
    public static int QUERY_ABORTED;
    public static int QUERY_QUEUEFULL;
    public static int QUERY_TIMEOUT;
    public static int QUERY_GENERIC;
    public static bool KeepConnection(int resultCode);
    public static string GetResultString(int resultCode);
}
public class Aerospike.Client.ResultSet : object {
    public static object END;
    private QueryAggregateExecutor executor;
    private BlockingCollection`1<object> queue;
    private CancellationToken cancelToken;
    private object row;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) valid;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public bool Disposed { get; private set; }
    public object Object { get; }
    public CancellationToken CancelToken { get; }
    public ResultSet(QueryAggregateExecutor executor, int capacity, CancellationToken cancelToken);
    private static ResultSet();
    public sealed virtual bool Next();
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual object get_Object();
    public sealed virtual CancellationToken get_CancelToken();
    public sealed virtual bool Put(object obj);
    internal void Abort();
}
public class Aerospike.Client.Role : object {
    public static string UserAdmin;
    public static string SysAdmin;
    public static string DataAdmin;
    public static string UDFAdmin;
    public static string SIndexAdmin;
    public static string Read;
    public static string ReadWrite;
    public static string ReadWriteUdf;
    public static string Write;
    public static string Truncate;
    public string name;
    public List`1<Privilege> privileges;
    public List`1<string> whitelist;
    public int readQuota;
    public int writeQuota;
    public bool isPredefined();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Aerospike.Client.SaltParseException : Exception {
    public SaltParseException(string message);
    public SaltParseException(string message, Exception innerException);
}
public class Aerospike.Client.ScanCallback : MulticastDelegate {
    public ScanCallback(object object, IntPtr method);
    public virtual void Invoke(Key key, Record record);
    public virtual IAsyncResult BeginInvoke(Key key, Record record, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Aerospike.Client.ScanExecutor : object {
    public static void ScanPartitions(Cluster cluster, ScanPolicy policy, string ns, string setName, String[] binNames, ScanCallback callback, PartitionTracker tracker);
}
public class Aerospike.Client.ScanPartitionCommand : MultiCommand {
    private ScanPolicy scanPolicy;
    private string setName;
    private String[] binNames;
    private ScanCallback callback;
    private ulong taskId;
    private PartitionTracker tracker;
    private NodePartitions nodePartitions;
    public ScanPartitionCommand(Cluster cluster, ScanPolicy scanPolicy, string ns, string setName, String[] binNames, ScanCallback callback, ulong taskId, PartitionTracker tracker, NodePartitions nodePartitions);
    public virtual void Execute();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
}
public class Aerospike.Client.ScanPolicy : Policy {
    public long maxRecords;
    public int recordsPerSecond;
    public int maxConcurrentNodes;
    public bool concurrentNodes;
    public bool includeBinData;
    public int recordQueueSize;
    public ScanPolicy(ScanPolicy other);
    public ScanPolicy(Policy other);
}
public class Aerospike.Client.ServerCommand : MultiCommand {
    private Statement statement;
    private ulong taskId;
    public ServerCommand(Cluster cluster, Node node, WritePolicy policy, Statement statement, ulong taskId);
    protected internal virtual bool IsWrite();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual bool ParseRow();
}
public class Aerospike.Client.Statement : object {
    internal string ns;
    internal string setName;
    internal string indexName;
    internal String[] binNames;
    internal Filter filter;
    internal Assembly resourceAssembly;
    internal string resourcePath;
    internal string packageName;
    internal string packageContents;
    internal string functionName;
    internal Value[] functionArgs;
    internal Operation[] operations;
    internal ulong taskId;
    internal long maxRecords;
    internal int recordsPerSecond;
    public string Namespace { get; public set; }
    public string SetName { get; public set; }
    public string IndexName { get; public set; }
    public String[] BinNames { get; public set; }
    public Filter Filter { get; public set; }
    public ulong TaskId { get; public set; }
    public long MaxRecords { get; public set; }
    public int RecordsPerSecond { get; public set; }
    public Assembly ResourceAssembly { get; public set; }
    public string ResourcePath { get; public set; }
    public string PackageName { get; public set; }
    public string PackageContents { get; public set; }
    public string FunctionName { get; public set; }
    public Value[] FunctionArgs { get; public set; }
    public Operation[] Operations { get; public set; }
    public void set_Namespace(string value);
    public string get_Namespace();
    public void SetNamespace(string ns);
    public void set_SetName(string value);
    public string get_SetName();
    public void SetSetName(string setName);
    public void set_IndexName(string value);
    public string get_IndexName();
    public void SetIndexName(string indexName);
    public void set_BinNames(String[] value);
    public String[] get_BinNames();
    public void SetBinNames(String[] binNames);
    public void set_Filter(Filter value);
    public Filter get_Filter();
    public void SetFilter(Filter filter);
    public void set_TaskId(ulong value);
    public ulong get_TaskId();
    public void SetTaskId(long taskId);
    public void set_MaxRecords(long value);
    public long get_MaxRecords();
    public void set_RecordsPerSecond(int value);
    public int get_RecordsPerSecond();
    public void SetRecordsPerSecond(int recordsPerSecond);
    public void SetAggregateFunction(string packageName, string functionName, Value[] functionArgs);
    public void SetAggregateFunction(Assembly resourceAssembly, string resourcePath, string packageName, string functionName, Value[] functionArgs);
    public void SetAggregateFunction(string packageName, string packageContents, string functionName, Value[] functionArgs);
    public void set_ResourceAssembly(Assembly value);
    public Assembly get_ResourceAssembly();
    public void set_ResourcePath(string value);
    public string get_ResourcePath();
    public void set_PackageName(string value);
    public string get_PackageName();
    public void set_PackageContents(string value);
    public string get_PackageContents();
    public void set_FunctionName(string value);
    public string get_FunctionName();
    public void set_FunctionArgs(Value[] value);
    public Value[] get_FunctionArgs();
    public void set_Operations(Operation[] value);
    public Operation[] get_Operations();
    internal ulong PrepareTaskId();
}
internal class Aerospike.Client.SwitchClear : object {
    internal IPAddress clearAddress;
    internal IPEndPoint clearSocketAddress;
    internal Connection clearConn;
    internal SwitchClear(Cluster cluster, Connection conn, Byte[] sessionToken);
}
public abstract class Aerospike.Client.SyncCommand : Command {
    protected Cluster cluster;
    protected Policy policy;
    internal int iteration;
    internal int commandSentCounter;
    internal DateTime deadline;
    public SyncCommand(Cluster cluster, Policy policy);
    public SyncCommand(Cluster cluster, Policy policy, int socketTimeout, int totalTimeout);
    public virtual void Execute();
    public void ExecuteCommand();
    protected internal sealed virtual int SizeBuffer();
    protected internal void SizeBuffer(int size);
    protected internal sealed virtual void End();
    protected internal sealed virtual void SetLength(int length);
    protected internal virtual bool RetryBatch(Cluster cluster, int socketTimeout, int totalTimeout, DateTime deadline, int iteration, int commandSentCounter);
    protected internal virtual bool IsWrite();
    protected virtual bool IsSingle();
    protected internal abstract virtual Node GetNode();
    protected abstract virtual LatencyType GetLatencyType();
    protected internal abstract virtual void WriteBuffer();
    protected internal abstract virtual void ParseResult(IConnection conn);
    protected internal abstract virtual bool PrepareRetry(bool timeout);
}
public class Aerospike.Client.ThreadLocalData : object {
    public static int THREAD_LOCAL_CUTOFF;
    [ThreadStaticAttribute]
private static Byte[] BufferThreadLocal;
    private static ThreadLocalData();
    public static Byte[] GetBuffer();
    public static Byte[] ResizeBuffer(int size);
}
public class Aerospike.Client.TlsConnection : Connection {
    private SslStream sslStream;
    private Cluster cluster;
    private string tlsName;
    public TlsConnection(Cluster cluster, string tlsName, IPEndPoint address, int timeoutMillis, Pool`1<Connection> pool);
    public TlsConnection(Cluster cluster, string tlsName, IPEndPoint address, int timeoutMillis, Node node, Pool`1<Connection> pool);
    private bool ValidateServerCertificate(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    internal static bool ValidateCertificate(Cluster cluster, string tlsName, X509Certificate cert, SslPolicyErrors sslPolicyErrors);
    private static bool FindTlsName(string str, string filter, string tlsName);
    public virtual void Write(Byte[] buffer, int length);
    public virtual void ReadFully(Byte[] buffer, int length);
    public virtual Stream GetStream();
    public virtual void Close();
}
public class Aerospike.Client.TlsPolicy : object {
    public SslProtocols protocols;
    public Byte[][] revokeCertificates;
    public X509CertificateCollection clientCertificates;
    public bool forLoginOnly;
    public TlsPolicy(TlsPolicy other);
    public TlsPolicy(string protocolString, string revokeString, string clientCertificateFile, bool forLoginOnly);
    private void ParseSslProtocols(string protocolString);
    private void ParseRevokeString(string revokeString);
    private void ParseClientCertificateFile(string clientCertificateFile);
}
public class Aerospike.Client.TouchCommand : SyncCommand {
    private WritePolicy writePolicy;
    private Key key;
    private Partition partition;
    public TouchCommand(Cluster cluster, WritePolicy writePolicy, Key key);
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult(IConnection conn);
    protected internal virtual bool PrepareRetry(bool timeout);
}
public class Aerospike.Client.Unpacker : object {
    private Byte[] buffer;
    private int offset;
    private int length;
    private bool lua;
    public Unpacker(Byte[] buffer, int offset, int length, bool lua);
    public object UnpackList();
    private object UnpackList(int count);
    private object GetList(List`1<object> list);
    public object UnpackMap();
    private object UnpackMap(int count);
    private IDictionary`2<object, object> CreateMap(int count);
    private object GetMap(IDictionary`2<object, object> map);
    private object UnpackBlob(int count);
    public object UnpackObject();
    public Nullable`1<long> UnpackInteger();
    public Nullable`1<bool> UnpackBool();
    public Nullable`1<float> UnpackFloat();
    public Nullable`1<double> UnpackDouble();
    public string UnpackString();
    private string UnpackBlobString(int count);
    public int UnpackMapItemCount(MapOrder& order);
    public int UnpackListItemCount();
    public void SkipObjects(int count);
    public void SkipObject();
    private void SkipMap(int count);
    private void SkipList(int count);
    private int SkipTypeExtensions(int itemCount);
}
public class Aerospike.Client.User : object {
    public string name;
    public List`1<string> roles;
    public List`1<UInt32> readInfo;
    public List`1<UInt32> writeInfo;
    public UInt32 connsInUse;
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Aerospike.Client.Util : object {
    private static DateTime UnixEpoch;
    private static Util();
    public static long NanosFromEpoch(DateTime dt);
    public static void Sleep(int millis);
    public static string GetErrorMessage(Exception e);
    public static string GetStackTrace(Exception e);
    public static string ReadFileEncodeBase64(string path);
    public static string MapToString(IDictionary`2<object, object> map);
    private static void MapToString(StringBuilder sb, IDictionary`2<object, object> map);
    public static string ListToString(IList list);
    private static void ListToString(StringBuilder sb, IList list);
    public static string ArrayToString(Object[] list);
    private static void ArrayToString(StringBuilder sb, Object[] list);
    public static string BytesToString(Byte[] bytes);
    public static string ObjectToString(object obj);
    private static void ObjectToString(StringBuilder sb, object obj);
    public static bool ToBool(object result);
    public static bool ByteArrayEquals(Byte[] b1, Byte[] b2);
    public static Byte[][] HexStringToByteArrays(string str);
    public static Byte[] HexStringToBytes(string str);
    public static int HexVal(char hex);
}
public abstract class Aerospike.Client.Value : object {
    public static bool UseBoolBin;
    public static bool DisableSerializer;
    public static bool DisableDeserializer;
    public static Value INFINITY;
    public static Value WILDCARD;
    public ParticleType Type { get; }
    public object Object { get; }
    public static Value AsNull { get; }
    public bool IsNull { get; }
    private static Value();
    public abstract virtual ParticleType get_Type();
    public abstract virtual object get_Object();
    public static Value get_AsNull();
    public bool get_IsNull();
    public abstract virtual int EstimateSize();
    public abstract virtual int Write(Byte[] buffer, int offset);
    public abstract virtual void Pack(Packer packer);
    public virtual void ValidateKeyType();
    public virtual int ToInteger();
    public virtual UInt32 ToUnsignedInteger();
    public virtual long ToLong();
    public virtual ulong ToUnsignedLong();
    public static Value Get(string value);
    public static Value Get(Byte[] value);
    public static Value Get(Byte[] value, int offset, int length);
    public static DoubleValue Get(double value);
    public static FloatValue Get(float value);
    public static LongValue Get(long value);
    public static UnsignedLongValue Get(ulong value);
    public static IntegerValue Get(int value);
    public static UnsignedIntegerValue Get(UInt32 value);
    public static ShortValue Get(short value);
    public static UnsignedShortValue Get(ushort value);
    public static Value Get(bool value);
    public static ByteValue Get(byte value);
    public static SignedByteValue Get(sbyte value);
    public static Value Get(BlobValue value);
    public static Value GetAsGeoJSON(string value);
    public static Value GetAsHLL(Byte[] value);
    public static Value Get(Value[] value);
    public static Value Get(IList value);
    public static Value Get(IDictionary value);
    public static Value Get(IDictionary value, MapOrder order);
    public static Value Get(T obj);
}
public abstract class Aerospike.Client.Value`1 : Value {
    [CompilerGeneratedAttribute]
private T <value>k__BackingField;
    [CompilerGeneratedAttribute]
private ParticleType <Type>k__BackingField;
    public T value { get; }
    public ParticleType Type { get; }
    public object Object { get; }
    internal Value`1(ParticleType type);
    internal Value`1(T value, ParticleType type);
    [CompilerGeneratedAttribute]
public T get_value();
    [CompilerGeneratedAttribute]
public virtual ParticleType get_Type();
    public virtual object get_Object();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(T other);
    public sealed virtual bool Equals(Value`1<T> other);
    public virtual int GetHashCode();
    public static bool op_Equality(Value`1<T> o1, Value`1<T> o2);
    public static bool op_Inequality(Value`1<T> o1, Value`1<T> o2);
    public static bool op_Equality(Value`1<T> o1, T o2);
    public static bool op_Inequality(Value`1<T> o1, T o2);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class Aerospike.Client.ValueRipemd160 : ValueType {
    private Span`1<UInt32> X;
    private Span`1<byte> xBuf;
    private int xOff;
    private int xBufOff;
    private long byteCount;
    private UInt32 H0;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    public ValueRipemd160(Span`1<UInt32> x, Span`1<byte> xBuf);
    public static Byte[] ComputeHashDigest(ReadOnlySpan`1<byte> input);
    public void Reset();
    public void Add(ReadOnlySpan`1<byte> input);
    private void Add(byte input);
    public Byte[] HashDigest();
    private void ProcessWord(ReadOnlySpan`1<byte> input, int inOff);
    private void ProcessLength(long bitLength);
    private void ProcessBlock();
}
[IsReadOnlyAttribute]
public class Aerospike.Client.ValueStopwatch : ValueType {
    private static double TimespanTicksPerStopwatchTick;
    private static double MillisecondsPerStopwatchTick;
    private long startTimestamp;
    public bool IsActive { get; }
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    private ValueStopwatch(long startTimestamp);
    private static ValueStopwatch();
    public static ValueStopwatch StartNew();
    public bool get_IsActive();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
}
public class Aerospike.Client.WriteCommand : SyncCommand {
    private WritePolicy writePolicy;
    private Key key;
    private Partition partition;
    private Bin[] bins;
    private Type operation;
    public WriteCommand(Cluster cluster, WritePolicy writePolicy, Key key, Bin[] bins, Type operation);
    protected internal virtual bool IsWrite();
    protected internal virtual Node GetNode();
    protected virtual LatencyType GetLatencyType();
    protected internal virtual void WriteBuffer();
    protected internal virtual void ParseResult(IConnection conn);
    protected internal virtual bool PrepareRetry(bool timeout);
}
public interface Aerospike.Client.WriteListener {
    public abstract virtual void OnSuccess(Key key);
    public abstract virtual void OnFailure(AerospikeException exception);
}
internal class Aerospike.Client.WriteListenerAdapter : ListenerAdapter`1<Key> {
    public WriteListenerAdapter(CancellationToken token);
    public sealed virtual void OnSuccess(Key key);
}
public class Aerospike.Client.WritePolicy : Policy {
    public RecordExistsAction recordExistsAction;
    public GenerationPolicy generationPolicy;
    public CommitLevel commitLevel;
    public int generation;
    public int expiration;
    public bool respondAllOps;
    public bool durableDelete;
    public WritePolicy(WritePolicy other);
    public WritePolicy(Policy other);
}
