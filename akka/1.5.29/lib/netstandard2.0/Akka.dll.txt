public abstract class Akka.Actor.ActorBase : object {
    private IActorRef _clearedSelf;
    private SupervisorStrategy _supervisorStrategy;
    private bool HasBeenCleared { get; }
    protected IActorRef Sender { get; }
    protected IActorRef Self { get; }
    private IActorContext Akka.Actor.IInternalActor.ActorContext { get; }
    protected static IActorContext Context { get; }
    protected static Receive EmptyReceive { get; }
    internal SupervisorStrategy SupervisorStrategyInternal { get; internal set; }
    private bool get_HasBeenCleared();
    protected IActorRef get_Sender();
    protected IActorRef get_Self();
    private sealed virtual override IActorContext Akka.Actor.IInternalActor.get_ActorContext();
    protected static IActorContext get_Context();
    protected internal virtual bool AroundReceive(Receive receive, object message);
    protected abstract virtual bool Receive(object message);
    protected static Receive get_EmptyReceive();
    protected virtual void Unhandled(object message);
    protected void Become(Receive receive);
    protected void BecomeStacked(Receive receive);
    protected void UnbecomeStacked();
    internal void Clear(IActorRef self);
    internal void Unclear();
    protected void SetReceiveTimeout(Nullable`1<TimeSpan> timeout);
    public virtual void AroundPreRestart(Exception cause, object message);
    public virtual void AroundPreStart();
    protected virtual void PreStart();
    public virtual void AroundPostRestart(Exception cause, object message);
    protected virtual void PreRestart(Exception reason, object message);
    protected virtual void PostRestart(Exception reason);
    public virtual void AroundPostStop();
    protected virtual void PostStop();
    internal SupervisorStrategy get_SupervisorStrategyInternal();
    internal void set_SupervisorStrategyInternal(SupervisorStrategy value);
    protected virtual SupervisorStrategy SupervisorStrategy();
}
[DebuggerDisplayAttribute("{Self,nq}")]
public class Akka.Actor.ActorCell : object {
    private IChildrenContainer modreq(System.Runtime.CompilerServices.IsVolatile) _childrenContainerDoNotCallMeDirectly;
    private long _nextRandomNameDoNotCallMeDirectly;
    private ImmutableDictionary`2<string, FunctionRef> _functionRefsDoNotCallMeDirectly;
    private IInternalActorRef _self;
    public static int UndefinedUid;
    private Props _props;
    private static int DefaultState;
    private static int SuspendedState;
    private static int SuspendedWaitForChildrenState;
    private ActorBase _actor;
    private bool _actorHasBeenCleared;
    private Mailbox modreq(System.Runtime.CompilerServices.IsVolatile) _mailboxDoNotCallMeDirectly;
    private ActorSystemImpl _systemImpl;
    private ActorTaskScheduler _taskScheduler;
    private LatestFirstSystemMessageList _sysMsgStash;
    [CompilerGeneratedAttribute]
private object <CurrentMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDispatcher <Dispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private IInternalActorRef <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private static Props <TerminatedProps>k__BackingField;
    [NullableAttribute("1")]
private IActorState _state;
    private int _currentEnvelopeId;
    private IActorRef _failed_DoNotUseMeDirectly;
    private Nullable`1<TimeSpan> _receiveTimeoutDuration;
    private ICancelable _pendingReceiveTimeout;
    public IChildrenContainer ChildrenContainer { get; }
    private IReadOnlyCollection`1<IActorRef> Children { get; }
    private ImmutableDictionary`2<string, FunctionRef> FunctionRefs { get; }
    protected bool IsNormal { get; }
    protected bool IsTerminating { get; }
    private bool IsWaitingForChildren { get; }
    public object CurrentMessage { get; internal set; }
    public Mailbox Mailbox { get; }
    public MessageDispatcher Dispatcher { get; private set; }
    public bool IsLocal { get; }
    internal ActorBase Actor { get; }
    public bool IsTerminated { get; }
    internal static ActorCell Current { get; }
    public ActorSystem System { get; }
    public ActorSystemImpl SystemImpl { get; }
    public Props Props { get; }
    public IActorRef Self { get; }
    private IActorRef Akka.Actor.IActorContext.Parent { get; }
    public IInternalActorRef Parent { get; private set; }
    public IActorRef Sender { get; private set; }
    public bool HasMessages { get; }
    public int NumberOfMessages { get; }
    internal bool ActorHasBeenCleared { get; }
    internal static Props TerminatedProps { get; }
    public ActorTaskScheduler TaskScheduler { get; }
    private Type ActorType { get; }
    public int CurrentEnvelopeId { get; }
    private bool IsFailed { get; }
    private IActorRef Perpetrator { get; }
    public Nullable`1<TimeSpan> ReceiveTimeout { get; }
    public ActorCell(ActorSystemImpl system, IInternalActorRef self, Props props, MessageDispatcher dispatcher, IInternalActorRef parent);
    private static ActorCell();
    public sealed virtual IChildrenContainer get_ChildrenContainer();
    private IReadOnlyCollection`1<IActorRef> get_Children();
    private ImmutableDictionary`2<string, FunctionRef> get_FunctionRefs();
    internal bool TryGetFunctionRef(string name, FunctionRef& functionRef);
    internal bool TryGetFunctionRef(string name, int uid, FunctionRef& functionRef);
    internal FunctionRef AddFunctionRef(Action`2<IActorRef, object> tell, string suffix);
    internal bool RemoveFunctionRef(FunctionRef functionRef);
    protected void StopFunctionRefs();
    public virtual IActorRef AttachChild(Props props, bool isSystemService, string name);
    public virtual IActorRef ActorOf(Props props, string name);
    private IActorRef ActorOf(Props props, string name, bool isAsync, bool isSystemService);
    private string GetRandomActorName(string prefix);
    public sealed virtual void Stop(IActorRef child);
    private bool SwapChildrenRefs(IChildrenContainer oldChildren, IChildrenContainer newChildren);
    public void ReserveChild(string name);
    protected void UnreserveChild(string name);
    public ChildRestartStats InitChild(IInternalActorRef actor);
    protected bool SetChildrenTerminationReason(SuspendReason reason);
    protected void SetTerminated();
    protected bool get_IsNormal();
    protected bool get_IsTerminating();
    private bool get_IsWaitingForChildren();
    private void SuspendChildren(List`1<IActorRef> exceptFor);
    private void ResumeChildren(Exception causedByFailure, IActorRef perpetrator);
    public sealed virtual bool TryGetChildStatsByName(string name, IChildStats& child);
    private bool TryGetChildRestartStatsByName(string name, ChildRestartStats& child);
    protected bool TryGetChildStatsByRef(IActorRef actor, ChildRestartStats& child);
    public sealed virtual IInternalActorRef GetSingleChild(string name);
    protected SuspendReason RemoveChildAndGetStateChange(IActorRef child);
    private IChildrenContainer RemoveChild(IActorRef child);
    private static string CheckName(string name);
    private IInternalActorRef MakeChild(Props props, string name, bool async, bool systemService);
    protected void Stash(SystemMessage msg);
    private LatestFirstSystemMessageList UnstashAll();
    [CompilerGeneratedAttribute]
public object get_CurrentMessage();
    [CompilerGeneratedAttribute]
internal void set_CurrentMessage(object value);
    public Mailbox get_Mailbox();
    [CompilerGeneratedAttribute]
public sealed virtual MessageDispatcher get_Dispatcher();
    [CompilerGeneratedAttribute]
private void set_Dispatcher(MessageDispatcher value);
    public sealed virtual bool get_IsLocal();
    internal ActorBase get_Actor();
    public sealed virtual bool get_IsTerminated();
    internal static ActorCell get_Current();
    public sealed virtual ActorSystem get_System();
    public sealed virtual ActorSystemImpl get_SystemImpl();
    public sealed virtual Props get_Props();
    public sealed virtual IActorRef get_Self();
    private sealed virtual override IActorRef Akka.Actor.IActorContext.get_Parent();
    [CompilerGeneratedAttribute]
public sealed virtual IInternalActorRef get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(IInternalActorRef value);
    [CompilerGeneratedAttribute]
public sealed virtual IActorRef get_Sender();
    [CompilerGeneratedAttribute]
private void set_Sender(IActorRef value);
    public sealed virtual bool get_HasMessages();
    public sealed virtual int get_NumberOfMessages();
    internal bool get_ActorHasBeenCleared();
    [CompilerGeneratedAttribute]
internal static Props get_TerminatedProps();
    public virtual ActorTaskScheduler get_TaskScheduler();
    public void Init(bool sendSupervise, MailboxType mailboxType);
    [ObsoleteAttribute("Use TryGetChildStatsByName [0.7.1]", "True")]
public sealed virtual IInternalActorRef GetChildByName(string name);
    private sealed virtual override IActorRef Akka.Actor.IActorContext.Child(string name);
    public sealed virtual ActorSelection ActorSelection(string path);
    public sealed virtual ActorSelection ActorSelection(ActorPath path);
    private sealed virtual override IEnumerable`1<IActorRef> Akka.Actor.IActorContext.GetChildren();
    public sealed virtual IEnumerable`1<IInternalActorRef> GetChildren();
    public sealed virtual void Become(Receive receive);
    public sealed virtual void BecomeStacked(Receive receive);
    public sealed virtual void UnbecomeStacked();
    private sealed virtual override void Akka.Actor.IUntypedActorContext.Become(UntypedReceive receive);
    private sealed virtual override void Akka.Actor.IUntypedActorContext.BecomeStacked(UntypedReceive receive);
    private static long NewUid();
    private ActorBase NewActor();
    protected virtual ActorBase CreateNewActorInstance();
    public void UseThreadContext(Action action);
    public virtual void SendMessage(Envelope message);
    public virtual void SendMessage(IActorRef sender, object message);
    protected void ClearActorCell();
    protected void ClearActor(ActorBase actor);
    private void ReleaseActor(ActorBase a);
    protected void PrepareForNewActor();
    protected void SetActorFields(ActorBase actor);
    internal static ValueTuple`2<string, int> GetNameAndUid(string name);
    public static IActorRef GetCurrentSelfOrNoSender();
    public static IActorRef GetCurrentSenderOrNoSender();
    private Envelope SerializeAndDeserialize(Envelope envelope);
    private object SerializeAndDeserializePayload(object obj);
    [NullableContextAttribute("1")]
public sealed virtual IActorRef Watch(IActorRef subject);
    [NullableContextAttribute("1")]
public sealed virtual IActorRef WatchWith(IActorRef subject, object message);
    [NullableContextAttribute("1")]
public sealed virtual IActorRef Unwatch(IActorRef subject);
    [NullableContextAttribute("1")]
protected void ReceivedTerminated(Terminated t);
    [NullableContextAttribute("1")]
protected void WatchedActorTerminated(IActorRef actor, bool existenceConfirmed, bool addressTerminated);
    [NullableContextAttribute("1")]
public void TerminatedQueuedFor(IActorRef subject, Option`1<object> customMessage);
    [NullableContextAttribute("1")]
private bool WatchingContains(IActorRef subject);
    [NullableContextAttribute("1")]
private bool TryGetWatching(IActorRef subject, Option`1& message);
    protected void TellWatchersWeDied();
    [NullableContextAttribute("1")]
private void SendTerminated(bool ifLocal, IInternalActorRef watcher);
    [NullableContextAttribute("1")]
protected void UnwatchWatchedActors(ActorBase actor);
    [NullableContextAttribute("1")]
protected void AddWatcher(IActorRef watchee, IActorRef watcher);
    [NullableContextAttribute("1")]
protected void RemWatcher(IActorRef watchee, IActorRef watcher);
    [NullableContextAttribute("1")]
protected void AddressTerminated(Address address);
    [NullableContextAttribute("1")]
private void MaintainAddressTerminatedSubscription(Action block, IActorRef change);
    [NullableContextAttribute("2")]
private static bool IsNonLocal(IActorRef ref);
    private bool HasNonLocalAddress();
    private void UnsubscribeAddressTerminated();
    private void SubscribeAddressTerminated();
    private Type get_ActorType();
    public int get_CurrentEnvelopeId();
    public void Invoke(Envelope envelope);
    private IActorRef MatchSender(Envelope envelope);
    protected internal virtual void AutoReceiveMessage(Envelope envelope);
    public void ReceiveMessageForTest(Envelope envelope);
    protected virtual void ReceiveMessage(object message);
    private void ReceiveSelection(ActorSelectionMessage m);
    private int CalculateState();
    private static bool ShouldStash(SystemMessage m, int state);
    private void SendAllToDeadLetters(EarliestFirstSystemMessageList messages);
    private void SysMsgInvokeAll(EarliestFirstSystemMessageList messages, int currentState);
    internal void SystemInvoke(ISystemMessage envelope);
    private void HandleActorTaskSchedulerMessage(ActorTaskSchedulerMessage m);
    internal Mailbox SwapMailbox(Mailbox mailbox);
    private void Publish(LogEvent event);
    private void Supervise(IActorRef child, bool async);
    private static void HandleSupervise(IActorRef child, bool async);
    private void HandleIdentity(Identify m);
    private void HandlePoisonPill();
    public sealed virtual void Restart(Exception cause);
    private void Create(Exception failure);
    public virtual void Start();
    protected virtual void PreStart();
    public sealed virtual void Resume(Exception causedByFailure);
    public sealed virtual void Stop();
    public sealed virtual void Suspend();
    public virtual void SendSystemMessage(ISystemMessage systemMessage);
    private static void Kill();
    private void SuspendNonRecursive();
    private void ResumeNonRecursive();
    private bool get_IsFailed();
    private void SetFailed(IActorRef perpetrator);
    private void ClearFailed();
    private IActorRef get_Perpetrator();
    private void FaultRecreate(Exception cause);
    private void FaultSuspend();
    private void FaultResume(Exception causedByFailure);
    private void FaultCreate();
    private void FinishCreate();
    private void Terminate();
    private void HandleInvokeFailure(Exception cause, IEnumerable`1<IActorRef> childrenNotToSuspend);
    private void StopChildren();
    private void FinishTerminate();
    private void FinishRecreate(Exception cause, ActorBase failedActor);
    private void HandleFailed(Failed f);
    private void HandleChildTerminated(IActorRef child);
    private void HandleNonFatalOrInterruptedException(Action action);
    public sealed virtual void SetReceiveTimeout(Nullable`1<TimeSpan> timeout);
    public sealed virtual Nullable`1<TimeSpan> get_ReceiveTimeout();
    public void CheckReceiveTimeout(bool reschedule);
    private void RescheduleReceiveTimeout(TimeSpan timeout);
    private void CancelReceiveTimeout();
    [CompilerGeneratedAttribute]
private void <TellWatchersWeDied>b__140_0();
}
public class Akka.Actor.ActorIdentity : object {
    [CompilerGeneratedAttribute]
private object <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <Subject>k__BackingField;
    public object MessageId { get; }
    public IActorRef Subject { get; }
    public ActorIdentity(object messageId, IActorRef subject);
    [CompilerGeneratedAttribute]
public object get_MessageId();
    [CompilerGeneratedAttribute]
public IActorRef get_Subject();
    private bool Equals(ActorIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Akka.Actor.ActorInitializationException : AkkaException {
    [CompilerGeneratedAttribute]
private IActorRef <Actor>k__BackingField;
    public IActorRef Actor { get; public set; }
    public ActorInitializationException(string message);
    public ActorInitializationException(string message, Exception cause);
    public ActorInitializationException(IActorRef actor, string message, Exception cause);
    protected ActorInitializationException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IActorRef get_Actor();
    [CompilerGeneratedAttribute]
public void set_Actor(IActorRef value);
    public virtual string ToString();
}
public class Akka.Actor.ActorInterruptedException : AkkaException {
    public ActorInterruptedException(string message, Exception cause);
    protected ActorInterruptedException(SerializationInfo info, StreamingContext context);
}
public class Akka.Actor.ActorKilledException : AkkaException {
    public ActorKilledException(string message);
    protected ActorKilledException(SerializationInfo info, StreamingContext context);
}
public class Akka.Actor.ActorNotFoundException : AkkaException {
    protected ActorNotFoundException(SerializationInfo info, StreamingContext context);
    public ActorNotFoundException(string message, Exception innerException);
}
public abstract class Akka.Actor.ActorPath : object {
    public static string ValidSymbols;
    private static Boolean[] ValidAscii;
    internal static string ValidActorNameDescription;
    private Address _address;
    private ActorPath _parent;
    private int _depth;
    private string _name;
    private long _uid;
    public string Name { get; }
    public Address Address { get; }
    public long Uid { get; }
    public ActorPath Parent { get; }
    public int Depth { get; }
    public IReadOnlyList`1<string> Elements { get; }
    internal IReadOnlyList`1<string> ElementsWithUid { get; }
    [JsonIgnoreAttribute]
public ActorPath Root { get; }
    protected ActorPath(Address address, string name);
    protected ActorPath(ActorPath parentPath, string name, long uid);
    private static ActorPath();
    public static bool IsValidPathElement(string s);
    private static bool IsValidChar(char c);
    private static bool IsHexChar(char c);
    private static bool Validate(string chars);
    public string get_Name();
    public Address get_Address();
    public long get_Uid();
    public ActorPath get_Parent();
    public int get_Depth();
    public IReadOnlyList`1<string> get_Elements();
    internal IReadOnlyList`1<string> get_ElementsWithUid();
    public ActorPath get_Root();
    public sealed virtual bool Equals(ActorPath other);
    public sealed virtual int CompareTo(ActorPath other);
    private int InternalCompareTo(ActorPath left, ActorPath right);
    public ActorPath WithUid(long uid);
    public static ActorPath op_Division(ActorPath path, string name);
    public static ActorPath op_Division(ActorPath path, IEnumerable`1<string> name);
    public ActorPath ParentOf(int depth);
    public static ActorPath Parse(string path);
    public static bool TryParse(string path, ActorPath& actorPath);
    public static bool TryParse(ActorPath basePath, string absoluteUri, ActorPath& actorPath);
    public static bool TryParse(ActorPath basePath, ReadOnlySpan`1<char> absoluteUri, ActorPath& actorPath);
    public static bool TryParseAddress(string path, Address& address);
    public static bool TryParseAddress(string path, Address& address, ReadOnlySpan`1& absoluteUri);
    public static bool TryParseParts(ReadOnlySpan`1<char> path, ReadOnlySpan`1& address, ReadOnlySpan`1& absoluteUri);
    private string Join(ReadOnlySpan`1<char> prefix, Nullable`1<long> uid);
    public string ToStringWithoutAddress();
    public virtual string ToString();
    public string ToStringWithUid();
    public ActorPath Child(string childName);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ActorPath left, ActorPath right);
    public static bool op_Inequality(ActorPath left, ActorPath right);
    public string ToStringWithAddress();
    private string ToStringWithAddress(bool includeUid);
    public string ToSerializationFormat();
    public string ToSerializationFormatWithAddress(Address address);
    private string AppendUidFragment(string withAddress);
    public string ToStringWithAddress(Address address);
    private string ToStringWithAddress(Address address, bool includeUid);
    public static string FormatPathElements(IEnumerable`1<string> pathElements);
    public sealed virtual ISurrogate ToSurrogate(ActorSystem system);
    [CompilerGeneratedAttribute]
internal static void <Join>g__AppendUidSpan|45_0(Span`1& writeable, int startPos, int sizeHint, <>c__DisplayClass45_0& );
}
public class Akka.Actor.ActorProducerPipeline : object {
    private Lazy`1<ILoggingAdapter> _log;
    private List`1<IActorProducerPlugin> _plugins;
    public int Count { get; }
    public ActorProducerPipeline(Lazy`1<ILoggingAdapter> log, IEnumerable`1<IActorProducerPlugin> plugins);
    public int get_Count();
    public void AfterActorIncarnated(ActorBase actor, IActorContext context);
    public void BeforeActorIncarnated(ActorBase actor, IActorContext context);
    private void LogException(ActorBase actor, Exception e, string errorMessageFormat, IActorProducerPlugin plugin);
    public sealed virtual IEnumerator`1<IActorProducerPlugin> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Akka.Actor.ActorProducerPipelineResolver : object {
    private Lazy`1<ILoggingAdapter> _log;
    private List`1<IActorProducerPlugin> _plugins;
    private ConcurrentDictionary`2<Type, ActorProducerPipeline> _pipelines;
    public int TotalPluginCount { get; }
    public ActorProducerPipelineResolver(Func`1<ILoggingAdapter> logBuilder);
    public int get_TotalPluginCount();
    public bool Register(IActorProducerPlugin plugin);
    public bool Insert(int index, IActorProducerPlugin plugin);
    public bool Unregister(IActorProducerPlugin plugin);
    public bool IsRegistered(IActorProducerPlugin plugin);
    internal ActorProducerPipeline ResolvePipeline(Type actorType);
    private ActorProducerPipeline CreatePipeline(Type type);
    [IteratorStateMachineAttribute("Akka.Actor.ActorProducerPipelineResolver/<PluginCollectionFor>d__12")]
private IEnumerable`1<IActorProducerPlugin> PluginCollectionFor(Type actorType);
    private bool AlreadyExists(IActorProducerPlugin plugin);
}
public abstract class Akka.Actor.ActorProducerPluginBase : object {
    public virtual bool CanBeAppliedTo(Type actorType);
    public virtual void AfterIncarnated(ActorBase actor, IActorContext context);
    public virtual void BeforeIncarnated(ActorBase actor, IActorContext context);
}
public abstract class Akka.Actor.ActorProducerPluginBase`1 : object {
    public virtual bool CanBeAppliedTo(Type actorType);
    private sealed virtual override void Akka.Actor.IActorProducerPlugin.AfterIncarnated(ActorBase actor, IActorContext context);
    private sealed virtual override void Akka.Actor.IActorProducerPlugin.BeforeIncarnated(ActorBase actor, IActorContext context);
    public virtual void AfterIncarnated(TActor actor, IActorContext context);
    public virtual void BeforeIncarnated(TActor actor, IActorContext context);
}
public abstract class Akka.Actor.ActorRefBase : object {
    public ActorPath Path { get; }
    public abstract virtual ActorPath get_Path();
    public sealed virtual void Tell(object message, IActorRef sender);
    protected abstract virtual void TellInternal(object message, IActorRef sender);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual bool Equals(IActorRef other);
    public sealed virtual int CompareTo(IActorRef other);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
[ExtensionAttribute]
public static class Akka.Actor.ActorRefExtensions : object {
    [ExtensionAttribute]
public static bool IsNobody(IActorRef actorRef);
    [ExtensionAttribute]
public static IActorRef GetOrElse(IActorRef actorRef, Func`1<IActorRef> elseValue);
}
[ExtensionAttribute]
public static class Akka.Actor.ActorRefFactoryExtensions : object {
    [ExtensionAttribute]
public static IActorRef ActorOf(IActorRefFactory factory, string name);
    [ExtensionAttribute]
public static ActorSelection ActorSelection(IActorRefFactory factory, IActorRef anchorRef, string actorPath);
}
public static class Akka.Actor.ActorRefFactoryShared : object {
    public static ActorSelection ActorSelection(ActorPath actorPath, ActorSystem system);
    public static ActorSelection ActorSelection(string path, ActorSystem system, IActorRef lookupRoot);
    public static ActorSelection ActorSelection(IActorRef anchorActorRef, string path);
}
[ExtensionAttribute]
public static class Akka.Actor.ActorRefImplicitSenderExtensions : object {
    [ExtensionAttribute]
public static void Tell(IActorRef receiver, object message);
    [ExtensionAttribute]
public static void Forward(IActorRef receiver, object message);
}
public static class Akka.Actor.ActorRefs : object {
    public static Nobody Nobody;
    public static IActorRef NoSender;
    private static ActorRefs();
}
internal static class Akka.Actor.ActorRefSender : object {
    public static IActorRef GetSelfOrNoSender();
}
[InternalApiAttribute]
public abstract class Akka.Actor.ActorRefWithCell : InternalActorRefBase {
    public ICell Underlying { get; }
    public IEnumerable`1<IActorRef> Children { get; }
    public abstract virtual ICell get_Underlying();
    public abstract virtual IEnumerable`1<IActorRef> get_Children();
    public abstract virtual IInternalActorRef GetSingleChild(string name);
    [IteratorStateMachineAttribute("Akka.Actor.ActorRefWithCell/<SelfAndChildren>d__5")]
private IEnumerable`1<IActorRef> SelfAndChildren();
}
public class Akka.Actor.ActorRestarted : object {
    [CompilerGeneratedAttribute]
private IActorRef <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ActorType>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    public IActorRef Subject { get; }
    public Type ActorType { get; }
    public Exception Reason { get; }
    internal ActorRestarted(IActorRef subject, Type actorType, Exception reason);
    [CompilerGeneratedAttribute]
public sealed virtual IActorRef get_Subject();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ActorType();
    [CompilerGeneratedAttribute]
public Exception get_Reason();
}
public class Akka.Actor.ActorSelection : object {
    [CompilerGeneratedAttribute]
private IActorRef <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionPathElement[] <Path>k__BackingField;
    public IActorRef Anchor { get; private set; }
    public SelectionPathElement[] Path { get; private set; }
    public string PathString { get; }
    public ActorSelection(IActorRef anchor, SelectionPathElement[] path);
    public ActorSelection(IActorRef anchor, string path);
    public ActorSelection(IActorRef anchor, IEnumerable`1<string> elements);
    [CompilerGeneratedAttribute]
public IActorRef get_Anchor();
    [CompilerGeneratedAttribute]
private void set_Anchor(IActorRef value);
    [CompilerGeneratedAttribute]
public SelectionPathElement[] get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(SelectionPathElement[] value);
    public string get_PathString();
    public sealed virtual void Tell(object message, IActorRef sender);
    public Task`1<IActorRef> ResolveOne(TimeSpan timeout);
    public Task`1<IActorRef> ResolveOne(TimeSpan timeout, CancellationToken ct);
    [AsyncStateMachineAttribute("Akka.Actor.ActorSelection/<InnerResolveOne>d__17")]
private Task`1<IActorRef> InnerResolveOne(TimeSpan timeout, CancellationToken ct);
    internal static void DeliverSelection(IInternalActorRef anchor, IActorRef sender, ActorSelectionMessage sel);
    public virtual bool Equals(object obj);
    protected bool Equals(ActorSelection other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static void <DeliverSelection>g__Rec|18_0(IInternalActorRef actorRef, <>c__DisplayClass18_0& , <>c__DisplayClass18_1& );
    [CompilerGeneratedAttribute]
internal static EmptyLocalActorRef <DeliverSelection>g__EmptyRef|18_1(<>c__DisplayClass18_0& , <>c__DisplayClass18_2& );
}
public class Akka.Actor.ActorSelectionMessage : object {
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionPathElement[] <Elements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WildCardFanOut>k__BackingField;
    public object Message { get; }
    public SelectionPathElement[] Elements { get; }
    public bool WildCardFanOut { get; }
    public ActorSelectionMessage(object message, SelectionPathElement[] elements, bool wildCardFanOut);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Message();
    [CompilerGeneratedAttribute]
public SelectionPathElement[] get_Elements();
    [CompilerGeneratedAttribute]
public bool get_WildCardFanOut();
    public virtual string ToString();
    public ActorSelectionMessage Copy(object message, SelectionPathElement[] elements, Nullable`1<bool> wildCardFanOut);
}
public class Akka.Actor.ActorStarted : object {
    [CompilerGeneratedAttribute]
private IActorRef <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ActorType>k__BackingField;
    public IActorRef Subject { get; }
    public Type ActorType { get; }
    internal ActorStarted(IActorRef subject, Type actorType);
    [CompilerGeneratedAttribute]
public sealed virtual IActorRef get_Subject();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ActorType();
}
public class Akka.Actor.ActorStashPlugin : ActorProducerPluginBase {
    public virtual bool CanBeAppliedTo(Type actorType);
    public virtual void AfterIncarnated(ActorBase actor, IActorContext context);
    public virtual void BeforeIncarnated(ActorBase actor, IActorContext context);
}
public class Akka.Actor.ActorStopped : object {
    [CompilerGeneratedAttribute]
private IActorRef <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ActorType>k__BackingField;
    public IActorRef Subject { get; }
    public Type ActorType { get; }
    internal ActorStopped(IActorRef subject, Type actorType);
    [CompilerGeneratedAttribute]
public sealed virtual IActorRef get_Subject();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ActorType();
}
public abstract class Akka.Actor.ActorSystem : object {
    [CompilerGeneratedAttribute]
private TimeSpan <StartTime>k__BackingField;
    private TimeSpan _creationTime;
    private bool _isDisposed;
    public Settings Settings { get; }
    public string Name { get; }
    public Serialization Serialization { get; }
    public EventStream EventStream { get; }
    public IActorRef DeadLetters { get; }
    public IActorRef IgnoreRef { get; }
    public Dispatchers Dispatchers { get; }
    public Mailboxes Mailboxes { get; }
    public IScheduler Scheduler { get; }
    public ILoggingAdapter Log { get; }
    public TimeSpan StartTime { get; }
    public TimeSpan Uptime { get; }
    public Task WhenTerminated { get; }
    public abstract virtual Settings get_Settings();
    public abstract virtual string get_Name();
    public abstract virtual Serialization get_Serialization();
    public abstract virtual EventStream get_EventStream();
    public abstract virtual IActorRef get_DeadLetters();
    public abstract virtual IActorRef get_IgnoreRef();
    public abstract virtual Dispatchers get_Dispatchers();
    public abstract virtual Mailboxes get_Mailboxes();
    public abstract virtual IScheduler get_Scheduler();
    public abstract virtual ILoggingAdapter get_Log();
    [CompilerGeneratedAttribute]
public TimeSpan get_StartTime();
    public TimeSpan get_Uptime();
    public static ActorSystem Create(string name, Config config);
    public static ActorSystem Create(string name, BootstrapSetup setup);
    public static ActorSystem Create(string name, ActorSystemSetup setup);
    public static ActorSystem Create(string name);
    private static ActorSystem CreateAndStartSystem(string name, Config withFallback, ActorSystemSetup setup);
    public abstract virtual object GetExtension(IExtensionId extensionId);
    public abstract virtual T GetExtension();
    public abstract virtual bool HasExtension(Type type);
    public abstract virtual bool HasExtension();
    public abstract virtual bool TryGetExtension(Type extensionType, Object& extension);
    public abstract virtual bool TryGetExtension(T& extension);
    public abstract virtual void RegisterOnTermination(Action code);
    public abstract virtual Task Terminate();
    internal abstract virtual Task FinalTerminate();
    public abstract virtual Task get_WhenTerminated();
    public abstract virtual void Stop(IActorRef actor);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public abstract virtual object RegisterExtension(IExtensionId extension);
    public abstract virtual IActorRef ActorOf(Props props, string name);
    public abstract virtual ActorSelection ActorSelection(ActorPath actorPath);
    public abstract virtual ActorSelection ActorSelection(string actorPath);
}
[ExtensionAttribute]
public static class Akka.Actor.ActorSystemWithExtensions : object {
    [ExtensionAttribute]
public static T WithExtension(ActorSystem system);
    [ExtensionAttribute]
public static T WithExtension(ActorSystem system, Type extensionId);
    [ExtensionAttribute]
public static T WithExtension(ActorSystem system);
}
public class Akka.Actor.Address : object {
    public static IComparer`1<Address> Comparer;
    public static Address AllSystems;
    private string _toString;
    private string _host;
    private Nullable`1<int> _port;
    private string _system;
    private string _protocol;
    public string Host { get; }
    public Nullable`1<int> Port { get; }
    public string System { get; }
    public string Protocol { get; }
    public bool HasLocalScope { get; }
    public bool HasGlobalScope { get; }
    public Address(string protocol, string system, string host, Nullable`1<int> port);
    private static Address();
    public string get_Host();
    public Nullable`1<int> get_Port();
    public string get_System();
    public string get_Protocol();
    public bool get_HasLocalScope();
    public bool get_HasGlobalScope();
    private static string CreateLazyToString(Address addr);
    public sealed virtual int CompareTo(Address other);
    public virtual string ToString();
    public sealed virtual bool Equals(Address other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual object Clone();
    public Address WithProtocol(string protocol);
    public Address WithSystem(string system);
    public Address WithHost(string host);
    public Address WithPort(Nullable`1<int> port);
    public static bool op_Equality(Address left, Address right);
    public static bool op_Inequality(Address left, Address right);
    public string HostPort();
    public static Address Parse(string address);
    public static bool TryParse(string path, Address& address);
    public static bool TryParse(string path, Address& address, String& absolutUri);
    public static bool TryParse(ReadOnlySpan`1<char> span, Address& address);
    public static bool TryParse(ReadOnlySpan`1<char> span, Address& address, ReadOnlySpan`1& absolutUri);
    public sealed virtual ISurrogate ToSurrogate(ActorSystem system);
}
internal class Akka.Actor.AddressTerminated : object {
    [CompilerGeneratedAttribute]
private Address <Address>k__BackingField;
    public Address Address { get; }
    public AddressTerminated(Address address);
    [CompilerGeneratedAttribute]
public Address get_Address();
    public virtual string ToString();
}
public abstract class Akka.Actor.AkkaException : Exception {
    protected Exception Cause { get; }
    protected AkkaException(string message, Exception cause);
    protected AkkaException(SerializationInfo info, StreamingContext context);
    protected Exception get_Cause();
}
public class Akka.Actor.AllForOneStrategy : SupervisorStrategy {
    private IDecider _decider;
    private int _withinTimeRangeMilliseconds;
    private int _maxNumberOfRetries;
    public int MaxNumberOfRetries { get; }
    public int WithinTimeRangeMilliseconds { get; }
    public IDecider Decider { get; }
    public AllForOneStrategy(Nullable`1<int> maxNrOfRetries, Nullable`1<TimeSpan> withinTimeRange, Func`2<Exception, Directive> localOnlyDecider);
    public AllForOneStrategy(Nullable`1<int> maxNrOfRetries, Nullable`1<TimeSpan> withinTimeRange, IDecider decider);
    public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Func`2<Exception, Directive> localOnlyDecider, bool loggingEnabled);
    public AllForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, IDecider decider, bool loggingEnabled);
    public AllForOneStrategy(Func`2<Exception, Directive> localOnlyDecider);
    public AllForOneStrategy(IDecider decider);
    public int get_MaxNumberOfRetries();
    public int get_WithinTimeRangeMilliseconds();
    public virtual IDecider get_Decider();
    protected virtual Directive Handle(IActorRef child, Exception exception);
    public virtual void ProcessFailure(IActorContext context, bool restart, IActorRef child, Exception cause, ChildRestartStats stats, IReadOnlyCollection`1<ChildRestartStats> children);
    public virtual void HandleChildTerminated(IActorContext actorContext, IActorRef child, IEnumerable`1<IInternalActorRef> children);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
    public sealed virtual bool Equals(AllForOneStrategy other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private bool <ProcessFailure>b__17_0(ChildRestartStats c);
}
internal class Akka.Actor.AlreadyCanceledCancelable : object {
    [CompilerGeneratedAttribute]
private static ICancelable <Instance>k__BackingField;
    public bool IsCancellationRequested { get; }
    public static ICancelable Instance { get; }
    public CancellationToken Token { get; }
    private static AlreadyCanceledCancelable();
    public sealed virtual void Cancel();
    public sealed virtual bool get_IsCancellationRequested();
    [CompilerGeneratedAttribute]
public static ICancelable get_Instance();
    public sealed virtual CancellationToken get_Token();
    private sealed virtual override void Akka.Actor.ICancelable.CancelAfter(TimeSpan delay);
    private sealed virtual override void Akka.Actor.ICancelable.CancelAfter(int millisecondsDelay);
    private sealed virtual override void Akka.Actor.ICancelable.Cancel(bool throwOnFirstException);
}
public class Akka.Actor.AskTimeoutException : AkkaException {
    public AskTimeoutException(string message);
    protected AskTimeoutException(SerializationInfo info, StreamingContext context);
}
public class Akka.Actor.BootstrapSetup : Setup {
    [CompilerGeneratedAttribute]
private Option`1<Config> <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<ProviderSelection> <ActorRefProvider>k__BackingField;
    public Option`1<Config> Config { get; }
    public Option`1<ProviderSelection> ActorRefProvider { get; }
    internal BootstrapSetup(Option`1<Config> config, Option`1<ProviderSelection> actorRefProvider);
    [CompilerGeneratedAttribute]
public Option`1<Config> get_Config();
    [CompilerGeneratedAttribute]
public Option`1<ProviderSelection> get_ActorRefProvider();
    public static BootstrapSetup Create();
    public BootstrapSetup WithActorRefProvider(ProviderSelection name);
    public BootstrapSetup WithConfig(Config config);
    public BootstrapSetup WithConfigFallback(Config config);
}
public class Akka.Actor.Cancelable : object {
    private IActionScheduler _scheduler;
    private CancellationTokenSource _source;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsCancellationRequested { get; }
    public CancellationToken Token { get; }
    public bool IsDisposed { get; private set; }
    public Cancelable(IActionScheduler scheduler, TimeSpan delay);
    public Cancelable(IScheduler scheduler, TimeSpan delay);
    public Cancelable(IScheduler scheduler, int millisecondsDelay);
    public Cancelable(IScheduler scheduler);
    public Cancelable(IActionScheduler scheduler);
    private Cancelable(IActionScheduler scheduler, CancellationTokenSource source);
    public sealed virtual bool get_IsCancellationRequested();
    public sealed virtual CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Cancel();
    public sealed virtual void Cancel(bool throwOnFirstException);
    public sealed virtual void CancelAfter(TimeSpan delay);
    public sealed virtual void CancelAfter(int millisecondsDelay);
    private void InternalCancelAfter(TimeSpan delay);
    public static ICancelable CreateCanceled();
    public static ICancelable CreateLinkedCancelable(IScheduler scheduler, ICancelable[] cancelables);
    public static ICancelable CreateLinkedCancelable(IActionScheduler scheduler, ICancelable[] cancelables);
    public static ICancelable CreateLinkedCancelable(IScheduler scheduler, CancellationToken[] cancellationTokens);
    public static ICancelable CreateLinkedCancelable(IActionScheduler scheduler, CancellationToken[] cancellationTokens);
    private void ThrowIfDisposed();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <InternalCancelAfter>b__20_0();
}
[ExtensionAttribute]
public static class Akka.Actor.CancelableExtensions : object {
    [ExtensionAttribute]
public static void CancelIfNotNull(ICancelable cancelable);
}
public class Akka.Actor.ChildActorPath : ActorPath {
    public ChildActorPath(ActorPath parentPath, string name, long uid);
}
public class Akka.Actor.CoordinatedShutdown : object {
    public static string PhaseBeforeServiceUnbind;
    public static string PhaseServiceUnbind;
    public static string PhaseServiceRequestsDone;
    public static string PhaseServiceStop;
    public static string PhaseBeforeClusterShutdown;
    public static string PhaseClusterShardingShutdownRegion;
    public static string PhaseClusterLeave;
    public static string PhaseClusterExiting;
    public static string PhaseClusterExitingDone;
    public static string PhaseClusterShutdown;
    public static string PhaseBeforeActorSystemTerminate;
    public static string PhaseActorSystemTerminate;
    [CompilerGeneratedAttribute]
private ExtendedActorSystem <System>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Phase> <Phases>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggingAdapter <Log>k__BackingField;
    private HashSet`1<string> _knownPhases;
    internal List`1<string> OrderedPhases;
    private ConcurrentSet`1<Func`1<Task`1<Done>>> _clrShutdownTasks;
    private ConcurrentDictionary`2<string, ImmutableList`1<ValueTuple`2<string, Func`1<Task`1<Done>>>>> _tasks;
    private AtomicReference`1<Reason> _runStarted;
    private AtomicBoolean _clrHooksStarted;
    private TaskCompletionSource`1<Done> _runPromise;
    private TaskCompletionSource`1<Done> _hooksRunPromise;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _runningClrHook;
    public ExtendedActorSystem System { get; }
    internal Dictionary`2<string, Phase> Phases { get; }
    internal ILoggingAdapter Log { get; }
    internal Task`1<Done> ClrShutdownTask { get; }
    public Reason ShutdownReason { get; }
    public TimeSpan TotalTimeout { get; }
    internal CoordinatedShutdown(ExtendedActorSystem system, Dictionary`2<string, Phase> phases);
    public static CoordinatedShutdown Get(ActorSystem sys);
    [CompilerGeneratedAttribute]
public ExtendedActorSystem get_System();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, Phase> get_Phases();
    [CompilerGeneratedAttribute]
internal ILoggingAdapter get_Log();
    internal Task`1<Done> get_ClrShutdownTask();
    public void AddTask(string phase, string taskName, Func`1<Task`1<Done>> task);
    internal void AddClrShutdownHook(Func`1<Task`1<Done>> hook);
    private Task`1<Done> RunClrHooks();
    public Reason get_ShutdownReason();
    public Task`1<Done> Run(Reason reason, string fromPhase);
    public TimeSpan Timeout(string phase);
    public TimeSpan get_TotalTimeout();
    internal static Dictionary`2<string, Phase> PhasesFromConfig(Config config);
    internal static List`1<string> TopologicalSort(Dictionary`2<string, Phase> phases);
    internal static void InitPhaseActorSystemTerminate(ActorSystem system, Config conf, CoordinatedShutdown coord);
    internal static void InitClrHook(ActorSystem system, Config conf, CoordinatedShutdown coord);
    private static EventHandler TerminateOnClrExit(CoordinatedShutdown coord);
    [CompilerGeneratedAttribute]
private Task`1<Done> <RunClrHooks>b__43_0(Func`1<Task`1<Done>> hook);
    [CompilerGeneratedAttribute]
private void <RunClrHooks>b__43_1(Task`1<Done[]> tr);
    [CompilerGeneratedAttribute]
private void <Run>b__46_1(Task`1<Done> tr);
    [CompilerGeneratedAttribute]
private TimeSpan <get_TotalTimeout>b__49_0(TimeSpan span, string s);
}
public class Akka.Actor.CoordinatedShutdownExtension : ExtensionIdProvider`1<CoordinatedShutdown> {
    public virtual CoordinatedShutdown CreateExtension(ExtendedActorSystem system);
}
[ObsoleteAttribute("This class will be removed in Akka.NET v1.6.0 - use the IScheduler instead.")]
public class Akka.Actor.DateTimeOffsetNowTimeProvider : object {
    [CompilerGeneratedAttribute]
private static DateTimeOffsetNowTimeProvider <Instance>k__BackingField;
    public DateTimeOffset Now { get; }
    public DateTime DateTimeNow { get; }
    public TimeSpan MonotonicClock { get; }
    public TimeSpan HighResMonotonicClock { get; }
    public static DateTimeOffsetNowTimeProvider Instance { get; }
    private static DateTimeOffsetNowTimeProvider();
    public sealed virtual DateTimeOffset get_Now();
    public sealed virtual DateTime get_DateTimeNow();
    public sealed virtual TimeSpan get_MonotonicClock();
    public sealed virtual TimeSpan get_HighResMonotonicClock();
    [CompilerGeneratedAttribute]
public static DateTimeOffsetNowTimeProvider get_Instance();
}
public class Akka.Actor.DeadLetterActorRef : EmptyLocalActorRef {
    private EventStream _eventStream;
    public DeadLetterActorRef(IActorRefProvider provider, ActorPath path, EventStream eventStream);
    protected virtual void TellInternal(object message, IActorRef sender);
    protected virtual bool SpecialHandle(object message, IActorRef sender);
}
[InternalApiAttribute]
public class Akka.Actor.DeadLetterMailbox : Mailbox {
    private IActorRef _deadLetters;
    internal bool HasSystemMessages { get; }
    public DeadLetterMailbox(IActorRef deadLetters);
    internal virtual bool get_HasSystemMessages();
    internal virtual EarliestFirstSystemMessageList SystemDrain(LatestFirstSystemMessageList newContents);
    internal virtual void SystemEnqueue(IActorRef receiver, SystemMessage message);
}
internal class Akka.Actor.DeadLetterMessageQueue : object {
    private IActorRef _deadLetters;
    public bool HasMessages { get; }
    public int Count { get; }
    public DeadLetterMessageQueue(IActorRef deadLetters);
    public sealed virtual bool get_HasMessages();
    public sealed virtual int get_Count();
    public sealed virtual void Enqueue(IActorRef receiver, Envelope envelope);
    public sealed virtual bool TryDequeue(Envelope& envelope);
    public sealed virtual void CleanUp(IActorRef owner, IMessageQueue deadletters);
}
internal class Akka.Actor.DeadlineComparer : object {
    [CompilerGeneratedAttribute]
private static DeadlineComparer <Instance>k__BackingField;
    public static DeadlineComparer Instance { get; }
    private static DeadlineComparer();
    [CompilerGeneratedAttribute]
public static DeadlineComparer get_Instance();
    public sealed virtual int Compare(IQuery x, IQuery y);
}
public class Akka.Actor.DeathPactException : AkkaException {
    [CompilerGeneratedAttribute]
private IActorRef <DeadActor>k__BackingField;
    public IActorRef DeadActor { get; }
    public DeathPactException(IActorRef deadActor);
    protected DeathPactException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IActorRef get_DeadActor();
}
public static class Akka.Actor.Decider : object {
    public static DeployableDecider From(Directive defaultDirective, KeyValuePair`2[] pairs);
    public static DeployableDecider From(Directive defaultDirective, IEnumerable`1<KeyValuePair`2<Type, Directive>> pairs);
    public static LocalOnlyDecider From(Func`2<Exception, Directive> localOnlyDecider);
}
internal class Akka.Actor.DefaultActorState : object {
    private IActorRef _watchedBy;
    private Receive _receive;
    public sealed virtual IActorState RemoveWatching(IActorRef actor);
    public sealed virtual IActorState RemoveWatchedBy(IActorRef actor);
    public sealed virtual ValueTuple`2<IActorState, Option`1<object>> RemoveTerminated(IActorRef actor);
    public sealed virtual IActorState AddWatching(IActorRef actor, Option`1<object> msg);
    public sealed virtual IActorState AddWatchedBy(IActorRef actor);
    private FullActorState GetFullState();
    public sealed virtual IActorState AddTerminated(IActorRef actor, Option`1<object> customMessage);
    public sealed virtual bool ContainsWatching(IActorRef actor);
    public sealed virtual bool TryGetWatching(IActorRef actor, Option`1& msg);
    public sealed virtual bool ContainsWatchedBy(IActorRef actor);
    public sealed virtual bool ContainsTerminated(IActorRef actor);
    [IteratorStateMachineAttribute("Akka.Actor.DefaultActorState/<GetWatching>d__13")]
public sealed virtual IEnumerable`1<IActorRef> GetWatching();
    [IteratorStateMachineAttribute("Akka.Actor.DefaultActorState/<GetWatchedBy>d__14")]
public sealed virtual IEnumerable`1<IActorRef> GetWatchedBy();
    [IteratorStateMachineAttribute("Akka.Actor.DefaultActorState/<GetTerminated>d__15")]
public sealed virtual IEnumerable`1<IActorRef> GetTerminated();
    public sealed virtual IActorState ClearWatching();
    public sealed virtual IActorState ClearWatchedBy();
    public sealed virtual IActorState ClearTerminated();
    public sealed virtual IActorState Become(Receive receive);
    public sealed virtual IActorState BecomeStacked(Receive receive);
    public sealed virtual IActorState UnbecomeStacked();
    public sealed virtual IActorState ClearBehaviorStack();
    public sealed virtual Receive GetCurrentBehavior();
}
public class Akka.Actor.DefaultSupervisorStrategy : SupervisorStrategyConfigurator {
    public virtual SupervisorStrategy Create();
}
public class Akka.Actor.Deploy : object {
    public static Deploy Local;
    public static string NoDispatcherGiven;
    public static string NoMailboxGiven;
    public static int NoStashSize;
    internal static string DispatcherSameAsParent;
    public static Scope NoScopeGiven;
    public static Deploy None;
    private Config _config;
    private string _dispatcher;
    private string _mailbox;
    private string _path;
    private int _boundedStashCapacity;
    private RouterConfig _routerConfig;
    private Scope _scope;
    public string Path { get; }
    public Config Config { get; }
    public RouterConfig RouterConfig { get; }
    public Scope Scope { get; }
    public string Mailbox { get; }
    public string Dispatcher { get; }
    public int StashCapacity { get; }
    public Deploy(string path, Scope scope);
    public Deploy(Scope scope);
    public Deploy(RouterConfig routerConfig, Scope scope);
    public Deploy(RouterConfig routerConfig);
    public Deploy(string path, Config config, RouterConfig routerConfig, Scope scope, string dispatcher);
    public Deploy(string path, Config config, RouterConfig routerConfig, Scope scope, string dispatcher, string mailbox);
    public Deploy(string path, Config config, RouterConfig routerConfig, Scope scope, string dispatcher, string mailbox, int stashCapacity);
    private static Deploy();
    public string get_Path();
    public Config get_Config();
    public RouterConfig get_RouterConfig();
    public Scope get_Scope();
    public string get_Mailbox();
    public string get_Dispatcher();
    public int get_StashCapacity();
    public sealed virtual bool Equals(Deploy other);
    public sealed virtual ISurrogate ToSurrogate(ActorSystem system);
    public virtual Deploy WithFallback(Deploy other);
    public virtual Deploy WithScope(Scope scope);
    public virtual Deploy WithMailbox(string mailbox);
    public virtual Deploy WithDispatcher(string dispatcher);
    public virtual Deploy WithRouterConfig(RouterConfig routerConfig);
    public virtual Deploy WithStashCapacity(int stashSize);
}
public class Akka.Actor.DeployableDecider : object {
    [CompilerGeneratedAttribute]
private Directive <DefaultDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2[] <Pairs>k__BackingField;
    public Directive DefaultDirective { get; private set; }
    public KeyValuePair`2[] Pairs { get; private set; }
    public DeployableDecider(Directive defaultDirective, IEnumerable`1<KeyValuePair`2<Type, Directive>> pairs);
    public DeployableDecider(Directive defaultDirective, KeyValuePair`2[] pairs);
    [CompilerGeneratedAttribute]
public Directive get_DefaultDirective();
    [CompilerGeneratedAttribute]
private void set_DefaultDirective(Directive value);
    [CompilerGeneratedAttribute]
public KeyValuePair`2[] get_Pairs();
    [CompilerGeneratedAttribute]
private void set_Pairs(KeyValuePair`2[] value);
    public sealed virtual Directive Decide(Exception cause);
    public sealed virtual bool Equals(DeployableDecider other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Akka.Actor.Deployer : object {
    protected Config Default;
    private Settings _settings;
    private AtomicReference`1<WildcardIndex`1<Deploy>> _deployments;
    public Deployer(Settings settings);
    public Deploy Lookup(ActorPath path);
    public Deploy Lookup(IEnumerable`1<string> path);
    public void SetDeploy(Deploy deploy);
    public virtual Deploy ParseConfig(string key, Config config);
    private RouterConfig CreateRouterConfig(string routerTypeAlias, Config deployment);
    [CompilerGeneratedAttribute]
private Deploy <.ctor>b__3_1(KeyValuePair`2<string, HoconValue> kvp);
    [CompilerGeneratedAttribute]
private void <SetDeploy>g__Add|6_0(IList`1<string> path, Deploy d);
}
public enum Akka.Actor.Directive : Enum {
    public int value__;
    public static Directive Resume;
    public static Directive Restart;
    public static Directive Escalate;
    public static Directive Stop;
}
[ExtensionAttribute]
public static class Akka.Actor.DirectiveExtensions : object {
    [ExtensionAttribute]
public static KeyValuePair`2<Type, Directive> When(Directive self);
}
public class Akka.Actor.Dsl.Act : ReceiveActor {
    [CompilerGeneratedAttribute]
private Action`2<Exception, IActorContext> <OnPostRestart>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<Exception, object, IActorContext> <OnPreRestart>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IActorContext> <OnPostStop>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IActorContext> <OnPreStart>k__BackingField;
    [CompilerGeneratedAttribute]
private SupervisorStrategy <Strategy>k__BackingField;
    public Action`2<Exception, IActorContext> OnPostRestart { get; public set; }
    public Action`3<Exception, object, IActorContext> OnPreRestart { get; public set; }
    public Action`1<IActorContext> OnPostStop { get; public set; }
    public Action`1<IActorContext> OnPreStart { get; public set; }
    public SupervisorStrategy Strategy { get; public set; }
    public Act(Action`1<IActorDsl> config);
    public Act(Action`2<IActorDsl, IActorContext> config);
    [CompilerGeneratedAttribute]
public sealed virtual Action`2<Exception, IActorContext> get_OnPostRestart();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OnPostRestart(Action`2<Exception, IActorContext> value);
    [CompilerGeneratedAttribute]
public sealed virtual Action`3<Exception, object, IActorContext> get_OnPreRestart();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OnPreRestart(Action`3<Exception, object, IActorContext> value);
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<IActorContext> get_OnPostStop();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OnPostStop(Action`1<IActorContext> value);
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<IActorContext> get_OnPreStart();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OnPreStart(Action`1<IActorContext> value);
    [CompilerGeneratedAttribute]
public sealed virtual SupervisorStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Strategy(SupervisorStrategy value);
    public sealed virtual void Receive(Action`2<T, IActorContext> handler);
    public sealed virtual void Receive(Action`2<T, IActorContext> handler, Predicate`1<T> shouldHandle);
    public sealed virtual void Receive(Predicate`1<T> shouldHandle, Action`2<T, IActorContext> handler);
    public sealed virtual void ReceiveAny(Action`2<object, IActorContext> handler);
    public sealed virtual void ReceiveAsync(Func`3<T, IActorContext, Task> handler, Predicate`1<T> shouldHandle);
    public sealed virtual void ReceiveAsync(Predicate`1<T> shouldHandle, Func`3<T, IActorContext, Task> handler);
    public sealed virtual void ReceiveAnyAsync(Func`3<object, IActorContext, Task> handler);
    public sealed virtual void DefaultPreRestart(Exception reason, object message);
    public sealed virtual void DefaultPostRestart(Exception reason);
    public sealed virtual void DefaultPreStart();
    public sealed virtual void DefaultPostStop();
    public sealed virtual void Become(Action`2<object, IActorContext> handler);
    public sealed virtual void BecomeStacked(Action`2<object, IActorContext> handler);
    private sealed virtual override void Akka.Actor.Dsl.IActorDsl.UnbecomeStacked();
    public sealed virtual IActorRef ActorOf(Action`1<IActorDsl> config, string name);
    protected virtual void PreRestart(Exception reason, object message);
    protected virtual void PostRestart(Exception reason);
    protected virtual void PostStop();
    protected virtual void PreStart();
    protected virtual SupervisorStrategy SupervisorStrategy();
}
[ExtensionAttribute]
public static class Akka.Actor.Dsl.ActExtensions : object {
    [ExtensionAttribute]
public static IActorRef ActorOf(IActorRefFactory factory, Action`1<IActorDsl> config, string name);
    [ExtensionAttribute]
public static IActorRef ActorOf(IActorRefFactory factory, Action`2<IActorDsl, IActorContext> config, string name);
}
public interface Akka.Actor.Dsl.IActorDsl {
    public Action`2<Exception, IActorContext> OnPostRestart { get; public set; }
    public Action`3<Exception, object, IActorContext> OnPreRestart { get; public set; }
    public Action`1<IActorContext> OnPostStop { get; public set; }
    public Action`1<IActorContext> OnPreStart { get; public set; }
    public SupervisorStrategy Strategy { get; public set; }
    public abstract virtual Action`2<Exception, IActorContext> get_OnPostRestart();
    public abstract virtual void set_OnPostRestart(Action`2<Exception, IActorContext> value);
    public abstract virtual Action`3<Exception, object, IActorContext> get_OnPreRestart();
    public abstract virtual void set_OnPreRestart(Action`3<Exception, object, IActorContext> value);
    public abstract virtual Action`1<IActorContext> get_OnPostStop();
    public abstract virtual void set_OnPostStop(Action`1<IActorContext> value);
    public abstract virtual Action`1<IActorContext> get_OnPreStart();
    public abstract virtual void set_OnPreStart(Action`1<IActorContext> value);
    public abstract virtual SupervisorStrategy get_Strategy();
    public abstract virtual void set_Strategy(SupervisorStrategy value);
    public abstract virtual void Receive(Action`2<T, IActorContext> handler);
    public abstract virtual void Receive(Predicate`1<T> shouldHandle, Action`2<T, IActorContext> handler);
    public abstract virtual void Receive(Action`2<T, IActorContext> handler, Predicate`1<T> shouldHandle);
    public abstract virtual void ReceiveAny(Action`2<object, IActorContext> handler);
    public abstract virtual void ReceiveAsync(Func`3<T, IActorContext, Task> handler, Predicate`1<T> shouldHandle);
    public abstract virtual void ReceiveAsync(Predicate`1<T> shouldHandle, Func`3<T, IActorContext, Task> handler);
    public abstract virtual void ReceiveAnyAsync(Func`3<object, IActorContext, Task> handler);
    public abstract virtual void DefaultPreRestart(Exception reason, object message);
    public abstract virtual void DefaultPostRestart(Exception reason);
    public abstract virtual void DefaultPreStart();
    public abstract virtual void DefaultPostStop();
    public abstract virtual void Become(Action`2<object, IActorContext> handler);
    public abstract virtual void BecomeStacked(Action`2<object, IActorContext> handler);
    public abstract virtual void UnbecomeStacked();
    public abstract virtual IActorRef ActorOf(Action`1<IActorDsl> config, string name);
}
internal class Akka.Actor.DynamicProps`1 : Props {
    private Func`1<TActor> invoker;
    public DynamicProps`1(Func`1<TActor> invoker);
    private DynamicProps`1(Props copy, Func`1<TActor> invoker);
    public virtual ActorBase NewActor();
    protected virtual Props Copy();
}
public class Akka.Actor.EmptyLocalActorRef : MinimalActorRef {
    private IActorRefProvider _provider;
    private ActorPath _path;
    private EventStream _eventStream;
    public ActorPath Path { get; }
    public IActorRefProvider Provider { get; }
    [ObsoleteAttribute("Use Context.Watch and Receive<Terminated> [1.1.0]")]
public bool IsTerminated { get; }
    public EmptyLocalActorRef(IActorRefProvider provider, ActorPath path, EventStream eventStream);
    public virtual ActorPath get_Path();
    public virtual IActorRefProvider get_Provider();
    public virtual bool get_IsTerminated();
    protected virtual void TellInternal(object message, IActorRef sender);
    public virtual void SendSystemMessage(ISystemMessage message);
    protected virtual bool SpecialHandle(object message, IActorRef sender);
    private void PublishSupressedDeadLetter(IDeadLetterSuppression msg, IActorRef sender);
}
[IsReadOnlyAttribute]
public class Akka.Actor.Envelope : ValueType {
    [CompilerGeneratedAttribute]
private IActorRef <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    public IActorRef Sender { get; }
    public object Message { get; }
    public Envelope(object message, IActorRef sender, ActorSystem system);
    public Envelope(object message, IActorRef sender);
    [CompilerGeneratedAttribute]
public IActorRef get_Sender();
    [CompilerGeneratedAttribute]
public object get_Message();
    public virtual string ToString();
}
public class Akka.Actor.EventStreamActor : ActorBase {
    protected virtual bool Receive(object message);
}
public abstract class Akka.Actor.ExtendedActorSystem : ActorSystem {
    public IActorRefProvider Provider { get; }
    public IInternalActorRef Guardian { get; }
    public IInternalActorRef LookupRoot { get; }
    public IInternalActorRef SystemGuardian { get; }
    public ActorProducerPipelineResolver ActorPipelineResolver { get; }
    public abstract virtual IActorRefProvider get_Provider();
    public abstract virtual IInternalActorRef get_Guardian();
    public abstract virtual IInternalActorRef get_LookupRoot();
    public abstract virtual IInternalActorRef get_SystemGuardian();
    public abstract virtual ActorProducerPipelineResolver get_ActorPipelineResolver();
    public abstract virtual IActorRef SystemActorOf(Props props, string name);
    public abstract virtual IActorRef SystemActorOf(string name);
    public abstract virtual void Abort();
    public abstract virtual string PrintTree();
}
public abstract class Akka.Actor.ExtensionIdProvider`1 : object {
    public Type ExtensionType { get; }
    public sealed virtual T Apply(ActorSystem system);
    private sealed virtual override object Akka.Actor.IExtensionId.Get(ActorSystem system);
    private sealed virtual override object Akka.Actor.IExtensionId.CreateExtension(ExtendedActorSystem system);
    public sealed virtual Type get_ExtensionType();
    private sealed virtual override object Akka.Actor.IExtensionId.Apply(ActorSystem system);
    public sealed virtual T Get(ActorSystem system);
    public abstract virtual T CreateExtension(ExtendedActorSystem system);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ObsoleteAttribute("Use Akka.Actor.Status.Failure")]
public class Akka.Actor.Failure : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    public Exception Exception { get; public set; }
    public DateTime Timestamp { get; public set; }
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
}
[ObsoleteAttribute("Use List of Akka.Actor.Status.Failure")]
public class Akka.Actor.Failures : object {
    [CompilerGeneratedAttribute]
private List`1<Failure> <Entries>k__BackingField;
    public List`1<Failure> Entries { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<Failure> get_Entries();
    [CompilerGeneratedAttribute]
private void set_Entries(List`1<Failure> value);
}
public abstract class Akka.Actor.FSM`2 : FSMBase {
    private ILoggingAdapter _log;
    [CompilerGeneratedAttribute]
private ListenerSupport <Listeners>k__BackingField;
    protected bool DebugEvent;
    private State`2<TState, TData> _currentState;
    private ICancelable _timeoutFuture;
    private State`2<TState, TData> _nextState;
    private long _generation;
    private IDictionary`2<string, Timer> _timers;
    private AtomicCounter _timerGen;
    private Dictionary`2<TState, StateFunction<TState, TData>> _stateFunctions;
    private Dictionary`2<TState, Nullable`1<TimeSpan>> _stateTimeouts;
    private StateFunction<TState, TData> _handleEvent;
    private Action`1<StopEvent`2<TState, TData>> _terminateEvent;
    private IList`1<TransitionHandler<TState, TData>> _transitionEvent;
    private bool Akka.Actor.Internal.IInternalSupportsTestFSMRef<TState,TData>.IsStateTimerActive { get; }
    public TState StateName { get; }
    public TData StateData { get; }
    public TData NextStateData { get; }
    public ListenerSupport Listeners { get; }
    private StateFunction<TState, TData> HandleEventDefault { get; }
    private StateFunction<TState, TData> HandleEvent { get; private set; }
    public void When(TState stateName, StateFunction<TState, TData> func, Nullable`1<TimeSpan> timeout);
    public void StartWith(TState stateName, TData stateData, Nullable`1<TimeSpan> timeout);
    public State`2<TState, TData> GoTo(TState nextStateName);
    [ObsoleteAttribute("This method is obsoleted. Use GoTo(nextStateName).Using(newStateData) [1.2.0]")]
public State`2<TState, TData> GoTo(TState nextStateName, TData stateData);
    public State`2<TState, TData> Stay();
    public State`2<TState, TData> Stop();
    public State`2<TState, TData> Stop(Reason reason);
    public State`2<TState, TData> Stop(Reason reason, TData stateData);
    public TransformHelper<TState, TData> Transform(StateFunction<TState, TData> func);
    public void SetTimer(string name, object msg, TimeSpan timeout, bool repeat);
    public void CancelTimer(string name);
    public bool IsTimerActive(string name);
    public void SetStateTimeout(TState state, Nullable`1<TimeSpan> timeout);
    private sealed virtual override bool Akka.Actor.Internal.IInternalSupportsTestFSMRef<TState,TData>.get_IsStateTimerActive();
    public void OnTransition(TransitionHandler<TState, TData> transitionHandler);
    public void OnTermination(Action`1<StopEvent`2<TState, TData>> terminationHandler);
    public void WhenUnhandled(StateFunction<TState, TData> stateFunction);
    public void Initialize();
    public TState get_StateName();
    public TData get_StateData();
    public TData get_NextStateData();
    [CompilerGeneratedAttribute]
public sealed virtual ListenerSupport get_Listeners();
    private void Register(TState name, StateFunction<TState, TData> function, Nullable`1<TimeSpan> timeout);
    private StateFunction<TState, TData> get_HandleEventDefault();
    private StateFunction<TState, TData> get_HandleEvent();
    private void set_HandleEvent(StateFunction<TState, TData> value);
    private void HandleTransition(TState previous, TState next);
    private static StateFunction<TState, TData> OrElse(StateFunction<TState, TData> original, StateFunction<TState, TData> fallback);
    protected virtual bool Receive(object message);
    private void ProcessMsg(object any, object source);
    private void ProcessEvent(Event`1<TData> fsmEvent, object source);
    private static string GetSourceString(object source);
    private sealed virtual override void Akka.Actor.Internal.IInternalSupportsTestFSMRef<TState,TData>.ApplyState(State`2<TState, TData> upcomingState);
    private void ApplyState(State`2<TState, TData> nextState);
    private void MakeTransition(State`2<TState, TData> nextState);
    private void Terminate(State`2<TState, TData> upcomingState);
    protected virtual void PostStop();
    protected virtual void LogTermination(Reason reason);
    [CompilerGeneratedAttribute]
private State`2<TState, TData> <get_HandleEventDefault>b__44_0(Event`1<TData> event);
}
public abstract class Akka.Actor.FSMBase : ActorBase {
}
internal class Akka.Actor.FullActorState : object {
    private Dictionary`2<IActorRef, Option`1<object>> _watching;
    private HashSet`1<IActorRef> _watchedBy;
    private Dictionary`2<IActorRef, Option`1<object>> _terminatedQueue;
    private Stack`1<Receive> _behaviorStack;
    public sealed virtual IActorState RemoveWatching(IActorRef actor);
    public sealed virtual IActorState RemoveWatchedBy(IActorRef actor);
    public sealed virtual ValueTuple`2<IActorState, Option`1<object>> RemoveTerminated(IActorRef actor);
    public sealed virtual IActorState AddWatching(IActorRef actor, Option`1<object> msg);
    public sealed virtual IActorState AddWatchedBy(IActorRef actor);
    public sealed virtual IActorState AddTerminated(IActorRef actor, Option`1<object> customMessage);
    public sealed virtual bool ContainsWatching(IActorRef actor);
    public sealed virtual bool TryGetWatching(IActorRef actor, Option`1& msg);
    public sealed virtual bool ContainsWatchedBy(IActorRef actor);
    public sealed virtual bool ContainsTerminated(IActorRef actor);
    public sealed virtual IEnumerable`1<IActorRef> GetWatching();
    public sealed virtual IEnumerable`1<IActorRef> GetWatchedBy();
    public sealed virtual IEnumerable`1<IActorRef> GetTerminated();
    public sealed virtual IActorState ClearWatching();
    public sealed virtual IActorState ClearWatchedBy();
    public sealed virtual IActorState ClearTerminated();
    public sealed virtual IActorState Become(Receive receive);
    public sealed virtual IActorState BecomeStacked(Receive receive);
    public sealed virtual IActorState UnbecomeStacked();
    public sealed virtual IActorState ClearBehaviorStack();
    public sealed virtual Receive GetCurrentBehavior();
}
internal class Akka.Actor.FunctionRef : MinimalActorRef {
    private EventStream _eventStream;
    private Action`2<IActorRef, object> _tell;
    private ImmutableHashSet`1<IActorRef> _watching;
    private ImmutableHashSet`1<IActorRef> _watchedBy;
    [CompilerGeneratedAttribute]
private ActorPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRefProvider <Provider>k__BackingField;
    public ActorPath Path { get; }
    public IActorRefProvider Provider { get; }
    public bool IsTerminated { get; }
    public FunctionRef(ActorPath path, IActorRefProvider provider, EventStream eventStream, Action`2<IActorRef, object> tell);
    [CompilerGeneratedAttribute]
public virtual ActorPath get_Path();
    [CompilerGeneratedAttribute]
public virtual IActorRefProvider get_Provider();
    public virtual bool get_IsTerminated();
    public void Watch(IActorRef actorRef);
    public void Unwatch(IActorRef actorRef);
    public bool IsWatching(IActorRef actorRef);
    protected virtual void TellInternal(object message, IActorRef sender);
    public virtual void SendSystemMessage(ISystemMessage message);
    private void SendTerminated();
    private void SendTerminated(IActorRef watcher);
    private void UnwatchWatched(IActorRef watched);
    public virtual void Stop();
    private void AddWatcher(IInternalActorRef watchee, IInternalActorRef watcher);
    private void RemoveWatcher(IInternalActorRef watchee, IInternalActorRef watcher);
    private void Publish(LogEvent e);
}
public class Akka.Actor.FutureActorRef`1 : MinimalActorRef {
    private TaskCompletionSource`1<T> _result;
    private ActorPath _path;
    private IActorRefProvider _provider;
    public ActorPath Path { get; }
    public IActorRefProvider Provider { get; }
    public FutureActorRef`1(TaskCompletionSource`1<T> result, ActorPath path, IActorRefProvider provider);
    public virtual ActorPath get_Path();
    public virtual IActorRefProvider get_Provider();
    protected virtual void TellInternal(object message, IActorRef sender);
    public virtual void DeliverAsk(object message, ICanTell destination);
}
[ExtensionAttribute]
public static class Akka.Actor.Futures : object {
    [ExtensionAttribute]
public static Task`1<object> Ask(ICanTell self, object message, Nullable`1<TimeSpan> timeout);
    [ExtensionAttribute]
public static Task`1<object> Ask(ICanTell self, object message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<object> Ask(ICanTell self, object message, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> Ask(ICanTell self, object message, Nullable`1<TimeSpan> timeout);
    [ExtensionAttribute]
public static Task`1<T> Ask(ICanTell self, object message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> Ask(ICanTell self, object message, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> Ask(ICanTell self, Func`2<IActorRef, object> messageFactory, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    internal static IActorRefProvider ResolveProvider(ICanTell self);
}
internal class Akka.Actor.Get : ValueType {
    [CompilerGeneratedAttribute]
private TimeSpan <Deadline>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <Client>k__BackingField;
    public TimeSpan Deadline { get; private set; }
    public IActorRef Client { get; private set; }
    public Get(TimeSpan deadline, IActorRef client);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_Deadline();
    [CompilerGeneratedAttribute]
private void set_Deadline(TimeSpan value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IActorRef get_Client();
    [CompilerGeneratedAttribute]
private void set_Client(IActorRef value);
    public sealed virtual IQuery WithClient(IActorRef client);
}
[ExtensionAttribute]
public static class Akka.Actor.GracefulStopSupport : object {
    [ExtensionAttribute]
public static Task`1<bool> GracefulStop(IActorRef target, TimeSpan timeout);
    [AsyncStateMachineAttribute("Akka.Actor.GracefulStopSupport/<GracefulStop>d__1")]
[ExtensionAttribute]
public static Task`1<bool> GracefulStop(IActorRef target, TimeSpan timeout, object stopMessage);
}
public class Akka.Actor.GuardianActor : ActorBase {
    protected virtual bool Receive(object message);
    protected virtual void PreStart();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Akka.Actor.HashedWheelTimerScheduler : SchedulerBase {
    private TimeSpan _shutdownTimeout;
    private TimeSpan _timerDuration;
    private long _tickDuration;
    private long _startTime;
    private long _tick;
    private int _mask;
    private CountdownEvent _workerInitialized;
    private ConcurrentQueue`1<SchedulerRegistration> _registrations;
    private Bucket[] _wheel;
    private static int WORKER_STATE_INIT;
    private static int WORKER_STATE_STARTED;
    private static int WORKER_STATE_SHUTDOWN;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _workerState;
    private HashSet`1<SchedulerRegistration> _unprocessedRegistrations;
    private HashSet`1<SchedulerRegistration> _rescheduleRegistrations;
    [NullableAttribute("2")]
private Thread _worker;
    private TaskCompletionSource`1<IEnumerable`1<SchedulerRegistration>> _stopped;
    private static Task`1<IEnumerable`1<SchedulerRegistration>> Completed;
    protected DateTimeOffset TimeNow { get; }
    protected DateTime DateTimeNow { get; }
    public TimeSpan MonotonicClock { get; }
    public TimeSpan HighResMonotonicClock { get; }
    private static HashedWheelTimerScheduler();
    public HashedWheelTimerScheduler(Config scheduler, ILoggingAdapter log);
    private static Bucket[] CreateWheel(int ticksPerWheel, ILoggingAdapter log);
    private static int NormalizeTicksPerWheel(int ticksPerWheel);
    private void Start();
    private void Run();
    private void ProcessReschedule();
    private long WaitForNextTick();
    private void TransferRegistrationsToBuckets();
    private void PlaceInBucket(SchedulerRegistration reg);
    protected virtual DateTimeOffset get_TimeNow();
    protected virtual DateTime get_DateTimeNow();
    public virtual TimeSpan get_MonotonicClock();
    public virtual TimeSpan get_HighResMonotonicClock();
    protected virtual void InternalScheduleTellOnce(TimeSpan delay, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    private void InternalSchedule(TimeSpan delay, TimeSpan interval, IRunnable action, ICancelable cancelable);
    protected virtual void InternalScheduleTellRepeatedly(TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    protected virtual void InternalScheduleOnce(TimeSpan delay, Action action, ICancelable cancelable);
    protected virtual void InternalScheduleOnce(TimeSpan delay, IRunnable action, ICancelable cancelable);
    protected virtual void InternalScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action, ICancelable cancelable);
    protected virtual void InternalScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, IRunnable action, ICancelable cancelable);
    private Task`1<IEnumerable`1<SchedulerRegistration>> Stop();
    public sealed virtual void Dispose();
}
public interface Akka.Actor.IActionScheduler {
    public abstract virtual void ScheduleOnce(TimeSpan delay, Action action, ICancelable cancelable);
    public abstract virtual void ScheduleOnce(TimeSpan delay, Action action);
    public abstract virtual void ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action, ICancelable cancelable);
    public abstract virtual void ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action);
}
public interface Akka.Actor.IActorContext {
    public IActorRef Self { get; }
    public Props Props { get; }
    public MessageDispatcher Dispatcher { get; }
    public IActorRef Sender { get; }
    public ActorSystem System { get; }
    public IActorRef Parent { get; }
    public Nullable`1<TimeSpan> ReceiveTimeout { get; }
    public abstract virtual IActorRef get_Self();
    public abstract virtual Props get_Props();
    public abstract virtual MessageDispatcher get_Dispatcher();
    public abstract virtual IActorRef get_Sender();
    public abstract virtual ActorSystem get_System();
    public abstract virtual IActorRef get_Parent();
    public abstract virtual void Become(Receive receive);
    public abstract virtual void BecomeStacked(Receive receive);
    public abstract virtual void UnbecomeStacked();
    public abstract virtual IActorRef Child(string name);
    public abstract virtual IEnumerable`1<IActorRef> GetChildren();
    public abstract virtual void SetReceiveTimeout(Nullable`1<TimeSpan> timeout);
    public abstract virtual Nullable`1<TimeSpan> get_ReceiveTimeout();
    public abstract virtual void Stop(IActorRef child);
}
public interface Akka.Actor.IActorProducerPlugin {
    public abstract virtual bool CanBeAppliedTo(Type actorType);
    public abstract virtual void AfterIncarnated(ActorBase actor, IActorContext context);
    public abstract virtual void BeforeIncarnated(ActorBase actor, IActorContext context);
}
public interface Akka.Actor.IActorRef {
    public ActorPath Path { get; }
    public abstract virtual ActorPath get_Path();
}
public interface Akka.Actor.IActorRefFactory {
    public abstract virtual IActorRef ActorOf(Props props, string name);
    public abstract virtual ActorSelection ActorSelection(ActorPath actorPath);
    public abstract virtual ActorSelection ActorSelection(string actorPath);
}
public interface Akka.Actor.IActorRefProvider {
    public IInternalActorRef RootGuardian { get; }
    public LocalActorRef Guardian { get; }
    public LocalActorRef SystemGuardian { get; }
    public IActorRef DeadLetters { get; }
    public IActorRef IgnoreRef { get; }
    public ActorPath RootPath { get; }
    public Settings Settings { get; }
    public Deployer Deployer { get; }
    public IInternalActorRef TempContainer { get; }
    public Task TerminationTask { get; }
    public Address DefaultAddress { get; }
    [InternalApiAttribute]
public Information SerializationInformation { get; }
    public abstract virtual IInternalActorRef get_RootGuardian();
    public abstract virtual IActorRef RootGuardianAt(Address address);
    public abstract virtual LocalActorRef get_Guardian();
    public abstract virtual LocalActorRef get_SystemGuardian();
    public abstract virtual IActorRef get_DeadLetters();
    public abstract virtual IActorRef get_IgnoreRef();
    public abstract virtual ActorPath get_RootPath();
    public abstract virtual Settings get_Settings();
    public abstract virtual void Init(ActorSystemImpl system);
    public abstract virtual Deployer get_Deployer();
    public abstract virtual ActorPath TempPath();
    public abstract virtual IInternalActorRef get_TempContainer();
    public abstract virtual void RegisterTempActor(IInternalActorRef actorRef, ActorPath path);
    public abstract virtual void UnregisterTempActor(ActorPath path);
    [InternalApiAttribute]
public abstract virtual FutureActorRef`1<T> CreateFutureRef(TaskCompletionSource`1<T> tcs);
    public abstract virtual IInternalActorRef ActorOf(ActorSystemImpl system, Props props, IInternalActorRef supervisor, ActorPath path, bool systemService, Deploy deploy, bool lookupDeploy, bool async);
    public abstract virtual IActorRef ResolveActorRef(string path);
    public abstract virtual IActorRef ResolveActorRef(ActorPath actorPath);
    public abstract virtual Task get_TerminationTask();
    public abstract virtual Address GetExternalAddressFor(Address address);
    public abstract virtual Address get_DefaultAddress();
    public abstract virtual Information get_SerializationInformation();
}
[InternalApiAttribute]
public interface Akka.Actor.IActorRefScope {
    public bool IsLocal { get; }
    public abstract virtual bool get_IsLocal();
}
public interface Akka.Actor.IActorStash {
    public IStash Stash { get; public set; }
    public abstract virtual IStash get_Stash();
    public abstract virtual void set_Stash(IStash value);
}
internal interface Akka.Actor.IActorState {
    public abstract virtual IActorState RemoveWatching(IActorRef actor);
    public abstract virtual IActorState RemoveWatchedBy(IActorRef actor);
    public abstract virtual ValueTuple`2<IActorState, Option`1<object>> RemoveTerminated(IActorRef actor);
    public abstract virtual IActorState AddWatching(IActorRef actor, Option`1<object> message);
    public abstract virtual IActorState AddWatchedBy(IActorRef actor);
    public abstract virtual IActorState AddTerminated(IActorRef actor, Option`1<object> customMessage);
    public abstract virtual IActorState ClearWatching();
    public abstract virtual IActorState ClearWatchedBy();
    public abstract virtual IActorState ClearTerminated();
    public abstract virtual IActorState ClearBehaviorStack();
    public abstract virtual IActorState Become(Receive receive);
    public abstract virtual IActorState BecomeStacked(Receive receive);
    public abstract virtual IActorState UnbecomeStacked();
    public abstract virtual bool ContainsWatching(IActorRef actor);
    public abstract virtual bool TryGetWatching(IActorRef actor, Option`1& msg);
    public abstract virtual bool ContainsWatchedBy(IActorRef actor);
    public abstract virtual bool ContainsTerminated(IActorRef actor);
    public abstract virtual IEnumerable`1<IActorRef> GetWatching();
    public abstract virtual IEnumerable`1<IActorRef> GetWatchedBy();
    public abstract virtual IEnumerable`1<IActorRef> GetTerminated();
    public abstract virtual Receive GetCurrentBehavior();
}
public interface Akka.Actor.IActorTelemetryEvent {
    public IActorRef Subject { get; }
    public Type ActorType { get; }
    public abstract virtual IActorRef get_Subject();
    public abstract virtual Type get_ActorType();
}
public interface Akka.Actor.IAdvancedScheduler {
}
public interface Akka.Actor.IAutoReceivedMessage {
}
public interface Akka.Actor.ICancelable {
    public bool IsCancellationRequested { get; }
    public CancellationToken Token { get; }
    public abstract virtual void Cancel();
    public abstract virtual bool get_IsCancellationRequested();
    public abstract virtual CancellationToken get_Token();
    public abstract virtual void CancelAfter(TimeSpan delay);
    public abstract virtual void CancelAfter(int millisecondsDelay);
    public abstract virtual void Cancel(bool throwOnFirstException);
}
public interface Akka.Actor.ICanTell {
    public abstract virtual void Tell(object message, IActorRef sender);
}
public interface Akka.Actor.ICanWatch {
    public abstract virtual IActorRef Watch(IActorRef subject);
    public abstract virtual IActorRef WatchWith(IActorRef subject, object message);
    public abstract virtual IActorRef Unwatch(IActorRef subject);
}
[InternalApiAttribute]
public interface Akka.Actor.ICell {
    public IActorRef Self { get; }
    public ActorSystem System { get; }
    public ActorSystemImpl SystemImpl { get; }
    public IInternalActorRef Parent { get; }
    public bool IsLocal { get; }
    public Props Props { get; }
    public bool HasMessages { get; }
    public int NumberOfMessages { get; }
    public bool IsTerminated { get; }
    public IChildrenContainer ChildrenContainer { get; }
    public abstract virtual IActorRef get_Self();
    public abstract virtual ActorSystem get_System();
    public abstract virtual ActorSystemImpl get_SystemImpl();
    public abstract virtual void Start();
    public abstract virtual void Suspend();
    public abstract virtual void Resume(Exception causedByFailure);
    public abstract virtual void Restart(Exception cause);
    public abstract virtual void Stop();
    public abstract virtual IInternalActorRef get_Parent();
    public abstract virtual bool get_IsLocal();
    public abstract virtual Props get_Props();
    public abstract virtual bool get_HasMessages();
    public abstract virtual int get_NumberOfMessages();
    public abstract virtual bool get_IsTerminated();
    public abstract virtual void SendMessage(IActorRef sender, object message);
    [ObsoleteAttribute("Used ChildrenRefs instead [1.1.0]")]
public abstract virtual IEnumerable`1<IInternalActorRef> GetChildren();
    public abstract virtual IChildrenContainer get_ChildrenContainer();
    public abstract virtual IInternalActorRef GetSingleChild(string name);
    public abstract virtual IInternalActorRef GetChildByName(string name);
    public abstract virtual bool TryGetChildStatsByName(string name, IChildStats& child);
    public abstract virtual void SendSystemMessage(ISystemMessage message);
}
public interface Akka.Actor.IDateTimeOffsetNowTimeProvider {
}
public interface Akka.Actor.IDecider {
    public abstract virtual Directive Decide(Exception cause);
}
public class Akka.Actor.Identify : object {
    [CompilerGeneratedAttribute]
private object <MessageId>k__BackingField;
    public object MessageId { get; }
    public Identify(object messageId);
    [CompilerGeneratedAttribute]
public object get_MessageId();
    private bool Equals(Identify other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface Akka.Actor.IExtension {
}
public interface Akka.Actor.IExtensionId {
    public Type ExtensionType { get; }
    public abstract virtual object Apply(ActorSystem system);
    public abstract virtual object Get(ActorSystem system);
    public abstract virtual object CreateExtension(ExtendedActorSystem system);
    public abstract virtual Type get_ExtensionType();
}
public interface Akka.Actor.IExtensionId`1 {
    public abstract virtual T Apply(ActorSystem system);
    public abstract virtual T Get(ActorSystem system);
    public abstract virtual T CreateExtension(ExtendedActorSystem system);
}
internal class Akka.Actor.IgnoreActorRef : MinimalActorRef {
    private static IgnoreActorRefSurrogate SurrogateInstance;
    private static string fakeSystemName;
    private static ActorPath path;
    private static string pathString;
    [CompilerGeneratedAttribute]
private IActorRefProvider <Provider>k__BackingField;
    public static ActorPath StaticPath { get; }
    public ActorPath Path { get; }
    public IActorRefProvider Provider { get; }
    public IgnoreActorRef(IActorRefProvider provider);
    private static IgnoreActorRef();
    public static ActorPath get_StaticPath();
    public virtual ActorPath get_Path();
    [CompilerGeneratedAttribute]
public virtual IActorRefProvider get_Provider();
    public static bool IsIgnoreRefPath(string otherPath);
    public static bool IsIgnoreRefPath(ActorPath otherPath);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public interface Akka.Actor.IInboxable {
    public IActorRef Receiver { get; }
    public abstract virtual IActorRef get_Receiver();
    public abstract virtual object Receive();
    public abstract virtual object Receive(TimeSpan timeout);
    public abstract virtual Task`1<object> ReceiveAsync();
    public abstract virtual Task`1<object> ReceiveAsync(TimeSpan timeout);
    public abstract virtual object ReceiveWhere(Predicate`1<object> predicate);
    public abstract virtual object ReceiveWhere(Predicate`1<object> predicate, TimeSpan timeout);
    public abstract virtual void Send(IActorRef target, object message);
}
public interface Akka.Actor.IIndirectActorProducer {
    public Type ActorType { get; }
    public abstract virtual Type get_ActorType();
    public abstract virtual ActorBase Produce();
    public abstract virtual void Release(ActorBase actor);
}
public interface Akka.Actor.IInternalActor {
    public IActorContext ActorContext { get; }
    public abstract virtual IActorContext get_ActorContext();
}
[InternalApiAttribute]
public interface Akka.Actor.IInternalActorRef {
    public IInternalActorRef Parent { get; }
    public IActorRefProvider Provider { get; }
    [ObsoleteAttribute("Use Context.Watch and Receive<Terminated> [1.1.0]")]
public bool IsTerminated { get; }
    public abstract virtual IInternalActorRef get_Parent();
    public abstract virtual IActorRefProvider get_Provider();
    public abstract virtual bool get_IsTerminated();
    public abstract virtual IActorRef GetChild(IReadOnlyList`1<string> name);
    public abstract virtual void Resume(Exception causedByFailure);
    public abstract virtual void Start();
    public abstract virtual void Stop();
    public abstract virtual void Restart(Exception cause);
    public abstract virtual void Suspend();
    [ObsoleteAttribute("Use SendSystemMessage(message) [1.1.0]")]
public abstract virtual void SendSystemMessage(ISystemMessage message, IActorRef sender);
    public abstract virtual void SendSystemMessage(ISystemMessage message);
}
public class Akka.Actor.IllegalActorNameException : AkkaException {
    public IllegalActorNameException(string message);
    protected IllegalActorNameException(SerializationInfo info, StreamingContext context);
}
public class Akka.Actor.IllegalActorStateException : AkkaException {
    public IllegalActorStateException(string message);
    protected IllegalActorStateException(SerializationInfo info, StreamingContext context);
}
internal interface Akka.Actor.ILocalRef {
}
public interface Akka.Actor.ILoggingFSM {
}
public interface Akka.Actor.ILogReceive {
}
public class Akka.Actor.Inbox : object {
    private static int _inboxNr;
    private ActorSystem _system;
    private TimeSpan _defaultTimeout;
    [CompilerGeneratedAttribute]
private IActorRef <Receiver>k__BackingField;
    public IActorRef Receiver { get; private set; }
    private Inbox(TimeSpan defaultTimeout, IActorRef receiver, ActorSystem system);
    public static Inbox Create(ActorSystem system);
    [CompilerGeneratedAttribute]
public sealed virtual IActorRef get_Receiver();
    [CompilerGeneratedAttribute]
private void set_Receiver(IActorRef value);
    public sealed virtual IActorRef Watch(IActorRef subject);
    public sealed virtual IActorRef WatchWith(IActorRef subject, object message);
    public sealed virtual IActorRef Unwatch(IActorRef subject);
    public sealed virtual void Send(IActorRef actorRef, object message);
    public sealed virtual object Receive();
    public sealed virtual object Receive(TimeSpan timeout);
    public sealed virtual object ReceiveWhere(Predicate`1<object> predicate);
    public sealed virtual object ReceiveWhere(Predicate`1<object> predicate, TimeSpan timeout);
    public sealed virtual Task`1<object> ReceiveAsync();
    public sealed virtual Task`1<object> ReceiveAsync(TimeSpan timeout);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private object AwaitResult(Task`1<object> task, TimeSpan timeout);
}
internal class Akka.Actor.InboxActor : ActorBase {
    private InboxQueue`1<object> _messages;
    private InboxQueue`1<IQuery> _clients;
    private ISet`1<IQuery> _clientsByTimeout;
    private bool _printedWarning;
    private object _currentMessage;
    private Nullable`1<Select> _currentSelect;
    private Nullable`1<ValueTuple`2<TimeSpan, ICancelable>> _currentDeadline;
    private int _size;
    private ILoggingAdapter _log;
    private IQuery[] _matched;
    public InboxActor(int size);
    private void EnqueueQuery(IQuery query);
    private void EnqueueMessage(object message);
    private bool ClientPredicate(IQuery query);
    private bool MessagePredicate(object message);
    protected virtual bool Receive(object message);
}
internal class Akka.Actor.InboxQueue`1 : object {
    private LinkedList`1<T> _inner;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public int RemoveAll(Predicate`1<T> predicate);
    public void Enqueue(T item);
    public T Dequeue();
    public T DequeueFirstOrDefault(Predicate`1<T> predicate);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
public interface Akka.Actor.INoSerializationVerificationNeeded {
}
public interface Akka.Actor.INotInfluenceReceiveTimeout {
}
public abstract class Akka.Actor.Internal.AbstractStash : object {
    private LinkedList`1<Envelope> _theStash;
    private ActorCell _actorCell;
    private IDequeBasedMessageQueueSemantics _mailbox;
    private int _currentEnvelopeId;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool NonEmpty { get; }
    public bool IsFull { get; }
    public int Capacity { get; }
    protected AbstractStash(IActorContext context);
    public sealed virtual void Stash();
    public sealed virtual void Unstash();
    public sealed virtual void UnstashAll();
    public sealed virtual void UnstashAll(Func`2<Envelope, bool> filterPredicate);
    public sealed virtual IEnumerable`1<Envelope> ClearStash();
    public sealed virtual void Prepend(IEnumerable`1<Envelope> envelopes);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool get_NonEmpty();
    public sealed virtual bool get_IsFull();
    [CompilerGeneratedAttribute]
public virtual int get_Capacity();
    private void EnqueueFirst(Envelope msg);
}
public class Akka.Actor.Internal.ActorSystemImpl : ExtendedActorSystem {
    private IActorRef _logDeadLetterListener;
    private ConcurrentDictionary`2<Type, Lazy`1<object>> _extensions;
    private ILoggingAdapter _log;
    private IActorRefProvider _provider;
    private Settings _settings;
    private string _name;
    private Serialization _serialization;
    private EventStream _eventStream;
    private Dispatchers _dispatchers;
    private Mailboxes _mailboxes;
    private IScheduler _scheduler;
    private ActorProducerPipelineResolver _actorProducerPipelineResolver;
    private TerminationCallbacks _terminationCallbacks;
    [CompilerGeneratedAttribute]
private Option`1<Props> <GuardianProps>k__BackingField;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) Aborting;
    public IActorRefProvider Provider { get; }
    public Settings Settings { get; }
    public string Name { get; }
    public Serialization Serialization { get; }
    public EventStream EventStream { get; }
    public IActorRef DeadLetters { get; }
    public IActorRef IgnoreRef { get; }
    public Dispatchers Dispatchers { get; }
    public Mailboxes Mailboxes { get; }
    public IScheduler Scheduler { get; }
    public ILoggingAdapter Log { get; }
    public ActorProducerPipelineResolver ActorPipelineResolver { get; }
    public IInternalActorRef Guardian { get; }
    public IInternalActorRef LookupRoot { get; }
    public IInternalActorRef SystemGuardian { get; }
    public Option`1<Props> GuardianProps { get; }
    public Task WhenTerminated { get; }
    public ActorSystemImpl(string name);
    public ActorSystemImpl(string name, Config config, ActorSystemSetup setup, Nullable`1<Option`1<Props>> guardianProps);
    public virtual IActorRefProvider get_Provider();
    public virtual Settings get_Settings();
    public virtual string get_Name();
    public virtual Serialization get_Serialization();
    public virtual EventStream get_EventStream();
    public virtual IActorRef get_DeadLetters();
    public virtual IActorRef get_IgnoreRef();
    public virtual Dispatchers get_Dispatchers();
    public virtual Mailboxes get_Mailboxes();
    public virtual IScheduler get_Scheduler();
    public virtual ILoggingAdapter get_Log();
    public virtual ActorProducerPipelineResolver get_ActorPipelineResolver();
    public virtual IInternalActorRef get_Guardian();
    public virtual IInternalActorRef get_LookupRoot();
    public virtual IInternalActorRef get_SystemGuardian();
    [CompilerGeneratedAttribute]
public Option`1<Props> get_GuardianProps();
    public virtual IActorRef SystemActorOf(Props props, string name);
    public virtual IActorRef SystemActorOf(string name);
    public virtual void Abort();
    public void Start();
    private void WarnIfJsonIsDefaultSerializer();
    public virtual IActorRef ActorOf(Props props, string name);
    public virtual ActorSelection ActorSelection(ActorPath actorPath);
    public virtual ActorSelection ActorSelection(string actorPath);
    private void ConfigureScheduler();
    private void StopScheduler();
    private void LoadExtensions();
    private void ConfigureExtensions(IEnumerable`1<IExtensionId> extensionIdProviders);
    public virtual object RegisterExtension(IExtensionId extension);
    public virtual object GetExtension(IExtensionId extensionId);
    public virtual bool TryGetExtension(Type extensionType, Object& extension);
    public virtual bool TryGetExtension(T& extension);
    public virtual T GetExtension();
    public virtual bool HasExtension(Type type);
    public virtual bool HasExtension();
    private void ConfigureSettings(Config config, ActorSystemSetup setup);
    private void ConfigureEventStream();
    private void ConfigureSerialization();
    private sealed virtual override void Akka.Actor.Internal.ISupportSerializationConfigReload.ReloadSerialization();
    private void ConfigureMailboxes();
    private void ConfigureProvider();
    private void ConfigureLoggers();
    private void ConfigureDispatchers();
    private void ConfigureActorProducerPipeline();
    private void ConfigureTerminationCallbacks();
    public virtual void RegisterOnTermination(Action code);
    public virtual Task Terminate();
    internal virtual Task FinalTerminate();
    public virtual Task get_WhenTerminated();
    public virtual void Stop(IActorRef actor);
    public virtual string ToString();
    public virtual string PrintTree();
    [CompilerGeneratedAttribute]
private ILoggingAdapter <ConfigureActorProducerPipeline>b__76_0();
    [CompilerGeneratedAttribute]
internal static string <PrintTree>g__PrintNode|85_0(IActorRef node, string indent);
}
public class Akka.Actor.Internal.BoundedStashImpl : AbstractStash {
    public BoundedStashImpl(IActorContext context);
}
public class Akka.Actor.Internal.ChildNameReserved : object {
    [CompilerGeneratedAttribute]
private static ChildNameReserved <Instance>k__BackingField;
    public static ChildNameReserved Instance { get; }
    private static ChildNameReserved();
    [CompilerGeneratedAttribute]
public static ChildNameReserved get_Instance();
    public virtual string ToString();
}
public abstract class Akka.Actor.Internal.ChildrenContainerBase : object {
    private IImmutableDictionary`2<string, IChildStats> _children;
    public bool IsTerminating { get; }
    public bool IsNormal { get; }
    public IReadOnlyCollection`1<IInternalActorRef> Children { get; }
    public IReadOnlyCollection`1<ChildRestartStats> Stats { get; }
    protected IImmutableDictionary`2<string, IChildStats> InternalChildren { get; }
    protected ChildrenContainerBase(IImmutableDictionary`2<string, IChildStats> children);
    public virtual bool get_IsTerminating();
    public virtual bool get_IsNormal();
    public abstract virtual IChildrenContainer Add(string name, ChildRestartStats stats);
    public abstract virtual IChildrenContainer Remove(IActorRef child);
    public abstract virtual IChildrenContainer Reserve(string name);
    public abstract virtual IChildrenContainer ShallDie(IActorRef actor);
    public abstract virtual IChildrenContainer Unreserve(string name);
    public sealed virtual IReadOnlyCollection`1<IInternalActorRef> get_Children();
    public sealed virtual IReadOnlyCollection`1<ChildRestartStats> get_Stats();
    protected IImmutableDictionary`2<string, IChildStats> get_InternalChildren();
    public sealed virtual bool TryGetByName(string name, IChildStats& stats);
    public sealed virtual bool TryGetByRef(IActorRef actor, ChildRestartStats& childRestartStats);
    public sealed virtual bool Contains(IActorRef actor);
    protected void ChildStatsAppender(StringBuilder sb, KeyValuePair`2<string, IChildStats> kvp, int index);
}
public class Akka.Actor.Internal.ChildRestartStats : object {
    private IInternalActorRef _child;
    private UInt32 _maxNrOfRetriesCount;
    private long _restartTimeWindowStartTicks;
    public long Uid { get; }
    public IInternalActorRef Child { get; }
    public UInt32 MaxNrOfRetriesCount { get; }
    public long RestartTimeWindowStartTicks { get; }
    public ChildRestartStats(IInternalActorRef child, UInt32 maxNrOfRetriesCount, long restartTimeWindowStartTicks);
    public long get_Uid();
    public IInternalActorRef get_Child();
    public UInt32 get_MaxNrOfRetriesCount();
    public long get_RestartTimeWindowStartTicks();
    public bool RequestRestartPermission(int maxNrOfRetries, int withinTimeMilliseconds);
    private bool RetriesInWindowOkay(int retries, int windowInMilliseconds);
}
public class Akka.Actor.Internal.EmptyChildrenContainer : object {
    private static ImmutableDictionary`2<string, IChildStats> _emptyStats;
    [CompilerGeneratedAttribute]
private static IChildrenContainer <Instance>k__BackingField;
    public static IChildrenContainer Instance { get; }
    public IReadOnlyCollection`1<IInternalActorRef> Children { get; }
    public IReadOnlyCollection`1<ChildRestartStats> Stats { get; }
    public bool IsTerminating { get; }
    public bool IsNormal { get; }
    private static EmptyChildrenContainer();
    [CompilerGeneratedAttribute]
public static IChildrenContainer get_Instance();
    public virtual IChildrenContainer Add(string name, ChildRestartStats stats);
    public sealed virtual IChildrenContainer Remove(IActorRef child);
    public sealed virtual bool TryGetByName(string name, IChildStats& stats);
    public sealed virtual bool TryGetByRef(IActorRef actor, ChildRestartStats& childRestartStats);
    public sealed virtual bool Contains(IActorRef actor);
    public sealed virtual IReadOnlyCollection`1<IInternalActorRef> get_Children();
    public sealed virtual IReadOnlyCollection`1<ChildRestartStats> get_Stats();
    public sealed virtual IChildrenContainer ShallDie(IActorRef actor);
    public virtual IChildrenContainer Reserve(string name);
    public sealed virtual IChildrenContainer Unreserve(string name);
    public virtual string ToString();
    public virtual bool get_IsTerminating();
    public virtual bool get_IsNormal();
}
public interface Akka.Actor.Internal.IChildrenContainer {
    public IReadOnlyCollection`1<IInternalActorRef> Children { get; }
    public IReadOnlyCollection`1<ChildRestartStats> Stats { get; }
    public bool IsTerminating { get; }
    public bool IsNormal { get; }
    public abstract virtual IChildrenContainer Add(string name, ChildRestartStats stats);
    public abstract virtual IChildrenContainer Remove(IActorRef child);
    public abstract virtual bool TryGetByName(string name, IChildStats& stats);
    public abstract virtual bool TryGetByRef(IActorRef actor, ChildRestartStats& stats);
    public abstract virtual IReadOnlyCollection`1<IInternalActorRef> get_Children();
    public abstract virtual IReadOnlyCollection`1<ChildRestartStats> get_Stats();
    public abstract virtual IChildrenContainer ShallDie(IActorRef actor);
    public abstract virtual IChildrenContainer Reserve(string name);
    public abstract virtual IChildrenContainer Unreserve(string name);
    public abstract virtual bool get_IsTerminating();
    public abstract virtual bool get_IsNormal();
    public abstract virtual bool Contains(IActorRef actor);
}
public interface Akka.Actor.Internal.IChildStats {
}
public interface Akka.Actor.Internal.IInitializableActor {
    public abstract virtual void Init();
}
[InternalApiAttribute]
public interface Akka.Actor.Internal.IInternalSupportsTestFSMRef`2 {
    public bool IsStateTimerActive { get; }
    public abstract virtual void ApplyState(State`2<TState, TData> upcomingState);
    public abstract virtual bool get_IsStateTimerActive();
}
[InternalApiAttribute]
public class Akka.Actor.Internal.InternalActivateFsmLogging : object {
    [CompilerGeneratedAttribute]
private static InternalActivateFsmLogging <Instance>k__BackingField;
    public static InternalActivateFsmLogging Instance { get; }
    private static InternalActivateFsmLogging();
    [CompilerGeneratedAttribute]
public static InternalActivateFsmLogging get_Instance();
}
public static class Akka.Actor.Internal.InternalCurrentActorCellKeeper : object {
    [ThreadStaticAttribute]
private static ActorCell _current;
    public static ActorCell Current { get; public set; }
    public static ActorCell get_Current();
    public static void set_Current(ActorCell value);
}
internal interface Akka.Actor.Internal.ISupportSerializationConfigReload {
    public abstract virtual void ReloadSerialization();
}
public class Akka.Actor.Internal.NormalChildrenContainer : ChildrenContainerBase {
    private NormalChildrenContainer(IImmutableDictionary`2<string, IChildStats> children);
    public static IChildrenContainer Create(IImmutableDictionary`2<string, IChildStats> children);
    public virtual IChildrenContainer Add(string name, ChildRestartStats stats);
    public virtual IChildrenContainer Remove(IActorRef child);
    public virtual IChildrenContainer ShallDie(IActorRef actor);
    public virtual IChildrenContainer Reserve(string name);
    public virtual IChildrenContainer Unreserve(string name);
    public virtual string ToString();
}
public abstract class Akka.Actor.Internal.SuspendReason : object {
}
public class Akka.Actor.Internal.TerminatedChildrenContainer : EmptyChildrenContainer {
    [CompilerGeneratedAttribute]
private static IChildrenContainer <Instance>k__BackingField;
    public static IChildrenContainer Instance { get; }
    public bool IsTerminating { get; }
    public bool IsNormal { get; }
    private static TerminatedChildrenContainer();
    [CompilerGeneratedAttribute]
public static IChildrenContainer get_Instance();
    public virtual IChildrenContainer Add(string name, ChildRestartStats stats);
    public virtual IChildrenContainer Reserve(string name);
    public virtual bool get_IsTerminating();
    public virtual bool get_IsNormal();
    public virtual string ToString();
}
public class Akka.Actor.Internal.TerminatingChildrenContainer : ChildrenContainerBase {
    private ImmutableHashSet`1<IActorRef> _toDie;
    private SuspendReason _reason;
    public ImmutableHashSet`1<IActorRef> ToDie { get; }
    public SuspendReason Reason { get; }
    public bool IsTerminating { get; }
    public bool IsNormal { get; }
    public TerminatingChildrenContainer(IImmutableDictionary`2<string, IChildStats> children, IActorRef toDie, SuspendReason reason);
    public TerminatingChildrenContainer(IImmutableDictionary`2<string, IChildStats> children, ImmutableHashSet`1<IActorRef> toDie, SuspendReason reason);
    public ImmutableHashSet`1<IActorRef> get_ToDie();
    public SuspendReason get_Reason();
    public virtual IChildrenContainer Add(string name, ChildRestartStats stats);
    public virtual IChildrenContainer Remove(IActorRef child);
    public virtual IChildrenContainer ShallDie(IActorRef actor);
    public virtual IChildrenContainer Reserve(string name);
    public virtual IChildrenContainer Unreserve(string name);
    public virtual bool get_IsTerminating();
    public virtual bool get_IsNormal();
    public virtual string ToString();
    public IChildrenContainer CreateCopyWithReason(SuspendReason reason);
}
internal class Akka.Actor.Internal.TerminationCallbacks : object {
    private Task _terminationTask;
    private AtomicReference`1<Task> _atomicRef;
    public Task TerminationTask { get; }
    public TerminationCallbacks(Task upStreamTerminated);
    public void Add(Action code);
    public Task get_TerminationTask();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1(Task _);
}
public class Akka.Actor.Internal.UnboundedStashImpl : AbstractStash {
    public int Capacity { get; }
    public UnboundedStashImpl(IActorContext context);
    public virtual int get_Capacity();
}
internal class Akka.Actor.Internal.UnrestrictedStashImpl : AbstractStash {
    public UnrestrictedStashImpl(IActorContext context);
}
[InternalApiAttribute]
public abstract class Akka.Actor.InternalActorRefBase : ActorRefBase {
    public IInternalActorRef Parent { get; }
    public IActorRefProvider Provider { get; }
    public bool IsTerminated { get; }
    public bool IsLocal { get; }
    public abstract virtual IInternalActorRef get_Parent();
    public abstract virtual IActorRefProvider get_Provider();
    public abstract virtual IActorRef GetChild(IReadOnlyList`1<string> name);
    public abstract virtual void Resume(Exception causedByFailure);
    public abstract virtual void Start();
    public abstract virtual void Stop();
    public abstract virtual void Restart(Exception cause);
    public abstract virtual void Suspend();
    public abstract virtual bool get_IsTerminated();
    public abstract virtual bool get_IsLocal();
    [ObsoleteAttribute("Use SendSystemMessage(message) instead [1.1.0]")]
public sealed virtual void SendSystemMessage(ISystemMessage message, IActorRef sender);
    public abstract virtual void SendSystemMessage(ISystemMessage message);
}
public class Akka.Actor.InvalidActorNameException : AkkaException {
    public InvalidActorNameException(string message);
    public InvalidActorNameException(string message, Exception innerException);
    protected InvalidActorNameException(SerializationInfo info, StreamingContext context);
}
public class Akka.Actor.InvalidMessageException : AkkaException {
    public InvalidMessageException(string message);
    protected InvalidMessageException(SerializationInfo info, StreamingContext context);
}
public interface Akka.Actor.IPossiblyHarmful {
}
internal interface Akka.Actor.IQuery {
    public TimeSpan Deadline { get; }
    public IActorRef Client { get; }
    public abstract virtual TimeSpan get_Deadline();
    public abstract virtual IActorRef get_Client();
    public abstract virtual IQuery WithClient(IActorRef client);
}
public interface Akka.Actor.IRepointableRef {
    public bool IsStarted { get; }
    public abstract virtual bool get_IsStarted();
}
public interface Akka.Actor.IRunnableScheduler {
    public abstract virtual void ScheduleOnce(TimeSpan delay, IRunnable action, ICancelable cancelable);
    public abstract virtual void ScheduleOnce(TimeSpan delay, IRunnable action);
    public abstract virtual void ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, IRunnable action, ICancelable cancelable);
    public abstract virtual void ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, IRunnable action);
}
public interface Akka.Actor.IScheduler {
    public IAdvancedScheduler Advanced { get; }
    public abstract virtual IAdvancedScheduler get_Advanced();
}
public interface Akka.Actor.IStash {
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool NonEmpty { get; }
    public bool IsFull { get; }
    public int Capacity { get; }
    public abstract virtual void Stash();
    public abstract virtual void Unstash();
    public abstract virtual void UnstashAll();
    public abstract virtual void UnstashAll(Func`2<Envelope, bool> predicate);
    public abstract virtual IEnumerable`1<Envelope> ClearStash();
    public abstract virtual void Prepend(IEnumerable`1<Envelope> envelopes);
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_NonEmpty();
    public abstract virtual bool get_IsFull();
    public abstract virtual int get_Capacity();
}
public interface Akka.Actor.ITellScheduler {
    public abstract virtual void ScheduleTellOnce(TimeSpan delay, ICanTell receiver, object message, IActorRef sender);
    public abstract virtual void ScheduleTellOnce(TimeSpan delay, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    public abstract virtual void ScheduleTellRepeatedly(TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, IActorRef sender);
    public abstract virtual void ScheduleTellRepeatedly(TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
}
public interface Akka.Actor.ITimeProvider {
    public DateTimeOffset Now { get; }
    public DateTime DateTimeNow { get; }
    public TimeSpan MonotonicClock { get; }
    public TimeSpan HighResMonotonicClock { get; }
    public abstract virtual DateTimeOffset get_Now();
    public abstract virtual DateTime get_DateTimeNow();
    public abstract virtual TimeSpan get_MonotonicClock();
    public abstract virtual TimeSpan get_HighResMonotonicClock();
}
public interface Akka.Actor.ITimerScheduler {
    public IReadOnlyCollection`1<object> ActiveTimers { get; }
    public abstract virtual void StartPeriodicTimer(object key, object msg, TimeSpan interval);
    public abstract virtual void StartPeriodicTimer(object key, object msg, TimeSpan interval, IActorRef sender);
    public abstract virtual void StartPeriodicTimer(object key, object msg, TimeSpan initialDelay, TimeSpan interval);
    public abstract virtual void StartPeriodicTimer(object key, object msg, TimeSpan initialDelay, TimeSpan interval, IActorRef sender);
    public abstract virtual void StartSingleTimer(object key, object msg, TimeSpan timeout);
    public abstract virtual void StartSingleTimer(object key, object msg, TimeSpan timeout, IActorRef sender);
    public abstract virtual bool IsTimerActive(object key);
    public abstract virtual IReadOnlyCollection`1<object> get_ActiveTimers();
    public abstract virtual void Cancel(object key);
    public abstract virtual void CancelAll();
}
public interface Akka.Actor.IUntypedActorContext {
    public abstract virtual void Become(UntypedReceive receive);
    public abstract virtual void BecomeStacked(UntypedReceive receive);
}
[ObsoleteAttribute("Use `IWithStash` with a configured BoundedDeque-based mailbox instead.")]
public interface Akka.Actor.IWithBoundedStash {
}
public interface Akka.Actor.IWithStash {
}
public interface Akka.Actor.IWithTimers {
    public ITimerScheduler Timers { get; public set; }
    public abstract virtual ITimerScheduler get_Timers();
    public abstract virtual void set_Timers(ITimerScheduler value);
}
public interface Akka.Actor.IWithUnboundedStash {
}
public interface Akka.Actor.IWithUnrestrictedStash {
}
public interface Akka.Actor.IWrappedMessage {
    public object Message { get; }
    public abstract virtual object get_Message();
}
internal class Akka.Actor.Kick : ValueType {
}
public class Akka.Actor.Kill : object {
    [CompilerGeneratedAttribute]
private static Kill <Instance>k__BackingField;
    public static Kill Instance { get; }
    private static Kill();
    [CompilerGeneratedAttribute]
public static Kill get_Instance();
    public virtual string ToString();
}
public class Akka.Actor.LocalActorRef : ActorRefWithCell {
    private ActorSystemImpl _system;
    private MessageDispatcher _dispatcher;
    private IInternalActorRef _supervisor;
    private ActorPath _path;
    private ActorCell _cell;
    [CompilerGeneratedAttribute]
private MailboxType <MailboxType>k__BackingField;
    public ICell Underlying { get; }
    public ActorCell Cell { get; }
    public IActorRefProvider Provider { get; }
    public IInternalActorRef Parent { get; }
    public IEnumerable`1<IActorRef> Children { get; }
    public bool IsLocal { get; }
    public ActorPath Path { get; }
    protected ActorSystem System { get; }
    protected Props Props { get; }
    protected MessageDispatcher Dispatcher { get; }
    protected IInternalActorRef Supervisor { get; }
    public bool IsTerminated { get; }
    protected MailboxType MailboxType { get; }
    public LocalActorRef(ActorSystemImpl system, Props props, MessageDispatcher dispatcher, MailboxType mailboxType, IInternalActorRef supervisor, ActorPath path);
    protected virtual ActorCell NewActorCell(ActorSystemImpl system, IInternalActorRef self, Props props, MessageDispatcher dispatcher, IInternalActorRef supervisor);
    public virtual ICell get_Underlying();
    public ActorCell get_Cell();
    public virtual IActorRefProvider get_Provider();
    public virtual IInternalActorRef get_Parent();
    public virtual IEnumerable`1<IActorRef> get_Children();
    public virtual void Start();
    public virtual void Stop();
    public virtual void Suspend();
    public virtual bool get_IsLocal();
    public virtual void SendSystemMessage(ISystemMessage message);
    public virtual ActorPath get_Path();
    protected ActorSystem get_System();
    protected Props get_Props();
    protected MessageDispatcher get_Dispatcher();
    protected IInternalActorRef get_Supervisor();
    public virtual bool get_IsTerminated();
    [CompilerGeneratedAttribute]
protected MailboxType get_MailboxType();
    public virtual void Resume(Exception causedByFailure);
    public virtual void Restart(Exception cause);
    protected virtual void TellInternal(object message, IActorRef sender);
    public virtual IInternalActorRef GetSingleChild(string name);
    public virtual IActorRef GetChild(IReadOnlyList`1<string> name);
}
public class Akka.Actor.LocalActorRefProvider : object {
    private Settings _settings;
    private EventStream _eventStream;
    private Deployer _deployer;
    private IInternalActorRef _deadLetters;
    private RootActorPath _rootPath;
    private ILoggingAdapter _log;
    private AtomicCounterLong _tempNumber;
    private ActorPath _tempNode;
    private ActorSystemImpl _system;
    private Dictionary`2<string, IInternalActorRef> _extraNames;
    private TaskCompletionSource`1<Status> _terminationPromise;
    private SupervisorStrategy _systemGuardianStrategy;
    private SupervisorStrategyConfigurator _userGuardianStrategyConfigurator;
    private VirtualPathContainer _tempContainer;
    private RootGuardianActorRef _rootGuardian;
    private LocalActorRef _userGuardian;
    private MailboxType _defaultMailbox;
    private LocalActorRef _systemGuardian;
    [CompilerGeneratedAttribute]
private IActorRef <IgnoreRef>k__BackingField;
    private Information _serializationInformationCache;
    public IActorRef DeadLetters { get; }
    public IActorRef IgnoreRef { get; }
    public Deployer Deployer { get; }
    public IInternalActorRef RootGuardian { get; }
    public ActorPath RootPath { get; }
    public Settings Settings { get; }
    public LocalActorRef SystemGuardian { get; }
    public IInternalActorRef TempContainer { get; }
    public Task TerminationTask { get; }
    public LocalActorRef Guardian { get; }
    public EventStream EventStream { get; }
    private MessageDispatcher InternalDispatcher { get; }
    private SupervisorStrategy UserGuardianSupervisorStrategy { get; }
    public Address DefaultAddress { get; }
    public Information SerializationInformation { get; }
    public ILoggingAdapter Log { get; }
    public LocalActorRefProvider(string systemName, Settings settings, EventStream eventStream);
    public LocalActorRefProvider(string systemName, Settings settings, EventStream eventStream, Deployer deployer, Func`2<ActorPath, IInternalActorRef> deadLettersFactory);
    public sealed virtual IActorRef get_DeadLetters();
    [CompilerGeneratedAttribute]
public sealed virtual IActorRef get_IgnoreRef();
    public sealed virtual Deployer get_Deployer();
    public sealed virtual IInternalActorRef get_RootGuardian();
    public sealed virtual ActorPath get_RootPath();
    public sealed virtual Settings get_Settings();
    public sealed virtual LocalActorRef get_SystemGuardian();
    public sealed virtual IInternalActorRef get_TempContainer();
    public sealed virtual Task get_TerminationTask();
    public sealed virtual LocalActorRef get_Guardian();
    public EventStream get_EventStream();
    private MessageDispatcher get_InternalDispatcher();
    private SupervisorStrategy get_UserGuardianSupervisorStrategy();
    public sealed virtual ActorPath TempPath();
    private string GetNextTempName();
    public void RegisterExtraName(string name, IInternalActorRef actor);
    private RootGuardianActorRef CreateRootGuardian(ActorSystemImpl system);
    public sealed virtual IActorRef RootGuardianAt(Address address);
    private LocalActorRef CreateUserGuardian(LocalActorRef rootGuardian, string name);
    private LocalActorRef CreateSystemGuardian(LocalActorRef rootGuardian, string name, LocalActorRef userGuardian);
    public sealed virtual void RegisterTempActor(IInternalActorRef actorRef, ActorPath path);
    public sealed virtual void UnregisterTempActor(ActorPath path);
    public sealed virtual FutureActorRef`1<T> CreateFutureRef(TaskCompletionSource`1<T> tcs);
    public sealed virtual void Init(ActorSystemImpl system);
    public sealed virtual IActorRef ResolveActorRef(string path);
    public sealed virtual IActorRef ResolveActorRef(ActorPath path);
    internal IInternalActorRef ResolveActorRef(IInternalActorRef actorRef, IReadOnlyList`1<string> pathElements);
    public sealed virtual IInternalActorRef ActorOf(ActorSystemImpl system, Props props, IInternalActorRef supervisor, ActorPath path, bool systemService, Deploy deploy, bool lookupDeploy, bool async);
    public sealed virtual Address GetExternalAddressFor(Address address);
    public sealed virtual Address get_DefaultAddress();
    public sealed virtual Information get_SerializationInformation();
    public ILoggingAdapter get_Log();
    [CompilerGeneratedAttribute]
private IInternalActorRef <.ctor>b__19_0(ActorPath p);
    [CompilerGeneratedAttribute]
private Directive <CreateRootGuardian>b__50_0(Exception ex);
}
public class Akka.Actor.LocalOnlyDecider : object {
    private Func`2<Exception, Directive> _decider;
    public LocalOnlyDecider(Func`2<Exception, Directive> decider);
    public sealed virtual Directive Decide(Exception cause);
}
public class Akka.Actor.LocalScope : Scope {
    [CompilerGeneratedAttribute]
private static LocalScope <Instance>k__BackingField;
    public static LocalScope Instance { get; }
    private static LocalScope();
    [CompilerGeneratedAttribute]
public static LocalScope get_Instance();
    public virtual Scope WithFallback(Scope other);
    public virtual Scope Copy();
    public sealed virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Actor.LoggerInitializationException : AkkaException {
    public LoggerInitializationException(string message);
    public LoggerInitializationException(string message, Exception cause);
    protected LoggerInitializationException(SerializationInfo info, StreamingContext context);
}
[InternalApiAttribute]
public abstract class Akka.Actor.MinimalActorRef : InternalActorRefBase {
    public IInternalActorRef Parent { get; }
    public bool IsLocal { get; }
    [ObsoleteAttribute("Use Context.Watch and Receive<Terminated> [1.1.0]")]
public bool IsTerminated { get; }
    public virtual IInternalActorRef get_Parent();
    public virtual IActorRef GetChild(IReadOnlyList`1<string> name);
    public virtual void Resume(Exception causedByFailure);
    public virtual void Start();
    public virtual void Stop();
    public virtual void Restart(Exception cause);
    public virtual void Suspend();
    protected virtual void TellInternal(object message, IActorRef sender);
    public virtual void SendSystemMessage(ISystemMessage message);
    public virtual bool get_IsLocal();
    public virtual bool get_IsTerminated();
}
public class Akka.Actor.Nobody : MinimalActorRef {
    public static Nobody Instance;
    private static NobodySurrogate SurrogateInstance;
    private ActorPath _path;
    public ActorPath Path { get; }
    public IActorRefProvider Provider { get; }
    private static Nobody();
    public virtual ActorPath get_Path();
    public virtual IActorRefProvider get_Provider();
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
internal class Akka.Actor.NoScopeGiven : Scope {
    [CompilerGeneratedAttribute]
private static NoScopeGiven <Instance>k__BackingField;
    public static NoScopeGiven Instance { get; }
    private static NoScopeGiven();
    [CompilerGeneratedAttribute]
public static NoScopeGiven get_Instance();
    public virtual Scope WithFallback(Scope other);
    public virtual Scope Copy();
}
public class Akka.Actor.OneForOneStrategy : SupervisorStrategy {
    private int _maxNumberOfRetries;
    private int _withinTimeRangeMilliseconds;
    private IDecider _decider;
    public int MaxNumberOfRetries { get; }
    public int WithinTimeRangeMilliseconds { get; }
    public IDecider Decider { get; }
    public OneForOneStrategy(Nullable`1<int> maxNrOfRetries, Nullable`1<TimeSpan> withinTimeRange, Func`2<Exception, Directive> localOnlyDecider);
    public OneForOneStrategy(Nullable`1<int> maxNrOfRetries, Nullable`1<TimeSpan> withinTimeRange, IDecider decider);
    public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, Func`2<Exception, Directive> localOnlyDecider, bool loggingEnabled);
    public OneForOneStrategy(int maxNrOfRetries, int withinTimeMilliseconds, IDecider decider, bool loggingEnabled);
    public OneForOneStrategy(Func`2<Exception, Directive> localOnlyDecider);
    public OneForOneStrategy(Func`2<Exception, Directive> localOnlyDecider, bool loggingEnabled);
    public OneForOneStrategy(IDecider decider);
    public int get_MaxNumberOfRetries();
    public int get_WithinTimeRangeMilliseconds();
    public virtual IDecider get_Decider();
    public OneForOneStrategy WithMaxNrOfRetries(int maxNrOfRetries);
    protected virtual Directive Handle(IActorRef child, Exception exception);
    public virtual void ProcessFailure(IActorContext context, bool restart, IActorRef child, Exception cause, ChildRestartStats stats, IReadOnlyCollection`1<ChildRestartStats> children);
    public virtual void HandleChildTerminated(IActorContext actorContext, IActorRef child, IEnumerable`1<IInternalActorRef> children);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
    public sealed virtual bool Equals(OneForOneStrategy other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Akka.Actor.Phase : object {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <DependsOn>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recover>k__BackingField;
    public ImmutableHashSet`1<string> DependsOn { get; }
    public TimeSpan Timeout { get; }
    public bool Recover { get; }
    public Phase(ImmutableHashSet`1<string> dependsOn, TimeSpan timeout, bool recover);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_DependsOn();
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public bool get_Recover();
    private bool Equals(Phase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Akka.Actor.PipeToSupport : object {
    [ExtensionAttribute]
public static Task PipeTo(Task`1<T> taskToPipe, ICanTell recipient, IActorRef sender, Func`2<T, object> success, Func`2<Exception, object> failure);
    [ExtensionAttribute]
public static Task PipeTo(ValueTask`1<T> taskToPipe, ICanTell recipient, IActorRef sender, Func`2<T, object> success, Func`2<Exception, object> failure);
    [AsyncStateMachineAttribute("Akka.Actor.PipeToSupport/<PipeTo>d__2`1")]
[ExtensionAttribute]
public static Task PipeTo(Task`1<T> taskToPipe, ICanTell recipient, bool useConfigureAwait, IActorRef sender, Func`2<T, object> success, Func`2<Exception, object> failure);
    [AsyncStateMachineAttribute("Akka.Actor.PipeToSupport/<PipeTo>d__3`1")]
[ExtensionAttribute]
public static Task PipeTo(ValueTask`1<T> taskToPipe, ICanTell recipient, bool useConfigureAwait, IActorRef sender, Func`2<T, object> success, Func`2<Exception, object> failure);
    [ExtensionAttribute]
public static Task PipeTo(Task taskToPipe, ICanTell recipient, IActorRef sender, Func`1<object> success, Func`2<Exception, object> failure);
    [ExtensionAttribute]
public static Task PipeTo(ValueTask taskToPipe, ICanTell recipient, IActorRef sender, Func`1<object> success, Func`2<Exception, object> failure);
    [AsyncStateMachineAttribute("Akka.Actor.PipeToSupport/<PipeTo>d__6")]
[ExtensionAttribute]
public static Task PipeTo(Task taskToPipe, ICanTell recipient, bool useConfigureAwait, IActorRef sender, Func`1<object> success, Func`2<Exception, object> failure);
    [AsyncStateMachineAttribute("Akka.Actor.PipeToSupport/<PipeTo>d__7")]
[ExtensionAttribute]
public static Task PipeTo(ValueTask taskToPipe, ICanTell recipient, bool useConfigureAwait, IActorRef sender, Func`1<object> success, Func`2<Exception, object> failure);
}
public class Akka.Actor.PoisonPill : object {
    [CompilerGeneratedAttribute]
private static PoisonPill <Instance>k__BackingField;
    public static PoisonPill Instance { get; }
    private static PoisonPill();
    [CompilerGeneratedAttribute]
public static PoisonPill get_Instance();
    public virtual string ToString();
}
public class Akka.Actor.PostRestartException : ActorInitializationException {
    [CompilerGeneratedAttribute]
private Exception <OriginalCause>k__BackingField;
    public Exception OriginalCause { get; }
    public PostRestartException(IActorRef actor, Exception cause, Exception originalCause);
    protected PostRestartException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Exception get_OriginalCause();
}
public class Akka.Actor.PreRestartException : ActorInitializationException {
    [CompilerGeneratedAttribute]
private Exception <RestartException>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OptionalMessage>k__BackingField;
    public Exception RestartException { get; }
    public object OptionalMessage { get; }
    public PreRestartException(IActorRef actor, Exception restartException, Exception cause, object optionalMessage);
    protected PreRestartException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Exception get_RestartException();
    [CompilerGeneratedAttribute]
public object get_OptionalMessage();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Akka.Actor.PromiseActorRef : MinimalActorRef {
    private IActorRefProvider _provider;
    private TaskCompletionSource`1<object> _promise;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _mcn;
    private AtomicReference`1<object> _stateDoNotCallMeDirectly;
    private static Failure ActorStopResult;
    private static Action`1<object> CancelAction;
    private AtomicReference`1<ImmutableHashSet`1<IActorRef>> _watchedByDoNotCallMeDirectly;
    public Task`1<object> Result { get; }
    private ImmutableHashSet`1<IActorRef> WatchedBy { get; }
    public IActorRefProvider Provider { get; }
    private object State { get; private set; }
    public IInternalActorRef Parent { get; }
    public ActorPath Path { get; }
    private PromiseActorRef(IActorRefProvider provider, TaskCompletionSource`1<object> promise, string mcn);
    private static PromiseActorRef();
    public Task`1<object> get_Result();
    public static PromiseActorRef Apply(IActorRefProvider provider, string messageClassName, CancellationToken cancellationToken);
    public static PromiseActorRef Apply(IActorRefProvider provider, TimeSpan timeout, object targetName, string messageClassName, IActorRef sender);
    private ImmutableHashSet`1<IActorRef> get_WatchedBy();
    private bool UpdateWatchedBy(ImmutableHashSet`1<IActorRef> oldWatchedBy, ImmutableHashSet`1<IActorRef> newWatchedBy);
    public virtual IActorRefProvider get_Provider();
    private bool AddWatcher(IActorRef watcher);
    private void RemoveWatcher(IActorRef watcher);
    private ImmutableHashSet`1<IActorRef> ClearWatchers();
    private object get_State();
    private void set_State(object value);
    private bool UpdateState(object oldState, object newState);
    public virtual IInternalActorRef get_Parent();
    public virtual ActorPath get_Path();
    private ActorPath GetPath();
    protected virtual void TellInternal(object message, IActorRef sender);
    public virtual void SendSystemMessage(ISystemMessage message);
    public virtual void Stop();
    private void StopEnsureCompleted();
}
public class Akka.Actor.Props : object {
    private static string NullActorTypeExceptionText;
    private static Deploy DefaultDeploy;
    private static Object[] NoArgs;
    public static Props None;
    private Type _inputType;
    private Type _outputType;
    private IIndirectActorProducer _producer;
    [CompilerGeneratedAttribute]
private Deploy <Deploy>k__BackingField;
    [CompilerGeneratedAttribute]
private SupervisorStrategy <SupervisorStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private static Props <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    [JsonIgnoreAttribute]
public Type Type { get; }
    [JsonIgnoreAttribute]
public string Dispatcher { get; }
    [JsonIgnoreAttribute]
public string Mailbox { get; }
    public string TypeName { get; private set; }
    [JsonIgnoreAttribute]
public RouterConfig RouterConfig { get; }
    public Deploy Deploy { get; protected set; }
    public SupervisorStrategy SupervisorStrategy { get; protected set; }
    public static Props Empty { get; }
    public Object[] Arguments { get; }
    protected Props(Props copy);
    public Props(Type type, Object[] args);
    public Props(Type type);
    public Props(Type type, SupervisorStrategy supervisorStrategy, IEnumerable`1<object> args);
    public Props(Type type, SupervisorStrategy supervisorStrategy, Object[] args);
    public Props(Deploy deploy, Type type, IEnumerable`1<object> args);
    public Props(Deploy deploy, Type type, Object[] args);
    internal Props(IIndirectActorProducer producer, Deploy deploy, Object[] args);
    private static Props();
    public Type get_Type();
    public string get_Dispatcher();
    public string get_Mailbox();
    public string get_TypeName();
    private void set_TypeName(string value);
    public RouterConfig get_RouterConfig();
    [CompilerGeneratedAttribute]
public Deploy get_Deploy();
    [CompilerGeneratedAttribute]
protected void set_Deploy(Deploy value);
    [CompilerGeneratedAttribute]
public SupervisorStrategy get_SupervisorStrategy();
    [CompilerGeneratedAttribute]
protected void set_SupervisorStrategy(SupervisorStrategy value);
    [CompilerGeneratedAttribute]
public static Props get_Empty();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    public sealed virtual bool Equals(Props other);
    public sealed virtual ISurrogate ToSurrogate(ActorSystem system);
    private bool CompareInputType(Props other);
    private bool CompareDeploy(Props other);
    private bool CompareSupervisorStrategy(Props other);
    private bool CompareArguments(Props other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Props Create(Expression`1<Func`1<TActor>> factory, SupervisorStrategy supervisorStrategy);
    public static Props Create(Object[] args);
    [ObsoleteAttribute("Do not use this method. Call CreateBy(IIndirectActorProducer, params object[] args) instead")]
public static Props CreateBy(Object[] args);
    public static Props CreateBy(IIndirectActorProducer producer, Object[] args);
    public static Props Create(SupervisorStrategy supervisorStrategy);
    public static Props Create(Type type, Object[] args);
    public Props WithMailbox(string mailbox);
    public Props WithDispatcher(string dispatcher);
    public Props WithRouter(RouterConfig routerConfig);
    public Props WithStashCapacity(int stashCapacity);
    public Props WithDeploy(Deploy deploy);
    public Props WithSupervisorStrategy(SupervisorStrategy supervisorStrategy);
    public virtual ActorBase NewActor();
    protected virtual Props Copy();
    [ObsoleteAttribute("we should not be calling this method. Pass in an explicit IIndirectActorProducer reference instead.")]
private static IIndirectActorProducer CreateProducer(Type type, Object[] args);
    internal void Release(ActorBase actor);
}
public abstract class Akka.Actor.ProviderSelection : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Fqn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCluster>k__BackingField;
    internal static string LocalActorRefProvider;
    internal static string RemoteActorRefProvider;
    internal static string ClusterActorRefProvider;
    internal string Identifier { get; }
    internal string Fqn { get; }
    internal bool HasCluster { get; }
    private ProviderSelection(string identifier, string fqn, bool hasCluster);
    [CompilerGeneratedAttribute]
internal string get_Identifier();
    [CompilerGeneratedAttribute]
internal string get_Fqn();
    [CompilerGeneratedAttribute]
internal bool get_HasCluster();
    internal static ProviderSelection GetProvider(string providerClass);
}
public class Akka.Actor.Receive : MulticastDelegate {
    public Receive(object object, IntPtr method);
    public virtual bool Invoke(object message);
    public virtual IAsyncResult BeginInvoke(object message, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class Akka.Actor.ReceiveActor : UntypedActor {
    private bool _shouldUnhandle;
    private Stack`1<MatchBuilder> _matchHandlerBuilders;
    private PartialAction`1<object> _partialReceive;
    private bool _hasBeenInitialized;
    private sealed virtual override void Akka.Actor.Internal.IInitializableActor.Init();
    private PartialAction`1<object> BuildNewReceiveHandler(MatchBuilder matchBuilder);
    private void EnsureMayConfigureMessageHandlers();
    private void PrepareConfigureMessageHandlers();
    protected sealed virtual void OnReceive(object message);
    private void ExecutePartialMessageHandler(object message, PartialAction`1<object> partialAction);
    protected void Become(Action configure);
    protected void BecomeStacked(Action configure);
    private PartialAction`1<object> CreateNewHandler(Action configure);
    private static Action`1<T> WrapAsyncHandler(Func`2<T, Task> asyncHandler);
    protected void ReceiveAsync(Func`2<T, Task> handler, Predicate`1<T> shouldHandle);
    protected void ReceiveAsync(Predicate`1<T> shouldHandle, Func`2<T, Task> handler);
    protected void ReceiveAsync(Type messageType, Func`2<object, Task> handler, Predicate`1<object> shouldHandle);
    protected void ReceiveAsync(Type messageType, Predicate`1<object> shouldHandle, Func`2<object, Task> handler);
    protected void ReceiveAnyAsync(Func`2<object, Task> handler);
    protected void Receive(Action`1<T> handler, Predicate`1<T> shouldHandle);
    protected void Receive(Predicate`1<T> shouldHandle, Action`1<T> handler);
    protected void Receive(Type messageType, Action`1<object> handler, Predicate`1<object> shouldHandle);
    protected void Receive(Type messageType, Predicate`1<object> shouldHandle, Action`1<object> handler);
    protected void Receive(Func`2<T, bool> handler);
    protected void Receive(Type messageType, Func`2<object, bool> handler);
    protected void ReceiveAny(Action`1<object> handler);
}
public class Akka.Actor.ReceiveTimeout : object {
    [CompilerGeneratedAttribute]
private static ReceiveTimeout <Instance>k__BackingField;
    public static ReceiveTimeout Instance { get; }
    private static ReceiveTimeout();
    [CompilerGeneratedAttribute]
public static ReceiveTimeout get_Instance();
}
public static class Akka.Actor.RelativeActorPath : object {
    public static IEnumerable`1<string> Unapply(string addr);
}
public class Akka.Actor.RemoteScope : Scope {
    [CompilerGeneratedAttribute]
private Address <Address>k__BackingField;
    public Address Address { get; public set; }
    public RemoteScope(Address address);
    [CompilerGeneratedAttribute]
public Address get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(Address value);
    public sealed virtual bool Equals(RemoteScope other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Scope WithFallback(Scope other);
    public virtual Scope Copy();
}
public class Akka.Actor.RepointableActorRef : ActorRefWithCell {
    private ICell modreq(System.Runtime.CompilerServices.IsVolatile) _underlying_DoNotCallMeDirectly;
    private ICell modreq(System.Runtime.CompilerServices.IsVolatile) _lookup_DoNotCallMeDirectly;
    protected ActorSystemImpl System;
    protected Props Props;
    protected MessageDispatcher Dispatcher;
    internal MailboxType MailboxType;
    protected IInternalActorRef Supervisor;
    protected ActorPath _path;
    public ICell Underlying { get; }
    public ICell Lookup { get; }
    public bool IsTerminated { get; }
    public ActorPath Path { get; }
    public IInternalActorRef Parent { get; }
    public IActorRefProvider Provider { get; }
    public bool IsLocal { get; }
    public bool IsStarted { get; }
    public IEnumerable`1<IActorRef> Children { get; }
    public RepointableActorRef(ActorSystemImpl system, Props props, MessageDispatcher dispatcher, MailboxType mailboxType, IInternalActorRef supervisor, ActorPath path);
    public virtual ICell get_Underlying();
    public ICell get_Lookup();
    public virtual bool get_IsTerminated();
    public void SwapUnderlying(ICell cell);
    private void SwapLookup(ICell cell);
    public RepointableActorRef Initialize(bool async);
    public void Point();
    protected virtual ActorCell NewCell();
    public virtual ActorPath get_Path();
    public virtual IInternalActorRef get_Parent();
    public virtual IActorRefProvider get_Provider();
    public virtual bool get_IsLocal();
    public virtual void Start();
    public virtual void Suspend();
    public virtual void SendSystemMessage(ISystemMessage message);
    public virtual void Resume(Exception causedByFailure);
    public virtual void Stop();
    public virtual void Restart(Exception cause);
    public sealed virtual bool get_IsStarted();
    protected virtual void TellInternal(object message, IActorRef sender);
    public virtual IActorRef GetChild(IReadOnlyList`1<string> name);
    public virtual IInternalActorRef GetSingleChild(string name);
    public virtual IEnumerable`1<IActorRef> get_Children();
}
public class Akka.Actor.RootActorPath : ActorPath {
    public RootActorPath(Address address, string name);
}
[InternalApiAttribute]
public class Akka.Actor.RootGuardianActorRef : LocalActorRef {
    private IInternalActorRef _tempContainer;
    private IInternalActorRef _deadLetters;
    private IReadOnlyDictionary`2<string, IInternalActorRef> _extraNames;
    public IInternalActorRef Parent { get; }
    public RootGuardianActorRef(ActorSystemImpl system, Props props, MessageDispatcher dispatcher, MailboxType mailboxType, IInternalActorRef supervisor, ActorPath path, IInternalActorRef deadLetters, IReadOnlyDictionary`2<string, IInternalActorRef> extraNames);
    public virtual IInternalActorRef get_Parent();
    public void SetTempContainer(IInternalActorRef tempContainer);
    public virtual IInternalActorRef GetSingleChild(string name);
}
public class Akka.Actor.RootGuardianSupervisor : MinimalActorRef {
    private ILoggingAdapter _log;
    private TaskCompletionSource`1<Status> _terminationPromise;
    private ActorPath _path;
    private Switch _stopped;
    private IActorRefProvider _provider;
    [CompilerGeneratedAttribute]
private Exception <CauseOfTermination>k__BackingField;
    private bool IsWalking { get; }
    public Exception CauseOfTermination { get; private set; }
    public ActorPath Path { get; }
    public IActorRefProvider Provider { get; }
    public RootGuardianSupervisor(RootActorPath root, IActorRefProvider provider, TaskCompletionSource`1<Status> terminationPromise, ILoggingAdapter log);
    private bool get_IsWalking();
    protected virtual void TellInternal(object message, IActorRef sender);
    public virtual void SendSystemMessage(ISystemMessage systemMessage);
    [CompilerGeneratedAttribute]
public Exception get_CauseOfTermination();
    [CompilerGeneratedAttribute]
private void set_CauseOfTermination(Exception value);
    public virtual void Stop();
    public virtual ActorPath get_Path();
    public virtual IActorRefProvider get_Provider();
}
[InternalApiAttribute]
public interface Akka.Actor.Scheduler.IScheduledTellMsg {
}
internal class Akka.Actor.Scheduler.ScheduledTellMsg : object {
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    public object Message { get; }
    public ScheduledTellMsg(object message);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Message();
}
internal class Akka.Actor.Scheduler.ScheduledTellMsgNoInfluenceReceiveTimeout : object {
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    public object Message { get; }
    public ScheduledTellMsgNoInfluenceReceiveTimeout(object message);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Message();
}
internal class Akka.Actor.Scheduler.TimerScheduler : object {
    private IActorContext _ctx;
    private Dictionary`2<object, Timer> _timers;
    private AtomicCounter _timerGen;
    private bool _logDebug;
    private ILoggingAdapter _log;
    public IReadOnlyCollection`1<object> ActiveTimers { get; }
    public TimerScheduler(IActorContext ctx);
    public sealed virtual void StartPeriodicTimer(object key, object msg, TimeSpan interval);
    public sealed virtual void StartPeriodicTimer(object key, object msg, TimeSpan interval, IActorRef sender);
    public sealed virtual void StartPeriodicTimer(object key, object msg, TimeSpan initialDelay, TimeSpan interval);
    public sealed virtual void StartPeriodicTimer(object key, object msg, TimeSpan initialDelay, TimeSpan interval, IActorRef sender);
    public sealed virtual void StartSingleTimer(object key, object msg, TimeSpan timeout);
    public sealed virtual void StartSingleTimer(object key, object msg, TimeSpan timeout, IActorRef sender);
    public sealed virtual bool IsTimerActive(object key);
    public sealed virtual IReadOnlyCollection`1<object> get_ActiveTimers();
    public sealed virtual void Cancel(object key);
    public sealed virtual void CancelAll();
    private void CancelTimer(Timer timer);
    private void StartTimer(object key, object msg, TimeSpan timeout, TimeSpan initialDelay, bool repeat, IActorRef sender);
    public object InterceptTimerMsg(ILoggingAdapter log, ITimerMsg timerMsg);
}
public abstract class Akka.Actor.SchedulerBase : object {
    protected Config SchedulerConfig;
    protected ILoggingAdapter Log;
    private IAdvancedScheduler Akka.Actor.IScheduler.Advanced { get; }
    private DateTimeOffset Akka.Actor.ITimeProvider.Now { get; }
    private DateTime Akka.Actor.ITimeProvider.DateTimeNow { get; }
    protected DateTimeOffset TimeNow { get; }
    protected DateTime DateTimeNow { get; }
    public TimeSpan MonotonicClock { get; }
    public TimeSpan HighResMonotonicClock { get; }
    protected SchedulerBase(Config scheduler, ILoggingAdapter log);
    private sealed virtual override void Akka.Actor.ITellScheduler.ScheduleTellOnce(TimeSpan delay, ICanTell receiver, object message, IActorRef sender);
    private sealed virtual override void Akka.Actor.ITellScheduler.ScheduleTellOnce(TimeSpan delay, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    private sealed virtual override void Akka.Actor.ITellScheduler.ScheduleTellRepeatedly(TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, IActorRef sender);
    private sealed virtual override void Akka.Actor.ITellScheduler.ScheduleTellRepeatedly(TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    private sealed virtual override void Akka.Actor.IActionScheduler.ScheduleOnce(TimeSpan delay, Action action);
    private sealed virtual override void Akka.Actor.IActionScheduler.ScheduleOnce(TimeSpan delay, Action action, ICancelable cancelable);
    private sealed virtual override void Akka.Actor.IActionScheduler.ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action);
    private sealed virtual override void Akka.Actor.IActionScheduler.ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action, ICancelable cancelable);
    private sealed virtual override IAdvancedScheduler Akka.Actor.IScheduler.get_Advanced();
    private sealed virtual override DateTimeOffset Akka.Actor.ITimeProvider.get_Now();
    private sealed virtual override DateTime Akka.Actor.ITimeProvider.get_DateTimeNow();
    protected abstract virtual DateTimeOffset get_TimeNow();
    protected abstract virtual DateTime get_DateTimeNow();
    public abstract virtual TimeSpan get_MonotonicClock();
    public abstract virtual TimeSpan get_HighResMonotonicClock();
    protected abstract virtual void InternalScheduleTellOnce(TimeSpan delay, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    protected abstract virtual void InternalScheduleTellRepeatedly(TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    protected abstract virtual void InternalScheduleOnce(TimeSpan delay, Action action, ICancelable cancelable);
    protected abstract virtual void InternalScheduleOnce(TimeSpan delay, IRunnable action, ICancelable cancelable);
    protected abstract virtual void InternalScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, Action action, ICancelable cancelable);
    protected abstract virtual void InternalScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, IRunnable action, ICancelable cancelable);
    protected static void ValidateInterval(TimeSpan interval, string parameterName);
    protected static void ValidateDelay(TimeSpan delay, string parameterName);
    public sealed virtual void ScheduleOnce(TimeSpan delay, IRunnable action, ICancelable cancelable);
    public sealed virtual void ScheduleOnce(TimeSpan delay, IRunnable action);
    public sealed virtual void ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, IRunnable action, ICancelable cancelable);
    public sealed virtual void ScheduleRepeatedly(TimeSpan initialDelay, TimeSpan interval, IRunnable action);
}
public class Akka.Actor.SchedulerException : AkkaException {
    public SchedulerException(string message);
    public SchedulerException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Akka.Actor.SchedulerExtensions : object {
    [ExtensionAttribute]
public static void ScheduleTellOnce(ITellScheduler scheduler, int millisecondsDelay, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    [ExtensionAttribute]
public static void ScheduleTellRepeatedly(ITellScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, ICanTell receiver, object message, IActorRef sender, ICancelable cancelable);
    [ExtensionAttribute]
public static ICancelable ScheduleTellOnceCancelable(IScheduler scheduler, TimeSpan delay, ICanTell receiver, object message, IActorRef sender);
    [ExtensionAttribute]
public static ICancelable ScheduleTellOnceCancelable(IScheduler scheduler, int millisecondsDelay, ICanTell receiver, object message, IActorRef sender);
    [ExtensionAttribute]
public static ICancelable ScheduleTellRepeatedlyCancelable(IScheduler scheduler, TimeSpan initialDelay, TimeSpan interval, ICanTell receiver, object message, IActorRef sender);
    [ExtensionAttribute]
public static ICancelable ScheduleTellRepeatedlyCancelable(IScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, ICanTell receiver, object message, IActorRef sender);
    [ExtensionAttribute]
public static void ScheduleOnce(IActionScheduler scheduler, int millisecondsDelay, Action action, ICancelable cancelable);
    [ExtensionAttribute]
public static void ScheduleRepeatedly(IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Action action, ICancelable cancelable);
    [ExtensionAttribute]
public static ICancelable ScheduleOnceCancelable(IActionScheduler scheduler, TimeSpan delay, Action action);
    [ExtensionAttribute]
public static ICancelable ScheduleOnceCancelable(IActionScheduler scheduler, int millisecondsDelay, Action action);
    [ExtensionAttribute]
public static ICancelable ScheduleRepeatedlyCancelable(IActionScheduler scheduler, TimeSpan initialDelay, TimeSpan interval, Action action);
    [ExtensionAttribute]
public static ICancelable ScheduleRepeatedlyCancelable(IActionScheduler scheduler, int initialMillisecondsDelay, int millisecondsInterval, Action action);
}
public abstract class Akka.Actor.Scope : object {
    public static LocalScope Local;
    private static Scope();
    public abstract virtual Scope WithFallback(Scope other);
    public abstract virtual Scope Copy();
    public virtual bool Equals(Scope other);
}
internal class Akka.Actor.Select : ValueType {
    [CompilerGeneratedAttribute]
private TimeSpan <Deadline>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <Predicate>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <Client>k__BackingField;
    public TimeSpan Deadline { get; private set; }
    public Predicate`1<object> Predicate { get; public set; }
    public IActorRef Client { get; private set; }
    public Select(TimeSpan deadline, Predicate`1<object> predicate, IActorRef client);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_Deadline();
    [CompilerGeneratedAttribute]
private void set_Deadline(TimeSpan value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Predicate`1<object> get_Predicate();
    [CompilerGeneratedAttribute]
public void set_Predicate(Predicate`1<object> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual IActorRef get_Client();
    [CompilerGeneratedAttribute]
private void set_Client(IActorRef value);
    public sealed virtual IQuery WithClient(IActorRef client);
}
public class Akka.Actor.SelectChildName : SelectionPathElement {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public SelectChildName(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    protected bool Equals(SelectChildName other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Akka.Actor.SelectChildPattern : SelectionPathElement {
    [CompilerGeneratedAttribute]
private string <PatternStr>k__BackingField;
    public string PatternStr { get; }
    public SelectChildPattern(string patternStr);
    [CompilerGeneratedAttribute]
public string get_PatternStr();
    protected bool Equals(SelectChildPattern other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Akka.Actor.SelectChildRecursive : SelectionPathElement {
    public static SelectChildRecursive Instance;
    private static SelectChildRecursive();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Akka.Actor.SelectionPathElement : object {
}
public class Akka.Actor.SelectParent : SelectionPathElement {
    public static SelectParent Instance;
    private static SelectParent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Akka.Actor.Settings : object {
    private Config _userConfig;
    private Config _fallbackConfig;
    [CompilerGeneratedAttribute]
private ActorSystem <System>k__BackingField;
    [CompilerGeneratedAttribute]
private Config <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private ActorSystemSetup <Setup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private ProviderSelection <ProviderSelectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupervisorStrategyClass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeAllMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeAllCreators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitActorTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <AskTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CreationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <UnstartedPushTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdoutLogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private MinimalLogger <StdoutLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Loggers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoggersDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LoggerStartTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LoggerAsyncStart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogConfigOnStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogMessageFormatter <LogFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private LogFilterEvaluator <LogFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogSerializerOverrideOnStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LogDeadLetters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogDeadLettersDuringShutdown>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LogDeadLettersSuspendDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddLoggingReceive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugAutoReceive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugEventStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugUnhandledMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugRouterMisconfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Home>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugLifecycle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugTimerScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FsmDebugEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultVirtualNodesFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchedulerClass>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SchedulerShutdownTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CoordinatedShutdownTerminateActorSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CoordinatedShutdownRunByActorSystemTerminate>k__BackingField;
    public ActorSystem System { get; private set; }
    public Config Config { get; private set; }
    public ActorSystemSetup Setup { get; }
    public bool HasCluster { get; }
    public ProviderSelection ProviderSelectionType { get; }
    public string ConfigVersion { get; private set; }
    public string ProviderClass { get; private set; }
    public string SupervisorStrategyClass { get; private set; }
    public bool SerializeAllMessages { get; private set; }
    public bool SerializeAllCreators { get; private set; }
    public bool EmitActorTelemetry { get; }
    public TimeSpan AskTimeout { get; private set; }
    public TimeSpan CreationTimeout { get; private set; }
    public TimeSpan UnstartedPushTimeout { get; private set; }
    public string LogLevel { get; private set; }
    public string StdoutLogLevel { get; private set; }
    public MinimalLogger StdoutLogger { get; }
    public IList`1<string> Loggers { get; private set; }
    public string LoggersDispatcher { get; private set; }
    public TimeSpan LoggerStartTimeout { get; private set; }
    public bool LoggerAsyncStart { get; private set; }
    public bool LogConfigOnStart { get; private set; }
    public ILogMessageFormatter LogFormatter { get; }
    public LogFilterEvaluator LogFilter { get; }
    public bool LogSerializerOverrideOnStart { get; private set; }
    public int LogDeadLetters { get; private set; }
    public bool LogDeadLettersDuringShutdown { get; private set; }
    public TimeSpan LogDeadLettersSuspendDuration { get; }
    public bool AddLoggingReceive { get; private set; }
    public bool DebugAutoReceive { get; private set; }
    public bool DebugEventStream { get; private set; }
    public bool DebugUnhandledMessage { get; private set; }
    public bool DebugRouterMisconfiguration { get; private set; }
    public string Home { get; private set; }
    public bool DebugLifecycle { get; private set; }
    public bool DebugTimerScheduler { get; private set; }
    public bool FsmDebugEvent { get; private set; }
    public int DefaultVirtualNodesFactor { get; private set; }
    public string SchedulerClass { get; private set; }
    public TimeSpan SchedulerShutdownTimeout { get; private set; }
    public bool CoordinatedShutdownTerminateActorSystem { get; private set; }
    public bool CoordinatedShutdownRunByActorSystemTerminate { get; private set; }
    public Settings(ActorSystem system, Config config);
    public Settings(ActorSystem system, Config config, ActorSystemSetup setup);
    private void RebuildConfig();
    public void InjectTopLevelFallback(Config config);
    [CompilerGeneratedAttribute]
public ActorSystem get_System();
    [CompilerGeneratedAttribute]
private void set_System(ActorSystem value);
    [CompilerGeneratedAttribute]
public Config get_Config();
    [CompilerGeneratedAttribute]
private void set_Config(Config value);
    [CompilerGeneratedAttribute]
public ActorSystemSetup get_Setup();
    [CompilerGeneratedAttribute]
public bool get_HasCluster();
    [CompilerGeneratedAttribute]
public ProviderSelection get_ProviderSelectionType();
    [CompilerGeneratedAttribute]
public string get_ConfigVersion();
    [CompilerGeneratedAttribute]
private void set_ConfigVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ProviderClass();
    [CompilerGeneratedAttribute]
private void set_ProviderClass(string value);
    [CompilerGeneratedAttribute]
public string get_SupervisorStrategyClass();
    [CompilerGeneratedAttribute]
private void set_SupervisorStrategyClass(string value);
    [CompilerGeneratedAttribute]
public bool get_SerializeAllMessages();
    [CompilerGeneratedAttribute]
private void set_SerializeAllMessages(bool value);
    [CompilerGeneratedAttribute]
public bool get_SerializeAllCreators();
    [CompilerGeneratedAttribute]
private void set_SerializeAllCreators(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitActorTelemetry();
    [CompilerGeneratedAttribute]
public TimeSpan get_AskTimeout();
    [CompilerGeneratedAttribute]
private void set_AskTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CreationTimeout();
    [CompilerGeneratedAttribute]
private void set_CreationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_UnstartedPushTimeout();
    [CompilerGeneratedAttribute]
private void set_UnstartedPushTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_LogLevel();
    [CompilerGeneratedAttribute]
private void set_LogLevel(string value);
    [CompilerGeneratedAttribute]
public string get_StdoutLogLevel();
    [CompilerGeneratedAttribute]
private void set_StdoutLogLevel(string value);
    [CompilerGeneratedAttribute]
public MinimalLogger get_StdoutLogger();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Loggers();
    [CompilerGeneratedAttribute]
private void set_Loggers(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_LoggersDispatcher();
    [CompilerGeneratedAttribute]
private void set_LoggersDispatcher(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LoggerStartTimeout();
    [CompilerGeneratedAttribute]
private void set_LoggerStartTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_LoggerAsyncStart();
    [CompilerGeneratedAttribute]
private void set_LoggerAsyncStart(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogConfigOnStart();
    [CompilerGeneratedAttribute]
private void set_LogConfigOnStart(bool value);
    [CompilerGeneratedAttribute]
public ILogMessageFormatter get_LogFormatter();
    [CompilerGeneratedAttribute]
public LogFilterEvaluator get_LogFilter();
    [CompilerGeneratedAttribute]
public bool get_LogSerializerOverrideOnStart();
    [CompilerGeneratedAttribute]
private void set_LogSerializerOverrideOnStart(bool value);
    [CompilerGeneratedAttribute]
public int get_LogDeadLetters();
    [CompilerGeneratedAttribute]
private void set_LogDeadLetters(int value);
    [CompilerGeneratedAttribute]
public bool get_LogDeadLettersDuringShutdown();
    [CompilerGeneratedAttribute]
private void set_LogDeadLettersDuringShutdown(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_LogDeadLettersSuspendDuration();
    [CompilerGeneratedAttribute]
public bool get_AddLoggingReceive();
    [CompilerGeneratedAttribute]
private void set_AddLoggingReceive(bool value);
    [CompilerGeneratedAttribute]
public bool get_DebugAutoReceive();
    [CompilerGeneratedAttribute]
private void set_DebugAutoReceive(bool value);
    [CompilerGeneratedAttribute]
public bool get_DebugEventStream();
    [CompilerGeneratedAttribute]
private void set_DebugEventStream(bool value);
    [CompilerGeneratedAttribute]
public bool get_DebugUnhandledMessage();
    [CompilerGeneratedAttribute]
private void set_DebugUnhandledMessage(bool value);
    [CompilerGeneratedAttribute]
public bool get_DebugRouterMisconfiguration();
    [CompilerGeneratedAttribute]
private void set_DebugRouterMisconfiguration(bool value);
    [CompilerGeneratedAttribute]
public string get_Home();
    [CompilerGeneratedAttribute]
private void set_Home(string value);
    [CompilerGeneratedAttribute]
public bool get_DebugLifecycle();
    [CompilerGeneratedAttribute]
private void set_DebugLifecycle(bool value);
    [CompilerGeneratedAttribute]
public bool get_DebugTimerScheduler();
    [CompilerGeneratedAttribute]
private void set_DebugTimerScheduler(bool value);
    [CompilerGeneratedAttribute]
public bool get_FsmDebugEvent();
    [CompilerGeneratedAttribute]
private void set_FsmDebugEvent(bool value);
    [CompilerGeneratedAttribute]
public int get_DefaultVirtualNodesFactor();
    [CompilerGeneratedAttribute]
private void set_DefaultVirtualNodesFactor(int value);
    [CompilerGeneratedAttribute]
public string get_SchedulerClass();
    [CompilerGeneratedAttribute]
private void set_SchedulerClass(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SchedulerShutdownTimeout();
    [CompilerGeneratedAttribute]
private void set_SchedulerShutdownTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_CoordinatedShutdownTerminateActorSystem();
    [CompilerGeneratedAttribute]
private void set_CoordinatedShutdownTerminateActorSystem(bool value);
    [CompilerGeneratedAttribute]
public bool get_CoordinatedShutdownRunByActorSystemTerminate();
    [CompilerGeneratedAttribute]
private void set_CoordinatedShutdownRunByActorSystemTerminate(bool value);
    public virtual string ToString();
}
public class Akka.Actor.Setup.ActorSystemSetup : object {
    public static ActorSystemSetup Empty;
    private ImmutableDictionary`2<Type, Setup> _setups;
    internal ActorSystemSetup(ImmutableDictionary`2<Type, Setup> setups);
    private static ActorSystemSetup();
    public static ActorSystemSetup Create(Setup[] setup);
    public Option`1<T> Get();
    public ActorSystemSetup WithSetup(T setup);
    public ActorSystemSetup And(T setup);
    public virtual string ToString();
}
public abstract class Akka.Actor.Setup.Setup : object {
    public ActorSystemSetup And(Setup other);
}
internal class Akka.Actor.StartWatch : ValueType {
    [CompilerGeneratedAttribute]
private IActorRef <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    public IActorRef Target { get; private set; }
    public object Message { get; private set; }
    public StartWatch(IActorRef target, object message);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IActorRef get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(IActorRef value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(object value);
}
[ExtensionAttribute]
public static class Akka.Actor.StashFactory : object {
    [ExtensionAttribute]
public static IStash CreateStash(IActorContext context);
    [ExtensionAttribute]
public static IStash CreateStash(IActorContext context, IActorStash actorInstance);
    [ExtensionAttribute]
public static IStash CreateStash(IActorContext context, Type actorType);
}
public class Akka.Actor.StashOverflowException : AkkaException {
    public StashOverflowException(string message, Exception cause);
    protected StashOverflowException(SerializationInfo info, StreamingContext context);
}
public abstract class Akka.Actor.Status : object {
}
public class Akka.Actor.StoppingSupervisorStrategy : SupervisorStrategyConfigurator {
    public virtual SupervisorStrategy Create();
}
internal class Akka.Actor.StopWatch : ValueType {
    [CompilerGeneratedAttribute]
private IActorRef <Target>k__BackingField;
    public IActorRef Target { get; private set; }
    public StopWatch(IActorRef target);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IActorRef get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(IActorRef value);
}
public abstract class Akka.Actor.SupervisorStrategy : object {
    public static IDecider DefaultDecider;
    [CompilerGeneratedAttribute]
private bool <LoggingEnabled>k__BackingField;
    public static SupervisorStrategy DefaultStrategy;
    public static OneForOneStrategy StoppingStrategy;
    public IDecider Decider { get; }
    protected bool LoggingEnabled { get; protected set; }
    private static SupervisorStrategy();
    public abstract virtual IDecider get_Decider();
    protected abstract virtual Directive Handle(IActorRef child, Exception exception);
    public bool HandleFailure(ActorCell actorCell, IActorRef child, Exception cause, ChildRestartStats stats, IReadOnlyCollection`1<ChildRestartStats> children);
    protected void RestartChild(IActorRef child, Exception cause, bool suspendFirst);
    public abstract virtual void ProcessFailure(IActorContext context, bool restart, IActorRef child, Exception cause, ChildRestartStats stats, IReadOnlyCollection`1<ChildRestartStats> children);
    protected void ResumeChild(IActorRef child, Exception exception);
    protected virtual void LogFailure(IActorContext context, IActorRef child, Exception cause, Directive directive);
    [CompilerGeneratedAttribute]
protected bool get_LoggingEnabled();
    [CompilerGeneratedAttribute]
protected void set_LoggingEnabled(bool value);
    private static void Publish(IActorContext context, LogEvent logEvent);
    public abstract virtual void HandleChildTerminated(IActorContext actorContext, IActorRef child, IEnumerable`1<IInternalActorRef> children);
    public abstract virtual ISurrogate ToSurrogate(ActorSystem system);
}
public abstract class Akka.Actor.SupervisorStrategyConfigurator : object {
    public abstract virtual SupervisorStrategy Create();
    public static SupervisorStrategyConfigurator CreateConfigurator(string typeName);
}
public class Akka.Actor.SystemGuardianActor : ActorBase {
    private IActorRef _userGuardian;
    private HashSet`1<IActorRef> _terminationHooks;
    public SystemGuardianActor(IActorRef userGuardian);
    protected virtual bool Receive(object message);
    private bool Terminating(object message);
    private void StopWhenAllTerminationHooksDone(IActorRef terminatedActor);
    private void StopWhenAllTerminationHooksDone();
    protected virtual void PreRestart(Exception reason, object message);
}
public class Akka.Actor.Terminated : object {
    [CompilerGeneratedAttribute]
private IActorRef <ActorRef>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddressTerminated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExistenceConfirmed>k__BackingField;
    public IActorRef ActorRef { get; }
    public bool AddressTerminated { get; }
    public bool ExistenceConfirmed { get; }
    public Terminated(IActorRef actorRef, bool existenceConfirmed, bool addressTerminated);
    [CompilerGeneratedAttribute]
public IActorRef get_ActorRef();
    [CompilerGeneratedAttribute]
public bool get_AddressTerminated();
    [CompilerGeneratedAttribute]
public bool get_ExistenceConfirmed();
    public virtual string ToString();
    public sealed virtual bool Equals(Terminated other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Akka.Actor.TerminatedProps : Props {
    public virtual ActorBase NewActor();
}
[InternalApiAttribute]
public class Akka.Actor.UnstartedCell : object {
    private ActorSystemImpl _system;
    private RepointableActorRef _self;
    private Props _props;
    private IInternalActorRef _supervisor;
    private object _lock;
    private LinkedList`1<Envelope> _messageQueue;
    private LatestFirstSystemMessageList _sysMsgQueue;
    private TimeSpan _timeout;
    public ActorSystem System { get; }
    public ActorSystemImpl SystemImpl { get; }
    public IInternalActorRef Parent { get; }
    public IChildrenContainer ChildrenContainer { get; }
    public bool IsLocal { get; }
    public bool IsTerminated { get; }
    public bool HasMessages { get; }
    public int NumberOfMessages { get; }
    public IActorRef Self { get; }
    public Props Props { get; }
    public UnstartedCell(ActorSystemImpl system, RepointableActorRef self, Props props, IInternalActorRef supervisor);
    private void DrainSysMsgQueue(ICell cell);
    public void ReplaceWith(ICell cell);
    public sealed virtual ActorSystem get_System();
    public sealed virtual ActorSystemImpl get_SystemImpl();
    public sealed virtual void Start();
    public sealed virtual void Suspend();
    public sealed virtual void Resume(Exception causedByFailure);
    public sealed virtual void Restart(Exception cause);
    public sealed virtual void Stop();
    public sealed virtual IInternalActorRef get_Parent();
    public sealed virtual IEnumerable`1<IInternalActorRef> GetChildren();
    public sealed virtual IChildrenContainer get_ChildrenContainer();
    public sealed virtual IInternalActorRef GetSingleChild(string name);
    public sealed virtual IInternalActorRef GetChildByName(string name);
    public sealed virtual bool TryGetChildStatsByName(string name, IChildStats& child);
    public sealed virtual void SendMessage(IActorRef sender, object message);
    private void SendMessage(object message, IActorRef sender);
    public sealed virtual void SendSystemMessage(ISystemMessage message);
    public sealed virtual bool get_IsLocal();
    private bool CellIsReady(ICell cell);
    public sealed virtual bool get_IsTerminated();
    public sealed virtual bool get_HasMessages();
    public sealed virtual int get_NumberOfMessages();
    public sealed virtual IActorRef get_Self();
    public sealed virtual Props get_Props();
}
public abstract class Akka.Actor.UntypedActor : ActorBase {
    protected static IUntypedActorContext Context { get; }
    protected sealed virtual bool Receive(object message);
    protected void RunTask(Action action);
    protected void RunTask(Func`1<Task> action);
    protected abstract virtual void OnReceive(object message);
    protected void Become(UntypedReceive receive);
    protected void BecomeStacked(UntypedReceive receive);
    protected static IUntypedActorContext get_Context();
}
public abstract class Akka.Actor.UntypedActorWithStash : UntypedActor {
    [CompilerGeneratedAttribute]
private IStash <Stash>k__BackingField;
    public IStash Stash { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IStash get_Stash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Stash(IStash value);
}
public abstract class Akka.Actor.UntypedActorWithUnboundedStash : UntypedActor {
    [CompilerGeneratedAttribute]
private IStash <Stash>k__BackingField;
    public IStash Stash { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IStash get_Stash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Stash(IStash value);
}
public abstract class Akka.Actor.UntypedActorWithUnrestrictedStash : UntypedActor {
    [CompilerGeneratedAttribute]
private IStash <Stash>k__BackingField;
    public IStash Stash { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IStash get_Stash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Stash(IStash value);
}
public class Akka.Actor.UntypedReceive : MulticastDelegate {
    public UntypedReceive(object object, IntPtr method);
    public virtual void Invoke(object message);
    public virtual IAsyncResult BeginInvoke(object message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Akka.Actor.VirtualPathContainer : MinimalActorRef {
    private IInternalActorRef _parent;
    private ILoggingAdapter _log;
    private IActorRefProvider _provider;
    private ActorPath _path;
    private ConcurrentDictionary`2<string, IInternalActorRef> _children;
    public IActorRefProvider Provider { get; }
    public IInternalActorRef Parent { get; }
    public ActorPath Path { get; }
    public ILoggingAdapter Log { get; }
    public bool HasChildren { get; }
    public VirtualPathContainer(IActorRefProvider provider, ActorPath path, IInternalActorRef parent, ILoggingAdapter log);
    public virtual IActorRefProvider get_Provider();
    public virtual IInternalActorRef get_Parent();
    public virtual ActorPath get_Path();
    public ILoggingAdapter get_Log();
    protected bool TryGetChild(string name, IInternalActorRef& child);
    public void AddChild(string name, IInternalActorRef actor);
    public void RemoveChild(string name);
    public void RemoveChild(string name, IActorRef child);
    public virtual IActorRef GetChild(IReadOnlyList`1<string> name);
    public bool get_HasChildren();
    public void ForEachChild(Action`1<IInternalActorRef> action);
}
[ExtensionAttribute]
public static class Akka.Actor.WatchAsyncSupport : object {
    [AsyncStateMachineAttribute("Akka.Actor.WatchAsyncSupport/<WatchAsync>d__0")]
[ExtensionAttribute]
public static Task`1<bool> WatchAsync(IActorRef target, CancellationToken token);
}
public static class Akka.Actor.WrappedMessage : object {
    public static object Unwrap(object message);
}
[AttributeUsageAttribute("1534")]
public class Akka.Annotations.ApiMayChangeAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
public class Akka.Annotations.DoNotInheritAttribute : Attribute {
}
[AttributeUsageAttribute("1534")]
public class Akka.Annotations.InternalApiAttribute : Attribute {
}
[AttributeUsageAttribute("1534")]
public class Akka.Annotations.InternalStableApiAttribute : Attribute {
}
public class Akka.Configuration.Config : object {
    [CompilerGeneratedAttribute]
private Config <Fallback>k__BackingField;
    [CompilerGeneratedAttribute]
private HoconValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private HoconValue <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HoconSubstitution> <Substitutions>k__BackingField;
    public static Config Empty;
    public Config Fallback { get; private set; }
    public bool IsEmpty { get; }
    private HoconValue Value { get; private set; }
    public HoconValue Root { get; private set; }
    public IEnumerable`1<HoconSubstitution> Substitutions { get; public set; }
    public Config(HoconRoot root);
    public Config(Config source, Config fallback);
    private static Config();
    [CompilerGeneratedAttribute]
public Config get_Fallback();
    [CompilerGeneratedAttribute]
private void set_Fallback(Config value);
    public virtual bool get_IsEmpty();
    [CompilerGeneratedAttribute]
private HoconValue get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(HoconValue value);
    [CompilerGeneratedAttribute]
public virtual HoconValue get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(HoconValue value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<HoconSubstitution> get_Substitutions();
    [CompilerGeneratedAttribute]
public void set_Substitutions(IEnumerable`1<HoconSubstitution> value);
    protected Config Copy(Config fallback);
    private HoconValue GetNode(string path);
    public virtual bool GetBoolean(string path, bool default);
    public virtual Nullable`1<long> GetByteSize(string path);
    public virtual Nullable`1<long> GetByteSize(string path, Nullable`1<long> def);
    public virtual int GetInt(string path, int default);
    public virtual long GetLong(string path, long default);
    public virtual string GetString(string path, string default);
    public virtual float GetFloat(string path, float default);
    public virtual decimal GetDecimal(string path, decimal default);
    public virtual double GetDouble(string path, double default);
    public virtual IList`1<bool> GetBooleanList(string path);
    public virtual IList`1<decimal> GetDecimalList(string path);
    public virtual IList`1<float> GetFloatList(string path);
    public virtual IList`1<double> GetDoubleList(string path);
    public virtual IList`1<int> GetIntList(string path);
    public virtual IList`1<long> GetLongList(string path);
    public virtual IList`1<byte> GetByteList(string path);
    public virtual IList`1<string> GetStringList(string path);
    public virtual IList`1<string> GetStringList(string path, String[] defaultPaths);
    public virtual Config GetConfig(string path);
    public HoconValue GetValue(string path);
    public virtual TimeSpan GetTimeSpan(string path, Nullable`1<TimeSpan> default, bool allowInfinite);
    public virtual string ToString();
    public string ToString(bool includeFallback);
    public virtual Config WithFallback(Config fallback);
    public virtual bool HasPath(string path);
    public static Config op_Addition(Config config, string fallback);
    public static Config op_Addition(string configHocon, Config fallbackConfig);
    public static Config op_Implicit(string str);
    [IteratorStateMachineAttribute("Akka.Configuration.Config/<AsEnumerable>d__51")]
public virtual IEnumerable`1<KeyValuePair`2<string, HoconValue>> AsEnumerable();
    internal bool Contains(Config other);
    private bool Contains(Dictionary`2<string, HoconValue> other, string path);
}
[ExtensionAttribute]
public static class Akka.Configuration.ConfigExtensions : object {
    [ExtensionAttribute]
public static Config SafeWithFallback(Config config, Config fallback);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Config config);
}
public class Akka.Configuration.ConfigurationException : AkkaException {
    public ConfigurationException(string message);
    public ConfigurationException(string message, Exception exception);
    protected ConfigurationException(SerializationInfo info, StreamingContext context);
    public static ConfigurationException NullOrEmptyConfig(string path);
}
public class Akka.Configuration.ConfigurationFactory : object {
    public static Config Empty { get; }
    public static Config get_Empty();
    public static Config ParseString(string hocon, Func`2<string, HoconRoot> includeCallback);
    public static Config ParseString(string hocon);
    public static Config Load();
    public static Config Default();
    internal static Config FromResource(string resourceName);
    public static Config FromResource(string resourceName, object instanceInAssembly);
    public static Config FromResource(string resourceName);
    public static Config FromResource(string resourceName, Assembly assembly);
    public static Config FromObject(object source);
}
public class Akka.Configuration.Hocon.AkkaConfigurationSection : ConfigurationSection {
    private static string ConfigurationPropertyName;
    private Config _akkaConfig;
    public Config AkkaConfig { get; }
    [ConfigurationPropertyAttribute("hocon")]
public HoconConfigurationElement Hocon { get; public set; }
    public Config get_AkkaConfig();
    public HoconConfigurationElement get_Hocon();
    public void set_Hocon(HoconConfigurationElement value);
}
public abstract class Akka.Configuration.Hocon.CDataConfigurationElement : ConfigurationElement {
    protected static string ContentPropertyName;
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
}
public class Akka.Configuration.Hocon.HoconArray : List`1<HoconValue> {
    public sealed virtual bool IsString();
    public sealed virtual string GetString();
    public sealed virtual bool IsArray();
    public sealed virtual IList`1<HoconValue> GetArray();
    public virtual string ToString();
}
public class Akka.Configuration.Hocon.HoconConfigurationElement : CDataConfigurationElement {
    [ConfigurationPropertyAttribute("content")]
public string Content { get; public set; }
    public string get_Content();
    public void set_Content(string value);
}
public class Akka.Configuration.Hocon.HoconLiteral : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public sealed virtual bool IsString();
    public sealed virtual string GetString();
    public sealed virtual bool IsArray();
    public sealed virtual IList`1<HoconValue> GetArray();
    public virtual string ToString();
}
public class Akka.Configuration.Hocon.HoconObject : object {
    private static Regex EscapeRegex;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, HoconValue> <Items>k__BackingField;
    [JsonIgnoreAttribute]
public IDictionary`2<string, object> Unwrapped { get; }
    public Dictionary`2<string, HoconValue> Items { get; private set; }
    private static HoconObject();
    public IDictionary`2<string, object> get_Unwrapped();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, HoconValue> get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(Dictionary`2<string, HoconValue> value);
    public sealed virtual bool IsString();
    public sealed virtual string GetString();
    public sealed virtual bool IsArray();
    public sealed virtual IList`1<HoconValue> GetArray();
    public HoconValue GetKey(string key);
    public HoconValue GetOrCreateKey(string key);
    public virtual string ToString();
    public string ToString(int indent);
    private string QuoteIfNeeded(string text);
    public void Merge(HoconObject other);
    internal HoconObject MergeImmutable(HoconObject other);
}
public class Akka.Configuration.Hocon.HoconRoot : object {
    [CompilerGeneratedAttribute]
private HoconValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HoconSubstitution> <Substitutions>k__BackingField;
    public HoconValue Value { get; private set; }
    public IEnumerable`1<HoconSubstitution> Substitutions { get; private set; }
    public HoconRoot(HoconValue value, IEnumerable`1<HoconSubstitution> substitutions);
    public HoconRoot(HoconValue value);
    [CompilerGeneratedAttribute]
public HoconValue get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(HoconValue value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<HoconSubstitution> get_Substitutions();
    [CompilerGeneratedAttribute]
private void set_Substitutions(IEnumerable`1<HoconSubstitution> value);
}
public class Akka.Configuration.Hocon.HoconSubstitution : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private HoconValue <ResolvedValue>k__BackingField;
    public string Path { get; public set; }
    public HoconValue ResolvedValue { get; public set; }
    public HoconSubstitution(string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public HoconValue get_ResolvedValue();
    [CompilerGeneratedAttribute]
public void set_ResolvedValue(HoconValue value);
    public sealed virtual bool IsString();
    public sealed virtual string GetString();
    public sealed virtual bool IsArray();
    public sealed virtual IList`1<HoconValue> GetArray();
    public sealed virtual bool IsObject();
    public sealed virtual HoconObject GetObject();
}
public class Akka.Configuration.Hocon.HoconTokenizer : Tokenizer {
    private static string NotInUnquotedKey;
    private static string NotInUnquotedText;
    public HoconTokenizer(string text);
    public void PullWhitespaceAndComments();
    public string PullRestOfLine();
    public Token PullNext();
    private bool IsStartOfQuotedKey();
    public Token PullArrayEnd();
    public bool IsArrayEnd();
    public bool IsArrayStart();
    public Token PullArrayStart();
    public Token PullDot();
    public Token PullComma();
    public Token PullStartOfObject();
    public Token PullEndOfObject();
    public Token PullAssignment();
    public bool IsComma();
    public bool IsDot();
    public bool IsObjectStart();
    public bool IsEndOfObject();
    public bool IsAssignment();
    public bool IsStartOfQuotedText();
    public bool IsStartOfTripleQuotedText();
    public Token PullComment();
    public Token PullUnquotedKey();
    public bool IsUnquotedKey();
    public bool IsUnquotedKeyStart();
    public bool IsWhitespace();
    public bool IsWhitespaceOrComment();
    public Token PullTripleQuotedText();
    public Token PullQuotedText();
    public Token PullQuotedKey();
    public Token PullInclude();
    private string PullEscapeSequence();
    public bool IsStartOfComment();
    public Token PullValue();
    public bool IsSubstitutionStart();
    public bool IsInclude();
    public Token PullSubstitution();
    public bool IsSpaceOrTab();
    public bool IsStartSimpleValue();
    public Token PullSpaceOrTab();
    private Token PullUnquotedText();
    private bool IsUnquotedText();
    public Token PullSimpleValue();
    internal bool IsValue();
}
public class Akka.Configuration.Hocon.HoconValue : object {
    private static Regex EscapeRegex;
    private static Regex TimeSpanRegex;
    [CompilerGeneratedAttribute]
private List`1<IHoconElement> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AdoptedFromFallback>k__BackingField;
    [CompilerGeneratedAttribute]
private static ByteSize[] <ByteSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Char[] <Digits>k__BackingField;
    public bool IsEmpty { get; }
    public List`1<IHoconElement> Values { get; private set; }
    internal bool AdoptedFromFallback { get; private set; }
    private static ByteSize[] ByteSizes { get; }
    private static Char[] Digits { get; }
    public HoconValue(List`1<IHoconElement> values, bool adoptedFromFallback);
    private static HoconValue();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public List`1<IHoconElement> get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(List`1<IHoconElement> value);
    [CompilerGeneratedAttribute]
internal bool get_AdoptedFromFallback();
    [CompilerGeneratedAttribute]
private void set_AdoptedFromFallback(bool value);
    public Config ToConfig();
    public Config AtKey(string key);
    public sealed virtual HoconObject GetObject();
    public sealed virtual bool IsObject();
    public void AppendValue(IHoconElement value);
    public void Clear();
    public void NewValue(IHoconElement value);
    public bool IsString();
    private string ConcatString();
    public HoconValue GetChildObject(string key);
    public bool GetBoolean();
    public string GetString();
    public decimal GetDecimal();
    public float GetFloat();
    public double GetDouble();
    public long GetLong();
    public int GetInt();
    public byte GetByte();
    public IList`1<byte> GetByteList();
    public IList`1<int> GetIntList();
    public IList`1<long> GetLongList();
    public IList`1<bool> GetBooleanList();
    public IList`1<float> GetFloatList();
    public IList`1<double> GetDoubleList();
    public IList`1<decimal> GetDecimalList();
    public IList`1<string> GetStringList();
    public IList`1<HoconValue> GetArray();
    public bool IsArray();
    public TimeSpan GetTimeSpan(bool allowInfinite);
    private static double ParsePositiveValue(string v);
    [CompilerGeneratedAttribute]
private static ByteSize[] get_ByteSizes();
    [CompilerGeneratedAttribute]
private static Char[] get_Digits();
    public Nullable`1<long> GetByteSize();
    public virtual string ToString();
    public virtual string ToString(int indent);
    private string QuoteIfNeeded(string text);
}
public interface Akka.Configuration.Hocon.IHoconElement {
    public abstract virtual bool IsString();
    public abstract virtual string GetString();
    public abstract virtual bool IsArray();
    public abstract virtual IList`1<HoconValue> GetArray();
}
public interface Akka.Configuration.Hocon.IMightBeAHoconObject {
    public abstract virtual bool IsObject();
    public abstract virtual HoconObject GetObject();
}
public class Akka.Configuration.Hocon.Parser : object {
    private List`1<HoconSubstitution> _substitutions;
    private HoconTokenizer _reader;
    private HoconValue _root;
    private Func`2<string, HoconRoot> _includeCallback;
    public static HoconRoot Parse(string text, Func`2<string, HoconRoot> includeCallback);
    private HoconRoot ParseText(string text, Func`2<string, HoconRoot> includeCallback);
    private void ParseObject(HoconValue owner, bool root, string currentPath);
    private void ParseKeyContent(HoconValue value, string currentPath);
    public void ParseValue(HoconValue owner, string currentPath);
    private void ParseTrailingWhitespace(HoconValue owner);
    private static HoconSubstitution ParseSubstitution(string value);
    public HoconArray ParseArray(string currentPath);
    private void IgnoreComma();
}
public class Akka.Configuration.Hocon.Token : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenType <Type>k__BackingField;
    public string Value { get; public set; }
    public TokenType Type { get; public set; }
    public Token(TokenType type);
    public Token(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public TokenType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TokenType value);
    public static Token Key(string key);
    public static Token Substitution(string path);
    public static Token LiteralValue(string value);
    internal static Token Include(string path);
}
public class Akka.Configuration.Hocon.Tokenizer : object {
    private string _text;
    private int _index;
    private Stack`1<int> _indexStack;
    public bool EoF { get; }
    public Tokenizer(string text);
    public void Push();
    public void Pop();
    public bool get_EoF();
    public bool Matches(string pattern);
    protected string PickErrorLine(Int32& index);
    public string Take(int length);
    public bool Matches(String[] patterns);
    public char Peek();
    public char Take();
    public void PullWhitespace();
}
public enum Akka.Configuration.Hocon.TokenType : Enum {
    public int value__;
    public static TokenType Comment;
    public static TokenType Key;
    public static TokenType LiteralValue;
    public static TokenType Assign;
    public static TokenType ObjectStart;
    public static TokenType ObjectEnd;
    public static TokenType Dot;
    public static TokenType EoF;
    public static TokenType ArrayStart;
    public static TokenType ArrayEnd;
    public static TokenType Comma;
    public static TokenType Substitute;
    public static TokenType Include;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Akka.Delivery.ConsumerController : object {
    internal static void AssertLocalConsumer(IActorRef consumer);
    public static Props Create(IActorRefFactory actorRefFactory, Option`1<IActorRef> producerControllerReference, Settings settings);
    internal static Props CreateWithFuzzing(IActorRefFactory actorRefFactory, Option`1<IActorRef> producerControllerReference, Func`2<object, double> fuzzing, Settings settings);
    private static Props ConsumerControllerProps(IActorContext context, Option`1<IActorRef> producerControllerReference, Settings settings, Func`2<object, double> fuzzing);
    private static Props ConsumerControllerProps(ActorSystem system, Option`1<IActorRef> producerControllerReference, Settings settings, Func`2<object, double> fuzzing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Akka.Delivery.DurableProducerQueue : object {
    public static string NoQualifier;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[InternalApiAttribute]
public class Akka.Delivery.Internal.ChunkedMessage : ValueType {
    [CompilerGeneratedAttribute]
private ByteString <SerializedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FirstChunk>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LastChunk>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SerializerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Manifest>k__BackingField;
    public ByteString SerializedMessage { get; }
    public bool FirstChunk { get; }
    public bool LastChunk { get; }
    public int SerializerId { get; }
    public string Manifest { get; }
    public ChunkedMessage(ByteString serializedMessage, bool firstChunk, bool lastChunk, int serializerId, string manifest);
    [CompilerGeneratedAttribute]
public ByteString get_SerializedMessage();
    [CompilerGeneratedAttribute]
public bool get_FirstChunk();
    [CompilerGeneratedAttribute]
public bool get_LastChunk();
    [CompilerGeneratedAttribute]
public int get_SerializerId();
    [CompilerGeneratedAttribute]
public string get_Manifest();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Akka.Delivery.Internal.ConsumerController`1 : ReceiveActor {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, double> _fuzzingControl;
    private ILoggingAdapter _log;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RetryTimer<T> _retryTimer;
    private Serialization _serialization;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Option`1<IActorRef> _producerControllerRegistration;
    [CompilerGeneratedAttribute]
private Settings <Settings>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private State<T> <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private IStash <Stash>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimerScheduler <Timers>k__BackingField;
    public Settings Settings { get; }
    [NullableAttribute("0")]
public State<T> CurrentState { get; private set; }
    public bool ResendLost { get; }
    public IStash Stash { get; public set; }
    public ITimerScheduler Timers { get; public set; }
    public ConsumerController`1(Option`1<IActorRef> producerControllerRegistration, Settings settings, Func`2<object, double> fuzzingControl);
    [CompilerGeneratedAttribute]
public Settings get_Settings();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public State<T> get_CurrentState();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void set_CurrentState(State<T> value);
    public bool get_ResendLost();
    [CompilerGeneratedAttribute]
public sealed virtual IStash get_Stash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Stash(IStash value);
    [CompilerGeneratedAttribute]
public sealed virtual ITimerScheduler get_Timers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timers(ITimerScheduler value);
    protected internal virtual bool AroundReceive(Receive receive, object message);
    private void WaitForStart();
    private void Active();
    private void Resending();
    private void WaitingForConfirmation(SequencedMessage`1<T> sequencedMessage);
    protected virtual void PostStop();
    private void ReceiveUnexpectedConfirmed(Confirmed c);
    private void ReceiveRetry(Action nextBehavior);
    [NullableContextAttribute("0")]
private State<T> RetryRequest();
    private void ReceiveDeliverThenStop(Action nextBehavior);
    private void ReceiveRegisterToProducerController(RegisterToProducerController`1<T> reg, Action nextBehavior);
    private void ReceiveConsumerTerminated(IActorRef consumer);
    private void ReceiveStart(Start`1<T> start, Action nextBehavior);
    private void ReceiveChangedProducer(SequencedMessage`1<T> seqMsg);
    private void LogChangedProducer(SequencedMessage`1<T> seqMsg);
    private void Deliver(SequencedMessage`1<T> seqMsg);
    private SequencedMessage`1<T> AssembleChunks(ImmutableList`1<SequencedMessage`1<T>> collectedChunks);
    [NullableContextAttribute("0")]
private static State<T> InitialState(Start`1<T> start, Option`1<IActorRef> registering, bool stopping);
    [CompilerGeneratedAttribute]
private void <Active>b__25_0(SequencedMessage`1<T> seqMsg);
    [CompilerGeneratedAttribute]
private void <Active>b__25_1(Retry<T> _);
    [CompilerGeneratedAttribute]
private void <Active>b__25_6();
    [CompilerGeneratedAttribute]
private void <Active>b__25_2(Start`1<T> start);
    [CompilerGeneratedAttribute]
private void <Active>b__25_3(ConsumerTerminated<T> t);
    [CompilerGeneratedAttribute]
private void <Active>b__25_4(RegisterToProducerController`1<T> controller);
    [CompilerGeneratedAttribute]
private void <Active>b__25_5(DeliverThenStop`1<T> _);
    [CompilerGeneratedAttribute]
private void <Resending>b__26_0(SequencedMessage`1<T> seqMsg);
    [CompilerGeneratedAttribute]
private void <Resending>b__26_1(Retry<T> _);
    [CompilerGeneratedAttribute]
private void <Resending>b__26_6();
    [CompilerGeneratedAttribute]
private void <Resending>b__26_2(Start`1<T> start);
    [CompilerGeneratedAttribute]
private void <Resending>b__26_3(ConsumerTerminated<T> t);
    [CompilerGeneratedAttribute]
private void <Resending>b__26_4(RegisterToProducerController`1<T> controller);
    [CompilerGeneratedAttribute]
private void <Resending>b__26_5(DeliverThenStop`1<T> _);
}
[InternalApiAttribute]
public interface Akka.Delivery.Internal.IDeliverySerializable {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[InternalApiAttribute]
public class Akka.Delivery.Internal.MessageOrChunk`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ChunkedMessage> <Chunk>k__BackingField;
    public T Message { get; }
    public Nullable`1<ChunkedMessage> Chunk { get; }
    public bool IsMessage { get; }
    [NullableContextAttribute("1")]
public MessageOrChunk`1(T message);
    public MessageOrChunk`1(ChunkedMessage chunkedMessage);
    [CompilerGeneratedAttribute]
public T get_Message();
    [CompilerGeneratedAttribute]
public Nullable`1<ChunkedMessage> get_Chunk();
    public bool get_IsMessage();
    [NullableContextAttribute("1")]
public static MessageOrChunk`1<T> op_Implicit(T message);
    [NullableContextAttribute("1")]
public static T op_Implicit(MessageOrChunk`1<T> message);
    public static ChunkedMessage op_Implicit(MessageOrChunk`1<T> message);
    public static MessageOrChunk`1<T> op_Implicit(ChunkedMessage chunkedMessage);
    public sealed virtual bool Equals(MessageOrChunk`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Akka.Delivery.Internal.ProducerController`1 : ReceiveActor {
    private static Func`2<SequencedMessage`1<T>, object> DefaultSend;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Option`1<Props> _durableProducerQueueProps;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, double> _fuzzingControl;
    private ILoggingAdapter _log;
    private Lazy`1<Serialization> _serialization;
    private ITimeProvider _timeProvider;
    [CompilerGeneratedAttribute]
private string <ProducerId>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private State<T> <CurrentState>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Option`1<IActorRef> <DurableProducerQueueRef>k__BackingField;
    [CompilerGeneratedAttribute]
private Settings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private ITimerScheduler <Timers>k__BackingField;
    public string ProducerId { get; }
    [NullableAttribute("0")]
public State<T> CurrentState { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<IActorRef> DurableProducerQueueRef { get; private set; }
    public Settings Settings { get; }
    public ITimerScheduler Timers { get; public set; }
    public ProducerController`1(string producerId, Option`1<Props> durableProducerQueue, Action`1<SequencedMessage`1<T>> sendAdapter, Settings settings, ITimeProvider timeProvider, Func`2<object, double> fuzzingControl);
    [NullableContextAttribute("2")]
public ProducerController`1(string producerId, Option`1<Props> durableProducerQueue, Settings settings, ITimeProvider timeProvider, Func`2<object, double> fuzzingControl);
    private static ProducerController`1();
    [CompilerGeneratedAttribute]
public string get_ProducerId();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public State<T> get_CurrentState();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void set_CurrentState(State<T> value);
    [CompilerGeneratedAttribute]
public Option`1<IActorRef> get_DurableProducerQueueRef();
    [CompilerGeneratedAttribute]
private void set_DurableProducerQueueRef(Option`1<IActorRef> value);
    [CompilerGeneratedAttribute]
public Settings get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual ITimerScheduler get_Timers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timers(ITimerScheduler value);
    protected internal virtual bool AroundReceive(Receive receive, object message);
    private void WaitingForActivation(Option`1<IActorRef> consumerController, Action`1<State<T>> becomeActive);
    [NullableContextAttribute("0")]
private void BecomeActive(State<T> state);
    private void Active();
    protected virtual void PreStart();
    private void CheckOnMsgRequestedState();
    private void CheckReceiveMessageRemainingChunkState();
    private void OnMsg(SequencedMessage`1<T> seqMsg, ImmutableDictionary`2<long, IActorRef> newReplyAfterStore, ImmutableList`1<SequencedMessage`1<T>> remainingChunks);
    [NullableContextAttribute("0")]
private State<T> OnAck(long newConfirmedSeqNr);
    private void ReceiveRequest(long newConfirmedSeqNr, long newRequestedSeqNr, bool supportResend, bool viaTimeout);
    private void ReceiveAck(long newConfirmedSeqNr);
    private Option`1<IActorRef> AskLoadState();
    private void AskLoadState(Option`1<IActorRef> durableProducerQueue, int attempt);
    private static Option`1<State`1<T>> CreateInitialState(bool hasDurableQueue);
    [NullableContextAttribute("0")]
private State<T> CreateState(IActorRef producer, Option`1<IActorRef> consumerController, State`1<T> loadedState);
    private void ResendUnconfirmed(ImmutableList`1<SequencedMessage`1<T>> newUnconfirmed);
    private void ReceiveResendFirstUnconfirmed();
    private void ReceiveResendFirst();
    private void ReceiveStart(Start`1<T> start);
    private void ReceiveRegisterConsumer(IActorRef consumerController);
    private void ReceiveSendChunk();
    private ImmutableList`1<SequencedMessage`1<T>> Chunk(T msg, bool ack, Serialization serialization);
    [IteratorStateMachineAttribute("Akka.Delivery.Internal.ProducerController`1/<CreateChunks>d__49")]
internal static IEnumerable`1<ChunkedMessage> CreateChunks(T msg, int chunkSize, Serialization serialization);
    private void ReceiveStoreMessageSentCompleted(long seqNr);
    private void ReceiveStoreMessageSentFailed(StoreMessageSentFailed`1<T> f);
    private void ReceiveResend(long fromSeqNr);
    private void StoreMessageSent(MessageSent`1<T> messageSent, int attempt);
    [CompilerGeneratedAttribute]
private void <Active>b__30_0(MessageWithConfirmation`1<T> sendNext);
    [CompilerGeneratedAttribute]
private void <Active>b__30_1(T sendNext);
    [CompilerGeneratedAttribute]
private void <Active>b__30_2(StoreMessageSentCompleted`1<T> completed);
    [CompilerGeneratedAttribute]
private void <Active>b__30_3(Request r);
    [CompilerGeneratedAttribute]
private void <Active>b__30_4(Ack ack);
    [CompilerGeneratedAttribute]
private void <Active>b__30_5(SendChunk _);
    [CompilerGeneratedAttribute]
private void <Active>b__30_6(Resend resend);
    [CompilerGeneratedAttribute]
private void <Active>b__30_7(ResendFirst _);
    [CompilerGeneratedAttribute]
private void <Active>b__30_8(ResendFirstUnconfirmed _);
    [CompilerGeneratedAttribute]
private void <Active>b__30_9(RegisterConsumer`1<T> c);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IActorRef <AskLoadState>b__38_0(Props p);
    [CompilerGeneratedAttribute]
internal static LoadState <AskLoadState>g__Mapper|39_1(IActorRef r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Akka.Delivery.ProducerController : object {
    internal static void AssertLocalProducer(IActorRef producer);
    public static Props Create(IActorRefFactory actorRefFactory, string producerId, Option`1<Props> durableProducerQueue, Settings settings, Action`1<SequencedMessage`1<T>> sendAdapter);
    internal static Props CreateWithFuzzing(IActorRefFactory actorRefFactory, string producerId, Func`2<object, double> fuzzing, Option`1<Props> durableProducerQueue, Settings settings, Action`1<SequencedMessage`1<T>> sendAdapter);
    private static Props ProducerControllerProps(IActorContext context, string producerId, Option`1<Props> durableProducerQueue, Settings settings, Action`1<SequencedMessage`1<T>> sendAdapter, Func`2<object, double> fuzzing);
    private static Props ProducerControllerProps(ActorSystem actorSystem, string producerId, Option`1<Props> durableProducerQueue, Settings settings, Action`1<SequencedMessage`1<T>> sendAdapter, Func`2<object, double> fuzzing);
}
public class Akka.Dispatch.ActionRunnable : object {
    private Action _action;
    public ActionRunnable(Action action);
    public sealed virtual void Run();
}
public class Akka.Dispatch.ActionWithStateRunnable : object {
    private Action`1<object> _actionWithState;
    private object _state;
    public ActionWithStateRunnable(Action`1<object> actionWithState, object state);
    public sealed virtual void Run();
}
public class Akka.Dispatch.ActorTaskScheduler : TaskScheduler {
    private ActorCell _actorCell;
    [CompilerGeneratedAttribute]
private object <CurrentMessage>k__BackingField;
    public object CurrentMessage { get; private set; }
    public int MaximumConcurrencyLevel { get; }
    internal ActorTaskScheduler(ActorCell actorCell);
    [CompilerGeneratedAttribute]
public object get_CurrentMessage();
    [CompilerGeneratedAttribute]
private void set_CurrentMessage(object value);
    protected virtual void OnBeforeTaskStarted();
    protected virtual void OnAfterTaskCompleted();
    public virtual int get_MaximumConcurrencyLevel();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    private void ScheduleTask(Task task);
    internal void ExecuteTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    public static void RunTask(Action action);
    public static void RunTask(Func`1<Task> asyncAction);
    private static Exception GetTaskException(Task task);
    private static Exception TryUnwrapAggregateException(AggregateException aggregateException);
}
public class Akka.Dispatch.BoundedDequeBasedMailbox : MailboxType {
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PushTimeout>k__BackingField;
    public int Capacity { get; }
    public TimeSpan PushTimeout { get; }
    public BoundedDequeBasedMailbox(Settings settings, Config config);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_PushTimeout();
    public virtual IMessageQueue Create(IActorRef owner, ActorSystem system);
}
public class Akka.Dispatch.BoundedMailbox : MailboxType {
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PushTimeout>k__BackingField;
    public int Capacity { get; }
    public TimeSpan PushTimeout { get; }
    public BoundedMailbox(Settings settings, Config config);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_PushTimeout();
    public virtual IMessageQueue Create(IActorRef owner, ActorSystem system);
}
[InternalApiAttribute]
internal class Akka.Dispatch.CachingConfig : Config {
    private static Config EmptyConfig;
    private static IPathEntry InvalidPathEntry;
    private static IPathEntry NonExistingPathEntry;
    private static IPathEntry EmptyPathEntry;
    private Config _config;
    private ConcurrentDictionary`2<string, IPathEntry> _entryMap;
    public HoconValue Root { get; }
    public bool IsEmpty { get; }
    public CachingConfig(Config config);
    private static CachingConfig();
    private IPathEntry GetPathEntry(string path);
    public virtual HoconValue get_Root();
    public virtual Config WithFallback(Config fallback);
    public virtual bool HasPath(string path);
    public virtual bool get_IsEmpty();
    public virtual IEnumerable`1<KeyValuePair`2<string, HoconValue>> AsEnumerable();
    public virtual bool GetBoolean(string path, bool default);
    public virtual int GetInt(string path, int default);
    public virtual long GetLong(string path, long default);
    public virtual double GetDouble(string path, double default);
    public virtual string GetString(string path, string default);
    public virtual decimal GetDecimal(string path, decimal default);
    public virtual IList`1<bool> GetBooleanList(string path);
    public virtual IList`1<byte> GetByteList(string path);
    public virtual Nullable`1<long> GetByteSize(string path);
    public virtual IList`1<decimal> GetDecimalList(string path);
    public virtual IList`1<double> GetDoubleList(string path);
    public virtual float GetFloat(string path, float default);
    public virtual IList`1<float> GetFloatList(string path);
    public virtual IList`1<int> GetIntList(string path);
    public virtual IList`1<long> GetLongList(string path);
    public virtual IList`1<string> GetStringList(string path, String[] strings);
    public virtual TimeSpan GetTimeSpan(string path, Nullable`1<TimeSpan> default, bool allowInfinite);
    public virtual Config GetConfig(string path);
}
internal class Akka.Dispatch.ChannelExecutorConfigurator : ExecutorServiceConfigurator {
    private static Config PriorityDefault;
    [CompilerGeneratedAttribute]
private TaskSchedulerPriority <Priority>k__BackingField;
    public TaskSchedulerPriority Priority { get; }
    public ChannelExecutorConfigurator(Config config, IDispatcherPrerequisites prerequisites);
    private static ChannelExecutorConfigurator();
    [CompilerGeneratedAttribute]
public TaskSchedulerPriority get_Priority();
    public virtual ExecutorService Produce(string id);
}
public class Akka.Dispatch.ChannelTaskScheduler : object {
    [ThreadStaticAttribute]
private static TaskSchedulerPriority _threadPriority;
    private Task _controlTask;
    private CancellationTokenSource _cts;
    private Timer _timer;
    private Task[] _coworkers;
    private int _maximumConcurrencyLevel;
    private int _maxWork;
    private int _workInterval;
    private int _workStep;
    private PriorityTaskScheduler _highScheduler;
    private PriorityTaskScheduler _normalScheduler;
    private PriorityTaskScheduler _lowScheduler;
    private PriorityTaskScheduler _idleScheduler;
    public TaskScheduler High { get; }
    public TaskScheduler Normal { get; }
    public TaskScheduler Low { get; }
    public TaskScheduler Idle { get; }
    public ChannelTaskScheduler(ExtendedActorSystem system);
    public TaskScheduler get_High();
    public TaskScheduler get_Normal();
    public TaskScheduler get_Low();
    public TaskScheduler get_Idle();
    public static ChannelTaskScheduler Get(ActorSystem system);
    public TaskScheduler GetScheduler(TaskSchedulerPriority priority);
    [AsyncStateMachineAttribute("Akka.Dispatch.ChannelTaskScheduler/<ControlAsync>d__24")]
private Task ControlAsync();
    private void ScheduleCoWorkers(object state);
    private void Worker(object state);
    private int DoWork(int workerId);
    public sealed virtual void Dispose();
}
public class Akka.Dispatch.ChannelTaskSchedulerProvider : ExtensionIdProvider`1<ChannelTaskScheduler> {
    public virtual ChannelTaskScheduler CreateExtension(ExtendedActorSystem system);
}
public class Akka.Dispatch.CurrentSynchronizationContextDispatcher : Dispatcher {
    private ActorCell modreq(System.Runtime.CompilerServices.IsVolatile) _owner;
    public CurrentSynchronizationContextDispatcher(MessageDispatcherConfigurator configurator, string id, int throughput, Nullable`1<long> throughputDeadlineTime, ExecutorServiceFactory executorServiceFactory, TimeSpan shutdownTimeout);
    internal virtual void Register(ActorCell actor);
    internal virtual void Unregister(ActorCell actor);
}
internal class Akka.Dispatch.CurrentSynchronizationContextDispatcherConfigurator : MessageDispatcherConfigurator {
    private ExecutorServiceConfigurator _executorServiceConfigurator;
    public CurrentSynchronizationContextDispatcherConfigurator(Config config, IDispatcherPrerequisites prerequisites);
    public virtual MessageDispatcher Dispatcher();
}
internal class Akka.Dispatch.CurrentSynchronizationContextExecutorServiceFactory : ExecutorServiceConfigurator {
    public CurrentSynchronizationContextExecutorServiceFactory(Config config, IDispatcherPrerequisites prerequisites);
    public virtual ExecutorService Produce(string id);
}
internal static class Akka.Dispatch.DedicatedThreadPoolConfigHelpers : object {
    internal static DedicatedThreadPoolSettings DefaultSingleThreadPoolSettings;
    private static DedicatedThreadPoolConfigHelpers();
    internal static Nullable`1<TimeSpan> GetSafeDeadlockTimeout(Config cfg);
    internal static ThreadType ConfigureThreadType(string threadType);
}
public class Akka.Dispatch.DefaultDispatcherPrerequisites : object {
    [CompilerGeneratedAttribute]
private EventStream <EventStream>k__BackingField;
    [CompilerGeneratedAttribute]
private IScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private Settings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private Mailboxes <Mailboxes>k__BackingField;
    public EventStream EventStream { get; private set; }
    public IScheduler Scheduler { get; private set; }
    public Settings Settings { get; private set; }
    public Mailboxes Mailboxes { get; private set; }
    public DefaultDispatcherPrerequisites(EventStream eventStream, IScheduler scheduler, Settings settings, Mailboxes mailboxes);
    [CompilerGeneratedAttribute]
public sealed virtual EventStream get_EventStream();
    [CompilerGeneratedAttribute]
private void set_EventStream(EventStream value);
    [CompilerGeneratedAttribute]
public sealed virtual IScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
private void set_Scheduler(IScheduler value);
    [CompilerGeneratedAttribute]
public sealed virtual Settings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(Settings value);
    [CompilerGeneratedAttribute]
public sealed virtual Mailboxes get_Mailboxes();
    [CompilerGeneratedAttribute]
private void set_Mailboxes(Mailboxes value);
}
internal class Akka.Dispatch.DefaultTaskSchedulerExecutorConfigurator : ExecutorServiceConfigurator {
    public DefaultTaskSchedulerExecutorConfigurator(Config config, IDispatcherPrerequisites prerequisites);
    public virtual ExecutorService Produce(string id);
}
public class Akka.Dispatch.Dispatcher : MessageDispatcher {
    private LazyExecutorServiceDelegate _executorService;
    private ExecutorService Executor { get; }
    public Dispatcher(MessageDispatcherConfigurator configurator, string id, int throughput, Nullable`1<long> throughputDeadlineTime, ExecutorServiceFactory executorServiceFactory, TimeSpan shutdownTimeout);
    private ExecutorService get_Executor();
    protected virtual void ExecuteTask(IRunnable run);
    [InternalApiAttribute]
protected virtual void Shutdown();
}
public class Akka.Dispatch.DispatcherConfigurator : MessageDispatcherConfigurator {
    private MessageDispatcher _instance;
    public DispatcherConfigurator(Config config, IDispatcherPrerequisites prerequisites);
    public virtual MessageDispatcher Dispatcher();
}
public class Akka.Dispatch.Dispatchers : object {
    public static string DefaultDispatcherId;
    public static string DefaultBlockingDispatcherId;
    internal static string InternalDispatcherId;
    private static int MaxDispatcherAliasDepth;
    public static string SynchronizedDispatcherId;
    private ActorSystem _system;
    private Config _cachingConfig;
    private MessageDispatcher _defaultGlobalDispatcher;
    private ILoggingAdapter _logger;
    private ConcurrentDictionary`2<string, MessageDispatcherConfigurator> _dispatcherConfigurators;
    [CompilerGeneratedAttribute]
private MessageDispatcher <InternalDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private IDispatcherPrerequisites <Prerequisites>k__BackingField;
    private static Config ForkJoinExecutorConfig;
    private static Config CurrentSynchronizationContextExecutorConfig;
    private static Config TaskExecutorConfig;
    public MessageDispatcher DefaultGlobalDispatcher { get; }
    internal MessageDispatcher InternalDispatcher { get; }
    public Config DefaultDispatcherConfig { get; }
    public IDispatcherPrerequisites Prerequisites { get; private set; }
    public Dispatchers(ActorSystem system, IDispatcherPrerequisites prerequisites, ILoggingAdapter logger);
    private static Dispatchers();
    [InternalApiAttribute]
public static Config GetConfig(Config config, string id, int depth);
    public MessageDispatcher get_DefaultGlobalDispatcher();
    [CompilerGeneratedAttribute]
internal MessageDispatcher get_InternalDispatcher();
    public Config get_DefaultDispatcherConfig();
    internal void ReloadPrerequisites(IDispatcherPrerequisites prerequisites);
    [CompilerGeneratedAttribute]
public IDispatcherPrerequisites get_Prerequisites();
    [CompilerGeneratedAttribute]
private void set_Prerequisites(IDispatcherPrerequisites value);
    public MessageDispatcher Lookup(string dispatcherName);
    public bool HasDispatcher(string id);
    private MessageDispatcherConfigurator LookupConfigurator(string id);
    internal MessageDispatcher From(Config cfg);
    public bool RegisterConfigurator(string id, MessageDispatcherConfigurator configurator);
    private Config Config(string id);
    private Config Config(string id, Config appConfig);
    private static Config IdConfig(string id);
    private MessageDispatcherConfigurator ConfiguratorFrom(Config cfg);
}
public abstract class Akka.Dispatch.ExecutorService : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; private set; }
    protected ExecutorService(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    public abstract virtual void Execute(IRunnable run);
    public abstract virtual void Shutdown();
}
[InternalApiAttribute]
public abstract class Akka.Dispatch.ExecutorServiceConfigurator : ExecutorServiceFactory {
    [CompilerGeneratedAttribute]
private Config <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private IDispatcherPrerequisites <Prerequisites>k__BackingField;
    public Config Config { get; private set; }
    public IDispatcherPrerequisites Prerequisites { get; private set; }
    protected ExecutorServiceConfigurator(Config config, IDispatcherPrerequisites prerequisites);
    [CompilerGeneratedAttribute]
public Config get_Config();
    [CompilerGeneratedAttribute]
private void set_Config(Config value);
    [CompilerGeneratedAttribute]
public IDispatcherPrerequisites get_Prerequisites();
    [CompilerGeneratedAttribute]
private void set_Prerequisites(IDispatcherPrerequisites value);
}
[InternalApiAttribute]
public abstract class Akka.Dispatch.ExecutorServiceFactory : object {
    public abstract virtual ExecutorService Produce(string id);
}
internal class Akka.Dispatch.FixedConcurrencyTaskScheduler : TaskScheduler {
    [ThreadStaticAttribute]
private static bool _threadRunning;
    private ConcurrentQueue`1<Task> _tasks;
    private int _readers;
    [CompilerGeneratedAttribute]
private int <MaximumConcurrencyLevel>k__BackingField;
    public int MaximumConcurrencyLevel { get; }
    public FixedConcurrencyTaskScheduler(int degreeOfParallelism);
    [CompilerGeneratedAttribute]
public virtual int get_MaximumConcurrencyLevel();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual bool TryDequeue(Task task);
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    public void ReadChannel();
    [CompilerGeneratedAttribute]
private void <QueueTask>b__9_0(object _);
}
internal class Akka.Dispatch.ForkJoinExecutor : ExecutorService {
    private DedicatedThreadPool _dedicatedThreadPool;
    private byte _shuttingDown;
    public ForkJoinExecutor(string id, DedicatedThreadPoolSettings poolSettings);
    public virtual void Execute(IRunnable run);
    public virtual void Shutdown();
}
internal class Akka.Dispatch.ForkJoinExecutorServiceFactory : ExecutorServiceConfigurator {
    public static Config SingleThreadDefault;
    private DedicatedThreadPoolSettings _threadPoolConfiguration;
    public ForkJoinExecutorServiceFactory(Config config, IDispatcherPrerequisites prerequisites);
    private static ForkJoinExecutorServiceFactory();
    public virtual ExecutorService Produce(string id);
    private static DedicatedThreadPoolSettings ConfigureSettings(Config config);
}
internal class Akka.Dispatch.FullThreadPoolExecutorServiceImpl : ThreadPoolExecutorService {
    public FullThreadPoolExecutorServiceImpl(string id);
    public virtual void Execute(IRunnable run);
}
public class Akka.Dispatch.FutureActor : ActorBase {
    private IActorRef respondTo;
    private TaskCompletionSource`1<object> result;
    public FutureActor(TaskCompletionSource`1<object> completionSource, IActorRef respondTo);
    protected virtual bool Receive(object message);
}
public interface Akka.Dispatch.IBlockingMessageQueueSemantics {
    public TimeSpan BlockTimeOut { get; public set; }
    public abstract virtual TimeSpan get_BlockTimeOut();
    public abstract virtual void set_BlockTimeOut(TimeSpan value);
}
public interface Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics {
}
public interface Akka.Dispatch.IBoundedMessageQueueSemantics {
    public TimeSpan PushTimeOut { get; }
    public abstract virtual TimeSpan get_PushTimeOut();
}
public interface Akka.Dispatch.IDequeBasedMessageQueueSemantics {
    public abstract virtual void EnqueueFirst(Envelope envelope);
}
public interface Akka.Dispatch.IDispatcherPrerequisites {
    public EventStream EventStream { get; }
    public IScheduler Scheduler { get; }
    public Settings Settings { get; }
    public Mailboxes Mailboxes { get; }
    public abstract virtual EventStream get_EventStream();
    public abstract virtual IScheduler get_Scheduler();
    public abstract virtual Settings get_Settings();
    public abstract virtual Mailboxes get_Mailboxes();
}
public interface Akka.Dispatch.IMultipleConsumerSemantics {
}
public interface Akka.Dispatch.IProducesMessageQueue`1 {
}
public interface Akka.Dispatch.IProducesPushTimeoutSemanticsMailbox {
    public TimeSpan PushTimeout { get; }
    public abstract virtual TimeSpan get_PushTimeout();
}
public interface Akka.Dispatch.IRequiresMessageQueue`1 {
}
public interface Akka.Dispatch.IRunnable {
    public abstract virtual void Run();
}
public interface Akka.Dispatch.ISemantics {
}
public interface Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics {
}
public interface Akka.Dispatch.IUnboundedMessageQueueSemantics {
}
public class Akka.Dispatch.Mailbox : object {
    private ActorCell modreq(System.Runtime.CompilerServices.IsVolatile) _actor;
    private SystemMessage modreq(System.Runtime.CompilerServices.IsVolatile) _systemQueueDoNotCallMeDirectly;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _statusDotNotCallMeDirectly;
    [CompilerGeneratedAttribute]
private IMessageQueue <MessageQueue>k__BackingField;
    public IMessageQueue MessageQueue { get; }
    internal bool HasMessages { get; }
    internal int NumberOfMessages { get; }
    internal LatestFirstSystemMessageList SystemQueue { get; }
    public MessageDispatcher Dispatcher { get; }
    internal ActorCell Actor { get; }
    internal bool HasSystemMessages { get; }
    public Mailbox(IMessageQueue messageQueue);
    [CompilerGeneratedAttribute]
public IMessageQueue get_MessageQueue();
    internal void Enqueue(IActorRef receiver, Envelope envelope);
    internal bool TryDequeue(Envelope& msg);
    internal bool get_HasMessages();
    internal int get_NumberOfMessages();
    internal LatestFirstSystemMessageList get_SystemQueue();
    internal bool SystemQueuePut(LatestFirstSystemMessageList old, LatestFirstSystemMessageList newQueue);
    internal bool CanBeScheduledForExecution(bool hasMessageHint, bool hasSystemMessageHint);
    public MessageDispatcher get_Dispatcher();
    internal ActorCell get_Actor();
    public virtual void SetActor(ActorCell actorCell);
    internal int CurrentStatus();
    internal bool ShouldProcessMessage();
    internal int SuspendCount();
    internal bool IsSuspended();
    internal bool IsClosed();
    internal bool IsScheduled();
    private bool UpdateStatus(int oldStatus, int newStatus);
    private void SetStatus(int newStatus);
    internal bool Resume();
    internal bool Suspend();
    internal bool BecomeClosed();
    internal bool SetAsScheduled();
    internal bool SetAsIdle();
    public sealed virtual void Run();
    private void ProcessMailbox();
    private void ProcessMailbox(int left, long deadlineTicks);
    private void ProcessAllSystemMessages();
    public virtual void CleanUp();
    internal virtual void SystemEnqueue(IActorRef receiver, SystemMessage message);
    internal virtual EarliestFirstSystemMessageList SystemDrain(LatestFirstSystemMessageList newContents);
    internal virtual bool get_HasSystemMessages();
    [ConditionalAttribute("MAILBOXDEBUG")]
public static void DebugPrint(string message, Object[] args);
}
public class Akka.Dispatch.Mailboxes : object {
    private ActorSystem _system;
    private DeadLetterMailbox _deadLetterMailbox;
    public static string DefaultMailboxId;
    public static string NoMailboxRequirement;
    private Dictionary`2<Type, string> _mailboxBindings;
    private Config _defaultMailboxConfig;
    private ConcurrentDictionary`2<string, MailboxType> _mailboxTypeConfigurators;
    private bool _mailboxSizeWarningIssued;
    private bool _mailboxNonZeroPushTimeoutWarningIssued;
    private static Type RequiresMessageQueueGenericType;
    private static Type ProducesMessageQueueGenericType;
    private AtomicReference`1<ImmutableDictionary`2<string, int>> _stashCapacityCache;
    private int _defaultStashCapacity;
    private Settings Settings { get; }
    public DeadLetterMailbox DeadLetterMailbox { get; }
    public Mailboxes(ActorSystem system);
    private static Mailboxes();
    private Settings get_Settings();
    public DeadLetterMailbox get_DeadLetterMailbox();
    public bool HasRequiredType(Type actorType);
    public bool ProducesMessageQueue(Type mailboxType);
    private string LookupId(Type queueType);
    public MailboxType LookupByQueueType(Type queueType);
    public MailboxType Lookup(string id);
    private MailboxType LookupConfigurator(string id);
    private Config Config(string id);
    public Type GetRequiredType(Type actorType);
    private Type GetProducedMessageQueueType(MailboxType mailboxType);
    private Type GetMailboxRequirement(Config config);
    public MailboxType GetMailboxType(Props props, Config dispatcherConfig);
    private void Warn(string msg);
    [InternalApiAttribute]
public int StashCapacity(string dispatcher, string mailbox);
    private int StashCapacityFromConfig(string dispatcher, string mailbox);
    [CompilerGeneratedAttribute]
private bool <StashCapacity>g__UpdateCache|30_0(ImmutableDictionary`2<string, int> cache, string key, int value);
}
public abstract class Akka.Dispatch.MailboxType : object {
    protected Settings Settings;
    protected Config Config;
    protected MailboxType(Settings settings, Config config);
    public abstract virtual IMessageQueue Create(IActorRef owner, ActorSystem system);
}
public abstract class Akka.Dispatch.MessageDispatcher : object {
    private static int Unscheduled;
    private static int Scheduled;
    private static int Rescheduled;
    private static bool DebugDispatcher;
    internal static Lazy`1<Index`2<MessageDispatcher, IInternalActorRef>> Actors;
    public static int DefaultThroughput;
    [CompilerGeneratedAttribute]
private MessageDispatcherConfigurator <Configurator>k__BackingField;
    private long _inhabitantsDoNotCallMeDirectly;
    private int _shutdownScheduleDoNotCallMeDirectly;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ThroughputDeadlineTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Throughput>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ShutdownTimeout>k__BackingField;
    private ShutdownAction _shutdownAction;
    public MessageDispatcherConfigurator Configurator { get; private set; }
    public EventStream EventStream { get; }
    public Mailboxes Mailboxes { get; }
    public string Id { get; protected set; }
    public Nullable`1<long> ThroughputDeadlineTime { get; protected set; }
    public int Throughput { get; public set; }
    [InternalApiAttribute]
public TimeSpan ShutdownTimeout { get; protected set; }
    protected long Inhabitants { get; }
    private int ShutdownSchedule { get; }
    protected MessageDispatcher(MessageDispatcherConfigurator configurator);
    private static MessageDispatcher();
    internal static void PrintActors();
    [CompilerGeneratedAttribute]
public MessageDispatcherConfigurator get_Configurator();
    [CompilerGeneratedAttribute]
private void set_Configurator(MessageDispatcherConfigurator value);
    public EventStream get_EventStream();
    public Mailboxes get_Mailboxes();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
protected void set_Id(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ThroughputDeadlineTime();
    [CompilerGeneratedAttribute]
protected void set_ThroughputDeadlineTime(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public int get_Throughput();
    [CompilerGeneratedAttribute]
public void set_Throughput(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ShutdownTimeout();
    [CompilerGeneratedAttribute]
protected void set_ShutdownTimeout(TimeSpan value);
    protected long get_Inhabitants();
    private long AddInhabitants(long add);
    private int get_ShutdownSchedule();
    private bool UpdateShutdownSchedule(int expected, int update);
    public void Schedule(Action run);
    public void Schedule(IRunnable run);
    protected abstract virtual void ExecuteTask(IRunnable run);
    protected void ReportFailure(Exception ex);
    [InternalApiAttribute]
protected abstract virtual void Shutdown();
    private void IfSensibleToDoSoThenScheduleShutdown();
    private void ScheduleShutdownAction();
    internal static Mailbox CreateMailbox(ActorCell cell, MailboxType mailboxType);
    public virtual void Dispatch(ActorCell cell, Envelope envelope);
    public virtual void SystemDispatch(ActorCell cell, SystemMessage message);
    public virtual void Attach(ActorCell cell);
    internal virtual void Register(ActorCell actor);
    internal bool RegisterForExecution(Mailbox mbox, bool hasMessageHint, bool hasSystemMessageHint);
    public virtual void Detach(ActorCell cell);
    internal virtual void Unregister(ActorCell actor);
    internal virtual void Suspend(ActorCell actorCell);
    internal virtual void Resume(ActorCell actorCell);
    [CompilerGeneratedAttribute]
private void <ScheduleShutdownAction>b__49_0();
}
public abstract class Akka.Dispatch.MessageDispatcherConfigurator : object {
    [CompilerGeneratedAttribute]
private Config <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private IDispatcherPrerequisites <Prerequisites>k__BackingField;
    public Config Config { get; private set; }
    public IDispatcherPrerequisites Prerequisites { get; private set; }
    protected MessageDispatcherConfigurator(Config config, IDispatcherPrerequisites prerequisites);
    [CompilerGeneratedAttribute]
public Config get_Config();
    [CompilerGeneratedAttribute]
private void set_Config(Config value);
    [CompilerGeneratedAttribute]
public IDispatcherPrerequisites get_Prerequisites();
    [CompilerGeneratedAttribute]
private void set_Prerequisites(IDispatcherPrerequisites value);
    public abstract virtual MessageDispatcher Dispatcher();
    protected ExecutorServiceConfigurator ConfigureExecutor();
}
public abstract class Akka.Dispatch.MessageQueues.BlockingMessageQueue : object {
    private object _lock;
    private TimeSpan _blockTimeOut;
    protected int LockedCount { get; }
    public TimeSpan BlockTimeOut { get; public set; }
    public bool HasMessages { get; }
    public int Count { get; }
    protected abstract virtual int get_LockedCount();
    public sealed virtual TimeSpan get_BlockTimeOut();
    public sealed virtual void set_BlockTimeOut(TimeSpan value);
    public sealed virtual bool get_HasMessages();
    public sealed virtual int get_Count();
    public sealed virtual void Enqueue(IActorRef receiver, Envelope envelope);
    public sealed virtual bool TryDequeue(Envelope& envelope);
    public sealed virtual void CleanUp(IActorRef owner, IMessageQueue deadletters);
    protected abstract virtual void LockedEnqueue(Envelope envelope);
    protected abstract virtual bool LockedTryDequeue(Envelope& envelope);
}
public class Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue : DequeWrapperMessageQueue {
    [CompilerGeneratedAttribute]
private TimeSpan <PushTimeOut>k__BackingField;
    public TimeSpan PushTimeOut { get; }
    public BoundedDequeMessageQueue(int boundedCapacity, TimeSpan pushTimeOut);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_PushTimeOut();
}
public class Akka.Dispatch.MessageQueues.BoundedMessageQueue : object {
    private BlockingCollection`1<Envelope> _queue;
    [CompilerGeneratedAttribute]
private TimeSpan <PushTimeOut>k__BackingField;
    public bool HasMessages { get; }
    public int Count { get; }
    public TimeSpan PushTimeOut { get; public set; }
    public BoundedMessageQueue(Config config);
    public BoundedMessageQueue(int boundedCapacity, TimeSpan pushTimeOut);
    public sealed virtual bool get_HasMessages();
    public sealed virtual int get_Count();
    public sealed virtual void Enqueue(IActorRef receiver, Envelope envelope);
    public sealed virtual bool TryDequeue(Envelope& envelope);
    public sealed virtual void CleanUp(IActorRef owner, IMessageQueue deadletters);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_PushTimeOut();
    [CompilerGeneratedAttribute]
public void set_PushTimeOut(TimeSpan value);
}
public class Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue : object {
    private Stack`1<Envelope> _prependBuffer;
    protected IMessageQueue MessageQueue;
    public bool HasMessages { get; }
    public int Count { get; }
    public DequeWrapperMessageQueue(IMessageQueue messageQueue);
    public sealed virtual bool get_HasMessages();
    public sealed virtual int get_Count();
    public sealed virtual void Enqueue(IActorRef receiver, Envelope envelope);
    public sealed virtual bool TryDequeue(Envelope& envelope);
    public sealed virtual void CleanUp(IActorRef owner, IMessageQueue deadletters);
    public sealed virtual void EnqueueFirst(Envelope envelope);
}
public interface Akka.Dispatch.MessageQueues.IMessageQueue {
    public bool HasMessages { get; }
    public int Count { get; }
    public abstract virtual bool get_HasMessages();
    public abstract virtual int get_Count();
    public abstract virtual void Enqueue(IActorRef receiver, Envelope envelope);
    public abstract virtual bool TryDequeue(Envelope& envelope);
    public abstract virtual void CleanUp(IActorRef owner, IMessageQueue deadletters);
}
public class Akka.Dispatch.MessageQueues.UnboundedDequeMessageQueue : DequeWrapperMessageQueue {
}
public class Akka.Dispatch.MessageQueues.UnboundedMessageQueue : object {
    private ConcurrentQueue`1<Envelope> _queue;
    public bool HasMessages { get; }
    public int Count { get; }
    public sealed virtual bool get_HasMessages();
    public sealed virtual int get_Count();
    public sealed virtual void Enqueue(IActorRef receiver, Envelope envelope);
    public sealed virtual bool TryDequeue(Envelope& envelope);
    public sealed virtual void CleanUp(IActorRef owner, IMessageQueue deadletters);
}
public class Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue : BlockingMessageQueue {
    private ListPriorityQueue _prioQueue;
    private Stack`1<Envelope> _prependBuffer;
    protected int LockedCount { get; }
    public UnboundedPriorityMessageQueue(Func`2<object, int> priorityGenerator, int initialCapacity);
    protected virtual int get_LockedCount();
    protected virtual void LockedEnqueue(Envelope envelope);
    protected virtual bool LockedTryDequeue(Envelope& envelope);
    public sealed virtual void EnqueueFirst(Envelope envelope);
}
public class Akka.Dispatch.MessageQueues.UnboundedStablePriorityMessageQueue : BlockingMessageQueue {
    private StableListPriorityQueue _prioQueue;
    private Stack`1<Envelope> _prependBuffer;
    protected int LockedCount { get; }
    public UnboundedStablePriorityMessageQueue(Func`2<object, int> priorityGenerator, int initialCapacity);
    protected virtual int get_LockedCount();
    protected virtual void LockedEnqueue(Envelope envelope);
    protected virtual bool LockedTryDequeue(Envelope& envelope);
    public sealed virtual void EnqueueFirst(Envelope envelope);
}
internal class Akka.Dispatch.PartialTrustThreadPoolExecutorService : ThreadPoolExecutorService {
    public PartialTrustThreadPoolExecutorService(string id);
    public virtual void Execute(IRunnable run);
}
public class Akka.Dispatch.PinnedDispatcher : Dispatcher {
    private ActorCell modreq(System.Runtime.CompilerServices.IsVolatile) _owner;
    public PinnedDispatcher(MessageDispatcherConfigurator configurator, string id, int throughput, Nullable`1<long> throughputDeadlineTime, ExecutorServiceFactory executorServiceFactory, TimeSpan shutdownTimeout);
    internal virtual void Register(ActorCell actor);
    internal virtual void Unregister(ActorCell actor);
}
internal class Akka.Dispatch.PinnedDispatcherConfigurator : MessageDispatcherConfigurator {
    private ExecutorServiceConfigurator _executorServiceConfigurator;
    public PinnedDispatcherConfigurator(Config config, IDispatcherPrerequisites prerequisites);
    public virtual MessageDispatcher Dispatcher();
}
public class Akka.Dispatch.RejectedExecutionException : AkkaException {
    public RejectedExecutionException(string message, Exception inner);
    protected RejectedExecutionException(SerializationInfo info, StreamingContext context);
}
public class Akka.Dispatch.SysMsg.ActorTask : SystemMessage {
    [CompilerGeneratedAttribute]
private Task <Task>k__BackingField;
    public Task Task { get; private set; }
    public ActorTask(Task task);
    [CompilerGeneratedAttribute]
public Task get_Task();
    [CompilerGeneratedAttribute]
private void set_Task(Task value);
}
internal class Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage : SystemMessage {
    private ActorTaskScheduler _scheduler;
    private Task _task;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    public Exception Exception { get; }
    public object Message { get; }
    public ActorTaskSchedulerMessage(ActorTaskScheduler scheduler, Task task, object message);
    public ActorTaskSchedulerMessage(Exception exception, object message);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public object get_Message();
    public void ExecuteTask();
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.Create : SystemMessage {
    [CompilerGeneratedAttribute]
private ActorInitializationException <Failure>k__BackingField;
    public ActorInitializationException Failure { get; }
    public Create(ActorInitializationException failure);
    [CompilerGeneratedAttribute]
public ActorInitializationException get_Failure();
    private bool Equals(Create other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.DeathWatchNotification : SystemMessage {
    [CompilerGeneratedAttribute]
private IActorRef <Actor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExistenceConfirmed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddressTerminated>k__BackingField;
    public IActorRef Actor { get; private set; }
    public bool ExistenceConfirmed { get; private set; }
    public bool AddressTerminated { get; private set; }
    public DeathWatchNotification(IActorRef actor, bool existenceConfirmed, bool addressTerminated);
    [CompilerGeneratedAttribute]
public IActorRef get_Actor();
    [CompilerGeneratedAttribute]
private void set_Actor(IActorRef value);
    [CompilerGeneratedAttribute]
public bool get_ExistenceConfirmed();
    [CompilerGeneratedAttribute]
private void set_ExistenceConfirmed(bool value);
    [CompilerGeneratedAttribute]
public bool get_AddressTerminated();
    [CompilerGeneratedAttribute]
private void set_AddressTerminated(bool value);
    public virtual string ToString();
}
internal class Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList : ValueType {
    public SystemMessage Head;
    public bool IsEmpty { get; }
    public bool NonEmpty { get; }
    public int Size { get; }
    public EarliestFirstSystemMessageList Tail { get; }
    public LatestFirstSystemMessageList Reverse { get; }
    public EarliestFirstSystemMessageList(SystemMessage head);
    public bool get_IsEmpty();
    public bool get_NonEmpty();
    public int get_Size();
    public EarliestFirstSystemMessageList get_Tail();
    public LatestFirstSystemMessageList get_Reverse();
    public static EarliestFirstSystemMessageList op_Addition(EarliestFirstSystemMessageList list, SystemMessage msg);
    public static EarliestFirstSystemMessageList op_Addition(EarliestFirstSystemMessageList list, LatestFirstSystemMessageList other);
}
public class Akka.Dispatch.SysMsg.Escalate : SystemMessage {
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    public Exception Reason { get; private set; }
    public Escalate(Exception reason);
    [CompilerGeneratedAttribute]
public Exception get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(Exception value);
    public virtual string ToString();
}
[InternalApiAttribute]
public class Akka.Dispatch.SysMsg.Failed : SystemMessage {
    private long _uid;
    private Exception _cause;
    private IActorRef _child;
    public IActorRef Child { get; }
    public Exception Cause { get; }
    public long Uid { get; }
    public Failed(IActorRef child, Exception cause, long uid);
    public IActorRef get_Child();
    public Exception get_Cause();
    public long get_Uid();
    public virtual string ToString();
}
internal interface Akka.Dispatch.SysMsg.IStashWhenFailed {
}
internal interface Akka.Dispatch.SysMsg.IStashWhenWaitingForChildren {
}
public interface Akka.Dispatch.SysMsg.ISystemMessage {
}
internal class Akka.Dispatch.SysMsg.LatestFirstSystemMessageList : ValueType {
    public SystemMessage Head;
    public bool IsEmpty { get; }
    public bool NonEmpty { get; }
    public int Size { get; }
    public LatestFirstSystemMessageList Tail { get; }
    public EarliestFirstSystemMessageList Reverse { get; }
    public LatestFirstSystemMessageList(SystemMessage head);
    public bool get_IsEmpty();
    public bool get_NonEmpty();
    public int get_Size();
    public LatestFirstSystemMessageList get_Tail();
    public EarliestFirstSystemMessageList get_Reverse();
    public static LatestFirstSystemMessageList op_Addition(LatestFirstSystemMessageList list, SystemMessage msg);
}
public class Akka.Dispatch.SysMsg.NoMessage : SystemMessage {
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.Recreate : SystemMessage {
    [CompilerGeneratedAttribute]
private Exception <Cause>k__BackingField;
    public Exception Cause { get; private set; }
    public Recreate(Exception cause);
    [CompilerGeneratedAttribute]
public Exception get_Cause();
    [CompilerGeneratedAttribute]
private void set_Cause(Exception value);
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.RegisterTerminationHook : object {
    [CompilerGeneratedAttribute]
private static RegisterTerminationHook <Instance>k__BackingField;
    public static RegisterTerminationHook Instance { get; }
    private static RegisterTerminationHook();
    [CompilerGeneratedAttribute]
public static RegisterTerminationHook get_Instance();
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.Resume : SystemMessage {
    [CompilerGeneratedAttribute]
private Exception <CausedByFailure>k__BackingField;
    public Exception CausedByFailure { get; public set; }
    public Resume(Exception causedByFailure);
    [CompilerGeneratedAttribute]
public Exception get_CausedByFailure();
    [CompilerGeneratedAttribute]
public void set_CausedByFailure(Exception value);
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.Stop : SystemMessage {
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.StopChild : object {
    [CompilerGeneratedAttribute]
private IActorRef <Child>k__BackingField;
    public IActorRef Child { get; private set; }
    public StopChild(IActorRef child);
    [CompilerGeneratedAttribute]
public IActorRef get_Child();
    [CompilerGeneratedAttribute]
private void set_Child(IActorRef value);
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.Supervise : SystemMessage {
    [CompilerGeneratedAttribute]
private bool <Async>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <Child>k__BackingField;
    public bool Async { get; private set; }
    public IActorRef Child { get; private set; }
    public Supervise(IActorRef child, bool async);
    [CompilerGeneratedAttribute]
public bool get_Async();
    [CompilerGeneratedAttribute]
private void set_Async(bool value);
    [CompilerGeneratedAttribute]
public IActorRef get_Child();
    [CompilerGeneratedAttribute]
private void set_Child(IActorRef value);
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.Suspend : SystemMessage {
    public virtual string ToString();
}
[InternalStableApiAttribute]
public abstract class Akka.Dispatch.SysMsg.SystemMessage : object {
    internal SystemMessage Next;
    public bool Unlinked { get; }
    public void Unlink();
    public bool get_Unlinked();
}
internal static class Akka.Dispatch.SysMsg.SystemMessageList : object {
    public static LatestFirstSystemMessageList LNil;
    public static EarliestFirstSystemMessageList ENil;
    private static SystemMessageList();
    internal static int SizeInner(SystemMessage head, int acc);
    internal static SystemMessage ReverseInner(SystemMessage head, SystemMessage acc);
}
public class Akka.Dispatch.SysMsg.Terminate : SystemMessage {
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.TerminationHook : object {
    [CompilerGeneratedAttribute]
private static TerminationHook <Instance>k__BackingField;
    public static TerminationHook Instance { get; }
    private static TerminationHook();
    [CompilerGeneratedAttribute]
public static TerminationHook get_Instance();
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.TerminationHookDone : object {
    [CompilerGeneratedAttribute]
private static TerminationHookDone <Instance>k__BackingField;
    public static TerminationHookDone Instance { get; }
    private static TerminationHookDone();
    [CompilerGeneratedAttribute]
public static TerminationHookDone get_Instance();
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.Unwatch : SystemMessage {
    [CompilerGeneratedAttribute]
private IInternalActorRef <Watchee>k__BackingField;
    [CompilerGeneratedAttribute]
private IInternalActorRef <Watcher>k__BackingField;
    public IInternalActorRef Watchee { get; }
    public IInternalActorRef Watcher { get; }
    public Unwatch(IInternalActorRef watchee, IInternalActorRef watcher);
    [CompilerGeneratedAttribute]
public IInternalActorRef get_Watchee();
    [CompilerGeneratedAttribute]
public IInternalActorRef get_Watcher();
    private bool Equals(Unwatch other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Akka.Dispatch.SysMsg.Watch : SystemMessage {
    [CompilerGeneratedAttribute]
private IInternalActorRef <Watchee>k__BackingField;
    [CompilerGeneratedAttribute]
private IInternalActorRef <Watcher>k__BackingField;
    public IInternalActorRef Watchee { get; }
    public IInternalActorRef Watcher { get; }
    public Watch(IInternalActorRef watchee, IInternalActorRef watcher);
    [CompilerGeneratedAttribute]
public IInternalActorRef get_Watchee();
    [CompilerGeneratedAttribute]
public IInternalActorRef get_Watcher();
    protected bool Equals(Watch other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Akka.Dispatch.TaskSchedulerExecutor : ExecutorService {
    private TaskScheduler _scheduler;
    private static Action`1<object> Executor;
    public TaskSchedulerExecutor(string id, TaskScheduler scheduler);
    private static TaskSchedulerExecutor();
    public virtual void Execute(IRunnable run);
    public virtual void Shutdown();
}
public enum Akka.Dispatch.TaskSchedulerPriority : Enum {
    public int value__;
    public static TaskSchedulerPriority None;
    public static TaskSchedulerPriority Idle;
    public static TaskSchedulerPriority Background;
    public static TaskSchedulerPriority Low;
    public static TaskSchedulerPriority BelowNormal;
    public static TaskSchedulerPriority Normal;
    public static TaskSchedulerPriority AboveNormal;
    public static TaskSchedulerPriority High;
    public static TaskSchedulerPriority Realtime;
}
public class Akka.Dispatch.ThreadPoolConfig : object {
    private Config _config;
    public int PoolSizeMin { get; }
    public double PoolSizeFactor { get; }
    public int PoolSizeMax { get; }
    public ThreadPoolConfig(Config config);
    public int get_PoolSizeMin();
    public double get_PoolSizeFactor();
    public int get_PoolSizeMax();
    public static int ScaledPoolSize(int floor, double scalar, int ceiling);
}
internal abstract class Akka.Dispatch.ThreadPoolExecutorService : ExecutorService {
    protected static WaitCallback Executor;
    protected ThreadPoolExecutorService(string id);
    private static ThreadPoolExecutorService();
    public virtual void Shutdown();
}
internal class Akka.Dispatch.ThreadPoolExecutorServiceFactory : ExecutorServiceConfigurator {
    private static bool IsFullTrusted;
    public ThreadPoolExecutorServiceFactory(Config config, IDispatcherPrerequisites prerequisites);
    private static ThreadPoolExecutorServiceFactory();
    public virtual ExecutorService Produce(string id);
}
public class Akka.Dispatch.UnboundedDequeBasedMailbox : MailboxType {
    public UnboundedDequeBasedMailbox(Settings settings, Config config);
    public virtual IMessageQueue Create(IActorRef owner, ActorSystem system);
}
public class Akka.Dispatch.UnboundedMailbox : MailboxType {
    public UnboundedMailbox(Settings settings, Config config);
    public virtual IMessageQueue Create(IActorRef owner, ActorSystem system);
}
public abstract class Akka.Dispatch.UnboundedPriorityMailbox : MailboxType {
    [CompilerGeneratedAttribute]
private int <InitialCapacity>k__BackingField;
    public static int DefaultCapacity;
    public int InitialCapacity { get; }
    protected UnboundedPriorityMailbox(Settings settings, Config config);
    protected abstract virtual int PriorityGenerator(object message);
    [CompilerGeneratedAttribute]
public int get_InitialCapacity();
    public sealed virtual IMessageQueue Create(IActorRef owner, ActorSystem system);
}
public abstract class Akka.Dispatch.UnboundedStablePriorityMailbox : MailboxType {
    [CompilerGeneratedAttribute]
private int <InitialCapacity>k__BackingField;
    public static int DefaultCapacity;
    public int InitialCapacity { get; }
    protected UnboundedStablePriorityMailbox(Settings settings, Config config);
    protected abstract virtual int PriorityGenerator(object message);
    [CompilerGeneratedAttribute]
public int get_InitialCapacity();
    public sealed virtual IMessageQueue Create(IActorRef owner, ActorSystem system);
}
public class Akka.Done : object {
    public static Done Instance;
    private static Done();
}
public abstract class Akka.Event.ActorEventBus`2 : EventBus`3<TEvent, TClassifier, IActorRef> {
}
internal class Akka.Event.AddressTerminatedTopic : object {
    private HashSet`1<IActorRef> _subscribers;
    public static AddressTerminatedTopic Get(ActorSystem system);
    public void Subscribe(IActorRef subscriber);
    public void Unsubscribe(IActorRef subscriber);
    public void Publish(AddressTerminated msg);
}
internal class Akka.Event.AddressTerminatedTopicProvider : ExtensionIdProvider`1<AddressTerminatedTopic> {
    public virtual AddressTerminatedTopic CreateExtension(ExtendedActorSystem system);
}
public abstract class Akka.Event.AllDeadLetters : object {
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <Recipient>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <Sender>k__BackingField;
    public object Message { get; }
    public IActorRef Recipient { get; }
    public IActorRef Sender { get; }
    protected AllDeadLetters(object message, IActorRef sender, IActorRef recipient);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Message();
    [CompilerGeneratedAttribute]
public IActorRef get_Recipient();
    [CompilerGeneratedAttribute]
public IActorRef get_Sender();
    public virtual string ToString();
}
public class Akka.Event.BusLogging : LoggingAdapterBase {
    [CompilerGeneratedAttribute]
private LoggingBus <Bus>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <LogClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDebugEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsErrorEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInfoEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWarningEnabled>k__BackingField;
    public LoggingBus Bus { get; }
    public Type LogClass { get; }
    public string LogSource { get; }
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarningEnabled { get; }
    public BusLogging(LoggingBus bus, string logSource, Type logClass, ILogMessageFormatter logMessageFormatter);
    [CompilerGeneratedAttribute]
public LoggingBus get_Bus();
    [CompilerGeneratedAttribute]
public Type get_LogClass();
    [CompilerGeneratedAttribute]
public string get_LogSource();
    [CompilerGeneratedAttribute]
public virtual bool get_IsDebugEnabled();
    [CompilerGeneratedAttribute]
public virtual bool get_IsErrorEnabled();
    [CompilerGeneratedAttribute]
public virtual bool get_IsInfoEnabled();
    [CompilerGeneratedAttribute]
public virtual bool get_IsWarningEnabled();
    private LogEvent CreateLogEvent(LogLevel logLevel, object message, Exception cause);
    protected virtual void NotifyLog(LogLevel logLevel, object message, Exception cause);
}
public class Akka.Event.DeadLetter : AllDeadLetters {
    public DeadLetter(object message, IActorRef sender, IActorRef recipient);
}
public class Akka.Event.DeadLetterListener : ActorBase {
    private EventStream _eventStream;
    private bool _isAlwaysLoggingDeadLetters;
    private int _maxCount;
    private int _count;
    protected virtual void PostRestart(Exception reason);
    protected virtual void PreRestart(Exception reason, object message);
    protected virtual void PreStart();
    protected virtual void PostStop();
    private void IncrementCount();
    protected virtual bool Receive(object message);
    private bool ReceiveWithAlwaysLogging(object message);
    private bool ReceiveWithMaxCountLogging(object message);
    private Receive ReceiveWithSuspendLogging(TimeSpan suspendDuration);
    private Receive ReceiveWhenSuspended(TimeSpan suspendDuration, Deadline suspendDeadline);
    private void LogDeadLetter(AllDeadLetters d, string doneMsg);
    private static bool IsReal(IActorRef snd);
    private static bool IsWrappedSuppressed(AllDeadLetters d);
}
public class Akka.Event.Debug : LogEvent {
    public Debug(string logSource, Type logClass, object message);
    public Debug(Exception cause, string logSource, Type logClass, object message);
    public virtual LogLevel LogLevel();
}
public class Akka.Event.DefaultLogger : ActorBase {
    private MinimalLogger _stdoutLogger;
    protected virtual bool Receive(object message);
    protected virtual void Print(LogEvent logEvent);
}
internal class Akka.Event.DefaultLogMessage : LogMessage {
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public Object[] Args { get; }
    public DefaultLogMessage(ILogMessageFormatter formatter, string format, Object[] args);
    [CompilerGeneratedAttribute]
public Object[] get_Args();
    public virtual string ToString();
    public virtual string Unformatted();
    public virtual IEnumerable`1<object> Parameters();
}
public class Akka.Event.DefaultLogMessageFormatter : object {
    public static DefaultLogMessageFormatter Instance;
    private static DefaultLogMessageFormatter();
    public sealed virtual string Format(string format, Object[] args);
    public sealed virtual string Format(string format, IEnumerable`1<object> args);
}
public class Akka.Event.Dropped : AllDeadLetters {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public Dropped(object message, string reason, IActorRef sender, IActorRef recipient);
    public Dropped(object message, string reason, IActorRef recipient);
    [CompilerGeneratedAttribute]
public string get_Reason();
}
public class Akka.Event.DummyClassForStringSources : object {
}
public class Akka.Event.Error : LogEvent {
    public Error(Exception cause, string logSource, Type logClass, object message);
    public virtual LogLevel LogLevel();
}
public abstract class Akka.Event.EventBus`3 : object {
    private Dictionary`2<TClassifier, List`1<Subscription`2<TSubscriber, TClassifier>>> _classifiers;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _cache;
    protected string SimpleName(object source);
    protected string SimpleName(Type source);
    public virtual bool Subscribe(TSubscriber subscriber, TClassifier classifier);
    public virtual bool Unsubscribe(TSubscriber subscriber);
    public virtual bool Unsubscribe(TSubscriber subscriber, TClassifier classifier);
    private void ClearCache();
    protected abstract virtual bool IsSubClassification(TClassifier parent, TClassifier child);
    protected abstract virtual void Publish(TEvent event, TSubscriber subscriber);
    protected abstract virtual bool Classify(TEvent event, TClassifier classifier);
    protected abstract virtual TClassifier GetClassifier(TEvent event);
    public virtual void Publish(TEvent event);
    private void PublishToSubscribers(TEvent event, List`1<TSubscriber> cachedSubscribers);
    private List`1<TSubscriber> UpdateCacheForEventClassifier(TEvent event, TClassifier eventClass);
}
public class Akka.Event.EventStream : LoggingBus {
    private bool _debug;
    private static AtomicCounter UnsubscribersCounter;
    private AtomicReference`1<IActorRef> _unsubscriber;
    private ConcurrentSet`1<IActorRef> _pendingUnsubscribers;
    public EventStream(bool debug);
    private static EventStream();
    public virtual bool Subscribe(IActorRef subscriber, Type channel);
    public virtual bool Unsubscribe(IActorRef subscriber, Type channel);
    public virtual bool Unsubscribe(IActorRef subscriber);
    public void StartUnsubscriber(ActorSystemImpl system);
    private void RegisterWithUnsubscriber(IActorRef subscriber);
    private void UnregisterIfNoMoreSubscribedChannels(IActorRef subscriber);
}
[ExtensionAttribute]
public static class Akka.Event.EventStreamExtensions : object {
    [ExtensionAttribute]
public static bool Subscribe(EventStream eventStream, IActorRef subscriber);
    [ExtensionAttribute]
public static bool Unsubscribe(EventStream eventStream, IActorRef subscriber);
}
[InternalApiAttribute]
internal class Akka.Event.EventStreamUnsubscriber : ActorBase {
    private EventStream _eventStream;
    private bool _debug;
    private ActorSystem _system;
    public EventStreamUnsubscriber(EventStream eventStream, ActorSystem system, bool debug);
    protected virtual bool Receive(object message);
    protected virtual void PreStart();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Akka.Event.ExactMatchLogSourceFilter : LogFilterBase {
    private string _source;
    private StringComparison _comparison;
    public LogFilterType FilterType { get; }
    public ExactMatchLogSourceFilter(string source, StringComparison comparison);
    public virtual LogFilterType get_FilterType();
    public virtual LogFilterDecision ShouldKeepMessage(LogEvent content, string expandedMessage);
}
public interface Akka.Event.IDeadLetterSuppression {
}
public interface Akka.Event.ILoggerMessageQueueSemantics {
}
public interface Akka.Event.ILoggingAdapter {
    public ILogMessageFormatter Formatter { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarningEnabled { get; }
    public bool IsErrorEnabled { get; }
    public abstract virtual ILogMessageFormatter get_Formatter();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarningEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool IsEnabled(LogLevel logLevel);
    public abstract virtual void Log(LogLevel logLevel, Exception cause, string format);
    public abstract virtual void Log(LogLevel logLevel, Exception cause, LogMessage message);
}
public interface Akka.Event.ILogMessageFormatter {
    public abstract virtual string Format(string format, Object[] args);
    public abstract virtual string Format(string format, IEnumerable`1<object> args);
}
public class Akka.Event.Info : LogEvent {
    public Info(string logSource, Type logClass, object message);
    public Info(Exception cause, string logSource, Type logClass, object message);
    public virtual LogLevel LogLevel();
}
public class Akka.Event.InitializeLogger : object {
    [CompilerGeneratedAttribute]
private LoggingBus <LoggingBus>k__BackingField;
    public LoggingBus LoggingBus { get; private set; }
    public InitializeLogger(LoggingBus loggingBus);
    [CompilerGeneratedAttribute]
public LoggingBus get_LoggingBus();
    [CompilerGeneratedAttribute]
private void set_LoggingBus(LoggingBus value);
}
public abstract class Akka.Event.LogEvent : object {
    [CompilerGeneratedAttribute]
private Exception <Cause>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <Thread>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <LogClass>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    public Exception Cause { get; protected set; }
    public DateTime Timestamp { get; private set; }
    public Thread Thread { get; private set; }
    public string LogSource { get; protected set; }
    public Type LogClass { get; protected set; }
    public object Message { get; protected set; }
    [CompilerGeneratedAttribute]
public Exception get_Cause();
    [CompilerGeneratedAttribute]
protected void set_Cause(Exception value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Thread get_Thread();
    [CompilerGeneratedAttribute]
private void set_Thread(Thread value);
    [CompilerGeneratedAttribute]
public string get_LogSource();
    [CompilerGeneratedAttribute]
protected void set_LogSource(string value);
    [CompilerGeneratedAttribute]
public Type get_LogClass();
    [CompilerGeneratedAttribute]
protected void set_LogClass(Type value);
    [CompilerGeneratedAttribute]
public object get_Message();
    [CompilerGeneratedAttribute]
protected void set_Message(object value);
    public abstract virtual LogLevel LogLevel();
    public virtual string ToString();
}
public abstract class Akka.Event.LogFilterBase : object {
    public LogFilterType FilterType { get; }
    public abstract virtual LogFilterType get_FilterType();
    [NullableContextAttribute("1")]
public abstract virtual LogFilterDecision ShouldKeepMessage(LogEvent content, string expandedMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Akka.Event.LogFilterBuilder : object {
    private List`1<LogFilterBase> _filters;
    public LogFilterBuilder ExcludeSourceExactly(string source, StringComparison comparison);
    public LogFilterBuilder ExcludeSourceStartingWith(string sourceStart);
    public LogFilterBuilder ExcludeSourceContaining(string sourcePart);
    public LogFilterBuilder ExcludeSourceEndingWith(string sourceEnd);
    public LogFilterBuilder ExcludeSourceRegex(Regex regex);
    public LogFilterBuilder ExcludeMessageRegex(Regex regex);
    public LogFilterBuilder ExcludeMessageContaining(string messagePart);
    public LogFilterBuilder Add(LogFilterBase filter);
    public LogFilterBuilder AddRange(IEnumerable`1<LogFilterBase> filters);
    public LogFilterSetup Build();
}
public enum Akka.Event.LogFilterDecision : Enum {
    public int value__;
    public static LogFilterDecision Keep;
    public static LogFilterDecision Drop;
    public static LogFilterDecision NoDecision;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Akka.Event.LogFilterEvaluator : object {
    public static LogFilterEvaluator NoFilters;
    private LogFilterBase[] _filters;
    [CompilerGeneratedAttribute]
private bool <EvaluatesLogSourcesOnly>k__BackingField;
    public bool EvaluatesLogSourcesOnly { get; }
    public LogFilterEvaluator(LogFilterBase[] filters);
    private static LogFilterEvaluator();
    [CompilerGeneratedAttribute]
public bool get_EvaluatesLogSourcesOnly();
    public virtual bool ShouldTryKeepMessage(LogEvent evt, String& expandedLogMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Akka.Event.LogFilterSetup : Setup {
    [CompilerGeneratedAttribute]
private LogFilterBase[] <Filters>k__BackingField;
    public LogFilterBase[] Filters { get; }
    public LogFilterSetup(LogFilterBase[] filters);
    [CompilerGeneratedAttribute]
public LogFilterBase[] get_Filters();
    public LogFilterEvaluator CreateEvaluator();
}
public enum Akka.Event.LogFilterType : Enum {
    public int value__;
    public static LogFilterType Source;
    public static LogFilterType Content;
}
[ExtensionAttribute]
internal static class Akka.Event.LogFormats : object {
    public static IReadOnlyDictionary`2<LogLevel, string> PrettyPrintedLogLevel;
    private static LogFormats();
    [ExtensionAttribute]
public static string PrettyNameFor(LogLevel level);
}
public class Akka.Event.LoggerInitialized : object {
}
public class Akka.Event.LoggerMailbox : Mailbox {
    private IActorRef _owner;
    private ActorSystem _system;
    private bool Akka.Dispatch.MessageQueues.IMessageQueue.HasMessages { get; }
    private int Akka.Dispatch.MessageQueues.IMessageQueue.Count { get; }
    public LoggerMailbox(IActorRef owner, ActorSystem system);
    private sealed virtual override bool Akka.Dispatch.MessageQueues.IMessageQueue.get_HasMessages();
    private sealed virtual override int Akka.Dispatch.MessageQueues.IMessageQueue.get_Count();
    private sealed virtual override void Akka.Dispatch.MessageQueues.IMessageQueue.Enqueue(IActorRef receiver, Envelope envelope);
    private sealed virtual override bool Akka.Dispatch.MessageQueues.IMessageQueue.TryDequeue(Envelope& envelope);
    private sealed virtual override void Akka.Dispatch.MessageQueues.IMessageQueue.CleanUp(IActorRef owner, IMessageQueue deadletters);
}
internal class Akka.Event.LoggerMailboxType : MailboxType {
    public LoggerMailboxType(Settings settings, Config config);
    public virtual IMessageQueue Create(IActorRef owner, ActorSystem system);
}
[ExtensionAttribute]
public static class Akka.Event.Logging : object {
    private static string Debug;
    private static string Info;
    private static string Warning;
    private static string Error;
    private static string Off;
    private static LogLevel OffLogLevel;
    public static string SimpleName(object o);
    public static string SimpleName(Type t);
    [ExtensionAttribute]
public static Type ClassFor(LogLevel logLevel);
    [ExtensionAttribute]
public static string StringFor(LogLevel logLevel);
    [ExtensionAttribute]
internal static ILoggingAdapter GetLoggerStartup(IActorContext context, ILogMessageFormatter logMessageFormatter);
    [ExtensionAttribute]
public static ILoggingAdapter GetLogger(IActorContext context, ILogMessageFormatter logMessageFormatter);
    public static ILoggingAdapter GetLogger(ActorSystem system, object logSourceObj, ILogMessageFormatter logMessageFormatter);
    public static ILoggingAdapter GetLogger(LoggingBus loggingBus, object logSourceObj, ILogMessageFormatter logMessageFormatter);
    public static LogLevel LogLevelFor(string logLevel);
    public static LogLevel LogLevelFor();
}
public abstract class Akka.Event.LoggingAdapterBase : object {
    [CompilerGeneratedAttribute]
private ILogMessageFormatter <Formatter>k__BackingField;
    public ILogMessageFormatter Formatter { get; }
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarningEnabled { get; }
    protected LoggingAdapterBase(ILogMessageFormatter logMessageFormatter);
    [CompilerGeneratedAttribute]
public sealed virtual ILogMessageFormatter get_Formatter();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarningEnabled();
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    protected abstract virtual void NotifyLog(LogLevel logLevel, object message, Exception cause);
    public sealed virtual void Log(LogLevel logLevel, Exception cause, LogMessage message);
    public sealed virtual void Log(LogLevel logLevel, Exception cause, string format);
}
public class Akka.Event.LoggingBus : ActorEventBus`2<object, Type> {
    private static LogLevel[] AllLogLevels;
    private static int _loggerId;
    private List`1<IActorRef> _loggers;
    private CancellationTokenSource _shutdownCts;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    public LogLevel LogLevel { get; private set; }
    private static LoggingBus();
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
private void set_LogLevel(LogLevel value);
    protected virtual bool IsSubClassification(Type parent, Type child);
    protected virtual void Publish(object event, IActorRef subscriber);
    protected virtual bool Classify(object event, Type classifier);
    protected virtual Type GetClassifier(object event);
    internal void StartDefaultLoggers(ActorSystemImpl system);
    internal void StopDefaultLoggers(ActorSystem system);
    private void RemoveLogger(IActorRef logger);
    private ValueTuple`2<Task, string> AddLogger(ActorSystemImpl system, Type loggerType, string loggingBusName);
    private string CreateLoggerName(Type actorClass);
    public void StartStdoutLogger(Settings config);
    private void SetUpStdoutLogger(Settings config);
    public void SetLogLevel(LogLevel logLevel);
    private void SubscribeLogLevelAndAbove(LogLevel logLevel, IActorRef logger);
}
[ExtensionAttribute]
public static class Akka.Event.LoggingExtensions : object {
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel level, string format);
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel level, string format, Object[] args);
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel level, Exception cause, string format, Object[] args);
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel logLevel, Exception cause, string format, T1 arg1);
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel logLevel, Exception cause, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel logLevel, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel logLevel, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel logLevel, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Log(ILoggingAdapter log, LogLevel logLevel, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, string format);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, Exception cause, string format);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, string format, T1 arg1);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, Exception cause, string format, T1 arg1);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, Exception cause, string format, Object[] args);
    [ExtensionAttribute]
public static void Debug(ILoggingAdapter log, string format, Object[] args);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, string format);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, Exception cause, string format);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, string format, T1 arg1);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, Exception cause, string format, T1 arg1);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, Exception cause, string format, Object[] args);
    [ExtensionAttribute]
public static void Info(ILoggingAdapter log, string format, Object[] args);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, string format);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, Exception cause, string format);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, string format, T1 arg1);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, Exception cause, string format, T1 arg1);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, Exception cause, string format, Object[] args);
    [ExtensionAttribute]
public static void Warning(ILoggingAdapter log, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, string format);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, Exception cause, string format);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, string format, T1 arg1);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, Exception cause, string format, T1 arg1);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, Exception cause, string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, Exception cause, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(ILoggingAdapter log, string format, Object[] args);
}
public enum Akka.Event.LogLevel : Enum {
    public int value__;
    public static LogLevel DebugLevel;
    public static LogLevel InfoLevel;
    public static LogLevel WarningLevel;
    public static LogLevel ErrorLevel;
}
public abstract class Akka.Event.LogMessage : object {
    protected ILogMessageFormatter Formatter;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public LogMessage(ILogMessageFormatter formatter, string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
    [InternalApiAttribute]
public abstract virtual string Unformatted();
    [InternalApiAttribute]
public abstract virtual IEnumerable`1<object> Parameters();
}
internal class Akka.Event.LogMessage`1 : LogMessage {
    [CompilerGeneratedAttribute]
private T <Arg>k__BackingField;
    public T Arg { get; }
    public LogMessage`1(ILogMessageFormatter formatter, string format, T arg);
    [CompilerGeneratedAttribute]
public T get_Arg();
    public virtual string ToString();
    public virtual string Unformatted();
    public virtual IEnumerable`1<object> Parameters();
}
public static class Akka.Event.LogMessageExtensions : object {
}
public class Akka.Event.LogSource : ValueType {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Source { get; }
    public Type Type { get; }
    private LogSource(string source, Type type);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Source();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Type get_Type();
    public static LogSource Create(object o);
    public static LogSource Create(object o, ActorSystem system);
    public static LogSource Create(string source, Type t);
    public static Type SourceType(object o);
    public static string FromType(Type t, ActorSystem system);
    public static string FromString(string source, ActorSystem system);
    public static string FromActor(IActorContext actor, ActorSystem system);
    public static string FromActorRef(IActorRef a, ActorSystem system);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Akka.Event.LogValues`1 : ValueType {
    private T1 _value1;
    public int Count { get; }
    public object Item { get; }
    public LogValues`1(T1 value1);
    [IteratorStateMachineAttribute("Akka.Event.LogValues`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Akka.Event.LogValues`2 : ValueType {
    private T1 _value1;
    private T2 _value2;
    public int Count { get; }
    public object Item { get; }
    public LogValues`2(T1 value1, T2 value2);
    [IteratorStateMachineAttribute("Akka.Event.LogValues`2/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Akka.Event.LogValues`3 : ValueType {
    private T1 _value1;
    private T2 _value2;
    private T3 _value3;
    public int Count { get; }
    public object Item { get; }
    public LogValues`3(T1 value1, T2 value2, T3 value3);
    [IteratorStateMachineAttribute("Akka.Event.LogValues`3/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Akka.Event.LogValues`4 : ValueType {
    private T1 _value1;
    private T2 _value2;
    private T3 _value3;
    private T4 _value4;
    public int Count { get; }
    public object Item { get; }
    public LogValues`4(T1 value1, T2 value2, T3 value3, T4 value4);
    [IteratorStateMachineAttribute("Akka.Event.LogValues`4/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Akka.Event.LogValues`5 : ValueType {
    private T1 _value1;
    private T2 _value2;
    private T3 _value3;
    private T4 _value4;
    private T5 _value5;
    public int Count { get; }
    public object Item { get; }
    public LogValues`5(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    [IteratorStateMachineAttribute("Akka.Event.LogValues`5/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Akka.Event.LogValues`6 : ValueType {
    private T1 _value1;
    private T2 _value2;
    private T3 _value3;
    private T4 _value4;
    private T5 _value5;
    private T6 _value6;
    public int Count { get; }
    public object Item { get; }
    public LogValues`6(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    [IteratorStateMachineAttribute("Akka.Event.LogValues`6/<GetEnumerator>d__7")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int index);
}
public abstract class Akka.Event.MinimalLogger : MinimalActorRef {
    [CompilerGeneratedAttribute]
private LogFilterEvaluator <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private ActorPath <Path>k__BackingField;
    public LogFilterEvaluator Filter { get; internal set; }
    public IActorRefProvider Provider { get; }
    public ActorPath Path { get; }
    [CompilerGeneratedAttribute]
public LogFilterEvaluator get_Filter();
    [CompilerGeneratedAttribute]
internal void set_Filter(LogFilterEvaluator value);
    public sealed virtual IActorRefProvider get_Provider();
    [CompilerGeneratedAttribute]
public sealed virtual ActorPath get_Path();
    protected sealed virtual void TellInternal(object message, IActorRef sender);
    protected abstract virtual void Log(object message);
}
public class Akka.Event.NoLogger : object {
    public static ILoggingAdapter Instance;
    public ILogMessageFormatter Formatter { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarningEnabled { get; }
    public bool IsErrorEnabled { get; }
    private static NoLogger();
    public sealed virtual ILogMessageFormatter get_Formatter();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarningEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, Exception cause, string format);
    public sealed virtual void Log(LogLevel logLevel, Exception cause, LogMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Akka.Event.RegexLogMessageFilter : LogFilterBase {
    private Regex _messageRegex;
    public LogFilterType FilterType { get; }
    public RegexLogMessageFilter(Regex messageRegex);
    public virtual LogFilterType get_FilterType();
    public virtual LogFilterDecision ShouldKeepMessage(LogEvent content, string expandedMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Akka.Event.RegexLogSourceFilter : LogFilterBase {
    private Regex _sourceRegex;
    public LogFilterType FilterType { get; }
    public RegexLogSourceFilter(Regex sourceRegex);
    public virtual LogFilterType get_FilterType();
    public virtual LogFilterDecision ShouldKeepMessage(LogEvent content, string expandedMessage);
}
public class Akka.Event.StandardOutLogger : MinimalLogger {
    [CompilerGeneratedAttribute]
private static ConsoleColor <DebugColor>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleColor <InfoColor>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleColor <WarningColor>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleColor <ErrorColor>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <UseColors>k__BackingField;
    public static ConsoleColor DebugColor { get; public set; }
    public static ConsoleColor InfoColor { get; public set; }
    public static ConsoleColor WarningColor { get; public set; }
    public static ConsoleColor ErrorColor { get; public set; }
    public static bool UseColors { get; public set; }
    private static StandardOutLogger();
    protected virtual void Log(object message);
    [CompilerGeneratedAttribute]
public static ConsoleColor get_DebugColor();
    [CompilerGeneratedAttribute]
public static void set_DebugColor(ConsoleColor value);
    [CompilerGeneratedAttribute]
public static ConsoleColor get_InfoColor();
    [CompilerGeneratedAttribute]
public static void set_InfoColor(ConsoleColor value);
    [CompilerGeneratedAttribute]
public static ConsoleColor get_WarningColor();
    [CompilerGeneratedAttribute]
public static void set_WarningColor(ConsoleColor value);
    [CompilerGeneratedAttribute]
public static ConsoleColor get_ErrorColor();
    [CompilerGeneratedAttribute]
public static void set_ErrorColor(ConsoleColor value);
    [CompilerGeneratedAttribute]
public static bool get_UseColors();
    [CompilerGeneratedAttribute]
public static void set_UseColors(bool value);
    internal static void PrintLogEvent(LogEvent logEvent, LogFilterEvaluator filter);
}
public class Akka.Event.Subscription`2 : object {
    [CompilerGeneratedAttribute]
private TSubscriber <Subscriber>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<TClassifier> <Unsubscriptions>k__BackingField;
    public TSubscriber Subscriber { get; private set; }
    public ISet`1<TClassifier> Unsubscriptions { get; private set; }
    public Subscription`2(TSubscriber subscriber, IEnumerable`1<TClassifier> unsubscriptions);
    public Subscription`2(TSubscriber subscriber);
    [CompilerGeneratedAttribute]
public TSubscriber get_Subscriber();
    [CompilerGeneratedAttribute]
private void set_Subscriber(TSubscriber value);
    [CompilerGeneratedAttribute]
public ISet`1<TClassifier> get_Unsubscriptions();
    [CompilerGeneratedAttribute]
private void set_Unsubscriptions(ISet`1<TClassifier> value);
}
public class Akka.Event.SuppressedDeadLetter : AllDeadLetters {
    public SuppressedDeadLetter(IDeadLetterSuppression message, IActorRef sender, IActorRef recipient);
}
public class Akka.Event.TraceLogger : UntypedActor {
    protected virtual void OnReceive(object message);
}
public class Akka.Event.UnhandledMessage : AllDeadLetters {
    public UnhandledMessage(object message, IActorRef sender, IActorRef recipient);
}
public class Akka.Event.Warning : LogEvent {
    public Warning(string logSource, Type logClass, object message);
    public Warning(Exception cause, string logSource, Type logClass, object message);
    public virtual LogLevel LogLevel();
}
public class Akka.IO.Buffers.BufferPoolAllocationException : AkkaException {
    public BufferPoolAllocationException(string message);
    protected BufferPoolAllocationException(SerializationInfo info, StreamingContext context);
}
public class Akka.IO.Buffers.BufferPoolInfo : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Free>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Used>k__BackingField;
    public Type Type { get; }
    public long TotalSize { get; }
    public long Free { get; }
    public long Used { get; }
    public BufferPoolInfo(Type type, long totalSize, long free, long used);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public long get_TotalSize();
    [CompilerGeneratedAttribute]
public long get_Free();
    [CompilerGeneratedAttribute]
public long get_Used();
}
internal class Akka.IO.Buffers.DirectBufferPool : object {
    private static int Retries;
    private object _syncRoot;
    private int _bufferSize;
    private int _buffersPerSegment;
    private int _segmentSize;
    private int _maxSegmentCount;
    private ConcurrentStack`1<ArraySegment`1<byte>> _buffers;
    private List`1<Byte[]> _segments;
    private int TotalBufferSize { get; }
    public DirectBufferPool(ExtendedActorSystem system, Config config);
    public DirectBufferPool(int bufferSize, int buffersPerSegment, int initialSegments, int maxSegments);
    private int get_TotalBufferSize();
    public sealed virtual BufferPoolInfo Diagnostics();
    public virtual string ToString();
    private void AllocateSegment();
    public sealed virtual ArraySegment`1<byte> Rent();
    public sealed virtual IEnumerable`1<ArraySegment`1<byte>> Rent(int minimumSize);
    public sealed virtual void Release(ArraySegment`1<byte> buf);
    public sealed virtual void Release(IEnumerable`1<ArraySegment`1<byte>> buffers);
}
internal class Akka.IO.Buffers.DisabledBufferPool : object {
    private int _bufferSize;
    public DisabledBufferPool(ExtendedActorSystem system, Config config);
    public DisabledBufferPool(int bufferSize);
    public sealed virtual ArraySegment`1<byte> Rent();
    public sealed virtual IEnumerable`1<ArraySegment`1<byte>> Rent(int minimumSize);
    public sealed virtual void Release(ArraySegment`1<byte> buf);
    public sealed virtual void Release(IEnumerable`1<ArraySegment`1<byte>> buffers);
    public sealed virtual BufferPoolInfo Diagnostics();
    private ArraySegment`1<byte> RentOfSize(int size);
}
public interface Akka.IO.Buffers.IBufferPool {
    public abstract virtual ArraySegment`1<byte> Rent();
    public abstract virtual IEnumerable`1<ArraySegment`1<byte>> Rent(int minimumSize);
    public abstract virtual void Release(ArraySegment`1<byte> buf);
    public abstract virtual void Release(IEnumerable`1<ArraySegment`1<byte>> buf);
    public abstract virtual BufferPoolInfo Diagnostics();
}
public enum Akka.IO.ByteOrder : Enum {
    public int value__;
    public static ByteOrder BigEndian;
    public static ByteOrder LittleEndian;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("(Count = {_count}, Buffers = {_buffers})")]
public class Akka.IO.ByteString : object {
    [CompilerGeneratedAttribute]
private static ByteString <Empty>k__BackingField;
    private int _count;
    private ArraySegment`1[] _buffers;
    public static ByteString Empty { get; }
    public int Count { get; }
    public bool IsCompact { get; }
    public bool IsEmpty { get; }
    internal IList`1<ArraySegment`1<byte>> Buffers { get; }
    public byte Item { get; }
    private ByteString(ArraySegment`1[] buffers, int count);
    private ByteString(ArraySegment`1<byte> buffer);
    private ByteString(Byte[] array, int offset, int count);
    private static ByteString();
    internal static ByteString FromBuffers(IEnumerator`1<ArraySegment`1<byte>> buffers);
    public static ByteString CopyFrom(Byte[] array);
    public static ByteString CopyFrom(ArraySegment`1<byte> buffer);
    public static ByteString CopyFrom(Byte[] array, int offset, int count);
    public static ByteString CopyFrom(Memory`1<byte> memory);
    public static ByteString CopyFrom(Memory`1<byte> memory, int offset, int count);
    public static ByteString CopyFrom(Span`1<byte> span);
    public static ByteString CopyFrom(Span`1<byte> span, int offset, int count);
    public static ByteString CopyFrom(IEnumerable`1<ArraySegment`1<byte>> buffers);
    public static ByteString FromBytes(Byte[] array);
    public static ByteString FromBytes(ArraySegment`1<byte> buffer);
    public static ByteString FromBytes(Byte[] array, int offset, int count);
    public static ByteString FromBytes(IEnumerable`1<ArraySegment`1<byte>> buffers);
    public static ByteString FromString(string str);
    public static ByteString FromString(string str, Encoding encoding);
    [CompilerGeneratedAttribute]
public static ByteString get_Empty();
    public int get_Count();
    public bool get_IsCompact();
    public bool get_IsEmpty();
    internal IList`1<ArraySegment`1<byte>> get_Buffers();
    public byte get_Item(int index);
    public ByteString Compact();
    public ByteString Slice(int index);
    public ByteString Slice(int index, int count);
    private int GetBufferFittingIndex(int index, Int32& indexWithinBuffer);
    public int IndexOf(byte b);
    public int IndexOf(byte b, int from);
    public bool HasSubstring(ByteString other, int index);
    public Byte[] ToArray();
    public ByteString Concat(ByteString other);
    public int CopyTo(Byte[] buffer, int index, int count);
    public int CopyTo(Memory`1& buffer);
    public int CopyTo(Memory`1& buffer, int index, int count);
    public int CopyTo(Span`1& buffer);
    public int CopyTo(Span`1& buffer, int index, int count);
    public void WriteTo(Stream stream);
    [AsyncStateMachineAttribute("Akka.IO.ByteString/<WriteToAsync>d__48")]
public Task WriteToAsync(Stream stream);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ByteString other);
    [IteratorStateMachineAttribute("Akka.IO.ByteString/<GetEnumerator>d__52")]
public sealed virtual IEnumerator`1<byte> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public string ToString(Encoding encoding);
    public static bool op_Equality(ByteString x, ByteString y);
    public static bool op_Inequality(ByteString x, ByteString y);
    public static ByteString op_Explicit(Byte[] bytes);
    public static Byte[] op_Explicit(ByteString byteString);
    public static ByteString op_Addition(ByteString x, ByteString y);
}
[InternalApiAttribute]
public class Akka.IO.ConnectException : Exception {
    public ConnectException(string message);
}
public class Akka.IO.Dns : ExtensionIdProvider`1<DnsExt> {
    public static Dns Instance;
    private static Dns();
    public static Resolved Cached(string name, ActorSystem system);
    public static Resolved ResolveName(string name, ActorSystem system, IActorRef sender);
    public virtual DnsExt CreateExtension(ExtendedActorSystem system);
}
public abstract class Akka.IO.DnsBase : object {
    public virtual Resolved Cached(string name);
    public virtual Resolved Resolve(string name, ActorSystem system, IActorRef sender);
}
public class Akka.IO.DnsExt : IOExtension {
    private ExtendedActorSystem _system;
    private IActorRef _manager;
    [CompilerGeneratedAttribute]
private DnsSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private DnsBase <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private IDnsProvider <Provider>k__BackingField;
    public IActorRef Manager { get; }
    public DnsSettings Settings { get; private set; }
    public DnsBase Cache { get; private set; }
    public IDnsProvider Provider { get; private set; }
    public DnsExt(ExtendedActorSystem system);
    public virtual IActorRef get_Manager();
    public IActorRef GetResolver();
    [CompilerGeneratedAttribute]
public DnsSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(DnsSettings value);
    [CompilerGeneratedAttribute]
public DnsBase get_Cache();
    [CompilerGeneratedAttribute]
private void set_Cache(DnsBase value);
    [CompilerGeneratedAttribute]
public IDnsProvider get_Provider();
    [CompilerGeneratedAttribute]
private void set_Provider(IDnsProvider value);
}
public interface Akka.IO.IDnsProvider {
    public DnsBase Cache { get; }
    public Type ActorClass { get; }
    public Type ManagerClass { get; }
    public abstract virtual DnsBase get_Cache();
    public abstract virtual Type get_ActorClass();
    public abstract virtual Type get_ManagerClass();
}
public class Akka.IO.Inet : object {
}
public class Akka.IO.InetAddressDnsProvider : object {
    private DnsBase _cache;
    public DnsBase Cache { get; }
    public Type ActorClass { get; }
    public Type ManagerClass { get; }
    public sealed virtual DnsBase get_Cache();
    public sealed virtual Type get_ActorClass();
    public sealed virtual Type get_ManagerClass();
}
public class Akka.IO.InetAddressDnsResolver : ActorBase {
    private SimpleDnsCache _cache;
    private long _positiveTtl;
    private long _negativeTtl;
    private bool _useIpv6;
    public InetAddressDnsResolver(SimpleDnsCache cache, Config config);
    protected virtual bool Receive(object message);
}
public abstract class Akka.IO.IOExtension : object {
    public IActorRef Manager { get; }
    public abstract virtual IActorRef get_Manager();
}
internal interface Akka.IO.IPeriodicCacheCleanup {
    public abstract virtual void CleanUp();
}
[ExtensionAttribute]
internal static class Akka.IO.IpExtensions : object {
    internal static object GetInstanceField(Type type, object instance, string fieldName);
    [ExtensionAttribute]
public static IPAddress MapToIPv4(IPAddress ipa);
    [ExtensionAttribute]
public static IPAddress MapToIPv6(IPAddress ipa);
}
public interface Akka.IO.ISocketEventArgsPool {
    public BufferPoolInfo BufferPoolInfo { get; }
    public abstract virtual SocketAsyncEventArgs Acquire(IActorRef actor);
    public abstract virtual void Release(SocketAsyncEventArgs e);
    public abstract virtual BufferPoolInfo get_BufferPoolInfo();
}
internal class Akka.IO.PreallocatedSocketEventAgrsPool : object {
    private IBufferPool _bufferPool;
    private EventHandler`1<SocketAsyncEventArgs> _onComplete;
    public BufferPoolInfo BufferPoolInfo { get; }
    public PreallocatedSocketEventAgrsPool(int initSize, IBufferPool bufferPool, EventHandler`1<SocketAsyncEventArgs> onComplete);
    public sealed virtual SocketAsyncEventArgs Acquire(IActorRef actor);
    public sealed virtual void Release(SocketAsyncEventArgs e);
    public sealed virtual BufferPoolInfo get_BufferPoolInfo();
}
public class Akka.IO.SimpleDnsCache : DnsBase {
    private AtomicReference`1<Cache> _cache;
    private long _ticksBase;
    public virtual Resolved Cached(string name);
    protected virtual long Clock();
    internal void Put(Resolved r, long ttl);
    public sealed virtual void CleanUp();
}
public class Akka.IO.SimpleDnsManager : ActorBase {
    private DnsExt _ext;
    private ILoggingAdapter _log;
    private IActorRef _resolver;
    private IPeriodicCacheCleanup _cacheCleanup;
    private ICancelable _cleanupTimer;
    public SimpleDnsManager(DnsExt ext);
    protected virtual bool Receive(object message);
    protected virtual void PostStop();
}
[ExtensionAttribute]
internal static class Akka.IO.SocketAsyncEventArgsExtensions : object {
    [ExtensionAttribute]
public static void SetBuffer(SocketAsyncEventArgs args, ByteString data);
    [ExtensionAttribute]
public static void SetBuffer(SocketAsyncEventArgs args, IEnumerable`1<ByteString> dataCollection);
}
public class Akka.IO.Tcp : ExtensionIdProvider`1<TcpExt> {
    public static Tcp Instance;
    public static SupervisorStrategy ConnectionSupervisorStrategy;
    private static Tcp();
    public static IActorRef Manager(ActorSystem system);
    public virtual TcpExt CreateExtension(ExtendedActorSystem system);
}
internal abstract class Akka.IO.TcpConnection : ActorBase {
    private ConnectionStatus _status;
    protected TcpExt Tcp;
    protected Socket Socket;
    protected SocketAsyncEventArgs ReceiveArgs;
    protected SocketAsyncEventArgs SendArgs;
    protected ILoggingAdapter Log;
    private bool _pullMode;
    private PendingSimpleWritesQueue _writeCommandsQueue;
    private bool _traceLogging;
    private bool _isOutputShutdown;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentQueue`1<ValueTuple`2<IActorRef, object>> _pendingAcks;
    private bool _peerClosed;
    private IActorRef _interestedInResume;
    private CloseInformation _closedMessage;
    private IActorRef _watchedActor;
    private IOException droppingWriteBecauseWritingIsSuspendedException;
    private IOException droppingWriteBecauseQueueIsFullException;
    private bool IsWritePending { get; }
    protected TcpConnection(TcpExt tcp, Socket socket, bool pullMode, Option`1<int> writeCommandsBufferMaxSize);
    private bool get_IsWritePending();
    private Option`1<PendingWrite> GetAllowedPendingWrite();
    protected void SignDeathPact(IActorRef actor);
    protected void UnsignDeathPact();
    private Receive WaitingForRegistration(IActorRef commander);
    private Receive Connected(ConnectionInfo info);
    private Receive PeerSentEOF(ConnectionInfo info);
    private Receive ClosingWithPendingWrite(ConnectionInfo info, IActorRef closeCommander, ConnectionClosed closedEvent);
    private Receive Closing(ConnectionInfo info, IActorRef closeCommander);
    private Receive HandleWriteMessages(ConnectionInfo info);
    private void DropWrite(ConnectionInfo info, WriteCommand write);
    protected void CompleteConnect(IActorRef commander, IEnumerable`1<SocketOption> options);
    private void SuspendReading();
    private void ResumeReading();
    private void AcknowledgeSent();
    private void DoRead(ConnectionInfo info, IActorRef closeCommander);
    private ReadResult InnerRead(ConnectionInfo info, int remainingLimit, SocketAsyncEventArgs ea);
    private void DoWrite(ConnectionInfo info, Option`1<PendingWrite> write);
    private void HandleClose(ConnectionInfo info, IActorRef closeCommander, ConnectionClosed closedEvent);
    private void DoCloseConnection(ConnectionInfo info, IActorRef closeCommander, ConnectionClosed closedEvent);
    private void HandleError(IActorRef handler, SocketException exception);
    private bool SafeShutdownOutput();
    protected void AcquireSocketAsyncEventArgs();
    private void ReleaseSocketAsyncEventArgs();
    protected SocketAsyncEventArgs CreateSocketEventArgs(IActorRef onCompleteNotificationsReceiver);
    protected void ReleaseSocketEventArgs(SocketAsyncEventArgs e);
    private void CloseSocket();
    private void Abort();
    protected void StopWith(CloseInformation closeInfo);
    private void ReceiveAsync();
    private bool HasStatus(ConnectionStatus connectionStatus);
    private void SetStatus(ConnectionStatus connectionStatus);
    private void ClearStatus(ConnectionStatus connectionStatus);
    protected virtual void PostStop();
    protected virtual void PostRestart(Exception reason);
    private Option`1<PendingWrite> GetNextWrite(IEnumerable`1<ValueTuple`2<SimpleWriteCommand, IActorRef>> headCommands);
    private PendingWrite CreatePendingBufferWrite(List`1<ValueTuple`2<Write, IActorRef>> writes);
    [CompilerGeneratedAttribute]
internal static SocketCompleted <CreateSocketEventArgs>g__ResolveMessage|44_0(SocketAsyncEventArgs e);
}
public class Akka.IO.TcpExt : IOExtension {
    [CompilerGeneratedAttribute]
private IActorRef <Manager>k__BackingField;
    [CompilerGeneratedAttribute]
private IBufferPool <BufferPool>k__BackingField;
    [CompilerGeneratedAttribute]
private TcpSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDispatcher <FileIoDispatcher>k__BackingField;
    public IActorRef Manager { get; }
    public IBufferPool BufferPool { get; }
    public TcpSettings Settings { get; }
    internal MessageDispatcher FileIoDispatcher { get; }
    public TcpExt(ExtendedActorSystem system);
    internal TcpExt(ExtendedActorSystem system, TcpSettings settings);
    [CompilerGeneratedAttribute]
public virtual IActorRef get_Manager();
    [CompilerGeneratedAttribute]
public IBufferPool get_BufferPool();
    [CompilerGeneratedAttribute]
public TcpSettings get_Settings();
    [CompilerGeneratedAttribute]
internal MessageDispatcher get_FileIoDispatcher();
    private IBufferPool CreateBufferPool(ExtendedActorSystem system, Config config);
}
[ExtensionAttribute]
public static class Akka.IO.TcpExtensions : object {
    [ExtensionAttribute]
public static IActorRef Tcp(ActorSystem system);
}
internal class Akka.IO.TcpIncomingConnection : TcpConnection {
    private IActorRef _bindHandler;
    private IEnumerable`1<SocketOption> _options;
    public TcpIncomingConnection(TcpExt tcp, Socket socket, IActorRef bindHandler, IEnumerable`1<SocketOption> options, bool readThrottling);
    protected virtual void PreStart();
    protected virtual bool Receive(object message);
}
internal class Akka.IO.TcpListener : ActorBase {
    private TcpExt _tcp;
    private IActorRef _bindCommander;
    private Bind _bind;
    private Socket _socket;
    private ILoggingAdapter _log;
    private int _acceptLimit;
    private SocketAsyncEventArgs[] _saeas;
    private bool _binding;
    public TcpListener(TcpExt tcp, IActorRef bindCommander, Bind bind);
    private Receive Initializing();
    private Receive Bound();
    private Receive Unbinding(IActorRef requester);
    [IteratorStateMachineAttribute("Akka.IO.TcpListener/<Accept>d__12")]
private IEnumerable`1<SocketAsyncEventArgs> Accept(int limit);
    private Task`1<Bound> BindAsync();
    private Task`1<Unbound> UnbindAsync();
    protected virtual SupervisorStrategy SupervisorStrategy();
    protected virtual bool Receive(object message);
    protected virtual void PostStop();
    [CompilerGeneratedAttribute]
private bool <Initializing>b__9_0(object message);
    [CompilerGeneratedAttribute]
private bool <Bound>b__10_0(object message);
    [CompilerGeneratedAttribute]
private void <BindAsync>b__13_0(SocketOption x);
}
internal class Akka.IO.TcpManager : ActorBase {
    private TcpExt _tcp;
    public TcpManager(TcpExt tcp);
    protected virtual bool Receive(object message);
}
public class Akka.IO.TcpMessage : object {
    public static Command Connect(EndPoint remoteAddress, EndPoint localAddress, IEnumerable`1<SocketOption> options, Nullable`1<TimeSpan> timeout, bool pullMode);
    public static Command Connect(EndPoint remoteAddress);
    public static Command Bind(IActorRef handler, EndPoint endpoint, int backlog, IEnumerable`1<SocketOption> options, bool pullMode);
    public static Command Bind(IActorRef handler, EndPoint endpoint, int backlog);
    public static Command Register(IActorRef handler, bool keepOpenOnPeerClosed, bool useResumeWriting);
    public static Command Unbind();
    public static Command Close();
    public static Command ConfirmedClose();
    public static Command Abort();
    public static NoAck NoAck(object token);
    public static Command Write(ByteString data, Event ack);
    public static Command ResumeWriting();
    public static Command SuspendReading();
    public static Command ResumeReading();
    public static Command ResumeAccepting(int batchSize);
}
internal class Akka.IO.TcpOutgoingConnection : TcpConnection {
    private IActorRef _commander;
    private Connect _connect;
    private SocketAsyncEventArgs _connectArgs;
    private ConnectException finishConnectNeverReturnedTrueException;
    public TcpOutgoingConnection(TcpExt tcp, IActorRef commander, Connect connect);
    private void ReleaseConnectionSocketArgs();
    private void Stop(Exception cause);
    private void ReportConnectFailure(Action thunk);
    protected virtual void PreStart();
    protected virtual void PostStop();
    protected virtual bool Receive(object message);
    private Receive Resolving(DnsEndPoint remoteAddress);
    private void Register(IPEndPoint address, IPEndPoint fallbackAddress);
    private Receive Connecting(int remainingFinishConnectRetries, SocketAsyncEventArgs args, IPEndPoint fallbackAddress);
    [CompilerGeneratedAttribute]
private void <PreStart>b__8_0();
}
public class Akka.IO.TcpSettings : object {
    [CompilerGeneratedAttribute]
private string <BufferPoolConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialSocketAsyncEventArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchAcceptLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RegisterTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceivedMessageSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManagementDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileIODispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransferToLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FinishConnectRetries>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutgoingSocketForceIpv4>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WriteCommandsQueueMaxSize>k__BackingField;
    public string BufferPoolConfigPath { get; }
    public int InitialSocketAsyncEventArgs { get; }
    public bool TraceLogging { get; }
    public int BatchAcceptLimit { get; }
    public Nullable`1<TimeSpan> RegisterTimeout { get; }
    public int ReceivedMessageSizeLimit { get; }
    public string ManagementDispatcher { get; }
    public string FileIODispatcher { get; }
    public int TransferToLimit { get; public set; }
    public int FinishConnectRetries { get; }
    public bool OutgoingSocketForceIpv4 { get; }
    public int WriteCommandsQueueMaxSize { get; }
    public TcpSettings(string bufferPoolConfigPath, int initialSocketAsyncEventArgs, bool traceLogging, int batchAcceptLimit, Nullable`1<TimeSpan> registerTimeout, int receivedMessageSizeLimit, string managementDispatcher, string fileIoDispatcher, int transferToLimit, int finishConnectRetries, bool outgoingSocketForceIpv4, int writeCommandsQueueMaxSize);
    public static TcpSettings Create(ActorSystem system);
    public static TcpSettings Create(Config config);
    [CompilerGeneratedAttribute]
public string get_BufferPoolConfigPath();
    [CompilerGeneratedAttribute]
public int get_InitialSocketAsyncEventArgs();
    [CompilerGeneratedAttribute]
public bool get_TraceLogging();
    [CompilerGeneratedAttribute]
public int get_BatchAcceptLimit();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RegisterTimeout();
    [CompilerGeneratedAttribute]
public int get_ReceivedMessageSizeLimit();
    [CompilerGeneratedAttribute]
public string get_ManagementDispatcher();
    [CompilerGeneratedAttribute]
public string get_FileIODispatcher();
    [CompilerGeneratedAttribute]
public int get_TransferToLimit();
    [CompilerGeneratedAttribute]
public void set_TransferToLimit(int value);
    [CompilerGeneratedAttribute]
public int get_FinishConnectRetries();
    [CompilerGeneratedAttribute]
public bool get_OutgoingSocketForceIpv4();
    [CompilerGeneratedAttribute]
public int get_WriteCommandsQueueMaxSize();
}
public class Akka.IO.Udp : ExtensionIdProvider`1<UdpExt> {
    public static Udp Instance;
    private static Udp();
    public static IActorRef Manager(ActorSystem system);
    public virtual UdpExt CreateExtension(ExtendedActorSystem system);
}
public class Akka.IO.UdpConnected : ExtensionIdProvider`1<UdpConnectedExt> {
    public static UdpConnected Instance;
    private static UdpConnected();
    public virtual UdpConnectedExt CreateExtension(ExtendedActorSystem system);
}
public class Akka.IO.UdpConnectedExt : IOExtension {
    [CompilerGeneratedAttribute]
private IActorRef <Manager>k__BackingField;
    [CompilerGeneratedAttribute]
private ISocketEventArgsPool <SocketEventArgsPool>k__BackingField;
    [CompilerGeneratedAttribute]
private UdpSettings <Settings>k__BackingField;
    public IActorRef Manager { get; }
    internal ISocketEventArgsPool SocketEventArgsPool { get; }
    internal UdpSettings Settings { get; }
    public UdpConnectedExt(ExtendedActorSystem system);
    public UdpConnectedExt(ExtendedActorSystem system, UdpSettings settings);
    [CompilerGeneratedAttribute]
public virtual IActorRef get_Manager();
    [CompilerGeneratedAttribute]
internal ISocketEventArgsPool get_SocketEventArgsPool();
    [CompilerGeneratedAttribute]
internal UdpSettings get_Settings();
    private static IBufferPool CreateBufferPool(ExtendedActorSystem system, Config config);
    private void OnComplete(object sender, SocketAsyncEventArgs e);
    private static SocketCompleted ResolveMessage(SocketAsyncEventArgs e);
}
[InternalApiAttribute]
internal class Akka.IO.UdpConnectedManager : ActorBase {
    private UdpConnectedExt _udpConn;
    public UdpConnectedManager(UdpConnectedExt udpConn);
    protected virtual bool Receive(object message);
}
internal class Akka.IO.UdpConnection : ActorBase {
    protected UdpConnectedExt Udp;
    private IActorRef _commander;
    private Connect _connect;
    protected ILoggingAdapter Log;
    private Socket _socket;
    private bool _readingSuspended;
    private Received _pendingRead;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<Send, IActorRef>> _pendingSend;
    private SocketAsyncEventArgs _pendingReceive;
    private bool WritePending { get; }
    public UdpConnection(UdpConnectedExt udp, IActorRef commander, Connect connect);
    private bool get_WritePending();
    private Receive Resolving(DnsEndPoint remoteAddress);
    private void DoConnect(EndPoint address);
    protected virtual bool Receive(object message);
    private bool Connected(object message);
    private void DoRead(SocketReceived received, IActorRef handler);
    private void DoWrite();
    protected virtual void PostStop();
    private void ReportConnectFailure(Action thunk);
    private void ReceiveAsync();
}
public class Akka.IO.UdpExt : IOExtension {
    [CompilerGeneratedAttribute]
private IActorRef <Manager>k__BackingField;
    [CompilerGeneratedAttribute]
private UdpSettings <Setting>k__BackingField;
    [CompilerGeneratedAttribute]
private PreallocatedSocketEventAgrsPool <SocketEventArgsPool>k__BackingField;
    public IActorRef Manager { get; }
    internal UdpSettings Setting { get; }
    internal PreallocatedSocketEventAgrsPool SocketEventArgsPool { get; }
    public UdpExt(ExtendedActorSystem system);
    public UdpExt(ExtendedActorSystem system, UdpSettings settings);
    [CompilerGeneratedAttribute]
public virtual IActorRef get_Manager();
    [CompilerGeneratedAttribute]
internal UdpSettings get_Setting();
    [CompilerGeneratedAttribute]
internal PreallocatedSocketEventAgrsPool get_SocketEventArgsPool();
    private static IBufferPool CreateBufferPool(ExtendedActorSystem system, Config config);
    private void OnComplete(object sender, SocketAsyncEventArgs e);
    private static SocketCompleted ResolveMessage(SocketAsyncEventArgs e);
}
[ExtensionAttribute]
public static class Akka.IO.UdpExtensions : object {
    [ExtensionAttribute]
public static IActorRef Udp(ActorSystem system);
}
[InternalApiAttribute]
internal class Akka.IO.UdpListener : WithUdpSend {
    private IActorRef _bindCommander;
    private Bind _bind;
    protected ILoggingAdapter Log;
    [CompilerGeneratedAttribute]
private Socket <Socket>k__BackingField;
    [CompilerGeneratedAttribute]
private UdpExt <Udp>k__BackingField;
    protected Socket Socket { get; }
    protected UdpExt Udp { get; }
    public UdpListener(UdpExt udp, IActorRef bindCommander, Bind bind);
    [CompilerGeneratedAttribute]
protected sealed virtual Socket get_Socket();
    [CompilerGeneratedAttribute]
protected sealed virtual UdpExt get_Udp();
    protected virtual void PreStart();
    protected virtual bool Receive(object message);
    private bool ReadHandlers(object message);
    private void DoReceive(SocketReceived e, IActorRef handler);
    protected virtual void PostStop();
    private void ReceiveAsync();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(SocketOptionV2 x);
    [CompilerGeneratedAttribute]
private bool <PreStart>b__10_0(object m);
}
internal class Akka.IO.UdpManager : ActorBase {
    private UdpExt _udp;
    public UdpManager(UdpExt udp);
    protected virtual bool Receive(object message);
}
internal class Akka.IO.UdpSender : WithUdpSend {
    private UdpExt _udp;
    private IActorRef _commander;
    private IEnumerable`1<SocketOption> _options;
    private Socket _socket;
    private ILoggingAdapter _log;
    protected UdpExt Udp { get; }
    protected Socket Socket { get; }
    public UdpSender(UdpExt udp, IActorRef commander, IEnumerable`1<SocketOption> options);
    protected virtual UdpExt get_Udp();
    protected virtual Socket get_Socket();
    public virtual void AroundPreStart();
    protected virtual bool Receive(object message);
    protected virtual void PostStop();
    [CompilerGeneratedAttribute]
private Socket <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private void <AroundPreStart>b__10_0(SocketOptionV2 x);
}
public class Akka.IO.UdpSettings : object {
    [CompilerGeneratedAttribute]
private string <BufferPoolConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialSocketAsyncEventArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchReceiveLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManagementDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileIODispatcher>k__BackingField;
    public string BufferPoolConfigPath { get; }
    public bool TraceLogging { get; }
    public int InitialSocketAsyncEventArgs { get; }
    public int BatchReceiveLimit { get; }
    public string ManagementDispatcher { get; }
    public string FileIODispatcher { get; }
    public UdpSettings(string bufferPoolConfigPath, bool traceLogging, int initialSocketAsyncEventArgs, int batchReceiveLimit, string managementDispatcher, string fileIoDispatcher);
    public static UdpSettings Create(ActorSystem system);
    public static UdpSettings Create(Config config);
    [CompilerGeneratedAttribute]
public string get_BufferPoolConfigPath();
    [CompilerGeneratedAttribute]
public bool get_TraceLogging();
    [CompilerGeneratedAttribute]
public int get_InitialSocketAsyncEventArgs();
    [CompilerGeneratedAttribute]
public int get_BatchReceiveLimit();
    [CompilerGeneratedAttribute]
public string get_ManagementDispatcher();
    [CompilerGeneratedAttribute]
public string get_FileIODispatcher();
}
internal abstract class Akka.IO.WithUdpSend : ActorBase {
    private ILoggingAdapter _log;
    private Send _pendingSend;
    private IActorRef _pendingCommander;
    private bool _retriedSend;
    private bool HasWritePending { get; }
    protected Socket Socket { get; }
    protected UdpExt Udp { get; }
    private bool get_HasWritePending();
    protected abstract virtual Socket get_Socket();
    protected abstract virtual UdpExt get_Udp();
    public bool SendHandlers(object message);
    private void DoSend();
}
public class Akka.NotUsed : object {
    public static NotUsed Instance;
    private static NotUsed();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(NotUsed other);
    public sealed virtual int CompareTo(NotUsed other);
}
internal class Akka.Pattern.AutoReset : object {
    [CompilerGeneratedAttribute]
private TimeSpan <ResetBackoff>k__BackingField;
    public TimeSpan ResetBackoff { get; }
    public AutoReset(TimeSpan resetBackoff);
    [CompilerGeneratedAttribute]
public TimeSpan get_ResetBackoff();
}
public static class Akka.Pattern.Backoff : object {
    [ObsoleteAttribute("Use the overloaded one which accepts maxNrOfRetries instead.")]
public static BackoffOptions OnFailure(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor);
    public static BackoffOptions OnFailure(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries);
    [ObsoleteAttribute("Use the overloaded one which accepts maxNrOfRetries instead.")]
public static BackoffOptions OnStop(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor);
    public static BackoffOptions OnStop(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries);
}
internal class Akka.Pattern.BackoffOnRestartSupervisor : BackoffSupervisorBase {
    private TimeSpan _minBackoff;
    private TimeSpan _maxBackoff;
    private double _randomFactor;
    private OneForOneStrategy _strategy;
    private ILoggingAdapter _log;
    public BackoffOnRestartSupervisor(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, IBackoffReset reset, double randomFactor, OneForOneStrategy strategy, object replyWhileStopped, Func`2<object, bool> finalStopMessage);
    protected virtual SupervisorStrategy SupervisorStrategy();
    protected virtual bool Receive(object message);
    private Receive WaitChildTerminatedBeforeBackoff(IActorRef childRef);
    private bool WaitChildTerminatedBeforeBackoff(object message, IActorRef childRef);
    private bool OnTerminated(object message);
    [CompilerGeneratedAttribute]
private Directive <SupervisorStrategy>b__6_0(Exception ex);
}
public abstract class Akka.Pattern.BackoffOptions : object {
    internal Props Props { get; }
    public abstract virtual BackoffOptions WithAutoReset(TimeSpan resetBackoff);
    public abstract virtual BackoffOptions WithManualReset();
    public abstract virtual BackoffOptions WithSupervisorStrategy(OneForOneStrategy supervisorStrategy);
    public abstract virtual BackoffOptions WithDefaultStoppingStrategy();
    public abstract virtual BackoffOptions WithReplyWhileStopped(object replyWhileStopped);
    public abstract virtual BackoffOptions WithMaxNrOfRetries(int maxNrOfRetries);
    public abstract virtual BackoffOptions WithFinalStopMessage(Func`2<object, bool> isFinalStopMessage);
    internal abstract virtual Props get_Props();
}
internal class Akka.Pattern.BackoffOptionsImpl : BackoffOptions {
    private IBackoffType _backoffType;
    private Props _childProps;
    private string _childName;
    private TimeSpan _minBackoff;
    private TimeSpan _maxBackoff;
    private double _randomFactor;
    private IBackoffReset _reset;
    private OneForOneStrategy _strategy;
    private object _replyWhileStopped;
    private Func`2<object, bool> _finalStopMessage;
    internal Props Props { get; }
    public BackoffOptionsImpl(IBackoffType backoffType, Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor, IBackoffReset reset);
    public BackoffOptionsImpl(IBackoffType backoffType, Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor, IBackoffReset reset, OneForOneStrategy strategy, object replyWhileStopped, Func`2<object, bool> finalStopMessage);
    public virtual BackoffOptions WithAutoReset(TimeSpan resetBackoff);
    public virtual BackoffOptions WithManualReset();
    public virtual BackoffOptions WithSupervisorStrategy(OneForOneStrategy supervisorStrategy);
    public virtual BackoffOptions WithDefaultStoppingStrategy();
    public virtual BackoffOptions WithReplyWhileStopped(object replyWhileStopped);
    public virtual BackoffOptions WithMaxNrOfRetries(int maxNrOfRetries);
    public virtual BackoffOptions WithFinalStopMessage(Func`2<object, bool> isFinalStopMessage);
    internal virtual Props get_Props();
}
public class Akka.Pattern.BackoffSupervisor : BackoffSupervisorBase {
    private TimeSpan _minBackoff;
    private TimeSpan _maxBackoff;
    private double _randomFactor;
    private SupervisorStrategy _strategy;
    public BackoffSupervisor(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor);
    public BackoffSupervisor(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, IBackoffReset reset, double randomFactor, SupervisorStrategy strategy, object replyWhileStopped, Func`2<object, bool> finalStopMessage);
    protected virtual SupervisorStrategy SupervisorStrategy();
    protected virtual bool Receive(object message);
    private bool OnTerminated(object message);
    public static Props Props(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor);
    public static Props Props(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor, int maxNrOfRetries);
    public static Props Props(BackoffOptions options);
    public static Props PropsWithSupervisorStrategy(Props childProps, string childName, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor, SupervisorStrategy strategy);
    internal static TimeSpan CalculateDelay(int restartCount, TimeSpan minBackoff, TimeSpan maxBackoff, double randomFactor);
}
public abstract class Akka.Pattern.BackoffSupervisorBase : ActorBase {
    [CompilerGeneratedAttribute]
private Props <ChildProps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChildName>k__BackingField;
    [CompilerGeneratedAttribute]
private IBackoffReset <Reset>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ReplyWhileStopped>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, bool> <FinalStopMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <Child>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RestartCountN>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FinalStopMessageReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggingAdapter <Log>k__BackingField;
    protected Props ChildProps { get; }
    protected string ChildName { get; }
    protected IBackoffReset Reset { get; }
    protected object ReplyWhileStopped { get; }
    protected Func`2<object, bool> FinalStopMessage { get; }
    protected IActorRef Child { get; protected set; }
    protected int RestartCountN { get; protected set; }
    protected bool FinalStopMessageReceived { get; protected set; }
    internal ILoggingAdapter Log { get; }
    internal BackoffSupervisorBase(Props childProps, string childName, IBackoffReset reset, object replyWhileStopped, Func`2<object, bool> finalStopMessage);
    [CompilerGeneratedAttribute]
protected Props get_ChildProps();
    [CompilerGeneratedAttribute]
protected string get_ChildName();
    [CompilerGeneratedAttribute]
protected IBackoffReset get_Reset();
    [CompilerGeneratedAttribute]
protected object get_ReplyWhileStopped();
    [CompilerGeneratedAttribute]
protected Func`2<object, bool> get_FinalStopMessage();
    [CompilerGeneratedAttribute]
protected IActorRef get_Child();
    [CompilerGeneratedAttribute]
protected void set_Child(IActorRef value);
    [CompilerGeneratedAttribute]
protected int get_RestartCountN();
    [CompilerGeneratedAttribute]
protected void set_RestartCountN(int value);
    [CompilerGeneratedAttribute]
protected bool get_FinalStopMessageReceived();
    [CompilerGeneratedAttribute]
protected void set_FinalStopMessageReceived(bool value);
    [CompilerGeneratedAttribute]
internal ILoggingAdapter get_Log();
    protected virtual void PreStart();
    private void StartChild();
    protected bool HandleBackoff(object message);
}
public class Akka.Pattern.CircuitBreaker : object {
    private AtomicState _currentState;
    private long _currentResetTimeout;
    [CompilerGeneratedAttribute]
private IScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CallTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ResetTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxResetTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ExponentialBackoffFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RandomFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicState <Closed>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicState <Open>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicState <HalfOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <LastCaughtException>k__BackingField;
    private AtomicState CurrentState { get; }
    internal TimeSpan CurrentResetTimeout { get; }
    public IScheduler Scheduler { get; }
    public int MaxFailures { get; }
    public TimeSpan CallTimeout { get; }
    public TimeSpan ResetTimeout { get; }
    public TimeSpan MaxResetTimeout { get; }
    public double ExponentialBackoffFactor { get; }
    public double RandomFactor { get; }
    private AtomicState Closed { get; private set; }
    private AtomicState Open { get; private set; }
    private AtomicState HalfOpen { get; private set; }
    public long CurrentFailureCount { get; }
    public Exception LastCaughtException { get; private set; }
    public bool IsClosed { get; }
    public bool IsOpen { get; }
    public bool IsHalfOpen { get; }
    public CircuitBreaker(IScheduler scheduler, int maxFailures, TimeSpan callTimeout, TimeSpan resetTimeout);
    public CircuitBreaker(IScheduler scheduler, int maxFailures, TimeSpan callTimeout, TimeSpan resetTimeout, TimeSpan maxResetTimeout, double exponentialBackoffFactor);
    public CircuitBreaker(IScheduler scheduler, int maxFailures, TimeSpan callTimeout, TimeSpan resetTimeout, TimeSpan maxResetTimeout, double exponentialBackoffFactor, double randomFactor);
    private bool SwapState(AtomicState oldState, AtomicState newState);
    private AtomicState get_CurrentState();
    internal bool SwapStateResetTimeout(TimeSpan oldResetTimeout, TimeSpan newResetTimeout);
    internal TimeSpan get_CurrentResetTimeout();
    [CompilerGeneratedAttribute]
public IScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
public int get_MaxFailures();
    [CompilerGeneratedAttribute]
public TimeSpan get_CallTimeout();
    [CompilerGeneratedAttribute]
public TimeSpan get_ResetTimeout();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxResetTimeout();
    [CompilerGeneratedAttribute]
public double get_ExponentialBackoffFactor();
    [CompilerGeneratedAttribute]
public double get_RandomFactor();
    [CompilerGeneratedAttribute]
private AtomicState get_Closed();
    [CompilerGeneratedAttribute]
private void set_Closed(AtomicState value);
    [CompilerGeneratedAttribute]
private AtomicState get_Open();
    [CompilerGeneratedAttribute]
private void set_Open(AtomicState value);
    [CompilerGeneratedAttribute]
private AtomicState get_HalfOpen();
    [CompilerGeneratedAttribute]
private void set_HalfOpen(AtomicState value);
    public static CircuitBreaker Create(IScheduler scheduler, int maxFailures, TimeSpan callTimeout, TimeSpan resetTimeout);
    public long get_CurrentFailureCount();
    [CompilerGeneratedAttribute]
public Exception get_LastCaughtException();
    [CompilerGeneratedAttribute]
private void set_LastCaughtException(Exception value);
    public Task`1<T> WithCircuitBreaker(Func`1<Task`1<T>> body);
    public Task`1<T> WithCircuitBreaker(TState state, Func`2<TState, Task`1<T>> body);
    public Task WithCircuitBreaker(Func`1<Task> body);
    public Task WithCircuitBreaker(TState state, Func`2<TState, Task> body);
    public void WithSyncCircuitBreaker(Action body);
    public T WithSyncCircuitBreaker(Func`1<T> body);
    public void Succeed();
    internal void OnSuccess();
    public void Fail();
    internal void OnFail(Exception cause);
    public bool get_IsClosed();
    public bool get_IsOpen();
    public bool get_IsHalfOpen();
    public CircuitBreaker OnOpen(Action callback);
    public CircuitBreaker OnHalfOpen(Action callback);
    public CircuitBreaker OnClose(Action callback);
    public CircuitBreaker WithExponentialBackoff(TimeSpan maxResetTimeout);
    public CircuitBreaker WithRandomFactor(double randomFactor);
    private void Transition(AtomicState fromState, AtomicState toState);
    internal void TripBreaker(AtomicState fromState);
    internal void ResetBreaker();
    internal void AttemptReset();
}
internal class Akka.Pattern.Closed : AtomicState {
    private CircuitBreaker _breaker;
    public Closed(CircuitBreaker breaker);
    public virtual Task`1<T> Invoke(Func`1<Task`1<T>> body);
    public virtual Task`1<T> InvokeState(TState state, Func`2<TState, Task`1<T>> body);
    public virtual Task Invoke(Func`1<Task> body);
    public virtual Task InvokeState(TState state, Func`2<TState, Task> body);
    protected internal virtual void CallFails(Exception cause);
    protected internal virtual void CallSucceeds();
    protected virtual void EnterInternal();
    public virtual string ToString();
}
public static class Akka.Pattern.FutureTimeoutSupport : object {
    public static Task`1<T> After(TimeSpan duration, IScheduler scheduler, Func`1<Task`1<T>> value);
}
internal class Akka.Pattern.HalfOpen : AtomicState {
    private CircuitBreaker _breaker;
    private AtomicBoolean _lock;
    public HalfOpen(CircuitBreaker breaker);
    private void CheckState();
    public virtual Task`1<T> Invoke(Func`1<Task`1<T>> body);
    public virtual Task`1<T> InvokeState(TState state, Func`2<TState, Task`1<T>> body);
    [AsyncStateMachineAttribute("Akka.Pattern.HalfOpen/<Invoke>d__6")]
public virtual Task Invoke(Func`1<Task> body);
    [AsyncStateMachineAttribute("Akka.Pattern.HalfOpen/<InvokeState>d__7`1")]
public virtual Task InvokeState(TState state, Func`2<TState, Task> body);
    protected internal virtual void CallFails(Exception cause);
    protected internal virtual void CallSucceeds();
    protected virtual void EnterInternal();
    public virtual string ToString();
}
public interface Akka.Pattern.IBackoffReset {
}
internal interface Akka.Pattern.IBackoffType {
}
public class Akka.Pattern.IllegalStateException : AkkaException {
    public IllegalStateException(string message);
    public IllegalStateException(string message, Exception innerEx);
    protected IllegalStateException(SerializationInfo info, StreamingContext context);
}
internal class Akka.Pattern.ManualReset : object {
}
internal class Akka.Pattern.Open : AtomicState {
    private CircuitBreaker _breaker;
    public Open(CircuitBreaker breaker);
    private TimeSpan RemainingDuration();
    public virtual Task`1<T> Invoke(Func`1<Task`1<T>> body);
    public virtual Task InvokeState(TState state, Func`2<TState, Task> body);
    public virtual Task`1<T> InvokeState(TState state, Func`2<TState, Task`1<T>> body);
    public virtual Task Invoke(Func`1<Task> body);
    protected internal virtual void CallFails(Exception cause);
    protected internal virtual void CallSucceeds();
    protected virtual void EnterInternal();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <EnterInternal>b__9_0();
}
public class Akka.Pattern.OpenCircuitException : AkkaException {
    [CompilerGeneratedAttribute]
private TimeSpan <RemainingDuration>k__BackingField;
    public TimeSpan RemainingDuration { get; }
    public OpenCircuitException(string message);
    public OpenCircuitException(string message, TimeSpan remainingDuration);
    public OpenCircuitException(string message, Exception cause);
    public OpenCircuitException(string message, Exception cause, TimeSpan remainingDuration);
    public OpenCircuitException(Exception cause);
    public OpenCircuitException(Exception cause, TimeSpan remainingDuration);
    protected OpenCircuitException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public TimeSpan get_RemainingDuration();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Akka.Pattern.RestartImpliesFailure : object {
    public static RestartImpliesFailure Instance;
    private static RestartImpliesFailure();
}
public static class Akka.Pattern.RetrySupport : object {
    public static Task`1<T> Retry(Func`1<Task`1<T>> attempt, int attempts);
    public static Task`1<T> Retry(Func`1<Task`1<T>> attempt, int attempts, TimeSpan minBackoff, TimeSpan maxBackoff, int randomFactor, IScheduler scheduler);
    public static Task`1<T> Retry(Func`1<Task`1<T>> attempt, int attempts, TimeSpan delay, IScheduler scheduler);
    public static Task`1<T> Retry(Func`1<Task`1<T>> attempt, int attempts, Func`2<int, Option`1<TimeSpan>> delayFunction, IScheduler scheduler);
    private static Task`1<T> Retry(Func`1<Task`1<T>> attempt, int maxAttempts, int attempted);
    private static Task`1<T> Retry(Func`1<Task`1<T>> attempt, int maxAttempts, Func`2<int, Option`1<TimeSpan>> delayFunction, int attempted, IScheduler scheduler);
}
internal class Akka.Pattern.StopImpliesFailure : object {
    public static StopImpliesFailure Instance;
    private static StopImpliesFailure();
}
public class Akka.Pattern.UserCalledFailException : AkkaException {
    protected UserCalledFailException(SerializationInfo info, StreamingContext context);
}
public class Akka.Routing.ActorRefRoutee : Routee {
    [CompilerGeneratedAttribute]
private IActorRef <Actor>k__BackingField;
    public IActorRef Actor { get; }
    public ActorRefRoutee(IActorRef actor);
    [CompilerGeneratedAttribute]
public IActorRef get_Actor();
    public virtual void Send(object message, IActorRef sender);
    public virtual Task`1<object> Ask(object message, Nullable`1<TimeSpan> timeout);
    public virtual bool Equals(object obj);
    protected bool Equals(ActorRefRoutee other);
    public virtual int GetHashCode();
}
public class Akka.Routing.ActorSelectionRoutee : Routee {
    [CompilerGeneratedAttribute]
private ActorSelection <Selection>k__BackingField;
    public ActorSelection Selection { get; }
    public ActorSelectionRoutee(ActorSelection actor);
    [CompilerGeneratedAttribute]
public ActorSelection get_Selection();
    public virtual void Send(object message, IActorRef sender);
    public virtual Task`1<object> Ask(object message, Nullable`1<TimeSpan> timeout);
    public virtual bool Equals(object obj);
    protected bool Equals(ActorSelectionRoutee other);
    public virtual int GetHashCode();
}
public class Akka.Routing.AddRoutee : RouterManagementMessage {
    [CompilerGeneratedAttribute]
private Routee <Routee>k__BackingField;
    public Routee Routee { get; private set; }
    public AddRoutee(Routee routee);
    [CompilerGeneratedAttribute]
public Routee get_Routee();
    [CompilerGeneratedAttribute]
private void set_Routee(Routee value);
}
public class Akka.Routing.AdjustPoolSize : RouterManagementMessage {
    [CompilerGeneratedAttribute]
private int <Change>k__BackingField;
    public int Change { get; private set; }
    public AdjustPoolSize(int change);
    [CompilerGeneratedAttribute]
public int get_Change();
    [CompilerGeneratedAttribute]
private void set_Change(int value);
}
public class Akka.Routing.Broadcast : RouterEnvelope {
    public Broadcast(object message);
}
public class Akka.Routing.BroadcastGroup : Group {
    public BroadcastGroup(Config config);
    public BroadcastGroup(String[] paths);
    public BroadcastGroup(IEnumerable`1<string> paths);
    public BroadcastGroup(IEnumerable`1<string> paths, string routerDispatcher);
    public virtual IEnumerable`1<string> GetPaths(ActorSystem system);
    public virtual Router CreateRouter(ActorSystem system);
    public Group WithDispatcher(string dispatcher);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.BroadcastPool : Pool {
    public BroadcastPool(int nrOfInstances);
    public BroadcastPool(Config config);
    public BroadcastPool(int nrOfInstances, Resizer resizer, SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher);
    public virtual Router CreateRouter(ActorSystem system);
    public virtual int GetNrOfInstances(ActorSystem system);
    public BroadcastPool WithSupervisorStrategy(SupervisorStrategy strategy);
    public BroadcastPool WithResizer(Resizer resizer);
    public BroadcastPool WithDispatcher(string dispatcher);
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    private RouterConfig OverrideUnsetConfig(RouterConfig other);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.BroadcastRoutingLogic : RoutingLogic {
    public virtual Routee Select(object message, Routee[] routees);
}
public static class Akka.Routing.ConsistentHash : object {
    public static ConsistentHash`1<T> Create(IEnumerable`1<T> nodes, int virtualNodesFactor);
    internal static int ConcatenateNodeHash(int nodeHash, int vnode);
    internal static object ToBytesOrObject(object obj);
    internal static int HashFor(Byte[] bytes);
    internal static int HashFor(string hashKey);
}
public class Akka.Routing.ConsistentHash`1 : object {
    private SortedDictionary`2<int, T> _nodes;
    private int _virtualNodesFactor;
    private Nullable`1<ValueTuple`2<Int32[], T[]>> _ring;
    private Nullable`1<ValueTuple`2<Int32[], T[]>> RingTuple { get; }
    private Int32[] NodeHashRing { get; }
    private T[] NodeRing { get; }
    public bool IsEmpty { get; }
    public ConsistentHash`1(SortedDictionary`2<int, T> nodes, int virtualNodesFactor);
    private Nullable`1<ValueTuple`2<Int32[], T[]>> get_RingTuple();
    private Int32[] get_NodeHashRing();
    private T[] get_NodeRing();
    public ConsistentHash`1<T> Add(T node);
    public ConsistentHash`1<T> Remove(T node);
    private int Idx(int i);
    public T NodeFor(Byte[] key);
    public T NodeFor(string key);
    public bool get_IsEmpty();
    public static ConsistentHash`1<T> op_Addition(ConsistentHash`1<T> hash, T node);
    public static ConsistentHash`1<T> op_Subtraction(ConsistentHash`1<T> hash, T node);
}
public class Akka.Routing.ConsistentHashableEnvelope : RouterEnvelope {
    [CompilerGeneratedAttribute]
private object <HashKey>k__BackingField;
    public object HashKey { get; private set; }
    public object ConsistentHashKey { get; }
    public ConsistentHashableEnvelope(object message, object hashKey);
    [CompilerGeneratedAttribute]
public object get_HashKey();
    [CompilerGeneratedAttribute]
private void set_HashKey(object value);
    public sealed virtual object get_ConsistentHashKey();
}
public class Akka.Routing.ConsistentHashingGroup : Group {
    private ConsistentHashMapping _hashMapping;
    [CompilerGeneratedAttribute]
private int <VirtualNodesFactor>k__BackingField;
    public int VirtualNodesFactor { get; private set; }
    public ConsistentHashingGroup(Config config);
    public ConsistentHashingGroup(String[] paths);
    public ConsistentHashingGroup(IEnumerable`1<string> paths);
    public ConsistentHashingGroup(IEnumerable`1<string> paths, ConsistentHashMapping hashMapping);
    public ConsistentHashingGroup(IEnumerable`1<string> paths, int virtualNodesFactor, ConsistentHashMapping hashMapping, string routerDispatcher);
    [CompilerGeneratedAttribute]
public int get_VirtualNodesFactor();
    [CompilerGeneratedAttribute]
private void set_VirtualNodesFactor(int value);
    public virtual IEnumerable`1<string> GetPaths(ActorSystem system);
    public virtual Router CreateRouter(ActorSystem system);
    public ConsistentHashingGroup WithDispatcher(string dispatcher);
    public ConsistentHashingGroup WithVirtualNodesFactor(int vnodes);
    public ConsistentHashingGroup WithHashMapping(ConsistentHashMapping mapping);
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.ConsistentHashingPool : Pool {
    private ConsistentHashMapping _hashMapping;
    [CompilerGeneratedAttribute]
private int <VirtualNodesFactor>k__BackingField;
    public int VirtualNodesFactor { get; }
    public ConsistentHashingPool(int nrOfInstances);
    public ConsistentHashingPool(Config config);
    public ConsistentHashingPool(int nrOfInstances, ConsistentHashMapping hashMapping);
    public ConsistentHashingPool(int nrOfInstances, Resizer resizer, SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher, int virtualNodesFactor, ConsistentHashMapping hashMapping);
    [CompilerGeneratedAttribute]
public int get_VirtualNodesFactor();
    public virtual Router CreateRouter(ActorSystem system);
    public virtual int GetNrOfInstances(ActorSystem system);
    public ConsistentHashingPool WithSupervisorStrategy(SupervisorStrategy strategy);
    public ConsistentHashingPool WithResizer(Resizer resizer);
    public ConsistentHashingPool WithDispatcher(string dispatcher);
    public ConsistentHashingPool WithVirtualNodesFactor(int vnodes);
    public ConsistentHashingPool WithHashMapping(ConsistentHashMapping mapping);
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    private RouterConfig OverrideUnsetConfig(RouterConfig other);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
internal static class Akka.Routing.ConsistentHashingRouter : object {
    public static ConsistentHashMapping EmptyConsistentHashMapping;
    private static ConsistentHashingRouter();
}
public class Akka.Routing.ConsistentHashingRoutingLogic : RoutingLogic {
    private Lazy`1<ILoggingAdapter> _log;
    private ConsistentHashMapping _hashMapping;
    private ActorSystem _system;
    private AtomicReference`1<Tuple`2<Routee[], ConsistentHash`1<ConsistentRoutee>>> _consistentHashRef;
    private Address _selfAddress;
    private int _vnodes;
    public ConsistentHashingRoutingLogic(ActorSystem system);
    public ConsistentHashingRoutingLogic(ActorSystem system, int virtualNodesFactor, ConsistentHashMapping hashMapping);
    public virtual Routee Select(object message, Routee[] routees);
    public ConsistentHashingRoutingLogic WithHashMapping(ConsistentHashMapping mapping);
    [CompilerGeneratedAttribute]
private ILoggingAdapter <.ctor>b__7_0();
}
public class Akka.Routing.ConsistentHashMapping : MulticastDelegate {
    public ConsistentHashMapping(object object, IntPtr method);
    public virtual object Invoke(object msg);
    public virtual IAsyncResult BeginInvoke(object msg, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class Akka.Routing.ConsistentRoutee : object {
    [CompilerGeneratedAttribute]
private Routee <Routee>k__BackingField;
    [CompilerGeneratedAttribute]
private Address <SelfAddress>k__BackingField;
    public Routee Routee { get; private set; }
    public Address SelfAddress { get; private set; }
    public ConsistentRoutee(Routee routee, Address selfAddress);
    [CompilerGeneratedAttribute]
public Routee get_Routee();
    [CompilerGeneratedAttribute]
private void set_Routee(Routee value);
    [CompilerGeneratedAttribute]
public Address get_SelfAddress();
    [CompilerGeneratedAttribute]
private void set_SelfAddress(Address value);
    public virtual string ToString();
    private string ToStringWithFullAddress(ActorPath path);
}
public abstract class Akka.Routing.CustomRouterConfig : RouterConfig {
    protected CustomRouterConfig(string routerDispatcher);
    public virtual ActorBase CreateRouterActor();
}
public class Akka.Routing.Deafen : ListenerMessage {
    [CompilerGeneratedAttribute]
private IActorRef <Listener>k__BackingField;
    public IActorRef Listener { get; }
    public Deafen(IActorRef listener);
    [CompilerGeneratedAttribute]
public IActorRef get_Listener();
}
public class Akka.Routing.DefaultResizer : Resizer {
    [CompilerGeneratedAttribute]
private int <LowerBound>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UpperBound>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PressureThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RampupRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BackoffThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BackoffRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MessagesPerResize>k__BackingField;
    public int LowerBound { get; public set; }
    public int UpperBound { get; public set; }
    public int PressureThreshold { get; private set; }
    public double RampupRate { get; private set; }
    public double BackoffThreshold { get; private set; }
    public double BackoffRate { get; private set; }
    public int MessagesPerResize { get; private set; }
    public DefaultResizer(int lower, int upper, int pressureThreshold, double rampupRate, double backoffThreshold, double backoffRate, int messagesPerResize);
    public static DefaultResizer FromConfig(Config resizerConfig);
    internal static DefaultResizer Apply(Config resizerConfig);
    public virtual bool IsTimeForResize(long messageCounter);
    public virtual int Resize(IEnumerable`1<Routee> currentRoutees);
    public int Capacity(IEnumerable`1<Routee> currentRoutees);
    public int Pressure(IEnumerable`1<Routee> currentRoutees);
    public int Filter(int pressure, int capacity);
    public int Rampup(int pressure, int capacity);
    public int Backoff(int pressure, int capacity);
    [CompilerGeneratedAttribute]
public int get_LowerBound();
    [CompilerGeneratedAttribute]
public void set_LowerBound(int value);
    [CompilerGeneratedAttribute]
public int get_UpperBound();
    [CompilerGeneratedAttribute]
public void set_UpperBound(int value);
    [CompilerGeneratedAttribute]
public int get_PressureThreshold();
    [CompilerGeneratedAttribute]
private void set_PressureThreshold(int value);
    [CompilerGeneratedAttribute]
public double get_RampupRate();
    [CompilerGeneratedAttribute]
private void set_RampupRate(double value);
    [CompilerGeneratedAttribute]
public double get_BackoffThreshold();
    [CompilerGeneratedAttribute]
private void set_BackoffThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_BackoffRate();
    [CompilerGeneratedAttribute]
private void set_BackoffRate(double value);
    [CompilerGeneratedAttribute]
public int get_MessagesPerResize();
    [CompilerGeneratedAttribute]
private void set_MessagesPerResize(int value);
    public sealed virtual bool Equals(DefaultResizer other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private bool <Pressure>b__6_0(Routee routee);
}
public class Akka.Routing.FromConfig : Pool {
    [CompilerGeneratedAttribute]
private static FromConfig <Instance>k__BackingField;
    public static FromConfig Instance { get; }
    public FromConfig(Resizer resizer, SupervisorStrategy supervisorStrategy, string routerDispatcher);
    private static FromConfig();
    [CompilerGeneratedAttribute]
public static FromConfig get_Instance();
    public virtual Router CreateRouter(ActorSystem system);
    public virtual ActorBase CreateRouterActor();
    public virtual void VerifyConfig(ActorPath path);
    public FromConfig WithSupervisorStrategy(SupervisorStrategy strategy);
    public FromConfig WithResizer(Resizer resizer);
    public FromConfig WithDispatcher(string dispatcherId);
    public virtual int GetNrOfInstances(ActorSystem sys);
    public Props Props();
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.GetRoutees : RouterManagementMessage {
    [CompilerGeneratedAttribute]
private static GetRoutees <Instance>k__BackingField;
    public static GetRoutees Instance { get; }
    private static GetRoutees();
    [CompilerGeneratedAttribute]
public static GetRoutees get_Instance();
}
public abstract class Akka.Routing.Group : RouterConfig {
    protected String[] InternalPaths;
    protected Group(IEnumerable`1<string> paths, string routerDispatcher);
    public abstract virtual IEnumerable`1<string> GetPaths(ActorSystem system);
    public Props Props();
    internal Routee RouteeFor(string path, IActorContext context);
    public virtual ActorBase CreateRouterActor();
    public sealed virtual bool Equals(Group other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface Akka.Routing.IConsistentHashable {
    public object ConsistentHashKey { get; }
    public abstract virtual object get_ConsistentHashKey();
}
public interface Akka.Routing.IListeners {
    public ListenerSupport Listeners { get; }
    public abstract virtual ListenerSupport get_Listeners();
}
public class Akka.Routing.Listen : ListenerMessage {
    [CompilerGeneratedAttribute]
private IActorRef <Listener>k__BackingField;
    public IActorRef Listener { get; }
    public Listen(IActorRef listener);
    [CompilerGeneratedAttribute]
public IActorRef get_Listener();
}
public abstract class Akka.Routing.ListenerMessage : object {
}
public class Akka.Routing.ListenerSupport : object {
    protected HashSet`1<IActorRef> Listeners;
    public Receive ListenerReceive { get; }
    public Receive get_ListenerReceive();
    public void Add(IActorRef actor);
    public void Remove(IActorRef actor);
    public void Gossip(object message);
    public void Gossip(object message, IActorRef sender);
    [CompilerGeneratedAttribute]
private bool <get_ListenerReceive>b__2_0(object message);
}
internal class Akka.Routing.NoRoutee : Routee {
    public virtual void Send(object message, IActorRef sender);
}
public class Akka.Routing.NoRouter : RouterConfig {
    [CompilerGeneratedAttribute]
private static NoRouter <Instance>k__BackingField;
    public string RouterDispatcher { get; }
    public static NoRouter Instance { get; }
    private static NoRouter();
    public virtual Router CreateRouter(ActorSystem system);
    public virtual ActorBase CreateRouterActor();
    public virtual string get_RouterDispatcher();
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    public Props Props(Props routeeProps);
    [CompilerGeneratedAttribute]
public static NoRouter get_Instance();
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public abstract class Akka.Routing.Pool : RouterConfig {
    [CompilerGeneratedAttribute]
private int <NrOfInstances>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePoolDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private Resizer <Resizer>k__BackingField;
    [CompilerGeneratedAttribute]
private SupervisorStrategy <SupervisorStrategy>k__BackingField;
    public int NrOfInstances { get; }
    public bool UsePoolDispatcher { get; }
    public Resizer Resizer { get; }
    public SupervisorStrategy SupervisorStrategy { get; }
    public bool StopRouterWhenAllRouteesRemoved { get; }
    public static SupervisorStrategy DefaultSupervisorStrategy { get; }
    protected Pool(int nrOfInstances, Resizer resizer, SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher);
    [CompilerGeneratedAttribute]
public int get_NrOfInstances();
    public abstract virtual int GetNrOfInstances(ActorSystem system);
    [CompilerGeneratedAttribute]
public virtual bool get_UsePoolDispatcher();
    internal virtual Routee NewRoutee(Props routeeProps, IActorContext context);
    internal Props EnrichWithPoolDispatcher(Props routeeProps, IActorContext context);
    [CompilerGeneratedAttribute]
public virtual Resizer get_Resizer();
    [CompilerGeneratedAttribute]
public virtual SupervisorStrategy get_SupervisorStrategy();
    public Props Props(Props routeeProps);
    public virtual bool get_StopRouterWhenAllRouteesRemoved();
    public virtual ActorBase CreateRouterActor();
    public static SupervisorStrategy get_DefaultSupervisorStrategy();
    public sealed virtual bool Equals(Pool other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Akka.Routing.RandomGroup : Group {
    public RandomGroup(Config config);
    public RandomGroup(String[] paths);
    public RandomGroup(IEnumerable`1<string> paths);
    public RandomGroup(IEnumerable`1<string> paths, string routerDispatcher);
    public virtual IEnumerable`1<string> GetPaths(ActorSystem system);
    public virtual Router CreateRouter(ActorSystem system);
    public RandomGroup WithDispatcher(string dispatcher);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.RandomLogic : RoutingLogic {
    public virtual Routee Select(object message, Routee[] routees);
}
public class Akka.Routing.RandomPool : Pool {
    public RandomPool(Config config);
    public RandomPool(int nrOfInstances);
    public RandomPool(int nrOfInstances, Resizer resizer, SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher);
    public virtual Router CreateRouter(ActorSystem system);
    public virtual int GetNrOfInstances(ActorSystem system);
    public RandomPool WithSupervisorStrategy(SupervisorStrategy strategy);
    public RandomPool WithResizer(Resizer resizer);
    public RandomPool WithDispatcher(string dispatcher);
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    private RouterConfig OverrideUnsetConfig(RouterConfig other);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.RemoveRoutee : RouterManagementMessage {
    [CompilerGeneratedAttribute]
private Routee <Routee>k__BackingField;
    public Routee Routee { get; private set; }
    public RemoveRoutee(Routee routee);
    [CompilerGeneratedAttribute]
public Routee get_Routee();
    [CompilerGeneratedAttribute]
private void set_Routee(Routee value);
}
internal class Akka.Routing.ResizablePoolActor : RouterPoolActor {
    protected ResizablePoolCell ResizerCell { get; }
    public ResizablePoolActor(SupervisorStrategy supervisorStrategy);
    protected ResizablePoolCell get_ResizerCell();
    protected virtual void OnReceive(object message);
    protected virtual void StopIfAllRouteesRemoved();
}
internal class Akka.Routing.ResizablePoolCell : RoutedActorCell {
    private Resizer resizer;
    private AtomicBoolean _resizeInProgress;
    private AtomicCounterLong _resizeCounter;
    private Pool _pool;
    public ResizablePoolCell(ActorSystemImpl system, IInternalActorRef self, Props routerProps, MessageDispatcher dispatcher, Props routeeProps, IInternalActorRef supervisor, Pool pool);
    protected virtual void PreSuperStart();
    public virtual void SendMessage(Envelope envelope);
    internal void Resize(bool initial);
    [CompilerGeneratedAttribute]
private Routee <Resize>b__7_0();
}
public class Akka.Routing.Resize : RouterManagementMessage {
}
public abstract class Akka.Routing.Resizer : object {
    public abstract virtual bool IsTimeForResize(long messageCounter);
    public abstract virtual int Resize(IEnumerable`1<Routee> currentRoutees);
    public static Resizer FromConfig(Config parentConfig);
}
public class Akka.Routing.RoundRobinGroup : Group {
    public RoundRobinGroup(Config config);
    public RoundRobinGroup(String[] paths);
    public RoundRobinGroup(IEnumerable`1<string> paths);
    public RoundRobinGroup(IEnumerable`1<string> paths, string routerDispatcher);
    public virtual IEnumerable`1<string> GetPaths(ActorSystem system);
    public virtual Router CreateRouter(ActorSystem system);
    public Group WithDispatcher(string dispatcherId);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.RoundRobinPool : Pool {
    public RoundRobinPool(Config config);
    public RoundRobinPool(int nrOfInstances);
    public RoundRobinPool(int nrOfInstances, Resizer resizer);
    public RoundRobinPool(int nrOfInstances, Resizer resizer, SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher);
    public virtual Router CreateRouter(ActorSystem system);
    public virtual int GetNrOfInstances(ActorSystem sys);
    public RoundRobinPool WithSupervisorStrategy(SupervisorStrategy strategy);
    public RoundRobinPool WithResizer(Resizer resizer);
    public RoundRobinPool WithDispatcher(string dispatcher);
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    private RouterConfig OverrideUnsetConfig(RouterConfig other);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.RoundRobinRoutingLogic : RoutingLogic {
    private int _next;
    public RoundRobinRoutingLogic(int next);
    public virtual Routee Select(object message, Routee[] routees);
}
internal class Akka.Routing.RoutedActorCell : ActorCell {
    [CompilerGeneratedAttribute]
private Router <Router>k__BackingField;
    [CompilerGeneratedAttribute]
private Props <RouteeProps>k__BackingField;
    [CompilerGeneratedAttribute]
private RouterConfig <RouterConfig>k__BackingField;
    public Router Router { get; private set; }
    public Props RouteeProps { get; }
    public RouterConfig RouterConfig { get; }
    public RoutedActorCell(ActorSystemImpl system, IInternalActorRef self, Props routerProps, MessageDispatcher dispatcher, Props routeeProps, IInternalActorRef supervisor);
    [CompilerGeneratedAttribute]
public Router get_Router();
    [CompilerGeneratedAttribute]
private void set_Router(Router value);
    [CompilerGeneratedAttribute]
public Props get_RouteeProps();
    [CompilerGeneratedAttribute]
public RouterConfig get_RouterConfig();
    internal void AddRoutee(Routee routee);
    internal void AddRoutees(IList`1<Routee> routees);
    internal void RemoveRoutee(Routee routee, bool stopChild);
    internal void RemoveRoutees(IList`1<Routee> affectedRoutees, bool stopChild);
    private void Watch(Routee routee);
    private void Unwatch(Routee routee);
    private void StopIfChild(Routee routee);
    public virtual void Start();
    protected virtual void PreSuperStart();
    public virtual void SendMessage(Envelope envelope);
    protected virtual ActorBase CreateNewActorInstance();
}
internal class Akka.Routing.RoutedActorRef : RepointableActorRef {
    private Props _routeeProps;
    public RoutedActorRef(ActorSystemImpl system, Props routerProps, MessageDispatcher routerDispatcher, MailboxType routerMailbox, Props routeeProps, IInternalActorRef supervisor, ActorPath path);
    protected virtual ActorCell NewCell();
}
public class Akka.Routing.Routee : object {
    public static Routee NoRoutee;
    private static Routee();
    public virtual void Send(object message, IActorRef sender);
    public virtual Task`1<object> Ask(object message, Nullable`1<TimeSpan> timeout);
    public static Routee FromActorRef(IActorRef actorRef);
}
public class Akka.Routing.Routees : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Routee> <Members>k__BackingField;
    public IEnumerable`1<Routee> Members { get; private set; }
    public Routees(IEnumerable`1<Routee> routees);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Routee> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(IEnumerable`1<Routee> value);
}
public class Akka.Routing.Router : object {
    private Routee[] _routees;
    [CompilerGeneratedAttribute]
private RoutingLogic <RoutingLogic>k__BackingField;
    public IEnumerable`1<Routee> Routees { get; }
    public RoutingLogic RoutingLogic { get; }
    [InternalApiAttribute]
public Router(RoutingLogic logic, IActorRef routee, IActorRef[] routees);
    public Router(RoutingLogic logic, Routee[] routees);
    public IEnumerable`1<Routee> get_Routees();
    [CompilerGeneratedAttribute]
public RoutingLogic get_RoutingLogic();
    protected object UnWrap(object message);
    public virtual void Route(object message, IActorRef sender);
    protected virtual void Send(Routee routee, object message, IActorRef sender);
    public virtual Router WithRoutees(Routee[] routees);
    public virtual Router AddRoutee(Routee routee);
    public Router AddRoutee(IActorRef routee);
    public Router AddRoutee(ActorSelection routee);
    public virtual Router RemoveRoutee(Routee routee);
    public Router RemoveRoutee(IActorRef routee);
    public Router RemoveRoutee(ActorSelection routee);
}
internal class Akka.Routing.RouterActor : UntypedActor {
    [CompilerGeneratedAttribute]
private RoutedActorCell <Cell>k__BackingField;
    [CompilerGeneratedAttribute]
private IActorRef <RoutingLogicController>k__BackingField;
    protected RoutedActorCell Cell { get; }
    private IActorRef RoutingLogicController { get; }
    [CompilerGeneratedAttribute]
protected RoutedActorCell get_Cell();
    [CompilerGeneratedAttribute]
private IActorRef get_RoutingLogicController();
    protected virtual void OnReceive(object message);
    protected virtual void StopIfAllRouteesRemoved();
    protected virtual void PreRestart(Exception cause, object message);
}
public abstract class Akka.Routing.RouterConfig : object {
    [CompilerGeneratedAttribute]
private string <RouterDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopRouterWhenAllRouteesRemoved>k__BackingField;
    public string RouterDispatcher { get; }
    public bool StopRouterWhenAllRouteesRemoved { get; }
    protected RouterConfig(string routerDispatcher);
    public abstract virtual Router CreateRouter(ActorSystem system);
    [CompilerGeneratedAttribute]
public virtual string get_RouterDispatcher();
    public virtual Props RoutingLogicController(RoutingLogic routingLogic);
    public virtual bool IsManagementMessage(object message);
    [CompilerGeneratedAttribute]
public virtual bool get_StopRouterWhenAllRouteesRemoved();
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    public virtual void VerifyConfig(ActorPath path);
    [InternalApiAttribute]
public abstract virtual ActorBase CreateRouterActor();
    public abstract virtual ISurrogate ToSurrogate(ActorSystem system);
    public sealed virtual bool Equals(RouterConfig other);
    public virtual bool Equals(object obj);
}
public class Akka.Routing.RouterEnvelope : object {
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    public object Message { get; }
    public RouterEnvelope(object message);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Message();
}
public abstract class Akka.Routing.RouterManagementMessage : object {
}
public static class Akka.Routing.RouterMessage : object {
    public static GetRoutees GetRoutees;
    private static RouterMessage();
}
internal class Akka.Routing.RouterPoolActor : RouterActor {
    private SupervisorStrategy _supervisorStrategy;
    protected Pool Pool;
    public RouterPoolActor(SupervisorStrategy supervisorStrategy);
    protected virtual SupervisorStrategy SupervisorStrategy();
    protected virtual void OnReceive(object message);
    [CompilerGeneratedAttribute]
private Routee <OnReceive>b__4_0();
}
public abstract class Akka.Routing.RoutingLogic : object {
    public abstract virtual Routee Select(object message, Routee[] routees);
}
public class Akka.Routing.ScatterGatherFirstCompletedGroup : Group {
    [CompilerGeneratedAttribute]
private TimeSpan <Within>k__BackingField;
    public TimeSpan Within { get; }
    public ScatterGatherFirstCompletedGroup(Config config);
    public ScatterGatherFirstCompletedGroup(TimeSpan within, String[] paths);
    public ScatterGatherFirstCompletedGroup(IEnumerable`1<string> paths, TimeSpan within);
    public ScatterGatherFirstCompletedGroup(IEnumerable`1<string> paths, TimeSpan within, string routerDispatcher);
    [CompilerGeneratedAttribute]
public TimeSpan get_Within();
    public virtual Router CreateRouter(ActorSystem system);
    public virtual IEnumerable`1<string> GetPaths(ActorSystem system);
    public ScatterGatherFirstCompletedGroup WithDispatcher(string dispatcher);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.ScatterGatherFirstCompletedPool : Pool {
    [CompilerGeneratedAttribute]
private TimeSpan <Within>k__BackingField;
    public TimeSpan Within { get; }
    public ScatterGatherFirstCompletedPool(Config config);
    public ScatterGatherFirstCompletedPool(int nrOfInstances);
    public ScatterGatherFirstCompletedPool(int nrOfInstances, TimeSpan within);
    public ScatterGatherFirstCompletedPool(int nrOfInstances, Resizer resizer, TimeSpan within, SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher);
    [CompilerGeneratedAttribute]
public TimeSpan get_Within();
    public virtual Router CreateRouter(ActorSystem system);
    public virtual int GetNrOfInstances(ActorSystem system);
    public ScatterGatherFirstCompletedPool WithSupervisorStrategy(SupervisorStrategy strategy);
    public ScatterGatherFirstCompletedPool WithResizer(Resizer resizer);
    public ScatterGatherFirstCompletedPool WithDispatcher(string dispatcher);
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    private RouterConfig OverrideUnsetConfig(RouterConfig other);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
internal class Akka.Routing.ScatterGatherFirstCompletedRoutees : Routee {
    private Routee[] _routees;
    private TimeSpan _within;
    public ScatterGatherFirstCompletedRoutees(Routee[] routees, TimeSpan within);
    public virtual void Send(object message, IActorRef sender);
    [AsyncStateMachineAttribute("Akka.Routing.ScatterGatherFirstCompletedRoutees/<SendMessage>d__4")]
private Task`1<object> SendMessage(object message);
}
public class Akka.Routing.ScatterGatherFirstCompletedRoutingLogic : RoutingLogic {
    private TimeSpan _within;
    public ScatterGatherFirstCompletedRoutingLogic(TimeSpan within);
    public virtual Routee Select(object message, Routee[] routees);
}
public class Akka.Routing.SeveralRoutees : Routee {
    private Routee[] _routees;
    public SeveralRoutees(Routee[] routees);
    public virtual void Send(object message, IActorRef sender);
}
public class Akka.Routing.SmallestMailboxPool : Pool {
    public SmallestMailboxPool(Config config);
    public SmallestMailboxPool(int nrOfInstances);
    public SmallestMailboxPool(int nrOfInstances, Resizer resizer, SupervisorStrategy supervisorStrategy, string routerDispatcher, bool usePoolDispatcher);
    public virtual Router CreateRouter(ActorSystem system);
    public virtual int GetNrOfInstances(ActorSystem system);
    public SmallestMailboxPool WithSupervisorStrategy(SupervisorStrategy strategy);
    public SmallestMailboxPool WithResizer(Resizer resizer);
    public SmallestMailboxPool WithDispatcher(string dispatcher);
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    private RouterConfig OverrideUnsetConfig(RouterConfig other);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.SmallestMailboxRoutingLogic : RoutingLogic {
    private int _next;
    public SmallestMailboxRoutingLogic(int next);
    public virtual Routee Select(object message, Routee[] routees);
    private Routee SelectNext(Routee[] routees);
    private ICell TryGetActorCell(Routee routee);
}
public class Akka.Routing.TailChopping : RoutingLogic {
    private TimeSpan _within;
    private TimeSpan _interval;
    private IScheduler _scheduler;
    public TailChopping(IScheduler scheduler, TimeSpan within, TimeSpan interval);
    public virtual Routee Select(object message, Routee[] routees);
}
public class Akka.Routing.TailChoppingGroup : Group {
    [CompilerGeneratedAttribute]
private TimeSpan <Within>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Interval>k__BackingField;
    public TimeSpan Within { get; }
    public TimeSpan Interval { get; }
    public TailChoppingGroup(Config config);
    public TailChoppingGroup(IEnumerable`1<string> routeePaths, TimeSpan within, TimeSpan interval);
    public TailChoppingGroup(IEnumerable`1<string> routeePaths, TimeSpan within, TimeSpan interval, string routerDispatcher);
    [CompilerGeneratedAttribute]
public TimeSpan get_Within();
    [CompilerGeneratedAttribute]
public TimeSpan get_Interval();
    public virtual Router CreateRouter(ActorSystem system);
    public virtual IEnumerable`1<string> GetPaths(ActorSystem system);
    public TailChoppingGroup WithDispatcher(string dispatcher);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Routing.TailChoppingPool : Pool {
    [CompilerGeneratedAttribute]
private TimeSpan <Within>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Interval>k__BackingField;
    public TimeSpan Within { get; }
    public TimeSpan Interval { get; }
    public TailChoppingPool(Config config);
    public TailChoppingPool(int nrOfInstances, TimeSpan within, TimeSpan interval);
    public TailChoppingPool(int nrOfInstances, Resizer resizer, SupervisorStrategy supervisorStrategy, string routerDispatcher, TimeSpan within, TimeSpan interval, bool usePoolDispatcher);
    [CompilerGeneratedAttribute]
public TimeSpan get_Within();
    [CompilerGeneratedAttribute]
public TimeSpan get_Interval();
    public virtual Router CreateRouter(ActorSystem system);
    public virtual int GetNrOfInstances(ActorSystem system);
    public TailChoppingPool WithSupervisorStrategy(SupervisorStrategy strategy);
    public TailChoppingPool WithResizer(Resizer resizer);
    public TailChoppingPool WithDispatcher(string dispatcher);
    public virtual RouterConfig WithFallback(RouterConfig routerConfig);
    private RouterConfig OverrideUnsetConfig(RouterConfig other);
    public virtual ISurrogate ToSurrogate(ActorSystem system);
}
internal class Akka.Routing.TailChoppingRoutee : Routee {
    private Routee[] _routees;
    private TimeSpan _within;
    private TimeSpan _interval;
    private IScheduler _scheduler;
    public TailChoppingRoutee(IScheduler scheduler, Routee[] routees, TimeSpan within, TimeSpan interval);
    public virtual void Send(object message, IActorRef sender);
}
public class Akka.Routing.WithListeners : ListenerMessage {
    [CompilerGeneratedAttribute]
private Action`1<IActorRef> <ListenerFunction>k__BackingField;
    public Action`1<IActorRef> ListenerFunction { get; }
    public WithListeners(Action`1<IActorRef> listenerFunction);
    [CompilerGeneratedAttribute]
public Action`1<IActorRef> get_ListenerFunction();
}
public class Akka.Serialization.ByteArraySerializer : Serializer {
    public bool IncludeManifest { get; }
    public ByteArraySerializer(ExtendedActorSystem system);
    public virtual bool get_IncludeManifest();
    public virtual Byte[] ToBinary(object obj);
    public virtual object FromBinary(Byte[] bytes, Type type);
}
[InternalApiAttribute]
public class Akka.Serialization.Information : object {
    [CompilerGeneratedAttribute]
private Address <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private ActorSystem <System>k__BackingField;
    public Address Address { get; }
    public ActorSystem System { get; }
    public Information(Address address, ActorSystem system);
    [CompilerGeneratedAttribute]
public Address get_Address();
    [CompilerGeneratedAttribute]
public ActorSystem get_System();
    public sealed virtual bool Equals(Information other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Information left, Information right);
    public static bool op_Inequality(Information left, Information right);
}
public class Akka.Serialization.NewtonSoftJsonSerializer : Serializer {
    private JsonSerializer _serializer;
    private ObjectPool`1<StringBuilder> _sbPool;
    [CompilerGeneratedAttribute]
private JsonSerializerSettings <Settings>k__BackingField;
    public JsonSerializerSettings Settings { get; }
    public object Serializer { get; }
    public bool IncludeManifest { get; }
    public NewtonSoftJsonSerializer(ExtendedActorSystem system);
    public NewtonSoftJsonSerializer(ExtendedActorSystem system, Config config);
    public NewtonSoftJsonSerializer(ExtendedActorSystem system, NewtonSoftJsonSerializerSettings settings);
    [CompilerGeneratedAttribute]
public JsonSerializerSettings get_Settings();
    public object get_Serializer();
    private static JsonConverter CreateConverter(Type converterType, ExtendedActorSystem actorSystem);
    public virtual bool get_IncludeManifest();
    public virtual Byte[] ToBinary(object obj);
    private Byte[] toBinary_NewBuilder(object obj);
    private Byte[] toBinary_PooledBuilder(object obj);
    public virtual object FromBinary(Byte[] bytes, Type type);
    private static object TranslateSurrogate(object deserializedValue, NewtonSoftJsonSerializer parent, Type type);
    private static JToken RestoreJToken(JToken value);
    private static object GetValue(string V);
}
public class Akka.Serialization.NewtonSoftJsonSerializerSettings : object {
    public static NewtonSoftJsonSerializerSettings Default;
    [CompilerGeneratedAttribute]
private bool <EncodeTypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveObjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StringBuilderMinSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StringBuilderMaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePooledStringBuilder>k__BackingField;
    public bool EncodeTypeNames { get; }
    public bool PreserveObjectReferences { get; }
    public IEnumerable`1<Type> Converters { get; }
    public int StringBuilderMinSize { get; }
    public int StringBuilderMaxSize { get; }
    public bool UsePooledStringBuilder { get; }
    public NewtonSoftJsonSerializerSettings(bool encodeTypeNames, bool preserveObjectReferences, IEnumerable`1<Type> converters, bool usePooledStringBuilder, int stringBuilderMinSize, int stringBuilderMaxSize);
    private static NewtonSoftJsonSerializerSettings();
    public static NewtonSoftJsonSerializerSettings Create(Config config);
    [IteratorStateMachineAttribute("Akka.Serialization.NewtonSoftJsonSerializerSettings/<GetConverterTypes>d__2")]
private static IEnumerable`1<Type> GetConverterTypes(Config config);
    [CompilerGeneratedAttribute]
public bool get_EncodeTypeNames();
    [CompilerGeneratedAttribute]
public bool get_PreserveObjectReferences();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_Converters();
    [CompilerGeneratedAttribute]
public int get_StringBuilderMinSize();
    [CompilerGeneratedAttribute]
public int get_StringBuilderMaxSize();
    [CompilerGeneratedAttribute]
public bool get_UsePooledStringBuilder();
}
public class Akka.Serialization.NewtonSoftJsonSerializerSetup : Setup {
    [CompilerGeneratedAttribute]
private Action`1<JsonSerializerSettings> <ApplySettings>k__BackingField;
    public Action`1<JsonSerializerSettings> ApplySettings { get; }
    private NewtonSoftJsonSerializerSetup(Action`1<JsonSerializerSettings> settings);
    public static NewtonSoftJsonSerializerSetup Create(Action`1<JsonSerializerSettings> settings);
    [CompilerGeneratedAttribute]
public Action`1<JsonSerializerSettings> get_ApplySettings();
}
public class Akka.Serialization.NullSerializer : Serializer {
    private static Byte[] EmptyBytes;
    public int Identifier { get; }
    public bool IncludeManifest { get; }
    public NullSerializer(ExtendedActorSystem system);
    private static NullSerializer();
    public virtual int get_Identifier();
    public virtual bool get_IncludeManifest();
    public virtual Byte[] ToBinary(object obj);
    public virtual object FromBinary(Byte[] bytes, Type type);
}
public class Akka.Serialization.Serialization : object {
    [ThreadStaticAttribute]
internal static Information CurrentTransportInformation;
    private Serializer _nullSerializer;
    private ConcurrentDictionary`2<Type, Serializer> _serializerMap;
    private Dictionary`2<int, Serializer> _serializersById;
    private Dictionary`2<string, Serializer> _serializersByName;
    private ImmutableHashSet`1<SerializerDetails> _serializerDetails;
    private MinimalLogger _initializationLogger;
    private bool _logSerializerOverrideOnStart;
    [CompilerGeneratedAttribute]
private ExtendedActorSystem <System>k__BackingField;
    private Type _objectType;
    private Information SerializationInfo { get; }
    public ExtendedActorSystem System { get; }
    public Serialization(ExtendedActorSystem system);
    public static string ManifestFor(Serializer s, object msg);
    public static Information GetCurrentTransportInformation();
    [ObsoleteAttribute("Obsolete. Use the SerializeWithTransport<T>(ExtendedActorSystem) method instead.")]
public static T WithTransport(ActorSystem system, Address address, Func`1<T> action);
    private Information get_SerializationInfo();
    public static T WithTransport(ExtendedActorSystem system, Func`1<T> action);
    public static T WithTransport(ExtendedActorSystem system, TState state, Func`2<TState, T> action);
    private T WithTransport(Func`1<T> action);
    private Serializer GetSerializerByName(string name);
    [CompilerGeneratedAttribute]
public ExtendedActorSystem get_System();
    [ObsoleteAttribute("No longer supported. Use the AddSerializer(name, serializer) overload instead.", "True")]
public void AddSerializer(Serializer serializer);
    public void AddSerializer(string name, Serializer serializer);
    public void AddSerializationMap(Type type, Serializer serializer);
    internal void RemoveSerializationMap(Type type);
    private void LogWarning(string str);
    public Byte[] Serialize(object o);
    public object Deserialize(Byte[] bytes, int serializerId, Type type);
    public object Deserialize(Byte[] bytes, int serializerId, string manifest);
    public Serializer FindSerializerFor(object obj, string defaultSerializerName);
    public Serializer FindSerializerForType(Type objectType, string defaultSerializerName);
    public IActorRef DeserializeActorRef(string path);
    public static string SerializedActorPath(IActorRef actorRef);
    internal Serializer GetSerializerById(int serializerId);
}
public class Akka.Serialization.SerializationSetup : Setup {
    [CompilerGeneratedAttribute]
private Func`2<ExtendedActorSystem, ImmutableHashSet`1<SerializerDetails>> <CreateSerializers>k__BackingField;
    public Func`2<ExtendedActorSystem, ImmutableHashSet`1<SerializerDetails>> CreateSerializers { get; }
    internal SerializationSetup(Func`2<ExtendedActorSystem, ImmutableHashSet`1<SerializerDetails>> createSerializers);
    [CompilerGeneratedAttribute]
public Func`2<ExtendedActorSystem, ImmutableHashSet`1<SerializerDetails>> get_CreateSerializers();
    public static SerializationSetup Create(Func`2<ExtendedActorSystem, ImmutableHashSet`1<SerializerDetails>> createSerializers);
}
public abstract class Akka.Serialization.Serializer : object {
    protected ExtendedActorSystem system;
    private FastLazy`1<int> _value;
    public int Identifier { get; }
    public bool IncludeManifest { get; }
    protected Serializer(ExtendedActorSystem system);
    internal static string GetErrorForSerializerId(int id);
    public virtual int get_Identifier();
    public abstract virtual bool get_IncludeManifest();
    public abstract virtual Byte[] ToBinary(object obj);
    public Byte[] ToBinaryWithAddress(Address address, object obj);
    public abstract virtual object FromBinary(Byte[] bytes, Type type);
    public T FromBinary(Byte[] bytes);
}
public class Akka.Serialization.SerializerDetails : object {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private Serializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<Type> <UseFor>k__BackingField;
    public string Alias { get; }
    public Serializer Serializer { get; }
    public ImmutableHashSet`1<Type> UseFor { get; }
    internal SerializerDetails(string alias, Serializer serializer, ImmutableHashSet`1<Type> useFor);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public Serializer get_Serializer();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<Type> get_UseFor();
    public static SerializerDetails Create(string alias, Serializer serializer, ImmutableHashSet`1<Type> useFor);
}
internal class Akka.Serialization.SerializerErrorCode : object {
    public static Dictionary`2<int, SerializerErrorCode> ErrorCodes;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Fqcn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Injector>k__BackingField;
    public int Id { get; }
    public string Fqcn { get; }
    public string DirectAccess { get; }
    public string Injector { get; }
    private SerializerErrorCode(int id, string fqcn, string directAccess, string injector);
    private static SerializerErrorCode();
    public static string GetErrorForSerializerId(int id);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public string get_Fqcn();
    [CompilerGeneratedAttribute]
public string get_DirectAccess();
    [CompilerGeneratedAttribute]
public string get_Injector();
    public virtual string ToString();
}
[InternalApiAttribute]
public static class Akka.Serialization.SerializerIdentifierHelper : object {
    internal static string SerializationIdentifiers;
    public static int GetSerializerIdentifierFromConfig(Type type, ExtendedActorSystem system);
}
public abstract class Akka.Serialization.SerializerWithStringManifest : Serializer {
    public bool IncludeManifest { get; }
    protected SerializerWithStringManifest(ExtendedActorSystem system);
    public sealed virtual bool get_IncludeManifest();
    public sealed virtual object FromBinary(Byte[] bytes, Type type);
    public abstract virtual object FromBinary(Byte[] bytes, string manifest);
    public abstract virtual string Manifest(object o);
}
internal class Akka.Tools.MatchHandler.Argument : object {
    private PredicateAndHandler _predicateAndHandler;
    private object _value;
    private bool _valueIsActionOrFunc;
    public PredicateAndHandler PredicateAndHandler { get; }
    public object Value { get; }
    public bool ValueIsActionOrFunc { get; }
    public Argument(PredicateAndHandler predicateAndHandler, object value, bool valueIsActionOrFunc);
    public PredicateAndHandler get_PredicateAndHandler();
    public object get_Value();
    public bool get_ValueIsActionOrFunc();
}
internal class Akka.Tools.MatchHandler.CachedMatchCompiler`1 : object {
    private IMatchExpressionBuilder _expressionBuilder;
    private IPartialActionBuilder _actionBuilder;
    private ILambdaExpressionCompiler _expressionCompiler;
    private ConcurrentDictionary`2<MatchBuilderSignature, Delegate> _cache;
    public static CachedMatchCompiler`1<T> Instance;
    public CachedMatchCompiler`1(IMatchExpressionBuilder expressionBuilder, IPartialActionBuilder actionBuilder, ILambdaExpressionCompiler expressionCompiler);
    private static CachedMatchCompiler`1();
    public sealed virtual PartialAction`1<T> Compile(IReadOnlyList`1<TypeHandler> handlers, IReadOnlyList`1<Argument> capturedArguments, MatchBuilderSignature signature);
    private Delegate CompileToDelegate(IReadOnlyList`1<TypeHandler> handlers, IReadOnlyList`1<Argument> capturedArguments, Object[]& delegateArguments);
}
internal class Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments : object {
    private Delegate _compiledDelegate;
    private Object[] _delegateArguments;
    public Delegate CompiledDelegate { get; }
    public Object[] DelegateArguments { get; }
    public CompiledMatchHandlerWithArguments(Delegate compiledDelegate, Object[] delegateArguments);
    public Delegate get_CompiledDelegate();
    public Object[] get_DelegateArguments();
}
internal enum Akka.Tools.MatchHandler.HandlerKind : Enum {
    public int value__;
    public static HandlerKind Action;
    public static HandlerKind ActionWithPredicate;
    public static HandlerKind Func;
}
internal interface Akka.Tools.MatchHandler.ILambdaExpressionCompiler {
    public abstract virtual Delegate Compile(LambdaExpression expression);
}
internal interface Akka.Tools.MatchHandler.IMatchCompiler`1 {
    public abstract virtual PartialAction`1<T> Compile(IReadOnlyList`1<TypeHandler> handlers, IReadOnlyList`1<Argument> capturedArguments, MatchBuilderSignature signature);
}
internal interface Akka.Tools.MatchHandler.IMatchExpressionBuilder {
    public abstract virtual MatchExpressionBuilderResult BuildLambdaExpression(IReadOnlyList`1<TypeHandler> typeHandlers);
    public abstract virtual Object[] CreateArgumentValuesArray(IReadOnlyList`1<Argument> arguments);
}
internal interface Akka.Tools.MatchHandler.IPartialActionBuilder {
    public abstract virtual PartialAction`1<T> Build(CompiledMatchHandlerWithArguments handlerAndArgs);
}
internal interface Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture`1 {
    public abstract virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public abstract virtual bool Handle(T message);
}
internal class Akka.Tools.MatchHandler.LambdaExpressionCompiler : object {
    public sealed virtual Delegate Compile(LambdaExpression expression);
}
internal class Akka.Tools.MatchHandler.MatchBuilder : MatchBuilder`1<object> {
    public MatchBuilder(IMatchCompiler`1<object> compiler);
}
internal class Akka.Tools.MatchHandler.MatchBuilder`1 : object {
    private static Type _itemType;
    private List`1<TypeHandler> _typeHandlers;
    private List`1<Argument> _arguments;
    private List`1<object> _signature;
    private IMatchCompiler`1<TItem> _compiler;
    private State<TItem> _state;
    public MatchBuilder`1(IMatchCompiler`1<TItem> compiler);
    private static MatchBuilder`1();
    public void Match(Action`1<T> handler, Predicate`1<T> shouldHandle);
    public void Match(Type handlesType, Action`1<TItem> handler, Predicate`1<TItem> shouldHandle);
    public void Match(Func`2<T, bool> handler);
    public void Match(Type handlesType, Func`2<TItem, bool> handler);
    public void MatchAny(Action`1<TItem> handler);
    public PartialAction`1<TItem> Build();
    private static void EnsureCanHandleType(Type handlesType);
    private void EnsureCanAdd();
    private void AddHandler(Type handlesType, PredicateAndHandler predicateAndHandler);
    private bool TryGetPreviousTypeHandlerIfItHandlesSameType(Type type, TypeHandler& typeHandler);
}
internal class Akka.Tools.MatchHandler.MatchBuilderSignature : object {
    private IReadOnlyList`1<object> _list;
    public MatchBuilderSignature(IReadOnlyList`1<object> signature);
    public sealed virtual bool Equals(MatchBuilderSignature other);
    public virtual bool Equals(object obj);
    private bool ListsEqual(IReadOnlyList`1<object> x, IReadOnlyList`1<object> y);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Akka.Tools.MatchHandler.MatchExpressionBuilder`1 : object {
    private static int MaxNumberOfInlineParameters;
    private static Type _inputItemType;
    private static ParameterExpression _extraArgsArrayParameter;
    private static MatchExpressionBuilder`1();
    public sealed virtual MatchExpressionBuilderResult BuildLambdaExpression(IReadOnlyList`1<TypeHandler> typeHandlers);
    private static ValueTuple`2<ParameterExpression[], Object[]> DecorateHandlerAndPredicateExpressions(IReadOnlyList`1<Argument> arguments, ParameterExpression inputParameter);
    public sealed virtual Object[] CreateArgumentValuesArray(IReadOnlyList`1<Argument> arguments);
    private static void AddCodeForHandlers(List`1<PredicateAndHandler> predicateAndHandlers, List`1<Expression> bodyExpressions, Expression castedValueExpression, LabelTarget returnTarget, Expression inputValueExpression);
    private static void AddActionHandlerExpressions(PredicateAndHandler handler, List`1<Expression> body, Expression argumentExpression, LabelTarget returnTarget);
    private static void AddActionHandlerWithPredicateExpressions(PredicateAndHandler handler, List`1<Expression> body, Expression argumentExpression, LabelTarget returnTarget);
    private static void AddFuncHandlerExpressions(PredicateAndHandler handler, List`1<Expression> body, Expression argumentExpression, LabelTarget returnTarget);
}
internal class Akka.Tools.MatchHandler.MatchExpressionBuilderResult : object {
    private LambdaExpression _lambdaExpression;
    private Object[] _arguments;
    public LambdaExpression LambdaExpression { get; }
    public Object[] Arguments { get; }
    public MatchExpressionBuilderResult(LambdaExpression lambdaExpression, Object[] arguments);
    public LambdaExpression get_LambdaExpression();
    public Object[] get_Arguments();
}
internal class Akka.Tools.MatchHandler.PartialAction`1 : MulticastDelegate {
    public PartialAction`1(object object, IntPtr method);
    public virtual bool Invoke(T item);
    public virtual IAsyncResult BeginInvoke(T item, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Akka.Tools.MatchHandler.PartialActionBuilder : object {
    public static int MaxNumberOfArguments;
    private static Type _objectArrayType;
    private static Type[] _types;
    private static PartialActionBuilder();
    public sealed virtual PartialAction`1<T> Build(CompiledMatchHandlerWithArguments handlerAndArgs);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`1 : object {
    private Func`2<object, bool> _handler;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`10 : object {
    private Func`11<object, T1, T2, T3, T4, T5, T6, T7, T8, T9, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    private T8 _8;
    private T9 _9;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`11 : object {
    private Func`12<object, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    private T8 _8;
    private T9 _9;
    private T10 _10;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`12 : object {
    private Func`13<object, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    private T8 _8;
    private T9 _9;
    private T10 _10;
    private T11 _11;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`13 : object {
    private Func`14<object, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    private T8 _8;
    private T9 _9;
    private T10 _10;
    private T11 _11;
    private T12 _12;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`14 : object {
    private Func`15<object, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    private T8 _8;
    private T9 _9;
    private T10 _10;
    private T11 _11;
    private T12 _12;
    private T13 _13;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`15 : object {
    private Func`16<object, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    private T8 _8;
    private T9 _9;
    private T10 _10;
    private T11 _11;
    private T12 _12;
    private T13 _13;
    private T14 _14;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`16 : object {
    private Func`17<object, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    private T8 _8;
    private T9 _9;
    private T10 _10;
    private T11 _11;
    private T12 _12;
    private T13 _13;
    private T14 _14;
    private T15 _15;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`2 : object {
    private Func`3<object, T1, bool> _handler;
    private T1 _1;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`3 : object {
    private Func`4<object, T1, T2, bool> _handler;
    private T1 _1;
    private T2 _2;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`4 : object {
    private Func`5<object, T1, T2, T3, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`5 : object {
    private Func`6<object, T1, T2, T3, T4, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`6 : object {
    private Func`7<object, T1, T2, T3, T4, T5, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`7 : object {
    private Func`8<object, T1, T2, T3, T4, T5, T6, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`8 : object {
    private Func`9<object, T1, T2, T3, T4, T5, T6, T7, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`9 : object {
    private Func`10<object, T1, T2, T3, T4, T5, T6, T7, T8, bool> _handler;
    private T1 _1;
    private T2 _2;
    private T3 _3;
    private T4 _4;
    private T5 _5;
    private T6 _6;
    private T7 _7;
    private T8 _8;
    public sealed virtual void Initialize(Delegate handler, IReadOnlyList`1<object> arguments);
    public sealed virtual bool Handle(T value);
}
internal class Akka.Tools.MatchHandler.PredicateAndHandler : object {
    private HandlerKind _handlerKind;
    private bool _handlerFirstArgumentShouldBeBaseType;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Argument> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <ActionOrFuncExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <PredicateExpression>k__BackingField;
    public HandlerKind HandlerKind { get; }
    public IReadOnlyList`1<Argument> Arguments { get; private set; }
    public bool HandlerFirstArgumentShouldBeBaseType { get; }
    public Expression ActionOrFuncExpression { get; public set; }
    public Expression PredicateExpression { get; public set; }
    private PredicateAndHandler(HandlerKind handlerKind, bool handlerFirstArgumentShouldBeBaseType);
    public HandlerKind get_HandlerKind();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Argument> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(IReadOnlyList`1<Argument> value);
    public bool get_HandlerFirstArgumentShouldBeBaseType();
    [CompilerGeneratedAttribute]
public Expression get_ActionOrFuncExpression();
    [CompilerGeneratedAttribute]
public void set_ActionOrFuncExpression(Expression value);
    [CompilerGeneratedAttribute]
public Expression get_PredicateExpression();
    [CompilerGeneratedAttribute]
public void set_PredicateExpression(Expression value);
    public static PredicateAndHandler CreateAction(object action, object predicate, bool handlerFirstArgumentShouldBeBaseType);
    public static PredicateAndHandler CreateFunc(object func, bool handlerFirstArgumentShouldBeBaseType);
}
internal class Akka.Tools.MatchHandler.TypeHandler : object {
    private Type _handlesType;
    private List`1<PredicateAndHandler> _handlers;
    public Type HandlesType { get; }
    public List`1<PredicateAndHandler> Handlers { get; }
    public TypeHandler(Type handlesType);
    public Type get_HandlesType();
    public List`1<PredicateAndHandler> get_Handlers();
    public IEnumerable`1<Argument> GetArguments();
}
public class Akka.Util.AppVersion : object {
    public static AppVersion Zero;
    internal static string AssemblyVersionMarker;
    private static int Undefined;
    private Int32[] _numbers;
    private string _rest;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    [JsonConstructorAttribute]
internal AppVersion(string version);
    private static AppVersion();
    public static AppVersion Create(string version);
    internal static AppVersion AppVersionFromAssemblyVersion();
    [CompilerGeneratedAttribute]
public string get_Version();
    private AppVersion Parse();
    public sealed virtual int CompareTo(AppVersion other);
    public sealed virtual bool Equals(AppVersion other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(AppVersion first, AppVersion second);
    public static bool op_Inequality(AppVersion first, AppVersion second);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<int, string> <Parse>g__ParseLastPart|11_0(string s);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<int, string> <Parse>g__ParseDynverPart|11_1(string s);
    [CompilerGeneratedAttribute]
internal static ValueTuple`3<int, int, string> <Parse>g__ParseLastParts|11_2(string s);
}
public class Akka.Util.AtomicBoolean : object {
    private static int _falseValue;
    private static int _trueValue;
    private int _value;
    public bool Value { get; public set; }
    public AtomicBoolean(bool initialValue);
    public bool get_Value();
    public void set_Value(bool value);
    public bool CompareAndSet(bool expected, bool newValue);
    public bool GetAndSet(bool newValue);
    public static bool op_Implicit(AtomicBoolean atomicBoolean);
}
public class Akka.Util.AtomicReference`1 : object {
    protected T atomicValue;
    public T Value { get; public set; }
    public AtomicReference`1(T originalValue);
    public T get_Value();
    public void set_Value(T value);
    public bool CompareAndSet(T expected, T newValue);
    public T GetAndSet(T newValue);
    public static T op_Implicit(AtomicReference`1<T> atomicReference);
}
[ExtensionAttribute]
internal static class Akka.Util.Base64Encoding : object {
    private static string Base64Chars;
    [ExtensionAttribute]
public static string Base64Encode(long value);
    [ExtensionAttribute]
internal static string Base64Encode(long value, string prefix);
    [ExtensionAttribute]
public static string Base64Encode(string s);
}
[ExtensionAttribute]
public static class Akka.Util.BitArrayHelpers : object {
    [ExtensionAttribute]
public static Byte[] ToBytes(BitArray arr);
}
[ExtensionAttribute]
public static class Akka.Util.ByteHelpers : object {
    [ExtensionAttribute]
public static Byte[] PutInt(Byte[] target, int x, int offset, ByteOrder order);
}
public class Akka.Util.ConcurrentSet`1 : object {
    private ConcurrentDictionary`2<T, byte> _storage;
    public bool IsEmpty { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ConcurrentSet`1(IEnumerable`1<T> collection);
    public ConcurrentSet`1(IEqualityComparer`1<T> comparer);
    public ConcurrentSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public ConcurrentSet`1(int concurrencyLevel, int capacity);
    public ConcurrentSet`1(int concurrencyLevel, IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public ConcurrentSet`1(int concurrencyLevel, int capacity, IEqualityComparer`1<T> comparer);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool TryAdd(T item);
    public bool TryRemove(T item);
}
internal class Akka.Util.ContinuousEnumerator`1 : object {
    private IEnumerator`1<T> _internalEnumerator;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ContinuousEnumerator`1(IEnumerator`1<T> internalEnumerator);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[ExtensionAttribute]
internal static class Akka.Util.ContinuousEnumeratorExtensions : object {
    [ExtensionAttribute]
public static ContinuousEnumerator`1<T> GetContinuousEnumerator(IEnumerable`1<T> collection);
}
[InternalApiAttribute]
public static class Akka.Util.DynamicAccess : object {
    [InternalApiAttribute]
public static Try`1<TResult> CreateInstanceFor(string typeName, Object[] args);
}
public static class Akka.Util.Either : object {
    public static Left`1<T> Left(T value);
    public static Right`1<T> Right(T value);
}
public abstract class Akka.Util.Either`2 : object {
    [CompilerGeneratedAttribute]
private TB <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private TA <Left>k__BackingField;
    public bool IsLeft { get; }
    public bool IsRight { get; }
    protected TB Right { get; private set; }
    protected TA Left { get; private set; }
    public object Value { get; }
    protected Either`2(TA left, TB right);
    public abstract virtual bool get_IsLeft();
    public abstract virtual bool get_IsRight();
    [CompilerGeneratedAttribute]
protected TB get_Right();
    [CompilerGeneratedAttribute]
private void set_Right(TB value);
    [CompilerGeneratedAttribute]
protected TA get_Left();
    [CompilerGeneratedAttribute]
private void set_Left(TA value);
    public object get_Value();
    public Right`2<TA, TB> ToRight();
    public Left`2<TA, TB> ToLeft();
    public static Either`2<TA, TB> op_Implicit(Left`1<TA> left);
    public static Either`2<TA, TB> op_Implicit(Right`1<TB> right);
    public Either`2<TRes1, TRes2> Map(Func`2<TA, TRes1> map1, Func`2<TB, TRes2> map2);
    public Either`2<TRes, TB> MapLeft(Func`2<TA, TRes> map);
    public Either`2<TA, TRes> MapRight(Func`2<TB, TRes> map);
    public TRes Fold(Func`2<TA, TRes> left, Func`2<TB, TRes> right);
}
[ExtensionAttribute]
public static class Akka.Util.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static Option`1<T> AsOption(T obj);
}
public class Akka.Util.FastLazy`1 : object {
    private Func`1<T> _producer;
    private int _status;
    private Exception _exception;
    private T _createdValue;
    public T Value { get; }
    public FastLazy`1(Func`1<T> producer);
    public bool IsValueCreated();
    private bool IsExceptionThrown();
    public T get_Value();
    [CompilerGeneratedAttribute]
private bool <get_Value>b__8_0();
}
[DefaultMemberAttribute("Item")]
public class Akka.Util.Index`2 : object {
    private ConcurrentDictionary`2<TKey, ConcurrentSet`1<TValue>> _container;
    private ConcurrentSet`1<TValue> _emptySet;
    public IEnumerable`1<TValue> Item { get; }
    public HashSet`1<TValue> Values { get; }
    public ICollection`1<TKey> Keys { get; }
    public bool IsEmpty { get; }
    public bool Put(TKey key, TValue value);
    public TValue FindValue(TKey key, Func`2<TValue, bool> predicate);
    public IEnumerable`1<TValue> get_Item(TKey index);
    public void ForEach(Action`2<TKey, TValue> fun);
    public HashSet`1<TValue> get_Values();
    public ICollection`1<TKey> get_Keys();
    public bool Remove(TKey key, TValue value);
    public void RemoveValue(TValue value);
    public IEnumerable`1<TValue> Remove(TKey key);
    public bool get_IsEmpty();
    public void Clear();
}
[ExtensionAttribute]
internal static class Akka.Util.Internal.ArrayExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Array obj);
    [ExtensionAttribute]
public static bool NonEmpty(Array obj);
    [ExtensionAttribute]
public static void Shuffle(T[] array);
    [ExtensionAttribute]
public static Dictionary`2<T, int> ZipWithIndex(IEnumerable`1<T> collection);
    [ExtensionAttribute]
internal static IEnumerable`1<T> Slice(IEnumerable`1<T> items, int startIndex, int count);
    [ExtensionAttribute]
internal static IEnumerable`1<T> From(IEnumerable`1<T> items, T startingItem);
    [IteratorStateMachineAttribute("Akka.Util.Internal.ArrayExtensions/<Until>d__6`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> Until(IEnumerable`1<T> items, T startingItem);
    [ExtensionAttribute]
internal static IEnumerable`1<T> Tail(IEnumerable`1<T> items);
}
public class Akka.Util.Internal.AtomicCounter : object {
    private int _value;
    public int Current { get; }
    public AtomicCounter(int initialValue);
    public sealed virtual int get_Current();
    public sealed virtual int Next();
    public int Decrement();
    public sealed virtual int GetAndIncrement();
    public sealed virtual int IncrementAndGet();
    public int GetAndDecrement();
    public int DecrementAndGet();
    public sealed virtual int GetAndAdd(int amount);
    public sealed virtual int AddAndGet(int amount);
    public sealed virtual void Reset();
    public int GetAndSet(int value);
    public bool CompareAndSet(int expected, int newValue);
}
public class Akka.Util.Internal.AtomicCounterLong : object {
    private long _value;
    public long Current { get; }
    public AtomicCounterLong(long value);
    public sealed virtual long get_Current();
    public sealed virtual long Next();
    public sealed virtual long GetAndIncrement();
    public sealed virtual long IncrementAndGet();
    public long DecrementAndGet();
    public sealed virtual long GetAndAdd(long amount);
    public sealed virtual long AddAndGet(long amount);
    public sealed virtual void Reset();
    public long GetAndSet(long value);
    public bool CompareAndSet(long expected, long newValue);
    public virtual string ToString();
}
internal abstract class Akka.Util.Internal.AtomicState : AtomicCounterLong {
    private ConcurrentQueue`1<Action> _listeners;
    private TimeSpan _callTimeout;
    public bool HasListeners { get; }
    protected AtomicState(TimeSpan callTimeout, long startingCount);
    public sealed virtual void AddListener(Action listener);
    public sealed virtual bool get_HasListeners();
    [AsyncStateMachineAttribute("Akka.Util.Internal.AtomicState/<NotifyTransitionListeners>d__6")]
protected Task NotifyTransitionListeners();
    [AsyncStateMachineAttribute("Akka.Util.Internal.AtomicState/<CallThrough>d__7`1")]
public Task`1<T> CallThrough(Func`1<Task`1<T>> task);
    [AsyncStateMachineAttribute("Akka.Util.Internal.AtomicState/<CallThrough>d__8`2")]
public Task`1<T> CallThrough(TState state, Func`2<TState, Task`1<T>> task);
    [AsyncStateMachineAttribute("Akka.Util.Internal.AtomicState/<CallThrough>d__9")]
public Task CallThrough(Func`1<Task> task);
    [AsyncStateMachineAttribute("Akka.Util.Internal.AtomicState/<CallThrough>d__10`1")]
public Task CallThrough(TState state, Func`2<TState, Task> task);
    public abstract virtual Task`1<T> Invoke(Func`1<Task`1<T>> body);
    public abstract virtual Task`1<T> InvokeState(TState state, Func`2<TState, Task`1<T>> body);
    public abstract virtual Task Invoke(Func`1<Task> body);
    public abstract virtual Task InvokeState(TState state, Func`2<TState, Task> body);
    protected internal abstract virtual void CallFails(Exception cause);
    protected internal abstract virtual void CallSucceeds();
    protected abstract virtual void EnterInternal();
    public sealed virtual void Enter();
    [CompilerGeneratedAttribute]
private void <NotifyTransitionListeners>b__6_0();
}
[ExtensionAttribute]
internal static class Akka.Util.Internal.Collections.EnumeratorExtensions : object {
    [ExtensionAttribute]
public static Iterator`1<T> Iterator(IEnumerable`1<T> enumerable);
}
internal class Akka.Util.Internal.Collections.Iterator`1 : ValueType {
    private IList`1<T> _enumerator;
    private int _index;
    public Iterator`1(IEnumerable`1<T> enumerator);
    public T Next();
    public bool IsEmpty();
    public IEnumerable`1<T> ToVector();
}
[ExtensionAttribute]
internal static class Akka.Util.Internal.Collections.ListExtensions : object {
    [ExtensionAttribute]
public static List`1<T> Shuffle(List`1<T> this);
    [ExtensionAttribute]
public static IImmutableList`1<T> Shuffle(IImmutableList`1<T> this);
}
[DefaultMemberAttribute("Item")]
internal class Akka.Util.Internal.Collections.ListSlice`1 : ValueType {
    private IReadOnlyList`1<T> _array;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Offset { get; }
    public IReadOnlyList`1<T> Array { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ListSlice`1(IReadOnlyList`1<T> array);
    public ListSlice`1(IReadOnlyList`1<T> array, int offset, int count);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Offset();
    public IReadOnlyList`1<T> get_Array();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[ExtensionAttribute]
internal static class Akka.Util.Internal.Collections.SliceExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyList`1<T> NoCopySlice(IReadOnlyList`1<T> list, int offset);
}
[InternalApiAttribute]
internal class Akka.Util.Internal.ContextRemover : object {
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public ContextRemover GetAwaiter();
    public void GetResult();
}
[ExtensionAttribute]
internal static class Akka.Util.Internal.DictionaryExtensions : object {
    [ExtensionAttribute]
public static void Put(IDictionary`2<TKey, TVal> dict, TKey key, TVal value);
}
[ExtensionAttribute]
public static class Akka.Util.Internal.Extensions : object {
    [ExtensionAttribute]
public static T AsInstanceOf(object self);
    [ExtensionAttribute]
public static IEnumerable`1<T> Drop(IEnumerable`1<T> self, int count);
    [ExtensionAttribute]
public static T Head(IEnumerable`1<T> self);
    [IteratorStateMachineAttribute("Akka.Util.Internal.Extensions/<SplitDottedPathHonouringQuotes>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<string> SplitDottedPathHonouringQuotes(string path);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> self, string separator);
    [ExtensionAttribute]
public static string BetweenDoubleQuotes(string self);
    [ExtensionAttribute]
public static void AddOrSet(IDictionary`2<TKey, TValue> hash, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue GetOrElse(IDictionary`2<TKey, TValue> hash, TKey key, TValue elseValue);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> AddAndReturn(IDictionary`2<TKey, TValue> hash, TKey key, TValue value);
    [ExtensionAttribute]
public static TimeSpan Max(TimeSpan this, TimeSpan other);
    [ExtensionAttribute]
public static TimeSpan Min(TimeSpan this, TimeSpan other);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> enumerable, T item);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> TakeRight(IEnumerable`1<T> self, int n);
}
public interface Akka.Util.Internal.IAtomicCounter`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
    public abstract virtual T Next();
    public abstract virtual T GetAndIncrement();
    public abstract virtual T IncrementAndGet();
    public abstract virtual T GetAndAdd(T amount);
    public abstract virtual T AddAndGet(T amount);
    public abstract virtual void Reset();
}
public interface Akka.Util.Internal.IAtomicState {
    public bool HasListeners { get; }
    public abstract virtual void AddListener(Action listener);
    public abstract virtual bool get_HasListeners();
    public abstract virtual Task`1<T> Invoke(Func`1<Task`1<T>> body);
    public abstract virtual void Enter();
}
[ExtensionAttribute]
internal static class Akka.Util.Internal.ImmutabilityUtils : object {
    [ExtensionAttribute]
public static HashSet`1<T> CopyAndAdd(HashSet`1<T> set, T item);
    [ExtensionAttribute]
public static HashSet`1<T> CopyAndRemove(HashSet`1<T> set, T item);
    [ExtensionAttribute]
public static SortedDictionary`2<TKey, TValue> CopyAndAdd(SortedDictionary`2<TKey, TValue> dict, IEnumerable`1<KeyValuePair`2<TKey, TValue>> values);
    [ExtensionAttribute]
public static SortedDictionary`2<TKey, TValue> CopyAndRemove(SortedDictionary`2<TKey, TValue> dict, IEnumerable`1<KeyValuePair`2<TKey, TValue>> values);
}
public static class Akka.Util.Internal.InterlockedSpin : object {
    public static T Swap(T& reference, Func`2<T, T> updater);
    public static TReturn ConditionallySwap(T& reference, Func`2<T, ValueTuple`3<bool, T, TReturn>> updateIfTrue);
    private static bool CompareExchange(T& reference, T expectedValue, T newValue);
}
[ExtensionAttribute]
internal static class Akka.Util.Internal.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder AppendJoin(StringBuilder sb, string separator, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static StringBuilder AppendJoin(StringBuilder sb, string separator, IEnumerable`1<T> values, Action`3<StringBuilder, T, int> valueAppender);
    private static void DefaultAppendValue(StringBuilder sb, T value, int index);
}
[InternalApiAttribute]
internal static class Akka.Util.Internal.SynchronizationContextManager : object {
    [CompilerGeneratedAttribute]
private static ContextRemover <RemoveContext>k__BackingField;
    public static ContextRemover RemoveContext { get; }
    private static SynchronizationContextManager();
    [CompilerGeneratedAttribute]
public static ContextRemover get_RemoveContext();
}
[ExtensionAttribute]
internal static class Akka.Util.Internal.TaskEx : object {
    public static Task`1<Done> Completed;
    private static TaskEx();
    public static TaskCompletionSource`1<T> NonBlockingTaskCompletionSource();
    [ExtensionAttribute]
public static void NonBlockingTrySetResult(TaskCompletionSource`1<T> taskCompletionSource, T value);
    [ExtensionAttribute]
public static void NonBlockingTrySetException(TaskCompletionSource`1<T> taskCompletionSource, Exception exception);
    public static Task FromException(Exception ex);
    public static Task`1<T> FromException(Exception ex);
}
[ExtensionAttribute]
[InternalApiAttribute]
internal static class Akka.Util.Internal.TaskExtensions : object {
    [ExtensionAttribute]
public static Task WithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task OnComplete(Task source, Action`1<Try`1<Done>> f);
    [ExtensionAttribute]
public static Task OnComplete(Task`1<TSource> source, Action`1<Try`1<TSource>> f);
}
public interface Akka.Util.ISurrogate {
    public abstract virtual ISurrogated FromSurrogate(ActorSystem system);
}
public interface Akka.Util.ISurrogated {
    public abstract virtual ISurrogate ToSurrogate(ActorSystem system);
}
public class Akka.Util.Left`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; private set; }
    public bool IsLeft { get; }
    public bool IsRight { get; }
    public Left`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public bool get_IsLeft();
    public bool get_IsRight();
}
public class Akka.Util.Left`2 : Either`2<TA, TB> {
    public bool IsLeft { get; }
    public bool IsRight { get; }
    public TA Value { get; }
    public Left`2(TA a);
    public virtual bool get_IsLeft();
    public virtual bool get_IsRight();
    public TA get_Value();
}
public class Akka.Util.ListPriorityQueue : object {
    private List`1<Envelope> _data;
    private Func`2<object, int> _priorityCalculator;
    internal static Func`2<object, int> DefaultPriorityCalculator;
    public ListPriorityQueue(int initialCapacity, Func`2<object, int> priorityCalculator);
    private static ListPriorityQueue();
    public void Enqueue(Envelope item);
    public Envelope Dequeue();
    public Envelope Peek();
    public int Count();
    public virtual string ToString();
    public bool IsConsistent();
}
internal class Akka.Util.MessageBuffer : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LinkedList`1<ValueTuple`2<object, IActorRef>> _buffer;
    public bool IsEmpty { get; }
    public bool NonEmpty { get; }
    public int Count { get; }
    public ValueTuple`2<object, IActorRef> Head { get; }
    public static MessageBuffer Empty();
    public bool get_IsEmpty();
    public bool get_NonEmpty();
    public sealed virtual int get_Count();
    public MessageBuffer Append(object message, IActorRef ref);
    public void DropHead();
    public ValueTuple`2<object, IActorRef> get_Head();
    public sealed virtual IEnumerator`1<ValueTuple`2<object, IActorRef>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Akka.Util.MessageBufferMap`1 : object {
    private Dictionary`2<TId, MessageBuffer> _bufferMap;
    public bool IsEmpty { get; }
    public bool NonEmpty { get; }
    public int Count { get; }
    public int TotalCount { get; }
    public bool get_IsEmpty();
    public bool get_NonEmpty();
    public sealed virtual int get_Count();
    public int get_TotalCount();
    private MessageBuffer GetOrAddBuffer(TId id);
    public void Add(TId id);
    public void Append(TId id, object message, IActorRef ref);
    public void Remove(TId id);
    public int Drop(TId id, string reason, IActorRef deadLetters);
    public bool Contains(TId id);
    public MessageBuffer GetOrEmpty(TId id);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TId, MessageBuffer>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class Akka.Util.MonotonicClock : object {
    private static Stopwatch Stopwatch;
    private static long TicksInMillisecond;
    private static long TicksInSecond;
    private static long NanosPerTick;
    private static double TicksFrequency;
    public static TimeSpan Elapsed { get; }
    public static TimeSpan ElapsedHighRes { get; }
    internal static bool IsHighResolution { get; }
    private static MonotonicClock();
    public static TimeSpan get_Elapsed();
    public static TimeSpan get_ElapsedHighRes();
    public static long GetTicksHighRes();
    public static long GetMilliseconds();
    public static long GetNanos();
    public static long GetTicks();
    [ExtensionAttribute]
internal static long ToNanos(long ticks);
    [ExtensionAttribute]
internal static long ToTicks(long nanos);
    internal static bool get_IsHighResolution();
}
public static class Akka.Util.MurmurHash : object {
    private static UInt32 VisibleMagic;
    private static UInt32 HiddenMagicA;
    private static UInt32 HiddenMagicB;
    private static UInt32 VisibleMixer;
    private static UInt32 HiddenMixerA;
    private static UInt32 HiddenMixerB;
    private static UInt32 FinalMixer1;
    private static UInt32 FinalMixer2;
    private static UInt32 StringSeed;
    private static UInt32 ArraySeed;
    private static UInt32[] StoredMagicA;
    private static UInt32[] StoredMagicB;
    public static UInt32 StartMagicA;
    public static UInt32 StartMagicB;
    private static MurmurHash();
    public static UInt32 StartHash(UInt32 seed);
    public static UInt32 NextMagicA(UInt32 magicA);
    public static UInt32 NextMagicB(UInt32 magicB);
    public static UInt32 ExtendHash(UInt32 hash, UInt32 value, UInt32 magicA, UInt32 magicB);
    public static UInt32 FinalizeHash(UInt32 hash);
    private static UInt32 RotateLeft32(UInt32 original, int shift);
    private static ulong RotateLeft64(ulong original, int shift);
    public static int ByteHash(Byte[] b);
    public static int ArrayHash(T[] a);
    public static int StringHash(string s);
    public static int SymmetricHash(IEnumerable`1<T> xs, UInt32 seed);
}
[IsReadOnlyAttribute]
[InternalStableApiAttribute]
public class Akka.Util.Option`1 : ValueType {
    public static Option`1<T> None;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public bool HasValue { get; }
    public bool IsEmpty { get; }
    public T Value { get; }
    [ObsoleteAttribute("Use Option<T>.Create() instead")]
public Option`1(T value);
    private static Option`1();
    public static Option`1<T> Create(T value);
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public T get_Value();
    public static Option`1<T> op_Implicit(T value);
    public T GetOrElse(T fallbackValue);
    public Option`1<TNew> Select(Func`2<T, TNew> selector);
    public Option`1<TNew> FlatSelect(Func`2<T, Option`1<TNew>> mapper);
    public bool Equals(Option`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public void OnSuccess(Action`1<T> action);
    public static bool op_Equality(Option`1<T> left, Option`1<T> right);
    public static bool op_Inequality(Option`1<T> left, Option`1<T> right);
}
[ExtensionAttribute]
internal static class Akka.Util.Reflection.ExpressionBasedParser : object {
    private static ConcurrentDictionary`2<ConstructorInfo, String[]> paramNameDictionary;
    private static Type _objectType;
    private static Type _multicastDelegateType;
    private static ExpressionBasedParser();
    [ExtensionAttribute]
public static Object[] ParseExpressionArgs(NewExpression newExpr);
    private static Object[] ParseCallArgs(int argCount, ReadOnlyCollection`1<Expression> argProv);
    private static Expression ConvertIfNeeded(Expression toConv);
    private static Type TraverseForType(Type toConv);
    private static T CompileExprWithConvert(Expression`1<T> lambda);
}
[ExtensionAttribute]
public static class Akka.Util.Reflection.ExpressionExtensions : object {
    [ExtensionAttribute]
public static Object[] GetArguments(NewExpression newExpression);
}
public static class Akka.Util.Reflection.TypeCache : object {
    private static ConcurrentDictionary`2<string, Type> TypeMap;
    private static TypeCache();
    public static Type GetType(string typeName);
    private static Type GetTypeInternal(string typeName);
}
public static class Akka.Util.Result : object {
    public static Result`1<T> Success(T value);
    public static Result`1<T> Failure(Exception exception);
    public static Result`1<T> FromTask(Task`1<T> task);
    public static Result`1<T> From(Func`1<T> func);
}
public class Akka.Util.Result`1 : ValueType {
    public bool IsSuccess;
    public T Value;
    public Exception Exception;
    public Result`1(T value);
    public Result`1(Exception exception);
    public sealed virtual bool Equals(Result`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Result`1<T> left, Result`1<T> right);
    public static bool op_Inequality(Result`1<T> left, Result`1<T> right);
    public virtual string ToString();
}
public class Akka.Util.Right`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; private set; }
    public bool IsLeft { get; }
    public bool IsRight { get; }
    public Right`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public bool get_IsLeft();
    public bool get_IsRight();
}
public class Akka.Util.Right`2 : Either`2<TA, TB> {
    public bool IsLeft { get; }
    public bool IsRight { get; }
    public TB Value { get; }
    public Right`2(TB b);
    public virtual bool get_IsLeft();
    public virtual bool get_IsRight();
    public TB get_Value();
}
public static class Akka.Util.RuntimeDetector : object {
    public static bool IsMono;
    public static bool IsWindows;
    private static RuntimeDetector();
    private static bool _IsWindows();
}
internal static class Akka.Util.SpanHacks : object {
    private static char Negative;
    private static Char[] Numbers;
    private static SpanHacks();
    public static bool IsNumeric(char x);
    public static int Parse(ReadOnlySpan`1<char> str);
    public static int TryFormat(long i, int startPos, Span`1& span, int sizeHint);
    public static int Int64SizeInCharacters(long i);
    public static int PositiveInt64SizeInCharacters(long i, int padding);
    public static bool TryParse(ReadOnlySpan`1<char> str, Int32& returnValue);
    public static string ToLowerInvariant(ReadOnlySpan`1<char> input);
}
public class Akka.Util.StableListPriorityQueue : object {
    private List`1<WrappedEnvelope> _data;
    private WrappedEnvelopeComparator comparator;
    internal static Func`2<object, int> DefaultPriorityCalculator;
    private int sequenceNumber;
    public StableListPriorityQueue(int initialCapacity, Func`2<object, int> priorityCalculator);
    private static StableListPriorityQueue();
    public void Enqueue(Envelope item);
    public Envelope Dequeue();
    public Envelope Peek();
    public int Count();
    public virtual string ToString();
    public bool IsConsistent();
}
public static class Akka.Util.StandardOutWriter : object {
    private static object _lock;
    private static StandardOutWriter();
    public static void Write(string message, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> backgroundColor);
    public static void WriteLine(string message, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> backgroundColor);
    private static void WriteToConsole(string message, Nullable`1<ConsoleColor> foregroundColor, Nullable`1<ConsoleColor> backgroundColor, bool line);
}
public static class Akka.Util.StringFormat : object {
    public static string SafeJoin(string separator, Object[] args);
    private static Object[] ConvertValues(IList`1<object> args);
}
public class Akka.Util.Switch : object {
    private AtomicBoolean _switch;
    private object _lock;
    public bool IsOn { get; }
    public bool IsOff { get; }
    public Switch(bool startAsOn);
    protected bool TranscendFrom(bool from, Action action);
    public bool SwitchOff(Action action);
    public bool SwitchOn(Action action);
    public bool SwitchOff();
    public bool SwitchOn();
    public bool IfOn(Action action);
    public bool IfOff(Action action);
    public bool WhileOn(Action action);
    public bool WhileOff(Action action);
    public bool get_IsOn();
    public bool get_IsOff();
    public void Locked(Action action);
}
public static class Akka.Util.ThreadLocalRandom : object {
    private static int _seed;
    private static ThreadLocal`1<Random> _rng;
    public static Random Current { get; }
    private static ThreadLocalRandom();
    public static Random get_Current();
}
public class Akka.Util.TickTimeTokenBucket : TokenBucket {
    public long CurrentTime { get; }
    public TickTimeTokenBucket(long capacity, long period);
    public virtual long get_CurrentTime();
}
[InternalApiAttribute]
public abstract class Akka.Util.TokenBucket : object {
    private long _capacity;
    private long _ticksBetweenTokens;
    private long _lastUpdate;
    private long _availableTokens;
    public long CurrentTime { get; }
    protected TokenBucket(long capacity, long ticksBetweenTokens);
    public void Init();
    public abstract virtual long get_CurrentTime();
    public long Offer(long cost);
}
public class Akka.Util.Try`1 : object {
    [CompilerGeneratedAttribute]
private Option`1<T> <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<Exception> <Failure>k__BackingField;
    public bool IsSuccess { get; }
    public Option`1<T> Success { get; }
    public Option`1<Exception> Failure { get; }
    public Try`1(T success);
    public Try`1(Exception failure);
    public static Try`1<T> op_Implicit(T value);
    public bool get_IsSuccess();
    [CompilerGeneratedAttribute]
public Option`1<T> get_Success();
    [CompilerGeneratedAttribute]
public Option`1<Exception> get_Failure();
    public Try`1<T> Recover(Action`1<Exception> failureHandler);
    public Try`1<T> RecoverWith(Func`2<Exception, Try`1<T>> failureHandler);
    public static Try`1<T> From(Func`1<T> func);
    public Try`1<T> OrElse(Try`1<T> default);
    public Try`1<T> GetOrElse(Func`1<T> fallback);
    public T Get();
}
[ExtensionAttribute]
public static class Akka.Util.TypeExtensions : object {
    private static ConcurrentDictionary`2<Type, string> ShortenedTypeNames;
    private static Regex cleanAssemblyVersionRegex;
    private static TypeExtensions();
    [ExtensionAttribute]
public static bool Implements(Type type);
    [ExtensionAttribute]
public static bool Implements(Type type, Type moreGeneralType);
    [ExtensionAttribute]
[InternalApiAttribute]
public static string TypeQualifiedName(Type type);
}
public static class Akka.Util.Vector : object {
    public static Func`2<Func`1<T>, IList`1<T>> Fill(int number);
}
internal class Akka.Util.WildcardIndex`1 : object {
    private WildcardTree`1<T> _wildcardTree;
    private WildcardTree`1<T> _doubleWildcardTree;
    public bool IsEmpty { get; }
    private WildcardIndex`1(WildcardTree`1<T> singleWildcard, WildcardTree`1<T> doubleWildcard);
    public bool get_IsEmpty();
    public WildcardIndex`1<T> Insert(IEnumerable`1<string> elems, T data);
    public T Find(IEnumerable`1<string> elems);
    public sealed virtual bool Equals(WildcardIndex`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class Akka.Util.WildcardMatch : object {
    [ExtensionAttribute]
public static bool Like(string text, string pattern, bool caseSensitive);
}
internal class Akka.Util.WildcardTree`1 : object {
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, WildcardTree`1<T>> <Children>k__BackingField;
    public static WildcardTree`1<T> Empty;
    public bool IsEmpty { get; }
    public T Data { get; private set; }
    public IDictionary`2<string, WildcardTree`1<T>> Children { get; private set; }
    public WildcardTree`1(T data, IDictionary`2<string, WildcardTree`1<T>> children);
    private static WildcardTree`1();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public T get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(T value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, WildcardTree`1<T>> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(IDictionary`2<string, WildcardTree`1<T>> value);
    public WildcardTree`1<T> Insert(IEnumerator`1<string> elements, T data);
    public WildcardTree`1<T> FindWithSingleWildcard(IEnumerator`1<string> elements);
    public WildcardTree`1<T> FindWithTerminalDoubleWildcard(IEnumerator`1<string> elements, WildcardTree`1<T> alt);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Helios.Concurrency.DedicatedThreadPool : object {
    [CompilerGeneratedAttribute]
private DedicatedThreadPoolSettings <Settings>k__BackingField;
    private ThreadPoolWorkQueue _workQueue;
    private PoolWorker[] _workers;
    public DedicatedThreadPoolSettings Settings { get; private set; }
    public DedicatedThreadPool(DedicatedThreadPoolSettings settings);
    [CompilerGeneratedAttribute]
public DedicatedThreadPoolSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(DedicatedThreadPoolSettings value);
    public bool QueueUserWorkItem(T work);
    public sealed virtual void Dispose();
    public void WaitForThreadsExit();
    public void WaitForThreadsExit(TimeSpan timeout);
    [CompilerGeneratedAttribute]
private PoolWorker <.ctor>b__0_0(int workerId);
}
internal class Helios.Concurrency.DedicatedThreadPoolSettings : object {
    public static ThreadType DefaultThreadType;
    [CompilerGeneratedAttribute]
private int <NumThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadType <ThreadType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <DeadlockTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Exception> <ExceptionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadMaxStackSize>k__BackingField;
    public int NumThreads { get; private set; }
    public ThreadType ThreadType { get; private set; }
    public Nullable`1<TimeSpan> DeadlockTimeout { get; private set; }
    public string Name { get; private set; }
    public Action`1<Exception> ExceptionHandler { get; private set; }
    public int ThreadMaxStackSize { get; private set; }
    public DedicatedThreadPoolSettings(int numThreads, string name, Nullable`1<TimeSpan> deadlockTimeout);
    public DedicatedThreadPoolSettings(int numThreads, ThreadType threadType, string name, Nullable`1<TimeSpan> deadlockTimeout);
    [CompilerGeneratedAttribute]
public int get_NumThreads();
    [CompilerGeneratedAttribute]
private void set_NumThreads(int value);
    [CompilerGeneratedAttribute]
public ThreadType get_ThreadType();
    [CompilerGeneratedAttribute]
private void set_ThreadType(ThreadType value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_DeadlockTimeout();
    [CompilerGeneratedAttribute]
private void set_DeadlockTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Action`1<Exception> get_ExceptionHandler();
    [CompilerGeneratedAttribute]
private void set_ExceptionHandler(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public int get_ThreadMaxStackSize();
    [CompilerGeneratedAttribute]
private void set_ThreadMaxStackSize(int value);
}
internal class Helios.Concurrency.DedicatedThreadPoolTaskScheduler : TaskScheduler {
    [ThreadStaticAttribute]
private static bool _currentThreadIsRunningTasks;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _parallelWorkers;
    private LinkedList`1<Task> _tasks;
    private DedicatedThreadPool _pool;
    public int MaximumConcurrencyLevel { get; }
    public DedicatedThreadPoolTaskScheduler(DedicatedThreadPool pool);
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual bool TryDequeue(Task task);
    public virtual int get_MaximumConcurrencyLevel();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    private void EnsureWorkerRequested();
    private void ReleaseWorker();
    private void RequestWorker();
}
internal enum Helios.Concurrency.ThreadType : Enum {
    public int value__;
    public static ThreadType Foreground;
    public static ThreadType Background;
}
internal interface IAsyncResultInterceptor {
    public abstract virtual void OnTaskCompleted(object message, Exception exception);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class PolyfillExtensions : object {
    [NullableAttribute("1")]
private static ConcurrentDictionary`2<ParameterInfo, NullabilityInfo> parameterCache;
    [NullableAttribute("1")]
private static ConcurrentDictionary`2<PropertyInfo, NullabilityInfo> propertyCache;
    [NullableAttribute("1")]
private static ConcurrentDictionary`2<EventInfo, NullabilityInfo> eventCache;
    [NullableAttribute("1")]
private static ConcurrentDictionary`2<FieldInfo, NullabilityInfo> fieldCache;
    private static long TicksPerMicrosecond;
    private static PolyfillExtensions();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityInfo GetNullabilityInfo(MemberInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityState GetNullability(MemberInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNullable(MemberInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityInfo GetNullabilityInfo(FieldInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityState GetNullability(FieldInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNullable(FieldInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityInfo GetNullabilityInfo(EventInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityState GetNullability(EventInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNullable(EventInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityInfo GetNullabilityInfo(PropertyInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityState GetNullability(PropertyInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNullable(PropertyInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityInfo GetNullabilityInfo(ParameterInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static NullabilityState GetNullability(ParameterInfo info);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNullable(ParameterInfo info);
    [NullableContextAttribute("1")]
private static NullabilityState GetReadOrWriteState(NullabilityInfo nullability);
    [NullableContextAttribute("1")]
private static NullabilityState GetKnownState(string name, NullabilityInfo nullability);
    [NullableContextAttribute("1")]
private static bool IsNullable(string name, NullabilityInfo nullability);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.cancelasync")]
public static Task CancelAsync(CancellationTokenSource target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.remove")]
public static bool Remove(Dictionary`2<TKey, TValue> target, TKey key, TValue& value);
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetStreamAsync>d__24")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getstreamasync#system-net-http-httpclient-getstreamasync(system-string-system-threading-cancellationtoken)")]
public static Task`1<Stream> GetStreamAsync(HttpClient target, string requestUri, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getstreamasync#system-net-http-httpclient-getstreamasync(system-uri-system-threading-cancellationtoken)")]
public static Task`1<Stream> GetStreamAsync(HttpClient target, Uri requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetByteArrayAsync>d__26")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getbytearrayasync#system-net-http-httpclient-getbytearrayasync(system-string-system-threading-cancellationtoken)")]
public static Task`1<Byte[]> GetByteArrayAsync(HttpClient target, string requestUri, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getbytearrayasync#system-net-http-httpclient-getbytearrayasync(system-uri-system-threading-cancellationtoken)")]
public static Task`1<Byte[]> GetByteArrayAsync(HttpClient target, Uri requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<GetStringAsync>d__28")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getstringasync#system-net-http-httpclient-getstringasync(system-string-system-threading-cancellationtoken)")]
public static Task`1<string> GetStringAsync(HttpClient target, string requestUri, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getstringasync#system-net-http-httpclient-getstringasync(system-uri-system-threading-cancellationtoken)")]
public static Task`1<string> GetStringAsync(HttpClient target, Uri requestUri, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent.readasstreamasync#system-net-http-httpcontent-readasstreamasync(system-threading-cancellationtoken)")]
public static Task`1<Stream> ReadAsStreamAsync(HttpContent target, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent.readasbytearrayasync#system-net-http-httpcontent-readasbytearrayasync(system-threading-cancellationtoken)")]
public static Task`1<Byte[]> ReadAsByteArrayAsync(HttpContent target, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent.readasstringasync#system-net-http-httpcontent-readasstringasync(system-threading-cancellationtoken)")]
public static Task`1<string> ReadAsStringAsync(HttpContent target, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except?view=net-8.0#system-linq-enumerable-except-1(system-collections-generic-ienumerable((-0))-system-collections-generic-ienumerable((-0)))")]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> target, TSource item);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except?view=net-8.0#system-linq-enumerable-except-1(system-collections-generic-ienumerable((-0))-system-collections-generic-ienumerable((-0)))")]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> target, TSource[] items);
    [IteratorStateMachineAttribute("PolyfillExtensions/<Except>d__35`1")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except#system-linq-enumerable-except-1(system-collections-generic-ienumerable((-0))-system-collections-generic-ienumerable((-0))-system-collections-generic-iequalitycomparer((-0)))")]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> target, TSource item, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except#system-linq-enumerable-except-1(system-collections-generic-ienumerable((-0))-system-collections-generic-ienumerable((-0))-system-collections-generic-iequalitycomparer((-0)))")]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> target, IEqualityComparer`1<TSource> comparer, TSource[] items);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.chunk")]
public static IEnumerable`1<TSource[]> Chunk(IEnumerable`1<TSource> source, int size);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.maxby#system-linq-enumerable-maxby-2(system-collections-generic-ienumerable((-0))-system-func((-0-1)))")]
public static TSource MaxBy(IEnumerable`1<TSource> target, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.maxby?view=net-8.0#system-linq-enumerable-maxby-2(system-collections-generic-ienumerable((-0))-system-func((-0-1))-system-collections-generic-icomparer((-1)))")]
public static TSource MaxBy(IEnumerable`1<TSource> target, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.minby#system-linq-enumerable-minby-2(system-collections-generic-ienumerable((-0))-system-func((-0-1)))")]
public static TSource MinBy(IEnumerable`1<TSource> target, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.minby?view=net-8.0#system-linq-enumerable-minby-2(system-collections-generic-ienumerable((-0))-system-func((-0-1))-system-collections-generic-icomparer((-1)))")]
public static TSource MinBy(IEnumerable`1<TSource> target, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.skiplast")]
public static IEnumerable`1<TSource> SkipLast(IEnumerable`1<TSource> target, int count);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.collectionextensions.getvalueordefault")]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> target, TKey key);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.collectionextensions.getvalueordefault#system-collections-generic-collectionextensions-getvalueordefault-2(system-collections-generic-ireadonlydictionary((-0-1))-0-1)")]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> target, TKey key, TValue defaultValue);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.keyvaluepair-2.deconstruct")]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> target, TKey& key, TValue& value);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.contains#system-memoryextensions-contains-1(system-readonlyspan((-0))-0)")]
public static bool Contains(ReadOnlySpan`1<T> target, T value);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.contains#system-memoryextensions-contains-1(system-span((-0))-0)")]
public static bool Contains(Span`1<T> target, T value);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.sequenceequal#system-memoryextensions-sequenceequal-1(system-readonlyspan((-0))-system-readonlyspan((-0)))")]
public static bool SequenceEqual(ReadOnlySpan`1<char> target, string other);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.sequenceequal#system-memoryextensions-sequenceequal-1(system-span((-0))-system-readonlyspan((-0)))")]
public static bool SequenceEqual(Span`1<char> target, string other);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.startswith#system-memoryextensions-startswith-1(system-readonlyspan((-0))-system-readonlyspan((-0)))")]
public static bool StartsWith(ReadOnlySpan`1<char> target, string other, StringComparison comparison);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.startswith#system-memoryextensions-startswith-1(system-span((-0))-system-readonlyspan((-0)))")]
public static bool StartsWith(Span`1<char> target, string other);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.endswith#system-memoryextensions-endswith-1(system-readonlyspan((-0))-system-readonlyspan((-0)))")]
public static bool EndsWith(ReadOnlySpan`1<char> target, string other, StringComparison comparison);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.endswith#system-memoryextensions-endswith-1(system-span((-0))-system-readonlyspan((-0)))")]
public static bool EndsWith(Span`1<char> target, string other);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.timespan.nanoseconds")]
public static int Nanoseconds(TimeSpan target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetime.nanosecond")]
public static int Nanosecond(DateTime target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetimeoffset.nanosecond")]
public static int Nanosecond(DateTimeOffset target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.timespan.microseconds")]
public static int Microseconds(TimeSpan target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetime.microsecond")]
public static int Microsecond(DateTime target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetimeoffset.microsecond")]
public static int Microsecond(DateTimeOffset target);
    [ExtensionAttribute]
private static long TicksComponent(TimeSpan target);
    [ExtensionAttribute]
private static long TicksComponent(DateTime target);
    [ExtensionAttribute]
private static long TicksComponent(DateTimeOffset target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetime.addmicroseconds")]
public static DateTime AddMicroseconds(DateTime target, double microseconds);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetimeoffset.addmicroseconds")]
public static DateTimeOffset AddMicroseconds(DateTimeOffset target, double microseconds);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.readasync#system-io-stream-readasync(system-memory((system-byte))-system-threading-cancellationtoken)")]
public static ValueTask`1<int> ReadAsync(Stream target, Memory`1<byte> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.writeasync#system-io-stream-writeasync(system-readonlymemory((system-byte))-system-threading-cancellationtoken)")]
public static ValueTask WriteAsync(Stream target, ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.copytoasync#system-io-stream-copytoasync(system-io-stream-system-threading-cancellationtoken)")]
public static Task CopyToAsync(Stream target, Stream destination, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.copyto")]
public static void CopyTo(string target, Span`1<char> destination);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.trycopyto")]
public static bool TryCopyTo(string target, Span`1<char> destination);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.gethashcode#system-string-gethashcode(system-stringcomparison)")]
public static int GetHashCode(string target, StringComparison comparisonType);
    private static StringComparer FromComparison(StringComparison comparison);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.contains#system-string-contains(system-string-system-stringcomparison)")]
public static bool Contains(string target, string value, StringComparison comparisonType);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.contains#system-string-contains(system-char)")]
public static bool StartsWith(string target, char value);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.contains#system-string-contains(system-char)")]
public static bool EndsWith(string target, char value);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.split#system-string-split(system-char-system-stringsplitoptions)")]
public static String[] Split(string target, char separator, StringSplitOptions options);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.split#system-string-split(system-char-system-int32-system-stringsplitoptions)")]
public static String[] Split(string target, char separator, int count, StringSplitOptions options);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.contains#system-string-contains(system-char)")]
public static bool Contains(string target, char value);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.copyto#system-text-stringbuilder-copyto(system-int32-system-span((system-char))-system-int32)")]
public static void CopyTo(StringBuilder target, int sourceIndex, Span`1<char> destination, int count);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.append#system-text-stringbuilder-append(system-readonlyspan((system-char)))")]
public static StringBuilder Append(StringBuilder target, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.equals#system-text-stringbuilder-equals(system-readonlyspan((system-char)))")]
public static bool Equals(StringBuilder target, ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync#system-threading-tasks-task-waitasync(system-threading-cancellationtoken)")]
public static Task WaitAsync(Task target, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__83")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync#system-threading-tasks-task-waitasync(system-timespan)")]
public static Task WaitAsync(Task target, TimeSpan timeout);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__84")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync#system-threading-tasks-task-waitasync(system-timespan-system-threading-cancellationtoken)")]
public static Task WaitAsync(Task target, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync#system-threading-tasks-task-waitasync(system-threading-cancellationtoken)")]
public static Task`1<TResult> WaitAsync(Task`1<TResult> target, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__86`1")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1.waitasync#system-threading-tasks-task-1-waitasync(system-threading-cancellationtoken)")]
public static Task`1<TResult> WaitAsync(Task`1<TResult> target, TimeSpan timeout);
    [AsyncStateMachineAttribute("PolyfillExtensions/<WaitAsync>d__87`1")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1.waitasync#system-threading-tasks-task-1-waitasync(system-timespan-system-threading-cancellationtoken)")]
public static Task`1<TResult> WaitAsync(Task`1<TResult> target, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textreader.readasync#system-io-textreader-readasync(system-memory((system-char))-system-threading-cancellationtoken)")]
public static ValueTask`1<int> ReadAsync(TextReader target, Memory`1<char> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textreader.readtoendasync#system-io-textreader-readtoendasync(system-threading-cancellationtoken)")]
public static Task`1<string> ReadToEndAsync(TextReader target, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textreader.readtoendasync#system-io-textreader-readlineasync(system-threading-cancellationtoken)")]
public static Task`1<string> ReadLineAsync(TextReader target, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writeasync#system-io-textwriter-writeasync(system-readonlymemory((system-char))-system-threading-cancellationtoken)")]
public static ValueTask WriteAsync(TextWriter target, ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writelineasync#system-io-textwriter-writelineasync(system-readonlymemory((system-char))-system-threading-cancellationtoken)")]
public static ValueTask WriteLineAsync(TextWriter target, ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.write#system-io-textwriter-write(system-readonlyspan((system-char)))")]
public static void Write(TextWriter target, ReadOnlySpan`1<char> buffer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writeline#system-io-textwriter-writeline(system-readonlyspan((system-char)))")]
public static void WriteLine(TextWriter target, ReadOnlySpan`1<char> buffer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.sbyte.tryformat")]
public static bool TryFormat(sbyte target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryformat")]
public static bool TryFormat(byte target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int16.tryformat")]
public static bool TryFormat(short target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint16.tryformat")]
public static bool TryFormat(ushort target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryformat")]
public static bool TryFormat(int target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint32.tryformat")]
public static bool TryFormat(UInt32 target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int64.tryformat")]
public static bool TryFormat(long target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint64.tryformat")]
public static bool TryFormat(ulong target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.single.tryformat")]
public static bool TryFormat(float target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.double.tryformat")]
public static bool TryFormat(double target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.decimal.tryformat")]
public static bool TryFormat(decimal target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.boolean.tryformat")]
public static bool TryFormat(bool target, Span`1<char> destination, Int32& charsWritten);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetimeoffset.tryformat")]
public static bool TryFormat(DateTimeOffset target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetime.tryformat")]
public static bool TryFormat(DateTime target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private static bool CopyToSpan(Span`1<char> destination, Int32& charsWritten, string result);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo.hassamemetadatadefinitionas")]
public static bool HasSameMetadataDefinitionAs(MemberInfo target, MemberInfo other);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.type.isgenericmethodparameter")]
public static bool IsGenericMethodParameter(Type target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.type.getmemberwithsamemetadatadefinitionas")]
internal static MemberInfo GetMemberWithSameMetadataDefinitionAs(Type type, MemberInfo member);
    [IteratorStateMachineAttribute("PolyfillExtensions/<<Chunk>g__ChunkIterator|37_0>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TSource[]> <Chunk>g__ChunkIterator|37_0(IEnumerable`1<TSource> source, int size);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("27072")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2240")]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("108")]
internal class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.UnreachableException : Exception {
    public UnreachableException(string message);
    public UnreachableException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    public virtual string ToString();
    private string ToStringFromEnd();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Range : object {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Index Start { get; public set; }
    public Index End { get; public set; }
    public static Range All { get; }
    public Range(Index Start, Index End);
    [CompilerGeneratedAttribute]
protected Range(Range original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Start(Index value);
    [CompilerGeneratedAttribute]
public Index get_End();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_End(Index value);
    public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Range left, Range right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Range left, Range right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Range other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual Range <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Index& Start, Index& End);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Reflection.NullabilityInfo : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NullabilityState <ReadState>k__BackingField;
    [CompilerGeneratedAttribute]
private NullabilityState <WriteState>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NullabilityInfo <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private NullabilityInfo[] <GenericTypeArguments>k__BackingField;
    public Type Type { get; }
    public NullabilityState ReadState { get; internal set; }
    public NullabilityState WriteState { get; internal set; }
    [NullableAttribute("2")]
public NullabilityInfo ElementType { get; }
    public NullabilityInfo[] GenericTypeArguments { get; }
    internal NullabilityInfo(Type type, NullabilityState readState, NullabilityState writeState, NullabilityInfo elementType, NullabilityInfo[] typeArguments);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public NullabilityState get_ReadState();
    [CompilerGeneratedAttribute]
internal void set_ReadState(NullabilityState value);
    [CompilerGeneratedAttribute]
public NullabilityState get_WriteState();
    [CompilerGeneratedAttribute]
internal void set_WriteState(NullabilityState value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NullabilityInfo get_ElementType();
    [CompilerGeneratedAttribute]
public NullabilityInfo[] get_GenericTypeArguments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Reflection.NullabilityInfoContext : object {
    private static string CompilerServicesNameSpace;
    private Dictionary`2<Module, NotAnnotatedStatus> _publicOnlyModules;
    private Dictionary`2<MemberInfo, NullabilityState> _context;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    internal static bool IsSupported { get; }
    private static NullabilityInfoContext();
    [CompilerGeneratedAttribute]
internal static bool get_IsSupported();
    [NullableContextAttribute("2")]
private Nullable`1<NullabilityState> GetNullableContext(MemberInfo memberInfo);
    public NullabilityInfo Create(ParameterInfo parameterInfo);
    private void CheckParameterMetadataType(ParameterInfo parameter, NullabilityInfo nullability);
    private static MethodInfo GetMethodMetadataDefinition(MethodInfo method);
    private static void CheckNullabilityAttributes(NullabilityInfo nullability, IList`1<CustomAttributeData> attributes);
    public NullabilityInfo Create(PropertyInfo propertyInfo);
    private bool IsPrivateOrInternalMethodAndAnnotationDisabled(MethodBase method);
    public NullabilityInfo Create(EventInfo eventInfo);
    public NullabilityInfo Create(FieldInfo fieldInfo);
    private static void EnsureIsSupported();
    private bool IsPrivateOrInternalFieldAndAnnotationDisabled(FieldInfo fieldInfo);
    private bool IsPublicOnly(bool isPrivate, bool isFamilyAndAssembly, bool isAssembly, Module module);
    private static NotAnnotatedStatus PopulateAnnotationInfo(IList`1<CustomAttributeData> customAttributes);
    private NullabilityInfo GetNullabilityInfo(MemberInfo memberInfo, Type type, NullableAttributeStateParser parser);
    private NullabilityInfo GetNullabilityInfo(MemberInfo memberInfo, Type type, NullableAttributeStateParser parser, Int32& index);
    private static NullableAttributeStateParser CreateParser(IList`1<CustomAttributeData> customAttributes);
    private void TryLoadGenericMetaTypeNullability(MemberInfo memberInfo, NullabilityInfo nullability);
    private static MemberInfo GetMemberMetadataDefinition(MemberInfo member);
    private static Type GetPropertyMetaType(PropertyInfo property);
    private void CheckGenericParameters(NullabilityInfo nullability, MemberInfo metaMember, Type metaType, Type reflectedType);
    private bool TryUpdateGenericParameterNullability(NullabilityInfo nullability, Type genericParameter, Type reflectedType);
    private bool TryUpdateGenericTypeParameterNullabilityFromReflectedType(NullabilityInfo nullability, Type genericParameter, Type context, Type reflectedType);
    private static bool TryPopulateNullabilityInfo(NullabilityInfo nullability, NullableAttributeStateParser parser, Int32& index);
    [NullableContextAttribute("2")]
private static NullabilityState TranslateByte(object value);
    private static NullabilityState TranslateByte(byte b);
    private static bool IsValueTypeOrValueTypeByRef(Type type);
    [CompilerGeneratedAttribute]
internal static int <TryUpdateGenericTypeParameterNullabilityFromReflectedType>g__CountNullabilityStates|28_0(Type type);
}
internal enum System.Reflection.NullabilityState : Enum {
    public int value__;
    public static NullabilityState Unknown;
    public static NullabilityState NotNull;
    public static NullabilityState Nullable;
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("1")]
internal class System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("12")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("64")]
internal class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("396")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("1774")]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.SuppressGCTransitionAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute : Attribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Type[] CallConvs;
    [NullableAttribute("2")]
public string EntryPoint;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.ObsoletedOSPlatformAttribute : OSPlatformAttribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName);
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public string PlatformName { get; }
    protected OSPlatformAttribute(string platformName);
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
    public SupportedOSPlatformAttribute(string platformName);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public SupportedOSPlatformGuardAttribute(string platformName);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("1")]
internal class System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
    public TargetPlatformAttribute(string platformName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    [NullableContextAttribute("1")]
public UnsupportedOSPlatformAttribute(string platformName);
    [NullableContextAttribute("1")]
public UnsupportedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformGuardAttribute(string platformName);
}
