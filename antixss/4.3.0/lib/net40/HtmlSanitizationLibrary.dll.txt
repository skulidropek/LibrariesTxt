internal static class Microsoft.Exchange.CtsResources.GlobalizationStrings : object {
    private static ResourceManager ResourceManager;
    private static GlobalizationStrings();
    internal static string InvalidCodePage(int codePage);
}
internal static class Microsoft.Exchange.CtsResources.TextConvertersStrings : object {
    private static ResourceManager ResourceManager;
    public static string InputEncodingRequired { get; }
    public static string ConverterWriterInInconsistentStare { get; }
    public static string TagTooLong { get; }
    public static string WriteAfterFlush { get; }
    public static string TooManyIterationsToFlushConverter { get; }
    public static string IndexOutOfRange { get; }
    public static string CountTooLarge { get; }
    public static string TooManyIterationsToProduceOutput { get; }
    public static string TooManyIterationsToProcessInput { get; }
    public static string CannotWriteWhileCopyPending { get; }
    public static string ParametersCannotBeChangedAfterConverterObjectIsUsed { get; }
    public static string CountOutOfRange { get; }
    public static string WriteUnsupported { get; }
    public static string ContextNotValidInThisState { get; }
    public static string OffsetOutOfRange { get; }
    public static string ReadUnsupported { get; }
    public static string SeekUnsupported { get; }
    public static string ConverterStreamInInconsistentStare { get; }
    public static string HtmlNestingTooDeep { get; }
    public static string ConverterReaderInInconsistentStare { get; }
    private static TextConvertersStrings();
    public static string get_InputEncodingRequired();
    public static string get_ConverterWriterInInconsistentStare();
    public static string get_TagTooLong();
    public static string get_WriteAfterFlush();
    public static string get_TooManyIterationsToFlushConverter();
    public static string get_IndexOutOfRange();
    public static string get_CountTooLarge();
    public static string get_TooManyIterationsToProduceOutput();
    public static string CannotWriteOtherTagsInsideElement(string elementName);
    public static string get_TooManyIterationsToProcessInput();
    public static string get_CannotWriteWhileCopyPending();
    public static string get_ParametersCannotBeChangedAfterConverterObjectIsUsed();
    public static string get_CountOutOfRange();
    public static string get_WriteUnsupported();
    public static string get_ContextNotValidInThisState();
    public static string get_OffsetOutOfRange();
    public static string get_ReadUnsupported();
    public static string get_SeekUnsupported();
    public static string get_ConverterStreamInInconsistentStare();
    public static string get_HtmlNestingTooDeep();
    public static string get_ConverterReaderInInconsistentStare();
}
internal class Microsoft.Exchange.Data.ExchangeDataException : Exception {
    public ExchangeDataException(string message);
    public ExchangeDataException(string message, Exception innerException);
    protected ExchangeDataException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Exchange.Data.Globalization.AsciiEncoderFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual int get_MaxCharCount();
    public static string GetCharacterFallback(char charUnknown);
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
}
internal class Microsoft.Exchange.Data.Globalization.Charset : object {
    private bool available;
    private Encoding encoding;
    private short mapIndex;
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Culture <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWindowsCharset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public int CodePage { get; public set; }
    public string Name { get; public set; }
    public Culture Culture { get; public set; }
    public bool IsDetectable { get; }
    public bool IsWindowsCharset { get; public set; }
    public string Description { get; public set; }
    unknown int MapIndex {internal set; }
    internal Charset(int codePage, string name);
    [CompilerGeneratedAttribute]
public int get_CodePage();
    [CompilerGeneratedAttribute]
public void set_CodePage(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Culture get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(Culture value);
    public bool get_IsDetectable();
    [CompilerGeneratedAttribute]
public bool get_IsWindowsCharset();
    [CompilerGeneratedAttribute]
public void set_IsWindowsCharset(bool value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    internal void set_MapIndex(int value);
    public static bool TryGetCharset(string name, Charset& charset);
    public static bool TryGetCharset(int codePage, Charset& charset);
    public static bool TryGetEncoding(int codePage, Encoding& encoding);
    public static bool TryGetEncoding(string name, Encoding& encoding);
    public static Encoding GetEncoding(int codePage);
    public static Charset GetCharset(int codePage);
    public bool TryGetEncoding(Encoding& attemptedEncoding);
    public Encoding GetEncoding();
}
internal class Microsoft.Exchange.Data.Globalization.CharsetNotInstalledException : InvalidCharsetException {
    public CharsetNotInstalledException(int codePage, string message);
}
internal enum Microsoft.Exchange.Data.Globalization.CodePageAsciiSupport : Enum {
    public byte value__;
    public static CodePageAsciiSupport Unknown;
    public static CodePageAsciiSupport None;
    public static CodePageAsciiSupport Incomplete;
    public static CodePageAsciiSupport Remap;
    public static CodePageAsciiSupport Fine;
    public static CodePageAsciiSupport Complete;
}
internal class Microsoft.Exchange.Data.Globalization.CodePageDetectData : object {
    internal static CodePage[] CodePages;
    private static CodePageDetectData();
}
[FlagsAttribute]
internal enum Microsoft.Exchange.Data.Globalization.CodePageFlags : Enum {
    public byte value__;
    public static CodePageFlags None;
    public static CodePageFlags Detectable;
    public static CodePageFlags SevenBit;
}
internal enum Microsoft.Exchange.Data.Globalization.CodePageKind : Enum {
    public byte value__;
    public static CodePageKind Unknown;
    public static CodePageKind Sbcs;
    public static CodePageKind Dbcs;
    public static CodePageKind Mbcs;
    public static CodePageKind Unicode;
}
internal class Microsoft.Exchange.Data.Globalization.CodePageMap : CodePageMapData {
    private int codePage;
    private CodePageRange[] ranges;
    private int lastRangeIndex;
    private CodePageRange lastRange;
    public bool ChoseCodePage(int newCodePage);
    public bool IsUnsafeExtendedCharacter(char ch);
}
internal class Microsoft.Exchange.Data.Globalization.CodePageMapData : object {
    private static CodePage[] AllKnownCodePages;
    private static Byte[] CharacterBitmap;
    internal static CodePage[] CodePages { get; }
    internal static Byte[] Bitmap { get; }
    private static CodePageMapData();
    internal static CodePage[] get_CodePages();
    internal static Byte[] get_Bitmap();
}
internal enum Microsoft.Exchange.Data.Globalization.CodePageUnicodeCoverage : Enum {
    public byte value__;
    public static CodePageUnicodeCoverage Unknown;
    public static CodePageUnicodeCoverage Partial;
    public static CodePageUnicodeCoverage Complete;
}
internal class Microsoft.Exchange.Data.Globalization.Culture : object {
    private int lcid;
    private string name;
    private Int32[] codepageDetectionPriorityOrder;
    private CultureInfo cultureInfo;
    [CompilerGeneratedAttribute]
private Charset <WindowsCharset>k__BackingField;
    [CompilerGeneratedAttribute]
private Charset <MimeCharset>k__BackingField;
    [CompilerGeneratedAttribute]
private Charset <WebCharset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NativeDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Culture <ParentCulture>k__BackingField;
    public Charset WindowsCharset { get; public set; }
    public Charset MimeCharset { get; public set; }
    public Charset WebCharset { get; public set; }
    public string Description { get; public set; }
    public string NativeDescription { get; public set; }
    public Culture ParentCulture { get; public set; }
    unknown CultureInfo CultureInfo {public set; }
    internal Culture(int lcid, string name);
    [CompilerGeneratedAttribute]
public Charset get_WindowsCharset();
    [CompilerGeneratedAttribute]
public void set_WindowsCharset(Charset value);
    [CompilerGeneratedAttribute]
public Charset get_MimeCharset();
    [CompilerGeneratedAttribute]
public void set_MimeCharset(Charset value);
    [CompilerGeneratedAttribute]
public Charset get_WebCharset();
    [CompilerGeneratedAttribute]
public void set_WebCharset(Charset value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_NativeDescription();
    [CompilerGeneratedAttribute]
public void set_NativeDescription(string value);
    [CompilerGeneratedAttribute]
public Culture get_ParentCulture();
    [CompilerGeneratedAttribute]
public void set_ParentCulture(Culture value);
    public void set_CultureInfo(CultureInfo value);
    internal Int32[] GetCodepageDetectionPriorityOrder(GlobalizationData data);
    internal void SetCodepageDetectionPriorityOrder(Int32[] newCodepageDetectionPriorityOrder);
}
internal static class Microsoft.Exchange.Data.Globalization.CultureCharsetDatabase : object {
    private static IntComparer IntComparerInstance;
    private static GlobalizationData internalGlobalizationDataStore;
    internal static GlobalizationData InternalGlobalizationData { get; internal set; }
    private static CultureCharsetDatabase();
    internal static GlobalizationData get_InternalGlobalizationData();
    internal static void set_InternalGlobalizationData(GlobalizationData value);
    internal static Int32[] GetCultureSpecificCodepageDetectionPriorityOrder(Culture culture, Int32[] originalPriorityList);
    private static GlobalizationData LoadGlobalizationData(string defaultCultureName);
    private static bool IsDbcs(int codePage);
    private static bool InList(int codePage, Int32[] list, int listCount);
    private static bool IsSameLanguage(int codePage, int windowsCodePage);
}
internal enum Microsoft.Exchange.Data.Globalization.FallbackExceptions : Enum {
    public int value__;
    public static FallbackExceptions None;
    public static FallbackExceptions Common;
    public static FallbackExceptions All;
}
internal class Microsoft.Exchange.Data.Globalization.InvalidCharsetException : ExchangeDataException {
    public InvalidCharsetException(int codePage);
    public InvalidCharsetException(int codePage, string message);
    protected InvalidCharsetException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Exchange.Data.Globalization.RemapEncoding : Encoding {
    private Encoding decodingEncoding;
    private Encoding encodingEncoding;
    public int CodePage { get; }
    public string BodyName { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsSingleByte { get; }
    public RemapEncoding(int codePage);
    public virtual int get_CodePage();
    public virtual string get_BodyName();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual bool get_IsSingleByte();
    public virtual Byte[] GetPreamble();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual object Clone();
}
internal static class Microsoft.Exchange.Data.Internal.ApplicationServices : object {
    private static IApplicationServices ServicesProvider;
    public static IApplicationServices Provider { get; }
    private static ApplicationServices();
    public static IApplicationServices get_Provider();
    public static CtsConfigurationSetting GetSimpleConfigurationSetting(string subSectionName, string settingName);
    private static IApplicationServices LoadServices();
}
internal class Microsoft.Exchange.Data.Internal.CtsConfigurationArgument : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; private set; }
    public string Value { get; private set; }
    internal CtsConfigurationArgument(string name, string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
}
internal class Microsoft.Exchange.Data.Internal.CtsConfigurationSection : ConfigurationSection {
    private Dictionary`2<string, IList`1<CtsConfigurationSetting>> subSections;
    private static ConfigurationPropertyCollection properties;
    public Dictionary`2<string, IList`1<CtsConfigurationSetting>> SubSectionsDictionary { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public Dictionary`2<string, IList`1<CtsConfigurationSetting>> get_SubSectionsDictionary();
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual void DeserializeSection(XmlReader reader);
    private static CtsConfigurationSetting DeserializeSetting(XmlReader reader);
}
internal class Microsoft.Exchange.Data.Internal.CtsConfigurationSetting : object {
    private string configurationName;
    private IList`1<CtsConfigurationArgument> arguments;
    public string Name { get; }
    public IList`1<CtsConfigurationArgument> Arguments { get; }
    internal CtsConfigurationSetting(string name);
    public string get_Name();
    public IList`1<CtsConfigurationArgument> get_Arguments();
    internal void AddArgument(string name, string value);
}
internal class Microsoft.Exchange.Data.Internal.DefaultApplicationServices : object {
    private static IList`1<CtsConfigurationSetting> EmptySubSection;
    private object lockObject;
    private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) configurationSubSections;
    private static DefaultApplicationServices();
    public sealed virtual IList`1<CtsConfigurationSetting> GetConfiguration(string subSectionName);
    public sealed virtual void RefreshConfiguration();
    public sealed virtual void LogConfigurationErrorEvent();
}
internal interface Microsoft.Exchange.Data.Internal.IApplicationServices {
    public abstract virtual IList`1<CtsConfigurationSetting> GetConfiguration(string subSectionName);
    public abstract virtual void RefreshConfiguration();
    public abstract virtual void LogConfigurationErrorEvent();
}
internal static class Microsoft.Exchange.Data.Internal.InternalDebug : object {
    [CompilerGeneratedAttribute]
private static bool <UseSystemDiagnostics>k__BackingField;
    internal static bool UseSystemDiagnostics { get; internal set; }
    [CompilerGeneratedAttribute]
internal static bool get_UseSystemDiagnostics();
    [CompilerGeneratedAttribute]
internal static void set_UseSystemDiagnostics(bool value);
    [ConditionalAttribute("DEBUG")]
public static void Trace(long traceType, string format, Object[] traceObjects);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string formatString);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Exchange.Data.TextConverters.BufferString : ValueType {
    private Char[] buffer;
    private int offset;
    private int count;
    public static BufferString Null;
    public char Item { get; }
    public int Length { get; }
    public BufferString(Char[] buffer, int offset, int count);
    private static BufferString();
    public char get_Item(int index);
    public int get_Length();
    public void TrimWhitespace();
    public bool EqualsToLowerCaseStringIgnoreCase(string rightPart);
    public virtual string ToString();
    [ConditionalAttribute("DEBUG")]
private static void AssertStringIsLowerCase(string rightPart);
}
internal class Microsoft.Exchange.Data.TextConverters.ByteCache : object {
    private int cachedLength;
    private CacheEntry headEntry;
    private CacheEntry tailEntry;
    private CacheEntry freeList;
    public int Length { get; }
    public int get_Length();
    public void Reset();
    public void GetBuffer(int size, Byte[]& buffer, Int32& offset);
    public void Commit(int count);
    public void GetData(Byte[]& outputBuffer, Int32& outputOffset, Int32& outputCount);
    public void ReportRead(int count);
    public int Read(Byte[] buffer, int offset, int count);
    private void AllocateTail(int size);
}
[FlagsAttribute]
internal enum Microsoft.Exchange.Data.TextConverters.CharClass : Enum {
    public UInt32 value__;
    public static CharClass Invalid;
    public static CharClass NotInterestingText;
    public static CharClass Control;
    public static CharClass Whitespace;
    public static CharClass Alpha;
    public static CharClass Numeric;
    public static CharClass Backslash;
    public static CharClass LessThan;
    public static CharClass Equals;
    public static CharClass GreaterThan;
    public static CharClass Solidus;
    public static CharClass Ampersand;
    public static CharClass Nbsp;
    public static CharClass Comma;
    public static CharClass SingleQuote;
    public static CharClass DoubleQuote;
    public static CharClass GraveAccent;
    public static CharClass Circumflex;
    public static CharClass VerticalLine;
    public static CharClass Parentheses;
    public static CharClass CurlyBrackets;
    public static CharClass SquareBrackets;
    public static CharClass Tilde;
    public static CharClass Colon;
    public static CharClass UniqueMask;
    public static CharClass AlphaHex;
    public static CharClass HtmlSuffix;
    public static CharClass RtfInteresting;
    public static CharClass OverlappedMask;
    public static CharClass Quote;
    public static CharClass Brackets;
    public static CharClass NonWhitespaceText;
    public static CharClass NonWhitespaceNonControlText;
    public static CharClass HtmlNonWhitespaceText;
    public static CharClass NonWhitespaceNonUri;
    public static CharClass NonWhitespaceUri;
    public static CharClass HtmlTagName;
    public static CharClass HtmlTagNamePrefix;
    public static CharClass HtmlAttrName;
    public static CharClass HtmlAttrNamePrefix;
    public static CharClass HtmlAttrValue;
    public static CharClass HtmlScanQuoteSensitive;
    public static CharClass HtmlEntity;
    public static CharClass HtmlSimpleTagName;
    public static CharClass HtmlEndTagName;
    public static CharClass HtmlSimpleAttrName;
    public static CharClass HtmlEndAttrName;
    public static CharClass HtmlSimpleAttrQuotedValue;
    public static CharClass HtmlSimpleAttrUnquotedValue;
    public static CharClass HtmlEndAttrUnquotedValue;
    public static CharClass Hex;
}
internal enum Microsoft.Exchange.Data.TextConverters.CollapseWhitespaceState : Enum {
    public int value__;
    public static CollapseWhitespaceState NonSpace;
    public static CollapseWhitespaceState Whitespace;
    public static CollapseWhitespaceState NewLine;
}
internal enum Microsoft.Exchange.Data.TextConverters.ConfigParameter : Enum {
    public int value__;
    public static ConfigParameter InputEncoding;
    public static ConfigParameter OutputEncoding;
    public static ConfigParameter RtfCompressionMode;
    public static ConfigParameter RtfEncapsulation;
}
internal class Microsoft.Exchange.Data.TextConverters.ConverterBufferInput : ConverterInput {
    private static int DefaultMaxLength;
    private int maxLength;
    private string originalFragment;
    private Char[] parseBuffer;
    public bool IsEnough { get; }
    public bool IsEmpty { get; }
    public ConverterBufferInput(int maxLength, IProgressMonitor progressMonitor);
    public ConverterBufferInput(string fragment, IProgressMonitor progressMonitor);
    public ConverterBufferInput(int maxLength, string fragment, IProgressMonitor progressMonitor);
    public sealed virtual bool get_IsEnough();
    public bool get_IsEmpty();
    public void Write(string str);
    public sealed virtual void Write(Char[] buffer, int offset, int count);
    public sealed virtual void Write(int ucs32Char);
    public void Reset();
    public void Initialize(string fragment);
    public virtual bool ReadMore(Char[]& buffer, Int32& start, Int32& current, Int32& end);
    public virtual void ReportProcessed(int processedSize);
    public virtual int RemoveGap(int gapBegin, int gapEnd);
    protected virtual void Dispose();
    private int PrepareToBuffer(int count);
}
internal class Microsoft.Exchange.Data.TextConverters.ConverterDecodingInput : ConverterInput {
    private IResultsFeedback resultFeedback;
    private Stream pullSource;
    private ConverterStream pushSource;
    private bool rawEndOfFile;
    private Encoding originalEncoding;
    private Encoding encoding;
    private Decoder decoder;
    private bool encodingChanged;
    private int minDecodeBytes;
    private int minDecodeChars;
    private Char[] parseBuffer;
    private int parseStart;
    private int parseEnd;
    private int readFileOffset;
    private Byte[] readBuffer;
    private int readCurrent;
    private int readEnd;
    private Byte[] pushChunkBuffer;
    private int pushChunkStart;
    private int pushChunkCount;
    private int pushChunkUsed;
    private bool detectEncodingFromByteOrderMark;
    private Byte[] preamble;
    private IRestartable restartConsumer;
    private int restartMax;
    private ByteCache restartCache;
    private bool restarting;
    public Encoding Encoding { get; }
    public bool EncodingChanged { get; public set; }
    public ConverterDecodingInput(Stream source, bool push, Encoding encoding, bool detectEncodingFromByteOrderMark, int maxParseToken, int restartMax, int inputBufferSize, bool testBoundaryConditions, IResultsFeedback resultFeedback, IProgressMonitor progressMonitor);
    private void Reinitialize();
    public Encoding get_Encoding();
    public bool get_EncodingChanged();
    public void set_EncodingChanged(bool value);
    public virtual void SetRestartConsumer(IRestartable restartConsumer);
    public virtual bool ReadMore(Char[]& buffer, Int32& start, Int32& current, Int32& end);
    public virtual void ReportProcessed(int processedSize);
    public virtual int RemoveGap(int gapBegin, int gapEnd);
    public bool RestartWithNewEncoding(Encoding newEncoding);
    private void SetNewEncoding(Encoding newEncoding);
    protected virtual void Dispose();
    private int DecodeFromBuffer(Byte[] buffer, Int32& start, int end, int fileOffset, bool flush);
    private bool EnsureFreeSpace();
    private int GetMaxCharCount(int byteCount);
    private int CalculateMaxBytes(int charCount);
    private void DetectEncoding(Byte[] buffer, int start, int end);
    private void BackupForRestart(Byte[] buffer, int offset, int count, int fileOffset, bool force);
    private bool GetRestartChunk(Byte[]& restartChunk, Int32& restartStart, Int32& restartEnd);
    private void ReportRestartChunkUsed(int count);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IReusable.Initialize(object newSourceOrDestination);
}
internal class Microsoft.Exchange.Data.TextConverters.ConverterEncodingOutput : ConverterOutput {
    private static int LineSpaceThreshold;
    private static int SpaceThreshold;
    protected IResultsFeedback resultFeedback;
    private Stream pushSink;
    private ConverterStream pullSink;
    private bool endOfFile;
    private bool restartablePushSink;
    private long restartPosition;
    private bool encodingSameAsInput;
    private bool restartable;
    private bool canRestart;
    private bool lineModeEncoding;
    private int minCharsEncode;
    private Char[] lineBuffer;
    private int lineBufferCount;
    private int lineBufferLastNL;
    private ByteCache cache;
    private Encoding originalEncoding;
    private Encoding encoding;
    private Encoder encoder;
    private bool encodingCompleteUnicode;
    private CodePageMap codePageMap;
    private bool isFirstChar;
    public Encoding Encoding { get; public set; }
    public bool CodePageSameAsInput { get; }
    public bool CanAcceptMore { get; }
    public ConverterEncodingOutput(Stream destination, bool push, bool restartable, Encoding encoding, bool encodingSameAsInput, bool testBoundaryConditions, IResultsFeedback resultFeedback);
    private void Reinitialize();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_CodePageSameAsInput();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IRestartable.CanRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.Restart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.DisableRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IReusable.Initialize(object newSourceOrDestination);
    public virtual bool get_CanAcceptMore();
    public virtual void Write(Char[] buffer, int offset, int count, IFallback fallback);
    public void WriteComplete(Char[] buffer, int offset, int count, IFallback fallback);
    public virtual void Write(string text);
    public virtual void Flush();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IByteSource.GetOutputChunk(Byte[]& chunkBuffer, Int32& chunkOffset, Int32& chunkLength);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IByteSource.ReportOutput(int readCount);
    protected virtual void Dispose();
    private void EncodeBuffer(Char[] buffer, int offset, int count, bool flush);
    internal void ChangeEncoding(Encoding newEncoding);
    private bool FlushCached();
}
internal abstract class Microsoft.Exchange.Data.TextConverters.ConverterInput : object {
    protected bool endOfFile;
    protected int maxTokenSize;
    protected IProgressMonitor progressMonitor;
    public bool EndOfFile { get; }
    public int MaxTokenSize { get; }
    protected ConverterInput(IProgressMonitor progressMonitor);
    public bool get_EndOfFile();
    public int get_MaxTokenSize();
    public virtual void SetRestartConsumer(IRestartable restartConsumer);
    public abstract virtual bool ReadMore(Char[]& buffer, Int32& start, Int32& current, Int32& end);
    public abstract virtual void ReportProcessed(int processedSize);
    public abstract virtual int RemoveGap(int gapBegin, int gapEnd);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose();
}
internal abstract class Microsoft.Exchange.Data.TextConverters.ConverterOutput : object {
    protected static int stringBufferMax;
    protected static int stringBufferReserve;
    protected static int stringBufferThreshold;
    protected Char[] stringBuffer;
    private IFallback fallback;
    public bool CanAcceptMore { get; }
    private bool Microsoft.Exchange.Data.TextConverters.ITextSink.IsEnough { get; }
    public abstract virtual bool get_CanAcceptMore();
    public abstract virtual void Write(Char[] buffer, int offset, int count, IFallback fallback);
    public abstract virtual void Flush();
    public virtual void Write(string text);
    public void Write(string text, IFallback fallback);
    public void Write(string text, int offset, int count);
    public void Write(string text, int offset, int count, IFallback fallback);
    public void Write(char ch);
    public void Write(char ch, IFallback fallback);
    public void Write(int ucs32Literal, IFallback fallback);
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.ITextSink.get_IsEnough();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.ITextSink.Write(Char[] buffer, int offset, int count);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.ITextSink.Write(int ucs32Literal);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose();
}
internal class Microsoft.Exchange.Data.TextConverters.ConverterReader : TextReader {
    private int maxLoopsWithoutProgress;
    private ConverterUnicodeOutput sourceOutputObject;
    private IProducerConsumer producer;
    private bool madeProgress;
    private Char[] writeBuffer;
    private int writeIndex;
    private int writeCount;
    private object source;
    private bool endOfFile;
    private bool inconsistentState;
    public ConverterReader(TextReader sourceReader, TextConverter converter);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IProgressMonitor.ReportProgress();
    internal void SetSource(ConverterUnicodeOutput converterUnicodeOutputSource);
    internal void GetOutputBuffer(Char[]& outputBuffer, Int32& outputIndex, Int32& outputCount);
    internal void ReportOutput(int outputCount);
    internal void ReportEndOfFile();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Exchange.Data.TextConverters.ConverterStream : Stream {
    private int maxLoopsWithoutProgress;
    private IProducerConsumer consumer;
    private bool madeProgress;
    private Byte[] chunkToReadBuffer;
    private int chunkToReadOffset;
    private int chunkToReadCount;
    private IByteSource byteSource;
    private IProducerConsumer producer;
    private Byte[] writeBuffer;
    private int writeOffset;
    private int writeCount;
    private object sourceOrDestination;
    private bool endOfFile;
    private bool inconsistentState;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ConverterStream(TextReader sourceReader, TextConverter converter);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual void Close();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IProgressMonitor.ReportProgress();
    internal void SetSource(IByteSource newByteSource);
    internal void GetOutputBuffer(Byte[]& outputBuffer, Int32& outputOffset, Int32& outputCount);
    internal void ReportOutput(int outputCount);
    internal void ReportEndOfFile();
    internal bool GetInputChunk(Byte[]& chunkBuffer, Int32& chunkOffset, Int32& chunkCount, Boolean& eof);
    internal void ReportRead(int readCount);
}
internal enum Microsoft.Exchange.Data.TextConverters.ConverterStreamAccess : Enum {
    public int value__;
    public static ConverterStreamAccess Read;
    public static ConverterStreamAccess Write;
}
internal class Microsoft.Exchange.Data.TextConverters.ConverterUnicodeInput : ConverterInput {
    private TextReader pullSource;
    private ConverterWriter pushSource;
    private Char[] parseBuffer;
    private int parseStart;
    private int parseEnd;
    private Char[] pushChunkBuffer;
    private int pushChunkStart;
    private int pushChunkCount;
    private int pushChunkUsed;
    public ConverterUnicodeInput(object source, bool push, int maxParseToken, bool testBoundaryConditions, IProgressMonitor progressMonitor);
    private void Reinitialize();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IReusable.Initialize(object newSourceOrDestination);
    public virtual bool ReadMore(Char[]& buffer, Int32& start, Int32& current, Int32& end);
    public virtual void ReportProcessed(int processedSize);
    public virtual int RemoveGap(int gapBegin, int gapEnd);
    public void GetInputBuffer(Char[]& inputBuffer, Int32& inputOffset, Int32& inputCount, Int32& parseCount);
    public void Commit(int inputCount);
    protected virtual void Dispose();
    private bool EnsureFreeSpace();
}
internal class Microsoft.Exchange.Data.TextConverters.ConverterUnicodeOutput : ConverterOutput {
    private static int FallbackExpansionMax;
    private TextWriter pushSink;
    private ConverterReader pullSink;
    private bool endOfFile;
    private bool restartable;
    private bool canRestart;
    private bool isFirstChar;
    private TextCache cache;
    public bool CanAcceptMore { get; }
    public ConverterUnicodeOutput(object destination, bool push, bool restartable);
    private void Reinitialize();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IRestartable.CanRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.Restart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.DisableRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IReusable.Initialize(object newSourceOrDestination);
    protected virtual void Dispose();
    public virtual bool get_CanAcceptMore();
    public virtual void Write(Char[] buffer, int offset, int count, IFallback fallback);
    public virtual void Flush();
    public bool GetOutputChunk(Char[]& chunkBuffer, Int32& chunkOffset, Int32& chunkLength);
    public void ReportOutput(int readCount);
    private bool FlushCached();
    private static bool IsUnsafeCharacter(char ch, Byte[] unsafeAsciiMap, byte unsafeAsciiMask, bool hasUnsafeUnicode, bool isFirstChar, IFallback fallback);
}
internal class Microsoft.Exchange.Data.TextConverters.ConverterWriter : TextWriter {
    private ConverterUnicodeInput sinkInputObject;
    private IProducerConsumer consumer;
    private bool madeProgress;
    private int maxLoopsWithoutProgress;
    private Char[] chunkToReadBuffer;
    private int chunkToReadIndex;
    private int chunkToReadCount;
    private object destination;
    private bool endOfFile;
    private bool inconsistentState;
    private bool boundaryTesting;
    public Encoding Encoding { get; }
    public virtual Encoding get_Encoding();
    public virtual void Flush();
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual void WriteLine(string value);
    internal void SetSink(ConverterUnicodeInput sinkInputObject);
    internal bool GetInputChunk(Char[]& chunkBuffer, Int32& chunkIndex, Int32& chunkCount, Boolean& eof);
    internal void ReportRead(int readCount);
    protected virtual void Dispose(bool disposing);
    private void WriteBig(Char[] buffer, int index, int count, int parseCount);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IProgressMonitor.ReportProgress();
}
[FlagsAttribute]
internal enum Microsoft.Exchange.Data.TextConverters.DbcsLeadBits : Enum {
    public byte value__;
    public static DbcsLeadBits Lead1361;
    public static DbcsLeadBits Lead10001;
    public static DbcsLeadBits Lead10002;
    public static DbcsLeadBits Lead10003;
    public static DbcsLeadBits Lead10008;
    public static DbcsLeadBits Lead932;
    public static DbcsLeadBits Lead9XX;
}
internal class Microsoft.Exchange.Data.TextConverters.HashCode : ValueType {
    private int hash1;
    private int hash2;
    private int offset;
    public HashCode(bool ignore);
    public static int CalculateEmptyHash();
    public static int CalculateLowerCase(Char[] buffer, int offset, int length);
    public void AdvanceLowerCase(Char* s, int len);
    public void AdvanceLowerCase(int ucs32);
    public int AdvanceAndFinalizeHash(char c);
    public void AdvanceLowerCase(char c);
    public void AdvanceLowerCase(Char[] buffer, int offset, int length);
    private static void CheckArgs(Char[] buffer, int offset, int length);
    public int FinalizeHash();
}
internal enum Microsoft.Exchange.Data.TextConverters.HeaderFooterFormat : Enum {
    public int value__;
    public static HeaderFooterFormat Text;
    public static HeaderFooterFormat Html;
}
internal enum Microsoft.Exchange.Data.TextConverters.HtmlAttributeId : Enum {
    public byte value__;
    public static HtmlAttributeId Unknown;
    public static HtmlAttributeId Abbr;
    public static HtmlAttributeId Accept;
    public static HtmlAttributeId AcceptCharset;
    public static HtmlAttributeId AccessKey;
    public static HtmlAttributeId Action;
    public static HtmlAttributeId Align;
    public static HtmlAttributeId Alink;
    public static HtmlAttributeId Alt;
    public static HtmlAttributeId Archive;
    public static HtmlAttributeId Axis;
    public static HtmlAttributeId Background;
    public static HtmlAttributeId BGColor;
    public static HtmlAttributeId Border;
    public static HtmlAttributeId CellPadding;
    public static HtmlAttributeId CellSpacing;
    public static HtmlAttributeId Char;
    public static HtmlAttributeId CharOff;
    public static HtmlAttributeId Charset;
    public static HtmlAttributeId Checked;
    public static HtmlAttributeId Cite;
    public static HtmlAttributeId Class;
    public static HtmlAttributeId ClassId;
    public static HtmlAttributeId Clear;
    public static HtmlAttributeId Code;
    public static HtmlAttributeId CodeBase;
    public static HtmlAttributeId CodeType;
    public static HtmlAttributeId Color;
    public static HtmlAttributeId Cols;
    public static HtmlAttributeId ColSpan;
    public static HtmlAttributeId Compact;
    public static HtmlAttributeId Content;
    public static HtmlAttributeId Coords;
    public static HtmlAttributeId Data;
    public static HtmlAttributeId DateTime;
    public static HtmlAttributeId Declare;
    public static HtmlAttributeId Defer;
    public static HtmlAttributeId Dir;
    public static HtmlAttributeId Disabled;
    public static HtmlAttributeId DynSrc;
    public static HtmlAttributeId EncType;
    public static HtmlAttributeId Face;
    public static HtmlAttributeId For;
    public static HtmlAttributeId Frame;
    public static HtmlAttributeId FrameBorder;
    public static HtmlAttributeId Headers;
    public static HtmlAttributeId Height;
    public static HtmlAttributeId Href;
    public static HtmlAttributeId HrefLang;
    public static HtmlAttributeId Hspace;
    public static HtmlAttributeId HttpEquiv;
    public static HtmlAttributeId Id;
    public static HtmlAttributeId IsMap;
    public static HtmlAttributeId Label;
    public static HtmlAttributeId Lang;
    public static HtmlAttributeId Language;
    public static HtmlAttributeId LeftMargin;
    public static HtmlAttributeId Link;
    public static HtmlAttributeId LongDesc;
    public static HtmlAttributeId LowSrc;
    public static HtmlAttributeId MarginHeight;
    public static HtmlAttributeId MarginWidth;
    public static HtmlAttributeId MaxLength;
    public static HtmlAttributeId Media;
    public static HtmlAttributeId Method;
    public static HtmlAttributeId Multiple;
    public static HtmlAttributeId Name;
    public static HtmlAttributeId NoHref;
    public static HtmlAttributeId NoResize;
    public static HtmlAttributeId NoShade;
    public static HtmlAttributeId NoWrap;
    public static HtmlAttributeId Object;
    public static HtmlAttributeId Profile;
    public static HtmlAttributeId Prompt;
    public static HtmlAttributeId ReadOnly;
    public static HtmlAttributeId Rel;
    public static HtmlAttributeId Rev;
    public static HtmlAttributeId Rows;
    public static HtmlAttributeId RowSpan;
    public static HtmlAttributeId Rules;
    public static HtmlAttributeId Scheme;
    public static HtmlAttributeId Scope;
    public static HtmlAttributeId Scrolling;
    public static HtmlAttributeId Selected;
    public static HtmlAttributeId Shape;
    public static HtmlAttributeId Size;
    public static HtmlAttributeId Span;
    public static HtmlAttributeId Src;
    public static HtmlAttributeId StandBy;
    public static HtmlAttributeId Start;
    public static HtmlAttributeId Style;
    public static HtmlAttributeId Summary;
    public static HtmlAttributeId TabIndex;
    public static HtmlAttributeId Target;
    public static HtmlAttributeId Text;
    public static HtmlAttributeId Title;
    public static HtmlAttributeId TopMargin;
    public static HtmlAttributeId Type;
    public static HtmlAttributeId UseMap;
    public static HtmlAttributeId Valign;
    public static HtmlAttributeId Value;
    public static HtmlAttributeId ValueType;
    public static HtmlAttributeId Version;
    public static HtmlAttributeId Vlink;
    public static HtmlAttributeId Vspace;
    public static HtmlAttributeId Width;
}
internal class Microsoft.Exchange.Data.TextConverters.HtmlAttributeParts : ValueType {
    private AttrPartMajor major;
    private AttrPartMinor minor;
    internal HtmlAttributeParts(AttrPartMajor major, AttrPartMinor minor);
}
internal class Microsoft.Exchange.Data.TextConverters.HtmlInjection : Injection {
    protected bool filterHtml;
    protected HtmlTagCallback callback;
    protected bool injectingHead;
    protected IProgressMonitor progressMonitor;
    protected IHtmlParser documentParser;
    protected HtmlParser fragmentParser;
    protected HtmlToHtmlConverter fragmentToHtmlConverter;
    protected HtmlToTextConverter fragmentToTextConverter;
    public bool Active { get; }
    public bool InjectingHead { get; }
    public HtmlInjection(string injectHead, string injectTail, HeaderFooterFormat injectionFormat, bool filterHtml, HtmlTagCallback callback, bool testBoundaryConditions, Stream traceStream, IProgressMonitor progressMonitor);
    public bool get_Active();
    public bool get_InjectingHead();
    public IHtmlParser Push(bool head, IHtmlParser documentParser);
    public IHtmlParser Pop();
    public virtual void Inject(bool head, TextOutput output);
    protected virtual void Dispose(bool disposing);
    public virtual void InjectRtfFonts(int firstAvailableFontHandle);
    public virtual void InjectRtfColors(int nextColorIndex);
}
internal class Microsoft.Exchange.Data.TextConverters.HtmlTagCallback : MulticastDelegate {
    public HtmlTagCallback(object object, IntPtr method);
    public virtual void Invoke(HtmlTagContext tagContext, HtmlWriter htmlWriter);
    public virtual IAsyncResult BeginInvoke(HtmlTagContext tagContext, HtmlWriter htmlWriter, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class Microsoft.Exchange.Data.TextConverters.HtmlTagContext : object {
    private byte cookie;
    private bool valid;
    private bool invokeCallbackForEndTag;
    private bool deleteInnerContent;
    private bool deleteEndTag;
    private bool isEndTag;
    private bool isEmptyElementTag;
    private HtmlNameIndex tagNameIndex;
    private HtmlTagParts tagParts;
    internal HtmlNameIndex TagNameIndex { get; }
    internal HtmlTagParts TagParts { get; }
    internal bool IsInvokeCallbackForEndTag { get; }
    internal bool IsDeleteInnerContent { get; }
    internal bool IsDeleteEndTag { get; }
    internal HtmlNameIndex get_TagNameIndex();
    internal HtmlTagParts get_TagParts();
    internal bool get_IsInvokeCallbackForEndTag();
    internal bool get_IsDeleteInnerContent();
    internal bool get_IsDeleteEndTag();
    internal void InitializeTag(bool isEndTag, HtmlNameIndex tagNameIndex, bool droppedEndTag);
    internal void InitializeFragment(bool isEmptyElementTag, int attributeCount, HtmlTagParts tagParts);
    internal void UninitializeFragment();
    internal virtual bool GetCopyPendingStateImpl();
    internal abstract virtual string GetTagNameImpl();
    internal abstract virtual HtmlAttributeId GetAttributeNameIdImpl(int attributeIndex);
    internal abstract virtual HtmlAttributeParts GetAttributePartsImpl(int attributeIndex);
    internal abstract virtual string GetAttributeNameImpl(int attributeIndex);
    internal abstract virtual string GetAttributeValueImpl(int attributeIndex);
    internal abstract virtual void WriteTagImpl(bool writeAttributes);
    internal virtual void DeleteTagImpl();
    internal abstract virtual void WriteAttributeImpl(int attributeIndex, bool writeName, bool writeValue);
    internal void AssertContextValid();
}
public enum Microsoft.Exchange.Data.TextConverters.HtmlTagId : Enum {
    public byte value__;
    public static HtmlTagId Unknown;
    public static HtmlTagId A;
    public static HtmlTagId Abbr;
    public static HtmlTagId Acronym;
    public static HtmlTagId Address;
    public static HtmlTagId Applet;
    public static HtmlTagId Area;
    public static HtmlTagId B;
    public static HtmlTagId Base;
    public static HtmlTagId BaseFont;
    public static HtmlTagId Bdo;
    public static HtmlTagId BGSound;
    public static HtmlTagId Big;
    public static HtmlTagId Blink;
    public static HtmlTagId BlockQuote;
    public static HtmlTagId Body;
    public static HtmlTagId BR;
    public static HtmlTagId Button;
    public static HtmlTagId Caption;
    public static HtmlTagId Center;
    public static HtmlTagId Cite;
    public static HtmlTagId Code;
    public static HtmlTagId Col;
    public static HtmlTagId ColGroup;
    public static HtmlTagId Comment;
    public static HtmlTagId DD;
    public static HtmlTagId Del;
    public static HtmlTagId Dfn;
    public static HtmlTagId Dir;
    public static HtmlTagId Div;
    public static HtmlTagId DL;
    public static HtmlTagId DT;
    public static HtmlTagId EM;
    public static HtmlTagId Embed;
    public static HtmlTagId FieldSet;
    public static HtmlTagId Font;
    public static HtmlTagId Form;
    public static HtmlTagId Frame;
    public static HtmlTagId FrameSet;
    public static HtmlTagId H1;
    public static HtmlTagId H2;
    public static HtmlTagId H3;
    public static HtmlTagId H4;
    public static HtmlTagId H5;
    public static HtmlTagId H6;
    public static HtmlTagId Head;
    public static HtmlTagId HR;
    public static HtmlTagId Html;
    public static HtmlTagId I;
    public static HtmlTagId Iframe;
    public static HtmlTagId Image;
    public static HtmlTagId Img;
    public static HtmlTagId Input;
    public static HtmlTagId Ins;
    public static HtmlTagId IsIndex;
    public static HtmlTagId Kbd;
    public static HtmlTagId Label;
    public static HtmlTagId Legend;
    public static HtmlTagId LI;
    public static HtmlTagId Link;
    public static HtmlTagId Listing;
    public static HtmlTagId Map;
    public static HtmlTagId Marquee;
    public static HtmlTagId Menu;
    public static HtmlTagId Meta;
    public static HtmlTagId NextId;
    public static HtmlTagId NoBR;
    public static HtmlTagId NoEmbed;
    public static HtmlTagId NoFrames;
    public static HtmlTagId NoScript;
    public static HtmlTagId Object;
    public static HtmlTagId OL;
    public static HtmlTagId OptGroup;
    public static HtmlTagId Option;
    public static HtmlTagId P;
    public static HtmlTagId Param;
    public static HtmlTagId PlainText;
    public static HtmlTagId Pre;
    public static HtmlTagId Q;
    public static HtmlTagId RP;
    public static HtmlTagId RT;
    public static HtmlTagId Ruby;
    public static HtmlTagId S;
    public static HtmlTagId Samp;
    public static HtmlTagId Script;
    public static HtmlTagId Select;
    public static HtmlTagId Small;
    public static HtmlTagId Span;
    public static HtmlTagId Strike;
    public static HtmlTagId Strong;
    public static HtmlTagId Style;
    public static HtmlTagId Sub;
    public static HtmlTagId Sup;
    public static HtmlTagId Table;
    public static HtmlTagId Tbody;
    public static HtmlTagId TD;
    public static HtmlTagId TextArea;
    public static HtmlTagId Tfoot;
    public static HtmlTagId TH;
    public static HtmlTagId Thead;
    public static HtmlTagId Title;
    public static HtmlTagId TR;
    public static HtmlTagId TT;
    public static HtmlTagId U;
    public static HtmlTagId UL;
    public static HtmlTagId Var;
    public static HtmlTagId Wbr;
    public static HtmlTagId Xml;
    public static HtmlTagId Xmp;
}
internal class Microsoft.Exchange.Data.TextConverters.HtmlTagParts : ValueType {
    private TagPartMajor major;
    private TagPartMinor minor;
    public bool Begin { get; }
    public bool Name { get; }
    internal HtmlTagParts(TagPartMajor major, TagPartMinor minor);
    public bool get_Begin();
    public bool get_Name();
    public virtual string ToString();
}
internal class Microsoft.Exchange.Data.TextConverters.HtmlToHtml : TextConverter {
    private Encoding inputEncoding;
    private bool detectEncodingFromByteOrderMark;
    private bool detectEncodingFromMetaTag;
    private Encoding outputEncoding;
    private bool outputEncodingSameAsInput;
    private bool normalizeInputHtml;
    private HeaderFooterFormat injectionFormat;
    private string injectHead;
    private string injectTail;
    private bool filterHtml;
    private HtmlTagCallback htmlCallback;
    private bool testTruncateForCallback;
    private bool outputFragment;
    private int testMaxTokenRuns;
    private Stream testTraceStream;
    private bool testTraceShowTokenNum;
    private int testTraceStopOnTokenNum;
    private Stream testNormalizerTraceStream;
    private bool testNormalizerTraceShowTokenNum;
    private int testNormalizerTraceStopOnTokenNum;
    private int maxHtmlTagSize;
    private int testMaxHtmlTagAttributes;
    private int testMaxHtmlRestartOffset;
    private int testMaxHtmlNormalizerNesting;
    private int smallCssBlockThreshold;
    private bool preserveDisplayNoneStyle;
    unknown bool NormalizeHtml {internal set; }
    unknown bool OutputHtmlFragment {internal set; }
    unknown bool FilterHtml {internal set; }
    internal void set_NormalizeHtml(bool value);
    internal void set_OutputHtmlFragment(bool value);
    internal void set_FilterHtml(bool value);
    internal virtual IProducerConsumer CreatePushChain(ConverterStream converterStream, Stream output);
    internal virtual IProducerConsumer CreatePushChain(ConverterStream converterStream, TextWriter output);
    internal virtual IProducerConsumer CreatePullChain(Stream input, ConverterStream converterStream);
    internal virtual IProducerConsumer CreatePullChain(TextReader input, ConverterStream converterStream);
    internal virtual IProducerConsumer CreatePullChain(Stream input, ConverterReader converterReader);
    internal virtual IProducerConsumer CreatePullChain(TextReader input, ConverterReader converterReader);
    internal virtual void SetResult(ConfigParameter parameterId, object val);
    private IProducerConsumer CreateChain(ConverterInput input, ConverterOutput output, IProgressMonitor progressMonitor);
}
internal class Microsoft.Exchange.Data.TextConverters.HtmlWriter : object {
    private ConverterOutput output;
    private OutputState outputState;
    private bool filterHtml;
    private bool autoNewLines;
    private bool allowWspBeforeFollowingTag;
    private bool lastWhitespace;
    private int lineLength;
    private int longestLineLength;
    private int textLineLength;
    private int literalWhitespaceNesting;
    private bool literalTags;
    private bool literalEntities;
    private bool cssEscaping;
    private IFallback fallback;
    private HtmlNameIndex tagNameIndex;
    private HtmlNameIndex previousTagNameIndex;
    private bool isEndTag;
    private bool isEmptyScopeTag;
    private bool copyPending;
    internal bool HasEncoding { get; }
    internal bool CodePageSameAsInput { get; }
    internal Encoding Encoding { get; internal set; }
    internal bool IsTagOpen { get; }
    private bool Microsoft.Exchange.Data.TextConverters.ITextSink.IsEnough { get; }
    internal HtmlWriter(ConverterOutput output, bool filterHtml, bool autoNewLines);
    internal bool get_HasEncoding();
    internal bool get_CodePageSameAsInput();
    internal Encoding get_Encoding();
    internal void set_Encoding(Encoding value);
    internal bool get_IsTagOpen();
    public void Flush();
    internal void SetCopyPending(bool copyPending);
    internal void WriteStartTag(HtmlNameIndex nameIndex);
    internal void WriteEndTag(HtmlNameIndex nameIndex);
    internal void WriteTagBegin(HtmlNameIndex nameIndex, string name, bool isEndTag, bool allowWspLeft, bool allowWspRight);
    internal void WriteTagEnd();
    internal void WriteTagEnd(bool emptyScopeTag);
    internal void WriteAttribute(HtmlNameIndex nameIndex, string value);
    internal void WriteAttributeName(HtmlNameIndex nameIndex);
    internal void WriteAttributeValueInternal(string value);
    internal void WriteAttributeValueInternal(Char[] buffer, int index, int count);
    public void WriteMarkupText(string value);
    internal ITextSinkEx WriteUnstructuredTagContent();
    internal ITextSinkEx WriteTagName();
    internal ITextSinkEx WriteAttributeName();
    internal ITextSinkEx WriteAttributeValue();
    internal ITextSinkEx WriteText();
    internal void WriteNewLine();
    internal void WriteNewLine(bool optional);
    internal void WriteAutoNewLine();
    internal void WriteAutoNewLine(bool optional);
    internal void WriteCollapsedWhitespace();
    private void OutputLastWhitespace(char nextChar);
    private void OutputAttributeName(string name);
    private void OutputAttributeValue(string value);
    private void OutputAttributeValue(Char[] value, int index, int count);
    private void OutputAttributeEnd();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IRestartable.CanRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.Restart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.DisableRestart();
    private sealed virtual override Byte[] Microsoft.Exchange.Data.TextConverters.IFallback.GetUnsafeAsciiMap(Byte& unsafeAsciiMask);
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IFallback.HasUnsafeUnicode();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IFallback.TreatNonAsciiAsUnsafe(string charset);
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IFallback.IsUnsafeUnicode(char ch, bool isFirstChar);
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IFallback.FallBackChar(char ch, Char[] outputBuffer, Int32& outputBufferCount, int outputEnd);
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.ITextSink.get_IsEnough();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.ITextSink.Write(Char[] buffer, int offset, int count);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.ITextSink.Write(int ucs32Char);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.ITextSinkEx.Write(string text);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.ITextSinkEx.WriteNewLine();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
internal enum Microsoft.Exchange.Data.TextConverters.HtmlWriterState : Enum {
    public int value__;
    public static HtmlWriterState Default;
    public static HtmlWriterState Tag;
    public static HtmlWriterState Attribute;
}
internal interface Microsoft.Exchange.Data.TextConverters.IByteSource {
    public abstract virtual bool GetOutputChunk(Byte[]& chunkBuffer, Int32& chunkOffset, Int32& chunkLength);
    public abstract virtual void ReportOutput(int readCount);
}
internal interface Microsoft.Exchange.Data.TextConverters.IFallback {
    public abstract virtual Byte[] GetUnsafeAsciiMap(Byte& unsafeAsciiMask);
    public abstract virtual bool HasUnsafeUnicode();
    public abstract virtual bool TreatNonAsciiAsUnsafe(string charset);
    public abstract virtual bool IsUnsafeUnicode(char ch, bool isFirstChar);
    public abstract virtual bool FallBackChar(char ch, Char[] outputBuffer, Int32& outputBufferCount, int lineBufferEnd);
}
internal abstract class Microsoft.Exchange.Data.TextConverters.Injection : object {
    protected HeaderFooterFormat injectionFormat;
    protected string injectHead;
    protected string injectTail;
    protected bool headInjected;
    protected bool tailInjected;
    protected bool testBoundaryConditions;
    protected Stream traceStream;
    public HeaderFooterFormat HeaderFooterFormat { get; }
    public bool HaveHead { get; }
    public bool HaveTail { get; }
    public bool HeadDone { get; }
    public bool TailDone { get; }
    public HeaderFooterFormat get_HeaderFooterFormat();
    public bool get_HaveHead();
    public bool get_HaveTail();
    public bool get_HeadDone();
    public bool get_TailDone();
    public abstract virtual void Inject(bool head, TextOutput output);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Reset();
    public abstract virtual void InjectRtfFonts(int firstAvailableFontHandle);
    public abstract virtual void InjectRtfColors(int nextColorIndex);
}
internal static class Microsoft.Exchange.Data.TextConverters.Internal.Css.CssData : object {
    public static short MAX_NAME;
    public static short MAX_TAG_NAME;
    public static short NAME_HASH_SIZE;
    public static int NAME_HASH_MODIFIER;
    public static CssNameIndex[] nameHashTable;
    public static NameDef[] names;
    public static FilterActionEntry[] filterInstructions;
    private static CssData();
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Css.CssNameIndex : Enum {
    public byte value__;
    public static CssNameIndex Unknown;
    public static CssNameIndex ScrollbarArrowColor;
    public static CssNameIndex WhiteSpace;
    public static CssNameIndex LineBreak;
    public static CssNameIndex Orphans;
    public static CssNameIndex WritingMode;
    public static CssNameIndex Scrollbar3dLightColor;
    public static CssNameIndex TextAutospace;
    public static CssNameIndex VerticalAlign;
    public static CssNameIndex BorderRight;
    public static CssNameIndex Bottom;
    public static CssNameIndex FontFamily;
    public static CssNameIndex LineHeight;
    public static CssNameIndex BorderBottom;
    public static CssNameIndex ScrollbarBaseColor;
    public static CssNameIndex MinWidth;
    public static CssNameIndex BackgroundColor;
    public static CssNameIndex BorderTopStyle;
    public static CssNameIndex EmptyCells;
    public static CssNameIndex ListStyleType;
    public static CssNameIndex TextAlign;
    public static CssNameIndex FontWeight;
    public static CssNameIndex OutlineWidth;
    public static CssNameIndex CaptionSide;
    public static CssNameIndex ScrollbarShadowColor;
    public static CssNameIndex Clip;
    public static CssNameIndex Volume;
    public static CssNameIndex MarginLeft;
    public static CssNameIndex BorderTopWidth;
    public static CssNameIndex Azimuth;
    public static CssNameIndex UnicodeBidi;
    public static CssNameIndex Float;
    public static CssNameIndex LayoutFlow;
    public static CssNameIndex MinHeight;
    public static CssNameIndex Content;
    public static CssNameIndex Padding;
    public static CssNameIndex BorderBottomWidth;
    public static CssNameIndex Visibility;
    public static CssNameIndex Overflow;
    public static CssNameIndex TableLayout;
    public static CssNameIndex BorderLeftColor;
    public static CssNameIndex Pitch;
    public static CssNameIndex Pause;
    public static CssNameIndex OverflowY;
    public static CssNameIndex ScrollbarHighlightColor;
    public static CssNameIndex Height;
    public static CssNameIndex WordWrap;
    public static CssNameIndex Top;
    public static CssNameIndex ListStyle;
    public static CssNameIndex Margin;
    public static CssNameIndex TextKashidaSpace;
    public static CssNameIndex VoiceFamily;
    public static CssNameIndex CueBefore;
    public static CssNameIndex Clear;
    public static CssNameIndex TextOverflow;
    public static CssNameIndex BorderBottomStyle;
    public static CssNameIndex BorderColor;
    public static CssNameIndex TextDecoration;
    public static CssNameIndex Display;
    public static CssNameIndex CounterReset;
    public static CssNameIndex MarginBottom;
    public static CssNameIndex BorderStyle;
    public static CssNameIndex LayoutGrid;
    public static CssNameIndex Quotes;
    public static CssNameIndex Accelerator;
    public static CssNameIndex Border;
    public static CssNameIndex Zoom;
    public static CssNameIndex OutlineStyle;
    public static CssNameIndex Width;
    public static CssNameIndex Color;
    public static CssNameIndex PageBreakInside;
    public static CssNameIndex PitchRange;
    public static CssNameIndex BorderCollapse;
    public static CssNameIndex Speak;
    public static CssNameIndex Cue;
    public static CssNameIndex Left;
    public static CssNameIndex LayoutGridMode;
    public static CssNameIndex SpeakPunctuation;
    public static CssNameIndex LayoutGridLine;
    public static CssNameIndex BorderSpacing;
    public static CssNameIndex TextTransform;
    public static CssNameIndex BorderRightWidth;
    public static CssNameIndex PageBreakBefore;
    public static CssNameIndex TextIndent;
    public static CssNameIndex LayoutGridChar;
    public static CssNameIndex SpeechRate;
    public static CssNameIndex PauseBefore;
    public static CssNameIndex ScrollbarFaceColor;
    public static CssNameIndex PlayDuring;
    public static CssNameIndex WordBreak;
    public static CssNameIndex BorderBottomColor;
    public static CssNameIndex MarginRight;
    public static CssNameIndex SpeakNumeral;
    public static CssNameIndex TextJustify;
    public static CssNameIndex PaddingRight;
    public static CssNameIndex BorderRightStyle;
    public static CssNameIndex CounterIncrement;
    public static CssNameIndex TextUnderlinePosition;
    public static CssNameIndex WordSpacing;
    public static CssNameIndex Background;
    public static CssNameIndex OverflowX;
    public static CssNameIndex BorderWidth;
    public static CssNameIndex Widows;
    public static CssNameIndex ZIndex;
    public static CssNameIndex BorderTopColor;
    public static CssNameIndex MaxWidth;
    public static CssNameIndex ScrollbarDarkshadowColor;
    public static CssNameIndex CueAfter;
    public static CssNameIndex SpeakHeader;
    public static CssNameIndex Direction;
    public static CssNameIndex FontVariant;
    public static CssNameIndex Richness;
    public static CssNameIndex Stress;
    public static CssNameIndex Font;
    public static CssNameIndex Elevation;
    public static CssNameIndex Outline;
    public static CssNameIndex BorderRightColor;
    public static CssNameIndex FontStyle;
    public static CssNameIndex MarginTop;
    public static CssNameIndex BorderLeft;
    public static CssNameIndex ListStylePosition;
    public static CssNameIndex OutlineColor;
    public static CssNameIndex BorderLeftWidth;
    public static CssNameIndex PaddingBottom;
    public static CssNameIndex LayoutGridType;
    public static CssNameIndex PageBreakAfter;
    public static CssNameIndex FontSize;
    public static CssNameIndex Position;
    public static CssNameIndex BorderLeftStyle;
    public static CssNameIndex PaddingTop;
    public static CssNameIndex PaddingLeft;
    public static CssNameIndex Right;
    public static CssNameIndex PauseAfter;
    public static CssNameIndex MaxHeight;
    public static CssNameIndex LetterSpacing;
    public static CssNameIndex BorderTop;
    public static CssNameIndex Max;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Css.CssParseMode : Enum {
    public int value__;
    public static CssParseMode StyleAttribute;
    public static CssParseMode StyleTag;
    public static CssParseMode External;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Css.CssParser : object {
    internal static int MaxCssLength;
    private ConverterInput input;
    private bool endOfFile;
    private CssParseMode parseMode;
    private bool isInvalid;
    private Char[] parseBuffer;
    private int parseStart;
    private int parseCurrent;
    private int parseEnd;
    private int ruleDepth;
    protected CssTokenBuilder tokenBuilder;
    private CssToken token;
    private static String[] SafeTermFunctions;
    private static String[] SafePseudoFunctions;
    public CssToken Token { get; }
    public CssParser(ConverterInput input, int maxRuns, bool testBoundaryConditions);
    private static CssParser();
    public CssToken get_Token();
    private sealed virtual override void System.IDisposable.Dispose();
    public void Reset();
    public void SetParseMode(CssParseMode parseMode);
    public CssTokenId Parse();
    private char ScanStyleSheet(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanCdo(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanCdc(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanAtRule(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanPageSelector(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanRuleSet(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanDeclarationBlock(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanSelectors(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanSimpleSelector(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanSelectorSuffix(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanSelectorPseudo(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanSelectorAttrib(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanDeclarations(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanPropertyValue(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanExpr(char ch, CharClass& charClass, Int32& parseCurrent, int level);
    private char ScanTerm(char ch, CharClass& charClass, Int32& parseCurrent, int level);
    private char ScanNumeric(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanString(char ch, CharClass& charClass, Int32& parseCurrent, bool inProperty);
    private char ScanName(CssRunKind runKind, char ch, CharClass& charClass, Int32& parseCurrent, Int32& nameLength);
    private char ScanUrl(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanUnicodeRange(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanWhitespace(char ch, CharClass& charClass, Int32& parseCurrent, bool ignorable);
    private char ScanComment(char ch, CharClass& charClass, Int32& parseCurrent);
    private void PrepareAndAddRun(CssRunKind runKind, int start, Int32& parseCurrent);
    private void PrepareAndAddInvalidRun(CssRunKind runKind, Int32& parseCurrent);
    private void PrepareAndAddLiteralRun(CssRunKind runKind, int start, Int32& parseCurrent, int value);
    private char SkipToNextRule(char ch, CharClass& charClass, Int32& parseCurrent);
    private bool IsSafeIdentifier(String[] table, int start, int end);
    private bool IsNameEqual(string name, int start, int length);
    private bool IsNameCharacter(char ch, CharClass charClass, int parseCurrent);
    private bool IsNameStartCharacter(char ch, CharClass charClass, int parseCurrent);
    private static bool IsNameCharacterNoEscape(char ch, CharClass charClass);
    private static bool IsNameStartCharacterNoEscape(char ch, CharClass charClass);
    private bool IsUrlCharacter(char ch, CharClass charClass, int parseCurrent);
    private static bool IsUrlCharacterNoEscape(char ch, CharClass charClass);
    private bool IsEscape(char ch, int parseCurrent);
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Css.CssProperty : ValueType {
    private CssToken token;
    public bool IsPropertyBegin { get; }
    public bool IsPropertyNameEnd { get; }
    public bool IsDeleted { get; }
    public CssNameIndex NameId { get; }
    public bool HasNameFragment { get; }
    public PropertyNameTextReader Name { get; }
    public bool HasValueFragment { get; }
    public PropertyValueTextReader Value { get; }
    internal CssProperty(CssToken token);
    public bool get_IsPropertyBegin();
    public bool get_IsPropertyNameEnd();
    public bool get_IsDeleted();
    public CssNameIndex get_NameId();
    public bool get_HasNameFragment();
    public PropertyNameTextReader get_Name();
    public bool get_HasValueFragment();
    public PropertyValueTextReader get_Value();
    [ConditionalAttribute("DEBUG")]
private void AssertCurrent();
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Css.CssRunKind : Enum {
    public UInt32 value__;
    public static CssRunKind Invalid;
    public static CssRunKind Comment;
    public static CssRunKind Text;
    public static CssRunKind Space;
    public static CssRunKind SimpleSelector;
    public static CssRunKind Identifier;
    public static CssRunKind Delimiter;
    public static CssRunKind AtRuleName;
    public static CssRunKind SelectorName;
    public static CssRunKind SelectorCombinatorOrComma;
    public static CssRunKind SelectorPseudoStart;
    public static CssRunKind SelectorPseudo;
    public static CssRunKind SelectorPseudoArg;
    public static CssRunKind SelectorClassStart;
    public static CssRunKind SelectorClass;
    public static CssRunKind SelectorHashStart;
    public static CssRunKind SelectorHash;
    public static CssRunKind SelectorAttribStart;
    public static CssRunKind SelectorAttribName;
    public static CssRunKind SelectorAttribEquals;
    public static CssRunKind SelectorAttribIncludes;
    public static CssRunKind SelectorAttribDashmatch;
    public static CssRunKind SelectorAttribIdentifier;
    public static CssRunKind SelectorAttribString;
    public static CssRunKind SelectorAttribEnd;
    public static CssRunKind PropertyName;
    public static CssRunKind PropertyColon;
    public static CssRunKind ImportantStart;
    public static CssRunKind Important;
    public static CssRunKind Operator;
    public static CssRunKind UnaryOperator;
    public static CssRunKind Dot;
    public static CssRunKind Percent;
    public static CssRunKind Metrics;
    public static CssRunKind TermIdentifier;
    public static CssRunKind UnicodeRange;
    public static CssRunKind FunctionStart;
    public static CssRunKind FunctionEnd;
    public static CssRunKind HexColorStart;
    public static CssRunKind HexColor;
    public static CssRunKind String;
    public static CssRunKind Numeric;
    public static CssRunKind Url;
    public static CssRunKind PropertySemicolon;
    public static CssRunKind PageIdent;
    public static CssRunKind PagePseudoStart;
    public static CssRunKind PagePseudo;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Css.CssSelector : ValueType {
    private CssToken token;
    public bool IsDeleted { get; }
    public HtmlNameIndex NameId { get; }
    public bool HasNameFragment { get; }
    public SelectorNameTextReader Name { get; }
    public bool HasClassFragment { get; }
    public SelectorClassTextReader ClassName { get; }
    public CssSelectorClassType ClassType { get; }
    public bool IsSimple { get; }
    public CssSelectorCombinator Combinator { get; }
    internal CssSelector(CssToken token);
    public bool get_IsDeleted();
    public HtmlNameIndex get_NameId();
    public bool get_HasNameFragment();
    public SelectorNameTextReader get_Name();
    public bool get_HasClassFragment();
    public SelectorClassTextReader get_ClassName();
    public CssSelectorClassType get_ClassType();
    public bool get_IsSimple();
    public CssSelectorCombinator get_Combinator();
    [ConditionalAttribute("DEBUG")]
private void AssertCurrent();
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Css.CssSelectorClassType : Enum {
    public byte value__;
    public static CssSelectorClassType Regular;
    public static CssSelectorClassType Pseudo;
    public static CssSelectorClassType Hash;
    public static CssSelectorClassType Attrib;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Css.CssSelectorCombinator : Enum {
    public byte value__;
    public static CssSelectorCombinator None;
    public static CssSelectorCombinator Descendant;
    public static CssSelectorCombinator Adjacent;
    public static CssSelectorCombinator Child;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Css.CssToken : Token {
    protected internal PropertyListPartMajor partMajor;
    protected internal PropertyListPartMinor partMinor;
    protected internal PropertyEntry[] propertyList;
    protected internal int propertyHead;
    protected internal int propertyTail;
    protected internal int currentProperty;
    protected internal FragmentPosition propertyNamePosition;
    protected internal FragmentPosition propertyValuePosition;
    protected internal SelectorEntry[] selectorList;
    protected internal int selectorHead;
    protected internal int selectorTail;
    protected internal int currentSelector;
    protected internal FragmentPosition selectorNamePosition;
    protected internal FragmentPosition selectorClassPosition;
    public CssTokenId TokenId { get; }
    public bool IsPropertyListBegin { get; }
    public bool IsPropertyListEnd { get; }
    public PropertyEnumerator Properties { get; }
    public SelectorEnumerator Selectors { get; }
    public CssTokenId get_TokenId();
    public bool get_IsPropertyListBegin();
    public bool get_IsPropertyListEnd();
    public PropertyEnumerator get_Properties();
    public SelectorEnumerator get_Selectors();
    internal void Reset();
    protected internal void WriteEscapedOriginalTo(Fragment& fragment, ITextSink sink);
    private void EscapeAndWriteBuffer(Char[] buffer, int offset, int length, ITextSink sink);
    internal static bool AttemptUnescape(Char[] parseBuffer, int parseEnd, Char& ch, Int32& parseCurrent);
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Css.CssTokenBuilder : TokenBuilder {
    protected static byte BuildStateEndedCss;
    protected static byte BuildStatePropertyListStarted;
    protected static byte BuildStateBeforeSelector;
    protected static byte BuildStateSelectorName;
    protected static byte BuildStateEndSelectorName;
    protected static byte BuildStateSelectorClass;
    protected static byte BuildStateEndSelectorClass;
    protected static byte BuildStateBeforeProperty;
    protected static byte BuildStatePropertyName;
    protected static byte BuildStateEndPropertyName;
    protected static byte BuildStatePropertyValue;
    protected static byte BuildStateEndPropertyValue;
    protected CssToken cssToken;
    protected int maxProperties;
    protected int maxSelectors;
    public CssToken Token { get; }
    public bool Incomplete { get; }
    public CssTokenBuilder(Char[] buffer, int maxProperties, int maxSelectors, int maxRuns, bool testBoundaryConditions);
    public CssToken get_Token();
    public bool get_Incomplete();
    public virtual void Reset();
    public void StartRuleSet(int baseOffset, CssTokenId id);
    public void EndRuleSet();
    public void BuildUniversalSelector();
    public bool CanAddSelector();
    public void StartSelectorName();
    public void EndSelectorName(int nameLength);
    public void StartSelectorClass(CssSelectorClassType classType);
    public void EndSelectorClass();
    public void SetSelectorCombinator(CssSelectorCombinator combinator, bool previous);
    public void EndSimpleSelector();
    public void StartDeclarations(int baseOffset);
    public bool CanAddProperty();
    public void StartPropertyName();
    public void EndPropertyName(int nameLength);
    public void StartPropertyValue();
    public void EndPropertyValue();
    public void EndProperty();
    public void EndDeclarations();
    public bool PrepareAndAddRun(CssRunKind cssRunKind, int start, int end);
    public bool PrepareAndAddInvalidRun(CssRunKind cssRunKind, int end);
    public bool PrepareAndAddLiteralRun(CssRunKind cssRunKind, int start, int end, int value);
    public void InvalidateLastValidRun(CssRunKind kind);
    public void MarkPropertyAsDeleted();
    public CssNameIndex LookupName(int nameLength, Fragment fragment);
    public HtmlNameIndex LookupTagName(int nameLength, Fragment fragment);
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Css.CssTokenId : Enum {
    public byte value__;
    public static CssTokenId None;
    public static CssTokenId EndOfFile;
    public static CssTokenId AtRule;
    public static CssTokenId Declarations;
    public static CssTokenId RuleSet;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.Align : Enum {
    public int value__;
    public static Align Top;
    public static Align Middle;
    public static Align Center;
    public static Align Bottom;
    public static Align Left;
    public static Align Right;
    public static Align BaseLine;
    public static Align Justify;
    public static Align Sub;
    public static Align Super;
    public static Align TextTop;
    public static Align TextBottom;
    public static Align Char;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.BlockAlign : Enum {
    public int value__;
    public static BlockAlign Top;
    public static BlockAlign Middle;
    public static BlockAlign Bottom;
    public static BlockAlign Left;
    public static BlockAlign Right;
    public static BlockAlign Baseline;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.BlockHorizontalAlign : Enum {
    public int value__;
    public static BlockHorizontalAlign Left;
    public static BlockHorizontalAlign Center;
    public static BlockHorizontalAlign Right;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.BlockVerticalAlign : Enum {
    public int value__;
    public static BlockVerticalAlign Top;
    public static BlockVerticalAlign Middle;
    public static BlockVerticalAlign Bottom;
    public static BlockVerticalAlign Baseline;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.BorderStyle : Enum {
    public int value__;
    public static BorderStyle None;
    public static BorderStyle Hidden;
    public static BorderStyle Dotted;
    public static BorderStyle Dashed;
    public static BorderStyle Solid;
    public static BorderStyle Double;
    public static BorderStyle Groove;
    public static BorderStyle Ridge;
    public static BorderStyle Inset;
    public static BorderStyle Outset;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.Display : Enum {
    public int value__;
    public static Display None;
    public static Display Inline;
    public static Display Block;
    public static Display ListItem;
    public static Display RunIn;
    public static Display InlineBlock;
    public static Display Table;
    public static Display InlineTable;
    public static Display TableRowGroup;
    public static Display TableHeaderGroup;
    public static Display TableFooterGroup;
    public static Display TableRow;
    public static Display TableColumnGroup;
    public static Display TableColumn;
    public static Display TableCell;
    public static Display TableCaption;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Format.FlagProperties : ValueType {
    private static UInt32 AllDefinedBits;
    private static UInt32 AllValueBits;
    private static UInt32 ValueBit;
    private static UInt32 DefinedBit;
    private static UInt32 ValueAndDefinedBits;
    internal UInt32 bits;
    public static FlagProperties AllUndefined;
    public static FlagProperties AllOff;
    public static FlagProperties AllOn;
    public UInt32 Mask { get; }
    internal FlagProperties(UInt32 bits);
    private static FlagProperties();
    public static bool IsFlagProperty(PropertyId id);
    public bool IsDefined(PropertyId id);
    public bool IsOn(PropertyId id);
    public UInt32 get_Mask();
    public static FlagProperties Merge(FlagProperties baseFlags, FlagProperties overrideFlags);
    public static FlagProperties op_BitwiseAnd(FlagProperties x, FlagProperties y);
    public static FlagProperties op_BitwiseOr(FlagProperties x, FlagProperties y);
    public static FlagProperties op_ExclusiveOr(FlagProperties x, FlagProperties y);
    public static FlagProperties op_OnesComplement(FlagProperties x);
    public static bool op_Equality(FlagProperties x, FlagProperties y);
    public static bool op_Inequality(FlagProperties x, FlagProperties y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.LinkTarget : Enum {
    public int value__;
    public static LinkTarget Self;
    public static LinkTarget Top;
    public static LinkTarget Blank;
    public static LinkTarget Parent;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.ListStyle : Enum {
    public int value__;
    public static ListStyle None;
    public static ListStyle Bullet;
    public static ListStyle Decimal;
    public static ListStyle LowerAlpha;
    public static ListStyle UpperAlpha;
    public static ListStyle LowerRoman;
    public static ListStyle UpperRoman;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Format.Property : ValueType {
    private PropertyId id;
    private PropertyValue value;
    public static Property Null;
    private static Property();
    public virtual string ToString();
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Format.PropertyBitMask : ValueType {
    public static PropertyId FirstNonFlag;
    internal UInt32 bits1;
    internal UInt32 bits2;
    public static PropertyBitMask AllOff;
    public static PropertyBitMask AllOn;
    internal PropertyBitMask(UInt32 bits1, UInt32 bits2);
    private static PropertyBitMask();
    public bool IsSet(PropertyId id);
    public static PropertyBitMask op_BitwiseOr(PropertyBitMask x, PropertyBitMask y);
    public static PropertyBitMask op_BitwiseAnd(PropertyBitMask x, PropertyBitMask y);
    public static PropertyBitMask op_ExclusiveOr(PropertyBitMask x, PropertyBitMask y);
    public static PropertyBitMask op_OnesComplement(PropertyBitMask x);
    public static bool op_Equality(PropertyBitMask x, PropertyBitMask y);
    public static bool op_Inequality(PropertyBitMask x, PropertyBitMask y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.PropertyId : Enum {
    public byte value__;
    public static PropertyId Null;
    public static PropertyId FirstFlag;
    public static PropertyId Bold;
    public static PropertyId Italic;
    public static PropertyId Underline;
    public static PropertyId Subscript;
    public static PropertyId Superscript;
    public static PropertyId Strikethrough;
    public static PropertyId SmallCaps;
    public static PropertyId Capitalize;
    public static PropertyId RightToLeft;
    public static PropertyId Preformatted;
    public static PropertyId NoBreak;
    public static PropertyId Visible;
    public static PropertyId Overloaded1;
    public static PropertyId Overloaded2;
    public static PropertyId Overloaded3;
    public static PropertyId MergedCell;
    public static PropertyId TableLayoutFixed;
    public static PropertyId SelectMultiple;
    public static PropertyId OptionSelected;
    public static PropertyId ReadOnly;
    public static PropertyId TableBorderCollapse;
    public static PropertyId Disabled;
    public static PropertyId Checked;
    public static PropertyId LastFlag;
    public static PropertyId FontColor;
    public static PropertyId FontSize;
    public static PropertyId FontFace;
    public static PropertyId TextAlignment;
    public static PropertyId FirstLineIndent;
    public static PropertyId BlockAlignment;
    public static PropertyId HorizontalAlignment;
    public static PropertyId VerticalAlignment;
    public static PropertyId BackColor;
    public static PropertyId Display;
    public static PropertyId Language;
    public static PropertyId UnicodeBiDi;
    public static PropertyId Width;
    public static PropertyId Height;
    public static PropertyId Margins;
    public static PropertyId TopMargin;
    public static PropertyId RightMargin;
    public static PropertyId BottomMargin;
    public static PropertyId LeftMargin;
    public static PropertyId Paddings;
    public static PropertyId TopPadding;
    public static PropertyId RightPadding;
    public static PropertyId BottomPadding;
    public static PropertyId LeftPadding;
    public static PropertyId BorderWidths;
    public static PropertyId TopBorderWidth;
    public static PropertyId RightBorderWidth;
    public static PropertyId BottomBorderWidth;
    public static PropertyId LeftBorderWidth;
    public static PropertyId BorderStyles;
    public static PropertyId TopBorderStyle;
    public static PropertyId RightBorderStyle;
    public static PropertyId BottomBorderStyle;
    public static PropertyId LeftBorderStyle;
    public static PropertyId BorderColors;
    public static PropertyId TopBorderColor;
    public static PropertyId RightBorderColor;
    public static PropertyId BottomBorderColor;
    public static PropertyId LeftBorderColor;
    public static PropertyId ListLevel;
    public static PropertyId ListStyle;
    public static PropertyId ListStart;
    public static PropertyId NumColumns;
    public static PropertyId NumRows;
    public static PropertyId TableShowEmptyCells;
    public static PropertyId TableCaptionSideTop;
    public static PropertyId TableCellNoWrap;
    public static PropertyId TableBorderSpacingVertical;
    public static PropertyId TableBorderSpacingHorizontal;
    public static PropertyId TableBorder;
    public static PropertyId TableFrame;
    public static PropertyId TableRules;
    public static PropertyId TableCellSpacing;
    public static PropertyId TableCellPadding;
    public static PropertyId BookmarkName;
    public static PropertyId HyperlinkUrl;
    public static PropertyId HyperlinkTarget;
    public static PropertyId ImageUrl;
    public static PropertyId ImageAltText;
    public static PropertyId QuotingLevelDelta;
    public static PropertyId MaxValue;
    public static PropertyId ImageBorder;
    public static PropertyId IFrameUrl;
    public static PropertyId FormAction;
    public static PropertyId FormMethod;
    public static PropertyId FormEncodingType;
    public static PropertyId FormAcceptContentTypes;
    public static PropertyId FormAcceptCharsets;
    public static PropertyId Label;
    public static PropertyId OptionValue;
    public static PropertyId InputValue;
    public static PropertyId InputType;
    public static PropertyId InputSize;
    public static PropertyId InputMaxLength;
    public static PropertyId ButtonType;
    public static PropertyId Prompt;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Format.PropertyState : object {
    private static int MaxStackSize;
    private FlagProperties flagProperties;
    private FlagProperties distinctFlagProperties;
    private PropertyBitMask propertyMask;
    private PropertyBitMask distinctPropertyMask;
    public virtual string ToString();
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.PropertyType : Enum {
    public byte value__;
    public static PropertyType Null;
    public static PropertyType Calculated;
    public static PropertyType Bool;
    public static PropertyType String;
    public static PropertyType MultiValue;
    public static PropertyType Enum;
    public static PropertyType Color;
    public static PropertyType Integer;
    public static PropertyType Fractional;
    public static PropertyType Percentage;
    public static PropertyType AbsLength;
    public static PropertyType RelLength;
    public static PropertyType Pixels;
    public static PropertyType Ems;
    public static PropertyType Exs;
    public static PropertyType HtmlFontUnits;
    public static PropertyType RelHtmlFontUnits;
    public static PropertyType Multiple;
    public static PropertyType Milliseconds;
    public static PropertyType kHz;
    public static PropertyType Degrees;
    public static PropertyType FirstLength;
    public static PropertyType LastLength;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Format.PropertyValue : ValueType {
    private static UInt32 TypeMask;
    private static int TypeShift;
    private static UInt32 ValueMask;
    private static int ValueShift;
    public static int ValueMax;
    public static int ValueMin;
    private UInt32 rawValue;
    public static PropertyValue Null;
    public static PropertyValue True;
    public static PropertyValue False;
    internal static Int32[] sizesInTwips;
    internal static Int32[] maxSizesInTwips;
    public UInt32 RawType { get; }
    public PropertyType Type { get; }
    public int Value { get; }
    public UInt32 UnsignedValue { get; }
    public bool IsAbsRelLength { get; }
    public int StringHandle { get; }
    public int MultiValueHandle { get; }
    public bool Bool { get; }
    public int Enum { get; }
    public RGBT Color { get; }
    public float Percentage { get; }
    public float Fractional { get; }
    public int Integer { get; }
    public int Milliseconds { get; }
    public int kHz { get; }
    public int Degrees { get; }
    public float Points { get; }
    public float Inches { get; }
    public float Millimeters { get; }
    public int HtmlFontUnits { get; }
    public float Pixels { get; }
    public int PixelsInteger { get; }
    public float Ems { get; }
    public float Exs { get; }
    public int RelativeHtmlFontUnits { get; }
    public PropertyValue(bool value);
    public PropertyValue(PropertyType type, int value);
    private static PropertyValue();
    private static UInt32 ComposeRawValue(bool value);
    private static UInt32 ComposeRawValue(PropertyType type, int value);
    public UInt32 get_RawType();
    public static UInt32 GetRawType(PropertyType type);
    public PropertyType get_Type();
    public int get_Value();
    public UInt32 get_UnsignedValue();
    public bool get_IsAbsRelLength();
    public int get_StringHandle();
    public int get_MultiValueHandle();
    public bool get_Bool();
    public int get_Enum();
    public RGBT get_Color();
    public float get_Percentage();
    public float get_Fractional();
    public int get_Integer();
    public int get_Milliseconds();
    public int get_kHz();
    public int get_Degrees();
    public float get_Points();
    public float get_Inches();
    public float get_Millimeters();
    public int get_HtmlFontUnits();
    public float get_Pixels();
    public int get_PixelsInteger();
    public float get_Ems();
    public float get_Exs();
    public int get_RelativeHtmlFontUnits();
    public virtual string ToString();
    public static bool op_Equality(PropertyValue x, PropertyValue y);
    public static bool op_Inequality(PropertyValue x, PropertyValue y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Format.RGBT : ValueType {
    private UInt32 rawValue;
    public bool IsTransparent { get; }
    public UInt32 Transparency { get; }
    public UInt32 Red { get; }
    public UInt32 Green { get; }
    public UInt32 Blue { get; }
    public RGBT(UInt32 rawValue);
    public bool get_IsTransparent();
    public UInt32 get_Transparency();
    public UInt32 get_Red();
    public UInt32 get_Green();
    public UInt32 get_Blue();
    public virtual string ToString();
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.Side : Enum {
    public int value__;
    public static Side Top;
    public static Side Right;
    public static Side Bottom;
    public static Side Left;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.TextAlign : Enum {
    public int value__;
    public static TextAlign Left;
    public static TextAlign Center;
    public static TextAlign Right;
    public static TextAlign Justify;
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Format.UnicodeBiDi : Enum {
    public byte value__;
    public static UnicodeBiDi Normal;
    public static UnicodeBiDi Embed;
    public static UnicodeBiDi Override;
}
internal static class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlDtd : object {
    public static TagDefinition[] tags;
    public static Byte[] sets;
    private static HtmlDtd();
    public static bool IsTagInSet(HtmlTagIndex tag, SetId set);
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlEntityIndex : Enum {
    public ushort value__;
    public static HtmlEntityIndex omega;
    public static HtmlEntityIndex emsp;
    public static HtmlEntityIndex rle;
    public static HtmlEntityIndex Oacute;
    public static HtmlEntityIndex fnof;
    public static HtmlEntityIndex Oslash;
    public static HtmlEntityIndex Ntilde;
    public static HtmlEntityIndex larr;
    public static HtmlEntityIndex psi;
    public static HtmlEntityIndex QUOT;
    public static HtmlEntityIndex Pi;
    public static HtmlEntityIndex micro;
    public static HtmlEntityIndex piv;
    public static HtmlEntityIndex upsih;
    public static HtmlEntityIndex Xi;
    public static HtmlEntityIndex lceil;
    public static HtmlEntityIndex aring;
    public static HtmlEntityIndex ni;
    public static HtmlEntityIndex macr;
    public static HtmlEntityIndex cap;
    public static HtmlEntityIndex iuml;
    public static HtmlEntityIndex chi;
    public static HtmlEntityIndex frac14;
    public static HtmlEntityIndex frac34;
    public static HtmlEntityIndex ordm;
    public static HtmlEntityIndex nbsp;
    public static HtmlEntityIndex and;
    public static HtmlEntityIndex brvbar;
    public static HtmlEntityIndex zwsp;
    public static HtmlEntityIndex forall;
    public static HtmlEntityIndex pi;
    public static HtmlEntityIndex otimes;
    public static HtmlEntityIndex uacute;
    public static HtmlEntityIndex ang;
    public static HtmlEntityIndex iexcl;
    public static HtmlEntityIndex lrm;
    public static HtmlEntityIndex upsilon;
    public static HtmlEntityIndex xi;
    public static HtmlEntityIndex lre;
    public static HtmlEntityIndex zwj;
    public static HtmlEntityIndex Nu;
    public static HtmlEntityIndex Mu;
    public static HtmlEntityIndex lro;
    public static HtmlEntityIndex COPY;
    public static HtmlEntityIndex nsub;
    public static HtmlEntityIndex sub;
    public static HtmlEntityIndex thorn;
    public static HtmlEntityIndex sum;
    public static HtmlEntityIndex rsquo;
    public static HtmlEntityIndex middot;
    public static HtmlEntityIndex Ecirc;
    public static HtmlEntityIndex permil;
    public static HtmlEntityIndex thinsp;
    public static HtmlEntityIndex times;
    public static HtmlEntityIndex nu;
    public static HtmlEntityIndex mu;
    public static HtmlEntityIndex yen;
    public static HtmlEntityIndex prod;
    public static HtmlEntityIndex dArr;
    public static HtmlEntityIndex euml;
    public static HtmlEntityIndex acirc;
    public static HtmlEntityIndex Beta;
    public static HtmlEntityIndex radic;
    public static HtmlEntityIndex frac12;
    public static HtmlEntityIndex hearts;
    public static HtmlEntityIndex TRADE;
    public static HtmlEntityIndex rsaquo;
    public static HtmlEntityIndex Auml;
    public static HtmlEntityIndex ugrave;
    public static HtmlEntityIndex ccedil;
    public static HtmlEntityIndex OElig;
    public static HtmlEntityIndex sect;
    public static HtmlEntityIndex Eacute;
    public static HtmlEntityIndex there4;
    public static HtmlEntityIndex REG;
    public static HtmlEntityIndex plusmn;
    public static HtmlEntityIndex lang;
    public static HtmlEntityIndex thetasym;
    public static HtmlEntityIndex rArr;
    public static HtmlEntityIndex iota;
    public static HtmlEntityIndex rceil;
    public static HtmlEntityIndex empty;
    public static HtmlEntityIndex AMP;
    public static HtmlEntityIndex gt;
    public static HtmlEntityIndex Phi;
    public static HtmlEntityIndex Gamma;
    public static HtmlEntityIndex ass;
    public static HtmlEntityIndex lt;
    public static HtmlEntityIndex Zeta;
    public static HtmlEntityIndex Ograve;
    public static HtmlEntityIndex deg;
    public static HtmlEntityIndex spades;
    public static HtmlEntityIndex zwnj;
    public static HtmlEntityIndex exist;
    public static HtmlEntityIndex delta;
    public static HtmlEntityIndex reg;
    public static HtmlEntityIndex isin;
    public static HtmlEntityIndex Alpha;
    public static HtmlEntityIndex Yuml;
    public static HtmlEntityIndex cedil;
    public static HtmlEntityIndex sup2;
    public static HtmlEntityIndex rfloor;
    public static HtmlEntityIndex divide;
    public static HtmlEntityIndex Omicron;
    public static HtmlEntityIndex ordf;
    public static HtmlEntityIndex clubs;
    public static HtmlEntityIndex Uuml;
    public static HtmlEntityIndex Eta;
    public static HtmlEntityIndex Acirc;
    public static HtmlEntityIndex Atilde;
    public static HtmlEntityIndex Rho;
    public static HtmlEntityIndex alefsym;
    public static HtmlEntityIndex AElig;
    public static HtmlEntityIndex lfloor;
    public static HtmlEntityIndex hArr;
    public static HtmlEntityIndex oline;
    public static HtmlEntityIndex Aacute;
    public static HtmlEntityIndex Ccedil;
    public static HtmlEntityIndex theta;
    public static HtmlEntityIndex or;
    public static HtmlEntityIndex Egrave;
    public static HtmlEntityIndex trade;
    public static HtmlEntityIndex Int;
    public static HtmlEntityIndex sup1;
    public static HtmlEntityIndex phi;
    public static HtmlEntityIndex cup;
    public static HtmlEntityIndex equiv;
    public static HtmlEntityIndex sim;
    public static HtmlEntityIndex Yacute;
    public static HtmlEntityIndex Prime;
    public static HtmlEntityIndex uarr;
    public static HtmlEntityIndex mdash;
    public static HtmlEntityIndex amp;
    public static HtmlEntityIndex acute;
    public static HtmlEntityIndex ETH;
    public static HtmlEntityIndex eacute;
    public static HtmlEntityIndex weierp;
    public static HtmlEntityIndex Kappa;
    public static HtmlEntityIndex Theta;
    public static HtmlEntityIndex pound;
    public static HtmlEntityIndex rarr;
    public static HtmlEntityIndex Omega;
    public static HtmlEntityIndex oelig;
    public static HtmlEntityIndex sup;
    public static HtmlEntityIndex igrave;
    public static HtmlEntityIndex cent;
    public static HtmlEntityIndex agrave;
    public static HtmlEntityIndex dagger;
    public static HtmlEntityIndex bull;
    public static HtmlEntityIndex Ouml;
    public static HtmlEntityIndex Aring;
    public static HtmlEntityIndex loz;
    public static HtmlEntityIndex lowast;
    public static HtmlEntityIndex otilde;
    public static HtmlEntityIndex euro;
    public static HtmlEntityIndex uml;
    public static HtmlEntityIndex sigma;
    public static HtmlEntityIndex Epsilon;
    public static HtmlEntityIndex lsaquo;
    public static HtmlEntityIndex image;
    public static HtmlEntityIndex lArr;
    public static HtmlEntityIndex Iuml;
    public static HtmlEntityIndex Chi;
    public static HtmlEntityIndex eta;
    public static HtmlEntityIndex harr;
    public static HtmlEntityIndex aacute;
    public static HtmlEntityIndex nads;
    public static HtmlEntityIndex eth;
    public static HtmlEntityIndex GT;
    public static HtmlEntityIndex Sigma;
    public static HtmlEntityIndex THORN;
    public static HtmlEntityIndex oslash;
    public static HtmlEntityIndex aelig;
    public static HtmlEntityIndex LT;
    public static HtmlEntityIndex notin;
    public static HtmlEntityIndex aafs;
    public static HtmlEntityIndex yacute;
    public static HtmlEntityIndex laquo;
    public static HtmlEntityIndex prime;
    public static HtmlEntityIndex iss;
    public static HtmlEntityIndex Agrave;
    public static HtmlEntityIndex lambda;
    public static HtmlEntityIndex oplus;
    public static HtmlEntityIndex real;
    public static HtmlEntityIndex Ugrave;
    public static HtmlEntityIndex supe;
    public static HtmlEntityIndex para;
    public static HtmlEntityIndex darr;
    public static HtmlEntityIndex sube;
    public static HtmlEntityIndex asymp;
    public static HtmlEntityIndex Euml;
    public static HtmlEntityIndex ocirc;
    public static HtmlEntityIndex Lambda;
    public static HtmlEntityIndex beta;
    public static HtmlEntityIndex sup3;
    public static HtmlEntityIndex infin;
    public static HtmlEntityIndex Upsilon;
    public static HtmlEntityIndex ucirc;
    public static HtmlEntityIndex Delta;
    public static HtmlEntityIndex auml;
    public static HtmlEntityIndex Iacute;
    public static HtmlEntityIndex circ;
    public static HtmlEntityIndex Iota;
    public static HtmlEntityIndex tilde;
    public static HtmlEntityIndex bdquo;
    public static HtmlEntityIndex scaron;
    public static HtmlEntityIndex Tau;
    public static HtmlEntityIndex zeta;
    public static HtmlEntityIndex pdf;
    public static HtmlEntityIndex perp;
    public static HtmlEntityIndex shy;
    public static HtmlEntityIndex icirc;
    public static HtmlEntityIndex yuml;
    public static HtmlEntityIndex gamma;
    public static HtmlEntityIndex sigmaf;
    public static HtmlEntityIndex rang;
    public static HtmlEntityIndex crarr;
    public static HtmlEntityIndex raquo;
    public static HtmlEntityIndex minus;
    public static HtmlEntityIndex ograve;
    public static HtmlEntityIndex uuml;
    public static HtmlEntityIndex Ocirc;
    public static HtmlEntityIndex nods;
    public static HtmlEntityIndex ldquo;
    public static HtmlEntityIndex rho;
    public static HtmlEntityIndex szlig;
    public static HtmlEntityIndex Ucirc;
    public static HtmlEntityIndex alpha;
    public static HtmlEntityIndex quot;
    public static HtmlEntityIndex Dagger;
    public static HtmlEntityIndex Uacute;
    public static HtmlEntityIndex Igrave;
    public static HtmlEntityIndex Psi;
    public static HtmlEntityIndex tau;
    public static HtmlEntityIndex lsquo;
    public static HtmlEntityIndex ge;
    public static HtmlEntityIndex atilde;
    public static HtmlEntityIndex nabla;
    public static HtmlEntityIndex Scaron;
    public static HtmlEntityIndex cong;
    public static HtmlEntityIndex frasl;
    public static HtmlEntityIndex ne;
    public static HtmlEntityIndex curren;
    public static HtmlEntityIndex le;
    public static HtmlEntityIndex uArr;
    public static HtmlEntityIndex epsilon;
    public static HtmlEntityIndex iacute;
    public static HtmlEntityIndex rlm;
    public static HtmlEntityIndex Otilde;
    public static HtmlEntityIndex sdot;
    public static HtmlEntityIndex rlo;
    public static HtmlEntityIndex ndash;
    public static HtmlEntityIndex egrave;
    public static HtmlEntityIndex Icirc;
    public static HtmlEntityIndex oacute;
    public static HtmlEntityIndex part;
    public static HtmlEntityIndex diams;
    public static HtmlEntityIndex copy;
    public static HtmlEntityIndex ntilde;
    public static HtmlEntityIndex rdquo;
    public static HtmlEntityIndex iquest;
    public static HtmlEntityIndex sbquo;
    public static HtmlEntityIndex not;
    public static HtmlEntityIndex iafs;
    public static HtmlEntityIndex ouml;
    public static HtmlEntityIndex ecirc;
    public static HtmlEntityIndex kappa;
    public static HtmlEntityIndex ensp;
    public static HtmlEntityIndex prop;
    public static HtmlEntityIndex omicron;
    public static HtmlEntityIndex hellip;
}
internal static class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlFilterData : object {
    public static FilterActionEntry[] filterInstructions;
    public static FilterAttributeExceptionEntry[] filterExceptions;
    private static HtmlFilterData();
}
internal static class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlNameData : object {
    public static short MAX_NAME;
    public static short MAX_TAG_NAME;
    public static short MAX_ENTITY_NAME;
    public static short NAME_HASH_SIZE;
    public static int NAME_HASH_MODIFIER;
    public static short ENTITY_HASH_SIZE;
    public static int ENTITY_HASH_MODIFIER;
    public static HtmlNameIndex[] nameHashTable;
    public static HtmlEntityIndex[] entityHashTable;
    public static NameDef[] names;
    public static EntityDef[] entities;
    private static HtmlNameData();
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlNameIndex : Enum {
    public byte value__;
    public static HtmlNameIndex _NOTANAME;
    public static HtmlNameIndex _COMMENT;
    public static HtmlNameIndex _CONDITIONAL;
    public static HtmlNameIndex _BANG;
    public static HtmlNameIndex _ASP;
    public static HtmlNameIndex _DTD;
    public static HtmlNameIndex Unknown;
    public static HtmlNameIndex Nofill;
    public static HtmlNameIndex Comment;
    public static HtmlNameIndex LI;
    public static HtmlNameIndex Version;
    public static HtmlNameIndex CellSpacing;
    public static HtmlNameIndex Kbd;
    public static HtmlNameIndex Scheme;
    public static HtmlNameIndex Multiple;
    public static HtmlNameIndex Ruby;
    public static HtmlNameIndex Code;
    public static HtmlNameIndex NoResize;
    public static HtmlNameIndex Alt;
    public static HtmlNameIndex HrefLang;
    public static HtmlNameIndex FlushRight;
    public static HtmlNameIndex Accept;
    public static HtmlNameIndex FrameBorder;
    public static HtmlNameIndex Shape;
    public static HtmlNameIndex Param;
    public static HtmlNameIndex Acronym;
    public static HtmlNameIndex Bdo;
    public static HtmlNameIndex For;
    public static HtmlNameIndex Text;
    public static HtmlNameIndex Color;
    public static HtmlNameIndex A;
    public static HtmlNameIndex _Pxml;
    public static HtmlNameIndex Face;
    public static HtmlNameIndex RowSpan;
    public static HtmlNameIndex NoWrap;
    public static HtmlNameIndex Ins;
    public static HtmlNameIndex RP;
    public static HtmlNameIndex Script;
    public static HtmlNameIndex Char;
    public static HtmlNameIndex BGColor;
    public static HtmlNameIndex Style;
    public static HtmlNameIndex Width;
    public static HtmlNameIndex Headers;
    public static HtmlNameIndex Map;
    public static HtmlNameIndex Listing;
    public static HtmlNameIndex Data;
    public static HtmlNameIndex Sub;
    public static HtmlNameIndex H2;
    public static HtmlNameIndex Image;
    public static HtmlNameIndex StandBy;
    public static HtmlNameIndex Select;
    public static HtmlNameIndex Profile;
    public static HtmlNameIndex NoHref;
    public static HtmlNameIndex Button;
    public static HtmlNameIndex Meta;
    public static HtmlNameIndex Rules;
    public static HtmlNameIndex Class;
    public static HtmlNameIndex Src;
    public static HtmlNameIndex Legend;
    public static HtmlNameIndex Scrolling;
    public static HtmlNameIndex Vlink;
    public static HtmlNameIndex Del;
    public static HtmlNameIndex Hspace;
    public static HtmlNameIndex Charset;
    public static HtmlNameIndex RT;
    public static HtmlNameIndex Italic;
    public static HtmlNameIndex Div;
    public static HtmlNameIndex Dir;
    public static HtmlNameIndex TT;
    public static HtmlNameIndex LowSrc;
    public static HtmlNameIndex H6;
    public static HtmlNameIndex ValueType;
    public static HtmlNameIndex Declare;
    public static HtmlNameIndex Size;
    public static HtmlNameIndex FrameSet;
    public static HtmlNameIndex ReadOnly;
    public static HtmlNameIndex Language;
    public static HtmlNameIndex Area;
    public static HtmlNameIndex BlockQuote;
    public static HtmlNameIndex TopMargin;
    public static HtmlNameIndex NoEmbed;
    public static HtmlNameIndex BaseFont;
    public static HtmlNameIndex NoFrames;
    public static HtmlNameIndex Border;
    public static HtmlNameIndex Center;
    public static HtmlNameIndex Height;
    public static HtmlNameIndex Underline;
    public static HtmlNameIndex FlushBoth;
    public static HtmlNameIndex BGSound;
    public static HtmlNameIndex Var;
    public static HtmlNameIndex Start;
    public static HtmlNameIndex TD;
    public static HtmlNameIndex Id;
    public static HtmlNameIndex Rows;
    public static HtmlNameIndex H4;
    public static HtmlNameIndex Abbr;
    public static HtmlNameIndex HttpEquiv;
    public static HtmlNameIndex Span;
    public static HtmlNameIndex DD;
    public static HtmlNameIndex Address;
    public static HtmlNameIndex Applet;
    public static HtmlNameIndex Rel;
    public static HtmlNameIndex TextArea;
    public static HtmlNameIndex Tbody;
    public static HtmlNameIndex ParaIndent;
    public static HtmlNameIndex DT;
    public static HtmlNameIndex Checked;
    public static HtmlNameIndex NextId;
    public static HtmlNameIndex Head;
    public static HtmlNameIndex Rev;
    public static HtmlNameIndex Small;
    public static HtmlNameIndex Cite;
    public static HtmlNameIndex Cols;
    public static HtmlNameIndex LongDesc;
    public static HtmlNameIndex Sup;
    public static HtmlNameIndex Fixed;
    public static HtmlNameIndex Prompt;
    public static HtmlNameIndex Disabled;
    public static HtmlNameIndex Name;
    public static HtmlNameIndex Coords;
    public static HtmlNameIndex Summary;
    public static HtmlNameIndex Object;
    public static HtmlNameIndex Label;
    public static HtmlNameIndex Content;
    public static HtmlNameIndex Target;
    public static HtmlNameIndex EM;
    public static HtmlNameIndex Clear;
    public static HtmlNameIndex Scope;
    public static HtmlNameIndex Compact;
    public static HtmlNameIndex Blink;
    public static HtmlNameIndex Selected;
    public static HtmlNameIndex MaxLength;
    public static HtmlNameIndex Frame;
    public static HtmlNameIndex Thead;
    public static HtmlNameIndex TabIndex;
    public static HtmlNameIndex _Import;
    public static HtmlNameIndex Marquee;
    public static HtmlNameIndex Embed;
    public static HtmlNameIndex TH;
    public static HtmlNameIndex Caption;
    public static HtmlNameIndex Value;
    public static HtmlNameIndex Smaller;
    public static HtmlNameIndex DateTime;
    public static HtmlNameIndex ClassId;
    public static HtmlNameIndex Bold;
    public static HtmlNameIndex Strike;
    public static HtmlNameIndex FlushLeft;
    public static HtmlNameIndex NoShade;
    public static HtmlNameIndex LeftMargin;
    public static HtmlNameIndex Title;
    public static HtmlNameIndex Excerpt;
    public static HtmlNameIndex CellPadding;
    public static HtmlNameIndex Dfn;
    public static HtmlNameIndex CharOff;
    public static HtmlNameIndex IsIndex;
    public static HtmlNameIndex Tfoot;
    public static HtmlNameIndex NoBR;
    public static HtmlNameIndex Lang;
    public static HtmlNameIndex OptGroup;
    public static HtmlNameIndex AcceptCharset;
    public static HtmlNameIndex Option;
    public static HtmlNameIndex Big;
    public static HtmlNameIndex Font;
    public static HtmlNameIndex Type;
    public static HtmlNameIndex Href;
    public static HtmlNameIndex Img;
    public static HtmlNameIndex Vspace;
    public static HtmlNameIndex H3;
    public static HtmlNameIndex Align;
    public static HtmlNameIndex Wbr;
    public static HtmlNameIndex AccessKey;
    public static HtmlNameIndex Col;
    public static HtmlNameIndex Menu;
    public static HtmlNameIndex Bigger;
    public static HtmlNameIndex CodeBase;
    public static HtmlNameIndex Strong;
    public static HtmlNameIndex BR;
    public static HtmlNameIndex Archive;
    public static HtmlNameIndex UL;
    public static HtmlNameIndex NoScript;
    public static HtmlNameIndex PlainText;
    public static HtmlNameIndex Base;
    public static HtmlNameIndex IsMap;
    public static HtmlNameIndex Defer;
    public static HtmlNameIndex Body;
    public static HtmlNameIndex OL;
    public static HtmlNameIndex H1;
    public static HtmlNameIndex Valign;
    public static HtmlNameIndex Media;
    public static HtmlNameIndex Iframe;
    public static HtmlNameIndex DL;
    public static HtmlNameIndex ColSpan;
    public static HtmlNameIndex Axis;
    public static HtmlNameIndex MarginHeight;
    public static HtmlNameIndex Alink;
    public static HtmlNameIndex _Xml_Namespace;
    public static HtmlNameIndex Method;
    public static HtmlNameIndex FontFamily;
    public static HtmlNameIndex FieldSet;
    public static HtmlNameIndex Pre;
    public static HtmlNameIndex Table;
    public static HtmlNameIndex TR;
    public static HtmlNameIndex Samp;
    public static HtmlNameIndex Link;
    public static HtmlNameIndex HR;
    public static HtmlNameIndex Form;
    public static HtmlNameIndex Input;
    public static HtmlNameIndex Xml;
    public static HtmlNameIndex UseMap;
    public static HtmlNameIndex Xmp;
    public static HtmlNameIndex Html;
    public static HtmlNameIndex CodeType;
    public static HtmlNameIndex MarginWidth;
    public static HtmlNameIndex Q;
    public static HtmlNameIndex ColGroup;
    public static HtmlNameIndex DynSrc;
    public static HtmlNameIndex S;
    public static HtmlNameIndex P;
    public static HtmlNameIndex U;
    public static HtmlNameIndex Action;
    public static HtmlNameIndex EncType;
    public static HtmlNameIndex I;
    public static HtmlNameIndex B;
    public static HtmlNameIndex H5;
    public static HtmlNameIndex Background;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlNormalizingParser : object {
    private HtmlParser parser;
    private IRestartable restartConsumer;
    private int maxElementStack;
    private Context context;
    private Context[] contextStack;
    private int contextStackTop;
    private HtmlTagIndex[] elementStack;
    private int elementStackTop;
    private QueueItem[] queue;
    private int queueHead;
    private int queueTail;
    private int queueStart;
    private bool ensureHead;
    private Int32[] closeList;
    private HtmlTagIndex[] openList;
    private bool validRTC;
    private HtmlTagIndex tagIdRTC;
    private HtmlToken token;
    private HtmlToken inputToken;
    private bool ignoreInputTag;
    private int currentRun;
    private int currentRunOffset;
    private int numRuns;
    private bool allowWspLeft;
    private bool allowWspRight;
    private SmallTokenBuilder tokenBuilder;
    private HtmlInjection injection;
    private DocumentState saveState;
    public HtmlToken Token { get; }
    public HtmlNormalizingParser(HtmlParser parser, HtmlInjection injection, bool ensureHead, int maxNesting, bool testBoundaryConditions, Stream traceStream, bool traceShowTokenNum, int traceStopOnTokenNum);
    private void Reinitialize();
    public sealed virtual HtmlToken get_Token();
    public sealed virtual void SetRestartConsumer(IRestartable restartConsumer);
    public sealed virtual HtmlTokenId Parse();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IRestartable.CanRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.Restart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.DisableRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IReusable.Initialize(object newSourceOrDestination);
    public void Initialize(string fragment, bool preformatedText);
    private sealed virtual override void System.IDisposable.Dispose();
    private static TagDefinition GetTagDefinition(HtmlTagIndex tagIndex);
    private void Process(HtmlTokenId tokenId);
    private void HandleTokenEof();
    private void HandleTokenTag(HtmlToken tag);
    private void HandleTokenSpecialTag(HtmlToken tag);
    private void HandleTokenText(HtmlToken token);
    private void StartTagProcessing(HtmlTagIndex tagIndex, HtmlToken tag);
    private void StartSpecialTagProcessing(HtmlTagIndex tagIndex, HtmlToken tag);
    private void ProcessIgnoredTag(HtmlTagIndex tagIndex, HtmlToken tag);
    private bool ProcessOpenTag(HtmlTagIndex tagIndex, TagDefinition tagDef);
    private bool ProcessEndTag(HtmlTagIndex tagIndex, TagDefinition tagDef);
    private bool PrepareContainer(HtmlTagIndex tagIndex, TagDefinition tagDef);
    private int OpenContainer(HtmlTagIndex tagIndex);
    private void CloseContainer(int stackPos, bool useInputTag);
    private void CloseAllProhibitedContainers(TagDefinition tagDef);
    private void CloseAllContainers();
    private void CloseAllContainers(int level);
    private int FindContainer(SetId matchSet, SetId stopSet);
    private int FindContainer(HtmlTagIndex match, SetId stopSet);
    private HtmlTagIndex RequiredTextContainer();
    private int PushElement(HtmlTagIndex tagIndex, bool useInputTag, TagDefinition tagDef);
    private void PopElement(int stackPos, bool useInputTag);
    private void AddNonspace(char firstChar, char lastChar);
    private void AddSpace(bool oneNL);
    private bool QueryTextlike(HtmlTagIndex tagIndex);
    private void LFillTagB(TagDefinition tagDef);
    private void RFillTagB(TagDefinition tagDef);
    private void LFillTagE(TagDefinition tagDef);
    private void RFillTagE(TagDefinition tagDef);
    private void LFill(FillCode codeLeft, FillCode codeRight);
    private void RFill(FillCode code);
    private bool QueueEmpty();
    private QueueItemKind QueueHeadKind();
    private void EnqueueTail(QueueItemKind kind, HtmlTagIndex tagIndex, bool allowWspLeft, bool allowWspRight);
    private void EnqueueTail(QueueItemKind kind, int argument);
    private void EnqueueTail(QueueItemKind kind);
    private void EnqueueHead(QueueItemKind kind, HtmlTagIndex tagIndex, bool allowWspLeft, bool allowWspRight);
    private void EnqueueHead(QueueItemKind kind);
    private void EnqueueHead(QueueItemKind kind, int argument);
    private HtmlTokenId GetTokenFromQueue();
    private void ExpandQueue();
    private QueueItem DoDequeueFirst();
    private TagFill FillCodeFromTag(TagDefinition tagDef);
    private bool EnsureElementStackSpace();
    private void EnsureContextStackSpace();
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlParser : object {
    private static int ParseThresholdMax;
    private ConverterInput input;
    private bool endOfFile;
    private bool literalTags;
    private HtmlNameIndex literalTagNameId;
    private bool literalEntities;
    private bool plaintext;
    private bool parseConditionals;
    private ParseState parseState;
    private Char[] parseBuffer;
    private int parseStart;
    private int parseCurrent;
    private int parseEnd;
    private int parseThreshold;
    private bool slowParse;
    private char scanQuote;
    private char valueQuote;
    private CharClass lastCharClass;
    private int nameLength;
    private HtmlTokenBuilder tokenBuilder;
    private HtmlToken token;
    private IRestartable restartConsumer;
    private bool detectEncodingFromMetaTag;
    private Int16[] hashValuesTable;
    private bool rightMeta;
    private Encoding newEncoding;
    public HtmlToken Token { get; }
    public HtmlParser(ConverterInput input, bool detectEncodingFromMetaTag, bool preformatedText, int maxRuns, int maxAttrs, bool testBoundaryConditions);
    public sealed virtual HtmlToken get_Token();
    public sealed virtual void SetRestartConsumer(IRestartable restartConsumer);
    private void Reinitialize();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IRestartable.CanRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.Restart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.DisableRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IReusable.Initialize(object newSourceOrDestination);
    public void Initialize(string fragment, bool preformatedText);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual HtmlTokenId Parse();
    public HtmlTokenId ParseSlow();
    public bool ParseStateMachine(char ch, CharClass charClass, bool forceFlushToken);
    private static void ProcessNumericEntityValue(int entityValue, Int32& literal);
    private static bool FindEntityByHashName(short hash, Char[] buffer, int nameOffset, int nameLength, Int32& entityValue);
    private bool SkipInvalidCharacters(Char& ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanTagName(char ch, CharClass& charClass, Int32& parseCurrent, CharClass acceptCharClassSet);
    private char ScanAttrName(char ch, CharClass& charClass, Int32& parseCurrent, CharClass acceptCharClassSet);
    private char ScanWhitespace(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanText(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanAttrValue(char ch, CharClass& charClass, Int32& parseCurrent);
    private char ScanSkipTag(char ch, CharClass& charClass, Int32& parseCurrent);
    private bool ScanForInternalInvalidCharacters(int parseCurrent);
    private void ParseText(char ch, CharClass charClass, Int32& parseCurrent);
    private bool ParseAttributeText(char ch, CharClass charClass, Int32& parseCurrent);
    private void ParseWhitespace(char ch, CharClass charClass, Int32& parseCurrent);
    private bool CheckSuffix(int parseCurrent, char ch, Int32& addToTextCnt, Int32& tagSuffixCnt, Boolean& endScan);
    private bool DecodeEntity(int parseCurrent, bool inAttribute, Int32& literal, Int32& consume);
    private void HandleSpecialTag();
    private static string CharsetFromString(string arg, bool lookForWordCharset);
}
internal static class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlSupport : object {
    public static int HtmlNestingLimit;
    public static int MaxAttributeSize;
    public static int MaxCssPropertySize;
    public static int MaxNumberOfNonInlineStyles;
    public static Byte[] UnsafeAsciiMap;
    public static HtmlEntityIndex[] EntityMap;
    private static HtmlSupport();
    public static PropertyValue ParseNumber(BufferString value, NumberParseFlags parseFlags);
}
internal enum Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlTagIndex : Enum {
    public byte value__;
    public static HtmlTagIndex _NULL;
    public static HtmlTagIndex _ROOT;
    public static HtmlTagIndex _COMMENT;
    public static HtmlTagIndex _CONDITIONAL;
    public static HtmlTagIndex _BANG;
    public static HtmlTagIndex _DTD;
    public static HtmlTagIndex _ASP;
    public static HtmlTagIndex Unknown;
    public static HtmlTagIndex A;
    public static HtmlTagIndex Abbr;
    public static HtmlTagIndex Acronym;
    public static HtmlTagIndex Address;
    public static HtmlTagIndex Applet;
    public static HtmlTagIndex Area;
    public static HtmlTagIndex B;
    public static HtmlTagIndex Base;
    public static HtmlTagIndex BaseFont;
    public static HtmlTagIndex Bdo;
    public static HtmlTagIndex BGSound;
    public static HtmlTagIndex Big;
    public static HtmlTagIndex Blink;
    public static HtmlTagIndex BlockQuote;
    public static HtmlTagIndex Body;
    public static HtmlTagIndex BR;
    public static HtmlTagIndex Button;
    public static HtmlTagIndex Caption;
    public static HtmlTagIndex Center;
    public static HtmlTagIndex Cite;
    public static HtmlTagIndex Code;
    public static HtmlTagIndex Col;
    public static HtmlTagIndex ColGroup;
    public static HtmlTagIndex Comment;
    public static HtmlTagIndex DD;
    public static HtmlTagIndex Del;
    public static HtmlTagIndex Dfn;
    public static HtmlTagIndex Dir;
    public static HtmlTagIndex Div;
    public static HtmlTagIndex DL;
    public static HtmlTagIndex DT;
    public static HtmlTagIndex EM;
    public static HtmlTagIndex Embed;
    public static HtmlTagIndex FieldSet;
    public static HtmlTagIndex Font;
    public static HtmlTagIndex Form;
    public static HtmlTagIndex Frame;
    public static HtmlTagIndex FrameSet;
    public static HtmlTagIndex H1;
    public static HtmlTagIndex H2;
    public static HtmlTagIndex H3;
    public static HtmlTagIndex H4;
    public static HtmlTagIndex H5;
    public static HtmlTagIndex H6;
    public static HtmlTagIndex Head;
    public static HtmlTagIndex HR;
    public static HtmlTagIndex Html;
    public static HtmlTagIndex I;
    public static HtmlTagIndex Iframe;
    public static HtmlTagIndex Image;
    public static HtmlTagIndex Img;
    public static HtmlTagIndex Input;
    public static HtmlTagIndex Ins;
    public static HtmlTagIndex IsIndex;
    public static HtmlTagIndex Kbd;
    public static HtmlTagIndex Label;
    public static HtmlTagIndex Legend;
    public static HtmlTagIndex LI;
    public static HtmlTagIndex Link;
    public static HtmlTagIndex Listing;
    public static HtmlTagIndex Map;
    public static HtmlTagIndex Marquee;
    public static HtmlTagIndex Menu;
    public static HtmlTagIndex Meta;
    public static HtmlTagIndex NextId;
    public static HtmlTagIndex NoBR;
    public static HtmlTagIndex NoEmbed;
    public static HtmlTagIndex NoFrames;
    public static HtmlTagIndex NoScript;
    public static HtmlTagIndex Object;
    public static HtmlTagIndex OL;
    public static HtmlTagIndex OptGroup;
    public static HtmlTagIndex Option;
    public static HtmlTagIndex P;
    public static HtmlTagIndex Param;
    public static HtmlTagIndex PlainText;
    public static HtmlTagIndex Pre;
    public static HtmlTagIndex Q;
    public static HtmlTagIndex RP;
    public static HtmlTagIndex RT;
    public static HtmlTagIndex Ruby;
    public static HtmlTagIndex S;
    public static HtmlTagIndex Samp;
    public static HtmlTagIndex Script;
    public static HtmlTagIndex Select;
    public static HtmlTagIndex Small;
    public static HtmlTagIndex Span;
    public static HtmlTagIndex Strike;
    public static HtmlTagIndex Strong;
    public static HtmlTagIndex Style;
    public static HtmlTagIndex Sub;
    public static HtmlTagIndex Sup;
    public static HtmlTagIndex Table;
    public static HtmlTagIndex Tbody;
    public static HtmlTagIndex TC;
    public static HtmlTagIndex TD;
    public static HtmlTagIndex TextArea;
    public static HtmlTagIndex Tfoot;
    public static HtmlTagIndex TH;
    public static HtmlTagIndex Thead;
    public static HtmlTagIndex Title;
    public static HtmlTagIndex TR;
    public static HtmlTagIndex TT;
    public static HtmlTagIndex U;
    public static HtmlTagIndex UL;
    public static HtmlTagIndex Var;
    public static HtmlTagIndex Wbr;
    public static HtmlTagIndex Xmp;
    public static HtmlTagIndex Xml;
    public static HtmlTagIndex _Pxml;
    public static HtmlTagIndex _Import;
    public static HtmlTagIndex _Xml_Namespace;
    public static HtmlTagIndex _IMPLICIT_BEGIN;
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlToHtmlConverter : object {
    private bool convertFragment;
    private bool outputFragment;
    private bool filterForFragment;
    private bool filterHtml;
    private bool truncateForCallback;
    private int smallCssBlockThreshold;
    private bool preserveDisplayNoneStyle;
    private bool hasTailInjection;
    private IHtmlParser parser;
    private bool endOfFile;
    private bool normalizedInput;
    internal HtmlWriter writer;
    private HtmlTagCallback callback;
    private HtmlToHtmlTagContext callbackContext;
    internal HtmlToken token;
    private bool headDivUnterminated;
    private int currentLevel;
    private int currentLevelDelta;
    private bool insideCSS;
    private int dropLevel;
    private EndTagActionEntry[] endTagActionStack;
    private int endTagActionStackTop;
    private bool tagDropped;
    private bool justTruncated;
    private bool tagCallbackRequested;
    private bool attributeTriggeredCallback;
    private bool endTagCallbackRequested;
    private bool ignoreAttrCallback;
    private bool styleIsCSS;
    private FilterAction attrContinuationAction;
    private CopyPendingState copyPendingState;
    private HtmlTagIndex tagIndex;
    private int attributeCount;
    private int attributeSkipCount;
    private bool attributeIndirect;
    private AttributeIndirectEntry[] attributeIndirectIndex;
    private AttributeVirtualEntry[] attributeVirtualList;
    private int attributeVirtualCount;
    private ScratchBuffer attributeVirtualScratch;
    private ScratchBuffer attributeActionScratch;
    private bool attributeLeadingSpaces;
    private bool metaInjected;
    private bool insideHtml;
    private bool insideHead;
    private bool insideBody;
    private bool tagHasFilteredStyleAttribute;
    private CssParser cssParser;
    private ConverterBufferInput cssParserInput;
    private VirtualScratchSink virtualScratchSink;
    private IProgressMonitor progressMonitor;
    private static string NamePrefix;
    private static object lockObject;
    private static bool textConvertersConfigured;
    private static Dictionary`2<string, string> safeUrlDictionary;
    private static HtmlAttributeParts CompleteAttributeParts;
    private CopyPendingState CopyPendingStateFlag { get; private set; }
    public HtmlToHtmlConverter(IHtmlParser parser, HtmlWriter writer, bool convertFragment, bool outputFragment, bool filterHtml, HtmlTagCallback callback, bool truncateForCallback, bool hasTailInjection, Stream traceStream, bool traceShowTokenNum, int traceStopOnTokenNum, int smallCssBlockThreshold, bool preserveDisplayNoneStyle, IProgressMonitor progressMonitor);
    private static HtmlToHtmlConverter();
    private sealed virtual override void System.IDisposable.Dispose();
    private CopyPendingState get_CopyPendingStateFlag();
    private void set_CopyPendingStateFlag(CopyPendingState value);
    public sealed virtual void Run();
    public sealed virtual bool Flush();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IRestartable.CanRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.Restart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.DisableRestart();
    private void Process(HtmlTokenId tokenId);
    private void ProcessStartTag();
    private void ProcessEndTag();
    private void ProcessOverlappedClose();
    private void ProcessOverlappedReopen();
    private void ProcessText();
    private void ProcessInjectionBegin();
    private void ProcessInjectionEnd();
    private void ProcessEof();
    private void PreProcessStartTag();
    private void ProcessTagAttributes();
    private static int WhitespaceLength(Char[] buffer, int offset, int remainingLength);
    private static int NonWhitespaceLength(Char[] buffer, int offset, int remainingLength);
    private void PostProcessStartTag();
    private void PreProcessEndTag();
    internal void CopyInputTag(bool copyTagAttributes);
    private void CopyInputTagAttributes();
    internal void CopyInputAttribute(int index);
    internal void CopyInputAttributeName(int index);
    internal void CopyInputAttributeValue(int index);
    private static void ConfigureTextConverters();
    private static bool SafeUrlSchema(Char[] urlBuffer, int schemaLength);
    private static CheckUrlResult CheckUrl(Char[] urlBuffer, int urlLength, bool callbackRequested);
    private int AllocateVirtualEntry(int index, int offset, int length);
    private void VirtualizeFilteredStyle(int index);
    private bool InjectMetaTagIfNecessary();
    private void OutputMetaTag();
    private AttributeIndirectKind GetAttributeIndirectKind(int index);
    private int GetAttributeVirtualEntryIndex(int index);
    private HtmlAttribute GetAttribute(int index);
    internal HtmlAttributeId GetAttributeNameId(int index);
    internal HtmlAttributeParts GetAttributeParts(int index);
    internal string GetAttributeName(int index);
    internal string GetAttributeValue(int index);
    internal void WriteTag(bool copyTagAttributes);
    internal void WriteAttribute(int index, bool writeName, bool writeValue);
    private void AppendCssFromTokenText();
    private void AppendCss(string css);
    private void AppendCssFromAttribute(HtmlAttribute attribute);
    private void FlushCssInStyleTag();
    private void FlushCssInStyleAttributeToVirtualScratch();
    private void FlushCssInStyleAttribute(HtmlWriter writer);
    private bool CopyInputCssSelectors(SelectorEnumerator selectors, ITextSinkEx sink, bool agressiveFiltering);
    private bool CopyInputCssSelector(CssSelector selector, ITextSinkEx sink, bool agressiveFiltering);
    private void CopyInputCssProperties(bool inTag, PropertyEnumerator properties, ITextSinkEx sink, Boolean& firstProperty);
    private static void CopyInputCssProperty(CssProperty property, ITextSinkEx sink);
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlToHtmlTagContext : HtmlTagContext {
    private HtmlToHtmlConverter converter;
    public HtmlToHtmlTagContext(HtmlToHtmlConverter converter);
    internal virtual string GetTagNameImpl();
    internal virtual HtmlAttributeId GetAttributeNameIdImpl(int attributeIndex);
    internal virtual HtmlAttributeParts GetAttributePartsImpl(int attributeIndex);
    internal virtual string GetAttributeNameImpl(int attributeIndex);
    internal virtual string GetAttributeValueImpl(int attributeIndex);
    internal virtual void WriteTagImpl(bool copyTagAttributes);
    internal virtual void WriteAttributeImpl(int attributeIndex, bool writeName, bool writeValue);
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlTokenBuilder : TokenBuilder {
    protected static byte BuildStateEndedHtml;
    protected static byte BuildStateTagStarted;
    protected static byte BuildStateTagText;
    protected static byte BuildStateTagName;
    protected static byte BuildStateTagBeforeAttr;
    protected static byte BuildStateTagAttrName;
    protected static byte BuildStateTagEndAttrName;
    protected static byte BuildStateTagAttrValue;
    protected static byte BuildStateTagEndAttrValue;
    protected HtmlToken htmlToken;
    protected int maxAttrs;
    protected int numCarryOverRuns;
    protected int carryOverRunsHeadOffset;
    protected int carryOverRunsLength;
    public HtmlToken Token { get; }
    public bool IncompleteTag { get; }
    public HtmlTokenBuilder(Char[] buffer, int maxRuns, int maxAttrs, bool testBoundaryConditions);
    public HtmlToken get_Token();
    public bool get_IncompleteTag();
    public virtual void Reset();
    public HtmlTokenId MakeEmptyToken(HtmlTokenId tokenId);
    public HtmlTokenId MakeEmptyToken(HtmlTokenId tokenId, int argument);
    public void StartTag(HtmlNameIndex nameIndex, int baseOffset);
    public void AbortConditional(bool comment);
    public void SetEndTag();
    public void SetEmptyScope();
    public void StartTagText();
    public void EndTagText();
    public void StartTagName();
    public void EndTagNamePrefix();
    public void EndTagName(int nameLength);
    public bool CanAddAttribute();
    public void StartAttribute();
    public void EndAttributeNamePrefix();
    public void EndAttributeName(int nameLength);
    public void StartValue();
    public void SetValueQuote(char ch);
    public void EndValue();
    public void EndAttribute();
    public void EndTag(bool complete);
    public int RewindTag();
    public HtmlNameIndex LookupName(int nameLength, LexicalUnit unit);
    public bool PrepareToAddMoreRuns(int numRuns, int start, HtmlRunKind skippedRunKind);
    public void AddNullRun(HtmlRunKind kind);
    public void AddRun(RunTextType textType, HtmlRunKind kind, int start, int end);
    public void AddLiteralRun(RunTextType textType, HtmlRunKind kind, int start, int end, int literal);
    protected virtual void Rebase(int deltaOffset);
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Html.HtmlToTextConverter : object {
    private bool convertFragment;
    private IHtmlParser parser;
    private bool endOfFile;
    private TextOutput output;
    private HtmlToken token;
    private bool treatNbspAsBreakable;
    private bool outputImageLinks;
    private bool outputAnchorLinks;
    protected bool normalizedInput;
    private NormalizerContext normalizerContext;
    private TextMapping textMapping;
    private bool lineStarted;
    private bool wideGap;
    private bool nextParagraphCloseWideGap;
    private bool afterFirstParagraph;
    private bool ignoreNextP;
    private int listLevel;
    private int listIndex;
    private bool listOrdered;
    private bool insideComment;
    private bool insidePre;
    private bool insideAnchor;
    private ScratchBuffer urlScratch;
    private int imageHeightPixels;
    private int imageWidthPixels;
    private ScratchBuffer imageAltText;
    private ScratchBuffer scratch;
    private Injection injection;
    private UrlCompareSink urlCompareSink;
    public HtmlToTextConverter(IHtmlParser parser, TextOutput output, Injection injection, bool convertFragment, bool preformattedText, bool testTreatNbspAsBreakable, Stream traceStream, bool traceShowTokenNum, int traceStopOnTokenNum);
    private void Reinitialize();
    public sealed virtual void Run();
    public sealed virtual bool Flush();
    private void Process(HtmlTokenId tokenId);
    private void PushElement(TagDefinition tagDef);
    private void ProcessStartTagAttributes(TagDefinition tagDef);
    private void PopElement(TagDefinition tagDef);
    private void ProcessText();
    private void ProcessPreformatedText();
    private void NormalizeProcessText();
    private void NormalizeAddNonspace(TokenRun run);
    private void NormalizeAddNbsp(int count);
    private void NormalizeAddSpace(bool oneNL);
    private void LFillTagB(TagDefinition tagDef);
    private void RFillTagB(TagDefinition tagDef);
    private void LFillTagE(TagDefinition tagDef);
    private void RFillTagE(TagDefinition tagDef);
    private void LFill(FillCode codeLeft);
    private void RFill(FillCode code);
    private static TagDefinition GetTagDefinition(HtmlTagIndex tagIndex);
    private void EndAnchor();
    private void OutputText(string text);
    private void StartParagraphOrLine();
    private void EndLine();
    private void EndParagraph(bool wideGap);
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IRestartable.CanRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.Restart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.DisableRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IReusable.Initialize(object newSourceOrDestination);
    public void Initialize(string fragment, bool preformatedText);
}
internal interface Microsoft.Exchange.Data.TextConverters.Internal.Html.IHtmlParser {
    public HtmlToken Token { get; }
    public abstract virtual HtmlToken get_Token();
    public abstract virtual HtmlTokenId Parse();
    public abstract virtual void SetRestartConsumer(IRestartable restartConsumer);
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Text.ImageRenderingCallbackInternal : MulticastDelegate {
    public ImageRenderingCallbackInternal(object object, IntPtr method);
    public virtual bool Invoke(string attachmentUrl, int approximateRenderingPosition);
    public virtual IAsyncResult BeginInvoke(string attachmentUrl, int approximateRenderingPosition, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Exchange.Data.TextConverters.Internal.Text.TextOutput : object {
    private static Char[] Whitespaces;
    private ConverterOutput output;
    private bool lineWrapping;
    private bool rfc2646;
    private int longestNonWrappedParagraph;
    private int wrapBeforePosition;
    private bool preserveTrailingSpace;
    private bool preserveTabulation;
    private bool preserveNbsp;
    private int lineLength;
    private int lineLengthBeforeSoftWrap;
    private int flushedLength;
    private int tailSpace;
    private int breakOpportunity;
    private int nextBreakOpportunity;
    private int quotingLevel;
    private bool wrapped;
    private Char[] wrapBuffer;
    private bool signaturePossible;
    private bool anyNewlines;
    private bool endParagraph;
    private bool fallbacks;
    private bool htmlEscape;
    private string anchorUrl;
    private int linePosition;
    private ImageRenderingCallbackInternal imageRenderingCallback;
    unknown string AnchorUrl {internal set; }
    internal bool OutputCodePageSameAsInput { get; }
    unknown Encoding OutputEncoding {internal set; }
    internal bool ImageRenderingCallbackDefined { get; }
    public TextOutput(ConverterOutput output, bool lineWrapping, bool flowed, int wrapBeforePosition, int longestNonWrappedParagraph, ImageRenderingCallbackInternal imageRenderingCallback, bool fallbacks, bool htmlEscape, bool preserveSpace, Stream testTraceStream);
    private static TextOutput();
    internal void set_AnchorUrl(string value);
    internal bool get_OutputCodePageSameAsInput();
    internal void set_OutputEncoding(Encoding value);
    internal bool get_ImageRenderingCallbackDefined();
    private sealed virtual override Byte[] Microsoft.Exchange.Data.TextConverters.IFallback.GetUnsafeAsciiMap(Byte& unsafeAsciiMask);
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IFallback.HasUnsafeUnicode();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IFallback.TreatNonAsciiAsUnsafe(string charset);
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IFallback.IsUnsafeUnicode(char ch, bool isFirstChar);
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IFallback.FallBackChar(char ch, Char[] outputBuffer, Int32& outputBufferCount, int outputEnd);
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override bool Microsoft.Exchange.Data.TextConverters.IRestartable.CanRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.Restart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IRestartable.DisableRestart();
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IReusable.Initialize(object newSourceOrDestination);
    internal void CloseDocument();
    internal void OutputNewLine();
    internal void OutputTabulation(int count);
    internal void OutputSpace(int count);
    internal void OutputNbsp(int count);
    internal void OutputNonspace(Char[] buffer, int offset, int count, TextMapping textMapping);
    internal void OutputNonspace(string text, int offset, int length, TextMapping textMapping);
    internal void OutputNonspace(int ucs32Literal, TextMapping textMapping);
    internal void Flush();
    internal void OutputImage(string imageUrl, string imageAltText, int wdthPixels, int heightPixels);
    internal void OutputNonspace(string text, TextMapping textMapping);
    internal void CloseAnchor();
    internal void CancelAnchor();
    private int RenderingPosition();
    private void Reinitialize();
    private void OutputNonspaceImpl(Char[] buffer, int offset, int count, TextMapping textMapping);
    private int WrapBeforePosition();
    private int LongestNonWrappedParagraph();
    private void WrapPrepareToAppendNonspace(int count);
    private void FlushLine(char nextChar);
    private void FlushTailSpace();
    private void MapAndOutputSymbolCharacter(char ch, TextMapping textMapping);
}
internal abstract class Microsoft.Exchange.Data.TextConverters.Internal.TokenBuilder : object {
    protected static byte BuildStateInitialized;
    protected static byte BuildStateEnded;
    protected static byte FirstStarted;
    protected static byte BuildStateText;
    protected byte state;
    protected Token token;
    protected int maxRuns;
    protected int tailOffset;
    protected bool tokenValid;
    public Token Token { get; }
    public bool IsStarted { get; }
    public bool Valid { get; }
    public TokenBuilder(Token token, Char[] buffer, int maxRuns, bool testBoundaryConditions);
    public Token get_Token();
    public bool get_IsStarted();
    public bool get_Valid();
    public void BufferChanged(Char[] newBuffer, int newBase);
    public virtual void Reset();
    public TokenId MakeEmptyToken(TokenId tokenId);
    public TokenId MakeEmptyToken(TokenId tokenId, int argument);
    public void StartText(int baseOffset);
    public void EndText();
    public bool PrepareToAddMoreRuns(int numRuns, int start, UInt32 skippedRunKind);
    public bool SlowPrepareToAddMoreRuns(int numRuns, int start, UInt32 skippedRunKind);
    public bool PrepareToAddMoreRuns(int numRuns);
    [ConditionalAttribute("DEBUG")]
public void AssertPreparedToAddMoreRuns(int numRuns);
    [ConditionalAttribute("DEBUG")]
public void AssertCanAddMoreRuns(int numRuns);
    [ConditionalAttribute("DEBUG")]
public void AssertCurrentRunPosition(int position);
    [ConditionalAttribute("DEBUG")]
public void DebugPrepareToAddMoreRuns(int numRuns);
    public void AddTextRun(RunTextType textType, int start, int end);
    public void AddLiteralTextRun(RunTextType textType, int start, int end, int literal);
    internal void AddRun(RunType type, RunTextType textType, UInt32 kind, int start, int end, int value);
    internal void AddInvalidRun(int offset, UInt32 kind);
    internal void AddNullRun(UInt32 kind);
    internal void AddSentinelRun();
    protected virtual void Rebase(int deltaOffset);
    private bool ExpandRunsArray(int numRuns);
}
internal interface Microsoft.Exchange.Data.TextConverters.IProducerConsumer {
    public abstract virtual void Run();
    public abstract virtual bool Flush();
}
internal interface Microsoft.Exchange.Data.TextConverters.IProgressMonitor {
    public abstract virtual void ReportProgress();
}
internal interface Microsoft.Exchange.Data.TextConverters.IRestartable {
    public abstract virtual bool CanRestart();
    public abstract virtual void Restart();
    public abstract virtual void DisableRestart();
}
internal interface Microsoft.Exchange.Data.TextConverters.IResultsFeedback {
    public abstract virtual void Set(ConfigParameter parameterId, object val);
}
internal interface Microsoft.Exchange.Data.TextConverters.IReusable {
    public abstract virtual void Initialize(object newSourceOrDestination);
}
internal interface Microsoft.Exchange.Data.TextConverters.ITextSink {
    public bool IsEnough { get; }
    public abstract virtual bool get_IsEnough();
    public abstract virtual void Write(Char[] buffer, int offset, int count);
    public abstract virtual void Write(int ucs32Char);
}
internal interface Microsoft.Exchange.Data.TextConverters.ITextSinkEx {
    public abstract virtual void Write(string value);
    public abstract virtual void WriteNewLine();
}
internal static class Microsoft.Exchange.Data.TextConverters.ParseSupport : object {
    private static Char[] latin1MappingInUnicodeControlArea;
    private static Byte[] charToHexTable;
    private static CharClass[] lowCharClass;
    private static ParseSupport();
    public static int CharToDecimal(char ch);
    public static int CharToHex(char ch);
    public static char HighSurrogateCharFromUcs4(int ich);
    public static char LowSurrogateCharFromUcs4(int ich);
    public static bool IsCharClassOneOf(CharClass charClass, CharClass charClassSet);
    public static bool InvalidUnicodeCharacter(CharClass charClass);
    public static bool HtmlTextCharacter(CharClass charClass);
    public static bool WhitespaceCharacter(CharClass charClass);
    public static bool WhitespaceCharacter(char ch);
    public static bool NbspCharacter(CharClass charClass);
    public static bool AlphaCharacter(CharClass charClass);
    public static bool QuoteCharacter(CharClass charClass);
    public static bool HtmlAttrValueCharacter(CharClass charClass);
    public static bool HtmlScanQuoteSensitiveCharacter(CharClass charClass);
    public static bool HtmlSimpleTagNameCharacter(CharClass charClass);
    public static bool HtmlEndTagNameCharacter(CharClass charClass);
    public static bool HtmlSimpleAttrNameCharacter(CharClass charClass);
    public static bool HtmlEndAttrNameCharacter(CharClass charClass);
    public static bool HtmlSimpleAttrQuotedValueCharacter(CharClass charClass);
    public static bool HtmlSimpleAttrUnquotedValueCharacter(CharClass charClass);
    public static bool HtmlEndAttrUnquotedValueCharacter(CharClass charClass);
    public static bool NumericCharacter(CharClass charClass);
    public static bool HexCharacter(CharClass charClass);
    public static bool HtmlEntityCharacter(CharClass charClass);
    public static bool HtmlSuffixCharacter(CharClass charClass);
    public static CharClass GetCharClass(char ch);
    public static CharClass GetHighCharClass(char ch);
    public static bool IsUpperCase(char ch);
    public static char ToLowerCase(char ch);
    public static int Latin1MappingInUnicodeControlArea(int value);
    public static bool TwoFarEastNonHanguelChars(char ch1, char ch2);
    public static bool FarEastNonHanguelChar(char ch);
    private static bool HanguelRange(char ch);
}
internal class Microsoft.Exchange.Data.TextConverters.RecognizeInterestingFontName : ValueType {
    private static Byte[] CharMapToClass;
    private static SByte[0...,0...] StateTransitionTable;
    private sbyte state;
    public TextMapping TextMapping { get; }
    public bool IsRejected { get; }
    private static RecognizeInterestingFontName();
    public TextMapping get_TextMapping();
    public bool get_IsRejected();
    public void AddCharacter(char ch);
}
internal class Microsoft.Exchange.Data.TextConverters.RecognizeInterestingFontNameInInlineStyle : ValueType {
    private static Byte[] CharMapToClass;
    private static SByte[0...,0...] StateTransitionTable;
    private sbyte state;
    public TextMapping TextMapping { get; }
    public bool IsFinished { get; }
    private static RecognizeInterestingFontNameInInlineStyle();
    public TextMapping get_TextMapping();
    public bool get_IsFinished();
    public void AddCharacter(char ch);
}
internal enum Microsoft.Exchange.Data.TextConverters.RunKind : Enum {
    public UInt32 value__;
    public static RunKind Invalid;
    public static RunKind Text;
    public static RunKind StartLexicalUnitFlag;
    public static RunKind MajorKindMask;
    public static RunKind MajorKindMaskWithStartLexicalUnitFlag;
    public static RunKind MinorKindMask;
    public static RunKind KindMask;
}
internal enum Microsoft.Exchange.Data.TextConverters.RunTextType : Enum {
    public UInt32 value__;
    public static RunTextType Unknown;
    public static RunTextType Space;
    public static RunTextType NewLine;
    public static RunTextType Tabulation;
    public static RunTextType UnusualWhitespace;
    public static RunTextType LastWhitespace;
    public static RunTextType Nbsp;
    public static RunTextType NonSpace;
    public static RunTextType LastText;
    public static RunTextType Last;
    public static RunTextType Mask;
}
internal enum Microsoft.Exchange.Data.TextConverters.RunType : Enum {
    public UInt32 value__;
    public static RunType Invalid;
    public static RunType Special;
    public static RunType Normal;
    public static RunType Literal;
    public static RunType Mask;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Exchange.Data.TextConverters.ScratchBuffer : ValueType {
    private Char[] buffer;
    private int count;
    public Char[] Buffer { get; }
    public int Length { get; }
    public BufferString BufferString { get; }
    public char Item { get; public set; }
    public Char[] get_Buffer();
    public int get_Length();
    public BufferString get_BufferString();
    public char get_Item(int offset);
    public void set_Item(int offset, char value);
    public void Reset();
    public bool AppendHtmlAttributeValue(HtmlAttribute attr, int maxSize);
    public int Append(char ch, int maxSize);
    public int Append(string str, int maxSize);
    public int Append(Char[] buffer, int offset, int length, int maxSize);
    private int GetSpace(int maxSize);
}
internal class Microsoft.Exchange.Data.TextConverters.StringBuildSink : object {
    private StringBuilder sb;
    private int maxLength;
    public bool IsEnough { get; }
    public sealed virtual bool get_IsEnough();
    public void Reset(int maxLength);
    public sealed virtual void Write(Char[] buffer, int offset, int count);
    public sealed virtual void Write(int ucs32Char);
    public sealed virtual void Write(string value);
    public sealed virtual void WriteNewLine();
    public virtual string ToString();
}
internal class Microsoft.Exchange.Data.TextConverters.TextCache : object {
    private int cachedLength;
    private CacheEntry headEntry;
    private CacheEntry tailEntry;
    private CacheEntry freeList;
    public int Length { get; }
    public int get_Length();
    public void Reset();
    public void GetBuffer(int size, Char[]& buffer, Int32& offset, Int32& realSize);
    public void Commit(int count);
    public void GetData(Char[]& outputBuffer, Int32& outputOffset, Int32& outputCount);
    public void ReportRead(int count);
    public int Read(Char[] buffer, int offset, int count);
    private void AllocateTail(int size);
}
internal abstract class Microsoft.Exchange.Data.TextConverters.TextConverter : object {
    private bool testBoundaryConditions;
    private int inputBufferSize;
    private int outputBufferSize;
    [CompilerGeneratedAttribute]
private bool <Locked>k__BackingField;
    public int InputStreamBufferSize { get; }
    public int OutputStreamBufferSize { get; }
    internal bool TestBoundaryConditions { get; }
    protected bool Locked { get; protected set; }
    public int get_InputStreamBufferSize();
    public int get_OutputStreamBufferSize();
    internal bool get_TestBoundaryConditions();
    [CompilerGeneratedAttribute]
protected bool get_Locked();
    [CompilerGeneratedAttribute]
protected void set_Locked(bool value);
    public void Convert(TextReader sourceReader, Stream destinationStream);
    public void Convert(TextReader sourceReader, TextWriter destinationWriter);
    private sealed virtual override void Microsoft.Exchange.Data.TextConverters.IResultsFeedback.Set(ConfigParameter parameterId, object val);
    internal abstract virtual IProducerConsumer CreatePushChain(ConverterStream converterStream, Stream output);
    internal abstract virtual IProducerConsumer CreatePushChain(ConverterStream converterStream, TextWriter output);
    internal abstract virtual IProducerConsumer CreatePullChain(Stream input, ConverterStream converterStream);
    internal abstract virtual IProducerConsumer CreatePullChain(TextReader input, ConverterStream converterStream);
    internal abstract virtual IProducerConsumer CreatePullChain(Stream input, ConverterReader converterReader);
    internal abstract virtual IProducerConsumer CreatePullChain(TextReader input, ConverterReader converterReader);
    internal virtual void SetResult(ConfigParameter parameterId, object val);
    internal void AssertNotLocked();
}
internal class Microsoft.Exchange.Data.TextConverters.TextConvertersException : ExchangeDataException {
    internal TextConvertersException(string message);
    internal TextConvertersException(string message, Exception innerException);
}
internal enum Microsoft.Exchange.Data.TextConverters.TextMapping : Enum {
    public byte value__;
    public static TextMapping Unicode;
    public static TextMapping Symbol;
    public static TextMapping Wingdings;
    public static TextMapping OtherSymbol;
}
internal class Microsoft.Exchange.Data.TextConverters.Token : object {
    protected internal TokenId tokenId;
    protected internal int argument;
    protected internal Char[] buffer;
    protected internal RunEntry[] runList;
    protected internal Fragment whole;
    protected internal FragmentPosition wholePosition;
    private LowerCaseCompareSink compareSink;
    private LowerCaseSubstringSearchSink searchSink;
    private StringBuildSink stringBuildSink;
    public TokenId TokenId { get; }
    public int Argument { get; }
    public bool IsEmpty { get; }
    public RunEnumerator Runs { get; }
    public TextReader Text { get; }
    public bool IsWhitespaceOnly { get; }
    public TokenId get_TokenId();
    public int get_Argument();
    public bool get_IsEmpty();
    public RunEnumerator get_Runs();
    public TextReader get_Text();
    public bool get_IsWhitespaceOnly();
    protected internal bool IsWhitespaceOnlyImp(Fragment& fragment);
    internal static int LiteralLength(int literal);
    internal static char LiteralFirstChar(int literal);
    internal static char LiteralLastChar(int literal);
    protected internal int Read(LexicalUnit unit, FragmentPosition& position, Char[] buffer, int offset, int count);
    protected internal virtual void Rewind();
    protected internal int GetLength(Fragment& fragment);
    protected internal int GetLength(LexicalUnit unit);
    protected internal bool IsFragmentEmpty(Fragment& fragment);
    protected internal bool IsFragmentEmpty(LexicalUnit unit);
    protected internal bool IsContiguous(Fragment& fragment);
    protected internal bool IsContiguous(LexicalUnit unit);
    protected internal int CalculateHashLowerCase(Fragment fragment);
    protected internal int CalculateHashLowerCase(LexicalUnit unit);
    protected internal void WriteOriginalTo(Fragment& fragment, ITextSink sink);
    protected internal void WriteTo(Fragment& fragment, ITextSink sink);
    protected internal void WriteTo(LexicalUnit unit, ITextSink sink);
    protected internal string GetString(Fragment& fragment, int maxLength);
    protected internal string GetString(LexicalUnit unit, int maxLength);
    protected internal bool CaseInsensitiveCompareEqual(Fragment& fragment, string str);
    protected internal bool CaseInsensitiveCompareEqual(LexicalUnit unit, string str);
    protected internal virtual bool CaseInsensitiveCompareRunEqual(int runOffset, string str, int strOffset);
    protected internal bool CaseInsensitiveContainsSubstring(Fragment& fragment, string str);
    protected internal void StripLeadingWhitespace(Fragment& fragment);
    protected internal bool SkipLeadingWhitespace(LexicalUnit unit, FragmentPosition& position);
    protected internal bool MoveToNextRun(Fragment& fragment, FragmentPosition& position, bool skipInvalid);
    internal void SkipNonTextRuns(Int32& run, Int32& runOffset, int tail);
    internal void Reset();
}
internal enum Microsoft.Exchange.Data.TextConverters.TokenId : Enum {
    public byte value__;
    public static TokenId None;
    public static TokenId EndOfFile;
    public static TokenId Text;
    public static TokenId EncodingChange;
}
internal class Microsoft.Exchange.Data.TextConverters.TokenRun : ValueType {
    private Token token;
    public bool IsTextRun { get; }
    public bool IsNormal { get; }
    public bool IsLiteral { get; }
    public RunTextType TextType { get; }
    public Char[] RawBuffer { get; }
    public int RawOffset { get; }
    public int RawLength { get; }
    public int Literal { get; }
    public int Length { get; }
    public char FirstChar { get; }
    public char LastChar { get; }
    public bool IsAnyWhitespace { get; }
    internal TokenRun(Token token);
    public bool get_IsTextRun();
    public bool get_IsNormal();
    public bool get_IsLiteral();
    public RunTextType get_TextType();
    public Char[] get_RawBuffer();
    public int get_RawOffset();
    public int get_RawLength();
    public int get_Literal();
    public int get_Length();
    public char get_FirstChar();
    public char get_LastChar();
    public bool get_IsAnyWhitespace();
    [ConditionalAttribute("DEBUG")]
private void AssertCurrent();
}
internal class Microsoft.Exchange.Data.TextConverters.UrlCompareSink : object {
    private string url;
    private int urlPosition;
    public bool IsActive { get; }
    public bool IsMatch { get; }
    public bool IsEnough { get; }
    public void Initialize(string url);
    public void Reset();
    public bool get_IsActive();
    public bool get_IsMatch();
    public sealed virtual bool get_IsEnough();
    public sealed virtual void Write(Char[] buffer, int offset, int count);
    public sealed virtual void Write(int ucs32Char);
}
public static class Microsoft.Security.Application.Sanitizer : object {
    public static string GetSafeHtml(string input);
    public static string GetSafeHtmlFragment(string input);
    public static void GetSafeHtml(TextReader sourceReader, TextWriter destinationWriter);
    public static void GetSafeHtml(TextReader sourceReader, Stream destinationStream);
    public static void GetSafeHtmlFragment(TextReader sourceReader, TextWriter destinationWriter);
    public static void GetSafeHtmlFragment(TextReader sourceReader, Stream destinationStream);
}
internal class Microsoft.Security.Application.TextConverters.HTML.HtmlAttribute : ValueType {
    private HtmlToken token;
    public int Index { get; }
    public AttrPartMajor MajorPart { get; }
    public AttrPartMinor MinorPart { get; }
    public bool IsCompleteAttr { get; }
    public bool IsAttrBegin { get; }
    public bool IsAttrEnd { get; }
    public bool IsAttrNameEnd { get; }
    public bool IsDeleted { get; }
    public HtmlNameIndex NameIndex { get; }
    public bool HasNameFragment { get; }
    public AttributeNameTextReader Name { get; }
    public bool HasValueFragment { get; }
    public AttributeValueTextReader Value { get; }
    internal HtmlAttribute(HtmlToken token);
    public int get_Index();
    public AttrPartMajor get_MajorPart();
    public AttrPartMinor get_MinorPart();
    public bool get_IsCompleteAttr();
    public bool get_IsAttrBegin();
    public bool get_IsAttrEnd();
    public bool get_IsAttrNameEnd();
    public bool get_IsDeleted();
    public HtmlNameIndex get_NameIndex();
    public bool get_HasNameFragment();
    public AttributeNameTextReader get_Name();
    public bool get_HasValueFragment();
    public AttributeValueTextReader get_Value();
    public void SetMinorPart(AttrPartMinor newMinorPart);
    [ConditionalAttribute("DEBUG")]
private void AssertCurrent();
}
internal enum Microsoft.Security.Application.TextConverters.HTML.HtmlLexicalUnit : Enum {
    public UInt32 value__;
    public static HtmlLexicalUnit Invalid;
    public static HtmlLexicalUnit Text;
    public static HtmlLexicalUnit TagPrefix;
    public static HtmlLexicalUnit TagSuffix;
    public static HtmlLexicalUnit Name;
    public static HtmlLexicalUnit TagWhitespace;
    public static HtmlLexicalUnit AttrEqual;
    public static HtmlLexicalUnit AttrQuote;
    public static HtmlLexicalUnit AttrValue;
    public static HtmlLexicalUnit TagText;
}
internal enum Microsoft.Security.Application.TextConverters.HTML.HtmlRunKind : Enum {
    public UInt32 value__;
    public static HtmlRunKind Invalid;
    public static HtmlRunKind Text;
    public static HtmlRunKind TagPrefix;
    public static HtmlRunKind TagSuffix;
    public static HtmlRunKind Name;
    public static HtmlRunKind NamePrefixDelimiter;
    public static HtmlRunKind TagWhitespace;
    public static HtmlRunKind AttrEqual;
    public static HtmlRunKind AttrQuote;
    public static HtmlRunKind AttrValue;
    public static HtmlRunKind TagText;
}
internal class Microsoft.Security.Application.TextConverters.HTML.HtmlToken : Token {
    protected internal HtmlTagIndex tagIndex;
    protected internal HtmlTagIndex originalTagIndex;
    protected internal HtmlNameIndex nameIndex;
    protected internal TagFlags flags;
    protected internal TagPartMajor partMajor;
    protected internal TagPartMinor partMinor;
    protected internal LexicalUnit unstructured;
    protected internal FragmentPosition unstructuredPosition;
    protected internal LexicalUnit name;
    protected internal LexicalUnit localName;
    protected internal FragmentPosition namePosition;
    protected internal AttributeEntry[] attributeList;
    protected internal int attributeTail;
    protected internal int currentAttribute;
    protected internal FragmentPosition attrNamePosition;
    protected internal FragmentPosition attrValuePosition;
    public HtmlTokenId TokenId { get; }
    public TagFlags Flags { get; public set; }
    public bool IsEndTag { get; }
    public bool IsEmptyScope { get; }
    public TagPartMajor MajorPart { get; }
    public TagPartMinor MinorPart { get; }
    public bool IsTagBegin { get; }
    public bool IsTagEnd { get; }
    public bool IsTagNameBegin { get; }
    public bool IsTagNameEnd { get; }
    public bool HasNameFragment { get; }
    public HtmlNameIndex NameIndex { get; }
    public TagNameTextReader Name { get; }
    public TagUnstructuredContentTextReader UnstructuredContent { get; }
    public HtmlTagIndex TagIndex { get; }
    public HtmlTagIndex OriginalTagId { get; }
    public bool IsAllowWspLeft { get; }
    public bool IsAllowWspRight { get; }
    public AttributeEnumerator Attributes { get; }
    public HtmlTokenId get_TokenId();
    public TagFlags get_Flags();
    public void set_Flags(TagFlags value);
    public bool get_IsEndTag();
    public bool get_IsEmptyScope();
    public TagPartMajor get_MajorPart();
    public TagPartMinor get_MinorPart();
    public bool get_IsTagBegin();
    public bool get_IsTagEnd();
    public bool get_IsTagNameBegin();
    public bool get_IsTagNameEnd();
    public bool get_HasNameFragment();
    public HtmlNameIndex get_NameIndex();
    public TagNameTextReader get_Name();
    public TagUnstructuredContentTextReader get_UnstructuredContent();
    public HtmlTagIndex get_TagIndex();
    public HtmlTagIndex get_OriginalTagId();
    public bool get_IsAllowWspLeft();
    public bool get_IsAllowWspRight();
    public AttributeEnumerator get_Attributes();
    internal void Reset();
}
internal enum Microsoft.Security.Application.TextConverters.HTML.HtmlTokenId : Enum {
    public byte value__;
    public static HtmlTokenId None;
    public static HtmlTokenId EndOfFile;
    public static HtmlTokenId Text;
    public static HtmlTokenId EncodingChange;
    public static HtmlTokenId Tag;
    public static HtmlTokenId Restart;
    public static HtmlTokenId OverlappedClose;
    public static HtmlTokenId OverlappedReopen;
    public static HtmlTokenId InjectionBegin;
    public static HtmlTokenId InjectionEnd;
}
