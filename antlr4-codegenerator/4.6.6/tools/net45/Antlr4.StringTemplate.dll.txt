public class Antlr4.StringTemplate.AutoIndentWriter : object {
    public static int NoWrap;
    private ListStack`1<string> _indents;
    private Stack`1<int> _anchors;
    private string _newline;
    private TextWriter _writer;
    private int _charPosition;
    private int _charIndex;
    private int _lineWidth;
    public int Index { get; protected set; }
    public int LineWidth { get; public set; }
    protected bool AtStartOfLine { get; }
    protected TextWriter Writer { get; protected set; }
    public AutoIndentWriter(TextWriter writer);
    public AutoIndentWriter(TextWriter writer, string newline);
    public sealed virtual int get_Index();
    protected void set_Index(int value);
    public sealed virtual int get_LineWidth();
    public sealed virtual void set_LineWidth(int value);
    protected bool get_AtStartOfLine();
    protected TextWriter get_Writer();
    protected void set_Writer(TextWriter value);
    public virtual void PushIndentation(string indent);
    public virtual string PopIndentation();
    public virtual void PushAnchorPoint();
    public virtual void PopAnchorPoint();
    public virtual int Write(string value);
    public virtual int WriteSeparator(string value);
    public virtual int Write(string value, string wrap);
    public virtual int WriteWrap(string wrap);
    protected virtual int Indent();
}
public enum Antlr4.StringTemplate.Compiler.Bytecode : Enum {
    public byte value__;
    public static Bytecode Invalid;
    public static Bytecode INSTR_LOAD_STR;
    public static Bytecode INSTR_LOAD_ATTR;
    public static Bytecode INSTR_LOAD_LOCAL;
    public static Bytecode INSTR_LOAD_PROP;
    public static Bytecode INSTR_LOAD_PROP_IND;
    public static Bytecode INSTR_STORE_OPTION;
    public static Bytecode INSTR_STORE_ARG;
    public static Bytecode INSTR_NEW;
    public static Bytecode INSTR_NEW_IND;
    public static Bytecode INSTR_NEW_BOX_ARGS;
    public static Bytecode INSTR_SUPER_NEW;
    public static Bytecode INSTR_SUPER_NEW_BOX_ARGS;
    public static Bytecode INSTR_WRITE;
    public static Bytecode INSTR_WRITE_OPT;
    public static Bytecode INSTR_MAP;
    public static Bytecode INSTR_ROT_MAP;
    public static Bytecode INSTR_ZIP_MAP;
    public static Bytecode INSTR_BR;
    public static Bytecode INSTR_BRF;
    public static Bytecode INSTR_OPTIONS;
    public static Bytecode INSTR_ARGS;
    public static Bytecode INSTR_PASSTHRU;
    public static Bytecode INSTR_LIST;
    public static Bytecode INSTR_ADD;
    public static Bytecode INSTR_TOSTR;
    public static Bytecode INSTR_FIRST;
    public static Bytecode INSTR_LAST;
    public static Bytecode INSTR_REST;
    public static Bytecode INSTR_TRUNC;
    public static Bytecode INSTR_STRIP;
    public static Bytecode INSTR_TRIM;
    public static Bytecode INSTR_LENGTH;
    public static Bytecode INSTR_STRLEN;
    public static Bytecode INSTR_REVERSE;
    public static Bytecode INSTR_NOT;
    public static Bytecode INSTR_OR;
    public static Bytecode INSTR_AND;
    public static Bytecode INSTR_INDENT;
    public static Bytecode INSTR_DEDENT;
    public static Bytecode INSTR_NEWLINE;
    public static Bytecode INSTR_NOOP;
    public static Bytecode INSTR_POP;
    public static Bytecode INSTR_NULL;
    public static Bytecode INSTR_TRUE;
    public static Bytecode INSTR_FALSE;
    public static Bytecode INSTR_WRITE_STR;
    public static Bytecode INSTR_WRITE_LOCAL;
}
public class Antlr4.StringTemplate.Compiler.BytecodeDisassembler : object {
    private CompiledTemplate code;
    public BytecodeDisassembler(CompiledTemplate code);
    public virtual string GetInstructions();
    public virtual string Disassemble();
    public virtual int DisassembleInstruction(StringBuilder buf, int ip);
    private string ShowConstantPoolOperand(int poolIndex);
    internal static int GetShort(Byte[] memory, int index);
    public virtual string GetStrings();
    public virtual string GetSourceMap();
}
[GeneratedCodeAttribute("ANTLR", "3.5.2-beta2")]
[CLSCompliantAttribute("False")]
public class Antlr4.StringTemplate.Compiler.CodeGenerator : TreeParser {
    private string outermostTemplateName;
    private IToken templateToken;
    private string _template;
    private TemplateCompiler _compiler;
    private CompiledTemplate outermostImpl;
    internal static String[] tokenNames;
    public static int EOF;
    public static int IF;
    public static int ELSE;
    public static int ELSEIF;
    public static int ENDIF;
    public static int SUPER;
    public static int SEMI;
    public static int BANG;
    public static int ELLIPSIS;
    public static int EQUALS;
    public static int COLON;
    public static int LPAREN;
    public static int RPAREN;
    public static int LBRACK;
    public static int RBRACK;
    public static int COMMA;
    public static int DOT;
    public static int LCURLY;
    public static int RCURLY;
    public static int TEXT;
    public static int LDELIM;
    public static int RDELIM;
    public static int ID;
    public static int STRING;
    public static int WS;
    public static int PIPE;
    public static int OR;
    public static int AND;
    public static int INDENT;
    public static int NEWLINE;
    public static int AT;
    public static int END;
    public static int TRUE;
    public static int FALSE;
    public static int COMMENT;
    public static int ARGS;
    public static int ELEMENTS;
    public static int EXEC_FUNC;
    public static int EXPR;
    public static int INCLUDE;
    public static int INCLUDE_IND;
    public static int INCLUDE_REGION;
    public static int INCLUDE_SUPER;
    public static int INCLUDE_SUPER_REGION;
    public static int LIST;
    public static int MAP;
    public static int NULL;
    public static int OPTIONS;
    public static int PROP;
    public static int PROP_IND;
    public static int REGION;
    public static int SUBTEMPLATE;
    public static int TO_STR;
    public static int ZIP;
    protected ListStack`1<template_scope> template_stack;
    public ErrorManager errMgr { get; }
    public TemplateGroup Group { get; }
    public CompilationState CompilationState { get; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public CodeGenerator(ITreeNodeStream input, TemplateCompiler compiler, string name, string template, IToken templateToken);
    private CodeGenerator(ITreeNodeStream input);
    private CodeGenerator(ITreeNodeStream input, RecognizerSharedState state);
    private static CodeGenerator();
    public ErrorManager get_errMgr();
    public TemplateGroup get_Group();
    public CompilationState get_CompilationState();
    public void emit1(CommonTree opAST, Bytecode opcode, int arg);
    public void emit1(CommonTree opAST, Bytecode opcode, string arg);
    public void emit2(CommonTree opAST, Bytecode opcode, int arg, int arg2);
    public void emit2(CommonTree opAST, Bytecode opcode, string s, int arg2);
    public void emit(CommonTree opAST, Bytecode opcode);
    private void Indent(CommonTree indent);
    private void Dedent();
    public void insert(int addr, Bytecode opcode, string s);
    public void setOption(CommonTree id);
    public void write(int addr, short value);
    public int address();
    public void func(CommonTree id);
    public void refAttr(CommonTree id);
    public int defineString(string s);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("templateAndEOF")]
private void templateAndEOF();
    [GrammarRuleAttribute("template")]
public CompiledTemplate template(string name, List`1<FormalArgument> args);
    [GrammarRuleAttribute("chunk")]
private void chunk();
    [GrammarRuleAttribute("element")]
private void element();
    [GrammarRuleAttribute("singleElement")]
private void singleElement();
    [GrammarRuleAttribute("compoundElement")]
private void compoundElement(CommonTree indent);
    [GrammarRuleAttribute("exprElement")]
private void exprElement();
    [GrammarRuleAttribute("region")]
private region_return region(CommonTree indent);
    [GrammarRuleAttribute("subtemplate")]
private subtemplate_return subtemplate();
    [GrammarRuleAttribute("ifstat")]
private void ifstat(CommonTree indent);
    [GrammarRuleAttribute("conditional")]
private TreeRuleReturnScope`1<CommonTree> conditional();
    [GrammarRuleAttribute("exprOptions")]
private TreeRuleReturnScope`1<CommonTree> exprOptions();
    [GrammarRuleAttribute("option")]
private void option();
    [GrammarRuleAttribute("expr")]
private void expr();
    [GrammarRuleAttribute("prop")]
private void prop();
    [GrammarRuleAttribute("mapTemplateRef")]
private TreeRuleReturnScope`1<CommonTree> mapTemplateRef(int num_exprs);
    [GrammarRuleAttribute("includeExpr")]
private TreeRuleReturnScope`1<CommonTree> includeExpr();
    [GrammarRuleAttribute("primary")]
private TreeRuleReturnScope`1<CommonTree> primary();
    [GrammarRuleAttribute("arg")]
private void arg();
    [GrammarRuleAttribute("args")]
private args_return args();
    [GrammarRuleAttribute("list")]
private TreeRuleReturnScope`1<CommonTree> list();
    [GrammarRuleAttribute("listElement")]
private TreeRuleReturnScope`1<CommonTree> listElement();
}
public class Antlr4.StringTemplate.Compiler.CompilationState : object {
    internal CompiledTemplate impl;
    internal StringTable stringtable;
    internal int ip;
    internal ITokenStream tokens;
    internal ErrorManager errMgr;
    public CompilationState(ErrorManager errMgr, string name, ITokenStream tokens);
    public virtual int DefineString(string s);
    public virtual void ReferenceAttribute(IToken templateToken, CommonTree id);
    public virtual void SetOption(CommonTree id);
    public virtual void Function(IToken templateToken, CommonTree id);
    public virtual void Emit(Bytecode opcode);
    public virtual void Emit(CommonTree opAST, Bytecode opcode);
    public virtual void Emit1(CommonTree opAST, Bytecode opcode, int arg);
    public virtual void Emit2(CommonTree opAST, Bytecode opcode, int arg, int arg2);
    public virtual void Emit2(CommonTree opAST, Bytecode opcode, string s, int arg2);
    public virtual void Emit1(CommonTree opAST, Bytecode opcode, string s);
    public virtual void Insert(int addr, Bytecode opcode, string s);
    public virtual void Write(int addr, short value);
    protected virtual void EnsureCapacity(int n);
    public virtual void Indent(CommonTree indent);
    public static void WriteShort(Byte[] memory, int index, short value);
}
public class Antlr4.StringTemplate.Compiler.CompiledTemplate : object {
    private static ReadOnlyCollection`1<CompiledTemplate> EmptyImplicitlyDefinedTemplates;
    private string _name;
    private string _prefix;
    private string _template;
    private IToken _templateDefStartToken;
    private ITokenStream _tokens;
    private CommonTree _ast;
    private List`1<FormalArgument> _formalArguments;
    private bool _hasFormalArgs;
    private List`1<CompiledTemplate> implicitlyDefinedTemplates;
    private int _numberOfArgsWithDefaultValues;
    private TemplateGroup _nativeGroup;
    private bool isRegion;
    private RegionType regionDefType;
    private bool isAnonSubtemplate;
    public String[] strings;
    public Byte[] instrs;
    public int codeSize;
    public Interval[] sourceMap;
    public string Name { get; public set; }
    public string Prefix { get; public set; }
    public string Template { get; public set; }
    public IToken TemplateDefStartToken { get; public set; }
    public ITokenStream Tokens { get; public set; }
    public CommonTree Ast { get; public set; }
    public List`1<FormalArgument> FormalArguments { get; public set; }
    public bool HasFormalArgs { get; public set; }
    public ReadOnlyCollection`1<CompiledTemplate> ImplicitlyDefinedTemplates { get; }
    public TemplateGroup NativeGroup { get; public set; }
    public bool IsRegion { get; public set; }
    public RegionType RegionDefType { get; public set; }
    public bool IsAnonSubtemplate { get; public set; }
    public string TemplateSource { get; }
    public Interval TemplateRange { get; }
    public int NumberOfArgsWithDefaultValues { get; }
    private static CompiledTemplate();
    public string get_Name();
    public void set_Name(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public string get_Template();
    public void set_Template(string value);
    public IToken get_TemplateDefStartToken();
    public void set_TemplateDefStartToken(IToken value);
    public ITokenStream get_Tokens();
    public void set_Tokens(ITokenStream value);
    public CommonTree get_Ast();
    public void set_Ast(CommonTree value);
    public List`1<FormalArgument> get_FormalArguments();
    public void set_FormalArguments(List`1<FormalArgument> value);
    public bool get_HasFormalArgs();
    public void set_HasFormalArgs(bool value);
    public ReadOnlyCollection`1<CompiledTemplate> get_ImplicitlyDefinedTemplates();
    public virtual TemplateGroup get_NativeGroup();
    public virtual void set_NativeGroup(TemplateGroup value);
    public bool get_IsRegion();
    public void set_IsRegion(bool value);
    public RegionType get_RegionDefType();
    public void set_RegionDefType(RegionType value);
    public bool get_IsAnonSubtemplate();
    public void set_IsAnonSubtemplate(bool value);
    public virtual string get_TemplateSource();
    public virtual Interval get_TemplateRange();
    public virtual int get_NumberOfArgsWithDefaultValues();
    public virtual FormalArgument TryGetFormalArgument(string name);
    public CompiledTemplate Clone();
    public virtual void AddImplicitlyDefinedTemplate(CompiledTemplate sub);
    public virtual void DefineArgumentDefaultValueTemplates(TemplateGroup group);
    public virtual void DefineFormalArguments(IEnumerable`1<FormalArgument> args);
    public virtual void AddArgument(FormalArgument a);
    public virtual void DefineImplicitlyDefinedTemplates(TemplateGroup group);
    public virtual string GetInstructions();
    public virtual void Dump();
    public virtual string Disassemble();
}
public class Antlr4.StringTemplate.Compiler.FormalArgument : object {
    private string name;
    private int index;
    private IToken defaultValueToken;
    private object defaultValue;
    private CompiledTemplate compiledDefaultValue;
    public string Name { get; }
    public int Index { get; internal set; }
    public IToken DefaultValueToken { get; }
    public object DefaultValue { get; public set; }
    public CompiledTemplate CompiledDefaultValue { get; internal set; }
    public FormalArgument(string name);
    public FormalArgument(string name, IToken defaultValueToken);
    public string get_Name();
    public int get_Index();
    internal void set_Index(int value);
    public IToken get_DefaultValueToken();
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    public CompiledTemplate get_CompiledDefaultValue();
    internal void set_CompiledDefaultValue(CompiledTemplate value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[GeneratedCodeAttribute("ANTLR", "3.5.2-beta2")]
[CLSCompliantAttribute("False")]
public class Antlr4.StringTemplate.Compiler.GroupLexer : Lexer {
    public TemplateGroup group;
    public static int EOF;
    public static int ANONYMOUS_TEMPLATE;
    public static int BIGSTRING;
    public static int BIGSTRING_NO_NL;
    public static int COMMA;
    public static int COMMENT;
    public static int FALSE;
    public static int ID;
    public static int LBRACK;
    public static int LINE_COMMENT;
    public static int RBRACK;
    public static int STRING;
    public static int TRUE;
    public static int WS;
    public static int T__17;
    public static int T__18;
    public static int T__19;
    public static int T__20;
    public static int T__21;
    public static int T__22;
    public static int T__23;
    public static int T__24;
    public static int T__25;
    public static int T__26;
    public static int T__27;
    public static int T__28;
    private DFA8 dfa8;
    public string SourceName { get; }
    public string GrammarFileName { get; }
    public GroupLexer(ICharStream input);
    public GroupLexer(ICharStream input, RecognizerSharedState state);
    public virtual void ReportError(RecognitionException e);
    public virtual string get_SourceName();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("COMMA")]
private void mCOMMA();
    [GrammarRuleAttribute("FALSE")]
private void mFALSE();
    [GrammarRuleAttribute("LBRACK")]
private void mLBRACK();
    [GrammarRuleAttribute("RBRACK")]
private void mRBRACK();
    [GrammarRuleAttribute("TRUE")]
private void mTRUE();
    [GrammarRuleAttribute("T__17")]
private void mT__17();
    [GrammarRuleAttribute("T__18")]
private void mT__18();
    [GrammarRuleAttribute("T__19")]
private void mT__19();
    [GrammarRuleAttribute("T__20")]
private void mT__20();
    [GrammarRuleAttribute("T__21")]
private void mT__21();
    [GrammarRuleAttribute("T__22")]
private void mT__22();
    [GrammarRuleAttribute("T__23")]
private void mT__23();
    [GrammarRuleAttribute("T__24")]
private void mT__24();
    [GrammarRuleAttribute("T__25")]
private void mT__25();
    [GrammarRuleAttribute("T__26")]
private void mT__26();
    [GrammarRuleAttribute("T__27")]
private void mT__27();
    [GrammarRuleAttribute("T__28")]
private void mT__28();
    [GrammarRuleAttribute("ID")]
private void mID();
    [GrammarRuleAttribute("STRING")]
private void mSTRING();
    [GrammarRuleAttribute("BIGSTRING")]
private void mBIGSTRING();
    [GrammarRuleAttribute("BIGSTRING_NO_NL")]
private void mBIGSTRING_NO_NL();
    [GrammarRuleAttribute("ANONYMOUS_TEMPLATE")]
private void mANONYMOUS_TEMPLATE();
    [GrammarRuleAttribute("COMMENT")]
private void mCOMMENT();
    [GrammarRuleAttribute("LINE_COMMENT")]
private void mLINE_COMMENT();
    [GrammarRuleAttribute("WS")]
private void mWS();
    public virtual void mTokens();
    protected virtual void InitDFAs();
}
[GeneratedCodeAttribute("ANTLR", "3.5.2-beta2")]
[CLSCompliantAttribute("False")]
public class Antlr4.StringTemplate.Compiler.GroupParser : Parser {
    private TemplateGroup _group;
    internal static String[] tokenNames;
    public static int EOF;
    public static int ANONYMOUS_TEMPLATE;
    public static int BIGSTRING;
    public static int BIGSTRING_NO_NL;
    public static int COMMA;
    public static int COMMENT;
    public static int FALSE;
    public static int ID;
    public static int LBRACK;
    public static int LINE_COMMENT;
    public static int RBRACK;
    public static int STRING;
    public static int TRUE;
    public static int WS;
    public static int T__17;
    public static int T__18;
    public static int T__19;
    public static int T__20;
    public static int T__21;
    public static int T__22;
    public static int T__23;
    public static int T__24;
    public static int T__25;
    public static int T__26;
    public static int T__27;
    public static int T__28;
    protected ListStack`1<formalArgs_scope> formalArgs_stack;
    public TemplateGroup Group { get; internal set; }
    public string SourceName { get; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public GroupParser(ITokenStream input);
    public GroupParser(ITokenStream input, RecognizerSharedState state);
    private static GroupParser();
    public TemplateGroup get_Group();
    internal void set_Group(TemplateGroup value);
    public virtual void DisplayRecognitionError(String[] tokenNames, RecognitionException e);
    public virtual string get_SourceName();
    public virtual void Error(string msg);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("group")]
public void group(TemplateGroup group, string prefix);
    [GrammarRuleAttribute("oldStyleHeader")]
private void oldStyleHeader();
    [GrammarRuleAttribute("groupName")]
private string groupName();
    [GrammarRuleAttribute("delimiters")]
private void delimiters();
    [GrammarRuleAttribute("def")]
private void def(string prefix);
    [GrammarRuleAttribute("templateDef")]
public void templateDef(string prefix);
    [GrammarRuleAttribute("formalArgs")]
private List`1<FormalArgument> formalArgs();
    [GrammarRuleAttribute("formalArg")]
private void formalArg(List`1<FormalArgument> args);
    [GrammarRuleAttribute("dictDef")]
private void dictDef();
    [GrammarRuleAttribute("dict")]
private IDictionary`2<string, object> dict();
    [GrammarRuleAttribute("dictPairs")]
private void dictPairs(IDictionary`2<string, object> mapping);
    [GrammarRuleAttribute("defaultValuePair")]
private void defaultValuePair(IDictionary`2<string, object> mapping);
    [GrammarRuleAttribute("keyValuePair")]
private void keyValuePair(IDictionary`2<string, object> mapping);
    [GrammarRuleAttribute("keyValue")]
private object keyValue();
}
public class Antlr4.StringTemplate.Compiler.Instruction : object {
    public static int MaxOperands;
    public static int OperandSizeInBytes;
    public static Instruction[] instructions;
    internal string name;
    internal OperandType[] type;
    internal int nopnds;
    private static Instruction();
    public Instruction(string name);
    public Instruction(string name, OperandType a);
    public Instruction(string name, OperandType a, OperandType b);
}
public enum Antlr4.StringTemplate.Compiler.OperandType : Enum {
    public int value__;
    public static OperandType None;
    public static OperandType String;
    public static OperandType Address;
    public static OperandType Int;
}
public class Antlr4.StringTemplate.Compiler.StringTable : object {
    private Dictionary`2<string, int> table;
    private int i;
    public virtual int Add(string s);
    public virtual String[] ToArray();
}
public class Antlr4.StringTemplate.Compiler.TemplateCompiler : object {
    public static string SubtemplatePrefix;
    public static int InitialCodeSize;
    public static IDictionary`2<string, RenderOption> supportedOptions;
    public static int NUM_OPTIONS;
    public static IDictionary`2<string, string> defaultOptionValues;
    public static IDictionary`2<string, Bytecode> funcs;
    public static int subtemplateCount;
    private TemplateGroup _group;
    public TemplateGroup Group { get; }
    public ErrorManager ErrorManager { get; }
    public char DelimiterStartChar { get; }
    public char DelimiterStopChar { get; }
    public TemplateCompiler(TemplateGroup group);
    private static TemplateCompiler();
    public TemplateGroup get_Group();
    public ErrorManager get_ErrorManager();
    public char get_DelimiterStartChar();
    public char get_DelimiterStopChar();
    public virtual CompiledTemplate Compile(string template);
    public virtual CompiledTemplate Compile(string name, string template);
    public virtual CompiledTemplate Compile(string srcName, string name, List`1<FormalArgument> args, string template, IToken templateToken);
    public static CompiledTemplate DefineBlankRegion(CompiledTemplate outermostImpl, IToken nameToken);
    public static string GetNewSubtemplateName();
    protected virtual void ReportMessageAndThrowTemplateException(ITokenStream tokens, IToken templateToken, Parser parser, RecognitionException re);
}
public class Antlr4.StringTemplate.Compiler.TemplateException : Exception {
    public TemplateException(string message, Exception innerException);
}
public class Antlr4.StringTemplate.Compiler.TemplateLexer : object {
    public static char EOF;
    public static int EOF_TYPE;
    public static IToken SkipToken;
    public static int RBRACK;
    public static int LBRACK;
    public static int ELSE;
    public static int ELLIPSIS;
    public static int LCURLY;
    public static int BANG;
    [CLSCompliantAttribute("False")]
public static int EQUALS;
    public static int TEXT;
    public static int ID;
    public static int SEMI;
    public static int LPAREN;
    public static int IF;
    public static int ELSEIF;
    public static int COLON;
    public static int RPAREN;
    public static int COMMA;
    public static int RCURLY;
    public static int ENDIF;
    public static int RDELIM;
    public static int SUPER;
    public static int DOT;
    public static int LDELIM;
    public static int STRING;
    public static int PIPE;
    public static int OR;
    public static int AND;
    public static int INDENT;
    public static int NEWLINE;
    public static int AT;
    public static int REGION_END;
    public static int TRUE;
    public static int FALSE;
    public static int COMMENT;
    private char delimiterStartChar;
    private char delimiterStopChar;
    private bool scanningInsideExpr;
    public int subtemplateDepth;
    private ErrorManager errMgr;
    private IToken templateToken;
    private ICharStream input;
    private char c;
    private int startCharIndex;
    private int startLine;
    private int startCharPositionInLine;
    private Queue`1<IToken> tokens;
    public string SourceName { get; }
    public String[] TokenNames { get; }
    public TemplateLexer(ICharStream input);
    public TemplateLexer(ErrorManager errMgr, ICharStream input, IToken templateToken);
    public TemplateLexer(ErrorManager errMgr, ICharStream input, IToken templateToken, char delimiterStartChar, char delimiterStopChar);
    private static TemplateLexer();
    public virtual string get_SourceName();
    public sealed virtual String[] get_TokenNames();
    public virtual IToken NextToken();
    public virtual void Match(char x);
    protected virtual void Consume();
    public virtual void Emit(IToken token);
    public virtual IToken NextTokenImpl();
    protected virtual IToken NextTokenOutside();
    protected virtual IToken NextTokenInside();
    private IToken MatchSubTemplate();
    private IToken MatchEscape();
    private IToken MatchUnicode();
    private IToken MatchText();
    private IToken MatchIdentifier();
    private IToken MatchString();
    private void ConsumeWhitespace();
    private IToken MatchComment();
    private void ConsumeLineBreak();
    public static bool IsIDStartLetter(char c);
    public static bool IsIDLetter(char c);
    public static bool IsWS(char c);
    public static bool IsUnicodeLetter(char c);
    public virtual IToken NewToken(int ttype);
    public virtual IToken NewTokenFromPreviousChar(int ttype);
    public virtual IToken NewToken(int ttype, string text, int pos);
    public virtual IToken NewToken(int ttype, string text);
    private static string GetCharString(char c);
}
[GeneratedCodeAttribute("ANTLR", "3.5.2-beta2")]
[CLSCompliantAttribute("False")]
public class Antlr4.StringTemplate.Compiler.TemplateParser : Parser {
    private ErrorManager errMgr;
    private IToken templateToken;
    internal static String[] tokenNames;
    public static int EOF;
    public static int IF;
    public static int ELSE;
    public static int ELSEIF;
    public static int ENDIF;
    public static int SUPER;
    public static int SEMI;
    public static int BANG;
    public static int ELLIPSIS;
    public static int EQUALS;
    public static int COLON;
    public static int LPAREN;
    public static int RPAREN;
    public static int LBRACK;
    public static int RBRACK;
    public static int COMMA;
    public static int DOT;
    public static int LCURLY;
    public static int RCURLY;
    public static int TEXT;
    public static int LDELIM;
    public static int RDELIM;
    public static int ID;
    public static int STRING;
    public static int WS;
    public static int PIPE;
    public static int OR;
    public static int AND;
    public static int INDENT;
    public static int NEWLINE;
    public static int AT;
    public static int END;
    public static int TRUE;
    public static int FALSE;
    public static int COMMENT;
    public static int ARGS;
    public static int ELEMENTS;
    public static int EXEC_FUNC;
    public static int EXPR;
    public static int INCLUDE;
    public static int INCLUDE_IND;
    public static int INCLUDE_REGION;
    public static int INCLUDE_SUPER;
    public static int INCLUDE_SUPER_REGION;
    public static int LIST;
    public static int MAP;
    public static int NULL;
    public static int OPTIONS;
    public static int PROP;
    public static int PROP_IND;
    public static int REGION;
    public static int SUBTEMPLATE;
    public static int TO_STR;
    public static int ZIP;
    private ITreeAdaptor adaptor;
    protected ListStack`1<conditional_scope> conditional_stack;
    public ITreeAdaptor TreeAdaptor { get; public set; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public TemplateParser(ITokenStream input, ErrorManager errMgr, IToken templateToken);
    private TemplateParser(ITokenStream input);
    private TemplateParser(ITokenStream input, RecognizerSharedState state);
    private static TemplateParser();
    protected virtual object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow);
    public ITreeAdaptor get_TreeAdaptor();
    public void set_TreeAdaptor(ITreeAdaptor value);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("templateAndEOF")]
public AstParserRuleReturnScope`2<CommonTree, CommonToken> templateAndEOF();
    [GrammarRuleAttribute("template")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> template();
    [GrammarRuleAttribute("element")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> element();
    [GrammarRuleAttribute("singleElement")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> singleElement();
    [GrammarRuleAttribute("compoundElement")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> compoundElement();
    [GrammarRuleAttribute("exprTag")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> exprTag();
    [GrammarRuleAttribute("region")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> region();
    [GrammarRuleAttribute("regionbody")]
private regionbody_return regionbody();
    [GrammarRuleAttribute("subtemplate")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> subtemplate();
    [GrammarRuleAttribute("subtemplateargs")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> subtemplateargs();
    [GrammarRuleAttribute("subtemplate_args_trunc")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> subtemplate_args_trunc();
    [GrammarRuleAttribute("subtemplate_args_last")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> subtemplate_args_last();
    [GrammarRuleAttribute("ifstat")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> ifstat();
    [GrammarRuleAttribute("ifstatbody")]
private ifstatbody_return ifstatbody();
    [GrammarRuleAttribute("elseifstat")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> elseifstat();
    [GrammarRuleAttribute("elsestat")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> elsestat();
    [GrammarRuleAttribute("conditional")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> conditional();
    [GrammarRuleAttribute("andConditional")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> andConditional();
    [GrammarRuleAttribute("notConditional")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> notConditional();
    [GrammarRuleAttribute("exprOptions")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> exprOptions();
    [GrammarRuleAttribute("option")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> option();
    [GrammarRuleAttribute("exprNoComma")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> exprNoComma();
    [GrammarRuleAttribute("expr")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> expr();
    [GrammarRuleAttribute("mapExpr")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> mapExpr();
    [GrammarRuleAttribute("mapTemplateRef")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> mapTemplateRef();
    [GrammarRuleAttribute("memberExpr")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> memberExpr();
    [GrammarRuleAttribute("includeExpr")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> includeExpr();
    [GrammarRuleAttribute("primary")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> primary();
    [GrammarRuleAttribute("args")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> args();
    [GrammarRuleAttribute("argExprList")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> argExprList();
    [GrammarRuleAttribute("arg")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> arg();
    [GrammarRuleAttribute("namedArg")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> namedArg();
    [GrammarRuleAttribute("list")]
private AstParserRuleReturnScope`2<CommonTree, CommonToken> list();
}
public class Antlr4.StringTemplate.DateRenderer : object {
    public static IDictionary`2<string, string> formatToInt;
    private static DateRenderer();
    public virtual string ToString(object o, string formatString, CultureInfo locale);
}
public class Antlr4.StringTemplate.Debug.AddAttributeEvent : ConstructionEvent {
    private string name;
    private object value;
    public string Name { get; }
    public object Value { get; }
    public AddAttributeEvent(string name, object value);
    public string get_Name();
    public object get_Value();
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Debug.ConstructionEvent : object {
    private StackTrace stack;
    public virtual string GetFileName();
    public virtual int GetLine();
    public virtual StackFrame GetTemplateEntryPoint();
}
public class Antlr4.StringTemplate.Debug.DebugEvents : object {
    public List`1<InterpEvent> Events;
    public List`1<EvalTemplateEvent> ChildEvalTemplateEvents;
    public bool IsEarlyEval;
}
public class Antlr4.StringTemplate.Debug.EvalExprEvent : InterpEvent {
    private Interval _sourceInterval;
    private string expr;
    public Interval SourceInterval { get; }
    public string Expr { get; }
    public EvalExprEvent(TemplateFrame frame, Interval outputInterval, Interval sourceInterval);
    public Interval get_SourceInterval();
    public string get_Expr();
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Debug.EvalTemplateEvent : InterpEvent {
    public EvalTemplateEvent(TemplateFrame frame, Interval interval);
}
public class Antlr4.StringTemplate.Debug.IndentEvent : EvalExprEvent {
    public IndentEvent(TemplateFrame frame, Interval outputInterval, Interval sourceInterval);
}
public class Antlr4.StringTemplate.Debug.InterpEvent : object {
    private TemplateFrame _frame;
    private Interval _interval;
    public TemplateFrame Frame { get; }
    public Template Template { get; }
    public Interval OutputInterval { get; }
    public InterpEvent(TemplateFrame frame, Interval interval);
    public TemplateFrame get_Frame();
    public Template get_Template();
    public Interval get_OutputInterval();
    public virtual string ToString();
}
internal static class Antlr4.StringTemplate.Extensions.Arrays : object {
    public static TOutput[] ConvertAll(TInput[] array, Func`2<TInput, TOutput> transform);
}
[ExtensionAttribute]
public static class Antlr4.StringTemplate.Extensions.ExceptionExtensions : object {
    private static Action`1<Exception> _internalPreserveStackTrace;
    private static ExceptionExtensions();
    private static Action`1<Exception> GetInternalPreserveStackTraceDelegate();
    [ExtensionAttribute]
public static bool IsCritical(Exception e);
    [ExtensionAttribute]
public static void PreserveStackTrace(Exception e);
}
public interface Antlr4.StringTemplate.IAttributeRenderer {
    public abstract virtual string ToString(object obj, string formatString, CultureInfo culture);
}
public interface Antlr4.StringTemplate.IModelAdaptor {
    public abstract virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object obj, object property, string propertyName);
}
public class Antlr4.StringTemplate.Interpreter : object {
    public static int DefaultOperandStackSize;
    private static String[] predefinedAnonSubtemplateAttributes;
    private static bool trace;
    private TemplateGroup group;
    private CultureInfo culture;
    private ErrorManager _errorManager;
    private Object[] operands;
    private int sp;
    private int nwline;
    private List`1<string> executeTrace;
    private bool _debug;
    private List`1<InterpEvent> events;
    public static ReadOnlyCollection`1<string> PredefinedAnonymousSubtemplateAttributes { get; }
    public Interpreter(TemplateGroup group, bool debug);
    public Interpreter(TemplateGroup group, CultureInfo culture, bool debug);
    public Interpreter(TemplateGroup group, ErrorManager errorManager, bool debug);
    public Interpreter(TemplateGroup group, CultureInfo culture, ErrorManager errorManager, bool debug);
    private static Interpreter();
    public static ReadOnlyCollection`1<string> get_PredefinedAnonymousSubtemplateAttributes();
    public virtual int Execute(ITemplateWriter out, TemplateFrame frame);
    protected virtual int ExecuteImpl(ITemplateWriter out, TemplateFrame frame);
    internal virtual void SuperNew(TemplateFrame frame, string name, int nargs);
    internal virtual void SuperNew(TemplateFrame frame, string name, IDictionary`2<string, object> attrs);
    internal virtual void PassThrough(TemplateFrame frame, string templateName, IDictionary`2<string, object> attrs);
    internal virtual void StoreArguments(TemplateFrame frame, IDictionary`2<string, object> attrs, Template st);
    internal virtual void StoreArguments(TemplateFrame frame, int nargs, Template st);
    protected void Indent(ITemplateWriter out, TemplateFrame frame, int strIndex);
    protected virtual int WriteObjectNoOptions(ITemplateWriter out, TemplateFrame frame, object o);
    protected virtual int WriteObjectWithOptions(ITemplateWriter out, TemplateFrame frame, object o, Object[] options);
    protected virtual int WriteObject(ITemplateWriter out, TemplateFrame frame, object o, String[] options);
    protected virtual int WriteIterator(ITemplateWriter out, TemplateFrame frame, object o, String[] options);
    protected virtual int WritePlainObject(ITemplateWriter out, TemplateFrame frame, object o, String[] options);
    protected virtual Interval GetExpressionInterval(TemplateFrame frame);
    protected virtual void Map(TemplateFrame frame, object attr, Template st);
    protected virtual void RotateMap(TemplateFrame frame, object attr, List`1<Template> prototypes);
    protected virtual List`1<Template> RotateMapIterator(TemplateFrame frame, IEnumerator iterator, List`1<Template> prototypes);
    protected virtual AttributeList ZipMap(TemplateFrame frame, List`1<object> exprs, Template prototype);
    protected virtual void SetFirstArgument(TemplateFrame frame, Template st, object attr);
    protected virtual void AddToList(List`1<object> list, TemplateFrame frame, object o);
    public virtual object First(TemplateFrame frame, object v);
    public virtual object Last(TemplateFrame frame, object v);
    public virtual object Rest(TemplateFrame frame, object v);
    public virtual object Trunc(TemplateFrame frame, object v);
    public virtual object Strip(TemplateFrame frame, object v);
    public virtual object Reverse(TemplateFrame frame, object v);
    public virtual object Length(object v);
    protected virtual string ToString(TemplateFrame frame, object value);
    public static object ConvertAnythingIteratableToIterator(TemplateFrame frame, object o);
    public static IEnumerator ConvertAnythingToIterator(TemplateFrame frame, object o);
    protected virtual bool TestAttributeTrue(object a);
    protected virtual object GetObjectProperty(TemplateFrame frame, object o, object property);
    public virtual object GetAttribute(TemplateFrame frame, string name);
    protected virtual void SetDefaultArguments(TemplateFrame frame);
    protected virtual void Trace(TemplateFrame frame, int ip);
    protected virtual void PrintForTrace(StringBuilder tr, TemplateFrame frame, object o);
    public virtual List`1<InterpEvent> GetEvents();
    protected void TrackDebugEvent(TemplateFrame frame, InterpEvent e);
    public virtual List`1<string> GetExecutionTrace();
    private static int GetShort(Byte[] value, int startIndex);
}
public interface Antlr4.StringTemplate.ITemplateErrorListener {
    public abstract virtual void CompiletimeError(TemplateMessage msg);
    public abstract virtual void RuntimeError(TemplateMessage msg);
    public abstract virtual void IOError(TemplateMessage msg);
    public abstract virtual void InternalError(TemplateMessage msg);
}
public interface Antlr4.StringTemplate.ITemplateWriter {
    public int Index { get; }
    public int LineWidth { get; public set; }
    public abstract virtual int get_Index();
    public abstract virtual int get_LineWidth();
    public abstract virtual void set_LineWidth(int value);
    public abstract virtual void PushIndentation(string indent);
    public abstract virtual string PopIndentation();
    public abstract virtual void PushAnchorPoint();
    public abstract virtual void PopAnchorPoint();
    public abstract virtual int Write(string str);
    public abstract virtual int Write(string str, string wrap);
    public abstract virtual int WriteWrap(string wrap);
    public abstract virtual int WriteSeparator(string str);
}
public interface Antlr4.StringTemplate.ITypeProxyFactory {
    public abstract virtual object CreateProxy(TemplateFrame frame, object obj);
}
[DefaultMemberAttribute("Item")]
public class Antlr4.StringTemplate.Misc.Aggregate : object {
    private Dictionary`2<string, object> _properties;
    public IDictionary`2<string, object> Properties { get; }
    public object Item { get; internal set; }
    public IDictionary`2<string, object> get_Properties();
    public object get_Item(string propertyName);
    internal void set_Item(string propertyName, object value);
    public bool TryGetValue(string propertyName, Object& value);
}
public class Antlr4.StringTemplate.Misc.AggregateModelAdaptor : MapModelAdaptor {
    public virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object o, object property, string propertyName);
}
public class Antlr4.StringTemplate.Misc.AttributeNotFoundException : TemplateException {
    private TemplateFrame _frame;
    private string _attributeName;
    public string Message { get; }
    public AttributeNotFoundException(TemplateFrame frame, string attributeName);
    public virtual string get_Message();
}
[DebuggerDisplayAttribute("({_line},{_charPosition})")]
public class Antlr4.StringTemplate.Misc.Coordinate : ValueType {
    private int _line;
    private int _charPosition;
    public int Line { get; }
    public int CharPosition { get; }
    public Coordinate(int line, int charPosition);
    public int get_Line();
    public int get_CharPosition();
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Misc.DebugErrorListener : object {
    public virtual void CompiletimeError(TemplateMessage msg);
    public virtual void RuntimeError(TemplateMessage msg);
    public virtual void IOError(TemplateMessage msg);
    public virtual void InternalError(TemplateMessage msg);
    public virtual void Error(string s);
    public virtual void Error(string s, Exception e);
}
public class Antlr4.StringTemplate.Misc.ErrorBuffer : object {
    private List`1<TemplateMessage> errors;
    public ReadOnlyCollection`1<TemplateMessage> Errors { get; }
    protected List`1<TemplateMessage> ErrorList { get; }
    public ReadOnlyCollection`1<TemplateMessage> get_Errors();
    protected List`1<TemplateMessage> get_ErrorList();
    public virtual void CompiletimeError(TemplateMessage msg);
    public virtual void RuntimeError(TemplateMessage msg);
    public virtual void IOError(TemplateMessage msg);
    public virtual void InternalError(TemplateMessage msg);
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Misc.ErrorManager : object {
    private static ITemplateErrorListener _defaultErrorListener;
    private ITemplateErrorListener _listener;
    public static ITemplateErrorListener DefaultErrorListener { get; public set; }
    public ITemplateErrorListener Listener { get; }
    public ErrorManager(ITemplateErrorListener listener);
    private static ErrorManager();
    public static ITemplateErrorListener get_DefaultErrorListener();
    public static void set_DefaultErrorListener(ITemplateErrorListener value);
    public ITemplateErrorListener get_Listener();
    public virtual void CompiletimeError(ErrorType error, IToken templateToken, IToken t);
    public virtual void LexerError(string srcName, string msg, IToken templateToken, RecognitionException e);
    public virtual void CompiletimeError(ErrorType error, IToken templateToken, IToken t, object arg);
    public virtual void CompiletimeError(ErrorType error, IToken templateToken, IToken t, object arg, object arg2);
    public virtual void GroupSyntaxError(ErrorType error, string sourceName, IToken token);
    public virtual void GroupSyntaxError(ErrorType error, string sourceName, RecognitionException e, string message);
    public virtual void GroupLexerError(ErrorType error, string srcName, RecognitionException e, string msg);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error, object arg);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error, Exception e, object arg);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error, object arg, object arg2);
    public virtual void RuntimeError(TemplateFrame frame, ErrorType error, object arg, object arg2, object arg3);
    public virtual void IOError(Template self, ErrorType error, Exception e);
    public virtual void IOError(Template self, ErrorType error, Exception e, object arg);
    public virtual void InternalError(Template self, string msg, Exception e);
}
[DebuggerDisplayAttribute("{Message}")]
public class Antlr4.StringTemplate.Misc.ErrorType : object {
    public static ErrorType NO_SUCH_TEMPLATE;
    public static ErrorType NO_IMPORTED_TEMPLATE;
    public static ErrorType NO_SUCH_ATTRIBUTE;
    public static ErrorType NO_SUCH_ATTRIBUTE_PASS_THROUGH;
    public static ErrorType REF_TO_IMPLICIT_ATTRIBUTE_OUT_OF_SCOPE;
    public static ErrorType MISSING_FORMAL_ARGUMENTS;
    public static ErrorType NO_SUCH_PROPERTY;
    public static ErrorType MAP_ARGUMENT_COUNT_MISMATCH;
    public static ErrorType ARGUMENT_COUNT_MISMATCH;
    public static ErrorType EXPECTING_STRING;
    public static ErrorType CANT_IMPORT;
    public static ErrorType SYNTAX_ERROR;
    public static ErrorType TEMPLATE_REDEFINITION;
    public static ErrorType EMBEDDED_REGION_REDEFINITION;
    public static ErrorType REGION_REDEFINITION;
    public static ErrorType HIDDEN_EMBEDDED_REGION_DEFINITION;
    public static ErrorType MAP_REDEFINITION;
    public static ErrorType ALIAS_TARGET_UNDEFINED;
    public static ErrorType TEMPLATE_REDEFINITION_AS_MAP;
    public static ErrorType LEXER_ERROR;
    public static ErrorType NO_DEFAULT_VALUE;
    public static ErrorType NO_SUCH_FUNCTION;
    public static ErrorType NO_SUCH_REGION;
    public static ErrorType NO_SUCH_OPTION;
    public static ErrorType INVALID_TEMPLATE_NAME;
    public static ErrorType ANON_ARGUMENT_MISMATCH;
    public static ErrorType REQUIRED_PARAMETER_AFTER_OPTIONAL;
    public static ErrorType INVALID_DELIMITER;
    public static ErrorType INTERNAL_ERROR;
    public static ErrorType WRITE_IO_ERROR;
    public static ErrorType CANT_LOAD_GROUP_FILE;
    private string _message;
    public string Message { get; }
    private ErrorType(string m);
    private static ErrorType();
    public string get_Message();
}
internal static class Antlr4.StringTemplate.Misc.HttpUtility : object {
    internal static string UrlEncode(string str);
    internal static string UrlEncode(string str, Encoding e);
    internal static Byte[] UrlEncodeToBytes(string str, Encoding e);
    internal static Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    internal static Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    internal static bool IsUrlSafeChar(char ch);
    internal static char IntToHex(int n);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
}
[DebuggerDisplayAttribute("[{Start}..{End})")]
public class Antlr4.StringTemplate.Misc.Interval : object {
    private int _start;
    private int _length;
    public int Start { get; }
    public int End { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Interval(int start, int length);
    public int get_Start();
    public int get_End();
    public int get_Length();
    public bool get_IsEmpty();
    public static Interval FromBounds(int start, int end);
    public bool Contains(int position);
    public bool Contains(Interval interval);
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Misc.MapModelAdaptor : object {
    public virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object o, object property, string propertyName);
}
public class Antlr4.StringTemplate.Misc.MultiMap`2 : Dictionary`2<TKey, List`1<TValue>> {
    public virtual void Add(TKey key, TValue value);
}
public class Antlr4.StringTemplate.Misc.ObjectModelAdaptor : object {
    private static Dictionary`2<Type, Dictionary`2<string, Func`2<object, object>>> _memberAccessors;
    private static ObjectModelAdaptor();
    public virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object o, object property, string propertyName);
    private static Func`2<object, object> FindMember(Type type, string name);
    private static bool IsIndexer(PropertyInfo propertyInfo);
    private static Func`2<object, object> BuildAccessor(MethodInfo method);
    private static Func`2<object, object> BuildAccessor(MethodInfo method, string argument);
    private static Func`2<object, object> BuildAccessor(FieldInfo field);
}
public class Antlr4.StringTemplate.Misc.ObjectReferenceEqualityComparer`1 : object {
    private static ObjectReferenceEqualityComparer`1<T> _default;
    public static ObjectReferenceEqualityComparer`1<T> Default { get; }
    private static ObjectReferenceEqualityComparer`1();
    public static ObjectReferenceEqualityComparer`1<T> get_Default();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
}
public class Antlr4.StringTemplate.Misc.TemplateCompiletimeMessage : TemplateMessage {
    private IToken _templateToken;
    private IToken _token;
    private string _sourceName;
    public IToken TemplateToken { get; }
    public IToken Token { get; }
    public string SourceName { get; }
    public TemplateCompiletimeMessage(ErrorType error, string sourceName, IToken templateToken, IToken token);
    public TemplateCompiletimeMessage(ErrorType error, string sourceName, IToken templateToken, IToken token, Exception cause);
    public TemplateCompiletimeMessage(ErrorType error, string sourceName, IToken templateToken, IToken token, Exception cause, object arg);
    public TemplateCompiletimeMessage(ErrorType error, string sourceName, IToken templateToken, IToken token, Exception cause, object arg, object arg2);
    public IToken get_TemplateToken();
    public IToken get_Token();
    public string get_SourceName();
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Misc.TemplateGroupCompiletimeMessage : TemplateMessage {
    private IToken _token;
    private string _sourceName;
    public IToken Token { get; }
    public string SourceName { get; }
    public TemplateGroupCompiletimeMessage(ErrorType error, string sourceName, IToken token);
    public TemplateGroupCompiletimeMessage(ErrorType error, string sourceName, IToken token, Exception cause);
    public TemplateGroupCompiletimeMessage(ErrorType error, string sourceName, IToken token, Exception cause, object arg);
    public TemplateGroupCompiletimeMessage(ErrorType error, string sourceName, IToken token, Exception cause, object arg, object arg2);
    public IToken get_Token();
    public string get_SourceName();
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Misc.TemplateLexerMessage : TemplateMessage {
    private string _message;
    private IToken _templateToken;
    private string _sourceName;
    public string Message { get; }
    public IToken TemplateToken { get; }
    public string SourceName { get; }
    public TemplateLexerMessage(string sourceName, string message, IToken templateToken, Exception cause);
    public string get_Message();
    public IToken get_TemplateToken();
    public string get_SourceName();
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Misc.TemplateMessage : object {
    private Template self;
    private ErrorType error;
    private object arg;
    private object arg2;
    private object arg3;
    private Exception cause;
    public Template Self { get; }
    public ErrorType Error { get; }
    public object Arg { get; }
    public object Arg2 { get; }
    public object Arg3 { get; }
    public Exception Cause { get; }
    public TemplateMessage(ErrorType error);
    public TemplateMessage(ErrorType error, Template self);
    public TemplateMessage(ErrorType error, Template self, Exception cause);
    public TemplateMessage(ErrorType error, Template self, Exception cause, object arg);
    public TemplateMessage(ErrorType error, Template self, Exception cause, IToken where, object arg);
    public TemplateMessage(ErrorType error, Template self, Exception cause, object arg, object arg2);
    public TemplateMessage(ErrorType error, Template self, Exception cause, object arg, object arg2, object arg3);
    public Template get_Self();
    public ErrorType get_Error();
    public object get_Arg();
    public object get_Arg2();
    public object get_Arg3();
    public Exception get_Cause();
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Misc.TemplateModelAdaptor : object {
    public virtual object GetProperty(Interpreter interpreter, TemplateFrame frame, object o, object property, string propertyName);
}
public class Antlr4.StringTemplate.Misc.TemplateNoSuchPropertyException : TemplateException {
    private object _object;
    private string _propertyName;
    public string PropertyName { get; }
    public TemplateNoSuchPropertyException(object obj, string propertyName);
    public TemplateNoSuchPropertyException(object obj, string propertyName, Exception innerException);
    public string get_PropertyName();
}
public class Antlr4.StringTemplate.Misc.TemplateRuntimeMessage : TemplateMessage {
    private int ip;
    private TemplateFrame _frame;
    public TemplateFrame Frame { get; }
    public Interval SourceInterval { get; }
    public TemplateRuntimeMessage(ErrorType error, int ip);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame, object arg);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame, Exception e, object arg);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame, Exception e, object arg, object arg2);
    public TemplateRuntimeMessage(ErrorType error, int ip, TemplateFrame frame, Exception e, object arg, object arg2, object arg3);
    public TemplateFrame get_Frame();
    public Interval get_SourceInterval();
    public virtual string GetSourceLocation();
    public virtual string ToString();
}
public class Antlr4.StringTemplate.Misc.TextWriterErrorListener : object {
    private TextWriter _writer;
    public TextWriterErrorListener(TextWriter writer);
    public virtual void CompiletimeError(TemplateMessage msg);
    public virtual void RuntimeError(TemplateMessage msg);
    public virtual void IOError(TemplateMessage msg);
    public virtual void InternalError(TemplateMessage msg);
    public virtual void Error(string s);
    public virtual void Error(string s, Exception e);
}
[DefaultMemberAttribute("Item")]
public class Antlr4.StringTemplate.Misc.TypeRegistry`1 : object {
    private Dictionary`2<Type, T> _backingStore;
    private Dictionary`2<Type, Type> _cache;
    private ICollection`1<Type> System.Collections.Generic.IDictionary<System.Type,T>.Keys { get; }
    private ICollection`1<T> System.Collections.Generic.IDictionary<System.Type,T>.Values { get; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.Count { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public TypeRegistry`1(IEnumerable`1<KeyValuePair`2<Type, T>> collection);
    private sealed virtual override ICollection`1<Type> System.Collections.Generic.IDictionary<System.Type,T>.get_Keys();
    private sealed virtual override ICollection`1<T> System.Collections.Generic.IDictionary<System.Type,T>.get_Values();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.get_Count();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(Type key);
    public sealed virtual void set_Item(Type key, T value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(Type key, T value);
    public sealed virtual bool ContainsKey(Type key);
    public sealed virtual bool Remove(Type key);
    public sealed virtual bool TryGetValue(Type key, T& value);
    public sealed virtual void Clear();
    public sealed virtual IEnumerator`1<KeyValuePair`2<Type, T>> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.Add(KeyValuePair`2<Type, T> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.Contains(KeyValuePair`2<Type, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Type,T>>.Remove(KeyValuePair`2<Type, T> item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private void HandleAlteration(Type type);
}
public static class Antlr4.StringTemplate.Misc.Utility : object {
    public static string Strip(string s, int n);
    public static string TrimOneStartingNewline(string s);
    public static string TrimOneTrailingNewline(string s);
    public static string GetParent(string name);
    public static string GetPrefix(string name);
    public static string ReplaceEscapes(string s);
    public static string ReplaceEscapedRightAngle(string s);
    public static Coordinate GetLineCharPosition(string s, int index);
}
public class Antlr4.StringTemplate.NoIndentWriter : AutoIndentWriter {
    public NoIndentWriter(TextWriter writer);
    protected virtual int Indent();
}
public class Antlr4.StringTemplate.NumberRenderer : object {
    public virtual string ToString(object o, string formatString, CultureInfo culture);
}
public enum Antlr4.StringTemplate.RenderOption : Enum {
    public int value__;
    public static RenderOption Anchor;
    public static RenderOption Format;
    public static RenderOption Null;
    public static RenderOption Separator;
    public static RenderOption Wrap;
}
public class Antlr4.StringTemplate.StringRenderer : object {
    public virtual string ToString(object o, string formatString, CultureInfo culture);
}
public class Antlr4.StringTemplate.Template : object {
    public static string UnknownName;
    public static object EmptyAttribute;
    public static string ImplicitArgumentName;
    public CompiledTemplate impl;
    protected internal Object[] locals;
    private TemplateGroup groupThatCreatedThisInstance;
    private TemplateDebugState _debugState;
    public TemplateDebugState DebugState { get; public set; }
    public TemplateGroup Group { get; public set; }
    public string Name { get; }
    public bool IsAnonymousSubtemplate { get; }
    internal Template(TemplateGroup group);
    public Template(string template);
    public Template(string template, char delimiterStartChar, char delimiterStopChar);
    public Template(TemplateGroup group, string template);
    public Template(Template prototype);
    protected Template(Template prototype, bool shadowLocals);
    private static Template();
    public TemplateDebugState get_DebugState();
    public void set_DebugState(TemplateDebugState value);
    public TemplateGroup get_Group();
    public void set_Group(TemplateGroup value);
    public virtual Template CreateShadow();
    public virtual Template Add(string name, object value);
    public Template AddMany(string aggrSpec, Object[] values);
    public virtual void Remove(string name);
    protected internal virtual void RawSetAttribute(string name, object value);
    public virtual object GetAttribute(string name);
    public virtual IDictionary`2<string, object> GetAttributes();
    protected static AttributeList ConvertToAttributeList(object curvalue);
    public virtual string get_Name();
    public virtual bool get_IsAnonymousSubtemplate();
    public virtual int Write(ITemplateWriter out);
    public virtual int Write(ITemplateWriter out, CultureInfo culture);
    public virtual int Write(ITemplateWriter out, ITemplateErrorListener listener);
    public virtual int Write(ITemplateWriter out, CultureInfo culture, ITemplateErrorListener listener);
    public virtual int Write(TextWriter writer, ITemplateErrorListener listener);
    public virtual int Write(TextWriter writer, ITemplateErrorListener listener, int lineWidth);
    public virtual int Write(TextWriter writer, CultureInfo culture, ITemplateErrorListener listener, int lineWidth);
    public virtual string Render();
    public virtual string Render(int lineWidth);
    public virtual string Render(CultureInfo culture);
    public virtual string Render(CultureInfo culture, int lineWidth);
    public virtual List`1<InterpEvent> GetEvents();
    public virtual List`1<InterpEvent> GetEvents(int lineWidth);
    public virtual List`1<InterpEvent> GetEvents(ITemplateWriter writer);
    public virtual List`1<InterpEvent> GetEvents(CultureInfo locale);
    public virtual List`1<InterpEvent> GetEvents(CultureInfo locale, int lineWidth);
    public virtual List`1<InterpEvent> GetEvents(CultureInfo culture, ITemplateWriter writer);
    public virtual string ToString();
    public static string Format(string template, Object[] attributes);
    public static string Format(int lineWidth, string template, Object[] attributes);
}
public class Antlr4.StringTemplate.TemplateFrame : object {
    private Template _template;
    private TemplateFrame _parent;
    private int _depth;
    private int _ip;
    private DebugEvents _debugState;
    public Template Template { get; }
    public TemplateFrame Parent { get; }
    public int StackDepth { get; }
    public int InstructionPointer { get; public set; }
    public TemplateFrame(Template template, TemplateFrame parent);
    public Template get_Template();
    public TemplateFrame get_Parent();
    public int get_StackDepth();
    public int get_InstructionPointer();
    public void set_InstructionPointer(int value);
    public DebugEvents GetDebugState();
    public string GetEnclosingInstanceStackString();
    public List`1<Template> GetEnclosingInstanceStack(bool topdown);
    public List`1<TemplateFrame> GetFrameStack(bool topdown);
    public List`1<EvalTemplateEvent> GetEvalTemplateEventStack(bool topdown);
}
public class Antlr4.StringTemplate.TemplateGroup : object {
    public static string GroupFileExtension;
    public static string TemplateFileExtension;
    public static string DictionaryKey;
    public static string DefaultKey;
    private Encoding _encoding;
    private List`1<TemplateGroup> _imports;
    private List`1<TemplateGroup> _importsToClearOnUnload;
    private char delimiterStartChar;
    private char delimiterStopChar;
    private Dictionary`2<string, CompiledTemplate> templates;
    private Dictionary`2<string, IDictionary`2<string, object>> dictionaries;
    private TypeRegistry`1<IAttributeRenderer> renderers;
    private TypeRegistry`1<ITypeProxyFactory> _proxyFactories;
    protected TypeRegistry`1<IModelAdaptor> adaptors;
    private bool _verbose;
    private bool _enableCache;
    private bool _trackCreationEvents;
    private bool _iterateAcrossValues;
    protected static CompiledTemplate NotFoundTemplate;
    private static ErrorManager _defaultErrorManager;
    private static TemplateGroup _defaultGroup;
    private ErrorManager _errorManager;
    public static ErrorManager DefaultErrorManager { get; }
    public static TemplateGroup DefaultGroup { get; public set; }
    public char DelimiterStartChar { get; }
    public char DelimiterStopChar { get; }
    public ICollection`1<CompiledTemplate> CompiledTemplates { get; }
    public Encoding Encoding { get; public set; }
    public ErrorManager ErrorManager { get; public set; }
    public bool Verbose { get; public set; }
    public bool EnableCache { get; public set; }
    public bool TrackCreationEvents { get; public set; }
    public bool IterateAcrossValues { get; public set; }
    public ReadOnlyCollection`1<TemplateGroup> ImportedGroups { get; }
    public string Name { get; }
    public string FileName { get; }
    public Uri RootDirUri { get; }
    public ITemplateErrorListener Listener { get; public set; }
    public TemplateGroup(char delimiterStartChar, char delimiterStopChar);
    private static TemplateGroup();
    public static ErrorManager get_DefaultErrorManager();
    public static TemplateGroup get_DefaultGroup();
    public static void set_DefaultGroup(TemplateGroup value);
    public char get_DelimiterStartChar();
    public char get_DelimiterStopChar();
    public ICollection`1<CompiledTemplate> get_CompiledTemplates();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public ErrorManager get_ErrorManager();
    public void set_ErrorManager(ErrorManager value);
    public bool get_Verbose();
    public void set_Verbose(bool value);
    public bool get_EnableCache();
    public void set_EnableCache(bool value);
    public bool get_TrackCreationEvents();
    public void set_TrackCreationEvents(bool value);
    public bool get_IterateAcrossValues();
    public void set_IterateAcrossValues(bool value);
    public ReadOnlyCollection`1<TemplateGroup> get_ImportedGroups();
    public virtual Template GetInstanceOf(string name);
    protected internal virtual Template GetEmbeddedInstanceOf(TemplateFrame frame, string name);
    public virtual Template CreateSingleton(IToken templateToken);
    public virtual bool IsDefined(string name);
    public virtual CompiledTemplate LookupTemplate(string name);
    public virtual void Unload();
    protected virtual CompiledTemplate Load(string name);
    public virtual void Load();
    protected internal virtual CompiledTemplate LookupImportedTemplate(string name);
    public virtual CompiledTemplate RawGetTemplate(string name);
    public virtual IDictionary`2<string, object> RawGetDictionary(string name);
    public virtual bool IsDictionary(string name);
    public virtual CompiledTemplate DefineTemplate(string name, string template);
    public virtual CompiledTemplate DefineTemplate(string name, string template, String[] arguments);
    public virtual CompiledTemplate DefineTemplate(string fullyQualifiedTemplateName, IToken nameT, List`1<FormalArgument> args, string template, IToken templateToken);
    public virtual CompiledTemplate DefineTemplateAlias(IToken aliasT, IToken targetT);
    public virtual CompiledTemplate DefineRegion(string enclosingTemplateName, IToken regionT, string template, IToken templateToken);
    public virtual void DefineTemplateOrRegion(string fullyQualifiedTemplateName, string regionSurroundingTemplateName, IToken templateToken, string template, IToken nameToken, List`1<FormalArgument> args);
    public virtual void RawDefineTemplate(string name, CompiledTemplate code, IToken defT);
    public virtual void UndefineTemplate(string name);
    public virtual CompiledTemplate Compile(string srcName, string name, List`1<FormalArgument> args, string template, IToken templateToken);
    public static string GetMangledRegionName(string enclosingTemplateName, string name);
    public static string GetUnmangledTemplateName(string mangledName);
    public virtual void DefineDictionary(string name, IDictionary`2<string, object> mapping);
    public virtual void SetDelimiters(IToken openDelimiter, IToken closeDelimiter);
    public virtual void SetDelimiters(char delimiterStartChar, char delimiterStopChar);
    public virtual void ImportTemplates(TemplateGroup g);
    private void ImportTemplates(TemplateGroup group, bool clearOnUnload);
    public virtual void ImportTemplates(IToken fileNameToken);
    public virtual void LoadGroupFile(string prefix, string fileName);
    private bool TryLoadGroupFromCache(string cachePath, string prefix, string fileName);
    private bool TryLoadCachedGroup(Byte[] data, DateTime lastWriteTime);
    private object CreateGroupObject(BinaryReader reader, int key, Dictionary`2<int, object> objects);
    private void LoadGroupObject(BinaryReader reader, int key, Dictionary`2<int, object> objects);
    private void CacheCompiledGroup(string cachePath, string prefix, string fileName, DateTime lastWriteTime);
    private List`1<object> GetOrderedExports(IEnumerable`1<object> serializedObjects);
    private void GetOrderedExports(object currentObject, List`1<object> exportList, HashSet`1<object> visited);
    private void WriteGroupObjectReference(BinaryWriter writer, object obj);
    private void WriteGroupObject(BinaryWriter writer, object obj);
    private HashSet`1<object> CalculateReachableSerializedObjects(ICollection`1<object> rootSet);
    private void CalculateReachableSerializedObjects(object obj, HashSet`1<object> reachableObjects);
    public virtual CompiledTemplate LoadAbsoluteTemplateFile(string fileName);
    public virtual CompiledTemplate LoadTemplateFile(string prefix, string unqualifiedFileName, ICharStream templateStream);
    public virtual void RegisterModelAdaptor(Type attributeType, IModelAdaptor adaptor);
    public virtual IModelAdaptor GetModelAdaptor(Type attributeType);
    public void RegisterRenderer(Type attributeType, IAttributeRenderer renderer);
    public virtual void RegisterRenderer(Type attributeType, IAttributeRenderer renderer, bool recursive);
    public virtual IAttributeRenderer GetAttributeRenderer(Type attributeType);
    public virtual void RegisterTypeProxyFactory(Type targetType, ITypeProxyFactory factory);
    public virtual ITypeProxyFactory GetTypeProxyFactory(Type targetType);
    public virtual Template CreateStringTemplate();
    public virtual Template CreateStringTemplate(CompiledTemplate impl);
    public Template CreateStringTemplateInternally(CompiledTemplate impl);
    public Template CreateStringTemplateInternally(Template prototype);
    public virtual string get_Name();
    public virtual string get_FileName();
    public virtual Uri get_RootDirUri();
    public virtual string ToString();
    public virtual string Show();
    public virtual ITemplateErrorListener get_Listener();
    public virtual void set_Listener(ITemplateErrorListener value);
    public virtual HashSet`1<string> GetTemplateNames();
}
public class Antlr4.StringTemplate.TemplateGroupDirectory : TemplateGroup {
    public string groupDirName;
    public Uri root;
    public string Name { get; }
    public string FileName { get; }
    public Uri RootDirUri { get; }
    public TemplateGroupDirectory(string dirName);
    public TemplateGroupDirectory(string dirName, char delimiterStartChar, char delimiterStopChar);
    public TemplateGroupDirectory(string dirName, Encoding encoding);
    public TemplateGroupDirectory(string dirName, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public TemplateGroupDirectory(Uri root, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public virtual void ImportTemplates(IToken fileNameToken);
    protected virtual CompiledTemplate Load(string name);
    public virtual CompiledTemplate LoadTemplateFile(string prefix, string unqualifiedFileName);
    public virtual string get_Name();
    public virtual string get_FileName();
    public virtual Uri get_RootDirUri();
}
public class Antlr4.StringTemplate.TemplateGroupFile : TemplateGroup {
    private string _fileName;
    private Uri _url;
    private bool _alreadyLoaded;
    public string Name { get; }
    public string FileName { get; }
    public Uri RootDirUri { get; }
    public TemplateGroupFile(string fileName);
    public TemplateGroupFile(string fileName, char delimiterStartChar, char delimiterStopChar);
    public TemplateGroupFile(string fullyQualifiedFileName, Encoding encoding);
    public TemplateGroupFile(string fullyQualifiedFileName, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public TemplateGroupFile(Uri url, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public virtual bool IsDefined(string name);
    public virtual void Unload();
    protected virtual CompiledTemplate Load(string name);
    public virtual void Load();
    public virtual string Show();
    public virtual string get_Name();
    public virtual string get_FileName();
    public virtual Uri get_RootDirUri();
}
public class Antlr4.StringTemplate.TemplateGroupString : TemplateGroup {
    private string sourceName;
    private string text;
    private bool alreadyLoaded;
    public string FileName { get; }
    public TemplateGroupString(string text);
    public TemplateGroupString(string sourceName, string text);
    public TemplateGroupString(string sourceName, string text, char delimiterStartChar, char delimiterStopChar);
    public virtual string get_FileName();
    public virtual bool IsDefined(string name);
    public virtual void Load();
    protected virtual CompiledTemplate Load(string name);
}
public class Antlr4.StringTemplate.TemplateName : object {
    private static Regex NameFormatRegex;
    private string _name;
    public bool IsRooted { get; }
    public bool IsTemplate { get; }
    public string Name { get; }
    public TemplateName(string name);
    private static TemplateName();
    public bool get_IsRooted();
    public bool get_IsTemplate();
    public string get_Name();
    public static TemplateName op_Implicit(string name);
    public static string GetTemplatePath(string localPathRoot, TemplateName templateName);
}
public class Antlr4.StringTemplate.TemplateRawGroupDirectory : TemplateGroupDirectory {
    public TemplateRawGroupDirectory(string dirName);
    public TemplateRawGroupDirectory(string dirName, char delimiterStartChar, char delimiterStopChar);
    public TemplateRawGroupDirectory(string dirName, Encoding encoding);
    public TemplateRawGroupDirectory(string dirName, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public TemplateRawGroupDirectory(Uri root, Encoding encoding, char delimiterStartChar, char delimiterStopChar);
    public virtual CompiledTemplate LoadTemplateFile(string prefix, string unqualifiedFileName, ICharStream templateStream);
}
