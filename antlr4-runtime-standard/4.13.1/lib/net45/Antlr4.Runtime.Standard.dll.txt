public class Antlr4.Runtime.AntlrFileStream : AntlrInputStream {
    protected internal string fileName;
    public string SourceName { get; }
    public AntlrFileStream(string fileName);
    public AntlrFileStream(string fileName, Encoding encoding);
    public virtual void Load(string fileName, Encoding encoding);
    public virtual string get_SourceName();
}
public class Antlr4.Runtime.AntlrInputStream : BaseInputCharStream {
    protected internal Char[] data;
    public AntlrInputStream(string input);
    public AntlrInputStream(Char[] data, int numberOfActualCharsInArray);
    public AntlrInputStream(TextReader r);
    public AntlrInputStream(TextReader r, int initialSize);
    public AntlrInputStream(TextReader r, int initialSize, int readChunkSize);
    public AntlrInputStream(Stream input);
    public AntlrInputStream(Stream input, int initialSize);
    public AntlrInputStream(Stream input, int initialSize, int readChunkSize);
    public virtual void Load(TextReader r, int size, int readChunkSize);
    protected virtual int ValueAt(int i);
    protected virtual string ConvertDataToString(int start, int count);
}
public abstract class Antlr4.Runtime.Atn.AbstractPredicateTransition : Transition {
    public AbstractPredicateTransition(ATNState target);
}
public class Antlr4.Runtime.Atn.ActionTransition : Transition {
    public int ruleIndex;
    public int actionIndex;
    public bool isCtxDependent;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public ActionTransition(ATNState target, int ruleIndex);
    public ActionTransition(ATNState target, int ruleIndex, int actionIndex, bool isCtxDependent);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.AmbiguityInfo : DecisionEventInfo {
    public BitSet ambigAlts;
    public AmbiguityInfo(int decision, ATNConfigSet configs, BitSet ambigAlts, ITokenStream input, int startIndex, int stopIndex, bool fullCtx);
}
public class Antlr4.Runtime.Atn.ArrayPredictionContext : PredictionContext {
    public PredictionContext[] parents;
    public Int32[] returnStates;
    public bool IsEmpty { get; }
    public int Size { get; }
    public ArrayPredictionContext(SingletonPredictionContext a);
    public ArrayPredictionContext(PredictionContext[] parents, Int32[] returnStates);
    public virtual bool get_IsEmpty();
    public virtual int get_Size();
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual bool Equals(object o);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.ATN : object {
    public static int INVALID_ALT_NUMBER;
    [NotNullAttribute]
public IList`1<ATNState> states;
    [NotNullAttribute]
public IList`1<DecisionState> decisionToState;
    public RuleStartState[] ruleToStartState;
    public RuleStopState[] ruleToStopState;
    [NotNullAttribute]
public IDictionary`2<string, TokensStartState> modeNameToStartState;
    public ATNType grammarType;
    public int maxTokenType;
    public Int32[] ruleToTokenType;
    public ILexerAction[] lexerActions;
    [NotNullAttribute]
public IList`1<TokensStartState> modeToStartState;
    private PredictionContextCache contextCache;
    [NotNullAttribute]
public DFA[] decisionToDFA;
    [NotNullAttribute]
public DFA[] modeToDFA;
    protected internal ConcurrentDictionary`2<int, int> LL1Table;
    public int NumberOfDecisions { get; }
    public ATN(ATNType grammarType, int maxTokenType);
    public virtual PredictionContext GetCachedContext(PredictionContext context);
    public virtual IntervalSet NextTokens(ATNState s, RuleContext ctx);
    public virtual IntervalSet NextTokens(ATNState s);
    public virtual void AddState(ATNState state);
    public virtual void RemoveState(ATNState state);
    public virtual void DefineMode(string name, TokensStartState s);
    public virtual int DefineDecisionState(DecisionState s);
    public virtual DecisionState GetDecisionState(int decision);
    public virtual int get_NumberOfDecisions();
    public virtual IntervalSet GetExpectedTokens(int stateNumber, RuleContext context);
}
public class Antlr4.Runtime.Atn.ATNConfig : object {
    private static int SUPPRESS_PRECEDENCE_FILTER;
    public ATNState state;
    public int alt;
    public PredictionContext context;
    public int reachesIntoOuterContext;
    public SemanticContext semanticContext;
    public int OuterContextDepth { get; }
    public bool IsPrecedenceFilterSuppressed { get; }
    public ATNConfig(ATNConfig old);
    public ATNConfig(ATNState state, int alt, PredictionContext context);
    public ATNConfig(ATNState state, int alt, PredictionContext context, SemanticContext semanticContext);
    public ATNConfig(ATNConfig c, ATNState state);
    public ATNConfig(ATNConfig c, ATNState state, SemanticContext semanticContext);
    public ATNConfig(ATNConfig c, SemanticContext semanticContext);
    public ATNConfig(ATNConfig c, ATNState state, PredictionContext context);
    public ATNConfig(ATNConfig c, ATNState state, PredictionContext context, SemanticContext semanticContext);
    private static ATNConfig();
    public int get_OuterContextDepth();
    public bool get_IsPrecedenceFilterSuppressed();
    public void SetPrecedenceFilterSuppressed(bool value);
    public virtual bool Equals(object o);
    public virtual bool Equals(ATNConfig other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IRecognizer recog, bool showAlt);
}
public class Antlr4.Runtime.Atn.ATNConfigSet : object {
    protected bool readOnly;
    public ConfigHashSet configLookup;
    public ArrayList`1<ATNConfig> configs;
    public int uniqueAlt;
    public BitSet conflictingAlts;
    public bool hasSemanticContext;
    public bool dipsIntoOuterContext;
    public bool fullCtx;
    private int cachedHashCode;
    public List`1<ATNConfig> Elements { get; }
    public int Count { get; }
    public bool Empty { get; }
    public bool IsReadOnly { get; public set; }
    public ATNConfigSet(bool fullCtx);
    public ATNConfigSet(ATNConfigSet old);
    public bool Add(ATNConfig config);
    public bool Add(ATNConfig config, MergeCache mergeCache);
    public List`1<ATNConfig> get_Elements();
    public HashSet`1<ATNState> GetStates();
    public BitSet GetAlts();
    public List`1<SemanticContext> GetPredicates();
    public ATNConfig Get(int i);
    public void OptimizeConfigs(ATNSimulator interpreter);
    public bool AddAll(ICollection`1<ATNConfig> coll);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public int get_Count();
    public bool get_Empty();
    public bool Contains(object o);
    public void Clear();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.ATNDeserializationOptions : object {
    private static ATNDeserializationOptions defaultOptions;
    private bool readOnly;
    private bool verifyATN;
    private bool generateRuleBypassTransitions;
    private bool optimize;
    [NotNullAttribute]
public static ATNDeserializationOptions Default { get; }
    public bool IsReadOnly { get; }
    public bool VerifyAtn { get; public set; }
    public bool GenerateRuleBypassTransitions { get; public set; }
    public bool Optimize { get; public set; }
    private static ATNDeserializationOptions();
    public ATNDeserializationOptions(ATNDeserializationOptions options);
    public static ATNDeserializationOptions get_Default();
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public bool get_VerifyAtn();
    public void set_VerifyAtn(bool value);
    public bool get_GenerateRuleBypassTransitions();
    public void set_GenerateRuleBypassTransitions(bool value);
    public bool get_Optimize();
    public void set_Optimize(bool value);
    protected internal virtual void ThrowIfReadOnly();
}
public class Antlr4.Runtime.Atn.ATNDeserializer : object {
    public static int SerializedVersion;
    [NotNullAttribute]
private ATNDeserializationOptions deserializationOptions;
    private Int32[] data;
    private int p;
    public ATNDeserializer(ATNDeserializationOptions deserializationOptions);
    private static ATNDeserializer();
    public virtual ATN Deserialize(Int32[] data);
    protected internal virtual void OptimizeATN(ATN atn);
    protected internal virtual void GenerateRuleBypassTransitions(ATN atn);
    protected internal virtual void ReadLexerActions(ATN atn);
    protected internal virtual void ReadDecisions(ATN atn);
    protected internal virtual void ReadEdges(ATN atn, IList`1<IntervalSet> sets);
    protected internal virtual void ReadSets(ATN atn, IList`1<IntervalSet> sets);
    protected internal virtual void ReadModes(ATN atn);
    protected internal virtual void ReadRules(ATN atn);
    protected internal virtual void ReadStates(ATN atn);
    protected internal virtual ATN ReadATN();
    protected internal virtual void CheckVersion();
    protected internal virtual void MarkPrecedenceDecisions(ATN atn);
    protected internal virtual void VerifyATN(ATN atn);
    protected internal virtual void CheckCondition(bool condition);
    protected internal virtual void CheckCondition(bool condition, string message);
    private static int InlineSetRules(ATN atn);
    private static int CombineChainedEpsilons(ATN atn);
    private static int OptimizeSets(ATN atn, bool preserveOrder);
    private static void IdentifyTailCalls(ATN atn);
    private static bool TestTailCall(ATN atn, RuleTransition transition, bool optimizedPath);
    protected internal int ReadInt();
    protected internal virtual Transition EdgeFactory(ATN atn, TransitionType type, int src, int trg, int arg1, int arg2, int arg3, IList`1<IntervalSet> sets);
    protected internal virtual ATNState StateFactory(StateType type, int ruleIndex);
    protected internal virtual ILexerAction LexerActionFactory(LexerActionType type, int data1, int data2);
}
public abstract class Antlr4.Runtime.Atn.ATNSimulator : object {
    public static DFAState ERROR;
    public ATN atn;
    protected PredictionContextCache sharedContextCache;
    public ATNSimulator(ATN atn, PredictionContextCache sharedContextCache);
    private static ATNSimulator();
    private static DFAState InitERROR();
    public abstract virtual void Reset();
    public virtual void ClearDFA();
    public PredictionContextCache getSharedContextCache();
    public PredictionContext getCachedContext(PredictionContext context);
}
public abstract class Antlr4.Runtime.Atn.ATNState : object {
    public static int InitialNumTransitions;
    public static ReadOnlyCollection`1<string> serializationNames;
    public static int InvalidStateNumber;
    public ATN atn;
    public int stateNumber;
    public int ruleIndex;
    public bool epsilonOnlyTransitions;
    protected internal List`1<Transition> transitions;
    protected internal List`1<Transition> optimizedTransitions;
    public IntervalSet nextTokenWithinRule;
    public int NonStopStateNumber { get; }
    public bool IsNonGreedyExitState { get; }
    public Transition[] TransitionsArray { get; }
    public int NumberOfTransitions { get; }
    public StateType StateType { get; }
    public bool OnlyHasEpsilonTransitions { get; }
    public bool IsOptimized { get; }
    public int NumberOfOptimizedTransitions { get; }
    private static ATNState();
    public virtual int get_NonStopStateNumber();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual bool get_IsNonGreedyExitState();
    public virtual string ToString();
    public virtual Transition[] get_TransitionsArray();
    public virtual int get_NumberOfTransitions();
    public virtual void AddTransition(Transition e);
    public virtual void AddTransition(int index, Transition e);
    public virtual Transition Transition(int i);
    public virtual void SetTransition(int i, Transition e);
    public virtual void RemoveTransition(int index);
    public abstract virtual StateType get_StateType();
    public bool get_OnlyHasEpsilonTransitions();
    public virtual void SetRuleIndex(int ruleIndex);
    public virtual bool get_IsOptimized();
    public virtual int get_NumberOfOptimizedTransitions();
    public virtual Transition GetOptimizedTransition(int i);
    public virtual void AddOptimizedTransition(Transition e);
    public virtual void SetOptimizedTransition(int i, Transition e);
    public virtual void RemoveOptimizedTransition(int i);
}
public enum Antlr4.Runtime.Atn.ATNType : Enum {
    public int value__;
    public static ATNType Lexer;
    public static ATNType Parser;
}
public class Antlr4.Runtime.Atn.AtomTransition : Transition {
    public int token;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public AtomTransition(ATNState target, int token);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.BasicBlockStartState : BlockStartState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.BasicState : ATNState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.BlockEndState : ATNState {
    public BlockStartState startState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public abstract class Antlr4.Runtime.Atn.BlockStartState : DecisionState {
    public BlockEndState endState;
}
public class Antlr4.Runtime.Atn.ConfigEqualityComparator : object {
    public sealed virtual int GetHashCode(ATNConfig o);
    public sealed virtual bool Equals(ATNConfig a, ATNConfig b);
}
public class Antlr4.Runtime.Atn.ConfigHashSet : Dictionary`2<ATNConfig, ATNConfig> {
    public ConfigHashSet(IEqualityComparer`1<ATNConfig> comparer);
    public ATNConfig GetOrAdd(ATNConfig config);
}
public class Antlr4.Runtime.Atn.ConflictInfo : object {
    private BitSet conflictedAlts;
    private bool exact;
    public BitSet ConflictedAlts { get; }
    public bool IsExact { get; }
    public ConflictInfo(BitSet conflictedAlts, bool exact);
    public BitSet get_ConflictedAlts();
    public bool get_IsExact();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Antlr4.Runtime.Atn.ContextSensitivityInfo : DecisionEventInfo {
    public ContextSensitivityInfo(int decision, ATNConfigSet configs, ITokenStream input, int startIndex, int stopIndex);
}
public class Antlr4.Runtime.Atn.DecisionEventInfo : object {
    public int decision;
    public ATNConfigSet configs;
    [NotNullAttribute]
public ITokenStream input;
    public int startIndex;
    public int stopIndex;
    public bool fullCtx;
    public DecisionEventInfo(int decision, ATNConfigSet configs, ITokenStream input, int startIndex, int stopIndex, bool fullCtx);
}
public class Antlr4.Runtime.Atn.DecisionInfo : object {
    public int decision;
    public long invocations;
    public long timeInPrediction;
    public long SLL_TotalLook;
    public long SLL_MinLook;
    public long SLL_MaxLook;
    public LookaheadEventInfo SLL_MaxLookEvent;
    public long LL_TotalLook;
    public long LL_MinLook;
    public long LL_MaxLook;
    public LookaheadEventInfo LL_MaxLookEvent;
    public List`1<ContextSensitivityInfo> contextSensitivities;
    public List`1<ErrorInfo> errors;
    public List`1<AmbiguityInfo> ambiguities;
    public List`1<PredicateEvalInfo> predicateEvals;
    public long SLL_ATNTransitions;
    public long SLL_DFATransitions;
    public long LL_Fallback;
    public long LL_ATNTransitions;
    public long LL_DFATransitions;
    public DecisionInfo(int decision);
    public virtual string ToString();
}
public abstract class Antlr4.Runtime.Atn.DecisionState : ATNState {
    public int decision;
    public bool nonGreedy;
}
public class Antlr4.Runtime.Atn.EmptyPredictionContext : SingletonPredictionContext {
    public static EmptyPredictionContext Instance;
    public int Size { get; }
    public bool IsEmpty { get; }
    private static EmptyPredictionContext();
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual int get_Size();
    public virtual bool get_IsEmpty();
    public virtual bool Equals(object o);
    public virtual string ToString();
    public virtual String[] ToStrings(IRecognizer recognizer, int currentState);
    public virtual String[] ToStrings(IRecognizer recognizer, PredictionContext stop, int currentState);
}
public class Antlr4.Runtime.Atn.EpsilonTransition : Transition {
    private int outermostPrecedenceReturn;
    public int OutermostPrecedenceReturn { get; }
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public EpsilonTransition(ATNState target);
    public EpsilonTransition(ATNState target, int outermostPrecedenceReturn);
    public int get_OutermostPrecedenceReturn();
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.ErrorInfo : DecisionEventInfo {
    public ErrorInfo(int decision, ATNConfigSet configs, ITokenStream input, int startIndex, int stopIndex, bool fullCtx);
}
public interface Antlr4.Runtime.Atn.ILexerAction {
    [NotNullAttribute]
public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public abstract virtual LexerActionType get_ActionType();
    public abstract virtual bool get_IsPositionDependent();
    public abstract virtual void Execute(Lexer lexer);
}
public class Antlr4.Runtime.Atn.LexerActionExecutor : object {
    [NotNullAttribute]
private ILexerAction[] lexerActions;
    private int hashCode;
    [NotNullAttribute]
public ILexerAction[] LexerActions { get; }
    public LexerActionExecutor(ILexerAction[] lexerActions);
    public static LexerActionExecutor Append(LexerActionExecutor lexerActionExecutor, ILexerAction lexerAction);
    public virtual LexerActionExecutor FixOffsetBeforeMatch(int offset);
    public virtual ILexerAction[] get_LexerActions();
    public virtual void Execute(Lexer lexer, ICharStream input, int startIndex);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public enum Antlr4.Runtime.Atn.LexerActionType : Enum {
    public int value__;
    public static LexerActionType Channel;
    public static LexerActionType Custom;
    public static LexerActionType Mode;
    public static LexerActionType More;
    public static LexerActionType PopMode;
    public static LexerActionType PushMode;
    public static LexerActionType Skip;
    public static LexerActionType Type;
}
public class Antlr4.Runtime.Atn.LexerATNConfig : ATNConfig {
    private LexerActionExecutor lexerActionExecutor;
    private bool passedThroughNonGreedyDecision;
    public LexerATNConfig(ATNState state, int alt, PredictionContext context);
    public LexerATNConfig(ATNState state, int alt, PredictionContext context, LexerActionExecutor lexerActionExecutor);
    public LexerATNConfig(LexerATNConfig c, ATNState state);
    public LexerATNConfig(LexerATNConfig c, ATNState state, LexerActionExecutor lexerActionExecutor);
    public LexerATNConfig(LexerATNConfig c, ATNState state, PredictionContext context);
    public LexerActionExecutor getLexerActionExecutor();
    public bool hasPassedThroughNonGreedyDecision();
    public virtual int GetHashCode();
    public virtual bool Equals(ATNConfig other);
    private static bool checkNonGreedyDecision(LexerATNConfig source, ATNState target);
}
public class Antlr4.Runtime.Atn.LexerATNSimulator : ATNSimulator {
    public bool debug;
    public bool dfa_debug;
    public static int MIN_DFA_EDGE;
    public static int MAX_DFA_EDGE;
    protected Lexer recog;
    protected int startIndex;
    protected int thisLine;
    protected int charPositionInLine;
    public DFA[] decisionToDFA;
    protected int mode;
    private SimState prevAccept;
    public int Line { get; public set; }
    public int Column { get; public set; }
    public LexerATNSimulator(ATN atn, DFA[] decisionToDFA, PredictionContextCache sharedContextCache);
    public LexerATNSimulator(Lexer recog, ATN atn, DFA[] decisionToDFA, PredictionContextCache sharedContextCache);
    private static LexerATNSimulator();
    public void CopyState(LexerATNSimulator simulator);
    public int Match(ICharStream input, int mode);
    public virtual void Reset();
    public virtual void ClearDFA();
    protected int MatchATN(ICharStream input);
    protected int ExecATN(ICharStream input, DFAState ds0);
    protected DFAState GetExistingTargetState(DFAState s, int t);
    protected DFAState ComputeTargetState(ICharStream input, DFAState s, int t);
    protected int FailOrAccept(SimState prevAccept, ICharStream input, ATNConfigSet reach, int t);
    protected void GetReachableConfigSet(ICharStream input, ATNConfigSet closure, ATNConfigSet reach, int t);
    protected void Accept(ICharStream input, LexerActionExecutor lexerActionExecutor, int startIndex, int index, int line, int charPos);
    protected ATNState GetReachableTarget(Transition trans, int t);
    protected ATNConfigSet ComputeStartState(ICharStream input, ATNState p);
    protected bool Closure(ICharStream input, LexerATNConfig config, ATNConfigSet configs, bool currentAltReachedAcceptState, bool speculative, bool treatEofAsEpsilon);
    protected LexerATNConfig GetEpsilonTarget(ICharStream input, LexerATNConfig config, Transition t, ATNConfigSet configs, bool speculative, bool treatEofAsEpsilon);
    protected bool EvaluatePredicate(ICharStream input, int ruleIndex, int predIndex, bool speculative);
    protected void CaptureSimState(SimState settings, ICharStream input, DFAState dfaState);
    protected DFAState AddDFAEdge(DFAState from, int t, ATNConfigSet q);
    protected void AddDFAEdge(DFAState p, int t, DFAState q);
    protected DFAState AddDFAState(ATNConfigSet configSet);
    public DFA GetDFA(int mode);
    public string GetText(ICharStream input);
    public int get_Line();
    public void set_Line(int value);
    public int get_Column();
    public void set_Column(int value);
    public virtual void Consume(ICharStream input);
    public string GetTokenName(int t);
}
public class Antlr4.Runtime.Atn.LexerChannelAction : object {
    private int channel;
    public int Channel { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerChannelAction(int channel);
    public int get_Channel();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerCustomAction : object {
    private int ruleIndex;
    private int actionIndex;
    public int RuleIndex { get; }
    public int ActionIndex { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerCustomAction(int ruleIndex, int actionIndex);
    public int get_RuleIndex();
    public int get_ActionIndex();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Antlr4.Runtime.Atn.LexerIndexedCustomAction : object {
    private int offset;
    private ILexerAction action;
    public int Offset { get; }
    [NotNullAttribute]
public ILexerAction Action { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerIndexedCustomAction(int offset, ILexerAction action);
    public int get_Offset();
    public ILexerAction get_Action();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Antlr4.Runtime.Atn.LexerModeAction : object {
    private int mode;
    public int Mode { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerModeAction(int mode);
    public int get_Mode();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerMoreAction : object {
    public static LexerMoreAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerMoreAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerPopModeAction : object {
    public static LexerPopModeAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerPopModeAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerPushModeAction : object {
    private int mode;
    public int Mode { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerPushModeAction(int mode);
    public int get_Mode();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerSkipAction : object {
    public static LexerSkipAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerSkipAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerTypeAction : object {
    private int type;
    public int Type { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerTypeAction(int type);
    public virtual int get_Type();
    public virtual LexerActionType get_ActionType();
    public virtual bool get_IsPositionDependent();
    public virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LL1Analyzer : object {
    public static int HitPred;
    [NotNullAttribute]
public ATN atn;
    public LL1Analyzer(ATN atn);
    public virtual IntervalSet[] GetDecisionLookahead(ATNState s);
    public virtual IntervalSet Look(ATNState s, RuleContext ctx);
    public virtual IntervalSet Look(ATNState s, ATNState stopState, RuleContext ctx);
    protected internal virtual void Look_(ATNState s, ATNState stopState, PredictionContext ctx, IntervalSet look, HashSet`1<ATNConfig> lookBusy, BitSet calledRuleStack, bool seeThruPreds, bool addEOF);
}
public class Antlr4.Runtime.Atn.LookaheadEventInfo : DecisionEventInfo {
    public int predictedAlt;
    public LookaheadEventInfo(int decision, ATNConfigSet configs, int predictedAlt, ITokenStream input, int startIndex, int stopIndex, bool fullCtx);
}
public class Antlr4.Runtime.Atn.LoopEndState : ATNState {
    public ATNState loopBackState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.MergeCache : object {
    private Dictionary`2<PredictionContext, Dictionary`2<PredictionContext, PredictionContext>> data;
    public PredictionContext Get(PredictionContext a, PredictionContext b);
    public void Put(PredictionContext a, PredictionContext b, PredictionContext value);
}
public class Antlr4.Runtime.Atn.NotSetTransition : SetTransition {
    public TransitionType TransitionType { get; }
    public NotSetTransition(ATNState target, IntervalSet set);
    public virtual TransitionType get_TransitionType();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.ObjectEqualityComparator : object {
    public sealed virtual int GetHashCode(ATNConfig o);
    public sealed virtual bool Equals(ATNConfig a, ATNConfig b);
}
public class Antlr4.Runtime.Atn.OrderedATNConfigSet : ATNConfigSet {
}
public class Antlr4.Runtime.Atn.ParseInfo : object {
    protected ProfilingATNSimulator atnSimulator;
    public ParseInfo(ProfilingATNSimulator atnSimulator);
    public DecisionInfo[] getDecisionInfo();
    public List`1<int> getLLDecisions();
    public long getTotalTimeInPrediction();
    public long getTotalSLLLookaheadOps();
    public long getTotalLLLookaheadOps();
    public long getTotalSLLATNLookaheadOps();
    public long getTotalLLATNLookaheadOps();
    public long getTotalATNLookaheadOps();
    public int getDFASize();
    public int getDFASize(int decision);
}
public class Antlr4.Runtime.Atn.ParserATNSimulator : ATNSimulator {
    public static bool debug;
    public static bool trace_atn_sim;
    public static bool dfa_debug;
    public static bool retry_debug;
    protected Parser parser;
    public DFA[] decisionToDFA;
    private PredictionMode mode;
    protected MergeCache mergeCache;
    protected ITokenStream input;
    protected int startIndex;
    protected ParserRuleContext context;
    protected DFA thisDfa;
    public PredictionMode PredictionMode { get; public set; }
    public ParserATNSimulator(ATN atn, DFA[] decisionToDFA, PredictionContextCache sharedContextCache);
    public ParserATNSimulator(Parser parser, ATN atn, DFA[] decisionToDFA, PredictionContextCache sharedContextCache);
    public virtual void Reset();
    public virtual void ClearDFA();
    public virtual int AdaptivePredict(ITokenStream input, int decision, ParserRuleContext outerContext);
    protected int ExecATN(DFA dfa, DFAState s0, ITokenStream input, int startIndex, ParserRuleContext outerContext);
    protected virtual DFAState GetExistingTargetState(DFAState previousD, int t);
    protected virtual DFAState ComputeTargetState(DFA dfa, DFAState previousD, int t);
    protected void PredicateDFAState(DFAState dfaState, DecisionState decisionState);
    protected int ExecATNWithFullContext(DFA dfa, DFAState D, ATNConfigSet s0, ITokenStream input, int startIndex, ParserRuleContext outerContext);
    protected virtual ATNConfigSet ComputeReachSet(ATNConfigSet closure, int t, bool fullCtx);
    protected ATNConfigSet RemoveAllConfigsNotInRuleStopState(ATNConfigSet configSet, bool lookToEndOfRule);
    protected ATNConfigSet ComputeStartState(ATNState p, RuleContext ctx, bool fullCtx);
    protected ATNConfigSet ApplyPrecedenceFilter(ATNConfigSet configSet);
    protected ATNState GetReachableTarget(Transition trans, int ttype);
    protected SemanticContext[] GetPredsForAmbigAlts(BitSet ambigAlts, ATNConfigSet configSet, int nalts);
    protected PredPrediction[] GetPredicatePredictions(BitSet ambigAlts, SemanticContext[] altToPred);
    protected int GetSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(ATNConfigSet configs, ParserRuleContext outerContext);
    protected int getAltThatFinishedDecisionEntryRule(ATNConfigSet configSet);
    protected Pair`2<ATNConfigSet, ATNConfigSet> SplitAccordingToSemanticValidity(ATNConfigSet configSet, ParserRuleContext outerContext);
    protected virtual BitSet EvalSemanticContext(PredPrediction[] predPredictions, ParserRuleContext outerContext, bool complete);
    protected virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleContext parserCallStack, int alt, bool fullCtx);
    protected void Closure(ATNConfig config, ATNConfigSet configs, HashSet`1<ATNConfig> closureBusy, bool collectPredicates, bool fullCtx, bool treatEofAsEpsilon);
    protected void ClosureCheckingStopState(ATNConfig config, ATNConfigSet configSet, HashSet`1<ATNConfig> closureBusy, bool collectPredicates, bool fullCtx, int depth, bool treatEofAsEpsilon);
    protected void Closure_(ATNConfig config, ATNConfigSet configs, HashSet`1<ATNConfig> closureBusy, bool collectPredicates, bool fullCtx, int depth, bool treatEofAsEpsilon);
    protected bool CanDropLoopEntryEdgeInLeftRecursiveRule(ATNConfig config);
    public string GetRuleName(int index);
    protected ATNConfig GetEpsilonTarget(ATNConfig config, Transition t, bool collectPredicates, bool inContext, bool fullCtx, bool treatEofAsEpsilon);
    protected ATNConfig ActionTransition(ATNConfig config, ActionTransition t);
    public ATNConfig PrecedenceTransition(ATNConfig config, PrecedencePredicateTransition pt, bool collectPredicates, bool inContext, bool fullCtx);
    protected ATNConfig PredTransition(ATNConfig config, PredicateTransition pt, bool collectPredicates, bool inContext, bool fullCtx);
    protected ATNConfig RuleTransition(ATNConfig config, RuleTransition t);
    protected BitSet GetConflictingAlts(ATNConfigSet configSet);
    protected BitSet GetConflictingAltsOrUniqueAlt(ATNConfigSet configSet);
    public string GetTokenName(int t);
    public string GetLookaheadName(ITokenStream input);
    public void DumpDeadEndConfigs(NoViableAltException nvae);
    protected NoViableAltException NoViableAlt(ITokenStream input, ParserRuleContext outerContext, ATNConfigSet configs, int startIndex);
    protected static int GetUniqueAlt(ATNConfigSet configSet);
    protected DFAState AddDFAEdge(DFA dfa, DFAState from, int t, DFAState to);
    protected DFAState AddDFAState(DFA dfa, DFAState D);
    protected virtual void ReportAttemptingFullContext(DFA dfa, BitSet conflictingAlts, ATNConfigSet configs, int startIndex, int stopIndex);
    protected virtual void ReportContextSensitivity(DFA dfa, int prediction, ATNConfigSet configs, int startIndex, int stopIndex);
    protected virtual void ReportAmbiguity(DFA dfa, DFAState D, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public PredictionMode get_PredictionMode();
    public void set_PredictionMode(PredictionMode value);
    public Parser getParser();
}
public class Antlr4.Runtime.Atn.PlusBlockStartState : BlockStartState {
    public PlusLoopbackState loopBackState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.PlusLoopbackState : DecisionState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.PrecedencePredicateTransition : AbstractPredicateTransition {
    public int precedence;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public PrecedencePredicate Predicate { get; }
    public PrecedencePredicateTransition(ATNState target, int precedence);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public PrecedencePredicate get_Predicate();
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.PredicateEvalInfo : DecisionEventInfo {
    public SemanticContext semctx;
    public int predictedAlt;
    public bool evalResult;
    public PredicateEvalInfo(int decision, ITokenStream input, int startIndex, int stopIndex, SemanticContext semctx, bool evalResult, int predictedAlt, bool fullCtx);
}
public class Antlr4.Runtime.Atn.PredicateTransition : AbstractPredicateTransition {
    public int ruleIndex;
    public int predIndex;
    public bool isCtxDependent;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public Predicate Predicate { get; }
    public PredicateTransition(ATNState target, int ruleIndex, int predIndex, bool isCtxDependent);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public Predicate get_Predicate();
    public virtual string ToString();
}
public abstract class Antlr4.Runtime.Atn.PredictionContext : object {
    public static int EMPTY_RETURN_STATE;
    private static int INITIAL_HASH;
    private int cachedHashCode;
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmptyPath { get; }
    protected internal PredictionContext(int cachedHashCode);
    private static PredictionContext();
    protected internal static int CalculateEmptyHashCode();
    protected internal static int CalculateHashCode(PredictionContext parent, int returnState);
    protected internal static int CalculateHashCode(PredictionContext[] parents, Int32[] returnStates);
    public static PredictionContext FromRuleContext(ATN atn, RuleContext outerContext);
    public abstract virtual int get_Size();
    public abstract virtual PredictionContext GetParent(int index);
    public abstract virtual int GetReturnState(int index);
    public virtual bool get_IsEmpty();
    public virtual bool get_HasEmptyPath();
    public sealed virtual int GetHashCode();
    internal static PredictionContext Merge(PredictionContext a, PredictionContext b, bool rootIsWildcard, MergeCache mergeCache);
    public static PredictionContext MergeSingletons(SingletonPredictionContext a, SingletonPredictionContext b, bool rootIsWildcard, MergeCache mergeCache);
    public static PredictionContext MergeArrays(ArrayPredictionContext a, ArrayPredictionContext b, bool rootIsWildcard, MergeCache mergeCache);
    protected static void CombineCommonParents(PredictionContext[] parents);
    public static PredictionContext MergeRoot(SingletonPredictionContext a, SingletonPredictionContext b, bool rootIsWildcard);
    public static PredictionContext GetCachedContext(PredictionContext context, PredictionContextCache contextCache, IdentityHashMap visited);
    public virtual PredictionContext GetChild(int returnState);
    public virtual String[] ToStrings(IRecognizer recognizer, int currentState);
    public virtual String[] ToStrings(IRecognizer recognizer, PredictionContext stop, int currentState);
}
public class Antlr4.Runtime.Atn.PredictionContextCache : object {
    protected Dictionary`2<PredictionContext, PredictionContext> cache;
    public int Count { get; }
    public PredictionContext Add(PredictionContext ctx);
    public PredictionContext Get(PredictionContext ctx);
    public int get_Count();
}
public class Antlr4.Runtime.Atn.PredictionMode : object {
    public static PredictionMode SLL;
    public static PredictionMode LL;
    public static PredictionMode LL_EXACT_AMBIG_DETECTION;
    private static PredictionMode();
    public static bool HasSLLConflictTerminatingPrediction(PredictionMode mode, ATNConfigSet configSet);
    public static bool HasConfigInRuleStopState(IEnumerable`1<ATNConfig> configs);
    public static bool AllConfigsInRuleStopStates(IEnumerable`1<ATNConfig> configs);
    public static int ResolvesToJustOneViableAlt(IEnumerable`1<BitSet> altsets);
    public static bool AllSubsetsConflict(IEnumerable`1<BitSet> altsets);
    public static bool HasNonConflictingAltSet(IEnumerable`1<BitSet> altsets);
    public static bool HasConflictingAltSet(IEnumerable`1<BitSet> altsets);
    public static bool AllSubsetsEqual(IEnumerable`1<BitSet> altsets);
    public static int GetUniqueAlt(IEnumerable`1<BitSet> altsets);
    public static BitSet GetAlts(IEnumerable`1<BitSet> altsets);
    public static ICollection`1<BitSet> GetConflictingAltSubsets(IEnumerable`1<ATNConfig> configs);
    public static IDictionary`2<ATNState, BitSet> GetStateToAltMap(IEnumerable`1<ATNConfig> configs);
    public static bool HasStateAssociatedWithOneAlt(IEnumerable`1<ATNConfig> configs);
    public static int GetSingleViableAlt(IEnumerable`1<BitSet> altsets);
}
public class Antlr4.Runtime.Atn.ProfilingATNSimulator : ParserATNSimulator {
    protected DecisionInfo[] decisions;
    protected int numDecisions;
    protected int sllStopIndex;
    protected int llStopIndex;
    protected int currentDecision;
    protected DFAState currentState;
    protected int conflictingAltResolvedBySLL;
    public ProfilingATNSimulator(Parser parser);
    public virtual int AdaptivePredict(ITokenStream input, int decision, ParserRuleContext outerContext);
    protected virtual DFAState GetExistingTargetState(DFAState previousD, int t);
    protected virtual DFAState ComputeTargetState(DFA dfa, DFAState previousD, int t);
    protected virtual ATNConfigSet ComputeReachSet(ATNConfigSet closure, int t, bool fullCtx);
    protected virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleContext parserCallStack, int alt, bool fullCtx);
    protected virtual void ReportAttemptingFullContext(DFA dfa, BitSet conflictingAlts, ATNConfigSet configs, int startIndex, int stopIndex);
    protected virtual void ReportContextSensitivity(DFA dfa, int prediction, ATNConfigSet configs, int startIndex, int stopIndex);
    protected virtual void ReportAmbiguity(DFA dfa, DFAState D, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public DecisionInfo[] getDecisionInfo();
    public DFAState getCurrentState();
}
public class Antlr4.Runtime.Atn.RangeTransition : Transition {
    public int from;
    public int to;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public RangeTransition(ATNState target, int from, int to);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.RuleStartState : ATNState {
    public RuleStopState stopState;
    public bool isPrecedenceRule;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.RuleStopState : ATNState {
    public int NonStopStateNumber { get; }
    public StateType StateType { get; }
    public virtual int get_NonStopStateNumber();
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.RuleTransition : Transition {
    public int ruleIndex;
    public int precedence;
    [NotNullAttribute]
public ATNState followState;
    public bool tailCall;
    public bool optimizedTailCall;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    [ObsoleteAttribute("UseRuleTransition(RuleStartState, int, int, ATNState) instead.")]
public RuleTransition(RuleStartState ruleStart, int ruleIndex, ATNState followState);
    public RuleTransition(RuleStartState ruleStart, int ruleIndex, int precedence, ATNState followState);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
}
public abstract class Antlr4.Runtime.Atn.SemanticContext : object {
    public abstract virtual bool Eval(Recognizer`2<Symbol, ATNInterpreter> parser, RuleContext parserCallStack);
    public virtual SemanticContext EvalPrecedence(Recognizer`2<Symbol, ATNInterpreter> parser, RuleContext parserCallStack);
    public static SemanticContext AndOp(SemanticContext a, SemanticContext b);
    public static SemanticContext OrOp(SemanticContext a, SemanticContext b);
    private static IList`1<PrecedencePredicate> FilterPrecedencePredicates(HashSet`1<SemanticContext> collection);
}
public class Antlr4.Runtime.Atn.SetTransition : Transition {
    [NotNullAttribute]
public IntervalSet set;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public SetTransition(ATNState target, IntervalSet set);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.SimState : object {
    public int index;
    public int line;
    public int charPos;
    public DFAState dfaState;
    public void Reset();
}
public class Antlr4.Runtime.Atn.SimulatorState : object {
    public ParserRuleContext outerContext;
    public DFAState s0;
    public bool useContext;
    public ParserRuleContext remainingOuterContext;
    public SimulatorState(ParserRuleContext outerContext, DFAState s0, bool useContext, ParserRuleContext remainingOuterContext);
}
public class Antlr4.Runtime.Atn.SingletonPredictionContext : PredictionContext {
    [NotNullAttribute]
public PredictionContext parent;
    public int returnState;
    public int Size { get; }
    public bool IsEmpty { get; }
    internal SingletonPredictionContext(PredictionContext parent, int returnState);
    public static PredictionContext Create(PredictionContext parent, int returnState);
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual int get_Size();
    public virtual bool get_IsEmpty();
    public virtual bool Equals(object o);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.StarBlockStartState : BlockStartState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.StarLoopbackState : ATNState {
    public StarLoopEntryState LoopEntryState { get; }
    public StateType StateType { get; }
    public StarLoopEntryState get_LoopEntryState();
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.StarLoopEntryState : DecisionState {
    public StarLoopbackState loopBackState;
    public bool isPrecedenceDecision;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public enum Antlr4.Runtime.Atn.StateType : Enum {
    public int value__;
    public static StateType InvalidType;
    public static StateType Basic;
    public static StateType RuleStart;
    public static StateType BlockStart;
    public static StateType PlusBlockStart;
    public static StateType StarBlockStart;
    public static StateType TokenStart;
    public static StateType RuleStop;
    public static StateType BlockEnd;
    public static StateType StarLoopBack;
    public static StateType StarLoopEntry;
    public static StateType PlusLoopBack;
    public static StateType LoopEnd;
}
public class Antlr4.Runtime.Atn.TokensStartState : DecisionState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public abstract class Antlr4.Runtime.Atn.Transition : object {
    public static ReadOnlyCollection`1<string> serializationNames;
    [NotNullAttribute]
public ATNState target;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public IntervalSet Label { get; }
    protected internal Transition(ATNState target);
    private static Transition();
    public abstract virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual IntervalSet get_Label();
    public abstract virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
}
public enum Antlr4.Runtime.Atn.TransitionType : Enum {
    public int value__;
    public static TransitionType INVALID;
    public static TransitionType EPSILON;
    public static TransitionType RANGE;
    public static TransitionType RULE;
    public static TransitionType PREDICATE;
    public static TransitionType ATOM;
    public static TransitionType ACTION;
    public static TransitionType SET;
    public static TransitionType NOT_SET;
    public static TransitionType WILDCARD;
    public static TransitionType PRECEDENCE;
}
public class Antlr4.Runtime.Atn.WildcardTransition : Transition {
    public TransitionType TransitionType { get; }
    public WildcardTransition(ATNState target);
    public virtual TransitionType get_TransitionType();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.BailErrorStrategy : DefaultErrorStrategy {
    public virtual void Recover(Parser recognizer, RecognitionException e);
    public virtual IToken RecoverInline(Parser recognizer);
    public virtual void Sync(Parser recognizer);
}
public class Antlr4.Runtime.BaseErrorListener : object {
    public virtual void SyntaxError(TextWriter output, IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs);
}
public abstract class Antlr4.Runtime.BaseInputCharStream : object {
    public static int ReadBufferSize;
    public static int InitialBufferSize;
    protected internal int n;
    protected internal int p;
    public string name;
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public virtual void Reset();
    public virtual void Consume();
    public virtual int LA(int i);
    public virtual int Lt(int i);
    public virtual int get_Index();
    public virtual int get_Size();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Seek(int index);
    public virtual string GetText(Interval interval);
    protected abstract virtual int ValueAt(int i);
    protected abstract virtual string ConvertDataToString(int start, int count);
    public sealed virtual string ToString();
    public virtual string get_SourceName();
}
public class Antlr4.Runtime.BufferedTokenStream : object {
    [NotNullAttribute]
private ITokenSource _tokenSource;
    protected internal IList`1<IToken> tokens;
    protected internal int p;
    protected internal bool fetchedEOF;
    public ITokenSource TokenSource { get; }
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public BufferedTokenStream(ITokenSource tokenSource);
    public virtual ITokenSource get_TokenSource();
    public virtual int get_Index();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Reset();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual void Consume();
    protected internal virtual bool Sync(int i);
    protected internal virtual int Fetch(int n);
    public virtual IToken Get(int i);
    public virtual IList`1<IToken> Get(int start, int stop);
    public virtual int LA(int i);
    protected internal virtual IToken Lb(int k);
    public virtual IToken LT(int k);
    protected internal virtual int AdjustSeekIndex(int i);
    protected internal void LazyInit();
    protected internal virtual void Setup();
    public virtual void SetTokenSource(ITokenSource tokenSource);
    public virtual IList`1<IToken> GetTokens();
    public virtual IList`1<IToken> GetTokens(int start, int stop);
    public virtual IList`1<IToken> GetTokens(int start, int stop, BitSet types);
    public virtual IList`1<IToken> GetTokens(int start, int stop, int ttype);
    protected internal virtual int NextTokenOnChannel(int i, int channel);
    protected internal virtual int PreviousTokenOnChannel(int i, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToRight(int tokenIndex, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToRight(int tokenIndex);
    public virtual IList`1<IToken> GetHiddenTokensToLeft(int tokenIndex, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToLeft(int tokenIndex);
    protected internal virtual IList`1<IToken> FilterForChannel(int from, int to, int channel);
    public virtual string get_SourceName();
    public virtual string GetText();
    public virtual string GetText(Interval interval);
    public virtual string GetText(RuleContext ctx);
    public virtual string GetText(IToken start, IToken stop);
    public virtual void Fill();
}
public static class Antlr4.Runtime.CharStreams : object {
    public static ICharStream fromPath(string path);
    public static ICharStream fromPath(string path, Encoding encoding);
    public static ICharStream fromTextReader(TextReader textReader);
    public static ICharStream fromStream(Stream stream);
    public static ICharStream fromStream(Stream stream, Encoding encoding);
    public static ICharStream fromString(string s);
}
public class Antlr4.Runtime.CodePointCharStream : BaseInputCharStream {
    private Int32[] data;
    public CodePointCharStream(string input);
    protected virtual int ValueAt(int i);
    protected virtual string ConvertDataToString(int start, int count);
}
public class Antlr4.Runtime.CommonToken : object {
    private static long serialVersionUID;
    protected internal static Tuple`2<ITokenSource, ICharStream> EmptySource;
    private int _type;
    private int _line;
    protected internal int charPositionInLine;
    private int _channel;
    [NotNullAttribute]
protected internal Tuple`2<ITokenSource, ICharStream> source;
    private string _text;
    protected internal int index;
    protected internal int start;
    protected internal int stop;
    public int Type { get; public set; }
    public int Line { get; public set; }
    public string Text { get; public set; }
    public int Column { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public CommonToken(int type);
    public CommonToken(Tuple`2<ITokenSource, ICharStream> source, int type, int channel, int start, int stop);
    public CommonToken(int type, string text);
    public CommonToken(IToken oldToken);
    private static CommonToken();
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual int get_Column();
    public virtual void set_Column(int value);
    public virtual int get_Channel();
    public virtual void set_Channel(int value);
    public virtual int get_StartIndex();
    public virtual void set_StartIndex(int value);
    public virtual int get_StopIndex();
    public virtual void set_StopIndex(int value);
    public virtual int get_TokenIndex();
    public virtual void set_TokenIndex(int value);
    public virtual ITokenSource get_TokenSource();
    public virtual ICharStream get_InputStream();
    public virtual string ToString();
}
public class Antlr4.Runtime.CommonTokenFactory : object {
    public static ITokenFactory Default;
    protected internal bool copyText;
    public CommonTokenFactory(bool copyText);
    private static CommonTokenFactory();
    public virtual CommonToken Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    private sealed virtual override IToken Antlr4.Runtime.ITokenFactory.Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    public virtual CommonToken Create(int type, string text);
    private sealed virtual override IToken Antlr4.Runtime.ITokenFactory.Create(int type, string text);
}
public class Antlr4.Runtime.CommonTokenStream : BufferedTokenStream {
    protected internal int channel;
    public CommonTokenStream(ITokenSource tokenSource);
    public CommonTokenStream(ITokenSource tokenSource, int channel);
    protected internal virtual int AdjustSeekIndex(int i);
    protected internal virtual IToken Lb(int k);
    public virtual IToken LT(int k);
    public virtual int GetNumberOfOnChannelTokens();
}
public class Antlr4.Runtime.ConsoleErrorListener`1 : object {
    public static ConsoleErrorListener`1<Symbol> Instance;
    private static ConsoleErrorListener`1();
    public virtual void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.DefaultErrorStrategy : object {
    protected internal bool errorRecoveryMode;
    protected internal int lastErrorIndex;
    protected internal IntervalSet lastErrorStates;
    protected ParserRuleContext nextTokensContext;
    protected int nextTokensState;
    public virtual void Reset(Parser recognizer);
    protected internal virtual void BeginErrorCondition(Parser recognizer);
    public virtual bool InErrorRecoveryMode(Parser recognizer);
    protected internal virtual void EndErrorCondition(Parser recognizer);
    public virtual void ReportMatch(Parser recognizer);
    public virtual void ReportError(Parser recognizer, RecognitionException e);
    protected internal virtual void NotifyErrorListeners(Parser recognizer, string message, RecognitionException e);
    public virtual void Recover(Parser recognizer, RecognitionException e);
    public virtual void Sync(Parser recognizer);
    protected internal virtual void ReportNoViableAlternative(Parser recognizer, NoViableAltException e);
    protected internal virtual void ReportInputMismatch(Parser recognizer, InputMismatchException e);
    protected internal virtual void ReportFailedPredicate(Parser recognizer, FailedPredicateException e);
    protected internal virtual void ReportUnwantedToken(Parser recognizer);
    protected internal virtual void ReportMissingToken(Parser recognizer);
    public virtual IToken RecoverInline(Parser recognizer);
    protected internal virtual bool SingleTokenInsertion(Parser recognizer);
    protected internal virtual IToken SingleTokenDeletion(Parser recognizer);
    protected internal virtual IToken GetMissingSymbol(Parser recognizer);
    protected internal virtual IToken ConstructToken(ITokenSource tokenSource, int expectedTokenType, string tokenText, IToken current);
    protected internal virtual IntervalSet GetExpectedTokens(Parser recognizer);
    protected internal virtual string GetTokenErrorDisplay(IToken t);
    protected internal virtual string GetSymbolText(IToken symbol);
    protected internal virtual int GetSymbolType(IToken symbol);
    protected internal virtual string EscapeWSAndQuote(string s);
    protected internal virtual IntervalSet GetErrorRecoverySet(Parser recognizer);
    protected internal virtual void ConsumeUntil(Parser recognizer, IntervalSet set);
}
[FlagsAttribute]
public enum Antlr4.Runtime.Dependents : Enum {
    public int value__;
    public static Dependents None;
    public static Dependents Self;
    public static Dependents Parents;
    public static Dependents Children;
    public static Dependents Ancestors;
    public static Dependents Descendants;
    public static Dependents Siblings;
    public static Dependents PreceedingSiblings;
    public static Dependents FollowingSiblings;
    public static Dependents Preceeding;
    public static Dependents Following;
}
[DefaultMemberAttribute("Item")]
public abstract class Antlr4.Runtime.Dfa.AbstractEdgeMap`1 : object {
    protected internal int minIndex;
    protected internal int maxIndex;
    public T Item { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    protected AbstractEdgeMap`1(int minIndex, int maxIndex);
    public abstract virtual AbstractEdgeMap`1<T> Put(int key, T value);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.PutAll(IEdgeMap`1<T> m);
    public abstract virtual AbstractEdgeMap`1<T> Clear();
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Clear();
    public abstract virtual AbstractEdgeMap`1<T> Remove(int key);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Remove(int key);
    public abstract virtual bool ContainsKey(int arg1);
    public abstract virtual T get_Item(int arg1);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual IReadOnlyDictionary`2<int, T> ToMap();
    public virtual IEnumerator`1<KeyValuePair`2<int, T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Antlr4.Runtime.Dfa.AcceptStateInfo : object {
    private int prediction;
    private LexerActionExecutor lexerActionExecutor;
    public int Prediction { get; }
    public LexerActionExecutor LexerActionExecutor { get; }
    public AcceptStateInfo(int prediction);
    public AcceptStateInfo(int prediction, LexerActionExecutor lexerActionExecutor);
    public virtual int get_Prediction();
    public virtual LexerActionExecutor get_LexerActionExecutor();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.ArrayEdgeMap`1 : AbstractEdgeMap`1<T> {
    private T[] arrayData;
    private int size;
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public ArrayEdgeMap`1(int minIndex, int maxIndex);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual IReadOnlyDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.Dfa.DFA : object {
    public Dictionary`2<DFAState, DFAState> states;
    public DFAState s0;
    public int decision;
    public DecisionState atnStartState;
    private bool precedenceDfa;
    public bool IsPrecedenceDfa { get; }
    public DFA(DecisionState atnStartState);
    public DFA(DecisionState atnStartState, int decision);
    public bool get_IsPrecedenceDfa();
    public DFAState GetPrecedenceStartState(int precedence);
    public void SetPrecedenceStartState(int precedence, DFAState startState);
    public List`1<DFAState> GetStates();
    public virtual string ToString();
    public string ToString(IVocabulary vocabulary);
    public string ToLexerString();
}
public class Antlr4.Runtime.Dfa.DFASerializer : object {
    [NotNullAttribute]
private DFA dfa;
    [NotNullAttribute]
private IVocabulary vocabulary;
    [NullableAttribute]
internal String[] ruleNames;
    [NullableAttribute]
internal ATN atn;
    public DFASerializer(DFA dfa, IVocabulary vocabulary);
    public DFASerializer(DFA dfa, IRecognizer parser);
    public DFASerializer(DFA dfa, IVocabulary vocabulary, String[] ruleNames, ATN atn);
    public virtual string ToString();
    protected internal virtual string GetContextLabel(int i);
    protected internal virtual string GetEdgeLabel(int i);
    internal virtual string GetStateString(DFAState s);
}
public class Antlr4.Runtime.Dfa.DFAState : object {
    public int stateNumber;
    public ATNConfigSet configSet;
    public DFAState[] edges;
    public bool isAcceptState;
    public int prediction;
    public LexerActionExecutor lexerActionExecutor;
    public bool requiresFullContext;
    public PredPrediction[] predicates;
    public DFAState(int stateNumber);
    public DFAState(ATNConfigSet configs);
    public HashSet`1<int> getAltSet();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.EmptyEdgeMap`1 : AbstractEdgeMap`1<T> {
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public EmptyEdgeMap`1(int minIndex, int maxIndex);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual IReadOnlyDictionary`2<int, T> ToMap();
}
[DefaultMemberAttribute("Item")]
public interface Antlr4.Runtime.Dfa.IEdgeMap`1 {
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool ContainsKey(int key);
    public abstract virtual T get_Item(int key);
    public abstract virtual IEdgeMap`1<T> Put(int key, T value);
    public abstract virtual IEdgeMap`1<T> Remove(int key);
    public abstract virtual IEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    public abstract virtual IEdgeMap`1<T> Clear();
    public abstract virtual IReadOnlyDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.Dfa.LexerDFASerializer : DFASerializer {
    public LexerDFASerializer(DFA dfa);
    protected internal virtual string GetEdgeLabel(int i);
}
public class Antlr4.Runtime.Dfa.PredPrediction : object {
    public SemanticContext pred;
    public int alt;
    public PredPrediction(SemanticContext pred, int alt);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.SingletonEdgeMap`1 : AbstractEdgeMap`1<T> {
    private int key;
    private T value;
    public int Key { get; }
    public T Value { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public SingletonEdgeMap`1(int minIndex, int maxIndex, int key, T value);
    public int get_Key();
    public T get_Value();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual IReadOnlyDictionary`2<int, T> ToMap();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.SparseEdgeMap`1 : AbstractEdgeMap`1<T> {
    private static int DefaultMaxSize;
    private Int32[] keys;
    private List`1<T> values;
    public Int32[] Keys { get; }
    public IList`1<T> Values { get; }
    public int MaxSparseSize { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public SparseEdgeMap`1(int minIndex, int maxIndex);
    public SparseEdgeMap`1(int minIndex, int maxIndex, int maxSparseSize);
    private SparseEdgeMap`1(SparseEdgeMap`1<T> map, int maxSparseSize);
    public Int32[] get_Keys();
    public IList`1<T> get_Values();
    public int get_MaxSparseSize();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual IReadOnlyDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.DiagnosticErrorListener : BaseErrorListener {
    protected internal bool exactOnly;
    public DiagnosticErrorListener(bool exactOnly);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs);
    protected internal virtual string GetDecisionDescription(Parser recognizer, DFA dfa);
    protected internal virtual BitSet GetConflictingAlts(BitSet reportedAlts, ATNConfigSet configSet);
}
public class Antlr4.Runtime.FailedPredicateException : RecognitionException {
    private static long serialVersionUID;
    private int ruleIndex;
    private int predicateIndex;
    private string predicate;
    public int RuleIndex { get; }
    public int PredIndex { get; }
    [NullableAttribute]
public string Predicate { get; }
    public FailedPredicateException(Parser recognizer);
    public FailedPredicateException(Parser recognizer, string predicate);
    public FailedPredicateException(Parser recognizer, string predicate, string message);
    public virtual int get_RuleIndex();
    public virtual int get_PredIndex();
    public virtual string get_Predicate();
    private static string FormatMessage(string predicate, string message);
}
public interface Antlr4.Runtime.IAntlrErrorListener`1 {
    public abstract virtual void SyntaxError(TextWriter output, IRecognizer recognizer, TSymbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public interface Antlr4.Runtime.IAntlrErrorStrategy {
    public abstract virtual void Reset(Parser recognizer);
    public abstract virtual IToken RecoverInline(Parser recognizer);
    public abstract virtual void Recover(Parser recognizer, RecognitionException e);
    public abstract virtual void Sync(Parser recognizer);
    public abstract virtual bool InErrorRecoveryMode(Parser recognizer);
    public abstract virtual void ReportMatch(Parser recognizer);
    public abstract virtual void ReportError(Parser recognizer, RecognitionException e);
}
public interface Antlr4.Runtime.ICharStream {
    public abstract virtual string GetText(Interval interval);
}
public interface Antlr4.Runtime.IIntStream {
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public abstract virtual void Consume();
    public abstract virtual int LA(int i);
    public abstract virtual int Mark();
    public abstract virtual void Release(int marker);
    public abstract virtual int get_Index();
    public abstract virtual void Seek(int index);
    public abstract virtual int get_Size();
    public abstract virtual string get_SourceName();
}
public class Antlr4.Runtime.InputMismatchException : RecognitionException {
    private static long serialVersionUID;
    public InputMismatchException(Parser recognizer);
}
public class Antlr4.Runtime.InterpreterRuleContext : ParserRuleContext {
    private int ruleIndex;
    public int RuleIndex { get; }
    public InterpreterRuleContext(ParserRuleContext parent, int invokingStateNumber, int ruleIndex);
    public virtual int get_RuleIndex();
}
public static class Antlr4.Runtime.IntStreamConstants : object {
    public static int EOF;
    public static string UnknownSourceName;
}
public interface Antlr4.Runtime.IParserErrorListener {
    public abstract virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public abstract virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs);
    public abstract virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs);
}
public interface Antlr4.Runtime.IRecognizer {
    public IVocabulary Vocabulary { get; }
    public String[] RuleNames { get; }
    public string GrammarFileName { get; }
    public ATN Atn { get; }
    public int State { get; }
    public IIntStream InputStream { get; }
    public abstract virtual IVocabulary get_Vocabulary();
    public abstract virtual String[] get_RuleNames();
    public abstract virtual string get_GrammarFileName();
    public abstract virtual ATN get_Atn();
    public abstract virtual int get_State();
    public abstract virtual IIntStream get_InputStream();
}
public interface Antlr4.Runtime.IToken {
    public string Text { get; }
    public int Type { get; }
    public int Line { get; }
    public int Column { get; }
    public int Channel { get; }
    public int TokenIndex { get; }
    public int StartIndex { get; }
    public int StopIndex { get; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public abstract virtual string get_Text();
    public abstract virtual int get_Type();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual int get_Channel();
    public abstract virtual int get_TokenIndex();
    public abstract virtual int get_StartIndex();
    public abstract virtual int get_StopIndex();
    public abstract virtual ITokenSource get_TokenSource();
    public abstract virtual ICharStream get_InputStream();
}
public interface Antlr4.Runtime.ITokenFactory {
    public abstract virtual IToken Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    public abstract virtual IToken Create(int type, string text);
}
public interface Antlr4.Runtime.ITokenSource {
    public int Line { get; }
    public int Column { get; }
    public ICharStream InputStream { get; }
    public string SourceName { get; }
    public ITokenFactory TokenFactory { get; public set; }
    public abstract virtual IToken NextToken();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual ICharStream get_InputStream();
    public abstract virtual string get_SourceName();
    public abstract virtual ITokenFactory get_TokenFactory();
    public abstract virtual void set_TokenFactory(ITokenFactory value);
}
public interface Antlr4.Runtime.ITokenStream {
    public ITokenSource TokenSource { get; }
    public abstract virtual IToken LT(int k);
    public abstract virtual IToken Get(int i);
    public abstract virtual ITokenSource get_TokenSource();
    public abstract virtual string GetText(Interval interval);
    public abstract virtual string GetText();
    public abstract virtual string GetText(RuleContext ctx);
    public abstract virtual string GetText(IToken start, IToken stop);
}
public interface Antlr4.Runtime.IVocabulary {
    public abstract virtual string GetLiteralName(int tokenType);
    public abstract virtual string GetSymbolicName(int tokenType);
    public abstract virtual string GetDisplayName(int tokenType);
}
public interface Antlr4.Runtime.IWritableToken {
    unknown string Text {public set; }
    unknown int Type {public set; }
    unknown int Line {public set; }
    unknown int Column {public set; }
    unknown int Channel {public set; }
    unknown int TokenIndex {public set; }
    public abstract virtual void set_Text(string value);
    public abstract virtual void set_Type(int value);
    public abstract virtual void set_Line(int value);
    public abstract virtual void set_Column(int value);
    public abstract virtual void set_Channel(int value);
    public abstract virtual void set_TokenIndex(int value);
}
public abstract class Antlr4.Runtime.Lexer : Recognizer`2<int, LexerATNSimulator> {
    public static int DEFAULT_MODE;
    public static int DefaultTokenChannel;
    public static int Hidden;
    public static int MinCharValue;
    public static int MaxCharValue;
    private ICharStream _input;
    protected TextWriter Output;
    protected TextWriter ErrorOutput;
    private Tuple`2<ITokenSource, ICharStream> _tokenFactorySourcePair;
    private ITokenFactory _factory;
    private IToken _token;
    private int _tokenStartCharIndex;
    private int _tokenStartLine;
    private int _tokenStartColumn;
    private bool _hitEOF;
    private int _channel;
    private int _type;
    private Stack`1<int> _modeStack;
    private int _mode;
    private string _text;
    public ITokenFactory TokenFactory { get; public set; }
    public string SourceName { get; }
    public IIntStream InputStream { get; }
    private ICharStream Antlr4.Runtime.ITokenSource.InputStream { get; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int CharIndex { get; }
    public int TokenStartCharIndex { get; }
    public int TokenStartLine { get; }
    public int TokenStartColumn { get; }
    public string Text { get; public set; }
    public IToken Token { get; public set; }
    public int Type { get; public set; }
    public int Channel { get; public set; }
    public Stack`1<int> ModeStack { get; }
    public int CurrentMode { get; public set; }
    public bool HitEOF { get; public set; }
    public String[] ChannelNames { get; }
    public String[] ModeNames { get; }
    public Lexer(ICharStream input);
    public Lexer(ICharStream input, TextWriter output, TextWriter errorOutput);
    public virtual void Reset();
    public virtual IToken NextToken();
    public virtual void Skip();
    public virtual void More();
    public virtual void Mode(int m);
    public virtual void PushMode(int m);
    public virtual int PopMode();
    public virtual ITokenFactory get_TokenFactory();
    public virtual void set_TokenFactory(ITokenFactory value);
    public virtual void SetInputStream(ICharStream input);
    public virtual string get_SourceName();
    public virtual IIntStream get_InputStream();
    private sealed virtual override ICharStream Antlr4.Runtime.ITokenSource.get_InputStream();
    public virtual void Emit(IToken token);
    public virtual IToken Emit();
    public virtual IToken EmitEOF();
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual int get_Column();
    public virtual void set_Column(int value);
    public virtual int get_CharIndex();
    public virtual int get_TokenStartCharIndex();
    public virtual int get_TokenStartLine();
    public virtual int get_TokenStartColumn();
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual IToken get_Token();
    public virtual void set_Token(IToken value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual int get_Channel();
    public virtual void set_Channel(int value);
    public virtual Stack`1<int> get_ModeStack();
    public virtual int get_CurrentMode();
    public virtual void set_CurrentMode(int value);
    public virtual bool get_HitEOF();
    public virtual void set_HitEOF(bool value);
    public virtual String[] get_ChannelNames();
    public virtual String[] get_ModeNames();
    public virtual IList`1<IToken> GetAllTokens();
    public virtual void Recover(LexerNoViableAltException e);
    public virtual void NotifyListeners(LexerNoViableAltException e);
    public virtual string GetErrorDisplay(string s);
    public virtual string GetErrorDisplay(int c);
    public virtual string GetCharErrorDisplay(int c);
    public virtual void Recover(RecognitionException re);
}
public class Antlr4.Runtime.LexerInterpreter : Lexer {
    private string grammarFileName;
    private ATN atn;
    private String[] ruleNames;
    private String[] channelNames;
    private String[] modeNames;
    [NotNullAttribute]
private IVocabulary vocabulary;
    protected DFA[] decisionToDFA;
    protected PredictionContextCache sharedContextCache;
    public ATN Atn { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ChannelNames { get; }
    public String[] ModeNames { get; }
    public IVocabulary Vocabulary { get; }
    [ObsoleteAttribute("Use constructor with channelNames argument")]
public LexerInterpreter(string grammarFileName, IVocabulary vocabulary, IEnumerable`1<string> ruleNames, IEnumerable`1<string> modeNames, ATN atn, ICharStream input);
    public LexerInterpreter(string grammarFileName, IVocabulary vocabulary, IEnumerable`1<string> ruleNames, IEnumerable`1<string> channelNames, IEnumerable`1<string> modeNames, ATN atn, ICharStream input);
    public virtual ATN get_Atn();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ChannelNames();
    public virtual String[] get_ModeNames();
    public virtual IVocabulary get_Vocabulary();
}
public class Antlr4.Runtime.LexerNoViableAltException : RecognitionException {
    private static long serialVersionUID;
    private int startIndex;
    [NullableAttribute]
private ATNConfigSet deadEndConfigs;
    public int StartIndex { get; }
    [NullableAttribute]
public ATNConfigSet DeadEndConfigs { get; }
    public IIntStream InputStream { get; }
    public LexerNoViableAltException(Lexer lexer, ICharStream input, int startIndex, ATNConfigSet deadEndConfigs);
    public virtual int get_StartIndex();
    public virtual ATNConfigSet get_DeadEndConfigs();
    public virtual IIntStream get_InputStream();
    public virtual string ToString();
}
public class Antlr4.Runtime.ListTokenSource : object {
    protected internal IList`1<IToken> tokens;
    private string sourceName;
    protected internal int i;
    protected internal IToken eofToken;
    private ITokenFactory _factory;
    public int Column { get; }
    public int Line { get; }
    public ICharStream InputStream { get; }
    public string SourceName { get; }
    public ITokenFactory TokenFactory { get; public set; }
    public ListTokenSource(IList`1<IToken> tokens);
    public ListTokenSource(IList`1<IToken> tokens, string sourceName);
    public virtual int get_Column();
    public virtual IToken NextToken();
    public virtual int get_Line();
    public virtual ICharStream get_InputStream();
    public virtual string get_SourceName();
    public virtual ITokenFactory get_TokenFactory();
    public virtual void set_TokenFactory(ITokenFactory value);
}
public static class Antlr4.Runtime.Misc.Args : object {
    public static void NotNull(string parameterName, object value);
}
public class Antlr4.Runtime.Misc.ArrayList`1 : List`1<T> {
    public ArrayList`1(int count);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public bool Equals(List`1<T> o);
}
public interface Antlr4.Runtime.Misc.IIntSet {
    public int Count { get; }
    public bool IsNil { get; }
    public int SingleElement { get; }
    public abstract virtual void Add(int el);
    public abstract virtual IIntSet AddAll(IIntSet set);
    public abstract virtual IIntSet And(IIntSet a);
    public abstract virtual IIntSet Complement(IIntSet elements);
    public abstract virtual IIntSet Or(IIntSet a);
    public abstract virtual IIntSet Subtract(IIntSet a);
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsNil();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int get_SingleElement();
    public abstract virtual bool Contains(int el);
    public abstract virtual void Remove(int el);
    public abstract virtual IList`1<int> ToList();
    public abstract virtual string ToString();
}
public class Antlr4.Runtime.Misc.Interval : ValueType {
    public static Interval Invalid;
    public int a;
    public int b;
    public int Length { get; }
    public Interval(int a, int b);
    private static Interval();
    public static Interval Of(int a, int b);
    public int get_Length();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public bool StartsBeforeDisjoint(Interval other);
    public bool StartsBeforeNonDisjoint(Interval other);
    public bool StartsAfter(Interval other);
    public bool StartsAfterDisjoint(Interval other);
    public bool StartsAfterNonDisjoint(Interval other);
    public bool Disjoint(Interval other);
    public bool Adjacent(Interval other);
    public bool ProperlyContains(Interval other);
    public Interval Union(Interval other);
    public Interval Intersection(Interval other);
    public Nullable`1<Interval> DifferenceNotProperlyContained(Interval other);
    public virtual string ToString();
}
public class Antlr4.Runtime.Misc.IntervalSet : object {
    public static IntervalSet CompleteCharSet;
    public static IntervalSet EmptySet;
    protected internal IList`1<Interval> intervals;
    protected internal bool readonly;
    public bool IsNil { get; }
    public int SingleElement { get; }
    public int MaxElement { get; }
    public int MinElement { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private static IntervalSet();
    public IntervalSet(IList`1<Interval> intervals);
    public IntervalSet(IntervalSet set);
    public IntervalSet(Int32[] els);
    public static IntervalSet Of(int a);
    public static IntervalSet Of(int a, int b);
    public virtual void Clear();
    public virtual void Add(int el);
    public virtual void Add(int a, int b);
    protected internal virtual void Add(Interval addition);
    public static IntervalSet Or(IntervalSet[] sets);
    public virtual IntervalSet AddAll(IIntSet set);
    public virtual IntervalSet Complement(int minElement, int maxElement);
    public virtual IntervalSet Complement(IIntSet vocabulary);
    public virtual IntervalSet Subtract(IIntSet a);
    public static IntervalSet Subtract(IntervalSet left, IntervalSet right);
    public virtual IntervalSet Or(IIntSet a);
    public virtual IntervalSet And(IIntSet other);
    public virtual bool Contains(int el);
    public virtual bool get_IsNil();
    public virtual int get_SingleElement();
    public virtual int get_MaxElement();
    public virtual int get_MinElement();
    public virtual IList`1<Interval> GetIntervals();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual string ToString(bool elemAreChar);
    public virtual string ToString(IVocabulary vocabulary);
    protected internal virtual string ElementName(IVocabulary vocabulary, int a);
    public virtual int get_Count();
    public virtual ArrayList`1<int> ToIntegerList();
    public virtual IList`1<int> ToList();
    public virtual HashSet`1<int> ToSet();
    public virtual Int32[] ToArray();
    public virtual void Remove(int el);
    public virtual bool get_IsReadOnly();
    public virtual void SetReadonly(bool readonly);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.AddAll(IIntSet set);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.And(IIntSet a);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Complement(IIntSet elements);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Or(IIntSet a);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Subtract(IIntSet a);
}
public class Antlr4.Runtime.Misc.MultiMap`2 : Dictionary`2<K, IList`1<V>> {
    private static long serialVersionUID;
    public virtual void Map(K key, V value);
    public virtual IList`1<Tuple`2<K, V>> GetPairs();
}
public class Antlr4.Runtime.Misc.MurmurHash : object {
    private static int DefaultSeed;
    public static int Initialize();
    public static int Initialize(int seed);
    public static int Update(int hash, int value);
    public static int Update(int hash, object value);
    public static int Finish(int hash, int numberOfWords);
    public static int HashCode(T[] data, int seed);
}
[AttributeUsageAttribute("10624")]
public class Antlr4.Runtime.Misc.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10624")]
public class Antlr4.Runtime.Misc.NullableAttribute : Attribute {
}
public class Antlr4.Runtime.Misc.Pair`2 : object {
    public A a;
    public B b;
    public Pair`2(A a, B b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Antlr4.Runtime.Misc.ParseCanceledException : OperationCanceledException {
    public ParseCanceledException(string message);
    public ParseCanceledException(Exception cause);
    public ParseCanceledException(string message, Exception cause);
}
public class Antlr4.Runtime.Misc.RuleDependencyChecker : object {
    private static HashSet`1<string> checkedAssemblies;
    private static Dependents ImplementedDependents;
    private static RuleDependencyChecker();
    public static void CheckDependencies(Assembly assembly);
    private static IEnumerable`1<TypeInfo> GetTypesToCheck(Assembly assembly);
    private static bool IsChecked(Assembly assembly);
    private static void MarkChecked(Assembly assembly);
    private static void CheckDependencies(IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> dependencies, TypeInfo recognizerType);
    private static void ReportUnimplementedDependents(StringBuilder errors, Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider> dependency, Dependents dependents);
    private static int CheckDependencyVersion(StringBuilder errors, Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider> dependency, String[] ruleNames, Int32[] ruleVersions, int relatedRule, string relation);
    private static Int32[] GetRuleVersions(TypeInfo recognizerClass, String[] ruleNames);
    private static MethodInfo GetRuleMethod(TypeInfo recognizerClass, string name);
    private static String[] GetRuleNames(TypeInfo recognizerClass);
    public static IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> GetDependencies(TypeInfo clazz);
    private static void GetElementDependencies(ICustomAttributeProvider annotatedElement, IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> result);
    private static RuleRelations ExtractRuleRelations(TypeInfo recognizer);
    private static Int32[] GetSerializedATN(TypeInfo recognizerClass);
    protected static ICustomAttributeProvider AsCustomAttributeProvider(TypeInfo type);
    protected static ICustomAttributeProvider AsCustomAttributeProvider(MethodBase method);
    protected static ICustomAttributeProvider AsCustomAttributeProvider(ParameterInfo parameter);
    protected static ICustomAttributeProvider AsCustomAttributeProvider(FieldInfo field);
}
[ExtensionAttribute]
public static class Antlr4.Runtime.Misc.StaticUtils : object {
    [ExtensionAttribute]
public static string ToString(IEnumerable`1<T> list);
}
public class Antlr4.Runtime.Misc.Utils : object {
    public static string Join(string separator, IEnumerable`1<T> items);
    public static int NumNonnull(Object[] data);
    public static void RemoveAllElements(ICollection`1<T> data, T value);
    public static string EscapeWhitespace(string s, bool escapeSpaces);
    public static void RemoveAll(IList`1<T> list, Predicate`1<T> predicate);
    public static IDictionary`2<string, int> ToMap(String[] keys);
}
public class Antlr4.Runtime.NoViableAltException : RecognitionException {
    private static long serialVersionUID;
    [NullableAttribute]
private ATNConfigSet deadEndConfigs;
    [NotNullAttribute]
private IToken startToken;
    public IToken StartToken { get; }
    [NullableAttribute]
public ATNConfigSet DeadEndConfigs { get; }
    public NoViableAltException(Parser recognizer);
    public NoViableAltException(IRecognizer recognizer, ITokenStream input, IToken startToken, IToken offendingToken, ATNConfigSet deadEndConfigs, ParserRuleContext ctx);
    public virtual IToken get_StartToken();
    public virtual ATNConfigSet get_DeadEndConfigs();
}
public abstract class Antlr4.Runtime.Parser : Recognizer`2<IToken, ParserATNSimulator> {
    private ATN bypassAltsAtnCache;
    [NotNullAttribute]
private IAntlrErrorStrategy _errHandler;
    private ITokenStream _input;
    private List`1<int> _precedenceStack;
    private ParserRuleContext _ctx;
    private bool _buildParseTrees;
    private TraceListener _tracer;
    [NullableAttribute]
private IList`1<IParseTreeListener> _parseListeners;
    private int _syntaxErrors;
    protected TextWriter Output;
    protected TextWriter ErrorOutput;
    public bool BuildParseTree { get; public set; }
    public bool TrimParseTree { get; public set; }
    public IList`1<IParseTreeListener> ParseListeners { get; }
    public int NumberOfSyntaxErrors { get; }
    public ITokenFactory TokenFactory { get; }
    public IAntlrErrorStrategy ErrorHandler { get; public set; }
    public IIntStream InputStream { get; }
    public ITokenStream TokenStream { get; public set; }
    public IToken CurrentToken { get; }
    public int Precedence { get; }
    public ParserRuleContext Context { get; public set; }
    public IParserErrorListener ErrorListenerDispatch { get; }
    public ParserRuleContext RuleContext { get; }
    public string SourceName { get; }
    public ParseInfo ParseInfo { get; }
    unknown bool Profile {public set; }
    public bool Trace { get; public set; }
    public Parser(ITokenStream input);
    public Parser(ITokenStream input, TextWriter output, TextWriter errorOutput);
    public virtual void Reset();
    public virtual IToken Match(int ttype);
    public virtual IToken MatchWildcard();
    public virtual bool get_BuildParseTree();
    public virtual void set_BuildParseTree(bool value);
    public virtual bool get_TrimParseTree();
    public virtual void set_TrimParseTree(bool value);
    public virtual IList`1<IParseTreeListener> get_ParseListeners();
    public virtual void AddParseListener(IParseTreeListener listener);
    public virtual void RemoveParseListener(IParseTreeListener listener);
    public virtual void RemoveParseListeners();
    protected internal virtual void TriggerEnterRuleEvent();
    protected internal virtual void TriggerExitRuleEvent();
    public virtual int get_NumberOfSyntaxErrors();
    public virtual ITokenFactory get_TokenFactory();
    public virtual ATN GetATNWithBypassAlts();
    public virtual ParseTreePattern CompileParseTreePattern(string pattern, int patternRuleIndex);
    public virtual ParseTreePattern CompileParseTreePattern(string pattern, int patternRuleIndex, Lexer lexer);
    public virtual IAntlrErrorStrategy get_ErrorHandler();
    public virtual void set_ErrorHandler(IAntlrErrorStrategy value);
    public virtual IIntStream get_InputStream();
    public ITokenStream get_TokenStream();
    public void set_TokenStream(ITokenStream value);
    public virtual IToken get_CurrentToken();
    public void NotifyErrorListeners(string msg);
    public virtual void NotifyErrorListeners(IToken offendingToken, string msg, RecognitionException e);
    public virtual IToken Consume();
    protected internal virtual void AddContextToParseTree();
    public virtual void EnterRule(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void EnterLeftFactoredRule(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void ExitRule();
    public virtual void EnterOuterAlt(ParserRuleContext localctx, int altNum);
    public int get_Precedence();
    [ObsoleteAttribute("UseEnterRecursionRule(ParserRuleContext, int, int, int) instead.")]
public virtual void EnterRecursionRule(ParserRuleContext localctx, int ruleIndex);
    public virtual void EnterRecursionRule(ParserRuleContext localctx, int state, int ruleIndex, int precedence);
    public virtual void PushNewRecursionContext(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void UnrollRecursionContexts(ParserRuleContext _parentctx);
    public virtual ParserRuleContext GetInvokingContext(int ruleIndex);
    public virtual ParserRuleContext get_Context();
    public virtual void set_Context(ParserRuleContext value);
    public virtual bool Precpred(RuleContext localctx, int precedence);
    public IParserErrorListener get_ErrorListenerDispatch();
    public virtual bool InContext(string context);
    public virtual bool IsExpectedToken(int symbol);
    public virtual IntervalSet GetExpectedTokens();
    public virtual IntervalSet GetExpectedTokensWithinCurrentRule();
    public virtual int GetRuleIndex(string ruleName);
    public virtual ParserRuleContext get_RuleContext();
    public virtual IList`1<string> GetRuleInvocationStack();
    public virtual string GetRuleInvocationStackAsString();
    public virtual IList`1<string> GetRuleInvocationStack(RuleContext p);
    public virtual IList`1<string> GetDFAStrings();
    public virtual void DumpDFA();
    public virtual string get_SourceName();
    public virtual ParseInfo get_ParseInfo();
    public virtual void set_Profile(bool value);
    public virtual bool get_Trace();
    public virtual void set_Trace(bool value);
}
public class Antlr4.Runtime.ParserInterpreter : Parser {
    private string _grammarFileName;
    private ATN _atn;
    private DFA[] _decisionToDFA;
    protected internal BitSet pushRecursionContextStates;
    private String[] _ruleNames;
    [NotNullAttribute]
private IVocabulary vocabulary;
    private Stack`1<Tuple`2<ParserRuleContext, int>> _parentContextStack;
    public ATN Atn { get; }
    public IVocabulary Vocabulary { get; }
    public String[] RuleNames { get; }
    public string GrammarFileName { get; }
    protected internal ATNState AtnState { get; }
    public ParserInterpreter(string grammarFileName, IVocabulary vocabulary, IEnumerable`1<string> ruleNames, ATN atn, ITokenStream input);
    public virtual ATN get_Atn();
    public virtual IVocabulary get_Vocabulary();
    public virtual String[] get_RuleNames();
    public virtual string get_GrammarFileName();
    public virtual ParserRuleContext Parse(int startRuleIndex);
    public virtual void EnterRecursionRule(ParserRuleContext localctx, int state, int ruleIndex, int precedence);
    protected internal virtual ATNState get_AtnState();
    protected internal virtual void VisitState(ATNState p);
    protected internal virtual void VisitRuleStopState(ATNState p);
}
public class Antlr4.Runtime.ParserRuleContext : RuleContext {
    public static ParserRuleContext EMPTY;
    public IList`1<IParseTree> children;
    private IToken _start;
    private IToken _stop;
    public RecognitionException exception;
    public static ParserRuleContext EmptyContext { get; }
    public int ChildCount { get; }
    public Interval SourceInterval { get; }
    public IToken Start { get; public set; }
    public IToken Stop { get; public set; }
    public ParserRuleContext(ParserRuleContext parent, int invokingStateNumber);
    private static ParserRuleContext();
    public static ParserRuleContext get_EmptyContext();
    public virtual void CopyFrom(ParserRuleContext ctx);
    public virtual void EnterRule(IParseTreeListener listener);
    public virtual void ExitRule(IParseTreeListener listener);
    public virtual void AddChild(ITerminalNode t);
    public virtual void AddChild(RuleContext ruleInvocation);
    public virtual void RemoveLastChild();
    public virtual ITerminalNode AddChild(IToken matchedToken);
    public virtual IErrorNode AddErrorNode(IToken badToken);
    public virtual IParseTree GetChild(int i);
    public virtual T GetChild(int i);
    public virtual ITerminalNode GetToken(int ttype, int i);
    public virtual ITerminalNode[] GetTokens(int ttype);
    public virtual T GetRuleContext(int i);
    public virtual T[] GetRuleContexts();
    public virtual int get_ChildCount();
    public virtual Interval get_SourceInterval();
    public virtual IToken get_Start();
    public virtual void set_Start(IToken value);
    public virtual IToken get_Stop();
    public virtual void set_Stop(IToken value);
    public virtual string ToInfoString(Parser recognizer);
}
public class Antlr4.Runtime.ProxyErrorListener`1 : object {
    private IEnumerable`1<IAntlrErrorListener`1<Symbol>> delegates;
    protected internal IEnumerable`1<IAntlrErrorListener`1<Symbol>> Delegates { get; }
    public ProxyErrorListener`1(IEnumerable`1<IAntlrErrorListener`1<Symbol>> delegates);
    protected internal virtual IEnumerable`1<IAntlrErrorListener`1<Symbol>> get_Delegates();
    public virtual void SyntaxError(TextWriter output, IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.ProxyParserErrorListener : ProxyErrorListener`1<IToken> {
    public ProxyParserErrorListener(ICollection`1<IAntlrErrorListener`1<IToken>> delegates);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs);
}
public class Antlr4.Runtime.RecognitionException : Exception {
    private static long serialVersionUID;
    [NullableAttribute]
private IRecognizer recognizer;
    [NullableAttribute]
private RuleContext ctx;
    [NullableAttribute]
private IIntStream input;
    private IToken offendingToken;
    private int offendingState;
    public int OffendingState { get; protected set; }
    public RuleContext Context { get; }
    public IIntStream InputStream { get; }
    public IToken OffendingToken { get; protected set; }
    public IRecognizer Recognizer { get; }
    public RecognitionException(Lexer lexer, ICharStream input);
    public RecognitionException(IRecognizer recognizer, IIntStream input, ParserRuleContext ctx);
    public RecognitionException(string message, IRecognizer recognizer, IIntStream input, ParserRuleContext ctx);
    public int get_OffendingState();
    protected void set_OffendingState(int value);
    public virtual IntervalSet GetExpectedTokens();
    public virtual RuleContext get_Context();
    public virtual IIntStream get_InputStream();
    public IToken get_OffendingToken();
    protected void set_OffendingToken(IToken value);
    public virtual IRecognizer get_Recognizer();
}
public abstract class Antlr4.Runtime.Recognizer`2 : object {
    public static int Eof;
    private static ConditionalWeakTable`2<IVocabulary, IDictionary`2<string, int>> tokenTypeMapCache;
    private static ConditionalWeakTable`2<String[], IDictionary`2<string, int>> ruleIndexMapCache;
    [NotNullAttribute]
private IAntlrErrorListener`1[] _listeners;
    private ATNInterpreter _interp;
    private int _stateNumber;
    public String[] RuleNames { get; }
    public IVocabulary Vocabulary { get; }
    [NotNullAttribute]
public IDictionary`2<string, int> TokenTypeMap { get; }
    [NotNullAttribute]
public IDictionary`2<string, int> RuleIndexMap { get; }
    public Int32[] SerializedAtn { get; }
    public string GrammarFileName { get; }
    public ATN Atn { get; }
    public ATNInterpreter Interpreter { get; protected set; }
    public ParseInfo ParseInfo { get; }
    [NotNullAttribute]
public IList`1<IAntlrErrorListener`1<Symbol>> ErrorListeners { get; }
    public IAntlrErrorListener`1<Symbol> ErrorListenerDispatch { get; }
    public int State { get; public set; }
    public IIntStream InputStream { get; }
    private static Recognizer`2();
    public abstract virtual String[] get_RuleNames();
    public abstract virtual IVocabulary get_Vocabulary();
    public virtual IDictionary`2<string, int> get_TokenTypeMap();
    protected virtual IDictionary`2<string, int> CreateTokenTypeMap(IVocabulary vocabulary);
    public virtual IDictionary`2<string, int> get_RuleIndexMap();
    public virtual int GetTokenType(string tokenName);
    public virtual Int32[] get_SerializedAtn();
    public abstract virtual string get_GrammarFileName();
    public virtual ATN get_Atn();
    public virtual ATNInterpreter get_Interpreter();
    protected virtual void set_Interpreter(ATNInterpreter value);
    public virtual ParseInfo get_ParseInfo();
    public virtual string GetErrorHeader(RecognitionException e);
    [ObsoleteAttribute("This method is not called by the ANTLR 4 Runtime. Specific implementations of IAntlrErrorStrategy may provide a similar feature when necessary. For example, see DefaultErrorStrategy.GetTokenErrorDisplay(IToken).")]
public virtual string GetTokenErrorDisplay(IToken t);
    public virtual void AddErrorListener(IAntlrErrorListener`1<Symbol> listener);
    public virtual void RemoveErrorListener(IAntlrErrorListener`1<Symbol> listener);
    public virtual void RemoveErrorListeners();
    public virtual IList`1<IAntlrErrorListener`1<Symbol>> get_ErrorListeners();
    public virtual IAntlrErrorListener`1<Symbol> get_ErrorListenerDispatch();
    public virtual bool Sempred(RuleContext _localctx, int ruleIndex, int actionIndex);
    public virtual bool Precpred(RuleContext localctx, int precedence);
    public virtual void Action(RuleContext _localctx, int ruleIndex, int actionIndex);
    public sealed virtual int get_State();
    public void set_State(int value);
    public abstract virtual IIntStream get_InputStream();
}
public class Antlr4.Runtime.RuleContext : object {
    private RuleContext _parent;
    public int invokingState;
    public bool IsEmpty { get; }
    public Interval SourceInterval { get; }
    private RuleContext Antlr4.Runtime.Tree.IRuleNode.RuleContext { get; }
    public RuleContext Parent { get; public set; }
    private IRuleNode Antlr4.Runtime.Tree.IRuleNode.Parent { get; }
    private IParseTree Antlr4.Runtime.Tree.IParseTree.Parent { get; }
    private ITree Antlr4.Runtime.Tree.ITree.Parent { get; }
    public RuleContext Payload { get; }
    private object Antlr4.Runtime.Tree.ITree.Payload { get; }
    public int RuleIndex { get; }
    public int ChildCount { get; }
    public RuleContext(RuleContext parent, int invokingState);
    public static RuleContext GetChildContext(RuleContext parent, int invokingState);
    public virtual int Depth();
    public virtual bool get_IsEmpty();
    public virtual Interval get_SourceInterval();
    private sealed virtual override RuleContext Antlr4.Runtime.Tree.IRuleNode.get_RuleContext();
    public virtual RuleContext get_Parent();
    public virtual void set_Parent(RuleContext value);
    private sealed virtual override IRuleNode Antlr4.Runtime.Tree.IRuleNode.get_Parent();
    private sealed virtual override IParseTree Antlr4.Runtime.Tree.IParseTree.get_Parent();
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.get_Parent();
    public virtual RuleContext get_Payload();
    private sealed virtual override object Antlr4.Runtime.Tree.ITree.get_Payload();
    public virtual string GetText();
    public virtual int get_RuleIndex();
    public virtual int getAltNumber();
    public virtual void setAltNumber(int altNumber);
    public virtual IParseTree GetChild(int i);
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.GetChild(int i);
    public virtual int get_ChildCount();
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public virtual string ToStringTree(Parser recog);
    public virtual string ToStringTree(IList`1<string> ruleNames);
    public virtual string ToStringTree();
    public virtual string ToString();
    public string ToString(IRecognizer recog);
    public string ToString(IList`1<string> ruleNames);
    public virtual string ToString(IRecognizer recog, RuleContext stop);
    public virtual string ToString(IList`1<string> ruleNames, RuleContext stop);
}
[AttributeUsageAttribute("32767")]
public class Antlr4.Runtime.RuleDependencyAttribute : Attribute {
    private Type _recognizer;
    private int _rule;
    private int _version;
    private Dependents _dependents;
    public Type Recognizer { get; }
    public int Rule { get; }
    public int Version { get; }
    public Dependents Dependents { get; }
    public RuleDependencyAttribute(Type recognizer, int rule, int version);
    public RuleDependencyAttribute(Type recognizer, int rule, int version, Dependents dependents);
    public Type get_Recognizer();
    public int get_Rule();
    public int get_Version();
    public Dependents get_Dependents();
}
[AttributeUsageAttribute("64")]
public class Antlr4.Runtime.RuleVersionAttribute : Attribute {
    private int _version;
    public int Version { get; }
    public RuleVersionAttribute(int version);
    public int get_Version();
}
internal static class Antlr4.Runtime.Sharpen.Arrays : object {
    public static T[] CopyOf(T[] array, int newSize);
    public static IList`1<T> AsList(T[] array);
    public static void Fill(T[] array, T value);
    public static int HashCode(T[] array);
    public static bool Equals(T[] left, T[] right);
    public static string ToString(T[] array);
}
public class Antlr4.Runtime.Sharpen.AtomicReference`1 : object {
    private T modreq(System.Runtime.CompilerServices.IsVolatile) _value;
    public AtomicReference`1(T value);
    public T Get();
    public void Set(T value);
    public bool CompareAndSet(T expect, T update);
    public T GetAndSet(T value);
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Sharpen.BitSet : object {
    private static UInt64[] EmptyBits;
    private static int BitsPerElement;
    private UInt64[] _data;
    private static Int32[] index64;
    public bool Item { get; public set; }
    public BitSet(int nbits);
    private static BitSet();
    private static int GetBitCount(UInt64[] value);
    private static int BitScanForward(ulong value);
    public BitSet Clone();
    public void Clear(int index);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public bool Get(int index);
    public void Set(int index);
    public bool IsEmpty();
    public int Cardinality();
    public int NextSetBit(int fromIndex);
    public void And(BitSet set);
    public void Or(BitSet set);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class Antlr4.Runtime.Sharpen.Collections : object {
    public static T[] EmptyList();
    public static ReadOnlyDictionary`2<TKey, TValue> EmptyMap();
    public static ReadOnlyCollection`1<T> SingletonList(T item);
    public static ReadOnlyDictionary`2<TKey, TValue> SingletonMap(TKey key, TValue value);
}
[ExtensionAttribute]
internal static class Antlr4.Runtime.Sharpen.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue Get(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue Put(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
}
[ExtensionAttribute]
internal static class Antlr4.Runtime.Sharpen.ListExtensions : object {
    [ExtensionAttribute]
public static T Set(IList`1<T> list, int index, T value);
}
internal static class Antlr4.Runtime.Sharpen.Runtime : object {
    public static string Substring(string str, int beginOffset, int endOffset);
}
internal class Antlr4.Runtime.Sharpen.SequenceEqualityComparer`1 : EqualityComparer`1<IEnumerable`1<T>> {
    private static SequenceEqualityComparer`1<T> _default;
    private IEqualityComparer`1<T> _elementEqualityComparer;
    public static SequenceEqualityComparer`1<T> Default { get; }
    public SequenceEqualityComparer`1(IEqualityComparer`1<T> elementComparer);
    private static SequenceEqualityComparer`1();
    public static SequenceEqualityComparer`1<T> get_Default();
    public virtual bool Equals(IEnumerable`1<T> x, IEnumerable`1<T> y);
    public virtual int GetHashCode(IEnumerable`1<T> obj);
}
public static class Antlr4.Runtime.TokenConstants : object {
    public static int InvalidType;
    public static int EPSILON;
    public static int MinUserTokenType;
    public static int EOF;
    public static int DefaultChannel;
    public static int HiddenChannel;
    public static int MinUserChannelValue;
}
public class Antlr4.Runtime.TokenStreamRewriter : object {
    public static string DefaultProgramName;
    public static int ProgramInitSize;
    public static int MinTokenIndex;
    protected internal ITokenStream tokens;
    protected internal IDictionary`2<string, IList`1<RewriteOperation>> programs;
    protected internal IDictionary`2<string, int> lastRewriteTokenIndexes;
    public ITokenStream TokenStream { get; }
    public int LastRewriteTokenIndex { get; }
    public TokenStreamRewriter(ITokenStream tokens);
    public ITokenStream get_TokenStream();
    public virtual void Rollback(int instructionIndex);
    public virtual void Rollback(string programName, int instructionIndex);
    public virtual void DeleteProgram();
    public virtual void DeleteProgram(string programName);
    public virtual void InsertAfter(IToken t, object text);
    public virtual void InsertAfter(int index, object text);
    public virtual void InsertAfter(string programName, IToken t, object text);
    public virtual void InsertAfter(string programName, int index, object text);
    public virtual void InsertBefore(IToken t, object text);
    public virtual void InsertBefore(int index, object text);
    public virtual void InsertBefore(string programName, IToken t, object text);
    public virtual void InsertBefore(string programName, int index, object text);
    public virtual void Replace(int index, object text);
    public virtual void Replace(int from, int to, object text);
    public virtual void Replace(IToken indexT, object text);
    public virtual void Replace(IToken from, IToken to, object text);
    public virtual void Replace(string programName, int from, int to, object text);
    public virtual void Replace(string programName, IToken from, IToken to, object text);
    public virtual void Delete(int index);
    public virtual void Delete(int from, int to);
    public virtual void Delete(IToken indexT);
    public virtual void Delete(IToken from, IToken to);
    public virtual void Delete(string programName, int from, int to);
    public virtual void Delete(string programName, IToken from, IToken to);
    public virtual int get_LastRewriteTokenIndex();
    protected internal virtual int GetLastRewriteTokenIndex(string programName);
    protected internal virtual void SetLastRewriteTokenIndex(string programName, int i);
    protected internal virtual IList`1<RewriteOperation> GetProgram(string name);
    private IList`1<RewriteOperation> InitializeProgram(string name);
    public virtual string GetText();
    public virtual string GetText(Interval interval);
    public virtual string GetText(string programName, Interval interval);
    protected internal virtual IDictionary`2<int, RewriteOperation> ReduceToSingleOperationPerIndex(IList`1<RewriteOperation> rewrites);
    protected internal virtual string CatOpText(object a, object b);
    protected internal virtual IList`1<T> GetKindOfOps(IList`1<RewriteOperation> rewrites, int before);
}
public static class Antlr4.Runtime.TokenTypes : object {
    public static int More;
    public static int Skip;
}
public abstract class Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1 : object {
    protected internal Result DefaultResult { get; }
    public virtual Result Visit(IParseTree tree);
    public virtual Result VisitChildren(IRuleNode node);
    public virtual Result VisitTerminal(ITerminalNode node);
    public virtual Result VisitErrorNode(IErrorNode node);
    protected internal virtual Result get_DefaultResult();
    protected internal virtual Result AggregateResult(Result aggregate, Result nextResult);
    protected internal virtual bool ShouldVisitNextChild(IRuleNode node, Result currentResult);
}
public class Antlr4.Runtime.Tree.ErrorNodeImpl : TerminalNodeImpl {
    public ErrorNodeImpl(IToken token);
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
}
public interface Antlr4.Runtime.Tree.IErrorNode {
}
public interface Antlr4.Runtime.Tree.IParseTree {
    public IParseTree Parent { get; }
    public abstract virtual IParseTree get_Parent();
    public abstract virtual IParseTree GetChild(int i);
    public abstract virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public abstract virtual string GetText();
    public abstract virtual string ToStringTree(Parser parser);
}
public interface Antlr4.Runtime.Tree.IParseTreeListener {
    public abstract virtual void VisitTerminal(ITerminalNode node);
    public abstract virtual void VisitErrorNode(IErrorNode node);
    public abstract virtual void EnterEveryRule(ParserRuleContext ctx);
    public abstract virtual void ExitEveryRule(ParserRuleContext ctx);
}
public interface Antlr4.Runtime.Tree.IParseTreeVisitor`1 {
    public abstract virtual Result Visit(IParseTree tree);
    public abstract virtual Result VisitChildren(IRuleNode node);
    public abstract virtual Result VisitTerminal(ITerminalNode node);
    public abstract virtual Result VisitErrorNode(IErrorNode node);
}
public interface Antlr4.Runtime.Tree.IRuleNode {
    public RuleContext RuleContext { get; }
    public IRuleNode Parent { get; }
    public abstract virtual RuleContext get_RuleContext();
    public abstract virtual IRuleNode get_Parent();
}
public interface Antlr4.Runtime.Tree.ISyntaxTree {
    public Interval SourceInterval { get; }
    public abstract virtual Interval get_SourceInterval();
}
public interface Antlr4.Runtime.Tree.ITerminalNode {
    public IToken Symbol { get; }
    public IRuleNode Parent { get; }
    public abstract virtual IToken get_Symbol();
    public abstract virtual IRuleNode get_Parent();
}
public interface Antlr4.Runtime.Tree.ITree {
    public ITree Parent { get; }
    public object Payload { get; }
    public int ChildCount { get; }
    public abstract virtual ITree get_Parent();
    public abstract virtual object get_Payload();
    public abstract virtual ITree GetChild(int i);
    public abstract virtual int get_ChildCount();
    public abstract virtual string ToStringTree();
}
public class Antlr4.Runtime.Tree.ParseTreeProperty`1 : object {
    protected internal ConcurrentDictionary`2<IParseTree, V> annotations;
    public virtual V Get(IParseTree node);
    public virtual void Put(IParseTree node, V value);
    public virtual V RemoveFrom(IParseTree node);
}
public class Antlr4.Runtime.Tree.ParseTreeWalker : object {
    public static ParseTreeWalker Default;
    private static ParseTreeWalker();
    public virtual void Walk(IParseTreeListener listener, IParseTree t);
    protected internal virtual void EnterRule(IParseTreeListener listener, IRuleNode r);
    protected internal virtual void ExitRule(IParseTreeListener listener, IRuleNode r);
}
internal abstract class Antlr4.Runtime.Tree.Pattern.Chunk : object {
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreeMatch : object {
    private IParseTree tree;
    private ParseTreePattern pattern;
    private MultiMap`2<string, IParseTree> labels;
    private IParseTree mismatchedNode;
    [NotNullAttribute]
public MultiMap`2<string, IParseTree> Labels { get; }
    [NullableAttribute]
public IParseTree MismatchedNode { get; }
    public bool Succeeded { get; }
    [NotNullAttribute]
public ParseTreePattern Pattern { get; }
    [NotNullAttribute]
public IParseTree Tree { get; }
    public ParseTreeMatch(IParseTree tree, ParseTreePattern pattern, MultiMap`2<string, IParseTree> labels, IParseTree mismatchedNode);
    public virtual IParseTree Get(string label);
    public virtual IList`1<IParseTree> GetAll(string label);
    public virtual MultiMap`2<string, IParseTree> get_Labels();
    public virtual IParseTree get_MismatchedNode();
    public virtual bool get_Succeeded();
    public virtual ParseTreePattern get_Pattern();
    public virtual IParseTree get_Tree();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreePattern : object {
    private int patternRuleIndex;
    [NotNullAttribute]
private string pattern;
    [NotNullAttribute]
private IParseTree patternTree;
    [NotNullAttribute]
private ParseTreePatternMatcher matcher;
    [NotNullAttribute]
public ParseTreePatternMatcher Matcher { get; }
    [NotNullAttribute]
public string Pattern { get; }
    public int PatternRuleIndex { get; }
    [NotNullAttribute]
public IParseTree PatternTree { get; }
    public ParseTreePattern(ParseTreePatternMatcher matcher, string pattern, int patternRuleIndex, IParseTree patternTree);
    public virtual ParseTreeMatch Match(IParseTree tree);
    public virtual bool Matches(IParseTree tree);
    public virtual IList`1<ParseTreeMatch> FindAll(IParseTree tree, string xpath);
    public virtual ParseTreePatternMatcher get_Matcher();
    public virtual string get_Pattern();
    public virtual int get_PatternRuleIndex();
    public virtual IParseTree get_PatternTree();
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher : object {
    private Lexer lexer;
    private Parser parser;
    protected internal string start;
    protected internal string stop;
    protected internal string escape;
    [NotNullAttribute]
public Lexer Lexer { get; }
    [NotNullAttribute]
public Parser Parser { get; }
    public ParseTreePatternMatcher(Lexer lexer, Parser parser);
    public virtual void SetDelimiters(string start, string stop, string escapeLeft);
    public virtual bool Matches(IParseTree tree, string pattern, int patternRuleIndex);
    public virtual bool Matches(IParseTree tree, ParseTreePattern pattern);
    public virtual ParseTreeMatch Match(IParseTree tree, string pattern, int patternRuleIndex);
    public virtual ParseTreeMatch Match(IParseTree tree, ParseTreePattern pattern);
    public virtual ParseTreePattern Compile(string pattern, int patternRuleIndex);
    public virtual Lexer get_Lexer();
    public virtual Parser get_Parser();
    protected internal virtual IParseTree MatchImpl(IParseTree tree, IParseTree patternTree, MultiMap`2<string, IParseTree> labels);
    protected internal virtual RuleTagToken GetRuleTagToken(IParseTree t);
    public virtual IList`1<IToken> Tokenize(string pattern);
    internal virtual IList`1<Chunk> Split(string pattern);
}
public class Antlr4.Runtime.Tree.Pattern.RuleTagToken : object {
    private string ruleName;
    private int bypassTokenType;
    private string label;
    [NotNullAttribute]
public string RuleName { get; }
    [NullableAttribute]
public string Label { get; }
    public int Channel { get; }
    public string Text { get; }
    public int Type { get; }
    public int Line { get; }
    public int Column { get; }
    public int TokenIndex { get; }
    public int StartIndex { get; }
    public int StopIndex { get; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public RuleTagToken(string ruleName, int bypassTokenType);
    public RuleTagToken(string ruleName, int bypassTokenType, string label);
    public string get_RuleName();
    public string get_Label();
    public virtual int get_Channel();
    public virtual string get_Text();
    public virtual int get_Type();
    public virtual int get_Line();
    public virtual int get_Column();
    public virtual int get_TokenIndex();
    public virtual int get_StartIndex();
    public virtual int get_StopIndex();
    public virtual ITokenSource get_TokenSource();
    public virtual ICharStream get_InputStream();
    public virtual string ToString();
}
internal class Antlr4.Runtime.Tree.Pattern.TagChunk : Chunk {
    private string tag;
    private string label;
    [NotNullAttribute]
public string Tag { get; }
    [NullableAttribute]
public string Label { get; }
    public TagChunk(string tag);
    public TagChunk(string label, string tag);
    public string get_Tag();
    public string get_Label();
    public virtual string ToString();
}
internal class Antlr4.Runtime.Tree.Pattern.TextChunk : Chunk {
    [NotNullAttribute]
private string text;
    [NotNullAttribute]
public string Text { get; }
    public TextChunk(string text);
    public string get_Text();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.Pattern.TokenTagToken : CommonToken {
    [NotNullAttribute]
private string tokenName;
    [NullableAttribute]
private string label;
    [NotNullAttribute]
public string TokenName { get; }
    [NullableAttribute]
public string Label { get; }
    public string Text { get; }
    public TokenTagToken(string tokenName, int type);
    public TokenTagToken(string tokenName, int type, string label);
    public string get_TokenName();
    public string get_Label();
    public virtual string get_Text();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.TerminalNodeImpl : object {
    private IToken _symbol;
    private IRuleNode _parent;
    public IToken Symbol { get; }
    public IRuleNode Parent { get; public set; }
    private IParseTree Antlr4.Runtime.Tree.IParseTree.Parent { get; }
    private ITree Antlr4.Runtime.Tree.ITree.Parent { get; }
    public IToken Payload { get; }
    private object Antlr4.Runtime.Tree.ITree.Payload { get; }
    public Interval SourceInterval { get; }
    public int ChildCount { get; }
    public TerminalNodeImpl(IToken symbol);
    public virtual IParseTree GetChild(int i);
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.GetChild(int i);
    public virtual IToken get_Symbol();
    public virtual IRuleNode get_Parent();
    public virtual void set_Parent(IRuleNode value);
    private sealed virtual override IParseTree Antlr4.Runtime.Tree.IParseTree.get_Parent();
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.get_Parent();
    public virtual IToken get_Payload();
    private sealed virtual override object Antlr4.Runtime.Tree.ITree.get_Payload();
    public virtual Interval get_SourceInterval();
    public virtual int get_ChildCount();
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public virtual string GetText();
    public virtual string ToStringTree(Parser parser);
    public virtual string ToString();
    public virtual string ToStringTree();
}
public class Antlr4.Runtime.Tree.Trees : object {
    public static string ToStringTree(ITree t);
    public static string ToStringTree(ITree t, Parser recog);
    public static string ToStringTree(ITree t, IList`1<string> ruleNames);
    public static string GetNodeText(ITree t, Parser recog);
    public static string GetNodeText(ITree t, IList`1<string> ruleNames);
    public static IList`1<ITree> GetChildren(ITree t);
    public static IList`1<ITree> GetAncestors(ITree t);
    public static ICollection`1<IParseTree> FindAllTokenNodes(IParseTree t, int ttype);
    public static ICollection`1<IParseTree> FindAllRuleNodes(IParseTree t, int ruleIndex);
    public static IList`1<IParseTree> FindAllNodes(IParseTree t, int index, bool findTokens);
    private static void _findAllNodes(IParseTree t, int index, bool findTokens, IList`1<IParseTree> nodes);
    public static IList`1<IParseTree> Descendants(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPath : object {
    public static string Wildcard;
    public static string Not;
    protected internal string path;
    protected internal XPathElement[] elements;
    protected internal Parser parser;
    public XPath(Parser parser, string path);
    public virtual XPathElement[] Split(string path);
    protected internal virtual XPathElement GetXPathElement(IToken wordToken, bool anywhere);
    public static ICollection`1<IParseTree> FindAll(IParseTree tree, string xpath, Parser parser);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public abstract class Antlr4.Runtime.Tree.Xpath.XPathElement : object {
    protected internal string nodeName;
    protected internal bool invert;
    public XPathElement(string nodeName);
    public abstract virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.Xpath.XPathLexerErrorListener : object {
    public virtual void SyntaxError(TextWriter output, IRecognizer recognizer, int offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.Tree.Xpath.XPathRuleAnywhereElement : XPathElement {
    protected internal int ruleIndex;
    public XPathRuleAnywhereElement(string ruleName, int ruleIndex);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathRuleElement : XPathElement {
    protected internal int ruleIndex;
    public XPathRuleElement(string ruleName, int ruleIndex);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathTokenAnywhereElement : XPathElement {
    protected internal int tokenType;
    public XPathTokenAnywhereElement(string tokenName, int tokenType);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathTokenElement : XPathElement {
    protected internal int tokenType;
    public XPathTokenElement(string tokenName, int tokenType);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathWildcardAnywhereElement : XPathElement {
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathWildcardElement : XPathElement {
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.UnbufferedCharStream : object {
    protected internal Int32[] data;
    protected internal int n;
    protected internal int p;
    protected internal int numMarkers;
    protected internal int lastChar;
    protected internal int lastCharBufferStart;
    protected internal int currentCharIndex;
    protected internal TextReader input;
    public string name;
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    protected internal int BufferStartIndex { get; }
    public UnbufferedCharStream(int bufferSize);
    public UnbufferedCharStream(Stream input);
    public UnbufferedCharStream(TextReader input);
    public UnbufferedCharStream(Stream input, int bufferSize);
    public UnbufferedCharStream(TextReader input, int bufferSize);
    public virtual void Consume();
    protected internal virtual void Sync(int want);
    protected internal virtual int Fill(int n);
    protected internal virtual int NextChar();
    protected internal virtual void Add(int c);
    public virtual int LA(int i);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Index();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual string get_SourceName();
    public virtual string GetText(Interval interval);
    protected internal int get_BufferStartIndex();
}
public class Antlr4.Runtime.UnbufferedTokenStream : object {
    private ITokenSource _tokenSource;
    protected internal IToken[] tokens;
    protected internal int n;
    protected internal int p;
    protected internal int numMarkers;
    protected internal IToken lastToken;
    protected internal IToken lastTokenBufferStart;
    protected internal int currentTokenIndex;
    public ITokenSource TokenSource { get; public set; }
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public UnbufferedTokenStream(ITokenSource tokenSource);
    public UnbufferedTokenStream(ITokenSource tokenSource, int bufferSize);
    public virtual IToken Get(int i);
    public virtual IToken LT(int i);
    public virtual int LA(int i);
    public virtual ITokenSource get_TokenSource();
    public virtual void set_TokenSource(ITokenSource value);
    public virtual string GetText();
    public virtual string GetText(RuleContext ctx);
    public virtual string GetText(IToken start, IToken stop);
    public virtual void Consume();
    protected internal virtual void Sync(int want);
    protected internal virtual int Fill(int n);
    protected internal virtual void Add(IToken t);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Index();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual string get_SourceName();
    public virtual string GetText(Interval interval);
    protected internal int GetBufferStartIndex();
}
public class Antlr4.Runtime.Vocabulary : object {
    private static String[] EmptyNames;
    [NotNullAttribute]
public static Vocabulary EmptyVocabulary;
    [NotNullAttribute]
private String[] literalNames;
    [NotNullAttribute]
private String[] symbolicNames;
    [NotNullAttribute]
private String[] displayNames;
    private int maxTokenType;
    public Vocabulary(String[] literalNames, String[] symbolicNames);
    public Vocabulary(String[] literalNames, String[] symbolicNames, String[] displayNames);
    private static Vocabulary();
    public virtual int getMaxTokenType();
    public virtual string GetLiteralName(int tokenType);
    public virtual string GetSymbolicName(int tokenType);
    public virtual string GetDisplayName(int tokenType);
}
[GeneratedCodeAttribute("ANTLR", "4.11.2-SNAPSHOT")]
[CLSCompliantAttribute("False")]
public class XPathLexer : Lexer {
    protected static DFA[] decisionToDFA;
    protected static PredictionContextCache sharedContextCache;
    public static int TokenRef;
    public static int RuleRef;
    public static int Anywhere;
    public static int Root;
    public static int Wildcard;
    public static int Bang;
    public static int ID;
    public static int String;
    public static String[] channelNames;
    public static String[] modeNames;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    private static Int32[] _serializedATN;
    public static ATN _ATN;
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ChannelNames { get; }
    public String[] ModeNames { get; }
    public Int32[] SerializedAtn { get; }
    public XPathLexer(ICharStream input);
    public XPathLexer(ICharStream input, TextWriter output, TextWriter errorOutput);
    private static XPathLexer();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ChannelNames();
    public virtual String[] get_ModeNames();
    public virtual Int32[] get_SerializedAtn();
    public virtual void Action(RuleContext _localctx, int ruleIndex, int actionIndex);
    private void ID_action(RuleContext _localctx, int actionIndex);
}
