public class Antlr4.Runtime.AntlrFileStream : AntlrInputStream {
    protected internal string fileName;
    public string SourceName { get; }
    public AntlrFileStream(string fileName);
    public AntlrFileStream(string fileName, Encoding encoding);
    public virtual void Load(string fileName, Encoding encoding);
    public virtual string get_SourceName();
    private static string ReadAllText(string path);
    private static string ReadAllText(string path, Encoding encoding);
}
public class Antlr4.Runtime.AntlrInputStream : object {
    public static int ReadBufferSize;
    public static int InitialBufferSize;
    protected internal Char[] data;
    protected internal int n;
    protected internal int p;
    public string name;
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public AntlrInputStream(string input);
    public AntlrInputStream(Char[] data, int numberOfActualCharsInArray);
    public AntlrInputStream(TextReader r);
    public AntlrInputStream(TextReader r, int initialSize);
    public AntlrInputStream(TextReader r, int initialSize, int readChunkSize);
    public AntlrInputStream(Stream input);
    public AntlrInputStream(Stream input, int initialSize);
    public AntlrInputStream(Stream input, int initialSize, int readChunkSize);
    public virtual void Load(TextReader r, int size, int readChunkSize);
    public virtual void Reset();
    public virtual void Consume();
    public virtual int La(int i);
    public virtual int Lt(int i);
    public virtual int get_Index();
    public virtual int get_Size();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Seek(int index);
    public virtual string GetText(Interval interval);
    public virtual string get_SourceName();
    public virtual string ToString();
}
public abstract class Antlr4.Runtime.Atn.AbstractPredicateTransition : Transition {
    public AbstractPredicateTransition(ATNState target);
}
public class Antlr4.Runtime.Atn.ActionTransition : Transition {
    public int ruleIndex;
    public int actionIndex;
    public bool isCtxDependent;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public ActionTransition(ATNState target, int ruleIndex);
    public ActionTransition(ATNState target, int ruleIndex, int actionIndex, bool isCtxDependent);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.AmbiguityInfo : DecisionEventInfo {
    [NotNullAttribute]
private BitSet ambigAlts;
    public BitSet AmbiguousAlternatives { get; }
    public AmbiguityInfo(int decision, SimulatorState state, BitSet ambigAlts, ITokenStream input, int startIndex, int stopIndex);
    public virtual BitSet get_AmbiguousAlternatives();
}
public class Antlr4.Runtime.Atn.ArrayPredictionContext : PredictionContext {
    [NotNullAttribute]
public PredictionContext[] parents;
    [NotNullAttribute]
public Int32[] returnStates;
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmpty { get; }
    internal ArrayPredictionContext(PredictionContext[] parents, Int32[] returnStates);
    internal ArrayPredictionContext(PredictionContext[] parents, Int32[] returnStates, int hashCode);
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual int FindReturnState(int returnState);
    public virtual int get_Size();
    public virtual bool get_IsEmpty();
    public virtual bool get_HasEmpty();
    protected internal virtual PredictionContext AddEmptyContext();
    protected internal virtual PredictionContext RemoveEmptyContext();
    public virtual PredictionContext AppendContext(PredictionContext suffix, PredictionContextCache contextCache);
    private static PredictionContext AppendContext(PredictionContext context, PredictionContext suffix, IdentityHashMap visited);
    public virtual bool Equals(object o);
    private bool Equals(ArrayPredictionContext other, HashSet`1<IdentityCommutativePredictionContextOperands> visited);
}
public class Antlr4.Runtime.Atn.ATN : object {
    public static int InvalidAltNumber;
    [NotNullAttribute]
public IList`1<ATNState> states;
    [NotNullAttribute]
public IList`1<DecisionState> decisionToState;
    public RuleStartState[] ruleToStartState;
    public RuleStopState[] ruleToStopState;
    [NotNullAttribute]
public IDictionary`2<string, TokensStartState> modeNameToStartState;
    public ATNType grammarType;
    public int maxTokenType;
    public Int32[] ruleToTokenType;
    public ILexerAction[] lexerActions;
    [NotNullAttribute]
public IList`1<TokensStartState> modeToStartState;
    private ConcurrentDictionary`2<PredictionContext, PredictionContext> contextCache;
    [NotNullAttribute]
public DFA[] decisionToDFA;
    [NotNullAttribute]
public DFA[] modeToDFA;
    protected internal ConcurrentDictionary`2<int, int> LL1Table;
    public int ContextCacheSize { get; }
    public DFA[] DecisionToDfa { get; }
    public int NumberOfDecisions { get; }
    public ATN(ATNType grammarType, int maxTokenType);
    public void ClearDFA();
    public virtual int get_ContextCacheSize();
    public virtual PredictionContext GetCachedContext(PredictionContext context);
    public DFA[] get_DecisionToDfa();
    public virtual IntervalSet NextTokens(ATNState s, PredictionContext ctx);
    public virtual IntervalSet NextTokens(ATNState s);
    public virtual void AddState(ATNState state);
    public virtual void RemoveState(ATNState state);
    public virtual void DefineMode(string name, TokensStartState s);
    public virtual int DefineDecisionState(DecisionState s);
    public virtual DecisionState GetDecisionState(int decision);
    public virtual int get_NumberOfDecisions();
    public virtual IntervalSet GetExpectedTokens(int stateNumber, RuleContext context);
}
public class Antlr4.Runtime.Atn.ATNConfig : object {
    private static int SuppressPrecedenceFilter;
    [NotNullAttribute]
private ATNState state;
    private int altAndOuterContextDepth;
    [NotNullAttribute]
private PredictionContext context;
    public ATNState State { get; }
    public int Alt { get; }
    public PredictionContext Context { get; public set; }
    public bool ReachesIntoOuterContext { get; }
    public int OuterContextDepth { get; public set; }
    public LexerActionExecutor ActionExecutor { get; }
    public SemanticContext SemanticContext { get; }
    public bool PassedThroughNonGreedyDecision { get; }
    public bool PrecedenceFilterSuppressed { get; public set; }
    protected internal ATNConfig(ATNState state, int alt, PredictionContext context);
    protected internal ATNConfig(ATNConfig c, ATNState state, PredictionContext context);
    public static ATNConfig Create(ATNState state, int alt, PredictionContext context);
    public static ATNConfig Create(ATNState state, int alt, PredictionContext context, SemanticContext semanticContext);
    public static ATNConfig Create(ATNState state, int alt, PredictionContext context, SemanticContext semanticContext, LexerActionExecutor lexerActionExecutor);
    public ATNState get_State();
    public int get_Alt();
    public virtual PredictionContext get_Context();
    public virtual void set_Context(PredictionContext value);
    public bool get_ReachesIntoOuterContext();
    public virtual int get_OuterContextDepth();
    public virtual void set_OuterContextDepth(int value);
    public virtual LexerActionExecutor get_ActionExecutor();
    public virtual SemanticContext get_SemanticContext();
    public virtual bool get_PassedThroughNonGreedyDecision();
    public ATNConfig Clone();
    public ATNConfig Transform(ATNState state, bool checkNonGreedy);
    public ATNConfig Transform(ATNState state, SemanticContext semanticContext, bool checkNonGreedy);
    public ATNConfig Transform(ATNState state, PredictionContext context, bool checkNonGreedy);
    public ATNConfig Transform(ATNState state, LexerActionExecutor lexerActionExecutor, bool checkNonGreedy);
    private ATNConfig Transform(ATNState state, PredictionContext context, SemanticContext semanticContext, bool checkNonGreedy, LexerActionExecutor lexerActionExecutor);
    private static bool CheckNonGreedyDecision(ATNConfig source, ATNState target);
    public virtual ATNConfig AppendContext(int context, PredictionContextCache contextCache);
    public virtual ATNConfig AppendContext(PredictionContext context, PredictionContextCache contextCache);
    public virtual bool Contains(ATNConfig subconfig);
    public bool get_PrecedenceFilterSuppressed();
    public void set_PrecedenceFilterSuppressed(bool value);
    public virtual bool Equals(object o);
    public virtual bool Equals(ATNConfig other);
    public virtual int GetHashCode();
    public virtual string ToDotString();
    public virtual string ToString();
    public virtual string ToString(IRecognizer recog, bool showAlt);
    public virtual string ToString(IRecognizer recog, bool showAlt, bool showContext);
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Atn.ATNConfigSet : object {
    private Dictionary`2<long, ATNConfig> mergedConfigs;
    private List`1<ATNConfig> unmerged;
    private List`1<ATNConfig> configs;
    private int uniqueAlt;
    private ConflictInfo conflictInfo;
    private bool hasSemanticContext;
    private bool dipsIntoOuterContext;
    private bool outermostConfigSet;
    private int cachedHashCode;
    [NotNullAttribute]
public BitSet RepresentedAlternatives { get; }
    public bool IsReadOnly { get; }
    public bool IsOutermostConfigSet { get; public set; }
    public HashSet`1<ATNState> States { get; }
    public int Count { get; }
    public int UniqueAlt { get; }
    public bool HasSemanticContext { get; }
    public ConflictInfo ConflictInformation { get; public set; }
    public BitSet ConflictingAlts { get; }
    public bool IsExactConflict { get; }
    public bool DipsIntoOuterContext { get; }
    public ATNConfig Item { get; }
    protected internal ATNConfigSet(ATNConfigSet set, bool readonly);
    public virtual BitSet get_RepresentedAlternatives();
    public bool get_IsReadOnly();
    public virtual bool get_IsOutermostConfigSet();
    public virtual void set_IsOutermostConfigSet(bool value);
    public virtual HashSet`1<ATNState> get_States();
    public virtual void OptimizeConfigs(ATNSimulator interpreter);
    public virtual ATNConfigSet Clone(bool readonly);
    public virtual int get_Count();
    public virtual bool IsEmpty();
    public virtual bool Contains(object o);
    public virtual IEnumerator`1<ATNConfig> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Object[] ToArray();
    public virtual bool Add(ATNConfig e);
    public virtual bool Add(ATNConfig e, PredictionContextCache contextCache);
    private void UpdatePropertiesForMergedConfig(ATNConfig config);
    private void UpdatePropertiesForAddedConfig(ATNConfig config);
    protected internal virtual bool CanMerge(ATNConfig left, long leftKey, ATNConfig right);
    protected internal virtual long GetKey(ATNConfig e);
    public virtual bool Remove(object o);
    public virtual bool ContainsAll(IEnumerable`1<ATNConfig> c);
    public virtual bool AddAll(IEnumerable`1<ATNConfig> c);
    public virtual bool AddAll(IEnumerable`1<ATNConfig> c, PredictionContextCache contextCache);
    public virtual bool RetainAll(ICollection`1<_T0> c);
    public virtual bool RemoveAll(ICollection`1<_T0> c);
    public virtual void Clear();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string ToString(bool showContext);
    public virtual int get_UniqueAlt();
    public virtual bool get_HasSemanticContext();
    public virtual void ClearExplicitSemanticContext();
    public virtual void MarkExplicitSemanticContext();
    public virtual ConflictInfo get_ConflictInformation();
    public virtual void set_ConflictInformation(ConflictInfo value);
    public virtual BitSet get_ConflictingAlts();
    public virtual bool get_IsExactConflict();
    public virtual bool get_DipsIntoOuterContext();
    public virtual ATNConfig get_Item(int index);
    public virtual void Remove(int index);
    protected internal void EnsureWritable();
}
public class Antlr4.Runtime.Atn.ATNDeserializationOptions : object {
    private static ATNDeserializationOptions defaultOptions;
    private bool readOnly;
    private bool verifyATN;
    private bool generateRuleBypassTransitions;
    private bool optimize;
    [NotNullAttribute]
public static ATNDeserializationOptions Default { get; }
    public bool IsReadOnly { get; }
    public bool VerifyAtn { get; public set; }
    public bool GenerateRuleBypassTransitions { get; public set; }
    public bool Optimize { get; public set; }
    private static ATNDeserializationOptions();
    public ATNDeserializationOptions(ATNDeserializationOptions options);
    public static ATNDeserializationOptions get_Default();
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public bool get_VerifyAtn();
    public void set_VerifyAtn(bool value);
    public bool get_GenerateRuleBypassTransitions();
    public void set_GenerateRuleBypassTransitions(bool value);
    public bool get_Optimize();
    public void set_Optimize(bool value);
    protected internal virtual void ThrowIfReadOnly();
}
public class Antlr4.Runtime.Atn.ATNDeserializer : object {
    public static int SerializedVersion;
    private static Guid BaseSerializedUuid;
    private static Guid AddedLexerActions;
    private static IList`1<Guid> SupportedUuids;
    public static Guid SerializedUuid;
    [NotNullAttribute]
private ATNDeserializationOptions deserializationOptions;
    private static ATNDeserializer();
    public ATNDeserializer(ATNDeserializationOptions deserializationOptions);
    protected internal virtual bool IsFeatureSupported(Guid feature, Guid actualUuid);
    public virtual ATN Deserialize(Char[] data);
    protected internal virtual void MarkPrecedenceDecisions(ATN atn);
    protected internal virtual void VerifyATN(ATN atn);
    protected internal virtual void CheckCondition(bool condition);
    protected internal virtual void CheckCondition(bool condition, string message);
    private static int InlineSetRules(ATN atn);
    private static int CombineChainedEpsilons(ATN atn);
    private static int OptimizeSets(ATN atn, bool preserveOrder);
    private static void IdentifyTailCalls(ATN atn);
    private static bool TestTailCall(ATN atn, RuleTransition transition, bool optimizedPath);
    protected internal static int ToInt(char c);
    protected internal static int ToInt32(Char[] data, int offset);
    protected internal static long ToLong(Char[] data, int offset);
    protected internal static Guid ToUUID(Char[] data, int offset);
    protected internal virtual Transition EdgeFactory(ATN atn, TransitionType type, int src, int trg, int arg1, int arg2, int arg3, IList`1<IntervalSet> sets);
    protected internal virtual ATNState StateFactory(StateType type, int ruleIndex);
    protected internal virtual ILexerAction LexerActionFactory(LexerActionType type, int data1, int data2);
}
public class Antlr4.Runtime.Atn.ATNSerializer : object {
    public ATN atn;
    private IList`1<string> ruleNames;
    private IList`1<string> tokenNames;
    public ATNSerializer(ATN atn, IList`1<string> ruleNames);
    public ATNSerializer(ATN atn, IList`1<string> ruleNames, IList`1<string> tokenNames);
    public virtual List`1<int> Serialize();
    public virtual string Decode(Char[] data);
    public virtual string GetTokenName(int t);
    public static string GetSerializedAsString(ATN atn, IList`1<string> ruleNames);
    public static List`1<int> GetSerialized(ATN atn, IList`1<string> ruleNames);
    public static Char[] GetSerializedAsChars(ATN atn, IList`1<string> ruleNames);
    public static string GetDecoded(ATN atn, IList`1<string> ruleNames, IList`1<string> tokenNames);
    private void SerializeUUID(List`1<int> data, Guid uuid);
    private void SerializeInt(List`1<int> data, int value);
}
public abstract class Antlr4.Runtime.Atn.ATNSimulator : object {
    [ObsoleteAttribute("Use ATNDeserializer.SerializedVersion instead.")]
public static int SerializedVersion;
    [ObsoleteAttribute("Use ATNDeserializer.CheckCondition(bool) instead.")]
public static Guid SerializedUuid;
    public static char RuleVariantDelimiter;
    public static string RuleLfVariantMarker;
    public static string RuleNolfVariantMarker;
    [NotNullAttribute]
public static DFAState Error;
    [NotNullAttribute]
public ATN atn;
    public ATNSimulator(ATN atn);
    private static ATNSimulator();
    public abstract virtual void Reset();
    public virtual void ClearDFA();
    [ObsoleteAttribute("Use ATNDeserializer.Deserialize(char[]) instead.")]
public static ATN Deserialize(Char[] data);
    [ObsoleteAttribute("Use ATNDeserializer.CheckCondition(bool) instead.")]
public static void CheckCondition(bool condition);
    [ObsoleteAttribute("Use ATNDeserializer.CheckCondition(bool, string) instead.")]
public static void CheckCondition(bool condition, string message);
    [ObsoleteAttribute("Use ATNDeserializer.ToInt(char) instead.")]
public static int ToInt(char c);
    [ObsoleteAttribute("Use ATNDeserializer.ToInt32(char[], int) instead.")]
public static int ToInt32(Char[] data, int offset);
    [ObsoleteAttribute("Use ATNDeserializer.ToLong(char[], int) instead.")]
public static long ToLong(Char[] data, int offset);
    [ObsoleteAttribute("Use ATNDeserializer.ToUUID(char[], int) instead.")]
public static Guid ToUUID(Char[] data, int offset);
    [ObsoleteAttribute("Use ATNDeserializer.EdgeFactory(ATN, TransitionType, int, int, int, int, int, System.Collections.Generic.IList{E}) instead.")]
public static Transition EdgeFactory(ATN atn, TransitionType type, int src, int trg, int arg1, int arg2, int arg3, IList`1<IntervalSet> sets);
    [ObsoleteAttribute("Use ATNDeserializer.StateFactory(StateType, int) instead.")]
public static ATNState StateFactory(StateType type, int ruleIndex);
}
public abstract class Antlr4.Runtime.Atn.ATNState : object {
    public static int InitialNumTransitions;
    public static ReadOnlyCollection`1<string> serializationNames;
    public static int InvalidStateNumber;
    public ATN atn;
    public int stateNumber;
    public int ruleIndex;
    public bool epsilonOnlyTransitions;
    protected internal List`1<Transition> transitions;
    protected internal List`1<Transition> optimizedTransitions;
    public IntervalSet nextTokenWithinRule;
    public int StateNumber { get; }
    public int NonStopStateNumber { get; }
    public bool IsNonGreedyExitState { get; }
    public Transition[] Transitions { get; }
    public int NumberOfTransitions { get; }
    public StateType StateType { get; }
    public bool OnlyHasEpsilonTransitions { get; }
    public bool IsOptimized { get; }
    public int NumberOfOptimizedTransitions { get; }
    private static ATNState();
    public int get_StateNumber();
    public virtual int get_NonStopStateNumber();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual bool get_IsNonGreedyExitState();
    public virtual string ToString();
    public virtual Transition[] get_Transitions();
    public virtual int get_NumberOfTransitions();
    public virtual void AddTransition(Transition e);
    public virtual void AddTransition(int index, Transition e);
    public virtual Transition Transition(int i);
    public virtual void SetTransition(int i, Transition e);
    public virtual void RemoveTransition(int index);
    public abstract virtual StateType get_StateType();
    public bool get_OnlyHasEpsilonTransitions();
    public virtual void SetRuleIndex(int ruleIndex);
    public virtual bool get_IsOptimized();
    public virtual int get_NumberOfOptimizedTransitions();
    public virtual Transition GetOptimizedTransition(int i);
    public virtual void AddOptimizedTransition(Transition e);
    public virtual void SetOptimizedTransition(int i, Transition e);
    public virtual void RemoveOptimizedTransition(int i);
}
public enum Antlr4.Runtime.Atn.ATNType : Enum {
    public int value__;
    public static ATNType Lexer;
    public static ATNType Parser;
}
public class Antlr4.Runtime.Atn.AtomTransition : Transition {
    public int label;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public AtomTransition(ATNState target, int label);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.BasicBlockStartState : BlockStartState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.BasicState : ATNState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.BlockEndState : ATNState {
    public BlockStartState startState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public abstract class Antlr4.Runtime.Atn.BlockStartState : DecisionState {
    public BlockEndState endState;
}
public class Antlr4.Runtime.Atn.ConflictInfo : object {
    private BitSet conflictedAlts;
    private bool exact;
    public BitSet ConflictedAlts { get; }
    public bool IsExact { get; }
    public ConflictInfo(BitSet conflictedAlts, bool exact);
    public BitSet get_ConflictedAlts();
    public bool get_IsExact();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Antlr4.Runtime.Atn.ContextSensitivityInfo : DecisionEventInfo {
    public ContextSensitivityInfo(int decision, SimulatorState state, ITokenStream input, int startIndex, int stopIndex);
}
public class Antlr4.Runtime.Atn.DecisionEventInfo : object {
    public int decision;
    [NullableAttribute]
public SimulatorState state;
    [NotNullAttribute]
public ITokenStream input;
    public int startIndex;
    public int stopIndex;
    public bool fullCtx;
    public DecisionEventInfo(int decision, SimulatorState state, ITokenStream input, int startIndex, int stopIndex, bool fullCtx);
}
public class Antlr4.Runtime.Atn.DecisionInfo : object {
    public int decision;
    public long invocations;
    public long timeInPrediction;
    public long SLL_TotalLook;
    public long SLL_MinLook;
    public long SLL_MaxLook;
    public LookaheadEventInfo SLL_MaxLookEvent;
    public long LL_TotalLook;
    public long LL_MinLook;
    public long LL_MaxLook;
    public LookaheadEventInfo LL_MaxLookEvent;
    public IList`1<ContextSensitivityInfo> contextSensitivities;
    public IList`1<ErrorInfo> errors;
    public IList`1<AmbiguityInfo> ambiguities;
    public IList`1<PredicateEvalInfo> predicateEvals;
    public long SLL_ATNTransitions;
    public long SLL_DFATransitions;
    public long LL_Fallback;
    public long LL_ATNTransitions;
    public long LL_DFATransitions;
    public DecisionInfo(int decision);
    public virtual string ToString();
}
public abstract class Antlr4.Runtime.Atn.DecisionState : ATNState {
    public int decision;
    public bool nonGreedy;
    public bool sll;
}
public class Antlr4.Runtime.Atn.EmptyPredictionContext : PredictionContext {
    public static EmptyPredictionContext LocalContext;
    public static EmptyPredictionContext FullContext;
    private bool fullContext;
    public bool IsFullContext { get; }
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmpty { get; }
    private EmptyPredictionContext(bool fullContext);
    private static EmptyPredictionContext();
    public bool get_IsFullContext();
    protected internal virtual PredictionContext AddEmptyContext();
    protected internal virtual PredictionContext RemoveEmptyContext();
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual int FindReturnState(int returnState);
    public virtual int get_Size();
    public virtual PredictionContext AppendContext(int returnContext, PredictionContextCache contextCache);
    public virtual PredictionContext AppendContext(PredictionContext suffix, PredictionContextCache contextCache);
    public virtual bool get_IsEmpty();
    public virtual bool get_HasEmpty();
    public virtual bool Equals(object o);
    public virtual String[] ToStrings(IRecognizer recognizer, int currentState);
    public virtual String[] ToStrings(IRecognizer recognizer, PredictionContext stop, int currentState);
}
public class Antlr4.Runtime.Atn.EpsilonTransition : Transition {
    private int outermostPrecedenceReturn;
    public int OutermostPrecedenceReturn { get; }
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public EpsilonTransition(ATNState target);
    public EpsilonTransition(ATNState target, int outermostPrecedenceReturn);
    public int get_OutermostPrecedenceReturn();
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.ErrorInfo : DecisionEventInfo {
    public ErrorInfo(int decision, SimulatorState state, ITokenStream input, int startIndex, int stopIndex);
}
public interface Antlr4.Runtime.Atn.ILexerAction {
    [NotNullAttribute]
public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public abstract virtual LexerActionType get_ActionType();
    public abstract virtual bool get_IsPositionDependent();
    public abstract virtual void Execute(Lexer lexer);
}
public class Antlr4.Runtime.Atn.LexerActionExecutor : object {
    [NotNullAttribute]
private ILexerAction[] lexerActions;
    private int hashCode;
    [NotNullAttribute]
public ILexerAction[] LexerActions { get; }
    public LexerActionExecutor(ILexerAction[] lexerActions);
    public static LexerActionExecutor Append(LexerActionExecutor lexerActionExecutor, ILexerAction lexerAction);
    public virtual LexerActionExecutor FixOffsetBeforeMatch(int offset);
    public virtual ILexerAction[] get_LexerActions();
    public virtual void Execute(Lexer lexer, ICharStream input, int startIndex);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public enum Antlr4.Runtime.Atn.LexerActionType : Enum {
    public int value__;
    public static LexerActionType Channel;
    public static LexerActionType Custom;
    public static LexerActionType Mode;
    public static LexerActionType More;
    public static LexerActionType PopMode;
    public static LexerActionType PushMode;
    public static LexerActionType Skip;
    public static LexerActionType Type;
}
public class Antlr4.Runtime.Atn.LexerATNSimulator : ATNSimulator {
    public static bool debug;
    public static bool dfa_debug;
    public static int MinDfaEdge;
    public static int MaxDfaEdge;
    public bool optimize_tail_calls;
    [NullableAttribute]
protected internal Lexer recog;
    protected internal int startIndex;
    protected internal int line;
    protected internal int charPositionInLine;
    protected internal int mode;
    [NotNullAttribute]
protected internal SimState prevAccept;
    public static int match_calls;
    public int Line { get; public set; }
    public int Column { get; public set; }
    public LexerATNSimulator(ATN atn);
    public LexerATNSimulator(Lexer recog, ATN atn);
    private static LexerATNSimulator();
    public virtual void CopyState(LexerATNSimulator simulator);
    public virtual int Match(ICharStream input, int mode);
    public virtual void Reset();
    protected internal virtual int MatchATN(ICharStream input);
    protected internal virtual int ExecATN(ICharStream input, DFAState ds0);
    protected internal virtual DFAState GetExistingTargetState(DFAState s, int t);
    protected internal virtual DFAState ComputeTargetState(ICharStream input, DFAState s, int t);
    protected internal virtual int FailOrAccept(SimState prevAccept, ICharStream input, ATNConfigSet reach, int t);
    protected internal virtual void GetReachableConfigSet(ICharStream input, ATNConfigSet closure, ATNConfigSet reach, int t);
    protected internal virtual void Accept(ICharStream input, LexerActionExecutor lexerActionExecutor, int startIndex, int index, int line, int charPos);
    protected internal virtual ATNState GetReachableTarget(Transition trans, int t);
    protected internal virtual ATNConfigSet ComputeStartState(ICharStream input, ATNState p);
    protected internal virtual bool Closure(ICharStream input, ATNConfig config, ATNConfigSet configs, bool currentAltReachedAcceptState, bool speculative, bool treatEofAsEpsilon);
    protected internal virtual ATNConfig GetEpsilonTarget(ICharStream input, ATNConfig config, Transition t, ATNConfigSet configs, bool speculative, bool treatEofAsEpsilon);
    protected internal virtual bool EvaluatePredicate(ICharStream input, int ruleIndex, int predIndex, bool speculative);
    protected internal virtual void CaptureSimState(SimState settings, ICharStream input, DFAState dfaState);
    protected internal virtual DFAState AddDFAEdge(DFAState from, int t, ATNConfigSet q);
    protected internal virtual void AddDFAEdge(DFAState p, int t, DFAState q);
    protected internal virtual DFAState AddDFAState(ATNConfigSet configs);
    public DFA GetDFA(int mode);
    public virtual string GetText(ICharStream input);
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual int get_Column();
    public virtual void set_Column(int value);
    public virtual void Consume(ICharStream input);
    public virtual string GetTokenName(int t);
}
public class Antlr4.Runtime.Atn.LexerChannelAction : object {
    private int channel;
    public int Channel { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerChannelAction(int channel);
    public int get_Channel();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerCustomAction : object {
    private int ruleIndex;
    private int actionIndex;
    public int RuleIndex { get; }
    public int ActionIndex { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerCustomAction(int ruleIndex, int actionIndex);
    public int get_RuleIndex();
    public int get_ActionIndex();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Antlr4.Runtime.Atn.LexerIndexedCustomAction : object {
    private int offset;
    private ILexerAction action;
    public int Offset { get; }
    [NotNullAttribute]
public ILexerAction Action { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerIndexedCustomAction(int offset, ILexerAction action);
    public int get_Offset();
    public ILexerAction get_Action();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Antlr4.Runtime.Atn.LexerModeAction : object {
    private int mode;
    public int Mode { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerModeAction(int mode);
    public int get_Mode();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerMoreAction : object {
    public static LexerMoreAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerMoreAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerPopModeAction : object {
    public static LexerPopModeAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerPopModeAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerPushModeAction : object {
    private int mode;
    public int Mode { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerPushModeAction(int mode);
    public int get_Mode();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerSkipAction : object {
    public static LexerSkipAction Instance;
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    private static LexerSkipAction();
    public sealed virtual LexerActionType get_ActionType();
    public sealed virtual bool get_IsPositionDependent();
    public sealed virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LexerTypeAction : object {
    private int type;
    public int Type { get; }
    public LexerActionType ActionType { get; }
    public bool IsPositionDependent { get; }
    public LexerTypeAction(int type);
    public virtual int get_Type();
    public virtual LexerActionType get_ActionType();
    public virtual bool get_IsPositionDependent();
    public virtual void Execute(Lexer lexer);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.LL1Analyzer : object {
    public static int HitPred;
    [NotNullAttribute]
public ATN atn;
    public LL1Analyzer(ATN atn);
    public virtual IntervalSet[] GetDecisionLookahead(ATNState s);
    public virtual IntervalSet Look(ATNState s, PredictionContext ctx);
    public virtual IntervalSet Look(ATNState s, ATNState stopState, PredictionContext ctx);
    protected internal virtual void Look(ATNState s, ATNState stopState, PredictionContext ctx, IntervalSet look, HashSet`1<ATNConfig> lookBusy, BitSet calledRuleStack, bool seeThruPreds, bool addEOF);
}
public class Antlr4.Runtime.Atn.LookaheadEventInfo : DecisionEventInfo {
    private int predictedAlt;
    public int PredictedAlternative { get; }
    public LookaheadEventInfo(int decision, SimulatorState state, int predictedAlt, ITokenStream input, int startIndex, int stopIndex, bool fullCtx);
    public int get_PredictedAlternative();
}
public class Antlr4.Runtime.Atn.LoopEndState : ATNState {
    public ATNState loopBackState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.NotSetTransition : SetTransition {
    public TransitionType TransitionType { get; }
    public NotSetTransition(ATNState target, IntervalSet set);
    public virtual TransitionType get_TransitionType();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.OrderedATNConfigSet : ATNConfigSet {
    public OrderedATNConfigSet(ATNConfigSet set, bool readonly);
    public virtual ATNConfigSet Clone(bool readonly);
    protected internal virtual long GetKey(ATNConfig e);
    protected internal virtual bool CanMerge(ATNConfig left, long leftKey, ATNConfig right);
}
public class Antlr4.Runtime.Atn.ParseInfo : object {
    protected internal ProfilingATNSimulator atnSimulator;
    [NotNullAttribute]
public DecisionInfo[] DecisionInfo { get; }
    public ParseInfo(ProfilingATNSimulator atnSimulator);
    public virtual DecisionInfo[] get_DecisionInfo();
    public virtual IList`1<int> GetLLDecisions();
    public virtual long GetTotalTimeInPrediction();
    public virtual long GetTotalSLLLookaheadOps();
    public virtual long GetTotalLLLookaheadOps();
    public virtual long GetTotalSLLATNLookaheadOps();
    public virtual long GetTotalLLATNLookaheadOps();
    public virtual long GetTotalATNLookaheadOps();
    public virtual int GetDFASize();
    public virtual int GetDFASize(int decision);
}
public class Antlr4.Runtime.Atn.ParserATNSimulator : ATNSimulator {
    public static bool debug;
    public static bool dfa_debug;
    public static bool retry_debug;
    [NotNullAttribute]
private PredictionMode predictionMode;
    public bool force_global_context;
    public bool always_try_local_context;
    public bool enable_global_context_dfa;
    public bool optimize_unique_closure;
    public bool optimize_ll1;
    [ObsoleteAttribute("This flag is not currently used by the ATN simulator.")]
public bool optimize_hidden_conflicted_configs;
    public bool optimize_tail_calls;
    public bool tail_call_preserves_sll;
    public bool treat_sllk1_conflict_as_ambiguity;
    [NullableAttribute]
protected internal Parser parser;
    public bool reportAmbiguities;
    protected internal bool userWantsCtxSensitive;
    private DFA dfa;
    private static IComparer`1<ATNConfig> StateAltSortComparator;
    public PredictionMode PredictionMode { get; public set; }
    public Parser Parser { get; }
    public ParserATNSimulator(ATN atn);
    public ParserATNSimulator(Parser parser, ATN atn);
    private static ParserATNSimulator();
    public PredictionMode get_PredictionMode();
    public void set_PredictionMode(PredictionMode value);
    public virtual void Reset();
    public virtual int AdaptivePredict(ITokenStream input, int decision, ParserRuleContext outerContext);
    public virtual int AdaptivePredict(ITokenStream input, int decision, ParserRuleContext outerContext, bool useContext);
    protected internal virtual SimulatorState GetStartState(DFA dfa, ITokenStream input, ParserRuleContext outerContext, bool useContext);
    protected internal virtual int ExecDFA(DFA dfa, ITokenStream input, int startIndex, SimulatorState state);
    protected internal virtual bool IsAcceptState(DFAState state, bool useContext);
    protected internal virtual int ExecATN(DFA dfa, ITokenStream input, int startIndex, SimulatorState initialState);
    protected internal virtual int HandleNoViableAlt(ITokenStream input, int startIndex, SimulatorState previous);
    protected internal virtual SimulatorState ComputeReachSet(DFA dfa, SimulatorState previous, int t, PredictionContextCache contextCache);
    protected internal virtual DFAState GetExistingTargetState(DFAState s, int t);
    protected internal virtual Tuple`2<DFAState, ParserRuleContext> ComputeTargetState(DFA dfa, DFAState s, ParserRuleContext remainingGlobalContext, int t, bool useContext, PredictionContextCache contextCache);
    protected internal virtual ATNConfigSet RemoveAllConfigsNotInRuleStopState(ATNConfigSet configs, PredictionContextCache contextCache);
    protected internal virtual SimulatorState ComputeStartState(DFA dfa, ParserRuleContext globalContext, bool useContext);
    protected internal virtual ATNConfigSet ApplyPrecedenceFilter(ATNConfigSet configs, ParserRuleContext globalContext, PredictionContextCache contextCache);
    protected internal virtual ATNState GetReachableTarget(ATNConfig source, Transition trans, int ttype);
    protected internal virtual PredPrediction[] PredicateDFAState(DFAState D, ATNConfigSet configs, int nalts);
    protected internal virtual SemanticContext[] GetPredsForAmbigAlts(BitSet ambigAlts, ATNConfigSet configs, int nalts);
    protected internal virtual PredPrediction[] GetPredicatePredictions(BitSet ambigAlts, SemanticContext[] altToPred);
    protected internal virtual BitSet EvalSemanticContext(PredPrediction[] predPredictions, ParserRuleContext outerContext, bool complete);
    protected internal virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleContext parserCallStack, int alt);
    protected internal virtual void Closure(ATNConfigSet sourceConfigs, ATNConfigSet configs, bool collectPredicates, bool hasMoreContext, PredictionContextCache contextCache, bool treatEofAsEpsilon);
    protected internal virtual void Closure(ATNConfig config, ATNConfigSet configs, ATNConfigSet intermediate, HashSet`1<ATNConfig> closureBusy, bool collectPredicates, bool hasMoreContexts, PredictionContextCache contextCache, int depth, bool treatEofAsEpsilon);
    public virtual string GetRuleName(int index);
    protected internal virtual ATNConfig GetEpsilonTarget(ATNConfig config, Transition t, bool collectPredicates, bool inContext, PredictionContextCache contextCache, bool treatEofAsEpsilon);
    protected internal virtual ATNConfig ActionTransition(ATNConfig config, ActionTransition t);
    protected internal virtual ATNConfig PrecedenceTransition(ATNConfig config, PrecedencePredicateTransition pt, bool collectPredicates, bool inContext);
    protected internal virtual ATNConfig PredTransition(ATNConfig config, PredicateTransition pt, bool collectPredicates, bool inContext);
    protected internal virtual ATNConfig RuleTransition(ATNConfig config, RuleTransition t, PredictionContextCache contextCache);
    private ConflictInfo IsConflicted(ATNConfigSet configset, PredictionContextCache contextCache);
    protected internal virtual BitSet GetConflictingAltsFromConfigSet(ATNConfigSet configs);
    public virtual string GetTokenName(int t);
    public virtual string GetLookaheadName(ITokenStream input);
    public virtual void DumpDeadEndConfigs(NoViableAltException nvae);
    protected internal virtual NoViableAltException NoViableAlt(ITokenStream input, ParserRuleContext outerContext, ATNConfigSet configs, int startIndex);
    protected internal virtual int GetUniqueAlt(IEnumerable`1<ATNConfig> configs);
    protected internal virtual bool ConfigWithAltAtStopState(IEnumerable`1<ATNConfig> configs, int alt);
    protected internal virtual DFAState AddDFAEdge(DFA dfa, DFAState fromState, int t, List`1<int> contextTransitions, ATNConfigSet toConfigs, PredictionContextCache contextCache);
    protected internal virtual void AddDFAEdge(DFAState p, int t, DFAState q);
    protected internal virtual DFAState AddDFAContextState(DFA dfa, ATNConfigSet configs, int returnContext, PredictionContextCache contextCache);
    protected internal virtual DFAState AddDFAState(DFA dfa, ATNConfigSet configs, PredictionContextCache contextCache);
    protected internal virtual DFAState CreateDFAState(DFA dfa, ATNConfigSet configs);
    protected internal virtual void ReportAttemptingFullContext(DFA dfa, BitSet conflictingAlts, SimulatorState conflictState, int startIndex, int stopIndex);
    protected internal virtual void ReportContextSensitivity(DFA dfa, int prediction, SimulatorState acceptState, int startIndex, int stopIndex);
    protected internal virtual void ReportAmbiguity(DFA dfa, DFAState D, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    protected internal int GetReturnState(RuleContext context);
    protected internal ParserRuleContext SkipTailCalls(ParserRuleContext context);
    public virtual Parser get_Parser();
}
public class Antlr4.Runtime.Atn.PlusBlockStartState : BlockStartState {
    public PlusLoopbackState loopBackState;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.PlusLoopbackState : DecisionState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.PrecedencePredicateTransition : AbstractPredicateTransition {
    public int precedence;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public PrecedencePredicate Predicate { get; }
    public PrecedencePredicateTransition(ATNState target, int precedence);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public PrecedencePredicate get_Predicate();
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.PredicateEvalInfo : DecisionEventInfo {
    public SemanticContext semctx;
    public int predictedAlt;
    public bool evalResult;
    public PredicateEvalInfo(SimulatorState state, int decision, ITokenStream input, int startIndex, int stopIndex, SemanticContext semctx, bool evalResult, int predictedAlt);
}
public class Antlr4.Runtime.Atn.PredicateTransition : AbstractPredicateTransition {
    public int ruleIndex;
    public int predIndex;
    public bool isCtxDependent;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public Predicate Predicate { get; }
    public PredicateTransition(ATNState target, int ruleIndex, int predIndex, bool isCtxDependent);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public Predicate get_Predicate();
    public virtual string ToString();
}
public abstract class Antlr4.Runtime.Atn.PredictionContext : object {
    [NotNullAttribute]
public static PredictionContext EmptyLocal;
    [NotNullAttribute]
public static PredictionContext EmptyFull;
    public static int EmptyLocalStateKey;
    public static int EmptyFullStateKey;
    private static int InitialHash;
    private int cachedHashCode;
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmpty { get; }
    protected internal PredictionContext(int cachedHashCode);
    private static PredictionContext();
    protected internal static int CalculateEmptyHashCode();
    protected internal static int CalculateHashCode(PredictionContext parent, int returnState);
    protected internal static int CalculateHashCode(PredictionContext[] parents, Int32[] returnStates);
    public abstract virtual int get_Size();
    public abstract virtual int GetReturnState(int index);
    public abstract virtual int FindReturnState(int returnState);
    public abstract virtual PredictionContext GetParent(int index);
    protected internal abstract virtual PredictionContext AddEmptyContext();
    protected internal abstract virtual PredictionContext RemoveEmptyContext();
    public static PredictionContext FromRuleContext(ATN atn, RuleContext outerContext);
    public static PredictionContext FromRuleContext(ATN atn, RuleContext outerContext, bool fullContext);
    private static PredictionContext AddEmptyContext(PredictionContext context);
    private static PredictionContext RemoveEmptyContext(PredictionContext context);
    public static PredictionContext Join(PredictionContext context0, PredictionContext context1);
    internal static PredictionContext Join(PredictionContext context0, PredictionContext context1, PredictionContextCache contextCache);
    public static bool IsEmptyLocal(PredictionContext context);
    public static PredictionContext GetCachedContext(PredictionContext context, ConcurrentDictionary`2<PredictionContext, PredictionContext> contextCache, IdentityHashMap visited);
    public virtual PredictionContext AppendContext(int returnContext, PredictionContextCache contextCache);
    public abstract virtual PredictionContext AppendContext(PredictionContext suffix, PredictionContextCache contextCache);
    public virtual PredictionContext GetChild(int returnState);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_HasEmpty();
    public sealed virtual int GetHashCode();
    public abstract virtual bool Equals(object o);
    public virtual String[] ToStrings(IRecognizer recognizer, int currentState);
    public virtual String[] ToStrings(IRecognizer recognizer, PredictionContext stop, int currentState);
}
public class Antlr4.Runtime.Atn.PredictionContextCache : object {
    public static PredictionContextCache Uncached;
    private IDictionary`2<PredictionContext, PredictionContext> contexts;
    private IDictionary`2<PredictionContextAndInt, PredictionContext> childContexts;
    private IDictionary`2<IdentityCommutativePredictionContextOperands, PredictionContext> joinContexts;
    private bool enableCache;
    private PredictionContextCache(bool enableCache);
    private static PredictionContextCache();
    public virtual PredictionContext GetAsCached(PredictionContext context);
    public virtual PredictionContext GetChild(PredictionContext context, int invokingState);
    public virtual PredictionContext Join(PredictionContext x, PredictionContext y);
}
public class Antlr4.Runtime.Atn.PredictionMode : object {
    public static PredictionMode Sll;
    public static PredictionMode Ll;
    public static PredictionMode LlExactAmbigDetection;
    private static PredictionMode();
    public static bool HasSLLConflictTerminatingPrediction(PredictionMode mode, ATNConfigSet configs);
    public static bool HasConfigInRuleStopState(IEnumerable`1<ATNConfig> configs);
    public static bool AllConfigsInRuleStopStates(IEnumerable`1<ATNConfig> configs);
    public static int ResolvesToJustOneViableAlt(IEnumerable`1<BitSet> altsets);
    public static bool AllSubsetsConflict(IEnumerable`1<BitSet> altsets);
    public static bool HasNonConflictingAltSet(IEnumerable`1<BitSet> altsets);
    public static bool HasConflictingAltSet(IEnumerable`1<BitSet> altsets);
    public static bool AllSubsetsEqual(IEnumerable`1<BitSet> altsets);
    public static int GetUniqueAlt(IEnumerable`1<BitSet> altsets);
    public static BitSet GetAlts(IEnumerable`1<BitSet> altsets);
    public static BitSet GetAlts(ATNConfigSet configs);
    public static ICollection`1<BitSet> GetConflictingAltSubsets(IEnumerable`1<ATNConfig> configs);
    public static IDictionary`2<ATNState, BitSet> GetStateToAltMap(IEnumerable`1<ATNConfig> configs);
    public static bool HasStateAssociatedWithOneAlt(IEnumerable`1<ATNConfig> configs);
    public static int GetSingleViableAlt(IEnumerable`1<BitSet> altsets);
}
public class Antlr4.Runtime.Atn.ProfilingATNSimulator : ParserATNSimulator {
    protected internal DecisionInfo[] decisions;
    protected internal int numDecisions;
    protected internal ITokenStream _input;
    protected internal int _startIndex;
    protected internal int _sllStopIndex;
    protected internal int _llStopIndex;
    protected internal int currentDecision;
    protected internal SimulatorState currentState;
    protected internal int conflictingAltResolvedBySLL;
    public DecisionInfo[] DecisionInfo { get; }
    public SimulatorState CurrentState { get; }
    public ProfilingATNSimulator(Parser parser);
    public virtual int AdaptivePredict(ITokenStream input, int decision, ParserRuleContext outerContext);
    protected internal virtual SimulatorState GetStartState(DFA dfa, ITokenStream input, ParserRuleContext outerContext, bool useContext);
    protected internal virtual SimulatorState ComputeStartState(DFA dfa, ParserRuleContext globalContext, bool useContext);
    protected internal virtual SimulatorState ComputeReachSet(DFA dfa, SimulatorState previous, int t, PredictionContextCache contextCache);
    protected internal virtual DFAState GetExistingTargetState(DFAState previousD, int t);
    protected internal virtual Tuple`2<DFAState, ParserRuleContext> ComputeTargetState(DFA dfa, DFAState s, ParserRuleContext remainingGlobalContext, int t, bool useContext, PredictionContextCache contextCache);
    protected internal virtual bool EvalSemanticContext(SemanticContext pred, ParserRuleContext parserCallStack, int alt);
    protected internal virtual void ReportContextSensitivity(DFA dfa, int prediction, SimulatorState acceptState, int startIndex, int stopIndex);
    protected internal virtual void ReportAttemptingFullContext(DFA dfa, BitSet conflictingAlts, SimulatorState conflictState, int startIndex, int stopIndex);
    protected internal virtual void ReportAmbiguity(DFA dfa, DFAState D, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual DecisionInfo[] get_DecisionInfo();
    public virtual SimulatorState get_CurrentState();
}
public class Antlr4.Runtime.Atn.RangeTransition : Transition {
    public int from;
    public int to;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public RangeTransition(ATNState target, int from, int to);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.RuleStartState : ATNState {
    public RuleStopState stopState;
    public bool isPrecedenceRule;
    public bool leftFactored;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.RuleStopState : ATNState {
    public int NonStopStateNumber { get; }
    public StateType StateType { get; }
    public virtual int get_NonStopStateNumber();
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.RuleTransition : Transition {
    public int ruleIndex;
    public int precedence;
    [NotNullAttribute]
public ATNState followState;
    public bool tailCall;
    public bool optimizedTailCall;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    [ObsoleteAttribute("UseRuleTransition(RuleStartState, int, int, ATNState) instead.")]
public RuleTransition(RuleStartState ruleStart, int ruleIndex, ATNState followState);
    public RuleTransition(RuleStartState ruleStart, int ruleIndex, int precedence, ATNState followState);
    public virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
}
public abstract class Antlr4.Runtime.Atn.SemanticContext : object {
    public static SemanticContext None;
    private static SemanticContext();
    public abstract virtual bool Eval(Recognizer`2<Symbol, ATNInterpreter> parser, RuleContext parserCallStack);
    public virtual SemanticContext EvalPrecedence(Recognizer`2<Symbol, ATNInterpreter> parser, RuleContext parserCallStack);
    public static SemanticContext And(SemanticContext a, SemanticContext b);
    public static SemanticContext Or(SemanticContext a, SemanticContext b);
    private static IList`1<PrecedencePredicate> FilterPrecedencePredicates(HashSet`1<SemanticContext> collection);
}
public class Antlr4.Runtime.Atn.SetTransition : Transition {
    [NotNullAttribute]
public IntervalSet set;
    public TransitionType TransitionType { get; }
    public IntervalSet Label { get; }
    public SetTransition(ATNState target, IntervalSet set);
    public virtual TransitionType get_TransitionType();
    public virtual IntervalSet get_Label();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.Atn.SimulatorState : object {
    public ParserRuleContext outerContext;
    public DFAState s0;
    public bool useContext;
    public ParserRuleContext remainingOuterContext;
    public SimulatorState(ParserRuleContext outerContext, DFAState s0, bool useContext, ParserRuleContext remainingOuterContext);
}
public class Antlr4.Runtime.Atn.SingletonPredictionContext : PredictionContext {
    [NotNullAttribute]
public PredictionContext parent;
    public int returnState;
    public int Size { get; }
    public bool IsEmpty { get; }
    public bool HasEmpty { get; }
    internal SingletonPredictionContext(PredictionContext parent, int returnState);
    public virtual PredictionContext GetParent(int index);
    public virtual int GetReturnState(int index);
    public virtual int FindReturnState(int returnState);
    public virtual int get_Size();
    public virtual bool get_IsEmpty();
    public virtual bool get_HasEmpty();
    public virtual PredictionContext AppendContext(PredictionContext suffix, PredictionContextCache contextCache);
    protected internal virtual PredictionContext AddEmptyContext();
    protected internal virtual PredictionContext RemoveEmptyContext();
    public virtual bool Equals(object o);
}
public class Antlr4.Runtime.Atn.StarBlockStartState : BlockStartState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.StarLoopbackState : ATNState {
    public StarLoopEntryState LoopEntryState { get; }
    public StateType StateType { get; }
    public StarLoopEntryState get_LoopEntryState();
    public virtual StateType get_StateType();
}
public class Antlr4.Runtime.Atn.StarLoopEntryState : DecisionState {
    public StarLoopbackState loopBackState;
    public bool precedenceRuleDecision;
    public BitSet precedenceLoopbackStates;
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public enum Antlr4.Runtime.Atn.StateType : Enum {
    public int value__;
    public static StateType InvalidType;
    public static StateType Basic;
    public static StateType RuleStart;
    public static StateType BlockStart;
    public static StateType PlusBlockStart;
    public static StateType StarBlockStart;
    public static StateType TokenStart;
    public static StateType RuleStop;
    public static StateType BlockEnd;
    public static StateType StarLoopBack;
    public static StateType StarLoopEntry;
    public static StateType PlusLoopBack;
    public static StateType LoopEnd;
}
public class Antlr4.Runtime.Atn.TokensStartState : DecisionState {
    public StateType StateType { get; }
    public virtual StateType get_StateType();
}
public abstract class Antlr4.Runtime.Atn.Transition : object {
    public static ReadOnlyCollection`1<string> serializationNames;
    [NotNullAttribute]
public ATNState target;
    public TransitionType TransitionType { get; }
    public bool IsEpsilon { get; }
    public IntervalSet Label { get; }
    protected internal Transition(ATNState target);
    private static Transition();
    public abstract virtual TransitionType get_TransitionType();
    public virtual bool get_IsEpsilon();
    public virtual IntervalSet get_Label();
    public abstract virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
}
public enum Antlr4.Runtime.Atn.TransitionType : Enum {
    public int value__;
    public static TransitionType Invalid;
    public static TransitionType Epsilon;
    public static TransitionType Range;
    public static TransitionType Rule;
    public static TransitionType Predicate;
    public static TransitionType Atom;
    public static TransitionType Action;
    public static TransitionType Set;
    public static TransitionType NotSet;
    public static TransitionType Wildcard;
    public static TransitionType Precedence;
}
public class Antlr4.Runtime.Atn.WildcardTransition : Transition {
    public TransitionType TransitionType { get; }
    public WildcardTransition(ATNState target);
    public virtual TransitionType get_TransitionType();
    public virtual bool Matches(int symbol, int minVocabSymbol, int maxVocabSymbol);
    public virtual string ToString();
}
public class Antlr4.Runtime.BailErrorStrategy : DefaultErrorStrategy {
    public virtual void Recover(Parser recognizer, RecognitionException e);
    public virtual IToken RecoverInline(Parser recognizer);
    public virtual void Sync(Parser recognizer);
}
public class Antlr4.Runtime.BaseErrorListener : object {
    public virtual void SyntaxError(IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, SimulatorState conflictState);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, SimulatorState acceptState);
}
public class Antlr4.Runtime.BufferedTokenStream : object {
    [NotNullAttribute]
protected internal ITokenSource tokenSource;
    protected internal IList`1<IToken> tokens;
    protected internal int p;
    protected internal bool fetchedEOF;
    public ITokenSource TokenSource { get; }
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public BufferedTokenStream(ITokenSource tokenSource);
    public virtual ITokenSource get_TokenSource();
    public virtual int get_Index();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Reset();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual void Consume();
    protected internal virtual bool Sync(int i);
    protected internal virtual int Fetch(int n);
    public virtual IToken Get(int i);
    public virtual IList`1<IToken> Get(int start, int stop);
    public virtual int La(int i);
    protected internal virtual IToken Lb(int k);
    public virtual IToken Lt(int k);
    protected internal virtual int AdjustSeekIndex(int i);
    protected internal void LazyInit();
    protected internal virtual void Setup();
    public virtual void SetTokenSource(ITokenSource tokenSource);
    public virtual IList`1<IToken> GetTokens();
    public virtual IList`1<IToken> GetTokens(int start, int stop);
    public virtual IList`1<IToken> GetTokens(int start, int stop, BitSet types);
    public virtual IList`1<IToken> GetTokens(int start, int stop, int ttype);
    protected internal virtual int NextTokenOnChannel(int i, int channel);
    protected internal virtual int PreviousTokenOnChannel(int i, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToRight(int tokenIndex, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToRight(int tokenIndex);
    public virtual IList`1<IToken> GetHiddenTokensToLeft(int tokenIndex, int channel);
    public virtual IList`1<IToken> GetHiddenTokensToLeft(int tokenIndex);
    protected internal virtual IList`1<IToken> FilterForChannel(int from, int to, int channel);
    public virtual string get_SourceName();
    public virtual string GetText();
    public virtual string GetText(Interval interval);
    public virtual string GetText(RuleContext ctx);
    public virtual string GetText(IToken start, IToken stop);
    public virtual void Fill();
}
public class Antlr4.Runtime.CommonToken : object {
    private static long serialVersionUID;
    protected internal static Tuple`2<ITokenSource, ICharStream> EmptySource;
    protected internal int type;
    protected internal int line;
    protected internal int charPositionInLine;
    protected internal int channel;
    [NotNullAttribute]
protected internal Tuple`2<ITokenSource, ICharStream> source;
    protected internal string text;
    protected internal int index;
    protected internal int start;
    protected internal int stop;
    public int Type { get; public set; }
    public int Line { get; public set; }
    public string Text { get; public set; }
    public int Column { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public CommonToken(int type);
    public CommonToken(Tuple`2<ITokenSource, ICharStream> source, int type, int channel, int start, int stop);
    public CommonToken(int type, string text);
    public CommonToken(IToken oldToken);
    private static CommonToken();
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual int get_Column();
    public virtual void set_Column(int value);
    public virtual int get_Channel();
    public virtual void set_Channel(int value);
    public virtual int get_StartIndex();
    public virtual void set_StartIndex(int value);
    public virtual int get_StopIndex();
    public virtual void set_StopIndex(int value);
    public virtual int get_TokenIndex();
    public virtual void set_TokenIndex(int value);
    public virtual ITokenSource get_TokenSource();
    public virtual ICharStream get_InputStream();
    public virtual string ToString();
    public virtual string ToString(IRecognizer r);
}
public class Antlr4.Runtime.CommonTokenFactory : object {
    public static ITokenFactory Default;
    protected internal bool copyText;
    public CommonTokenFactory(bool copyText);
    private static CommonTokenFactory();
    public virtual CommonToken Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    private sealed virtual override IToken Antlr4.Runtime.ITokenFactory.Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    public virtual CommonToken Create(int type, string text);
    private sealed virtual override IToken Antlr4.Runtime.ITokenFactory.Create(int type, string text);
}
public class Antlr4.Runtime.CommonTokenStream : BufferedTokenStream {
    protected internal int channel;
    public CommonTokenStream(ITokenSource tokenSource);
    public CommonTokenStream(ITokenSource tokenSource, int channel);
    protected internal virtual int AdjustSeekIndex(int i);
    protected internal virtual IToken Lb(int k);
    public virtual IToken Lt(int k);
    public virtual int GetNumberOfOnChannelTokens();
}
public class Antlr4.Runtime.ConsoleErrorListener`1 : object {
    public static ConsoleErrorListener`1<Symbol> Instance;
    private static ConsoleErrorListener`1();
    public virtual void SyntaxError(IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.DefaultErrorStrategy : object {
    protected internal bool errorRecoveryMode;
    protected internal int lastErrorIndex;
    protected internal IntervalSet lastErrorStates;
    public virtual void Reset(Parser recognizer);
    protected internal virtual void BeginErrorCondition(Parser recognizer);
    public virtual bool InErrorRecoveryMode(Parser recognizer);
    protected internal virtual void EndErrorCondition(Parser recognizer);
    public virtual void ReportMatch(Parser recognizer);
    public virtual void ReportError(Parser recognizer, RecognitionException e);
    protected internal virtual void NotifyErrorListeners(Parser recognizer, string message, RecognitionException e);
    public virtual void Recover(Parser recognizer, RecognitionException e);
    public virtual void Sync(Parser recognizer);
    protected internal virtual void ReportNoViableAlternative(Parser recognizer, NoViableAltException e);
    protected internal virtual void ReportInputMismatch(Parser recognizer, InputMismatchException e);
    protected internal virtual void ReportFailedPredicate(Parser recognizer, FailedPredicateException e);
    protected internal virtual void ReportUnwantedToken(Parser recognizer);
    protected internal virtual void ReportMissingToken(Parser recognizer);
    public virtual IToken RecoverInline(Parser recognizer);
    protected internal virtual bool SingleTokenInsertion(Parser recognizer);
    protected internal virtual IToken SingleTokenDeletion(Parser recognizer);
    protected internal virtual IToken GetMissingSymbol(Parser recognizer);
    protected internal virtual IToken ConstructToken(ITokenSource tokenSource, int expectedTokenType, string tokenText, IToken current);
    protected internal virtual IntervalSet GetExpectedTokens(Parser recognizer);
    protected internal virtual string GetTokenErrorDisplay(IToken t);
    protected internal virtual string GetSymbolText(IToken symbol);
    protected internal virtual int GetSymbolType(IToken symbol);
    protected internal virtual string EscapeWSAndQuote(string s);
    protected internal virtual IntervalSet GetErrorRecoverySet(Parser recognizer);
    protected internal virtual void ConsumeUntil(Parser recognizer, IntervalSet set);
}
[FlagsAttribute]
public enum Antlr4.Runtime.Dependents : Enum {
    public int value__;
    public static Dependents None;
    public static Dependents Self;
    public static Dependents Parents;
    public static Dependents Children;
    public static Dependents Ancestors;
    public static Dependents Descendants;
    public static Dependents Siblings;
    public static Dependents PreceedingSiblings;
    public static Dependents FollowingSiblings;
    public static Dependents Preceeding;
    public static Dependents Following;
}
[DefaultMemberAttribute("Item")]
public abstract class Antlr4.Runtime.Dfa.AbstractEdgeMap`1 : object {
    protected internal int minIndex;
    protected internal int maxIndex;
    public T Item { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    protected AbstractEdgeMap`1(int minIndex, int maxIndex);
    public abstract virtual AbstractEdgeMap`1<T> Put(int key, T value);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.PutAll(IEdgeMap`1<T> m);
    public abstract virtual AbstractEdgeMap`1<T> Clear();
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Clear();
    public abstract virtual AbstractEdgeMap`1<T> Remove(int key);
    private sealed virtual override IEdgeMap`1<T> Antlr4.Runtime.Dfa.IEdgeMap<T>.Remove(int key);
    public abstract virtual bool ContainsKey(int arg1);
    public abstract virtual T get_Item(int arg1);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual ReadOnlyDictionary`2<int, T> ToMap();
    public virtual IEnumerator`1<KeyValuePair`2<int, T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Antlr4.Runtime.Dfa.AcceptStateInfo : object {
    private int prediction;
    private LexerActionExecutor lexerActionExecutor;
    public int Prediction { get; }
    public LexerActionExecutor LexerActionExecutor { get; }
    public AcceptStateInfo(int prediction);
    public AcceptStateInfo(int prediction, LexerActionExecutor lexerActionExecutor);
    public virtual int get_Prediction();
    public virtual LexerActionExecutor get_LexerActionExecutor();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.ArrayEdgeMap`1 : AbstractEdgeMap`1<T> {
    private T[] arrayData;
    private int size;
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public ArrayEdgeMap`1(int minIndex, int maxIndex);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual ReadOnlyDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.Dfa.DFA : object {
    [NotNullAttribute]
public ConcurrentDictionary`2<DFAState, DFAState> states;
    [NotNullAttribute]
public AtomicReference`1<DFAState> s0;
    [NotNullAttribute]
public AtomicReference`1<DFAState> s0full;
    public int decision;
    [NotNullAttribute]
public ATNState atnStartState;
    private int nextStateNumber;
    private int minDfaEdge;
    private int maxDfaEdge;
    [NotNullAttribute]
private static EmptyEdgeMap`1<DFAState> emptyPrecedenceEdges;
    [NotNullAttribute]
private EmptyEdgeMap`1<DFAState> emptyEdgeMap;
    [NotNullAttribute]
private EmptyEdgeMap`1<DFAState> emptyContextEdgeMap;
    private bool precedenceDfa;
    public int MinDfaEdge { get; }
    public int MaxDfaEdge { get; }
    public EmptyEdgeMap`1<DFAState> EmptyEdgeMap { get; }
    public EmptyEdgeMap`1<DFAState> EmptyContextEdgeMap { get; }
    public bool IsPrecedenceDfa { get; public set; }
    public bool IsEmpty { get; }
    public bool IsContextSensitive { get; }
    public DFA(ATNState atnStartState);
    public DFA(ATNState atnStartState, int decision);
    private static DFA();
    public int get_MinDfaEdge();
    public int get_MaxDfaEdge();
    public virtual EmptyEdgeMap`1<DFAState> get_EmptyEdgeMap();
    public virtual EmptyEdgeMap`1<DFAState> get_EmptyContextEdgeMap();
    public bool get_IsPrecedenceDfa();
    public void set_IsPrecedenceDfa(bool value);
    public DFAState GetPrecedenceStartState(int precedence, bool fullContext);
    public void SetPrecedenceStartState(int precedence, bool fullContext, DFAState startState);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsContextSensitive();
    public virtual DFAState AddState(DFAState state);
    public virtual string ToString();
    [ObsoleteAttribute("Use ToString(Antlr4.Runtime.IVocabulary) instead.")]
public virtual string ToString(String[] tokenNames);
    public virtual string ToString(IVocabulary vocabulary);
    [ObsoleteAttribute("Use ToString(Antlr4.Runtime.IVocabulary, string[]) instead.")]
public virtual string ToString(String[] tokenNames, String[] ruleNames);
    public virtual string ToString(IVocabulary vocabulary, String[] ruleNames);
    public virtual string ToLexerString();
}
public class Antlr4.Runtime.Dfa.DFASerializer : object {
    [NotNullAttribute]
private DFA dfa;
    [NotNullAttribute]
private IVocabulary vocabulary;
    [NullableAttribute]
internal String[] ruleNames;
    [NullableAttribute]
internal ATN atn;
    [ObsoleteAttribute("Use DFASerializer(DFA, Antlr4.Runtime.IVocabulary) instead.")]
public DFASerializer(DFA dfa, String[] tokenNames);
    public DFASerializer(DFA dfa, IVocabulary vocabulary);
    public DFASerializer(DFA dfa, IRecognizer parser);
    [ObsoleteAttribute("Use DFASerializer(DFA, Antlr4.Runtime.IVocabulary, string[], Antlr4.Runtime.Atn.ATN) instead.")]
public DFASerializer(DFA dfa, String[] tokenNames, String[] ruleNames, ATN atn);
    public DFASerializer(DFA dfa, IVocabulary vocabulary, String[] ruleNames, ATN atn);
    public virtual string ToString();
    protected internal virtual string GetContextLabel(int i);
    protected internal virtual string GetEdgeLabel(int i);
    internal virtual string GetStateString(DFAState s);
}
public class Antlr4.Runtime.Dfa.DFAState : object {
    public int stateNumber;
    [NotNullAttribute]
public ATNConfigSet configs;
    [NotNullAttribute]
private AbstractEdgeMap`1 modreq(System.Runtime.CompilerServices.IsVolatile) edges;
    private AcceptStateInfo acceptStateInfo;
    [NotNullAttribute]
private AbstractEdgeMap`1 modreq(System.Runtime.CompilerServices.IsVolatile) contextEdges;
    [NullableAttribute]
private BitSet contextSymbols;
    [NullableAttribute]
public PredPrediction[] predicates;
    public bool IsContextSensitive { get; }
    public AcceptStateInfo AcceptStateInfo { get; public set; }
    public bool IsAcceptState { get; }
    public int Prediction { get; }
    public LexerActionExecutor LexerActionExecutor { get; }
    public ReadOnlyDictionary`2<int, DFAState> EdgeMap { get; }
    public ReadOnlyDictionary`2<int, DFAState> ContextEdgeMap { get; }
    public DFAState(DFA dfa, ATNConfigSet configs);
    public DFAState(EmptyEdgeMap`1<DFAState> emptyEdges, EmptyEdgeMap`1<DFAState> emptyContextEdges, ATNConfigSet configs);
    public bool get_IsContextSensitive();
    public bool IsContextSymbol(int symbol);
    public void SetContextSymbol(int symbol);
    public virtual void SetContextSensitive(ATN atn);
    public AcceptStateInfo get_AcceptStateInfo();
    public void set_AcceptStateInfo(AcceptStateInfo value);
    public bool get_IsAcceptState();
    public int get_Prediction();
    public LexerActionExecutor get_LexerActionExecutor();
    public virtual DFAState GetTarget(int symbol);
    public virtual void SetTarget(int symbol, DFAState target);
    public virtual ReadOnlyDictionary`2<int, DFAState> get_EdgeMap();
    public virtual DFAState GetContextTarget(int invokingState);
    public virtual void SetContextTarget(int invokingState, DFAState target);
    public virtual ReadOnlyDictionary`2<int, DFAState> get_ContextEdgeMap();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.EmptyEdgeMap`1 : AbstractEdgeMap`1<T> {
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public EmptyEdgeMap`1(int minIndex, int maxIndex);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual ReadOnlyDictionary`2<int, T> ToMap();
}
[DefaultMemberAttribute("Item")]
public interface Antlr4.Runtime.Dfa.IEdgeMap`1 {
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool ContainsKey(int key);
    public abstract virtual T get_Item(int key);
    public abstract virtual IEdgeMap`1<T> Put(int key, T value);
    public abstract virtual IEdgeMap`1<T> Remove(int key);
    public abstract virtual IEdgeMap`1<T> PutAll(IEdgeMap`1<T> m);
    public abstract virtual IEdgeMap`1<T> Clear();
    public abstract virtual ReadOnlyDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.Dfa.LexerDFASerializer : DFASerializer {
    public LexerDFASerializer(DFA dfa);
    protected internal virtual string GetEdgeLabel(int i);
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.SingletonEdgeMap`1 : AbstractEdgeMap`1<T> {
    private int key;
    private T value;
    public int Key { get; }
    public T Value { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public SingletonEdgeMap`1(int minIndex, int maxIndex, int key, T value);
    public int get_Key();
    public T get_Value();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual ReadOnlyDictionary`2<int, T> ToMap();
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Dfa.SparseEdgeMap`1 : AbstractEdgeMap`1<T> {
    private static int DefaultMaxSize;
    private Int32[] keys;
    private List`1<T> values;
    public Int32[] Keys { get; }
    public IList`1<T> Values { get; }
    public int MaxSparseSize { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public SparseEdgeMap`1(int minIndex, int maxIndex);
    public SparseEdgeMap`1(int minIndex, int maxIndex, int maxSparseSize);
    private SparseEdgeMap`1(SparseEdgeMap`1<T> map, int maxSparseSize);
    public Int32[] get_Keys();
    public IList`1<T> get_Values();
    public int get_MaxSparseSize();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool ContainsKey(int key);
    public virtual T get_Item(int key);
    public virtual AbstractEdgeMap`1<T> Put(int key, T value);
    public virtual AbstractEdgeMap`1<T> Remove(int key);
    public virtual AbstractEdgeMap`1<T> Clear();
    public virtual ReadOnlyDictionary`2<int, T> ToMap();
}
public class Antlr4.Runtime.DiagnosticErrorListener : BaseErrorListener {
    protected internal bool exactOnly;
    public DiagnosticErrorListener(bool exactOnly);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, SimulatorState conflictState);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, SimulatorState acceptState);
    protected internal virtual string GetDecisionDescription(Parser recognizer, DFA dfa);
    protected internal virtual BitSet GetConflictingAlts(BitSet reportedAlts, ATNConfigSet configs);
}
public class Antlr4.Runtime.FailedPredicateException : RecognitionException {
    private static long serialVersionUID;
    private int ruleIndex;
    private int predicateIndex;
    private string predicate;
    public int RuleIndex { get; }
    public int PredIndex { get; }
    [NullableAttribute]
public string Predicate { get; }
    public FailedPredicateException(Parser recognizer);
    public FailedPredicateException(Parser recognizer, string predicate);
    public FailedPredicateException(Parser recognizer, string predicate, string message);
    public virtual int get_RuleIndex();
    public virtual int get_PredIndex();
    public virtual string get_Predicate();
    private static string FormatMessage(string predicate, string message);
}
public interface Antlr4.Runtime.IAntlrErrorListener`1 {
    public abstract virtual void SyntaxError(IRecognizer recognizer, TSymbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public interface Antlr4.Runtime.IAntlrErrorStrategy {
    public abstract virtual void Reset(Parser recognizer);
    public abstract virtual IToken RecoverInline(Parser recognizer);
    public abstract virtual void Recover(Parser recognizer, RecognitionException e);
    public abstract virtual void Sync(Parser recognizer);
    public abstract virtual bool InErrorRecoveryMode(Parser recognizer);
    public abstract virtual void ReportMatch(Parser recognizer);
    public abstract virtual void ReportError(Parser recognizer, RecognitionException e);
}
public interface Antlr4.Runtime.ICharStream {
    public abstract virtual string GetText(Interval interval);
}
public interface Antlr4.Runtime.IIntStream {
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public abstract virtual void Consume();
    public abstract virtual int La(int i);
    public abstract virtual int Mark();
    public abstract virtual void Release(int marker);
    public abstract virtual int get_Index();
    public abstract virtual void Seek(int index);
    public abstract virtual int get_Size();
    public abstract virtual string get_SourceName();
}
public class Antlr4.Runtime.InputMismatchException : RecognitionException {
    private static long serialVersionUID;
    public InputMismatchException(Parser recognizer);
}
public class Antlr4.Runtime.InterpreterRuleContext : ParserRuleContext {
    private int ruleIndex;
    public int RuleIndex { get; }
    public InterpreterRuleContext(ParserRuleContext parent, int invokingStateNumber, int ruleIndex);
    private InterpreterRuleContext(int ruleIndex);
    public virtual int get_RuleIndex();
}
public static class Antlr4.Runtime.IntStreamConstants : object {
    public static int Eof;
    public static string UnknownSourceName;
}
public interface Antlr4.Runtime.IParserErrorListener {
    public abstract virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public abstract virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, SimulatorState conflictState);
    public abstract virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, SimulatorState acceptState);
}
public interface Antlr4.Runtime.IRecognizer {
    [ObsoleteAttribute("Use IRecognizer.Vocabulary instead.")]
public String[] TokenNames { get; }
    public IVocabulary Vocabulary { get; }
    public String[] RuleNames { get; }
    public string GrammarFileName { get; }
    public ATN Atn { get; }
    public int State { get; }
    public IIntStream InputStream { get; }
    public abstract virtual String[] get_TokenNames();
    public abstract virtual IVocabulary get_Vocabulary();
    public abstract virtual String[] get_RuleNames();
    public abstract virtual string get_GrammarFileName();
    public abstract virtual ATN get_Atn();
    public abstract virtual int get_State();
    public abstract virtual IIntStream get_InputStream();
}
public interface Antlr4.Runtime.IToken {
    public string Text { get; }
    public int Type { get; }
    public int Line { get; }
    public int Column { get; }
    public int Channel { get; }
    public int TokenIndex { get; }
    public int StartIndex { get; }
    public int StopIndex { get; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public abstract virtual string get_Text();
    public abstract virtual int get_Type();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual int get_Channel();
    public abstract virtual int get_TokenIndex();
    public abstract virtual int get_StartIndex();
    public abstract virtual int get_StopIndex();
    public abstract virtual ITokenSource get_TokenSource();
    public abstract virtual ICharStream get_InputStream();
}
public interface Antlr4.Runtime.ITokenFactory {
    public abstract virtual IToken Create(Tuple`2<ITokenSource, ICharStream> source, int type, string text, int channel, int start, int stop, int line, int charPositionInLine);
    public abstract virtual IToken Create(int type, string text);
}
public interface Antlr4.Runtime.ITokenSource {
    public int Line { get; }
    public int Column { get; }
    public ICharStream InputStream { get; }
    public string SourceName { get; }
    public ITokenFactory TokenFactory { get; public set; }
    public abstract virtual IToken NextToken();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual ICharStream get_InputStream();
    public abstract virtual string get_SourceName();
    public abstract virtual ITokenFactory get_TokenFactory();
    public abstract virtual void set_TokenFactory(ITokenFactory value);
}
public interface Antlr4.Runtime.ITokenStream {
    public ITokenSource TokenSource { get; }
    public abstract virtual IToken Lt(int k);
    public abstract virtual IToken Get(int i);
    public abstract virtual ITokenSource get_TokenSource();
    public abstract virtual string GetText(Interval interval);
    public abstract virtual string GetText();
    public abstract virtual string GetText(RuleContext ctx);
    public abstract virtual string GetText(IToken start, IToken stop);
}
public interface Antlr4.Runtime.IVocabulary {
    public int MaxTokenType { get; }
    public abstract virtual int get_MaxTokenType();
    public abstract virtual string GetLiteralName(int tokenType);
    public abstract virtual string GetSymbolicName(int tokenType);
    public abstract virtual string GetDisplayName(int tokenType);
}
public interface Antlr4.Runtime.IWritableToken {
    unknown string Text {public set; }
    unknown int Type {public set; }
    unknown int Line {public set; }
    unknown int Column {public set; }
    unknown int Channel {public set; }
    unknown int TokenIndex {public set; }
    public abstract virtual void set_Text(string value);
    public abstract virtual void set_Type(int value);
    public abstract virtual void set_Line(int value);
    public abstract virtual void set_Column(int value);
    public abstract virtual void set_Channel(int value);
    public abstract virtual void set_TokenIndex(int value);
}
public abstract class Antlr4.Runtime.Lexer : Recognizer`2<int, LexerATNSimulator> {
    public static int DefaultMode;
    public static int DefaultTokenChannel;
    public static int Hidden;
    public static int MinCharValue;
    public static int MaxCharValue;
    public ICharStream _input;
    protected internal Tuple`2<ITokenSource, ICharStream> _tokenFactorySourcePair;
    protected internal ITokenFactory _factory;
    public IToken _token;
    public int _tokenStartCharIndex;
    public int _tokenStartLine;
    public int _tokenStartCharPositionInLine;
    public bool _hitEOF;
    public int _channel;
    public int _type;
    public List`1<int> _modeStack;
    public int _mode;
    public string _text;
    public ITokenFactory TokenFactory { get; public set; }
    public string SourceName { get; }
    public IIntStream InputStream { get; }
    private ICharStream Antlr4.Runtime.ITokenSource.InputStream { get; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int CharIndex { get; }
    public string Text { get; public set; }
    public IToken Token { get; public set; }
    public int Type { get; public set; }
    public int Channel { get; public set; }
    public String[] ModeNames { get; }
    [ObsoleteAttribute("Use IRecognizer.Vocabulary instead.")]
public String[] TokenNames { get; }
    public Lexer(ICharStream input);
    public virtual void Reset();
    public virtual IToken NextToken();
    public virtual void Skip();
    public virtual void More();
    public virtual void Mode(int m);
    public virtual void PushMode(int m);
    public virtual int PopMode();
    public virtual ITokenFactory get_TokenFactory();
    public virtual void set_TokenFactory(ITokenFactory value);
    public virtual void SetInputStream(ICharStream input);
    public virtual string get_SourceName();
    public virtual IIntStream get_InputStream();
    private sealed virtual override ICharStream Antlr4.Runtime.ITokenSource.get_InputStream();
    public virtual void Emit(IToken token);
    public virtual IToken Emit();
    public virtual IToken EmitEOF();
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual int get_Column();
    public virtual void set_Column(int value);
    public virtual int get_CharIndex();
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual IToken get_Token();
    public virtual void set_Token(IToken value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual int get_Channel();
    public virtual void set_Channel(int value);
    public virtual String[] get_ModeNames();
    public virtual String[] get_TokenNames();
    public virtual IList`1<IToken> GetAllTokens();
    public virtual void Recover(LexerNoViableAltException e);
    public virtual void NotifyListeners(LexerNoViableAltException e);
    public virtual string GetErrorDisplay(string s);
    public virtual string GetErrorDisplay(int c);
    public virtual string GetCharErrorDisplay(int c);
    public virtual void Recover(RecognitionException re);
}
public class Antlr4.Runtime.LexerInterpreter : Lexer {
    protected internal string grammarFileName;
    protected internal ATN atn;
    [ObsoleteAttribute]
protected internal String[] tokenNames;
    protected internal String[] ruleNames;
    protected internal String[] modeNames;
    [NotNullAttribute]
private IVocabulary vocabulary;
    public ATN Atn { get; }
    public string GrammarFileName { get; }
    [ObsoleteAttribute("Use IRecognizer.Vocabulary instead.")]
public String[] TokenNames { get; }
    public String[] RuleNames { get; }
    public String[] ModeNames { get; }
    public IVocabulary Vocabulary { get; }
    [ObsoleteAttribute]
public LexerInterpreter(string grammarFileName, IEnumerable`1<string> tokenNames, IEnumerable`1<string> ruleNames, IEnumerable`1<string> modeNames, ATN atn, ICharStream input);
    public LexerInterpreter(string grammarFileName, IVocabulary vocabulary, IEnumerable`1<string> ruleNames, IEnumerable`1<string> modeNames, ATN atn, ICharStream input);
    public virtual ATN get_Atn();
    public virtual string get_GrammarFileName();
    public virtual String[] get_TokenNames();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ModeNames();
    public virtual IVocabulary get_Vocabulary();
}
public class Antlr4.Runtime.LexerNoViableAltException : RecognitionException {
    private static long serialVersionUID;
    private int startIndex;
    [NullableAttribute]
private ATNConfigSet deadEndConfigs;
    public int StartIndex { get; }
    [NullableAttribute]
public ATNConfigSet DeadEndConfigs { get; }
    public IIntStream InputStream { get; }
    public LexerNoViableAltException(Lexer lexer, ICharStream input, int startIndex, ATNConfigSet deadEndConfigs);
    public virtual int get_StartIndex();
    public virtual ATNConfigSet get_DeadEndConfigs();
    public virtual IIntStream get_InputStream();
    public virtual string ToString();
}
public class Antlr4.Runtime.ListTokenSource : object {
    protected internal IList`1<IToken> tokens;
    private string sourceName;
    protected internal int i;
    protected internal IToken eofToken;
    private ITokenFactory _factory;
    public int Column { get; }
    public int Line { get; }
    public ICharStream InputStream { get; }
    public string SourceName { get; }
    public ITokenFactory TokenFactory { get; public set; }
    public ListTokenSource(IList`1<IToken> tokens);
    public ListTokenSource(IList`1<IToken> tokens, string sourceName);
    public virtual int get_Column();
    public virtual IToken NextToken();
    public virtual int get_Line();
    public virtual ICharStream get_InputStream();
    public virtual string get_SourceName();
    public virtual ITokenFactory get_TokenFactory();
    public virtual void set_TokenFactory(ITokenFactory value);
}
public static class Antlr4.Runtime.Misc.Args : object {
    public static void NotNull(string parameterName, object value);
}
public interface Antlr4.Runtime.Misc.IIntSet {
    public int Count { get; }
    public bool IsNil { get; }
    public int SingleElement { get; }
    public abstract virtual void Add(int el);
    public abstract virtual IIntSet AddAll(IIntSet set);
    public abstract virtual IIntSet And(IIntSet a);
    public abstract virtual IIntSet Complement(IIntSet elements);
    public abstract virtual IIntSet Or(IIntSet a);
    public abstract virtual IIntSet Subtract(IIntSet a);
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsNil();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int get_SingleElement();
    public abstract virtual bool Contains(int el);
    public abstract virtual void Remove(int el);
    public abstract virtual IList`1<int> ToList();
    public abstract virtual string ToString();
}
public class Antlr4.Runtime.Misc.Interval : ValueType {
    public static Interval Invalid;
    public int a;
    public int b;
    public int Length { get; }
    public Interval(int a, int b);
    private static Interval();
    public static Interval Of(int a, int b);
    public int get_Length();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public bool StartsBeforeDisjoint(Interval other);
    public bool StartsBeforeNonDisjoint(Interval other);
    public bool StartsAfter(Interval other);
    public bool StartsAfterDisjoint(Interval other);
    public bool StartsAfterNonDisjoint(Interval other);
    public bool Disjoint(Interval other);
    public bool Adjacent(Interval other);
    public bool ProperlyContains(Interval other);
    public Interval Union(Interval other);
    public Interval Intersection(Interval other);
    public Nullable`1<Interval> DifferenceNotProperlyContained(Interval other);
    public virtual string ToString();
}
public class Antlr4.Runtime.Misc.IntervalSet : object {
    public static IntervalSet CompleteCharSet;
    public static IntervalSet EmptySet;
    protected internal IList`1<Interval> intervals;
    protected internal bool readonly;
    public bool IsNil { get; }
    public int SingleElement { get; }
    public int MaxElement { get; }
    public int MinElement { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private static IntervalSet();
    public IntervalSet(IList`1<Interval> intervals);
    public IntervalSet(IntervalSet set);
    public IntervalSet(Int32[] els);
    public static IntervalSet Of(int a);
    public static IntervalSet Of(int a, int b);
    public virtual void Clear();
    public virtual void Add(int el);
    public virtual void Add(int a, int b);
    protected internal virtual void Add(Interval addition);
    public static IntervalSet Or(IntervalSet[] sets);
    public virtual IntervalSet AddAll(IIntSet set);
    public virtual IntervalSet Complement(int minElement, int maxElement);
    public virtual IntervalSet Complement(IIntSet vocabulary);
    public virtual IntervalSet Subtract(IIntSet a);
    public static IntervalSet Subtract(IntervalSet left, IntervalSet right);
    public virtual IntervalSet Or(IIntSet a);
    public virtual IntervalSet And(IIntSet other);
    public virtual bool Contains(int el);
    public virtual bool get_IsNil();
    public virtual int get_SingleElement();
    public virtual int get_MaxElement();
    public virtual int get_MinElement();
    public virtual IList`1<Interval> GetIntervals();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual string ToString(bool elemAreChar);
    [ObsoleteAttribute("Use ToString(Antlr4.Runtime.IVocabulary) instead.")]
public virtual string ToString(String[] tokenNames);
    public virtual string ToString(IVocabulary vocabulary);
    [ObsoleteAttribute("Use ElementName(Antlr4.Runtime.IVocabulary, int) instead.")]
protected internal virtual string ElementName(String[] tokenNames, int a);
    protected internal virtual string ElementName(IVocabulary vocabulary, int a);
    public virtual int get_Count();
    public virtual List`1<int> ToIntegerList();
    public virtual IList`1<int> ToList();
    public virtual HashSet`1<int> ToSet();
    public virtual Int32[] ToArray();
    public virtual void Remove(int el);
    public virtual bool get_IsReadOnly();
    public virtual void SetReadonly(bool readonly);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.AddAll(IIntSet set);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.And(IIntSet a);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Complement(IIntSet elements);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Or(IIntSet a);
    private sealed virtual override IIntSet Antlr4.Runtime.Misc.IIntSet.Subtract(IIntSet a);
}
public class Antlr4.Runtime.Misc.MultiMap`2 : Dictionary`2<K, IList`1<V>> {
    private static long serialVersionUID;
    public virtual void Map(K key, V value);
    public virtual IList`1<Tuple`2<K, V>> GetPairs();
}
public class Antlr4.Runtime.Misc.MurmurHash : object {
    private static int DefaultSeed;
    public static int Initialize();
    public static int Initialize(int seed);
    public static int Update(int hash, int value);
    public static int Update(int hash, object value);
    public static int Finish(int hash, int numberOfWords);
    public static int HashCode(T[] data, int seed);
}
[AttributeUsageAttribute("10624")]
public class Antlr4.Runtime.Misc.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10624")]
public class Antlr4.Runtime.Misc.NullableAttribute : Attribute {
}
public class Antlr4.Runtime.Misc.ParseCanceledException : Exception {
    public ParseCanceledException(string message);
    public ParseCanceledException(Exception cause);
    public ParseCanceledException(string message, Exception cause);
}
public class Antlr4.Runtime.Misc.RuleDependencyChecker : object {
    private static BindingFlags AllDeclaredStaticMembers;
    private static BindingFlags AllDeclaredMembers;
    private static HashSet`1<string> checkedAssemblies;
    private static Dependents ImplementedDependents;
    private static RuleDependencyChecker();
    public static void CheckDependencies(Assembly assembly);
    private static IList`1<Type> GetTypesToCheck(Assembly assembly);
    private static bool IsChecked(Assembly assembly);
    private static void MarkChecked(Assembly assembly);
    private static void CheckDependencies(IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> dependencies, Type recognizerType);
    private static void ReportUnimplementedDependents(StringBuilder errors, Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider> dependency, Dependents dependents);
    private static int CheckDependencyVersion(StringBuilder errors, Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider> dependency, String[] ruleNames, Int32[] ruleVersions, int relatedRule, string relation);
    private static Int32[] GetRuleVersions(Type recognizerClass, String[] ruleNames);
    private static MethodInfo GetRuleMethod(Type recognizerClass, string name);
    private static String[] GetRuleNames(Type recognizerClass);
    public static IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> GetDependencies(Type clazz);
    private static void GetElementDependencies(ICustomAttributeProvider annotatedElement, IList`1<Tuple`2<RuleDependencyAttribute, ICustomAttributeProvider>> result);
    private static RuleRelations ExtractRuleRelations(Type recognizer);
    private static string GetSerializedATN(Type recognizerClass);
    protected static ICustomAttributeProvider AsCustomAttributeProvider(ICustomAttributeProvider obj);
}
public class Antlr4.Runtime.Misc.Utils : object {
    public static string Join(string separator, IEnumerable`1<T> items);
    public static int NumNonnull(Object[] data);
    public static void RemoveAllElements(ICollection`1<T> data, T value);
    public static string EscapeWhitespace(string s, bool escapeSpaces);
    public static void RemoveAll(IList`1<T> list, Predicate`1<T> predicate);
    public static IDictionary`2<string, int> ToMap(String[] keys);
    public static Char[] ToCharArray(List`1<int> data);
    public static IntervalSet ToSet(BitSet bits);
}
public class Antlr4.Runtime.NoViableAltException : RecognitionException {
    private static long serialVersionUID;
    [NullableAttribute]
private ATNConfigSet deadEndConfigs;
    [NotNullAttribute]
private IToken startToken;
    public IToken StartToken { get; }
    [NullableAttribute]
public ATNConfigSet DeadEndConfigs { get; }
    public NoViableAltException(Parser recognizer);
    public NoViableAltException(IRecognizer recognizer, ITokenStream input, IToken startToken, IToken offendingToken, ATNConfigSet deadEndConfigs, ParserRuleContext ctx);
    public virtual IToken get_StartToken();
    public virtual ATNConfigSet get_DeadEndConfigs();
}
public abstract class Antlr4.Runtime.Parser : Recognizer`2<IToken, ParserATNSimulator> {
    private static IDictionary`2<string, ATN> bypassAltsAtnCache;
    [NotNullAttribute]
protected internal IAntlrErrorStrategy _errHandler;
    protected internal ITokenStream _input;
    protected internal List`1<int> _precedenceStack;
    protected internal ParserRuleContext _ctx;
    protected internal bool _buildParseTrees;
    private TraceListener _tracer;
    [NullableAttribute]
protected internal IList`1<IParseTreeListener> _parseListeners;
    protected internal int _syntaxErrors;
    protected internal bool matchedEOF;
    public bool BuildParseTree { get; public set; }
    public bool TrimParseTree { get; public set; }
    public IList`1<IParseTreeListener> ParseListeners { get; }
    public int NumberOfSyntaxErrors { get; }
    public ITokenFactory TokenFactory { get; }
    public IAntlrErrorStrategy ErrorHandler { get; public set; }
    public IIntStream InputStream { get; }
    public IToken CurrentToken { get; }
    public int Precedence { get; }
    public ParserRuleContext Context { get; public set; }
    public IAntlrErrorListener`1<IToken> ErrorListenerDispatch { get; }
    public bool MatchedEndOfFile { get; }
    public ParserRuleContext RuleContext { get; }
    public string SourceName { get; }
    public ParseInfo ParseInfo { get; }
    unknown bool Profile {public set; }
    public bool Trace { get; public set; }
    public Parser(ITokenStream input);
    private static Parser();
    public virtual void Reset();
    public virtual IToken Match(int ttype);
    public virtual IToken MatchWildcard();
    public virtual bool get_BuildParseTree();
    public virtual void set_BuildParseTree(bool value);
    public virtual bool get_TrimParseTree();
    public virtual void set_TrimParseTree(bool value);
    public virtual IList`1<IParseTreeListener> get_ParseListeners();
    public virtual void AddParseListener(IParseTreeListener listener);
    public virtual void RemoveParseListener(IParseTreeListener listener);
    public virtual void RemoveParseListeners();
    protected internal virtual void TriggerEnterRuleEvent();
    protected internal virtual void TriggerExitRuleEvent();
    public virtual int get_NumberOfSyntaxErrors();
    public virtual ITokenFactory get_TokenFactory();
    public virtual ATN GetATNWithBypassAlts();
    public virtual ParseTreePattern CompileParseTreePattern(string pattern, int patternRuleIndex);
    public virtual ParseTreePattern CompileParseTreePattern(string pattern, int patternRuleIndex, Lexer lexer);
    public virtual IAntlrErrorStrategy get_ErrorHandler();
    public virtual void set_ErrorHandler(IAntlrErrorStrategy value);
    public virtual IIntStream get_InputStream();
    public virtual void SetInputStream(ITokenStream input);
    public virtual IToken get_CurrentToken();
    public void NotifyErrorListeners(string msg);
    public virtual void NotifyErrorListeners(IToken offendingToken, string msg, RecognitionException e);
    public virtual IToken Consume();
    protected internal virtual void AddContextToParseTree();
    public virtual void EnterRule(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void EnterLeftFactoredRule(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void ExitRule();
    public virtual void EnterOuterAlt(ParserRuleContext localctx, int altNum);
    public int get_Precedence();
    [ObsoleteAttribute("UseEnterRecursionRule(ParserRuleContext, int, int, int) instead.")]
public virtual void EnterRecursionRule(ParserRuleContext localctx, int ruleIndex);
    public virtual void EnterRecursionRule(ParserRuleContext localctx, int state, int ruleIndex, int precedence);
    public virtual void PushNewRecursionContext(ParserRuleContext localctx, int state, int ruleIndex);
    public virtual void UnrollRecursionContexts(ParserRuleContext _parentctx);
    public virtual ParserRuleContext GetInvokingContext(int ruleIndex);
    public virtual ParserRuleContext get_Context();
    public virtual void set_Context(ParserRuleContext value);
    public virtual bool Precpred(RuleContext localctx, int precedence);
    public virtual IAntlrErrorListener`1<IToken> get_ErrorListenerDispatch();
    public virtual bool InContext(string context);
    public virtual bool IsExpectedToken(int symbol);
    public virtual bool get_MatchedEndOfFile();
    public virtual IntervalSet GetExpectedTokens();
    public virtual IntervalSet GetExpectedTokensWithinCurrentRule();
    public virtual int GetRuleIndex(string ruleName);
    public virtual ParserRuleContext get_RuleContext();
    public virtual IList`1<string> GetRuleInvocationStack();
    public virtual IList`1<string> GetRuleInvocationStack(RuleContext p);
    public virtual IList`1<string> GetDFAStrings();
    public virtual void DumpDFA();
    public virtual string get_SourceName();
    public virtual ParseInfo get_ParseInfo();
    public virtual void set_Profile(bool value);
    public virtual bool get_Trace();
    public virtual void set_Trace(bool value);
}
public class Antlr4.Runtime.ParserInterpreter : Parser {
    protected internal string grammarFileName;
    protected internal ATN atn;
    protected internal BitSet pushRecursionContextStates;
    [ObsoleteAttribute]
protected internal String[] tokenNames;
    protected internal String[] ruleNames;
    [NotNullAttribute]
private IVocabulary vocabulary;
    protected internal Stack`1<Tuple`2<ParserRuleContext, int>> _parentContextStack;
    protected internal int overrideDecision;
    protected internal int overrideDecisionInputIndex;
    protected internal int overrideDecisionAlt;
    protected internal bool overrideDecisionReached;
    protected internal InterpreterRuleContext overrideDecisionRoot;
    protected internal InterpreterRuleContext rootContext;
    public ATN Atn { get; }
    [ObsoleteAttribute("Use IRecognizer.Vocabulary instead.")]
public String[] TokenNames { get; }
    public IVocabulary Vocabulary { get; }
    public String[] RuleNames { get; }
    public string GrammarFileName { get; }
    protected internal ATNState AtnState { get; }
    public InterpreterRuleContext OverrideDecisionRoot { get; }
    public InterpreterRuleContext RootContext { get; }
    public ParserInterpreter(ParserInterpreter old);
    [ObsoleteAttribute("Use ParserInterpreter(string, IVocabulary, System.Collections.Generic.ICollection{E}, Antlr4.Runtime.Atn.ATN, ITokenStream) instead.")]
public ParserInterpreter(string grammarFileName, IEnumerable`1<string> tokenNames, IEnumerable`1<string> ruleNames, ATN atn, ITokenStream input);
    public ParserInterpreter(string grammarFileName, IVocabulary vocabulary, IEnumerable`1<string> ruleNames, ATN atn, ITokenStream input);
    public virtual void Reset();
    public virtual ATN get_Atn();
    public virtual String[] get_TokenNames();
    public virtual IVocabulary get_Vocabulary();
    public virtual String[] get_RuleNames();
    public virtual string get_GrammarFileName();
    public virtual ParserRuleContext Parse(int startRuleIndex);
    public virtual void EnterRecursionRule(ParserRuleContext localctx, int state, int ruleIndex, int precedence);
    protected internal virtual ATNState get_AtnState();
    protected internal virtual void VisitState(ATNState p);
    protected internal virtual int VisitDecisionState(DecisionState p);
    protected internal virtual InterpreterRuleContext CreateInterpreterRuleContext(ParserRuleContext parent, int invokingStateNumber, int ruleIndex);
    protected internal virtual void VisitRuleStopState(ATNState p);
    public virtual void AddDecisionOverride(int decision, int tokenIndex, int forcedAlt);
    public virtual InterpreterRuleContext get_OverrideDecisionRoot();
    protected internal virtual void Recover(RecognitionException e);
    protected internal virtual IToken RecoverInline();
    public virtual InterpreterRuleContext get_RootContext();
}
public class Antlr4.Runtime.ParserRuleContext : RuleContext {
    private static ParserRuleContext Empty;
    public IList`1<IParseTree> children;
    public IToken start;
    public IToken stop;
    public RecognitionException exception;
    public static ParserRuleContext EmptyContext { get; }
    public RuleContext Parent { get; }
    public int ChildCount { get; }
    public Interval SourceInterval { get; }
    public IToken Start { get; }
    public IToken Stop { get; }
    public ParserRuleContext(ParserRuleContext parent, int invokingStateNumber);
    private static ParserRuleContext();
    public static ParserRuleContext get_EmptyContext();
    public virtual void CopyFrom(ParserRuleContext ctx);
    public virtual void EnterRule(IParseTreeListener listener);
    public virtual void ExitRule(IParseTreeListener listener);
    public virtual void AddChild(ITerminalNode t);
    public virtual void AddChild(RuleContext ruleInvocation);
    public virtual void RemoveLastChild();
    public virtual ITerminalNode AddChild(IToken matchedToken);
    public virtual IErrorNode AddErrorNode(IToken badToken);
    public virtual RuleContext get_Parent();
    public virtual IParseTree GetChild(int i);
    public virtual T GetChild(int i);
    public virtual ITerminalNode GetToken(int ttype, int i);
    public virtual ITerminalNode[] GetTokens(int ttype);
    public virtual T GetRuleContext(int i);
    public virtual T[] GetRuleContexts();
    public virtual int get_ChildCount();
    public virtual Interval get_SourceInterval();
    public virtual IToken get_Start();
    public virtual IToken get_Stop();
    public virtual string ToInfoString(Parser recognizer);
}
public class Antlr4.Runtime.ProxyErrorListener`1 : object {
    private IEnumerable`1<IAntlrErrorListener`1<Symbol>> delegates;
    protected internal IEnumerable`1<IAntlrErrorListener`1<Symbol>> Delegates { get; }
    public ProxyErrorListener`1(IEnumerable`1<IAntlrErrorListener`1<Symbol>> delegates);
    protected internal virtual IEnumerable`1<IAntlrErrorListener`1<Symbol>> get_Delegates();
    public virtual void SyntaxError(IRecognizer recognizer, Symbol offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.ProxyParserErrorListener : ProxyErrorListener`1<IToken> {
    public ProxyParserErrorListener(ICollection`1<IAntlrErrorListener`1<IToken>> delegates);
    public virtual void ReportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, bool exact, BitSet ambigAlts, ATNConfigSet configs);
    public virtual void ReportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, SimulatorState conflictState);
    public virtual void ReportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, SimulatorState acceptState);
}
public class Antlr4.Runtime.RecognitionException : Exception {
    private static long serialVersionUID;
    [NullableAttribute]
private IRecognizer recognizer;
    [NullableAttribute]
private RuleContext ctx;
    [NullableAttribute]
private IIntStream input;
    private IToken offendingToken;
    private int offendingState;
    public int OffendingState { get; protected set; }
    public RuleContext Context { get; }
    public IIntStream InputStream { get; }
    public IToken OffendingToken { get; protected set; }
    public IRecognizer Recognizer { get; }
    public RecognitionException(Lexer lexer, ICharStream input);
    public RecognitionException(IRecognizer recognizer, IIntStream input, ParserRuleContext ctx);
    public RecognitionException(string message, IRecognizer recognizer, IIntStream input, ParserRuleContext ctx);
    public int get_OffendingState();
    protected void set_OffendingState(int value);
    public virtual IntervalSet GetExpectedTokens();
    public virtual RuleContext get_Context();
    public virtual IIntStream get_InputStream();
    public IToken get_OffendingToken();
    protected void set_OffendingToken(IToken value);
    public virtual IRecognizer get_Recognizer();
}
public abstract class Antlr4.Runtime.Recognizer`2 : object {
    public static int Eof;
    [NotNullAttribute]
private IAntlrErrorListener`1[] _listeners;
    protected internal ATNInterpreter _interp;
    private int _stateNumber;
    [ObsoleteAttribute("Use IRecognizer.Vocabulary instead.")]
public String[] TokenNames { get; }
    public String[] RuleNames { get; }
    public IVocabulary Vocabulary { get; }
    [NotNullAttribute]
public IDictionary`2<string, int> TokenTypeMap { get; }
    [NotNullAttribute]
public IDictionary`2<string, int> RuleIndexMap { get; }
    public string SerializedAtn { get; }
    public string GrammarFileName { get; }
    public ATN Atn { get; }
    public ATNInterpreter Interpreter { get; public set; }
    public ParseInfo ParseInfo { get; }
    [NotNullAttribute]
[ObsoleteAttribute("Use AddErrorListener, RemoveErrorListener(s), or ErrorListenerDispatch as appropriate.")]
public IList`1<IAntlrErrorListener`1<Symbol>> ErrorListeners { get; }
    public IAntlrErrorListener`1<Symbol> ErrorListenerDispatch { get; }
    public int State { get; public set; }
    public IIntStream InputStream { get; }
    public abstract virtual String[] get_TokenNames();
    public abstract virtual String[] get_RuleNames();
    public virtual IVocabulary get_Vocabulary();
    public virtual IDictionary`2<string, int> get_TokenTypeMap();
    protected virtual IDictionary`2<string, int> CreateTokenTypeMap(IVocabulary vocabulary);
    public virtual IDictionary`2<string, int> get_RuleIndexMap();
    public virtual int GetTokenType(string tokenName);
    public virtual string get_SerializedAtn();
    public abstract virtual string get_GrammarFileName();
    public virtual ATN get_Atn();
    public virtual ATNInterpreter get_Interpreter();
    public virtual void set_Interpreter(ATNInterpreter value);
    public virtual ParseInfo get_ParseInfo();
    public virtual string GetErrorHeader(RecognitionException e);
    [ObsoleteAttribute("This method is not called by the ANTLR 4 Runtime. Specific implementations of IAntlrErrorStrategy may provide a similar feature when necessary. For example, see DefaultErrorStrategy.GetTokenErrorDisplay(IToken).")]
public virtual string GetTokenErrorDisplay(IToken t);
    public virtual void AddErrorListener(IAntlrErrorListener`1<Symbol> listener);
    public virtual void RemoveErrorListener(IAntlrErrorListener`1<Symbol> listener);
    public virtual void RemoveErrorListeners();
    public virtual IList`1<IAntlrErrorListener`1<Symbol>> get_ErrorListeners();
    public virtual IAntlrErrorListener`1<Symbol> get_ErrorListenerDispatch();
    public virtual bool Sempred(RuleContext _localctx, int ruleIndex, int actionIndex);
    public virtual bool Precpred(RuleContext localctx, int precedence);
    public virtual void Action(RuleContext _localctx, int ruleIndex, int actionIndex);
    public sealed virtual int get_State();
    public void set_State(int value);
    public abstract virtual IIntStream get_InputStream();
}
public class Antlr4.Runtime.RuleContext : object {
    public RuleContext parent;
    public int invokingState;
    public bool IsEmpty { get; }
    public Interval SourceInterval { get; }
    private RuleContext Antlr4.Runtime.Tree.IRuleNode.RuleContext { get; }
    public RuleContext Parent { get; }
    private IRuleNode Antlr4.Runtime.Tree.IRuleNode.Parent { get; }
    private IParseTree Antlr4.Runtime.Tree.IParseTree.Parent { get; }
    private ITree Antlr4.Runtime.Tree.ITree.Parent { get; }
    public RuleContext Payload { get; }
    private object Antlr4.Runtime.Tree.ITree.Payload { get; }
    public int RuleIndex { get; }
    public int OuterAlternative { get; public set; }
    public int ChildCount { get; }
    public RuleContext(RuleContext parent, int invokingState);
    public static RuleContext GetChildContext(RuleContext parent, int invokingState);
    public virtual int Depth();
    public virtual bool get_IsEmpty();
    public virtual Interval get_SourceInterval();
    private sealed virtual override RuleContext Antlr4.Runtime.Tree.IRuleNode.get_RuleContext();
    public virtual RuleContext get_Parent();
    private sealed virtual override IRuleNode Antlr4.Runtime.Tree.IRuleNode.get_Parent();
    private sealed virtual override IParseTree Antlr4.Runtime.Tree.IParseTree.get_Parent();
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.get_Parent();
    public virtual RuleContext get_Payload();
    private sealed virtual override object Antlr4.Runtime.Tree.ITree.get_Payload();
    public virtual string GetText();
    public virtual int get_RuleIndex();
    public virtual int get_OuterAlternative();
    public virtual void set_OuterAlternative(int value);
    public virtual IParseTree GetChild(int i);
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.GetChild(int i);
    public virtual int get_ChildCount();
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public virtual string ToStringTree(Parser recog);
    public virtual string ToStringTree(IList`1<string> ruleNames);
    public virtual string ToStringTree();
    public virtual string ToString();
    public string ToString(IRecognizer recog);
    public string ToString(IList`1<string> ruleNames);
    public virtual string ToString(IRecognizer recog, RuleContext stop);
    public virtual string ToString(IList`1<string> ruleNames, RuleContext stop);
}
public class Antlr4.Runtime.RuleContextWithAltNum : ParserRuleContext {
    private int altNumber;
    public int OuterAlternative { get; public set; }
    public RuleContextWithAltNum(ParserRuleContext parent, int invokingStateNumber);
    public virtual int get_OuterAlternative();
    public virtual void set_OuterAlternative(int value);
}
[AttributeUsageAttribute("32767")]
public class Antlr4.Runtime.RuleDependencyAttribute : Attribute {
    private Type _recognizer;
    private int _rule;
    private int _version;
    private Dependents _dependents;
    public Type Recognizer { get; }
    public int Rule { get; }
    public int Version { get; }
    public Dependents Dependents { get; }
    public RuleDependencyAttribute(Type recognizer, int rule, int version);
    public RuleDependencyAttribute(Type recognizer, int rule, int version, Dependents dependents);
    public Type get_Recognizer();
    public int get_Rule();
    public int get_Version();
    public Dependents get_Dependents();
}
[AttributeUsageAttribute("64")]
public class Antlr4.Runtime.RuleVersionAttribute : Attribute {
    private int _version;
    public int Version { get; }
    public RuleVersionAttribute(int version);
    public int get_Version();
}
internal static class Antlr4.Runtime.Sharpen.Arrays : object {
    public static T[] CopyOf(T[] array, int newSize);
    public static IList`1<T> AsList(T[] array);
    public static void Fill(T[] array, T value);
    public static int HashCode(T[] array);
    public static bool Equals(T[] left, T[] right);
    public static string ToString(T[] array);
}
public class Antlr4.Runtime.Sharpen.AtomicReference`1 : object {
    private T modreq(System.Runtime.CompilerServices.IsVolatile) _value;
    public AtomicReference`1(T value);
    public T Get();
    public void Set(T value);
    public bool CompareAndSet(T expect, T update);
    public T GetAndSet(T value);
}
public class Antlr4.Runtime.Sharpen.BitSet : object {
    private static UInt64[] EmptyBits;
    private static int BitsPerElement;
    private UInt64[] _data;
    private static Int32[] index64;
    public BitSet(int nbits);
    private static BitSet();
    private static int GetBitCount(UInt64[] value);
    private static int BitScanForward(ulong value);
    public BitSet Clone();
    public void Clear(int index);
    public bool Get(int index);
    public void Set(int index);
    public bool IsEmpty();
    public int Cardinality();
    public int NextSetBit(int fromIndex);
    public void And(BitSet set);
    public void Or(BitSet set);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Antlr4.Runtime.Sharpen.CollectionDebuggerView`1 : object {
    private ICollection`1<T> c;
    public T[] Items { get; }
    public CollectionDebuggerView`1(ICollection`1<T> col);
    public T[] get_Items();
}
internal class Antlr4.Runtime.Sharpen.CollectionDebuggerView`2 : object {
    private ICollection`1<KeyValuePair`2<T, U>> c;
    public KeyValuePair`2[] Items { get; }
    public CollectionDebuggerView`2(ICollection`1<KeyValuePair`2<T, U>> col);
    public KeyValuePair`2[] get_Items();
}
internal static class Antlr4.Runtime.Sharpen.Collections : object {
    public static T[] EmptyList();
    public static ReadOnlyDictionary`2<TKey, TValue> EmptyMap();
    public static ReadOnlyCollection`1<T> SingletonList(T item);
    public static ReadOnlyDictionary`2<TKey, TValue> SingletonMap(TKey key, TValue value);
}
[DefaultMemberAttribute("Item")]
public class Antlr4.Runtime.Sharpen.ConcurrentDictionary`2 : object {
    private IEqualityComparer`1<TKey> comparer;
    private SplitOrderedList`2<TKey, KeyValuePair`2<TKey, TValue>> internalDictionary;
    public TValue Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public ConcurrentDictionary`2(IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity);
    public ConcurrentDictionary`2(int concurrencyLevel, IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity, IEqualityComparer`1<TKey> comparer);
    private void CheckKey(TKey key);
    private void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> pair);
    public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public TValue AddOrUpdate(TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    private TValue AddOrUpdate(TKey key, TValue addValue, TValue updateValue);
    private TValue GetValue(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key, TValue value);
    public bool TryRemove(TKey key, TValue& value);
    private bool Remove(TKey key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> pair);
    public KeyValuePair`2[] ToArray();
    public sealed virtual void Clear();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private ICollection`1<T> GetPart(Func`2<KeyValuePair`2<TKey, TValue>, T> extractor);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int startIndex);
    private void CopyTo(KeyValuePair`2[] array, int startIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int startIndex);
    private void CopyTo(KeyValuePair`2[] array, int startIndex, int num);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumeratorInternal();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private static KeyValuePair`2<U, V> Make(U key, V value);
    private UInt32 Hash(TKey key);
}
[ExtensionAttribute]
internal static class Antlr4.Runtime.Sharpen.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue Get(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue Put(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
}
[ExtensionAttribute]
internal static class Antlr4.Runtime.Sharpen.ListExtensions : object {
    [ExtensionAttribute]
public static T Set(IList`1<T> list, int index, T value);
}
internal static class Antlr4.Runtime.Sharpen.Runtime : object {
    public static string Substring(string str, int beginOffset, int endOffset);
}
internal class Antlr4.Runtime.Sharpen.SequenceEqualityComparer`1 : EqualityComparer`1<IEnumerable`1<T>> {
    private static SequenceEqualityComparer`1<T> _default;
    private IEqualityComparer`1<T> _elementEqualityComparer;
    public static SequenceEqualityComparer`1<T> Default { get; }
    public SequenceEqualityComparer`1(IEqualityComparer`1<T> elementComparer);
    private static SequenceEqualityComparer`1();
    public static SequenceEqualityComparer`1<T> get_Default();
    public virtual bool Equals(IEnumerable`1<T> x, IEnumerable`1<T> y);
    public virtual int GetHashCode(IEnumerable`1<T> obj);
}
internal class Antlr4.Runtime.Sharpen.SpinWait : ValueType {
    private static int step;
    private static int maxTime;
    private int ntime;
    public void SpinOnce();
}
internal class Antlr4.Runtime.Sharpen.SplitOrderedList`2 : object {
    private static int MaxLoad;
    private static UInt32 BucketSize;
    private Node<TKey, T> head;
    private Node<TKey, T> tail;
    private Node[] buckets;
    private int count;
    private int size;
    private SimpleRwLock<TKey, T> slim;
    private IEqualityComparer`1<TKey> comparer;
    private static Byte[] reverseTable;
    private static Byte[] logTable;
    public int Count { get; }
    public SplitOrderedList`2(IEqualityComparer`1<TKey> comparer);
    private static SplitOrderedList`2();
    public int get_Count();
    public T InsertOrUpdate(UInt32 key, TKey subKey, Func`1<T> addGetter, Func`2<T, T> updateGetter);
    public T InsertOrUpdate(UInt32 key, TKey subKey, T addValue, T updateValue);
    public bool Insert(UInt32 key, TKey subKey, T data);
    public T InsertOrGet(UInt32 key, TKey subKey, T data, Func`1<T> dataCreator);
    private bool InsertInternal(UInt32 key, TKey subKey, T data, Func`1<T> dataCreator, Node& current);
    public bool Find(UInt32 key, TKey subKey, T& data);
    public bool CompareExchange(UInt32 key, TKey subKey, T data, Func`2<T, bool> check);
    public bool Delete(UInt32 key, TKey subKey, T& data);
    public IEnumerator`1<T> GetEnumerator();
    private Node<TKey, T> InitializeBucket(UInt32 b);
    private static UInt32 GetParent(UInt32 v);
    private static ulong ComputeRegularKey(UInt32 key);
    private static ulong ComputeDummyKey(UInt32 key);
    private Node<TKey, T> GetBucket(UInt32 index);
    private Node<TKey, T> SetBucket(UInt32 index, Node<TKey, T> node);
    private void CheckSegment(UInt32 segment, bool readLockTaken);
    private Node<TKey, T> ListSearch(ulong key, TKey subKey, Node& left, Node<TKey, T> h);
    private bool ListDelete(Node<TKey, T> startPoint, ulong key, TKey subKey, T& data);
    private bool ListInsert(Node<TKey, T> newNode, Node<TKey, T> startPoint, Node& current, Func`1<T> dataCreator);
    private bool ListFind(ulong key, TKey subKey, Node<TKey, T> startPoint, Node& data);
}
public static class Antlr4.Runtime.TokenConstants : object {
    public static int InvalidType;
    public static int Epsilon;
    public static int MinUserTokenType;
    public static int Eof;
    public static int DefaultChannel;
    public static int HiddenChannel;
    public static int MinUserChannelValue;
}
public class Antlr4.Runtime.TokenStreamRewriter : object {
    public static string DefaultProgramName;
    public static int ProgramInitSize;
    public static int MinTokenIndex;
    protected internal ITokenStream tokens;
    protected internal IDictionary`2<string, IList`1<RewriteOperation>> programs;
    protected internal IDictionary`2<string, int> lastRewriteTokenIndexes;
    public ITokenStream TokenStream { get; }
    public int LastRewriteTokenIndex { get; }
    public TokenStreamRewriter(ITokenStream tokens);
    public ITokenStream get_TokenStream();
    public virtual void Rollback(int instructionIndex);
    public virtual void Rollback(string programName, int instructionIndex);
    public virtual void DeleteProgram();
    public virtual void DeleteProgram(string programName);
    public virtual void InsertAfter(IToken t, object text);
    public virtual void InsertAfter(int index, object text);
    public virtual void InsertAfter(string programName, IToken t, object text);
    public virtual void InsertAfter(string programName, int index, object text);
    public virtual void InsertBefore(IToken t, object text);
    public virtual void InsertBefore(int index, object text);
    public virtual void InsertBefore(string programName, IToken t, object text);
    public virtual void InsertBefore(string programName, int index, object text);
    public virtual void Replace(int index, object text);
    public virtual void Replace(int from, int to, object text);
    public virtual void Replace(IToken indexT, object text);
    public virtual void Replace(IToken from, IToken to, object text);
    public virtual void Replace(string programName, int from, int to, object text);
    public virtual void Replace(string programName, IToken from, IToken to, object text);
    public virtual void Delete(int index);
    public virtual void Delete(int from, int to);
    public virtual void Delete(IToken indexT);
    public virtual void Delete(IToken from, IToken to);
    public virtual void Delete(string programName, int from, int to);
    public virtual void Delete(string programName, IToken from, IToken to);
    public virtual int get_LastRewriteTokenIndex();
    protected internal virtual int GetLastRewriteTokenIndex(string programName);
    protected internal virtual void SetLastRewriteTokenIndex(string programName, int i);
    protected internal virtual IList`1<RewriteOperation> GetProgram(string name);
    private IList`1<RewriteOperation> InitializeProgram(string name);
    public virtual string GetText();
    public virtual string GetText(string programName);
    public virtual string GetText(Interval interval);
    public virtual string GetText(string programName, Interval interval);
    protected internal virtual IDictionary`2<int, RewriteOperation> ReduceToSingleOperationPerIndex(IList`1<RewriteOperation> rewrites);
    protected internal virtual string CatOpText(object a, object b);
    protected internal virtual IList`1<T> GetKindOfOps(IList`1<RewriteOperation> rewrites, int before);
}
public static class Antlr4.Runtime.TokenTypes : object {
    public static int More;
    public static int Skip;
}
public abstract class Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1 : object {
    protected internal Result DefaultResult { get; }
    public virtual Result Visit(IParseTree tree);
    public virtual Result VisitChildren(IRuleNode node);
    public virtual Result VisitTerminal(ITerminalNode node);
    public virtual Result VisitErrorNode(IErrorNode node);
    protected internal virtual Result get_DefaultResult();
    protected internal virtual Result AggregateResult(Result aggregate, Result nextResult);
    protected internal virtual bool ShouldVisitNextChild(IRuleNode node, Result currentResult);
}
public class Antlr4.Runtime.Tree.ErrorNodeImpl : TerminalNodeImpl {
    public ErrorNodeImpl(IToken token);
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
}
public interface Antlr4.Runtime.Tree.IErrorNode {
}
public interface Antlr4.Runtime.Tree.IParseTree {
    public IParseTree Parent { get; }
    public abstract virtual IParseTree get_Parent();
    public abstract virtual IParseTree GetChild(int i);
    public abstract virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public abstract virtual string GetText();
    public abstract virtual string ToStringTree(Parser parser);
}
public interface Antlr4.Runtime.Tree.IParseTreeListener {
    public abstract virtual void VisitTerminal(ITerminalNode node);
    public abstract virtual void VisitErrorNode(IErrorNode node);
    public abstract virtual void EnterEveryRule(ParserRuleContext ctx);
    public abstract virtual void ExitEveryRule(ParserRuleContext ctx);
}
public interface Antlr4.Runtime.Tree.IParseTreeVisitor`1 {
    public abstract virtual Result Visit(IParseTree tree);
    public abstract virtual Result VisitChildren(IRuleNode node);
    public abstract virtual Result VisitTerminal(ITerminalNode node);
    public abstract virtual Result VisitErrorNode(IErrorNode node);
}
public interface Antlr4.Runtime.Tree.IRuleNode {
    public RuleContext RuleContext { get; }
    public IRuleNode Parent { get; }
    public abstract virtual RuleContext get_RuleContext();
    public abstract virtual IRuleNode get_Parent();
}
public interface Antlr4.Runtime.Tree.ISyntaxTree {
    public Interval SourceInterval { get; }
    public abstract virtual Interval get_SourceInterval();
}
public interface Antlr4.Runtime.Tree.ITerminalNode {
    public IToken Symbol { get; }
    public IRuleNode Parent { get; }
    public abstract virtual IToken get_Symbol();
    public abstract virtual IRuleNode get_Parent();
}
public interface Antlr4.Runtime.Tree.ITree {
    public ITree Parent { get; }
    public object Payload { get; }
    public int ChildCount { get; }
    public abstract virtual ITree get_Parent();
    public abstract virtual object get_Payload();
    public abstract virtual ITree GetChild(int i);
    public abstract virtual int get_ChildCount();
    public abstract virtual string ToStringTree();
}
public class Antlr4.Runtime.Tree.ParseTreeProperty`1 : object {
    protected internal ConcurrentDictionary`2<IParseTree, V> annotations;
    public virtual V Get(IParseTree node);
    public virtual void Put(IParseTree node, V value);
    public virtual V RemoveFrom(IParseTree node);
}
public class Antlr4.Runtime.Tree.ParseTreeWalker : object {
    public static ParseTreeWalker Default;
    private static ParseTreeWalker();
    public virtual void Walk(IParseTreeListener listener, IParseTree t);
    protected internal virtual void EnterRule(IParseTreeListener listener, IRuleNode r);
    protected internal virtual void ExitRule(IParseTreeListener listener, IRuleNode r);
}
internal abstract class Antlr4.Runtime.Tree.Pattern.Chunk : object {
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreeMatch : object {
    private IParseTree tree;
    private ParseTreePattern pattern;
    private MultiMap`2<string, IParseTree> labels;
    private IParseTree mismatchedNode;
    [NotNullAttribute]
public MultiMap`2<string, IParseTree> Labels { get; }
    [NullableAttribute]
public IParseTree MismatchedNode { get; }
    public bool Succeeded { get; }
    [NotNullAttribute]
public ParseTreePattern Pattern { get; }
    [NotNullAttribute]
public IParseTree Tree { get; }
    public ParseTreeMatch(IParseTree tree, ParseTreePattern pattern, MultiMap`2<string, IParseTree> labels, IParseTree mismatchedNode);
    public virtual IParseTree Get(string label);
    public virtual IList`1<IParseTree> GetAll(string label);
    public virtual MultiMap`2<string, IParseTree> get_Labels();
    public virtual IParseTree get_MismatchedNode();
    public virtual bool get_Succeeded();
    public virtual ParseTreePattern get_Pattern();
    public virtual IParseTree get_Tree();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreePattern : object {
    private int patternRuleIndex;
    [NotNullAttribute]
private string pattern;
    [NotNullAttribute]
private IParseTree patternTree;
    [NotNullAttribute]
private ParseTreePatternMatcher matcher;
    [NotNullAttribute]
public ParseTreePatternMatcher Matcher { get; }
    [NotNullAttribute]
public string Pattern { get; }
    public int PatternRuleIndex { get; }
    [NotNullAttribute]
public IParseTree PatternTree { get; }
    public ParseTreePattern(ParseTreePatternMatcher matcher, string pattern, int patternRuleIndex, IParseTree patternTree);
    public virtual ParseTreeMatch Match(IParseTree tree);
    public virtual bool Matches(IParseTree tree);
    public virtual IList`1<ParseTreeMatch> FindAll(IParseTree tree, string xpath);
    public virtual ParseTreePatternMatcher get_Matcher();
    public virtual string get_Pattern();
    public virtual int get_PatternRuleIndex();
    public virtual IParseTree get_PatternTree();
}
public class Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher : object {
    private Lexer lexer;
    private Parser parser;
    protected internal string start;
    protected internal string stop;
    protected internal string escape;
    [NotNullAttribute]
public Lexer Lexer { get; }
    [NotNullAttribute]
public Parser Parser { get; }
    public ParseTreePatternMatcher(Lexer lexer, Parser parser);
    public virtual void SetDelimiters(string start, string stop, string escapeLeft);
    public virtual bool Matches(IParseTree tree, string pattern, int patternRuleIndex);
    public virtual bool Matches(IParseTree tree, ParseTreePattern pattern);
    public virtual ParseTreeMatch Match(IParseTree tree, string pattern, int patternRuleIndex);
    public virtual ParseTreeMatch Match(IParseTree tree, ParseTreePattern pattern);
    public virtual ParseTreePattern Compile(string pattern, int patternRuleIndex);
    public virtual Lexer get_Lexer();
    public virtual Parser get_Parser();
    protected internal virtual IParseTree MatchImpl(IParseTree tree, IParseTree patternTree, MultiMap`2<string, IParseTree> labels);
    protected internal virtual RuleTagToken GetRuleTagToken(IParseTree t);
    public virtual IList`1<IToken> Tokenize(string pattern);
    internal virtual IList`1<Chunk> Split(string pattern);
}
public class Antlr4.Runtime.Tree.Pattern.RuleTagToken : object {
    private string ruleName;
    private int bypassTokenType;
    private string label;
    [NotNullAttribute]
public string RuleName { get; }
    [NullableAttribute]
public string Label { get; }
    public int Channel { get; }
    public string Text { get; }
    public int Type { get; }
    public int Line { get; }
    public int Column { get; }
    public int TokenIndex { get; }
    public int StartIndex { get; }
    public int StopIndex { get; }
    public ITokenSource TokenSource { get; }
    public ICharStream InputStream { get; }
    public RuleTagToken(string ruleName, int bypassTokenType);
    public RuleTagToken(string ruleName, int bypassTokenType, string label);
    public string get_RuleName();
    public string get_Label();
    public virtual int get_Channel();
    public virtual string get_Text();
    public virtual int get_Type();
    public virtual int get_Line();
    public virtual int get_Column();
    public virtual int get_TokenIndex();
    public virtual int get_StartIndex();
    public virtual int get_StopIndex();
    public virtual ITokenSource get_TokenSource();
    public virtual ICharStream get_InputStream();
    public virtual string ToString();
}
internal class Antlr4.Runtime.Tree.Pattern.TagChunk : Chunk {
    private string tag;
    private string label;
    [NotNullAttribute]
public string Tag { get; }
    [NullableAttribute]
public string Label { get; }
    public TagChunk(string tag);
    public TagChunk(string label, string tag);
    public string get_Tag();
    public string get_Label();
    public virtual string ToString();
}
internal class Antlr4.Runtime.Tree.Pattern.TextChunk : Chunk {
    [NotNullAttribute]
private string text;
    [NotNullAttribute]
public string Text { get; }
    public TextChunk(string text);
    public string get_Text();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.Pattern.TokenTagToken : CommonToken {
    [NotNullAttribute]
private string tokenName;
    [NullableAttribute]
private string label;
    [NotNullAttribute]
public string TokenName { get; }
    [NullableAttribute]
public string Label { get; }
    public string Text { get; }
    public TokenTagToken(string tokenName, int type);
    public TokenTagToken(string tokenName, int type, string label);
    public string get_TokenName();
    public string get_Label();
    public virtual string get_Text();
    public virtual string ToString();
}
public class Antlr4.Runtime.Tree.TerminalNodeImpl : object {
    public IToken symbol;
    public IRuleNode parent;
    public IToken Symbol { get; }
    public IRuleNode Parent { get; }
    private IParseTree Antlr4.Runtime.Tree.IParseTree.Parent { get; }
    private ITree Antlr4.Runtime.Tree.ITree.Parent { get; }
    public IToken Payload { get; }
    private object Antlr4.Runtime.Tree.ITree.Payload { get; }
    public Interval SourceInterval { get; }
    public int ChildCount { get; }
    public TerminalNodeImpl(IToken symbol);
    public virtual IParseTree GetChild(int i);
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.GetChild(int i);
    public virtual IToken get_Symbol();
    public virtual IRuleNode get_Parent();
    private sealed virtual override IParseTree Antlr4.Runtime.Tree.IParseTree.get_Parent();
    private sealed virtual override ITree Antlr4.Runtime.Tree.ITree.get_Parent();
    public virtual IToken get_Payload();
    private sealed virtual override object Antlr4.Runtime.Tree.ITree.get_Payload();
    public virtual Interval get_SourceInterval();
    public virtual int get_ChildCount();
    public virtual T Accept(IParseTreeVisitor`1<T> visitor);
    public virtual string GetText();
    public virtual string ToStringTree(Parser parser);
    public virtual string ToString();
    public virtual string ToStringTree();
}
public class Antlr4.Runtime.Tree.Trees : object {
    public static string ToStringTree(ITree t);
    public static string ToStringTree(ITree t, Parser recog);
    public static string ToStringTree(ITree t, IList`1<string> ruleNames);
    public static string GetNodeText(ITree t, Parser recog);
    public static string GetNodeText(ITree t, IList`1<string> ruleNames);
    public static IList`1<ITree> GetChildren(ITree t);
    public static IList`1<ITree> GetAncestors(ITree t);
    public static bool IsAncestorOf(ITree t, ITree u);
    public static ICollection`1<IParseTree> FindAllTokenNodes(IParseTree t, int ttype);
    public static ICollection`1<IParseTree> FindAllRuleNodes(IParseTree t, int ruleIndex);
    public static IList`1<IParseTree> FindAllNodes(IParseTree t, int index, bool findTokens);
    public static void _findAllNodes(IParseTree t, int index, bool findTokens, IList`1<IParseTree> nodes);
    public static IList`1<IParseTree> GetDescendants(IParseTree t);
    [ObsoleteAttribute("")]
public static IList`1<IParseTree> Descendants(IParseTree t);
    public static ParserRuleContext GetRootOfSubtreeEnclosingRegion(IParseTree t, int startTokenIndex, int stopTokenIndex);
    public static void StripChildrenOutOfRange(ParserRuleContext t, ParserRuleContext root, int startIndex, int stopIndex);
    public static ITree FindNodeSuchThat(ITree t, Predicate`1<ITree> pred);
}
public class Antlr4.Runtime.Tree.Xpath.XPath : object {
    public static string Wildcard;
    public static string Not;
    protected internal string path;
    protected internal XPathElement[] elements;
    protected internal Parser parser;
    public XPath(Parser parser, string path);
    public virtual XPathElement[] Split(string path);
    protected internal virtual XPathElement GetXPathElement(IToken wordToken, bool anywhere);
    public static ICollection`1<IParseTree> FindAll(IParseTree tree, string xpath, Parser parser);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public abstract class Antlr4.Runtime.Tree.Xpath.XPathElement : object {
    protected internal string nodeName;
    protected internal bool invert;
    public XPathElement(string nodeName);
    public abstract virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
    public virtual string ToString();
}
[GeneratedCodeAttribute("ANTLR", "4.6.5-beta002")]
[CLSCompliantAttribute("False")]
public class Antlr4.Runtime.Tree.Xpath.XPathLexer : Lexer {
    public static int TokenRef;
    public static int RuleRef;
    public static int Anywhere;
    public static int Root;
    public static int Wildcard;
    public static int Bang;
    public static int ID;
    public static int String;
    public static String[] modeNames;
    public static String[] ruleNames;
    private static String[] _LiteralNames;
    private static String[] _SymbolicNames;
    public static IVocabulary DefaultVocabulary;
    [ObsoleteAttribute("Use Vocabulary instead.")]
public static String[] tokenNames;
    public static string _serializedATN;
    public static ATN _ATN;
    [ObsoleteAttribute("Use IRecognizer.Vocabulary instead.")]
public String[] TokenNames { get; }
    [NotNullAttribute]
public IVocabulary Vocabulary { get; }
    public string GrammarFileName { get; }
    public String[] RuleNames { get; }
    public String[] ModeNames { get; }
    public string SerializedAtn { get; }
    public XPathLexer(ICharStream input);
    private static XPathLexer();
    private static String[] GenerateTokenNames(IVocabulary vocabulary, int length);
    public virtual String[] get_TokenNames();
    public virtual IVocabulary get_Vocabulary();
    public virtual string get_GrammarFileName();
    public virtual String[] get_RuleNames();
    public virtual String[] get_ModeNames();
    public virtual string get_SerializedAtn();
    public virtual void Action(RuleContext _localctx, int ruleIndex, int actionIndex);
    private void ID_action(RuleContext _localctx, int actionIndex);
}
public class Antlr4.Runtime.Tree.Xpath.XPathLexerErrorListener : object {
    public virtual void SyntaxError(IRecognizer recognizer, int offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e);
}
public class Antlr4.Runtime.Tree.Xpath.XPathRuleAnywhereElement : XPathElement {
    protected internal int ruleIndex;
    public XPathRuleAnywhereElement(string ruleName, int ruleIndex);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathRuleElement : XPathElement {
    protected internal int ruleIndex;
    public XPathRuleElement(string ruleName, int ruleIndex);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathTokenAnywhereElement : XPathElement {
    protected internal int tokenType;
    public XPathTokenAnywhereElement(string tokenName, int tokenType);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathTokenElement : XPathElement {
    protected internal int tokenType;
    public XPathTokenElement(string tokenName, int tokenType);
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathWildcardAnywhereElement : XPathElement {
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.Tree.Xpath.XPathWildcardElement : XPathElement {
    public virtual ICollection`1<IParseTree> Evaluate(IParseTree t);
}
public class Antlr4.Runtime.UnbufferedCharStream : object {
    protected internal Char[] data;
    protected internal int n;
    protected internal int p;
    protected internal int numMarkers;
    protected internal int lastChar;
    protected internal int lastCharBufferStart;
    protected internal int currentCharIndex;
    protected internal TextReader input;
    public string name;
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    protected internal int BufferStartIndex { get; }
    public UnbufferedCharStream(int bufferSize);
    public UnbufferedCharStream(Stream input);
    public UnbufferedCharStream(TextReader input);
    public UnbufferedCharStream(Stream input, int bufferSize);
    public UnbufferedCharStream(TextReader input, int bufferSize);
    public virtual void Consume();
    protected internal virtual void Sync(int want);
    protected internal virtual int Fill(int n);
    protected internal virtual int NextChar();
    protected internal virtual void Add(int c);
    public virtual int La(int i);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Index();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual string get_SourceName();
    public virtual string GetText(Interval interval);
    protected internal int get_BufferStartIndex();
}
public class Antlr4.Runtime.UnbufferedTokenStream : object {
    protected internal ITokenSource tokenSource;
    protected internal IToken[] tokens;
    protected internal int n;
    protected internal int p;
    protected internal int numMarkers;
    protected internal IToken lastToken;
    protected internal IToken lastTokenBufferStart;
    protected internal int currentTokenIndex;
    public ITokenSource TokenSource { get; }
    public int Index { get; }
    public int Size { get; }
    public string SourceName { get; }
    public UnbufferedTokenStream(ITokenSource tokenSource);
    public UnbufferedTokenStream(ITokenSource tokenSource, int bufferSize);
    public virtual IToken Get(int i);
    public virtual IToken Lt(int i);
    public virtual int La(int i);
    public virtual ITokenSource get_TokenSource();
    public virtual string GetText();
    public virtual string GetText(RuleContext ctx);
    public virtual string GetText(IToken start, IToken stop);
    public virtual void Consume();
    protected internal virtual void Sync(int want);
    protected internal virtual int Fill(int n);
    protected internal virtual void Add(IToken t);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Index();
    public virtual void Seek(int index);
    public virtual int get_Size();
    public virtual string get_SourceName();
    public virtual string GetText(Interval interval);
    protected internal int GetBufferStartIndex();
}
public class Antlr4.Runtime.Vocabulary : object {
    private static String[] EmptyNames;
    [NotNullAttribute]
public static Vocabulary EmptyVocabulary;
    [NotNullAttribute]
private String[] literalNames;
    [NotNullAttribute]
private String[] symbolicNames;
    [NotNullAttribute]
private String[] displayNames;
    private int maxTokenType;
    public int MaxTokenType { get; }
    public Vocabulary(String[] literalNames, String[] symbolicNames);
    public Vocabulary(String[] literalNames, String[] symbolicNames, String[] displayNames);
    private static Vocabulary();
    public static IVocabulary FromTokenNames(String[] tokenNames);
    public virtual int get_MaxTokenType();
    public virtual string GetLiteralName(int tokenType);
    public virtual string GetSymbolicName(int tokenType);
    public virtual string GetDisplayName(int tokenType);
}
public class System.Collections.Generic.HashSet`1 : object {
    private static int INITIAL_SIZE;
    private static float DEFAULT_LOAD_FACTOR;
    private static int NO_SLOT;
    private static int HASH_FLAG;
    private Int32[] table;
    private Link[] links;
    private T[] slots;
    private int touched;
    private int empty_slot;
    private int count;
    private int threshold;
    private IEqualityComparer`1<T> comparer;
    private int generation;
    private static HashSetEqualityComparer<T> setComparer;
    public int Count { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public HashSet`1(IEqualityComparer`1<T> comparer);
    public HashSet`1(IEnumerable`1<T> collection);
    public HashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    private static HashSet`1();
    public sealed virtual int get_Count();
    private void Init(int capacity, IEqualityComparer`1<T> comparer);
    private void InitArrays(int size);
    private bool SlotsContainsAt(int index, int hash, T item);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    private void Resize();
    private int GetLinkHashCode(int index);
    private int GetItemHashCode(T item);
    public bool Add(T item);
    public IEqualityComparer`1<T> get_Comparer();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Remove(T item);
    public int RemoveWhere(Predicate`1<T> match);
    public void TrimExcess();
    public void IntersectWith(IEnumerable`1<T> other);
    public void ExceptWith(IEnumerable`1<T> other);
    public bool Overlaps(IEnumerable`1<T> other);
    public bool SetEquals(IEnumerable`1<T> other);
    public void SymmetricExceptWith(IEnumerable`1<T> other);
    private HashSet`1<T> ToSet(IEnumerable`1<T> enumerable);
    public void UnionWith(IEnumerable`1<T> other);
    private bool CheckIsSubsetOf(HashSet`1<T> other);
    public bool IsSubsetOf(IEnumerable`1<T> other);
    public bool IsProperSubsetOf(IEnumerable`1<T> other);
    private bool CheckIsSupersetOf(HashSet`1<T> other);
    public bool IsSupersetOf(IEnumerable`1<T> other);
    public bool IsProperSupersetOf(IEnumerable`1<T> other);
    public static IEqualityComparer`1<HashSet`1<T>> CreateSetComparer();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<T> GetEnumerator();
    public T[] ToArray();
}
internal interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
internal interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
internal interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    private IDictionary`2<TKey, TValue> m_dictionary;
    private object m_syncRoot;
    private KeyCollection<TKey, TValue> m_keys;
    private ValueCollection<TKey, TValue> m_values;
    protected IDictionary`2<TKey, TValue> Dictionary { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    protected IDictionary`2<TKey, TValue> get_Dictionary();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
}
internal static class System.Collections.ObjectModel.ReadOnlyDictionaryHelpers : object {
    internal static void CopyToNonGenericICollectionHelper(ICollection`1<T> collection, Array array, int index);
}
internal interface System.ITuple {
    public int Size { get; }
    public abstract virtual string ToString(StringBuilder sb);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual int get_Size();
}
internal static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
internal class System.Tuple`1 : object {
    private T1 m_Item1;
    public T1 Item1 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
public class System.Tuple`2 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
internal class System.Tuple`3 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
internal class System.Tuple`4 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
internal class System.Tuple`5 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
internal class System.Tuple`6 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
internal class System.Tuple`7 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private int System.ITuple.Size { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
internal class System.Tuple`8 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    private TRest m_Rest;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private int System.ITuple.Size { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITuple.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITuple.ToString(StringBuilder sb);
    private sealed virtual override int System.ITuple.get_Size();
}
