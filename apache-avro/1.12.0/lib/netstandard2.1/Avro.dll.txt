internal static class Avro.Aliases : object {
    internal static IList`1<SchemaName> GetSchemaNames(IEnumerable`1<string> aliases, string enclosingTypeName, string enclosingTypeNamespace);
}
public class Avro.ArraySchema : UnnamedSchema {
    [CompilerGeneratedAttribute]
private Schema <ItemSchema>k__BackingField;
    public Schema ItemSchema { get; public set; }
    private ArraySchema(Schema items, PropertyMap customAttributes);
    [CompilerGeneratedAttribute]
public Schema get_ItemSchema();
    [CompilerGeneratedAttribute]
public void set_ItemSchema(Schema value);
    internal static ArraySchema NewInstance(JToken jtok, PropertyMap props, SchemaNames names, string encspace);
    public static ArraySchema Create(Schema items, PropertyMap customAttributes);
    protected internal virtual void WriteJsonFields(JsonTextWriter writer, SchemaNames names, string encspace);
    public virtual bool CanRead(Schema writerSchema);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Avro.AvroDecimal : ValueType {
    [CompilerGeneratedAttribute]
private BigInteger <UnscaledValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    public BigInteger UnscaledValue { get; }
    public int Scale { get; }
    internal int Sign { get; }
    public AvroDecimal(double value);
    public AvroDecimal(float value);
    public AvroDecimal(decimal value);
    public AvroDecimal(int value);
    public AvroDecimal(long value);
    public AvroDecimal(UInt32 value);
    public AvroDecimal(ulong value);
    public AvroDecimal(BigInteger unscaledValue, int scale);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BigInteger get_UnscaledValue();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Scale();
    internal int get_Sign();
    public virtual string ToString();
    public static bool op_Equality(AvroDecimal left, AvroDecimal right);
    public static bool op_Inequality(AvroDecimal left, AvroDecimal right);
    public static bool op_GreaterThan(AvroDecimal left, AvroDecimal right);
    public static bool op_GreaterThanOrEqual(AvroDecimal left, AvroDecimal right);
    public static bool op_LessThan(AvroDecimal left, AvroDecimal right);
    public static bool op_LessThanOrEqual(AvroDecimal left, AvroDecimal right);
    public static bool op_Equality(AvroDecimal left, decimal right);
    public static bool op_Inequality(AvroDecimal left, decimal right);
    public static bool op_GreaterThan(AvroDecimal left, decimal right);
    public static bool op_GreaterThanOrEqual(AvroDecimal left, decimal right);
    public static bool op_LessThan(AvroDecimal left, decimal right);
    public static bool op_LessThanOrEqual(AvroDecimal left, decimal right);
    public static bool op_Equality(decimal left, AvroDecimal right);
    public static bool op_Inequality(decimal left, AvroDecimal right);
    public static bool op_GreaterThan(decimal left, AvroDecimal right);
    public static bool op_GreaterThanOrEqual(decimal left, AvroDecimal right);
    public static bool op_LessThan(decimal left, AvroDecimal right);
    public static bool op_LessThanOrEqual(decimal left, AvroDecimal right);
    public static byte op_Explicit(AvroDecimal value);
    public static byte ToByte(AvroDecimal value);
    public static sbyte op_Explicit(AvroDecimal value);
    public static sbyte ToSByte(AvroDecimal value);
    public static short op_Explicit(AvroDecimal value);
    public static short ToInt16(AvroDecimal value);
    public static int op_Explicit(AvroDecimal value);
    public static int ToInt32(AvroDecimal value);
    public static long op_Explicit(AvroDecimal value);
    public static long ToInt64(AvroDecimal value);
    public static ushort op_Explicit(AvroDecimal value);
    public static ushort ToUInt16(AvroDecimal value);
    public static UInt32 op_Explicit(AvroDecimal value);
    public static UInt32 ToUInt32(AvroDecimal value);
    public static ulong op_Explicit(AvroDecimal value);
    public static ulong ToUInt64(AvroDecimal value);
    public static float op_Explicit(AvroDecimal value);
    public static float ToSingle(AvroDecimal value);
    public static double op_Explicit(AvroDecimal value);
    public static double ToDouble(AvroDecimal value);
    public static decimal op_Explicit(AvroDecimal value);
    public static decimal ToDecimal(AvroDecimal value);
    public static BigInteger op_Explicit(AvroDecimal value);
    public static BigInteger ToBigInteger(AvroDecimal value);
    public static AvroDecimal op_Implicit(byte value);
    public static AvroDecimal op_Implicit(sbyte value);
    public static AvroDecimal op_Implicit(short value);
    public static AvroDecimal op_Implicit(int value);
    public static AvroDecimal op_Implicit(long value);
    public static AvroDecimal op_Implicit(ushort value);
    public static AvroDecimal op_Implicit(UInt32 value);
    public static AvroDecimal op_Implicit(ulong value);
    public static AvroDecimal op_Implicit(float value);
    public static AvroDecimal op_Implicit(double value);
    public static AvroDecimal op_Implicit(decimal value);
    public static AvroDecimal op_Implicit(BigInteger value);
    public T ToType();
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(AvroDecimal other);
    public sealed virtual bool Equals(AvroDecimal other);
    private static Byte[] GetBytesFromDecimal(decimal d);
}
public class Avro.AvroException : Exception {
    public AvroException(string s);
    public AvroException(string s, Exception inner);
}
public class Avro.AvroRuntimeException : AvroException {
    public AvroRuntimeException(string s);
    public AvroRuntimeException(string s, Exception inner);
}
public class Avro.AvroTypeException : AvroException {
    public AvroTypeException(string s);
    public AvroTypeException(string message, Exception innerException);
}
public class Avro.CodeGen : object {
    [CompilerGeneratedAttribute]
private CodeCompileUnit <CompileUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Schema> <Schemas>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Protocol> <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <NamespaceMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CodeNamespace> <NamespaceLookup>k__BackingField;
    public CodeCompileUnit CompileUnit { get; private set; }
    public IList`1<Schema> Schemas { get; private set; }
    public IList`1<Protocol> Protocols { get; private set; }
    [ObsoleteAttribute("NamespaceMapping is not used, use AddProtocol(string ...) or AddSchema(string ...) instead!")]
public IDictionary`2<string, string> NamespaceMapping { get; private set; }
    protected Dictionary`2<string, CodeNamespace> NamespaceLookup { get; private set; }
    public CodeGen(Dictionary`2<string, CodeNamespace> namespaceLookup);
    [CompilerGeneratedAttribute]
public CodeCompileUnit get_CompileUnit();
    [CompilerGeneratedAttribute]
private void set_CompileUnit(CodeCompileUnit value);
    [CompilerGeneratedAttribute]
public IList`1<Schema> get_Schemas();
    [CompilerGeneratedAttribute]
private void set_Schemas(IList`1<Schema> value);
    [CompilerGeneratedAttribute]
public IList`1<Protocol> get_Protocols();
    [CompilerGeneratedAttribute]
private void set_Protocols(IList`1<Protocol> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_NamespaceMapping();
    [CompilerGeneratedAttribute]
private void set_NamespaceMapping(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, CodeNamespace> get_NamespaceLookup();
    [CompilerGeneratedAttribute]
private void set_NamespaceLookup(Dictionary`2<string, CodeNamespace> value);
    public virtual void AddProtocol(Protocol protocol);
    public virtual void AddProtocol(string protocolText, IEnumerable`1<KeyValuePair`2<string, string>> namespaceMapping);
    public virtual void AddSchema(Schema schema);
    public virtual void AddSchema(string schemaText, IEnumerable`1<KeyValuePair`2<string, string>> namespaceMapping);
    protected virtual CodeNamespace AddNamespace(string name);
    [ObsoleteAttribute("This method is deprecated and it will be removed in a future release! Please change call to AddNamespace(string name).")]
protected virtual CodeNamespace addNamespace(string name);
    public virtual CodeCompileUnit GenerateCode();
    protected virtual void ProcessSchemas();
    [ObsoleteAttribute("This method is deprecated and it will be removed in a future release! Please change call to ProcessSchemas().")]
protected virtual void processSchemas();
    protected virtual void ProcessProtocols();
    [ObsoleteAttribute("This method is deprecated and it will be removed in a future release! Please change call to ProcessProtocols().")]
protected virtual void processProtocols();
    [ObsoleteAttribute("This method is deprecated and it will be removed in a future release! Please use GenerateNames() instead.")]
protected virtual SchemaNames generateNames(Protocol protocol);
    protected virtual SchemaNames GenerateNames(Protocol protocol);
    [ObsoleteAttribute("This method is deprecated and it will be removed in a future release! Please use GenerateNames() instead.")]
protected virtual SchemaNames generateNames(Schema schema);
    protected virtual SchemaNames GenerateNames(Schema schema);
    protected virtual void addName(Schema schema, SchemaNames names);
    protected virtual void processFixed(Schema schema);
    protected virtual void processEnum(Schema schema);
    protected virtual void processInterface(Protocol protocol);
    private static CodeMemberMethod CreateRequestMethod();
    private static void AddMethods(Protocol protocol, bool generateCallback, CodeTypeDeclaration ctd);
    private void AddProtocolDocumentation(Protocol protocol, CodeTypeDeclaration ctd);
    protected virtual CodeTypeDeclaration processRecord(Schema schema);
    internal static string getType(Schema schema, bool nullible, Boolean& nullibleEnum);
    [ObsoleteAttribute("This method is deprecated and it will be removed in a future release! Please use GetNullableType() instead.")]
public static Schema getNullableType(UnionSchema schema);
    public static Schema GetNullableType(UnionSchema schema);
    protected virtual void createSchemaField(Schema schema, CodeTypeDeclaration ctd, bool overrideFlag);
    protected virtual CodeCommentStatement createDocComment(string comment);
    public virtual void WriteCompileUnit(string outputFile);
    public virtual IDictionary`2<string, string> GetTypes();
    public virtual void WriteTypes(string outputdir, bool skipDirectories);
    private static string ReplaceMappedNamespacesInSchema(string input, IEnumerable`1<KeyValuePair`2<string, string>> namespaceMapping);
}
public class Avro.CodeGenException : AvroException {
    public CodeGenException(string s);
    public CodeGenException(string s, Exception inner);
}
public class Avro.CodeGenUtil : object {
    [CompilerGeneratedAttribute]
private static CodeGenUtil <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeNamespaceImport[] <NamespaceImports>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCommentStatement <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReservedKeywords>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeAttributeDeclaration <GeneratedCodeAttribute>k__BackingField;
    private static char At;
    private static char Dot;
    private string _assemblyInformationVersion;
    public static string Object;
    public static CodeGenUtil Instance { get; }
    public CodeNamespaceImport[] NamespaceImports { get; private set; }
    public CodeCommentStatement FileComment { get; private set; }
    public HashSet`1<string> ReservedKeywords { get; private set; }
    public CodeAttributeDeclaration GeneratedCodeAttribute { get; private set; }
    private static CodeGenUtil();
    [CompilerGeneratedAttribute]
public static CodeGenUtil get_Instance();
    [CompilerGeneratedAttribute]
public CodeNamespaceImport[] get_NamespaceImports();
    [CompilerGeneratedAttribute]
private void set_NamespaceImports(CodeNamespaceImport[] value);
    [CompilerGeneratedAttribute]
public CodeCommentStatement get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(CodeCommentStatement value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReservedKeywords();
    [CompilerGeneratedAttribute]
private void set_ReservedKeywords(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public CodeAttributeDeclaration get_GeneratedCodeAttribute();
    [CompilerGeneratedAttribute]
private void set_GeneratedCodeAttribute(CodeAttributeDeclaration value);
    public string Mangle(string name);
    public string UnMangle(string name);
    private CodeAttributeDeclaration GetGeneratedCodeAttribute();
    private static string GetInformationalVersion();
}
[DefaultMemberAttribute("Item")]
public class Avro.EnumSchema : NamedSchema {
    [CompilerGeneratedAttribute]
private IList`1<string> <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Default>k__BackingField;
    private IDictionary`2<string, int> symbolMap;
    public IList`1<string> Symbols { get; private set; }
    public string Default { get; private set; }
    public int Count { get; }
    public string Item { get; }
    private EnumSchema(SchemaName name, IList`1<SchemaName> aliases, List`1<string> symbols, IDictionary`2<string, int> symbolMap, PropertyMap props, SchemaNames names, string doc, string defaultSymbol);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Symbols();
    [CompilerGeneratedAttribute]
private void set_Symbols(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Default();
    [CompilerGeneratedAttribute]
private void set_Default(string value);
    public int get_Count();
    public static EnumSchema Create(string name, IEnumerable`1<string> symbols, string space, IEnumerable`1<string> aliases, PropertyMap customProperties, string doc, string defaultSymbol);
    internal static EnumSchema NewInstance(JToken jtok, PropertyMap props, SchemaNames names, string encspace);
    private static IDictionary`2<string, int> CreateSymbolsMap(IEnumerable`1<string> symbols);
    private static void ValidateSymbolName(string symbol);
    protected internal virtual void WriteJsonFields(JsonTextWriter writer, SchemaNames names, string encspace);
    public int Ordinal(string symbol);
    public string get_Item(int index);
    public bool Contains(string symbol);
    public IEnumerator`1<string> GetEnumerator();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool CanRead(Schema writerSchema);
}
public class Avro.Field : object {
    public string Name;
    [CompilerGeneratedAttribute]
private IList`1<string> <Aliases>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pos>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SortOrder> <Ordering>k__BackingField;
    [CompilerGeneratedAttribute]
private Schema <Schema>k__BackingField;
    private PropertyMap Props;
    internal static JTokenEqualityComparer JtokenEqual;
    public IList`1<string> Aliases { get; private set; }
    public int Pos { get; private set; }
    public string Documentation { get; private set; }
    public JToken DefaultValue { get; private set; }
    public Nullable`1<SortOrder> Ordering { get; private set; }
    public Schema Schema { get; private set; }
    public Field(Schema schema, string name, int pos, IList`1<string> aliases, string doc, JToken defaultValue, SortOrder sortorder, PropertyMap customProperties);
    internal Field(Schema schema, string name, IList`1<string> aliases, int pos, string doc, JToken defaultValue, SortOrder sortorder, PropertyMap props);
    private static Field();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Aliases();
    [CompilerGeneratedAttribute]
private void set_Aliases(IList`1<string> value);
    [CompilerGeneratedAttribute]
public int get_Pos();
    [CompilerGeneratedAttribute]
private void set_Pos(int value);
    [CompilerGeneratedAttribute]
public string get_Documentation();
    [CompilerGeneratedAttribute]
private void set_Documentation(string value);
    [CompilerGeneratedAttribute]
public JToken get_DefaultValue();
    [CompilerGeneratedAttribute]
private void set_DefaultValue(JToken value);
    [CompilerGeneratedAttribute]
public Nullable`1<SortOrder> get_Ordering();
    [CompilerGeneratedAttribute]
private void set_Ordering(Nullable`1<SortOrder> value);
    [CompilerGeneratedAttribute]
public Schema get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(Schema value);
    internal Field ChangePosition(int newPosition);
    protected internal void writeJson(JsonTextWriter writer, SchemaNames names, string encspace);
    internal static IList`1<string> GetAliases(JToken jtok);
    public string GetProperty(string key);
    public virtual bool Equals(object obj);
    private static bool areEqual(object o1, object o2);
    public virtual int GetHashCode();
    private static int getHashCode(object obj);
}
public abstract class Avro.File.Codec : object {
    private static List`1<CodecResolver> _codecResolvers;
    private static Codec();
    public abstract virtual Byte[] Compress(Byte[] uncompressedData);
    public abstract virtual void Compress(MemoryStream inputStream, MemoryStream outputStream);
    [ObsoleteAttribute]
public virtual Byte[] Decompress(Byte[] compressedData);
    public abstract virtual Byte[] Decompress(Byte[] compressedData, int length);
    public abstract virtual string GetName();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public static void RegisterResolver(CodecResolver resolver);
    public static Codec CreateCodec(Type codecType);
    public static Codec CreateCodecFromString(string codecType);
    public virtual string ToString();
}
public class Avro.File.DataFileConstants : object {
    public static string MetaDataSync;
    public static string MetaDataCodec;
    public static string MetaDataSchema;
    public static string NullCodec;
    public static string DeflateCodec;
    public static string SnappyCodec;
    public static string BZip2Codec;
    public static string XZCodec;
    public static string ZstandardCodec;
    public static string MetaDataReserved;
    public static int Version;
    public static Byte[] Magic;
    public static int NullCodecHash;
    public static int DeflateCodecHash;
    public static int SyncSize;
    public static int DefaultSyncInterval;
    private static DataFileConstants();
}
public class Avro.File.DataFileReader`1 : object {
    private DatumReader`1<T> _reader;
    private Decoder _decoder;
    private Decoder _datumDecoder;
    private Header _header;
    private Codec _codec;
    private DataBlock<T> _currentBlock;
    private long _blockRemaining;
    private long _blockSize;
    private bool _availableBlock;
    private Byte[] _syncBuffer;
    private long _blockStart;
    private Stream _stream;
    private bool _leaveOpen;
    private Schema _readerSchema;
    private CreateDatumReader<T> _datumReaderFactory;
    public IEnumerable`1<T> NextEntries { get; }
    private DataFileReader`1(Stream stream, Schema readerSchema, CreateDatumReader<T> datumReaderFactory, bool leaveOpen);
    public static IFileReader`1<T> OpenReader(string path);
    public static IFileReader`1<T> OpenReader(string path, Schema readerSchema);
    public static IFileReader`1<T> OpenReader(Stream inStream);
    public static IFileReader`1<T> OpenReader(Stream inStream, bool leaveOpen);
    public static IFileReader`1<T> OpenReader(Stream inStream, Schema readerSchema);
    public static IFileReader`1<T> OpenReader(Stream inStream, Schema readerSchema, bool leaveOpen);
    public static IFileReader`1<T> OpenReader(Stream inStream, Schema readerSchema, CreateDatumReader<T> datumReaderFactory);
    public static IFileReader`1<T> OpenReader(Stream inStream, Schema readerSchema, CreateDatumReader<T> datumReaderFactory, bool leaveOpen);
    public sealed virtual Header GetHeader();
    public sealed virtual Schema GetSchema();
    public sealed virtual ICollection`1<string> GetMetaKeys();
    public sealed virtual Byte[] GetMeta(string key);
    public sealed virtual long GetMetaLong(string key);
    public sealed virtual string GetMetaString(string key);
    public sealed virtual void Seek(long position);
    public sealed virtual void Sync(long position);
    public sealed virtual bool PastSync(long position);
    public sealed virtual long PreviousSync();
    public sealed virtual long Tell();
    [IteratorStateMachineAttribute("Avro.File.DataFileReader`1/<get_NextEntries>d__37")]
public sealed virtual IEnumerable`1<T> get_NextEntries();
    public sealed virtual bool HasNext();
    public void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void Init(Stream stream);
    private static DatumReader`1<T> CreateDefaultReader(Schema writerSchema, Schema readerSchema);
    private Codec ResolveCodec();
    public sealed virtual T Next();
    private T Next(T reuse);
    private void BlockFinished();
    private DataBlock<T> NextRawBlock(DataBlock<T> reuse);
    private bool DataLeft();
    private bool HasNextBlock();
}
public class Avro.File.DataFileWriter`1 : object {
    private Schema _schema;
    private Codec _codec;
    private Stream _stream;
    private bool _leaveOpen;
    private MemoryStream _blockStream;
    private MemoryStream _compressedBlockStream;
    private Encoder _encoder;
    private Encoder _blockEncoder;
    private DatumWriter`1<T> _writer;
    private Byte[] _syncData;
    private bool _isOpen;
    private bool _headerWritten;
    private int _blockCount;
    private int _syncInterval;
    private IDictionary`2<string, Byte[]> _metaData;
    private DataFileWriter`1(DatumWriter`1<T> writer);
    public static IFileWriter`1<T> OpenWriter(DatumWriter`1<T> writer, string path);
    public static IFileWriter`1<T> OpenWriter(DatumWriter`1<T> writer, Stream outStream);
    public static IFileWriter`1<T> OpenWriter(DatumWriter`1<T> writer, Stream outStream, bool leaveOpen);
    public static IFileWriter`1<T> OpenWriter(DatumWriter`1<T> writer, string path, Codec codec);
    public static IFileWriter`1<T> OpenWriter(DatumWriter`1<T> writer, Stream outStream, Codec codec);
    public static IFileWriter`1<T> OpenWriter(DatumWriter`1<T> writer, Stream outStream, Codec codec, bool leaveOpen);
    public static IFileWriter`1<T> OpenAppendWriter(DatumWriter`1<T> writer, string path);
    public static IFileWriter`1<T> OpenAppendWriter(DatumWriter`1<T> writer, Stream inStream, Stream outStream);
    public sealed virtual bool IsReservedMeta(string key);
    public sealed virtual void SetMeta(string key, Byte[] value);
    public sealed virtual void SetMeta(string key, long value);
    public sealed virtual void SetMeta(string key, string value);
    public sealed virtual void SetSyncInterval(int syncInterval);
    public sealed virtual void Append(T datum);
    private IFileWriter`1<T> AppendTo(string path);
    private IFileWriter`1<T> AppendTo(Stream inStream, Stream outStream);
    private void EnsureHeader();
    public sealed virtual void Flush();
    public sealed virtual long Sync();
    private void SyncInternal();
    public sealed virtual void Close();
    private void WriteHeader();
    private void Init();
    private void AssertOpen();
    private IFileWriter`1<T> Create(Schema schema, Stream outStream, Codec codec, bool leaveOpen);
    private void WriteMetaData();
    private void WriteIfBlockFull();
    private long BufferInUse();
    private void WriteBlock();
    private void WriteSyncData();
    private void GenerateSyncData();
    private void SetMetaInternal(string key, Byte[] value);
    private Byte[] GetByteValue(string value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Avro.File.DeflateCodec : Codec {
    public virtual Byte[] Compress(Byte[] uncompressedData);
    public virtual void Compress(MemoryStream inputStream, MemoryStream outputStream);
    public virtual Byte[] Decompress(Byte[] compressedData, int length);
    public virtual string GetName();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class Avro.File.Header : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SyncData>k__BackingField;
    [CompilerGeneratedAttribute]
private Schema <Schema>k__BackingField;
    public IDictionary`2<string, Byte[]> MetaData { get; }
    public Byte[] SyncData { get; }
    public Schema Schema { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, Byte[]> get_MetaData();
    [CompilerGeneratedAttribute]
public Byte[] get_SyncData();
    [CompilerGeneratedAttribute]
public Schema get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(Schema value);
}
public interface Avro.File.IFileReader`1 {
    public IEnumerable`1<T> NextEntries { get; }
    public abstract virtual Header GetHeader();
    public abstract virtual Schema GetSchema();
    public abstract virtual ICollection`1<string> GetMetaKeys();
    public abstract virtual IEnumerable`1<T> get_NextEntries();
    public abstract virtual T Next();
    public abstract virtual bool HasNext();
    public abstract virtual Byte[] GetMeta(string key);
    public abstract virtual long GetMetaLong(string key);
    public abstract virtual string GetMetaString(string key);
    public abstract virtual bool PastSync(long position);
    public abstract virtual long PreviousSync();
    public abstract virtual void Seek(long position);
    public abstract virtual void Sync(long position);
    public abstract virtual long Tell();
}
public interface Avro.File.IFileWriter`1 {
    public abstract virtual void Append(T datum);
    public abstract virtual void Close();
    public abstract virtual void Flush();
    public abstract virtual bool IsReservedMeta(string key);
    public abstract virtual void SetMeta(string key, Byte[] value);
    public abstract virtual void SetMeta(string key, long value);
    public abstract virtual void SetMeta(string key, string value);
    public abstract virtual void SetSyncInterval(int syncInterval);
    public abstract virtual long Sync();
}
public class Avro.File.NullCodec : Codec {
    public virtual Byte[] Compress(Byte[] uncompressedData);
    public virtual void Compress(MemoryStream inputStream, MemoryStream outputStream);
    public virtual Byte[] Decompress(Byte[] compressedData, int length);
    public virtual string GetName();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class Avro.FixedSchema : NamedSchema {
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public int Size { get; public set; }
    private FixedSchema(SchemaName name, IList`1<SchemaName> aliases, int size, PropertyMap props, SchemaNames names, string doc);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    public static FixedSchema Create(string name, int size, string space, IEnumerable`1<string> aliases, PropertyMap customProperties, string doc);
    internal static FixedSchema NewInstance(JToken jtok, PropertyMap props, SchemaNames names, string encspace);
    protected internal virtual void WriteJsonFields(JsonTextWriter writer, SchemaNames names, string encspace);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool CanRead(Schema writerSchema);
}
internal class Avro.Function`1 : MulticastDelegate {
    public Function`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public interface Avro.Generic.DatumReader`1 {
    public Schema ReaderSchema { get; }
    public Schema WriterSchema { get; }
    public abstract virtual Schema get_ReaderSchema();
    public abstract virtual Schema get_WriterSchema();
    public abstract virtual T Read(T reuse, Decoder decoder);
}
public interface Avro.Generic.DatumWriter`1 {
    public Schema Schema { get; }
    public abstract virtual Schema get_Schema();
    public abstract virtual void Write(T datum, Encoder encoder);
}
public class Avro.Generic.DefaultReader : object {
    [CompilerGeneratedAttribute]
private Schema <ReaderSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private Schema <WriterSchema>k__BackingField;
    public Schema ReaderSchema { get; private set; }
    public Schema WriterSchema { get; private set; }
    public DefaultReader(Schema writerSchema, Schema readerSchema);
    [CompilerGeneratedAttribute]
public Schema get_ReaderSchema();
    [CompilerGeneratedAttribute]
private void set_ReaderSchema(Schema value);
    [CompilerGeneratedAttribute]
public Schema get_WriterSchema();
    [CompilerGeneratedAttribute]
private void set_WriterSchema(Schema value);
    public T Read(T reuse, Decoder decoder);
    public object Read(object reuse, Schema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object ReadNull(Schema readerSchema, Decoder d);
    protected T Read(Type tag, Schema readerSchema, Reader`1<T> reader);
    protected virtual object ReadRecord(object reuse, RecordSchema writerSchema, Schema readerSchema, Decoder dec);
    protected virtual object CreateRecord(object reuse, RecordSchema readerSchema);
    protected virtual bool TryGetField(object record, string fieldName, int fieldPos, Object& value);
    protected virtual void AddField(object record, string fieldName, int fieldPos, object fieldValue);
    protected virtual object ReadEnum(object reuse, EnumSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object CreateEnum(object reuse, EnumSchema es, string symbol);
    protected virtual object ReadArray(object reuse, ArraySchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object CreateArray(object reuse, ArraySchema rs);
    protected virtual int GetArraySize(object array);
    protected virtual void ResizeArray(Object& array, int n);
    protected virtual void SetArrayElement(object array, int index, object value);
    protected virtual object GetArrayElement(object array, int index);
    protected virtual object ReadMap(object reuse, MapSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object CreateMap(object reuse, MapSchema ms);
    protected virtual void AddMapEntry(object map, string key, object value);
    protected virtual object ReadUnion(object reuse, UnionSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object ReadLogical(object reuse, LogicalSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object ReadFixed(object reuse, FixedSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object CreateFixed(object reuse, FixedSchema rs);
    protected virtual Byte[] GetFixedBuffer(object f);
    protected virtual void Skip(Schema writerSchema, Decoder d);
    protected static Schema findBranch(UnionSchema us, Schema s);
}
public class Avro.Generic.DefaultWriter : object {
    [CompilerGeneratedAttribute]
private Schema <Schema>k__BackingField;
    public Schema Schema { get; private set; }
    public DefaultWriter(Schema schema);
    [CompilerGeneratedAttribute]
public Schema get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(Schema value);
    public void Write(T value, Encoder encoder);
    public virtual void Write(Schema schema, object value, Encoder encoder);
    protected virtual void WriteNull(object value, Encoder encoder);
    protected virtual void Write(object value, Type tag, Writer`1<T> writer);
    protected virtual void WriteRecord(RecordSchema schema, object value, Encoder encoder);
    protected virtual void EnsureRecordObject(RecordSchema s, object value);
    protected virtual object GetField(object value, string fieldName, int fieldPos);
    protected virtual void WriteEnum(EnumSchema es, object value, Encoder encoder);
    protected virtual void WriteArray(ArraySchema schema, object value, Encoder encoder);
    protected virtual void EnsureArrayObject(object value);
    protected virtual long GetArrayLength(object value);
    protected virtual object GetArrayElement(object value, long index);
    protected virtual void WriteMap(MapSchema schema, object value, Encoder encoder);
    protected virtual void EnsureMapObject(object value);
    protected virtual long GetMapSize(object value);
    protected virtual IEnumerable`1<KeyValuePair`2<string, object>> GetMapValues(object value);
    protected virtual void WriteUnion(UnionSchema us, object value, Encoder encoder);
    protected virtual int ResolveUnion(UnionSchema us, object obj);
    protected virtual void WriteLogical(LogicalSchema ls, object value, Encoder encoder);
    protected virtual void WriteFixed(FixedSchema es, object value, Encoder encoder);
    protected AvroException TypeMismatch(object obj, string schemaType, string type);
    private void Error(Schema schema, object value);
    protected virtual bool Matches(Schema sc, object obj);
}
public class Avro.Generic.GenericDatumReader`1 : PreresolvingDatumReader`1<T> {
    public GenericDatumReader`1(Schema writerSchema, Schema readerSchema);
    protected virtual bool IsReusable(Type tag);
    protected virtual ArrayAccess<T> GetArrayAccess(ArraySchema readerSchema);
    protected virtual EnumAccess<T> GetEnumAccess(EnumSchema readerSchema);
    protected virtual MapAccess<T> GetMapAccess(MapSchema readerSchema);
    protected virtual RecordAccess<T> GetRecordAccess(RecordSchema readerSchema);
    protected virtual FixedAccess<T> GetFixedAccess(FixedSchema readerSchema);
}
public class Avro.Generic.GenericDatumWriter`1 : PreresolvingDatumWriter`1<T> {
    public GenericDatumWriter`1(Schema schema);
    protected virtual void WriteRecordFields(object recordObj, RecordFieldWriter[] writers, Encoder encoder);
    protected virtual void EnsureRecordObject(RecordSchema recordSchema, object value);
    protected virtual void WriteField(object record, string fieldName, int fieldPos, WriteItem<T> writer, Encoder encoder);
    protected virtual WriteItem<T> ResolveEnum(EnumSchema es);
    protected virtual void WriteFixed(FixedSchema es, object value, Encoder encoder);
    protected virtual bool UnionBranchMatches(Schema sc, object obj);
}
public class Avro.Generic.GenericEnum : object {
    [CompilerGeneratedAttribute]
private EnumSchema <Schema>k__BackingField;
    private string _value;
    public EnumSchema Schema { get; private set; }
    public string Value { get; public set; }
    public GenericEnum(EnumSchema schema, string value);
    [CompilerGeneratedAttribute]
public EnumSchema get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(EnumSchema value);
    public string get_Value();
    public void set_Value(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Avro.Generic.GenericFixed : object {
    protected Byte[] value;
    private FixedSchema schema;
    public FixedSchema Schema { get; public set; }
    public Byte[] Value { get; public set; }
    public GenericFixed(FixedSchema schema);
    public GenericFixed(FixedSchema schema, Byte[] value);
    protected GenericFixed(UInt32 size);
    public FixedSchema get_Schema();
    public void set_Schema(FixedSchema value);
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Avro.Generic.GenericReader`1 : object {
    private DefaultReader reader;
    public Schema WriterSchema { get; }
    public Schema ReaderSchema { get; }
    public GenericReader`1(Schema writerSchema, Schema readerSchema);
    public GenericReader`1(DefaultReader reader);
    public sealed virtual Schema get_WriterSchema();
    public sealed virtual Schema get_ReaderSchema();
    public sealed virtual T Read(T reuse, Decoder d);
}
[DefaultMemberAttribute("Item")]
public class Avro.Generic.GenericRecord : object {
    [CompilerGeneratedAttribute]
private RecordSchema <Schema>k__BackingField;
    private Object[] contents;
    public RecordSchema Schema { get; private set; }
    public object Item { get; }
    public GenericRecord(RecordSchema schema);
    [CompilerGeneratedAttribute]
public RecordSchema get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(RecordSchema value);
    public object get_Item(string fieldName);
    public void Add(string fieldName, object fieldValue);
    public bool TryGetValue(string fieldName, Object& result);
    public object GetValue(int fieldPos);
    public void Add(int fieldPos, object fieldValue);
    public bool TryGetValue(int fieldPos, Object& result);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GenericRecord other);
    private static bool mapsEqual(IDictionary d1, IDictionary d2);
    private static bool objectsEqual(object o1, object o2);
    private static bool arraysEqual(Array a1, Array a2);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Avro.Generic.GenericWriter`1 : object {
    private DefaultWriter writer;
    public Schema Schema { get; }
    public GenericWriter`1(Schema schema);
    public GenericWriter`1(DefaultWriter writer);
    public sealed virtual Schema get_Schema();
    public sealed virtual void Write(T value, Encoder encoder);
}
public abstract class Avro.Generic.PreresolvingDatumReader`1 : object {
    [CompilerGeneratedAttribute]
private Schema <ReaderSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private Schema <WriterSchema>k__BackingField;
    private ReadItem<T> _reader;
    private Dictionary`2<SchemaPair<T>, ReadItem<T>> _recordReaders;
    public Schema ReaderSchema { get; private set; }
    public Schema WriterSchema { get; private set; }
    protected PreresolvingDatumReader`1(Schema writerSchema, Schema readerSchema);
    [CompilerGeneratedAttribute]
public sealed virtual Schema get_ReaderSchema();
    [CompilerGeneratedAttribute]
private void set_ReaderSchema(Schema value);
    [CompilerGeneratedAttribute]
public sealed virtual Schema get_WriterSchema();
    [CompilerGeneratedAttribute]
private void set_WriterSchema(Schema value);
    public sealed virtual T Read(T reuse, Decoder decoder);
    protected abstract virtual ArrayAccess<T> GetArrayAccess(ArraySchema readerSchema);
    protected abstract virtual EnumAccess<T> GetEnumAccess(EnumSchema readerSchema);
    protected abstract virtual MapAccess<T> GetMapAccess(MapSchema readerSchema);
    protected abstract virtual RecordAccess<T> GetRecordAccess(RecordSchema readerSchema);
    protected abstract virtual FixedAccess<T> GetFixedAccess(FixedSchema readerSchema);
    private ReadItem<T> ResolveReader(Schema writerSchema, Schema readerSchema);
    private ReadItem<T> ResolveEnum(EnumSchema writerSchema, EnumSchema readerSchema);
    private ReadItem<T> ResolveRecord(RecordSchema writerSchema, RecordSchema readerSchema);
    private object ReadRecord(object reuse, Decoder decoder, RecordAccess<T> recordAccess, IEnumerable`1<FieldReader<T>> readSteps);
    private ReadItem<T> ResolveUnion(UnionSchema writerSchema, Schema readerSchema);
    private object ReadUnion(object reuse, Decoder d, ReadItem[] branchLookup);
    private ReadItem<T> ResolveMap(MapSchema writerSchema, MapSchema readerSchema);
    private object ReadMap(object reuse, Decoder decoder, MapAccess<T> mapAccess, ReadItem<T> valueReader);
    private ReadItem<T> ResolveArray(ArraySchema writerSchema, ArraySchema readerSchema);
    private object ReadArray(object reuse, Decoder decoder, ArrayAccess<T> arrayAccess, ReadItem<T> itemReader, bool itemReusable);
    private ReadItem<T> ResolveLogical(LogicalSchema writerSchema, LogicalSchema readerSchema);
    private ReadItem<T> ResolveFixed(FixedSchema writerSchema, FixedSchema readerSchema);
    private object ReadFixed(object reuse, Decoder decoder, FixedAccess<T> fixedAccess);
    protected static Schema FindBranch(UnionSchema us, Schema s);
    private object ReadNull(object reuse, Decoder decoder);
    private object ReadBoolean(object reuse, Decoder decoder);
    private ReadItem<T> Read(DecoderRead<T> decoderRead);
    private DecoderSkip<T> GetSkip(Schema writerSchema);
    protected virtual bool IsReusable(Type tag);
}
public abstract class Avro.Generic.PreresolvingDatumWriter`1 : object {
    [CompilerGeneratedAttribute]
private Schema <Schema>k__BackingField;
    private WriteItem<T> _writer;
    private ArrayAccess<T> _arrayAccess;
    private MapAccess<T> _mapAccess;
    private Dictionary`2<RecordSchema, WriteItem<T>> _recordWriters;
    public Schema Schema { get; private set; }
    protected PreresolvingDatumWriter`1(Schema schema, ArrayAccess<T> arrayAccess, MapAccess<T> mapAccess);
    [CompilerGeneratedAttribute]
public sealed virtual Schema get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(Schema value);
    public sealed virtual void Write(T datum, Encoder encoder);
    private WriteItem<T> ResolveWriter(Schema schema);
    protected void WriteNull(object value, Encoder encoder);
    protected void Write(object value, Type tag, Writer`1<TValue> writer);
    private WriteItem<T> ResolveRecord(RecordSchema recordSchema);
    protected abstract virtual void WriteRecordFields(object record, RecordFieldWriter[] writers, Encoder encoder);
    protected abstract virtual void EnsureRecordObject(RecordSchema recordSchema, object value);
    protected abstract virtual void WriteField(object record, string fieldName, int fieldPos, WriteItem<T> writer, Encoder encoder);
    protected abstract virtual WriteItem<T> ResolveEnum(EnumSchema es);
    protected WriteItem<T> ResolveArray(ArraySchema schema);
    private void WriteArray(WriteItem<T> itemWriter, object array, Encoder encoder);
    protected WriteItem<T> ResolveLogical(LogicalSchema schema);
    private WriteItem<T> ResolveMap(MapSchema mapSchema);
    protected void WriteMap(WriteItem<T> itemWriter, object value, Encoder encoder);
    private WriteItem<T> ResolveUnion(UnionSchema unionSchema);
    private void WriteUnion(UnionSchema unionSchema, Schema[] branchSchemas, WriteItem[] branchWriters, object value, Encoder encoder);
    protected int ResolveUnion(UnionSchema us, Schema[] branchSchemas, object obj);
    protected abstract virtual void WriteFixed(FixedSchema es, object value, Encoder encoder);
    protected static AvroException TypeMismatch(object obj, string schemaType, string type);
    private void Error(Schema schema, object value);
    protected abstract virtual bool UnionBranchMatches(Schema sc, object obj);
}
public class Avro.Generic.Reader`1 : MulticastDelegate {
    public Reader`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public class Avro.Generic.Writer`1 : MulticastDelegate {
    public Writer`1(object object, IntPtr method);
    public virtual void Invoke(T t);
    public virtual IAsyncResult BeginInvoke(T t, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Avro.IO.BinaryDecoder : object {
    private Stream stream;
    private static int StackallocThreshold;
    private static int MaxFastReadLength;
    private static int MaxDotNetArrayLength;
    public BinaryDecoder(Stream stream);
    public sealed virtual void ReadNull();
    public sealed virtual bool ReadBoolean();
    public sealed virtual int ReadInt();
    public sealed virtual long ReadLong();
    public sealed virtual Byte[] ReadBytes();
    public sealed virtual int ReadEnum();
    public sealed virtual long ReadArrayStart();
    public sealed virtual long ReadArrayNext();
    public sealed virtual long ReadMapStart();
    public sealed virtual long ReadMapNext();
    public sealed virtual int ReadUnionIndex();
    public sealed virtual void ReadFixed(Byte[] buffer);
    public sealed virtual void ReadFixed(Byte[] buffer, int start, int length);
    public sealed virtual void SkipNull();
    public sealed virtual void SkipBoolean();
    public sealed virtual void SkipInt();
    public sealed virtual void SkipLong();
    public sealed virtual void SkipFloat();
    public sealed virtual void SkipDouble();
    public sealed virtual void SkipBytes();
    public sealed virtual void SkipString();
    public sealed virtual void SkipEnum();
    public sealed virtual void SkipUnionIndex();
    public sealed virtual void SkipFixed(int len);
    private Byte[] read(long p);
    private byte read();
    private long doReadItemCount();
    private void Skip(int p);
    private void Skip(long p);
    public sealed virtual float ReadFloat();
    public sealed virtual double ReadDouble();
    public sealed virtual string ReadString();
    private void Read(Byte[] buffer, int start, int len);
    private void Read(Span`1<byte> buffer);
}
public class Avro.IO.BinaryEncoder : object {
    private Stream stream;
    public BinaryEncoder(Stream stream);
    public sealed virtual void WriteNull();
    public sealed virtual void WriteBoolean(bool b);
    public sealed virtual void WriteInt(int value);
    public sealed virtual void WriteLong(long value);
    public sealed virtual void WriteFloat(float value);
    public sealed virtual void WriteDouble(double value);
    public sealed virtual void WriteBytes(Byte[] value);
    public sealed virtual void WriteBytes(Byte[] value, int offset, int length);
    public sealed virtual void WriteString(string value);
    public sealed virtual void WriteEnum(int value);
    public sealed virtual void StartItem();
    public sealed virtual void SetItemCount(long value);
    public sealed virtual void WriteArrayStart();
    public sealed virtual void WriteArrayEnd();
    public sealed virtual void WriteMapStart();
    public sealed virtual void WriteMapEnd();
    public sealed virtual void WriteUnionIndex(int value);
    public sealed virtual void WriteFixed(Byte[] data);
    public sealed virtual void WriteFixed(Byte[] data, int start, int len);
    private void writeBytes(Byte[] bytes);
    private void writeBytes(Byte[] bytes, int offset, int length);
    private void writeByte(byte b);
    public sealed virtual void Flush();
}
public class Avro.IO.ByteBufferInputStream : InputStream {
    private IList`1<MemoryStream> _buffers;
    private int _currentBuffer;
    public long Length { get; }
    public ByteBufferInputStream(IList`1<MemoryStream> buffers);
    public virtual int Read(Byte[] b, int off, int len);
    private MemoryStream GetNextNonEmptyBuffer();
    public virtual long get_Length();
}
public class Avro.IO.ByteBufferOutputStream : OutputStream {
    public static int BUFFER_SIZE;
    private List`1<MemoryStream> _buffers;
    public long Length { get; }
    private void Reset();
    private static MemoryStream CreateBuffer();
    public void Prepend(List`1<MemoryStream> lists);
    public void Append(List`1<MemoryStream> lists);
    public virtual void Write(Byte[] b, int off, int len);
    public List`1<MemoryStream> GetBufferList();
    public virtual long get_Length();
    public virtual void Flush();
}
public interface Avro.IO.Decoder {
    public abstract virtual void ReadNull();
    public abstract virtual bool ReadBoolean();
    public abstract virtual int ReadInt();
    public abstract virtual long ReadLong();
    public abstract virtual float ReadFloat();
    public abstract virtual double ReadDouble();
    public abstract virtual Byte[] ReadBytes();
    public abstract virtual string ReadString();
    public abstract virtual int ReadEnum();
    public abstract virtual long ReadArrayStart();
    public abstract virtual long ReadArrayNext();
    public abstract virtual long ReadMapStart();
    public abstract virtual long ReadMapNext();
    public abstract virtual int ReadUnionIndex();
    public abstract virtual void ReadFixed(Byte[] buffer);
    public abstract virtual void ReadFixed(Byte[] buffer, int start, int length);
    public abstract virtual void SkipNull();
    public abstract virtual void SkipBoolean();
    public abstract virtual void SkipInt();
    public abstract virtual void SkipLong();
    public abstract virtual void SkipFloat();
    public abstract virtual void SkipDouble();
    public abstract virtual void SkipBytes();
    public abstract virtual void SkipString();
    public abstract virtual void SkipEnum();
    public abstract virtual void SkipUnionIndex();
    public abstract virtual void SkipFixed(int len);
}
public interface Avro.IO.Encoder {
    public abstract virtual void WriteNull();
    public abstract virtual void WriteBoolean(bool value);
    public abstract virtual void WriteInt(int value);
    public abstract virtual void WriteLong(long value);
    public abstract virtual void WriteFloat(float value);
    public abstract virtual void WriteDouble(double value);
    public abstract virtual void WriteBytes(Byte[] value);
    public abstract virtual void WriteBytes(Byte[] value, int offset, int length);
    public abstract virtual void WriteString(string value);
    public abstract virtual void WriteEnum(int value);
    public abstract virtual void SetItemCount(long value);
    public abstract virtual void StartItem();
    public abstract virtual void WriteArrayStart();
    public abstract virtual void WriteArrayEnd();
    public abstract virtual void WriteMapStart();
    public abstract virtual void WriteMapEnd();
    public abstract virtual void WriteUnionIndex(int value);
    public abstract virtual void WriteFixed(Byte[] data);
    public abstract virtual void WriteFixed(Byte[] data, int start, int len);
    public abstract virtual void Flush();
}
[ObsoleteAttribute("This will be removed from the public API in a future version.")]
public interface Avro.IO.ICallback`1 {
    public abstract virtual void HandleResult(T result);
    public abstract virtual void HandleException(Exception exception);
}
public abstract class Avro.IO.InputStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Avro.IO.JsonDecoder : ParsingDecoder {
    private JsonReader reader;
    private Stack`1<ReorderBuffer> reorderBuffers;
    private ReorderBuffer currentReorderBuffer;
    private JsonDecoder(Symbol root, Stream stream);
    private JsonDecoder(Symbol root, string str);
    public JsonDecoder(Schema schema, Stream stream);
    public JsonDecoder(Schema schema, string str);
    private static Symbol GetSymbol(Schema schema);
    public void Configure(Stream stream);
    public void Configure(string str);
    private void Advance(Symbol symbol);
    public virtual void ReadNull();
    public virtual bool ReadBoolean();
    public virtual int ReadInt();
    public virtual long ReadLong();
    public virtual float ReadFloat();
    public virtual double ReadDouble();
    public virtual string ReadString();
    public virtual void SkipString();
    public virtual Byte[] ReadBytes();
    private Byte[] ReadByteArray();
    public virtual void SkipBytes();
    private void CheckFixed(int size);
    public virtual void ReadFixed(Byte[] bytes);
    public virtual void ReadFixed(Byte[] bytes, int start, int len);
    public virtual void SkipFixed(int length);
    private void DoSkipFixed(int length);
    protected virtual void SkipFixed();
    public virtual int ReadEnum();
    public virtual long ReadArrayStart();
    public virtual long ReadArrayNext();
    private long DoArrayNext();
    public virtual void SkipArray();
    public virtual long ReadMapStart();
    public virtual long ReadMapNext();
    private long DoMapNext();
    public virtual void SkipMap();
    public virtual int ReadUnionIndex();
    public virtual void SkipNull();
    public virtual void SkipBoolean();
    public virtual void SkipInt();
    public virtual void SkipLong();
    public virtual void SkipFloat();
    public virtual void SkipDouble();
    public virtual void SkipEnum();
    public virtual void SkipUnionIndex();
    public virtual Symbol DoAction(Symbol input, Symbol top);
    private static IList`1<JsonElement> GetValueAsTree(JsonReader reader);
    private JsonReader MakeParser(IList`1& elements);
    private AvroTypeException TypeError(string type);
}
public class Avro.IO.JsonEncoder : ParsingEncoder {
    private Parser parser;
    private JsonWriter writer;
    private bool includeNamespace;
    private BitArray isEmpty;
    public bool IncludeNamespace { get; public set; }
    public JsonEncoder(Schema sc, Stream stream);
    public JsonEncoder(Schema sc, Stream stream, bool pretty);
    public JsonEncoder(Schema sc, JsonWriter writer);
    public virtual void Flush();
    private static JsonWriter GetJsonWriter(Stream stream, bool pretty);
    public virtual bool get_IncludeNamespace();
    public virtual void set_IncludeNamespace(bool value);
    public void Configure(Stream stream);
    public void Configure(JsonWriter jsonWriter);
    public virtual void WriteNull();
    public virtual void WriteBoolean(bool b);
    public virtual void WriteInt(int n);
    public virtual void WriteLong(long n);
    public virtual void WriteFloat(float f);
    public virtual void WriteDouble(double d);
    public virtual void WriteString(string str);
    public virtual void WriteBytes(Byte[] bytes);
    public virtual void WriteBytes(Byte[] bytes, int start, int len);
    private void WriteByteArray(Byte[] bytes, int start, int len);
    public virtual void WriteFixed(Byte[] bytes);
    public virtual void WriteFixed(Byte[] bytes, int start, int len);
    public virtual void WriteEnum(int e);
    public virtual void WriteArrayStart();
    public virtual void WriteArrayEnd();
    public virtual void WriteMapStart();
    public virtual void WriteMapEnd();
    public virtual void StartItem();
    public virtual void WriteUnionIndex(int unionIndex);
    public virtual Symbol DoAction(Symbol input, Symbol top);
}
public abstract class Avro.IO.OutputStream : Stream {
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
public class Avro.IO.Parsing.JsonGrammarGenerator : ValidatingGrammarGenerator {
    public virtual Symbol Generate(Schema schema);
    protected virtual Symbol Generate(Schema sc, IDictionary`2<LitS, Symbol> seen);
}
public class Avro.IO.Parsing.Parser : object {
    private IActionHandler symbolHandler;
    protected Symbol[] Stack;
    protected int Pos;
    public Parser(Symbol root, IActionHandler symbolHandler);
    private void ExpandStack();
    public Symbol Advance(Symbol input);
    public void ProcessImplicitActions();
    public void ProcessTrailingImplicitActions();
    public void PushProduction(Symbol sym);
    public virtual Symbol PopSymbol();
    public virtual Symbol TopSymbol();
    public virtual void PushSymbol(Symbol sym);
    public virtual int Depth();
    public virtual void Reset();
}
public class Avro.IO.Parsing.SkipParser : Parser {
    private ISkipHandler skipHandler;
    public SkipParser(Symbol root, IActionHandler symbolHandler, ISkipHandler skipHandler);
    public void SkipTo(int target);
    public void SkipRepeater();
    public void SkipSymbol(Symbol symToSkip);
}
public abstract class Avro.IO.Parsing.Symbol : object {
    [CompilerGeneratedAttribute]
private Kind <SymKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Symbol[] <Production>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Boolean>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Int>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Long>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Float>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Double>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <String>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Fixed>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <Union>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <ArrayStart>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <ArrayEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <MapStart>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <MapEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <ItemEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <WriterUnion>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <FieldAction>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <RecordStart>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <RecordEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <UnionEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <FieldEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <DefaultEndAction>k__BackingField;
    [CompilerGeneratedAttribute]
private static Symbol <MapKeyMarker>k__BackingField;
    public Kind SymKind { get; private set; }
    public Symbol[] Production { get; private set; }
    public static Symbol Null { get; }
    public static Symbol Boolean { get; }
    public static Symbol Int { get; }
    public static Symbol Long { get; }
    public static Symbol Float { get; }
    public static Symbol Double { get; }
    public static Symbol String { get; }
    public static Symbol Bytes { get; }
    public static Symbol Fixed { get; }
    public static Symbol Enum { get; }
    public static Symbol Union { get; }
    public static Symbol ArrayStart { get; }
    public static Symbol ArrayEnd { get; }
    public static Symbol MapStart { get; }
    public static Symbol MapEnd { get; }
    public static Symbol ItemEnd { get; }
    public static Symbol WriterUnion { get; }
    public static Symbol FieldAction { get; }
    public static Symbol RecordStart { get; }
    public static Symbol RecordEnd { get; }
    public static Symbol UnionEnd { get; }
    public static Symbol FieldEnd { get; }
    public static Symbol DefaultEndAction { get; }
    public static Symbol MapKeyMarker { get; }
    protected Symbol(Kind kind);
    protected Symbol(Kind kind, Symbol[] production);
    private static Symbol();
    [CompilerGeneratedAttribute]
public Kind get_SymKind();
    [CompilerGeneratedAttribute]
private void set_SymKind(Kind value);
    [CompilerGeneratedAttribute]
public Symbol[] get_Production();
    [CompilerGeneratedAttribute]
private void set_Production(Symbol[] value);
    public static Symbol NewRoot(Symbol[] symbols);
    public static Symbol NewSeq(Symbol[] production);
    public static Symbol NewRepeat(Symbol endSymbol, Symbol[] symsToRepeat);
    public static Symbol NewAlt(Symbol[] symbols, String[] labels);
    protected static Symbol Error(string e);
    protected static Symbol Resolve(Symbol w, Symbol r);
    protected virtual Symbol Flatten(IDictionary`2<Sequence, Sequence> map, IDictionary`2<Sequence, IList`1<Fixup>> map2);
    public virtual int FlattenedSize();
    protected static void Flatten(Symbol[] input, int start, Symbol[] output, int skip, IDictionary`2<Sequence, Sequence> map, IDictionary`2<Sequence, IList`1<Fixup>> map2);
    private static void CopyFixups(IList`1<Fixup> fixups, Symbol[] output, int outPos, Symbol[] toCopy);
    protected static int FlattenedSize(Symbol[] symbols, int start);
    private static bool HasErrors(Symbol symbol);
    private static bool HasErrors(Symbol symbol, ISet`1<Symbol> visited);
    private static bool HasErrors(Symbol root, Symbol[] symbols, ISet`1<Symbol> visited);
    [CompilerGeneratedAttribute]
public static Symbol get_Null();
    [CompilerGeneratedAttribute]
public static Symbol get_Boolean();
    [CompilerGeneratedAttribute]
public static Symbol get_Int();
    [CompilerGeneratedAttribute]
public static Symbol get_Long();
    [CompilerGeneratedAttribute]
public static Symbol get_Float();
    [CompilerGeneratedAttribute]
public static Symbol get_Double();
    [CompilerGeneratedAttribute]
public static Symbol get_String();
    [CompilerGeneratedAttribute]
public static Symbol get_Bytes();
    [CompilerGeneratedAttribute]
public static Symbol get_Fixed();
    [CompilerGeneratedAttribute]
public static Symbol get_Enum();
    [CompilerGeneratedAttribute]
public static Symbol get_Union();
    [CompilerGeneratedAttribute]
public static Symbol get_ArrayStart();
    [CompilerGeneratedAttribute]
public static Symbol get_ArrayEnd();
    [CompilerGeneratedAttribute]
public static Symbol get_MapStart();
    [CompilerGeneratedAttribute]
public static Symbol get_MapEnd();
    [CompilerGeneratedAttribute]
public static Symbol get_ItemEnd();
    [CompilerGeneratedAttribute]
public static Symbol get_WriterUnion();
    [CompilerGeneratedAttribute]
public static Symbol get_FieldAction();
    [CompilerGeneratedAttribute]
public static Symbol get_RecordStart();
    [CompilerGeneratedAttribute]
public static Symbol get_RecordEnd();
    [CompilerGeneratedAttribute]
public static Symbol get_UnionEnd();
    [CompilerGeneratedAttribute]
public static Symbol get_FieldEnd();
    [CompilerGeneratedAttribute]
public static Symbol get_DefaultEndAction();
    [CompilerGeneratedAttribute]
public static Symbol get_MapKeyMarker();
}
public class Avro.IO.Parsing.ValidatingGrammarGenerator : object {
    public virtual Symbol Generate(Schema schema);
    protected virtual Symbol Generate(Schema sc, IDictionary`2<LitS, Symbol> seen);
}
public abstract class Avro.IO.ParsingDecoder : object {
    protected SkipParser Parser;
    protected ParsingDecoder(Symbol root);
    public abstract virtual void ReadNull();
    public abstract virtual bool ReadBoolean();
    public abstract virtual int ReadInt();
    public abstract virtual long ReadLong();
    public abstract virtual float ReadFloat();
    public abstract virtual double ReadDouble();
    public abstract virtual Byte[] ReadBytes();
    public abstract virtual string ReadString();
    public abstract virtual int ReadEnum();
    public abstract virtual long ReadArrayStart();
    public abstract virtual long ReadArrayNext();
    public abstract virtual long ReadMapStart();
    public abstract virtual long ReadMapNext();
    public abstract virtual int ReadUnionIndex();
    public abstract virtual void ReadFixed(Byte[] buffer);
    public abstract virtual void ReadFixed(Byte[] buffer, int start, int length);
    public abstract virtual void SkipNull();
    public abstract virtual void SkipBoolean();
    public abstract virtual void SkipInt();
    public abstract virtual void SkipLong();
    public abstract virtual void SkipFloat();
    public abstract virtual void SkipDouble();
    public abstract virtual void SkipBytes();
    public abstract virtual void SkipString();
    public abstract virtual void SkipEnum();
    public abstract virtual void SkipUnionIndex();
    public abstract virtual void SkipFixed(int len);
    public abstract virtual void SkipArray();
    public abstract virtual void SkipMap();
    public abstract virtual Symbol DoAction(Symbol input, Symbol top);
    protected abstract virtual void SkipFixed();
    public virtual void SkipAction();
    public virtual void SkipTopSymbol();
}
public abstract class Avro.IO.ParsingEncoder : object {
    private Int64[] counts;
    protected int Pos;
    public abstract virtual void WriteNull();
    public abstract virtual void WriteBoolean(bool value);
    public abstract virtual void WriteInt(int value);
    public abstract virtual void WriteLong(long value);
    public abstract virtual void WriteFloat(float value);
    public abstract virtual void WriteDouble(double value);
    public abstract virtual void WriteBytes(Byte[] value);
    public abstract virtual void WriteBytes(Byte[] value, int offset, int length);
    public abstract virtual void WriteString(string value);
    public abstract virtual void WriteEnum(int value);
    public abstract virtual void WriteArrayStart();
    public abstract virtual void WriteArrayEnd();
    public abstract virtual void WriteMapStart();
    public abstract virtual void WriteMapEnd();
    public abstract virtual void WriteUnionIndex(int value);
    public abstract virtual void WriteFixed(Byte[] data);
    public abstract virtual void WriteFixed(Byte[] data, int start, int len);
    public abstract virtual void Flush();
    public virtual void SetItemCount(long value);
    public virtual void StartItem();
    protected void Push();
    protected void Pop();
    protected int Depth();
}
internal static class Avro.IO.Resolver : object {
    public static void EncodeDefaultValue(Encoder enc, Schema schema, JToken jtok);
}
internal class Avro.JsonHelper : object {
    public static string GetOptionalString(JToken jtok, string field);
    public static string GetRequiredString(JToken jtok, string field);
    public static int GetRequiredInteger(JToken jtok, string field);
    public static Nullable`1<bool> GetOptionalBoolean(JToken jtok, string field);
    internal static void writeIfNotNullOrEmpty(JsonTextWriter writer, string key, string value);
    internal static void writeIfNotNull(JsonTextWriter writer, string key, string value);
}
public class Avro.LogicalSchema : UnnamedSchema {
    [CompilerGeneratedAttribute]
private Schema <BaseSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogicalTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private LogicalType <LogicalType>k__BackingField;
    public Schema BaseSchema { get; private set; }
    public string LogicalTypeName { get; private set; }
    public LogicalType LogicalType { get; private set; }
    public string Name { get; }
    public string Fullname { get; }
    private LogicalSchema(Schema baseSchema, string logicalTypeName, PropertyMap props);
    [CompilerGeneratedAttribute]
public Schema get_BaseSchema();
    [CompilerGeneratedAttribute]
private void set_BaseSchema(Schema value);
    [CompilerGeneratedAttribute]
public string get_LogicalTypeName();
    [CompilerGeneratedAttribute]
private void set_LogicalTypeName(string value);
    [CompilerGeneratedAttribute]
public LogicalType get_LogicalType();
    [CompilerGeneratedAttribute]
private void set_LogicalType(LogicalType value);
    internal static LogicalSchema NewInstance(JToken jtok, PropertyMap props, SchemaNames names, string encspace);
    protected internal virtual void WriteJson(JsonTextWriter writer, SchemaNames names, string encspace);
    public virtual string get_Name();
    public virtual string get_Fullname();
    public virtual bool CanRead(Schema writerSchema);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Avro.MapSchema : UnnamedSchema {
    [CompilerGeneratedAttribute]
private Schema <ValueSchema>k__BackingField;
    public Schema ValueSchema { get; public set; }
    private MapSchema(Schema valueSchema, PropertyMap cutsomProperties);
    [CompilerGeneratedAttribute]
public Schema get_ValueSchema();
    [CompilerGeneratedAttribute]
public void set_ValueSchema(Schema value);
    public static MapSchema CreateMap(Schema type, PropertyMap customProperties);
    internal static MapSchema NewInstance(JToken jtok, PropertyMap props, SchemaNames names, string encspace);
    protected internal virtual void WriteJsonFields(JsonTextWriter writer, SchemaNames names, string encspace);
    public virtual bool CanRead(Schema writerSchema);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Avro.Message : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Doc>k__BackingField;
    [CompilerGeneratedAttribute]
private RecordSchema <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private Schema <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private UnionSchema <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Oneway>k__BackingField;
    [CompilerGeneratedAttribute]
private UnionSchema <SupportedErrors>k__BackingField;
    public string Name { get; public set; }
    public string Doc { get; public set; }
    public RecordSchema Request { get; public set; }
    public Schema Response { get; public set; }
    public UnionSchema Error { get; public set; }
    public Nullable`1<bool> Oneway { get; public set; }
    public UnionSchema SupportedErrors { get; public set; }
    public Message(string name, string doc, RecordSchema request, Schema response, UnionSchema error, Nullable`1<bool> oneway);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Doc();
    [CompilerGeneratedAttribute]
public void set_Doc(string value);
    [CompilerGeneratedAttribute]
public RecordSchema get_Request();
    [CompilerGeneratedAttribute]
public void set_Request(RecordSchema value);
    [CompilerGeneratedAttribute]
public Schema get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(Schema value);
    [CompilerGeneratedAttribute]
public UnionSchema get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(UnionSchema value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Oneway();
    [CompilerGeneratedAttribute]
public void set_Oneway(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public UnionSchema get_SupportedErrors();
    [CompilerGeneratedAttribute]
public void set_SupportedErrors(UnionSchema value);
    internal static Message Parse(JProperty jmessage, SchemaNames names, string encspace);
    internal void writeJson(JsonTextWriter writer, SchemaNames names, string encspace);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected static bool areEqual(object o1, object o2);
}
public abstract class Avro.NamedSchema : Schema {
    [CompilerGeneratedAttribute]
private SchemaName <SchemaName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    private IList`1<SchemaName> aliases;
    public SchemaName SchemaName { get; private set; }
    public string Name { get; }
    public string Namespace { get; }
    public string Fullname { get; }
    public string Documentation { get; private set; }
    protected NamedSchema(Type type, SchemaName name, IList`1<SchemaName> aliases, PropertyMap props, SchemaNames names, string doc);
    [CompilerGeneratedAttribute]
public SchemaName get_SchemaName();
    [CompilerGeneratedAttribute]
private void set_SchemaName(SchemaName value);
    public virtual string get_Name();
    public string get_Namespace();
    public virtual string get_Fullname();
    [CompilerGeneratedAttribute]
public string get_Documentation();
    [CompilerGeneratedAttribute]
private void set_Documentation(string value);
    internal static NamedSchema NewInstance(JObject jo, PropertyMap props, SchemaNames names, string encspace);
    protected static SchemaName GetName(JToken jtok, string encspace);
    protected static IList`1<SchemaName> GetAliases(JToken jtok, string space, string encspace);
    protected bool InAliases(SchemaName name);
    protected internal virtual void WriteJson(JsonTextWriter writer, SchemaNames names, string encspace);
    protected internal virtual void WriteJsonFields(JsonTextWriter writer, SchemaNames names, string encspace);
}
public class Avro.PrimitiveSchema : UnnamedSchema {
    private PrimitiveSchema(Type type, PropertyMap customProperties);
    public static PrimitiveSchema Create(Type type, PropertyMap customProperties);
    public static PrimitiveSchema NewInstance(string type, PropertyMap props);
    protected internal virtual void WriteJson(JsonTextWriter w, SchemaNames names, string encspace);
    public virtual bool CanRead(Schema writerSchema);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Avro.PropertyMap : Dictionary`2<string, string> {
    private static HashSet`1<string> ReservedProps;
    private static PropertyMap();
    public void Parse(JToken jtok);
    public void Set(string key, string value);
    public void WriteJson(JsonTextWriter writer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Avro.Protocol : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Doc>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Schema> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Message> <Messages>k__BackingField;
    private Byte[] md5;
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public string Doc { get; public set; }
    public IList`1<Schema> Types { get; public set; }
    public IDictionary`2<string, Message> Messages { get; public set; }
    public Byte[] MD5 { get; }
    public Protocol(string name, string space, string doc, IEnumerable`1<Schema> types, IDictionary`2<string, Message> messages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_Doc();
    [CompilerGeneratedAttribute]
public void set_Doc(string value);
    [CompilerGeneratedAttribute]
public IList`1<Schema> get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(IList`1<Schema> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, Message> get_Messages();
    [CompilerGeneratedAttribute]
public void set_Messages(IDictionary`2<string, Message> value);
    public Byte[] get_MD5();
    public static Protocol Parse(string jstring);
    private static Protocol Parse(JToken jtok);
    public virtual string ToString();
    internal void WriteJson(JsonTextWriter writer, SchemaNames names);
    public virtual bool Equals(object obj);
    private bool TypesEquals(IList`1<Schema> that);
    private bool MessagesEquals(IDictionary`2<string, Message> that);
    public virtual int GetHashCode();
    private int GetTypesHashCode();
    private int GetMessagesHashCode();
}
public class Avro.ProtocolParseException : AvroException {
    public ProtocolParseException(string s);
    public ProtocolParseException(string s, Exception inner);
}
[DefaultMemberAttribute("Item")]
public class Avro.RecordSchema : NamedSchema {
    private List`1<Field> _fields;
    private IDictionary`2<string, Field> fieldLookup;
    private IDictionary`2<string, Field> fieldAliasLookup;
    private bool request;
    [ThreadStaticAttribute]
private static List`1<RecordSchemaPair> seen;
    public List`1<Field> Fields { get; public set; }
    public int Count { get; }
    public Field Item { get; }
    private RecordSchema(Type type, SchemaName name, IList`1<SchemaName> aliases, PropertyMap props, List`1<Field> fields, bool request, IDictionary`2<string, Field> fieldMap, IDictionary`2<string, Field> fieldAliasMap, SchemaNames names, string doc);
    public List`1<Field> get_Fields();
    public void set_Fields(List`1<Field> value);
    public int get_Count();
    public static RecordSchema Create(string name, List`1<Field> fields, string space, IEnumerable`1<string> aliases, PropertyMap customProperties, string doc);
    [IteratorStateMachineAttribute("Avro.RecordSchema/<EnumerateSchemasRecursive>d__10")]
private static IEnumerable`1<Schema> EnumerateSchemasRecursive(Schema schema);
    private static IDictionary`2<string, Field> CreateFieldMap(List`1<Field> fields, bool includeAliases);
    internal static RecordSchema NewInstance(Type type, JToken jtok, PropertyMap props, SchemaNames names, string encspace);
    private static Field createField(JToken jfield, int pos, SchemaNames names, string encspace);
    private static void addToFieldMap(Dictionary`2<string, Field> map, string name, Field field);
    private List`1<Field> SetFieldsPositions(List`1<Field> fields);
    public Field get_Item(string name);
    public bool Contains(string fieldName);
    public bool TryGetField(string fieldName, Field& field);
    public bool TryGetFieldAlias(string fieldName, Field& field);
    public IEnumerator`1<Field> GetEnumerator();
    protected internal virtual void WriteJsonFields(JsonTextWriter writer, SchemaNames names, string encspace);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool CanRead(Schema writerSchema);
    private T protect(Function`1<T> bypass, Function`1<T> main, RecordSchema that);
    [CompilerGeneratedAttribute]
private int <GetHashCode>b__25_1();
}
public class Avro.Reflect.ArrayHelper : object {
    private static Type _defaultType;
    [CompilerGeneratedAttribute]
private IEnumerable <Enumerable>k__BackingField;
    public static Type DefaultType { get; public set; }
    public IEnumerable Enumerable { get; public set; }
    public Type ArrayType { get; }
    public ArrayHelper(IEnumerable enumerable);
    private static ArrayHelper();
    public static Type get_DefaultType();
    public static void set_DefaultType(Type value);
    [CompilerGeneratedAttribute]
public IEnumerable get_Enumerable();
    [CompilerGeneratedAttribute]
public void set_Enumerable(IEnumerable value);
    public virtual int Count();
    public virtual void Add(object o);
    public virtual void Clear();
    public virtual Type get_ArrayType();
}
[ExtensionAttribute]
public static class Avro.Reflect.ArraySchemaExtensions : object {
    [ExtensionAttribute]
public static string GetHelper(ArraySchema ars);
}
[AttributeUsageAttribute("128")]
public class Avro.Reflect.AvroFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private IAvroFieldConverter <Converter>k__BackingField;
    public string FieldName { get; public set; }
    public IAvroFieldConverter Converter { get; public set; }
    public AvroFieldAttribute(string fieldName, Type converter);
    public AvroFieldAttribute(Type converter);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public IAvroFieldConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(IAvroFieldConverter value);
}
public class Avro.Reflect.ClassCache : object {
    private static ConcurrentBag`1<IAvroFieldConverter> _defaultConverters;
    private ConcurrentDictionary`2<string, DotnetClass> _nameClassMap;
    private ConcurrentDictionary`2<string, Type> _nameArrayMap;
    private ConcurrentDictionary`2<string, Schema> _previousFields;
    private static ClassCache();
    private void AddClassNameMapItem(RecordSchema schema, Type dotnetClass);
    public static void AddDefaultConverter(IAvroFieldConverter converter);
    public static void AddDefaultConverter(Func`3<TAvro, Schema, TProperty> from, Func`3<TProperty, Schema, TAvro> to);
    public IAvroFieldConverter GetDefaultConverter(Type tag, Type propType);
    public void AddArrayHelper(string name, Type helperType);
    public ArrayHelper GetArrayHelper(ArraySchema schema, IEnumerable enumerable);
    public DotnetClass GetClass(RecordSchema schema);
    public void LoadClassCache(Type objType, Schema s);
}
public class Avro.Reflect.DateTimeOffsetToLongConverter : object {
    public sealed virtual object ToAvroType(object o, Schema s);
    public sealed virtual object FromAvroType(object o, Schema s);
    public sealed virtual Type GetAvroType();
    public sealed virtual Type GetPropertyType();
}
public class Avro.Reflect.DotnetClass : object {
    private ConcurrentDictionary`2<string, DotnetProperty> _propertyMap;
    private Type _type;
    public DotnetClass(Type t, RecordSchema r, ClassCache cache);
    private PropertyInfo GetPropertyInfo(Field f);
    public object GetValue(object o, Field f);
    public void SetValue(object o, Field f, object v);
    public Type GetClassType();
    public Type GetPropertyType(Field f);
}
internal class Avro.Reflect.DotnetProperty : object {
    private PropertyInfo _property;
    [CompilerGeneratedAttribute]
private IAvroFieldConverter <Converter>k__BackingField;
    public IAvroFieldConverter Converter { get; public set; }
    public DotnetProperty(PropertyInfo property, Schema schema, IAvroFieldConverter converter, ClassCache cache);
    public DotnetProperty(PropertyInfo property, Schema schema, ClassCache cache);
    [CompilerGeneratedAttribute]
public IAvroFieldConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(IAvroFieldConverter value);
    private bool IsPropertyCompatible(Schema schema);
    public virtual Type GetPropertyType();
    public virtual object GetValue(object o, Schema s);
    public virtual void SetValue(object o, object v, Schema s);
}
public static class Avro.Reflect.EnumCache : object {
    private static ConcurrentDictionary`2<string, Type> _nameEnumMap;
    private static EnumCache();
    public static void AddEnumNameMapItem(NamedSchema schema, Type dotnetEnum);
    public static Type GetEnumeration(NamedSchema schema);
}
public class Avro.Reflect.FuncFieldConverter`2 : TypedFieldConverter`2<TAvro, TProperty> {
    private Func`3<TAvro, Schema, TProperty> _from;
    private Func`3<TProperty, Schema, TAvro> _to;
    public FuncFieldConverter`2(Func`3<TAvro, Schema, TProperty> from, Func`3<TProperty, Schema, TAvro> to);
    public virtual TProperty From(TAvro o, Schema s);
    public virtual TAvro To(TProperty o, Schema s);
}
public interface Avro.Reflect.IAvroFieldConverter {
    public abstract virtual object ToAvroType(object o, Schema s);
    public abstract virtual object FromAvroType(object o, Schema s);
    public abstract virtual Type GetAvroType();
    public abstract virtual Type GetPropertyType();
}
public class Avro.Reflect.ReflectDefaultReader : SpecificDefaultReader {
    private ClassCache _classCache;
    private Type _mapType;
    private Func`2<Type, object> _recordFactory;
    public Type MapType { get; public set; }
    public ClassCache ClassCache { get; }
    public Func`2<Type, object> RecordFactory { get; public set; }
    public ReflectDefaultReader(Type objType, Schema writerSchema, Schema readerSchema, ClassCache cache);
    public Type get_MapType();
    public void set_MapType(Type value);
    public ClassCache get_ClassCache();
    public Func`2<Type, object> get_RecordFactory();
    public void set_RecordFactory(Func`2<Type, object> value);
    internal Type GetTypeFromSchema(Schema schema, bool nullable);
    public object GetDefaultValue(Schema s, JToken defaultValue);
    protected virtual object ReadEnum(object reuse, EnumSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object ReadRecord(object reuse, RecordSchema writerSchema, Schema readerSchema, Decoder dec);
    protected virtual object ReadFixed(object reuse, FixedSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object ReadArray(object reuse, ArraySchema writerSchema, Schema readerSchema, Decoder dec);
    protected virtual object ReadMap(object reuse, MapSchema writerSchema, Schema readerSchema, Decoder d);
}
public class Avro.Reflect.ReflectDefaultWriter : SpecificDefaultWriter {
    private ClassCache _classCache;
    public ClassCache ClassCache { get; }
    public ReflectDefaultWriter(Type objType, Schema schema, ClassCache cache);
    public ReflectDefaultWriter(Schema schema);
    public ClassCache get_ClassCache();
    protected virtual void WriteRecord(RecordSchema schema, object value, Encoder encoder);
    protected virtual void WriteFixed(FixedSchema schema, object value, Encoder encoder);
    protected virtual void WriteArray(ArraySchema schema, object value, Encoder encoder);
    protected virtual void WriteMap(MapSchema schema, object value, Encoder encoder);
    protected virtual bool Matches(Schema sc, object obj);
}
public class Avro.Reflect.ReflectReader`1 : object {
    private ReflectDefaultReader _reader;
    public ReflectDefaultReader Reader { get; }
    public Schema WriterSchema { get; }
    public Schema ReaderSchema { get; }
    public ReflectReader`1(Schema writerSchema, Schema readerSchema, ClassCache cache);
    public ReflectReader`1(ReflectDefaultReader reader);
    public ReflectDefaultReader get_Reader();
    public sealed virtual Schema get_WriterSchema();
    public sealed virtual Schema get_ReaderSchema();
    public sealed virtual T Read(T reuse, Decoder dec);
    public T Read(Decoder dec);
}
public class Avro.Reflect.ReflectWriter`1 : object {
    private ReflectDefaultWriter _writer;
    public ReflectDefaultWriter Writer { get; }
    public Schema Schema { get; }
    public ReflectWriter`1(Schema schema, ClassCache cache);
    public ReflectWriter`1(ReflectDefaultWriter writer);
    public ReflectDefaultWriter get_Writer();
    public sealed virtual Schema get_Schema();
    public sealed virtual void Write(T value, Encoder encoder);
}
public abstract class Avro.Reflect.TypedFieldConverter`2 : object {
    public abstract virtual TProperty From(TAvro o, Schema s);
    public abstract virtual TAvro To(TProperty o, Schema s);
    public sealed virtual object FromAvroType(object o, Schema s);
    public sealed virtual Type GetAvroType();
    public sealed virtual Type GetPropertyType();
    public sealed virtual object ToAvroType(object o, Schema s);
}
public abstract class Avro.Schema : object {
    [CompilerGeneratedAttribute]
private Type <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyMap <Props>k__BackingField;
    public Type Tag { get; private set; }
    internal PropertyMap Props { get; private set; }
    public string Name { get; }
    public string Fullname { get; }
    protected Schema(Type type, PropertyMap props);
    [CompilerGeneratedAttribute]
public Type get_Tag();
    [CompilerGeneratedAttribute]
private void set_Tag(Type value);
    [CompilerGeneratedAttribute]
internal PropertyMap get_Props();
    [CompilerGeneratedAttribute]
private void set_Props(PropertyMap value);
    public abstract virtual string get_Name();
    public virtual string get_Fullname();
    internal static Schema ParseJson(JToken jtok, SchemaNames names, string encspace);
    public static Schema Parse(string json);
    internal static Schema Parse(string json, SchemaNames names, string encspace);
    internal static PropertyMap GetProperties(JToken jtok);
    public virtual string ToString();
    private void writeStartObject(JsonTextWriter writer);
    public static string GetTypeString(Type type);
    protected internal virtual void WriteJsonFields(JsonTextWriter writer, SchemaNames names, string encspace);
    protected internal virtual void WriteJson(JsonTextWriter writer, SchemaNames names, string encspace);
    public string GetProperty(string key);
    public virtual int GetHashCode();
    public virtual bool CanRead(Schema writerSchema);
    protected static bool areEqual(object o1, object o2);
    protected static int getHashCode(object obj);
    public static Nullable`1<Type> ParseType(string type, bool removeQuotes);
    private static string RemoveQuotes(string value);
}
public class Avro.SchemaName : object {
    private string fullName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Space>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EncSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    public string Name { get; private set; }
    public string Space { get; private set; }
    public string EncSpace { get; private set; }
    public string Documentation { get; private set; }
    public string Fullname { get; }
    public string Namespace { get; }
    public SchemaName(string name, string space, string encspace, string documentation);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Space();
    [CompilerGeneratedAttribute]
private void set_Space(string value);
    [CompilerGeneratedAttribute]
public string get_EncSpace();
    [CompilerGeneratedAttribute]
private void set_EncSpace(string value);
    [CompilerGeneratedAttribute]
public string get_Documentation();
    [CompilerGeneratedAttribute]
private void set_Documentation(string value);
    public string get_Fullname();
    public string get_Namespace();
    public virtual string ToString();
    internal void WriteJson(JsonTextWriter writer, SchemaNames names, string encspace);
    public virtual bool Equals(object obj);
    private static bool areEqual(object obj1, object obj2);
    public virtual int GetHashCode();
}
public class Avro.SchemaNames : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<SchemaName, NamedSchema> <Names>k__BackingField;
    public IDictionary`2<SchemaName, NamedSchema> Names { get; private set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<SchemaName, NamedSchema> get_Names();
    [CompilerGeneratedAttribute]
private void set_Names(IDictionary`2<SchemaName, NamedSchema> value);
    public bool Contains(SchemaName name);
    public bool Add(SchemaName name, NamedSchema schema);
    public bool Add(NamedSchema schema);
    public bool TryGetValue(string name, string space, string encspace, string documentation, NamedSchema& schema);
    public IEnumerator`1<KeyValuePair`2<SchemaName, NamedSchema>> GetEnumerator();
}
public static class Avro.SchemaNormalization : object {
    [ObsoleteAttribute("This will be removed from the public API in a future version.")]
public static long Empty64;
    private static SchemaNormalization();
    public static string ToParsingForm(Schema s);
    public static Byte[] Fingerprint(string fpName, Byte[] data);
    public static Byte[] ParsingFingerprint(string fpName, Schema s);
    public static long ParsingFingerprint64(Schema s);
    private static long Fingerprint64(Byte[] data);
    private static StringBuilder Build(IDictionary`2<string, string> env, Schema s, StringBuilder o);
}
public class Avro.SchemaParseException : AvroException {
    public SchemaParseException(string s);
    public SchemaParseException(string message, Exception innerException);
}
public interface Avro.Specific.ICallbackRequestor {
    public abstract virtual void Request(string messageName, Object[] args, object callback);
}
public interface Avro.Specific.ISpecificProtocol {
    public Protocol Protocol { get; }
    public abstract virtual Protocol get_Protocol();
    public abstract virtual void Request(ICallbackRequestor requestor, string messageName, Object[] args, object callback);
}
public interface Avro.Specific.ISpecificRecord {
    public Schema Schema { get; }
    public abstract virtual Schema get_Schema();
    public abstract virtual object Get(int fieldPos);
    public abstract virtual void Put(int fieldPos, object fieldValue);
}
public class Avro.Specific.ObjectCreator : object {
    [CompilerGeneratedAttribute]
private static ObjectCreator <Instance>k__BackingField;
    private Type GenericMapType;
    private Type GenericListType;
    private Type GenericIListType;
    private Type GenericNullableType;
    private ConcurrentDictionary`2<string, Type> typeCacheByName;
    private Assembly execAssembly;
    private Assembly entryAssembly;
    private bool diffAssembly;
    public static ObjectCreator Instance { get; }
    private static ObjectCreator();
    [CompilerGeneratedAttribute]
public static ObjectCreator get_Instance();
    private Type FindType(string name);
    private bool TryGetIListItemTypeName(string name, String& itemTypeName);
    private bool TryGetNullableItemTypeName(string name, String& itemTypeName);
    public Type GetType(Schema schema);
    public Type GetType(string name, Type schemaType);
    public object New(string name, Type schemaType);
}
public class Avro.Specific.SpecificDatumReader`1 : PreresolvingDatumReader`1<T> {
    public SpecificDatumReader`1(Schema writerSchema, Schema readerSchema);
    protected virtual bool IsReusable(Type tag);
    protected virtual ArrayAccess<T> GetArrayAccess(ArraySchema readerSchema);
    protected virtual EnumAccess<T> GetEnumAccess(EnumSchema readerSchema);
    protected virtual MapAccess<T> GetMapAccess(MapSchema readerSchema);
    protected virtual RecordAccess<T> GetRecordAccess(RecordSchema readerSchema);
    protected virtual FixedAccess<T> GetFixedAccess(FixedSchema readerSchema);
}
public class Avro.Specific.SpecificDatumWriter`1 : PreresolvingDatumWriter`1<T> {
    public SpecificDatumWriter`1(Schema schema);
    protected virtual void WriteRecordFields(object recordObj, RecordFieldWriter[] writers, Encoder encoder);
    protected virtual void EnsureRecordObject(RecordSchema recordSchema, object value);
    protected virtual void WriteField(object record, string fieldName, int fieldPos, WriteItem<T> writer, Encoder encoder);
    protected virtual WriteItem<T> ResolveEnum(EnumSchema es);
    protected virtual void WriteFixed(FixedSchema schema, object value, Encoder encoder);
    protected virtual bool UnionBranchMatches(Schema sc, object obj);
}
public class Avro.Specific.SpecificDefaultReader : DefaultReader {
    public SpecificDefaultReader(Schema writerSchema, Schema readerSchema);
    protected virtual object ReadRecord(object reuse, RecordSchema writerSchema, Schema readerSchema, Decoder dec);
    protected virtual object ReadFixed(object reuse, FixedSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual object ReadEnum(object reuse, EnumSchema writerSchema, Schema readerSchema, Decoder dec);
    protected virtual object ReadArray(object reuse, ArraySchema writerSchema, Schema readerSchema, Decoder dec);
    protected virtual object ReadMap(object reuse, MapSchema writerSchema, Schema readerSchema, Decoder d);
    protected virtual string getTargetType(Schema schema);
}
public class Avro.Specific.SpecificDefaultWriter : DefaultWriter {
    public SpecificDefaultWriter(Schema schema);
    protected virtual void WriteRecord(RecordSchema schema, object value, Encoder encoder);
    protected virtual void WriteFixed(FixedSchema schema, object value, Encoder encoder);
    protected virtual void WriteEnum(EnumSchema schema, object value, Encoder encoder);
    protected virtual void WriteArray(ArraySchema schema, object value, Encoder encoder);
    protected virtual void WriteMap(MapSchema schema, object value, Encoder encoder);
    protected virtual void WriteUnion(UnionSchema us, object value, Encoder encoder);
    protected virtual bool Matches(Schema sc, object obj);
}
public abstract class Avro.Specific.SpecificException : Exception {
    public Schema Schema { get; }
    public SpecificException(string message);
    public SpecificException(string message, Exception innerException);
    public abstract virtual Schema get_Schema();
    public abstract virtual object Get(int fieldPos);
    public abstract virtual void Put(int fieldPos, object fieldValue);
}
public abstract class Avro.Specific.SpecificFixed : GenericFixed {
    public Schema Schema { get; }
    public SpecificFixed(UInt32 size);
    public abstract virtual Schema get_Schema();
    protected bool Equals(SpecificFixed obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Avro.Specific.SpecificReader`1 : object {
    private SpecificDefaultReader reader;
    public Schema WriterSchema { get; }
    public Schema ReaderSchema { get; }
    public SpecificReader`1(Schema writerSchema, Schema readerSchema);
    public SpecificReader`1(SpecificDefaultReader reader);
    public sealed virtual Schema get_WriterSchema();
    public sealed virtual Schema get_ReaderSchema();
    public sealed virtual T Read(T reuse, Decoder dec);
}
public class Avro.Specific.SpecificWriter`1 : GenericWriter`1<T> {
    public SpecificWriter`1(Schema schema);
    public SpecificWriter`1(SpecificDefaultWriter writer);
}
[DefaultMemberAttribute("Item")]
public class Avro.UnionSchema : UnnamedSchema {
    [CompilerGeneratedAttribute]
private IList`1<Schema> <Schemas>k__BackingField;
    public IList`1<Schema> Schemas { get; private set; }
    public int Count { get; }
    public Schema Item { get; }
    private UnionSchema(List`1<Schema> schemas, PropertyMap customProperties);
    [CompilerGeneratedAttribute]
public IList`1<Schema> get_Schemas();
    [CompilerGeneratedAttribute]
private void set_Schemas(IList`1<Schema> value);
    public int get_Count();
    internal static UnionSchema NewInstance(JArray jarr, PropertyMap props, SchemaNames names, string encspace);
    public static UnionSchema Create(List`1<Schema> schemas, PropertyMap customProperties);
    public Schema get_Item(int index);
    protected internal virtual void WriteJson(JsonTextWriter writer, SchemaNames names, string encspace);
    public int MatchingBranch(Schema s);
    public virtual bool CanRead(Schema writerSchema);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private void VerifyChildSchemas(List`1<Schema> schemas);
}
public abstract class Avro.UnnamedSchema : Schema {
    public string Name { get; }
    protected UnnamedSchema(Type type, PropertyMap props);
    public virtual string get_Name();
}
public class Avro.Util.Date : LogicalUnixEpochType`1<DateTime> {
    public static string LogicalTypeName;
    private static Date();
    public virtual void ValidateSchema(LogicalSchema schema);
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
}
public class Avro.Util.Decimal : LogicalType {
    public static string LogicalTypeName;
    private static Decimal();
    public virtual void ValidateSchema(LogicalSchema schema);
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
    public virtual Type GetCSharpType(bool nullible);
    public virtual bool IsInstanceOfLogicalType(object logicalValue);
    private static int GetScalePropertyValueFromSchema(Schema schema, int defaultVal);
    private static Byte[] GetDecimalFixedByteArray(Byte[] sourceBuffer, int size, byte fillValue);
}
public class Avro.Util.LocalTimestampMicrosecond : LogicalUnixEpochType`1<DateTime> {
    public static string LogicalTypeName;
    private static LocalTimestampMicrosecond();
    public virtual void ValidateSchema(LogicalSchema schema);
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
}
public class Avro.Util.LocalTimestampMillisecond : LogicalUnixEpochType`1<DateTime> {
    public static string LogicalTypeName;
    private static LocalTimestampMillisecond();
    public virtual void ValidateSchema(LogicalSchema schema);
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
}
public abstract class Avro.Util.LogicalType : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    protected LogicalType(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual void ValidateSchema(LogicalSchema schema);
    public abstract virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public abstract virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
    public abstract virtual Type GetCSharpType(bool nullible);
    public abstract virtual bool IsInstanceOfLogicalType(object logicalValue);
}
public class Avro.Util.LogicalTypeFactory : object {
    private IDictionary`2<string, LogicalType> _logicalTypes;
    [CompilerGeneratedAttribute]
private static LogicalTypeFactory <Instance>k__BackingField;
    public static LogicalTypeFactory Instance { get; }
    private static LogicalTypeFactory();
    [CompilerGeneratedAttribute]
public static LogicalTypeFactory get_Instance();
    public void Register(LogicalType logicalType);
    public LogicalType GetFromLogicalSchema(LogicalSchema schema, bool ignoreInvalidOrUnknown);
}
public abstract class Avro.Util.LogicalUnixEpochType`1 : LogicalType {
    protected static DateTime UnixEpochDateTime;
    protected static long TicksPerMicrosecond;
    protected LogicalUnixEpochType`1(string name);
    private static LogicalUnixEpochType`1();
    public virtual Type GetCSharpType(bool nullible);
    public virtual bool IsInstanceOfLogicalType(object logicalValue);
}
public class Avro.Util.TimeMicrosecond : LogicalUnixEpochType`1<TimeSpan> {
    private static TimeSpan _exclusiveUpperBound;
    public static string LogicalTypeName;
    private static TimeMicrosecond();
    public virtual void ValidateSchema(LogicalSchema schema);
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
    private static void ThrowIfOutOfRange(TimeSpan time, string paramName);
}
public class Avro.Util.TimeMillisecond : LogicalUnixEpochType`1<TimeSpan> {
    private static TimeSpan _exclusiveUpperBound;
    public static string LogicalTypeName;
    private static TimeMillisecond();
    public virtual void ValidateSchema(LogicalSchema schema);
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
    private static void ThrowIfOutOfRange(TimeSpan time, string paramName);
}
public class Avro.Util.TimestampMicrosecond : LogicalUnixEpochType`1<DateTime> {
    public static string LogicalTypeName;
    private static TimestampMicrosecond();
    public virtual void ValidateSchema(LogicalSchema schema);
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
}
public class Avro.Util.TimestampMillisecond : LogicalUnixEpochType`1<DateTime> {
    public static string LogicalTypeName;
    private static TimestampMillisecond();
    public virtual void ValidateSchema(LogicalSchema schema);
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
}
public class Avro.Util.Uuid : LogicalType {
    public static string LogicalTypeName;
    private static Uuid();
    public virtual object ConvertToBaseValue(object logicalValue, LogicalSchema schema);
    public virtual object ConvertToLogicalValue(object baseValue, LogicalSchema schema);
    public virtual Type GetCSharpType(bool nullible);
    public virtual bool IsInstanceOfLogicalType(object logicalValue);
    public virtual void ValidateSchema(LogicalSchema schema);
}
