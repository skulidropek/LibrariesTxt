public class App.Metrics.Apdex.ApdexContext : ValueType {
    private long _start;
    private IApdex _apdex;
    public TimeSpan Elapsed { get; }
    public ApdexContext(IApdex apdex);
    public TimeSpan get_Elapsed();
    public sealed virtual void Dispose();
}
public class App.Metrics.Apdex.ApdexOptions : MetricValueWithSamplingOption {
    [CompilerGeneratedAttribute]
private bool <AllowWarmup>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ApdexTSeconds>k__BackingField;
    public bool AllowWarmup { get; public set; }
    public double ApdexTSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowWarmup();
    [CompilerGeneratedAttribute]
public void set_AllowWarmup(bool value);
    [CompilerGeneratedAttribute]
public double get_ApdexTSeconds();
    [CompilerGeneratedAttribute]
public void set_ApdexTSeconds(double value);
}
public class App.Metrics.Apdex.ApdexSnapshot : ValueType {
    private static double ApdexTimeUnitFactor;
    [CompilerGeneratedAttribute]
private int <FrustratingSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SatisfiedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ToleratingSize>k__BackingField;
    public int FrustratingSize { get; }
    public int SatisfiedSize { get; }
    public int ToleratingSize { get; }
    public ApdexSnapshot(IEnumerable`1<long> samples, double apdexTSeconds);
    private static ApdexSnapshot();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_FrustratingSize();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_SatisfiedSize();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ToleratingSize();
    public static bool op_Equality(ApdexSnapshot left, ApdexSnapshot right);
    public static bool op_Inequality(ApdexSnapshot left, ApdexSnapshot right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(ApdexSnapshot other);
}
public class App.Metrics.Apdex.ApdexValue : object {
    [CompilerGeneratedAttribute]
private int <Frustrating>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Satisfied>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Tolerating>k__BackingField;
    public int Frustrating { get; }
    public int SampleSize { get; }
    public int Satisfied { get; }
    public double Score { get; }
    public int Tolerating { get; }
    public ApdexValue(double score, int satisfied, int tolerating, int frustrating, int sampleSize, bool allowWarmup);
    [CompilerGeneratedAttribute]
public int get_Frustrating();
    [CompilerGeneratedAttribute]
public int get_SampleSize();
    [CompilerGeneratedAttribute]
public int get_Satisfied();
    [CompilerGeneratedAttribute]
public double get_Score();
    [CompilerGeneratedAttribute]
public int get_Tolerating();
}
public class App.Metrics.Apdex.ApdexValueSource : MetricValueSourceBase`1<ApdexValue> {
    public ApdexValueSource(string name, IMetricValueProvider`1<ApdexValue> value, MetricTags tags, bool resetOnReporting);
}
public interface App.Metrics.Apdex.IApdex {
    public abstract virtual long CurrentTime();
    public abstract virtual long EndRecording();
    public abstract virtual ApdexContext NewContext();
    public abstract virtual long StartRecording();
    public abstract virtual void Track(long duration);
    public abstract virtual void Track(Action action);
    public abstract virtual T Track(Func`1<T> action);
}
public interface App.Metrics.Apdex.IApdexMetric {
}
public interface App.Metrics.Apdex.IApdexProvider {
    public abstract virtual ApdexSnapshot GetSnapshot(bool resetReservoir);
    public abstract virtual void Reset();
    public abstract virtual void Update(long value);
}
public interface App.Metrics.Apdex.IBuildApdexMetrics {
    public abstract virtual IApdexMetric Build(double apdexTSeconds, bool allowWarmup, IClock clock);
    public abstract virtual IApdexMetric Build(Func`1<IReservoir> reservoir, double apdexTSeconds, bool allowWarmup, IClock clock);
}
public interface App.Metrics.Apdex.IMeasureApdexMetrics {
    public abstract virtual void Track(ApdexOptions options, Action action);
    public abstract virtual void Track(ApdexOptions options, MetricTags tags, Action action);
    public abstract virtual ApdexContext Track(ApdexOptions options);
    public abstract virtual ApdexContext Track(ApdexOptions options, MetricTags tags);
}
public interface App.Metrics.Apdex.IProvideApdexMetrics {
    public abstract virtual IApdex Instance(ApdexOptions options);
    public abstract virtual IApdex Instance(ApdexOptions options, MetricTags tags);
    public abstract virtual IApdex Instance(ApdexOptions options, Func`1<T> builder);
    public abstract virtual IApdex Instance(ApdexOptions options, MetricTags tags, Func`1<T> builder);
}
public enum App.Metrics.ApdexFields : Enum {
    public int value__;
    public static ApdexFields Samples;
    public static ApdexFields Score;
    public static ApdexFields Satisfied;
    public static ApdexFields Tolerating;
    public static ApdexFields Frustrating;
}
public static class App.Metrics.AppMetricsConstants : object {
    public static string InternalMetricsContext;
}
public static class App.Metrics.AppMetricsReservoirSamplingConstants : object {
    public static int ApdexRequiredSamplesBeforeCalculating;
    public static double DefaultApdexTSeconds;
    public static double DefaultExponentialDecayFactor;
    public static double DefaultMinimumSampleWeight;
    public static int DefaultSampleSize;
}
public class App.Metrics.BucketHistogram.BucketHistogramOptions : MetricValueOptionsBase {
    [CompilerGeneratedAttribute]
private IEnumerable`1<double> <Buckets>k__BackingField;
    public IEnumerable`1<double> Buckets { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<double> get_Buckets();
    [CompilerGeneratedAttribute]
public void set_Buckets(IEnumerable`1<double> value);
}
public class App.Metrics.BucketHistogram.BucketHistogramValue : object {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<double, double> <Buckets>k__BackingField;
    public long Count { get; }
    public double Sum { get; }
    public IReadOnlyDictionary`2<double, double> Buckets { get; }
    public BucketHistogramValue(long count, double sum, IReadOnlyDictionary`2<double, double> buckets);
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public double get_Sum();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<double, double> get_Buckets();
    public BucketHistogramValue Scale(double factor);
}
public class App.Metrics.BucketHistogram.BucketHistogramValueSource : MetricValueSourceBase`1<BucketHistogramValue> {
    public BucketHistogramValueSource(string name, IMetricValueProvider`1<BucketHistogramValue> valueProvider, Unit unit, MetricTags tags);
}
public interface App.Metrics.BucketHistogram.IBucketHistogram {
}
public interface App.Metrics.BucketHistogram.IBucketHistogramMetric {
}
public interface App.Metrics.BucketHistogram.IBuildBucketHistogramMetrics {
    public abstract virtual IBucketHistogramMetric Build(IEnumerable`1<double> buckets);
}
public interface App.Metrics.BucketHistogram.IMeasureBucketHistogramMetrics {
    public abstract virtual void Update(BucketHistogramOptions options, long value);
    public abstract virtual void Update(BucketHistogramOptions options, MetricTags tags, long value);
}
public interface App.Metrics.BucketHistogram.IProvideBucketHistogramMetrics {
    public abstract virtual IBucketHistogram Instance(BucketHistogramOptions options);
    public abstract virtual IBucketHistogram Instance(BucketHistogramOptions options, Func`1<T> builder);
    public abstract virtual IBucketHistogram Instance(BucketHistogramOptions options, MetricTags tags);
    public abstract virtual IBucketHistogram Instance(BucketHistogramOptions options, MetricTags tags, Func`1<T> builder);
}
public enum App.Metrics.BucketHistogramFields : Enum {
    public int value__;
    public static BucketHistogramFields Count;
    public static BucketHistogramFields Sum;
    public static BucketHistogramFields Bucket;
}
public class App.Metrics.BucketTimer.BucketTimerOptions : MetricValueOptionsBase {
    [CompilerGeneratedAttribute]
private TimeUnit <DurationUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <RateUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<double> <Buckets>k__BackingField;
    public TimeUnit DurationUnit { get; public set; }
    public TimeUnit RateUnit { get; public set; }
    public IEnumerable`1<double> Buckets { get; public set; }
    [CompilerGeneratedAttribute]
public TimeUnit get_DurationUnit();
    [CompilerGeneratedAttribute]
public void set_DurationUnit(TimeUnit value);
    [CompilerGeneratedAttribute]
public TimeUnit get_RateUnit();
    [CompilerGeneratedAttribute]
public void set_RateUnit(TimeUnit value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<double> get_Buckets();
    [CompilerGeneratedAttribute]
public void set_Buckets(IEnumerable`1<double> value);
}
public class App.Metrics.BucketTimer.BucketTimerValue : object {
    [CompilerGeneratedAttribute]
private long <ActiveSessions>k__BackingField;
    [CompilerGeneratedAttribute]
private BucketHistogramValue <Histogram>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterValue <Rate>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <DurationUnit>k__BackingField;
    public long ActiveSessions { get; }
    public BucketHistogramValue Histogram { get; }
    public MeterValue Rate { get; }
    public TimeUnit DurationUnit { get; }
    public BucketTimerValue(MeterValue rate, BucketHistogramValue histogram, long activeSessions, TimeUnit durationUnit);
    [CompilerGeneratedAttribute]
public long get_ActiveSessions();
    [CompilerGeneratedAttribute]
public BucketHistogramValue get_Histogram();
    [CompilerGeneratedAttribute]
public MeterValue get_Rate();
    [CompilerGeneratedAttribute]
public TimeUnit get_DurationUnit();
    public BucketTimerValue Scale(TimeUnit rate, TimeUnit duration);
}
public class App.Metrics.BucketTimer.BucketTimerValueSource : MetricValueSourceBase`1<BucketTimerValue> {
    [CompilerGeneratedAttribute]
private TimeUnit <DurationUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <RateUnit>k__BackingField;
    public TimeUnit DurationUnit { get; }
    public TimeUnit RateUnit { get; }
    public BucketTimerValueSource(string name, IMetricValueProvider`1<BucketTimerValue> value, Unit unit, TimeUnit rateUnit, TimeUnit durationUnit, MetricTags tags);
    [CompilerGeneratedAttribute]
public TimeUnit get_DurationUnit();
    [CompilerGeneratedAttribute]
public TimeUnit get_RateUnit();
}
public interface App.Metrics.BucketTimer.IBucketTimerMetric {
}
public interface App.Metrics.BucketTimer.IBuildBucketTimerMetrics {
    public abstract virtual IBucketTimerMetric Build(IBucketHistogramMetric histogram, IClock clock, TimeUnit timeUnit);
    public abstract virtual IBucketTimerMetric Build(IEnumerable`1<double> buckets, IClock clock, TimeUnit timeUnit);
    public abstract virtual IBucketTimerMetric Build(IBucketHistogramMetric histogram, IMeterMetric meter, IClock clock, TimeUnit timeUnit);
    public abstract virtual IBucketTimerMetric Build(IEnumerable`1<double> buckets, IMeterMetric meter, IClock clock, TimeUnit timeUnit);
}
public interface App.Metrics.BucketTimer.IMeasureBucketTimerMetrics {
    public abstract virtual void Time(BucketTimerOptions options, Action action);
    public abstract virtual void Time(BucketTimerOptions options, MetricTags tags, Action action);
    public abstract virtual void Time(BucketTimerOptions options, Action action, string userValue);
    public abstract virtual void Time(BucketTimerOptions options, MetricTags tags, Action action, string userValue);
    public abstract virtual TimerContext Time(BucketTimerOptions options, MetricTags tags, string userValue);
    public abstract virtual TimerContext Time(BucketTimerOptions options, string userValue);
    public abstract virtual TimerContext Time(BucketTimerOptions options, MetricTags tags);
    public abstract virtual TimerContext Time(BucketTimerOptions options);
}
public interface App.Metrics.BucketTimer.IProvideBucketTimerMetrics {
    public abstract virtual ITimer Instance(BucketTimerOptions options);
    public abstract virtual ITimer Instance(BucketTimerOptions options, MetricTags tags);
    public abstract virtual ITimer Instance(BucketTimerOptions options, Func`1<T> builder);
    public abstract virtual ITimer Instance(BucketTimerOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual ITimer WithHistogram(BucketTimerOptions options, Func`1<T> histogramMetricBuilder);
    public abstract virtual ITimer WithHistogram(BucketTimerOptions options, MetricTags tags, Func`1<T> histogramMetricBuilder);
}
public interface App.Metrics.Builder.IMetricsReportingBuilder {
    public IMetricsBuilder Builder { get; }
    public abstract virtual IMetricsBuilder get_Builder();
    public abstract virtual IMetricsBuilder Using(IReportMetrics reporter);
    public abstract virtual IMetricsBuilder Using();
    public abstract virtual IMetricsBuilder Using(IFilterMetrics filter);
    public abstract virtual IMetricsBuilder Using(IMetricsOutputFormatter formatter);
    public abstract virtual IMetricsBuilder Using(IFilterMetrics filter, TimeSpan flushInterval);
    public abstract virtual IMetricsBuilder Using(IMetricsOutputFormatter formatter, IFilterMetrics filter, TimeSpan flushInterval);
    public abstract virtual IMetricsBuilder Using(IMetricsOutputFormatter formatter, TimeSpan flushInterval);
    public abstract virtual IMetricsBuilder Using(TimeSpan flushInterval);
}
public static class App.Metrics.ConstantValue : object {
    public static IMetricValueProvider`1<T> Provider(T value);
}
public class App.Metrics.ContextualMetricTagProviders : Dictionary`2<string, Func`1<string>> {
    public ContextualMetricTagProviders(Dictionary`2<string, Func`1<string>> tagProviders);
    public Dictionary`2<string, string> ComputeTagValues();
}
public class App.Metrics.Counter.CounterOptions : MetricValueOptionsBase {
    [CompilerGeneratedAttribute]
private bool <ReportItemPercentages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportSetItems>k__BackingField;
    public bool ReportItemPercentages { get; public set; }
    public bool ReportSetItems { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ReportItemPercentages();
    [CompilerGeneratedAttribute]
public void set_ReportItemPercentages(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReportSetItems();
    [CompilerGeneratedAttribute]
public void set_ReportSetItems(bool value);
}
public class App.Metrics.Counter.CounterValue : ValueType {
    public static IComparer`1<SetItem> SetItemComparer;
    private static SetItem[] NoItems;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private SetItem[] <Items>k__BackingField;
    public long Count { get; }
    public SetItem[] Items { get; }
    public CounterValue(long count, SetItem[] items);
    internal CounterValue(long count);
    private static CounterValue();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Count();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SetItem[] get_Items();
    public static bool op_Equality(CounterValue left, CounterValue right);
    public static bool op_Inequality(CounterValue left, CounterValue right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(CounterValue other);
}
public class App.Metrics.Counter.CounterValueSource : MetricValueSourceBase`1<CounterValue> {
    [CompilerGeneratedAttribute]
private bool <ReportItemPercentages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportSetItems>k__BackingField;
    public bool ReportItemPercentages { get; }
    public bool ReportSetItems { get; }
    public CounterValueSource(string name, IMetricValueProvider`1<CounterValue> value, Unit unit, MetricTags tags, bool resetOnReporting, bool reportItemPercentages, bool reportSetItems);
    [CompilerGeneratedAttribute]
public bool get_ReportItemPercentages();
    [CompilerGeneratedAttribute]
public bool get_ReportSetItems();
}
public interface App.Metrics.Counter.IBuildCounterMetrics {
    public abstract virtual ICounterMetric Build();
    public abstract virtual ICounterMetric Build(Func`1<T> builder);
}
public interface App.Metrics.Counter.ICounter {
    public abstract virtual void Decrement();
    public abstract virtual void Decrement(string setItem);
    public abstract virtual void Decrement(MetricSetItem setItem);
    public abstract virtual void Decrement(long amount);
    public abstract virtual void Decrement(string setItem, long amount);
    public abstract virtual void Decrement(MetricSetItem setItem, long amount);
    public abstract virtual void Increment();
    public abstract virtual void Increment(string setItem);
    public abstract virtual void Increment(MetricSetItem setItem);
    public abstract virtual void Increment(long amount);
    public abstract virtual void Increment(string setItem, long amount);
    public abstract virtual void Increment(MetricSetItem setItem, long amount);
}
public interface App.Metrics.Counter.ICounterMetric {
}
public interface App.Metrics.Counter.IMeasureCounterMetrics {
    public abstract virtual void Decrement(CounterOptions options);
    public abstract virtual void Decrement(CounterOptions options, MetricTags tags);
    public abstract virtual void Decrement(CounterOptions options, long amount);
    public abstract virtual void Decrement(CounterOptions options, MetricTags tags, long amount);
    public abstract virtual void Decrement(CounterOptions options, string item);
    public abstract virtual void Decrement(CounterOptions options, MetricTags tags, string item);
    public abstract virtual void Decrement(CounterOptions options, long amount, string item);
    public abstract virtual void Decrement(CounterOptions options, MetricTags tags, long amount, string item);
    public abstract virtual void Decrement(CounterOptions options, MetricSetItem setItem);
    public abstract virtual void Decrement(CounterOptions options, long amount, MetricSetItem setItem);
    public abstract virtual void Increment(CounterOptions options);
    public abstract virtual void Increment(CounterOptions options, MetricTags tags);
    public abstract virtual void Increment(CounterOptions options, long amount);
    public abstract virtual void Increment(CounterOptions options, MetricTags tags, long amount);
    public abstract virtual void Increment(CounterOptions options, string item);
    public abstract virtual void Increment(CounterOptions options, MetricTags tags, string item);
    public abstract virtual void Increment(CounterOptions options, MetricTags tags, long amount, string item);
    public abstract virtual void Increment(CounterOptions options, long amount, string item);
    public abstract virtual void Increment(CounterOptions options, MetricSetItem setItem);
    public abstract virtual void Increment(CounterOptions options, long amount, MetricSetItem setItem);
}
public interface App.Metrics.Counter.IProvideCounterMetrics {
    public abstract virtual ICounter Instance(CounterOptions options);
    public abstract virtual ICounter Instance(CounterOptions options, Func`1<T> builder);
    public abstract virtual ICounter Instance(CounterOptions options, MetricTags tags);
    public abstract virtual ICounter Instance(CounterOptions options, MetricTags tags, Func`1<T> builder);
}
public enum App.Metrics.CounterFields : Enum {
    public int value__;
    public static CounterFields Total;
    public static CounterFields SetItemPercent;
    public static CounterFields SetItem;
    public static CounterFields Value;
}
internal static class App.Metrics.DefaultMetricFieldNames : object {
    public static string DefaultMetricsSetItemSuffix;
    public static IReadOnlyDictionary`2<ApdexFields, string> Apdex { get; }
    public static IReadOnlyDictionary`2<HistogramFields, string> Histogram { get; }
    public static IReadOnlyDictionary`2<BucketHistogramFields, string> BucketHistogram { get; }
    public static IReadOnlyDictionary`2<MeterFields, string> Meter { get; }
    public static IReadOnlyDictionary`2<CounterFields, string> Counter { get; }
    public static IReadOnlyDictionary`2<GaugeFields, string> Gauge { get; }
    private static DefaultMetricFieldNames();
    public static IReadOnlyDictionary`2<ApdexFields, string> get_Apdex();
    public static IReadOnlyDictionary`2<HistogramFields, string> get_Histogram();
    public static IReadOnlyDictionary`2<BucketHistogramFields, string> get_BucketHistogram();
    public static IReadOnlyDictionary`2<MeterFields, string> get_Meter();
    public static IReadOnlyDictionary`2<CounterFields, string> get_Counter();
    public static IReadOnlyDictionary`2<GaugeFields, string> get_Gauge();
}
public interface App.Metrics.Filters.IFilterMetrics {
    public abstract virtual bool IsApdexMatch(ApdexValueSource apdex);
    public abstract virtual bool IsCounterMatch(CounterValueSource counter);
    public abstract virtual bool IsGaugeMatch(GaugeValueSource gauge);
    public abstract virtual bool IsHistogramMatch(HistogramValueSource histogram);
    public abstract virtual bool IsBucketHistogramMatch(BucketHistogramValueSource histogram);
    public abstract virtual bool IsContextMatch(string context);
    public abstract virtual bool IsMeterMatch(MeterValueSource meter);
    public abstract virtual bool IsTimerMatch(TimerValueSource timer);
    public abstract virtual bool IsBucketTimerMatch(BucketTimerValueSource timer);
    public abstract virtual IFilterMetrics WhereContext(Predicate`1<string> condition);
    public abstract virtual IFilterMetrics WhereContext(string context);
    public abstract virtual IFilterMetrics WhereName(string name);
    public abstract virtual IFilterMetrics WhereName(Predicate`1<string> condition);
    public abstract virtual IFilterMetrics WhereNameStartsWith(string name);
    public abstract virtual IFilterMetrics WhereTaggedWithKey(String[] tagKeys);
    public abstract virtual IFilterMetrics WhereTaggedWithKeyValue(TagKeyValueFilter tags);
    public abstract virtual IFilterMetrics WhereType(MetricType[] types);
}
public class App.Metrics.Filters.TagKeyValueFilter : Dictionary`2<string, string> {
}
public static class App.Metrics.Formatters.AppMetricsFormattingConstants : object {
}
public class App.Metrics.Formatters.EnvFormatterCollection : Collection`1<IEnvOutputFormatter> {
    public EnvFormatterCollection(IList`1<IEnvOutputFormatter> list);
    public IEnvOutputFormatter GetType();
    public IEnvOutputFormatter GetType(Type formatterType);
    public IEnvOutputFormatter GetType(MetricsMediaTypeValue mediaTypeValue);
    public void RemoveType();
    public void RemoveType(Type formatterType);
    public void RemoveType(MetricsMediaTypeValue mediaTypeValue);
    public void TryAdd(IEnvOutputFormatter formatter);
    public void TryAdd(IEnvOutputFormatter formatter);
}
public interface App.Metrics.Formatters.IEnvOutputFormatter {
    public MetricsMediaTypeValue MediaType { get; }
    public abstract virtual MetricsMediaTypeValue get_MediaType();
    public abstract virtual Task WriteAsync(Stream output, EnvironmentInfo environmentInfo, CancellationToken cancellationToken);
}
public interface App.Metrics.Formatters.IMetricsChunkedOutputFormatter {
    public abstract virtual Task`1<List`1<string>> WriteAsync(MetricsDataValueSource metricsData, int maximumChunkSize, CancellationToken cancellationToken);
}
public interface App.Metrics.Formatters.IMetricsOutputFormatter {
    public MetricsMediaTypeValue MediaType { get; }
    public MetricFields MetricFields { get; public set; }
    public abstract virtual MetricsMediaTypeValue get_MediaType();
    public abstract virtual MetricFields get_MetricFields();
    public abstract virtual void set_MetricFields(MetricFields value);
    public abstract virtual Task WriteAsync(Stream output, MetricsDataValueSource metricsData, CancellationToken cancellationToken);
}
public class App.Metrics.Formatters.MetricsFormatterCollection : Collection`1<IMetricsOutputFormatter> {
    public MetricsFormatterCollection(IList`1<IMetricsOutputFormatter> list);
    public IMetricsOutputFormatter GetType();
    public IMetricsOutputFormatter GetType(Type formatterType);
    public IMetricsOutputFormatter GetType(MetricsMediaTypeValue mediaTypeValue);
    public void RemoveType();
    public void RemoveType(Type formatterType);
    public void RemoveType(MetricsMediaTypeValue mediaTypeValue);
    public void TryAdd(IMetricsOutputFormatter formatter);
    public void TryAdd(IMetricsOutputFormatter formatter);
}
[ExtensionAttribute]
public static class App.Metrics.Formatters.MetricsFormatterReadonlyCollectionExtensions : object {
    [ExtensionAttribute]
public static IMetricsOutputFormatter GetType(IReadOnlyCollection`1<IMetricsOutputFormatter> formatters);
    [ExtensionAttribute]
public static IMetricsOutputFormatter GetType(IReadOnlyCollection`1<IMetricsOutputFormatter> formatters, Type formatterType);
}
public class App.Metrics.Formatters.MetricsMediaTypeValue : ValueType {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string ContentType { get; }
    public string Format { get; }
    public string SubType { get; }
    public string Type { get; }
    public string Version { get; }
    public MetricsMediaTypeValue(string type, string subType, string version, string format);
    public string get_ContentType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Format();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_SubType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Type();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Version();
    public static bool op_Equality(MetricsMediaTypeValue left, MetricsMediaTypeValue right);
    public static bool op_Inequality(MetricsMediaTypeValue left, MetricsMediaTypeValue right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool Equals(MetricsMediaTypeValue other);
}
public class App.Metrics.Formatters.MetricsReporterCollection : Collection`1<IReportMetrics> {
    public MetricsReporterCollection(IList`1<IReportMetrics> list);
    public IReportMetrics GetType();
    public IReportMetrics GetType(Type reporterType);
    public void RemoveType();
    public void RemoveType(Type reporterType);
    public void TryAdd(IReportMetrics reporter);
    public void TryAdd(IReportMetrics reporter);
}
public class App.Metrics.Gauge.GaugeOptions : MetricValueOptionsBase {
}
public class App.Metrics.Gauge.GaugeValueSource : MetricValueSourceBase`1<double> {
    public GaugeValueSource(string name, IMetricValueProvider`1<double> value, Unit unit, MetricTags tags, bool restOnReporting);
}
public interface App.Metrics.Gauge.IBuildGaugeMetrics {
    public abstract virtual IGaugeMetric Build(Func`1<double> valueProvider);
    public abstract virtual IGaugeMetric Build(Func`1<IMetricValueProvider`1<double>> valueProvider);
    public abstract virtual IGaugeMetric Build();
    public abstract virtual IGaugeMetric Build(Func`1<T> builder);
}
public interface App.Metrics.Gauge.IGauge {
    public abstract virtual void SetValue(double value);
}
public interface App.Metrics.Gauge.IGaugeMetric {
}
public interface App.Metrics.Gauge.IMeasureGaugeMetrics {
    public abstract virtual void SetValue(GaugeOptions options, Func`1<double> valueProvider);
    public abstract virtual void SetValue(GaugeOptions options, double value);
    public abstract virtual void SetValue(GaugeOptions options, MetricTags tags, double value);
    public abstract virtual void SetValue(GaugeOptions options, Func`1<IMetricValueProvider`1<double>> valueProvider);
    public abstract virtual void SetValue(GaugeOptions options, MetricTags tags, Func`1<IMetricValueProvider`1<double>> valueProvider);
    public abstract virtual void SetValue(GaugeOptions options, MetricTags tags, Func`1<double> valueProvider);
}
public interface App.Metrics.Gauge.IProvideGaugeMetrics {
    public abstract virtual IGauge Instance(GaugeOptions options);
    public abstract virtual IGauge Instance(GaugeOptions options, MetricTags tags);
    public abstract virtual IGauge Instance(GaugeOptions options, Func`1<T> builder);
    public abstract virtual IGauge Instance(GaugeOptions options, MetricTags tags, Func`1<T> builder);
}
public enum App.Metrics.GaugeFields : Enum {
    public int value__;
    public static GaugeFields Value;
}
public class App.Metrics.GlobalMetricTags : Dictionary`2<string, string> {
    public GlobalMetricTags(Dictionary`2<string, string> tags);
}
public class App.Metrics.Histogram.HistogramOptions : MetricValueWithSamplingOption {
}
public class App.Metrics.Histogram.HistogramValue : object {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastUserValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LastValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MaxUserValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Median>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinUserValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Percentile75>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Percentile95>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Percentile98>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Percentile99>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Percentile999>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StdDev>k__BackingField;
    public long Count { get; }
    public double Sum { get; }
    public string LastUserValue { get; }
    public double LastValue { get; }
    public double Max { get; }
    public string MaxUserValue { get; }
    public double Mean { get; }
    public double Median { get; }
    public double Min { get; }
    public string MinUserValue { get; }
    public double Percentile75 { get; }
    public double Percentile95 { get; }
    public double Percentile98 { get; }
    public double Percentile99 { get; }
    public double Percentile999 { get; }
    public int SampleSize { get; }
    public double StdDev { get; }
    public HistogramValue(double lastValue, string lastUserValue, IReservoirSnapshot snapshot);
    public HistogramValue(long count, double sum, double lastValue, string lastUserValue, double max, string maxUserValue, double mean, double min, string minUserValue, double stdDev, double median, double percentile75, double percentile95, double percentile98, double percentile99, double percentile999, int sampleSize);
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public double get_Sum();
    [CompilerGeneratedAttribute]
public string get_LastUserValue();
    [CompilerGeneratedAttribute]
public double get_LastValue();
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
public string get_MaxUserValue();
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
public double get_Median();
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
public string get_MinUserValue();
    [CompilerGeneratedAttribute]
public double get_Percentile75();
    [CompilerGeneratedAttribute]
public double get_Percentile95();
    [CompilerGeneratedAttribute]
public double get_Percentile98();
    [CompilerGeneratedAttribute]
public double get_Percentile99();
    [CompilerGeneratedAttribute]
public double get_Percentile999();
    [CompilerGeneratedAttribute]
public int get_SampleSize();
    [CompilerGeneratedAttribute]
public double get_StdDev();
    public HistogramValue Scale(double factor);
}
public class App.Metrics.Histogram.HistogramValueSource : MetricValueSourceBase`1<HistogramValue> {
    public HistogramValueSource(string name, IMetricValueProvider`1<HistogramValue> valueProvider, Unit unit, MetricTags tags, bool restOnReporting);
}
public interface App.Metrics.Histogram.IBuildHistogramMetrics {
    public abstract virtual IHistogramMetric Build(Func`1<IReservoir> setupReservoir);
}
public interface App.Metrics.Histogram.IHistogram {
    public abstract virtual void Update(long value, string userValue);
    public abstract virtual void Update(long value);
}
public interface App.Metrics.Histogram.IHistogramMetric {
}
public interface App.Metrics.Histogram.IMeasureHistogramMetrics {
    public abstract virtual void Update(HistogramOptions options, long value);
    public abstract virtual void Update(HistogramOptions options, MetricTags tags, long value);
    public abstract virtual void Update(HistogramOptions options, long value, string userValue);
    public abstract virtual void Update(HistogramOptions options, MetricTags tags, long value, string userValue);
}
public interface App.Metrics.Histogram.IProvideHistogramMetrics {
    public abstract virtual IHistogram Instance(HistogramOptions options);
    public abstract virtual IHistogram Instance(HistogramOptions options, Func`1<T> builder);
    public abstract virtual IHistogram Instance(HistogramOptions options, MetricTags tags);
    public abstract virtual IHistogram Instance(HistogramOptions options, MetricTags tags, Func`1<T> builder);
}
public enum App.Metrics.HistogramFields : Enum {
    public int value__;
    public static HistogramFields Samples;
    public static HistogramFields LastValue;
    public static HistogramFields Count;
    public static HistogramFields Sum;
    public static HistogramFields Min;
    public static HistogramFields Max;
    public static HistogramFields Mean;
    public static HistogramFields Median;
    public static HistogramFields StdDev;
    public static HistogramFields P999;
    public static HistogramFields P99;
    public static HistogramFields P98;
    public static HistogramFields P95;
    public static HistogramFields P75;
    public static HistogramFields UserLastValue;
    public static HistogramFields UserMinValue;
    public static HistogramFields UserMaxValue;
}
public interface App.Metrics.IBuildMetrics {
    public IBuildApdexMetrics Apdex { get; }
    public IBuildCounterMetrics Counter { get; }
    public IBuildGaugeMetrics Gauge { get; }
    public IBuildHistogramMetrics Histogram { get; }
    public IBuildBucketHistogramMetrics BucketHistogram { get; }
    public IBuildMeterMetrics Meter { get; }
    public IBuildTimerMetrics Timer { get; }
    public IBuildBucketTimerMetrics BucketTimer { get; }
    public abstract virtual IBuildApdexMetrics get_Apdex();
    public abstract virtual IBuildCounterMetrics get_Counter();
    public abstract virtual IBuildGaugeMetrics get_Gauge();
    public abstract virtual IBuildHistogramMetrics get_Histogram();
    public abstract virtual IBuildBucketHistogramMetrics get_BucketHistogram();
    public abstract virtual IBuildMeterMetrics get_Meter();
    public abstract virtual IBuildTimerMetrics get_Timer();
    public abstract virtual IBuildBucketTimerMetrics get_BucketTimer();
}
public interface App.Metrics.IClock {
    public long Nanoseconds { get; }
    public long Seconds { get; }
    public DateTime UtcDateTime { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Advanced(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Advanced(EventHandler value);
    public abstract virtual long get_Nanoseconds();
    public abstract virtual long get_Seconds();
    public abstract virtual DateTime get_UtcDateTime();
    public abstract virtual void Advance(TimeUnit unit, long value);
    public abstract virtual string FormatTimestamp(DateTime timestamp);
}
public interface App.Metrics.IEnvOutputFormattingBuilder {
    public IMetricsBuilder Builder { get; }
    public abstract virtual IMetricsBuilder get_Builder();
    public abstract virtual IMetricsBuilder Using(IEnvOutputFormatter formatter);
    public abstract virtual IMetricsBuilder Using();
}
public interface App.Metrics.IManageMetrics {
    public abstract virtual void Disable();
    public abstract virtual void Reset();
    public abstract virtual void ShutdownContext(string context);
}
public interface App.Metrics.IMeasureMetrics {
    public IMeasureApdexMetrics Apdex { get; }
    public IMeasureCounterMetrics Counter { get; }
    public IMeasureGaugeMetrics Gauge { get; }
    public IMeasureHistogramMetrics Histogram { get; }
    public IMeasureBucketHistogramMetrics BucketHistogram { get; }
    public IMeasureMeterMetrics Meter { get; }
    public IMeasureTimerMetrics Timer { get; }
    public IMeasureBucketTimerMetrics BucketTimer { get; }
    public abstract virtual IMeasureApdexMetrics get_Apdex();
    public abstract virtual IMeasureCounterMetrics get_Counter();
    public abstract virtual IMeasureGaugeMetrics get_Gauge();
    public abstract virtual IMeasureHistogramMetrics get_Histogram();
    public abstract virtual IMeasureBucketHistogramMetrics get_BucketHistogram();
    public abstract virtual IMeasureMeterMetrics get_Meter();
    public abstract virtual IMeasureTimerMetrics get_Timer();
    public abstract virtual IMeasureBucketTimerMetrics get_BucketTimer();
}
public interface App.Metrics.IMetricFieldsBuilder {
    public IMetricsBuilder Builder { get; }
    public abstract virtual IMetricsBuilder get_Builder();
    public abstract virtual IMetricsBuilder Configure(Action`1<MetricFields> setupFields);
}
public interface App.Metrics.IMetrics {
    public IBuildMetrics Build { get; }
    public IClock Clock { get; }
    public IFilterMetrics Filter { get; }
    public IManageMetrics Manage { get; }
    public IMeasureMetrics Measure { get; }
    public IProvideMetrics Provider { get; }
    public IProvideMetricValues Snapshot { get; }
    public abstract virtual IBuildMetrics get_Build();
    public abstract virtual IClock get_Clock();
    public abstract virtual IFilterMetrics get_Filter();
    public abstract virtual IManageMetrics get_Manage();
    public abstract virtual IMeasureMetrics get_Measure();
    public abstract virtual IProvideMetrics get_Provider();
    public abstract virtual IProvideMetricValues get_Snapshot();
}
public interface App.Metrics.IMetricsBuilder {
    public IMetricsFilterBuilder Filter { get; }
    public IMetricsConfigurationBuilder Configuration { get; }
    public IMetricFieldsBuilder MetricFields { get; }
    public IEnvOutputFormattingBuilder OutputEnvInfo { get; }
    public IMetricsReportingBuilder Report { get; }
    public IMetricsOutputFormattingBuilder OutputMetrics { get; }
    public IMetricsReservoirSamplingBuilder SampleWith { get; }
    public IMetricsClockBuilder TimeWith { get; }
    public abstract virtual IMetricsFilterBuilder get_Filter();
    public abstract virtual IMetricsConfigurationBuilder get_Configuration();
    public abstract virtual bool CanReport();
    public abstract virtual IMetricFieldsBuilder get_MetricFields();
    public abstract virtual IEnvOutputFormattingBuilder get_OutputEnvInfo();
    public abstract virtual IMetricsReportingBuilder get_Report();
    public abstract virtual IMetricsOutputFormattingBuilder get_OutputMetrics();
    public abstract virtual IMetricsReservoirSamplingBuilder get_SampleWith();
    public abstract virtual IMetricsClockBuilder get_TimeWith();
    public abstract virtual IMetricsRoot Build();
}
public interface App.Metrics.IMetricsClockBuilder {
    public IMetricsBuilder Builder { get; }
    public abstract virtual IMetricsBuilder get_Builder();
    public abstract virtual IMetricsBuilder Clock(IClock clock);
    public abstract virtual IMetricsBuilder Clock();
    public abstract virtual IMetricsBuilder StopwatchClock();
    public abstract virtual IMetricsBuilder SystemClock();
}
public interface App.Metrics.IMetricsConfigurationBuilder {
    public IMetricsBuilder Builder { get; }
    public abstract virtual IMetricsBuilder get_Builder();
    public abstract virtual IMetricsBuilder Configure(MetricsOptions options);
    public abstract virtual IMetricsBuilder Configure(IEnumerable`1<KeyValuePair`2<string, string>> optionValues);
    public abstract virtual IMetricsBuilder Configure(MetricsOptions options, IEnumerable`1<KeyValuePair`2<string, string>> optionValues);
    public abstract virtual IMetricsBuilder Configure(Action`1<MetricsOptions> setupAction);
    public abstract virtual IMetricsBuilder Extend(MetricsOptions options);
    public abstract virtual IMetricsBuilder Extend(IEnumerable`1<KeyValuePair`2<string, string>> optionValues);
}
public interface App.Metrics.IMetricsFilterBuilder {
    public IMetricsBuilder Builder { get; }
    public abstract virtual IMetricsBuilder get_Builder();
    public abstract virtual IMetricsBuilder ByIncludingOnlyContext(string context);
    public abstract virtual IMetricsBuilder ByIncludingOnlyTagKeyValues(TagKeyValueFilter tagKeyValues);
    public abstract virtual IMetricsBuilder ByIncludingOnlyTags(String[] tagKeys);
    public abstract virtual IMetricsBuilder ByIncludingOnlyTypes(MetricType[] types);
    public abstract virtual IMetricsBuilder With(IFilterMetrics filter);
    public abstract virtual IMetricsBuilder With(Action`1<IFilterMetrics> setupAction);
}
public interface App.Metrics.IMetricsOutputFormattingBuilder {
    public IMetricsBuilder Builder { get; }
    public abstract virtual IMetricsBuilder get_Builder();
    public abstract virtual IMetricsBuilder Using(IMetricsOutputFormatter formatter);
    public abstract virtual IMetricsBuilder Using(MetricFields fields);
    public abstract virtual IMetricsBuilder Using(IMetricsOutputFormatter formatter, bool replaceExisting);
    public abstract virtual IMetricsBuilder Using(bool replaceExisting, MetricFields fields);
}
public interface App.Metrics.IMetricsReservoirSamplingBuilder {
    public IMetricsBuilder Builder { get; }
    public abstract virtual IMetricsBuilder get_Builder();
    public abstract virtual IMetricsBuilder AlgorithmR(int sampleSize);
    public abstract virtual IMetricsBuilder AlgorithmR();
    public abstract virtual IMetricsBuilder ForwardDecaying(int sampleSize, double alpha);
    public abstract virtual IMetricsBuilder ForwardDecaying(int sampleSize, double alpha, double minimumSampleWeight);
    public abstract virtual IMetricsBuilder ForwardDecaying(int sampleSize, double alpha, double minimumSampleWeight, IClock clock);
    public abstract virtual IMetricsBuilder ForwardDecaying(int sampleSize, double alpha, double minimumSampleWeight, IClock clock, IReservoirRescaleScheduler rescaleScheduler);
    public abstract virtual IMetricsBuilder ForwardDecaying(double alpha, TimeSpan rescalePeriod);
    public abstract virtual IMetricsBuilder ForwardDecaying(TimeSpan rescalePeriod);
    public abstract virtual IMetricsBuilder ForwardDecaying();
    public abstract virtual IMetricsBuilder Reservoir(Func`1<IReservoir> reservoirBuilder);
    public abstract virtual IMetricsBuilder Reservoir();
    public abstract virtual IMetricsBuilder SlidingWindow(int sampleSize);
    public abstract virtual IMetricsBuilder SlidingWindow();
}
public interface App.Metrics.IMetricsRoot {
    public IReadOnlyCollection`1<IMetricsOutputFormatter> OutputMetricsFormatters { get; }
    public IMetricsOutputFormatter DefaultOutputMetricsFormatter { get; }
    public IEnvOutputFormatter DefaultOutputEnvFormatter { get; }
    public IReadOnlyCollection`1<IEnvOutputFormatter> OutputEnvFormatters { get; }
    public IReadOnlyCollection`1<IReportMetrics> Reporters { get; }
    public IRunMetricsReports ReportRunner { get; }
    public MetricsOptions Options { get; }
    public EnvironmentInfo EnvironmentInfo { get; }
    public abstract virtual IReadOnlyCollection`1<IMetricsOutputFormatter> get_OutputMetricsFormatters();
    public abstract virtual IMetricsOutputFormatter get_DefaultOutputMetricsFormatter();
    public abstract virtual IEnvOutputFormatter get_DefaultOutputEnvFormatter();
    public abstract virtual IReadOnlyCollection`1<IEnvOutputFormatter> get_OutputEnvFormatters();
    public abstract virtual IReadOnlyCollection`1<IReportMetrics> get_Reporters();
    public abstract virtual IRunMetricsReports get_ReportRunner();
    public abstract virtual MetricsOptions get_Options();
    public abstract virtual EnvironmentInfo get_EnvironmentInfo();
}
public interface App.Metrics.IMetricValueProvider`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
    public abstract virtual T GetValue(bool resetMetric);
}
public class App.Metrics.Infrastructure.EnvironmentInfo : ValueType {
    public static EnvironmentInfo Empty;
    private IEnumerable`1<EnvironmentInfoEntry> _entries;
    [CompilerGeneratedAttribute]
private string <RunningEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryAssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalTimeString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperatingSystemArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperatingSystemPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessorCount>k__BackingField;
    public IEnumerable`1<EnvironmentInfoEntry> Entries { get; }
    public string RunningEnvironment { get; }
    public string EntryAssemblyName { get; }
    public string EntryAssemblyVersion { get; }
    public string FrameworkDescription { get; }
    public string LocalTimeString { get; }
    public string MachineName { get; }
    public string OperatingSystemArchitecture { get; }
    public string OperatingSystemPlatform { get; }
    public string OperatingSystemVersion { get; }
    public string ProcessArchitecture { get; }
    public string ProcessorCount { get; }
    public EnvironmentInfo(IDictionary`2<string, string> entries);
    public EnvironmentInfo(string runningEnvironment, string frameworkDescription, string entryAssemblyName, string entryAssemblyVersion, string localTimeString, string machineName, string operatingSystemPlatform, string operatingSystemVersion, string operatingSystemArchitecture, string processArchitecture, string processorCount);
    private static EnvironmentInfo();
    public IEnumerable`1<EnvironmentInfoEntry> get_Entries();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_RunningEnvironment();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_EntryAssemblyName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_EntryAssemblyVersion();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FrameworkDescription();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_LocalTimeString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_MachineName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OperatingSystemArchitecture();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OperatingSystemPlatform();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OperatingSystemVersion();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ProcessArchitecture();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ProcessorCount();
    public static bool op_Equality(EnvironmentInfo left, EnvironmentInfo right);
    public static bool op_Inequality(EnvironmentInfo left, EnvironmentInfo right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EnvironmentInfo other);
}
public class App.Metrics.Infrastructure.EnvironmentInfoEntry : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; }
    public string Value { get; }
    public EnvironmentInfoEntry(string name, string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    public static bool op_Equality(EnvironmentInfoEntry left, EnvironmentInfoEntry right);
    public static bool op_Inequality(EnvironmentInfoEntry left, EnvironmentInfoEntry right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EnvironmentInfoEntry other);
}
public static class App.Metrics.Internal.AppMetricsTaskHelper : object {
    private static Task _completedTask;
    public static Task CompletedTask();
}
internal class App.Metrics.Internal.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public static int op_Implicit(HashCodeCombiner self);
    public static HashCodeCombiner Start();
    public void Add(IEnumerable e);
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
}
public interface App.Metrics.Internal.IHideObjectMembers {
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
}
internal interface App.Metrics.Internal.IMetricsTaskSchedular {
    public abstract virtual void Start(TimeSpan interval);
    public abstract virtual void SetTaskSource(Func`2<CancellationToken, Task> onTick);
}
internal static class App.Metrics.Internal.StringBuilderCache : object {
    private static int MaxBuilderSize;
    [ThreadStaticAttribute]
private static StringBuilder _cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static string GetStringAndRelease(StringBuilder sb);
    public static void Release(StringBuilder sb);
}
public interface App.Metrics.IProvideMetrics {
    public IProvideApdexMetrics Apdex { get; }
    public IProvideCounterMetrics Counter { get; }
    public IProvideGaugeMetrics Gauge { get; }
    public IProvideHistogramMetrics Histogram { get; }
    public IProvideMeterMetrics Meter { get; }
    public IProvideTimerMetrics Timer { get; }
    public IProvideBucketTimerMetrics BucketTimer { get; }
    public abstract virtual IProvideApdexMetrics get_Apdex();
    public abstract virtual IProvideCounterMetrics get_Counter();
    public abstract virtual IProvideGaugeMetrics get_Gauge();
    public abstract virtual IProvideHistogramMetrics get_Histogram();
    public abstract virtual IProvideMeterMetrics get_Meter();
    public abstract virtual IProvideTimerMetrics get_Timer();
    public abstract virtual IProvideBucketTimerMetrics get_BucketTimer();
}
public interface App.Metrics.IProvideMetricValues {
    public abstract virtual MetricsDataValueSource Get();
    public abstract virtual MetricsDataValueSource Get(IFilterMetrics overrideGlobalFilter);
    public abstract virtual MetricsContextValueSource GetForContext(string context);
}
public interface App.Metrics.IResetableMetric {
    public abstract virtual void Reset();
}
public interface App.Metrics.Meter.IBuildMeterMetrics {
    public abstract virtual IMeterMetric Build(IClock clock);
}
public interface App.Metrics.Meter.IMeasureMeterMetrics {
    public abstract virtual void Mark(MeterOptions options);
    public abstract virtual void Mark(MeterOptions options, long amount);
    public abstract virtual void Mark(MeterOptions options, MetricTags tags, long amount);
    public abstract virtual void Mark(MeterOptions options, MetricTags tags);
    public abstract virtual void Mark(MeterOptions options, string item);
    public abstract virtual void Mark(MeterOptions options, MetricTags tags, string item);
    public abstract virtual void Mark(MeterOptions options, MetricSetItem setItem);
    public abstract virtual void Mark(MeterOptions options, MetricTags tags, MetricSetItem setItem);
    public abstract virtual void Mark(MeterOptions options, long amount, string item);
    public abstract virtual void Mark(MeterOptions options, MetricTags tags, long amount, string item);
    public abstract virtual void Mark(MeterOptions options, long amount, MetricSetItem setItem);
    public abstract virtual void Mark(MeterOptions options, MetricTags tags, long amount, MetricSetItem setItem);
}
public interface App.Metrics.Meter.IMeter {
    public abstract virtual void Mark();
    public abstract virtual void Mark(string item);
    public abstract virtual void Mark(MetricSetItem setItem);
    public abstract virtual void Mark(MetricSetItem setItem, long amount);
    public abstract virtual void Mark(long amount);
    public abstract virtual void Mark(string item, long amount);
}
public interface App.Metrics.Meter.IMeterMetric {
}
public interface App.Metrics.Meter.IProvideMeterMetrics {
    public abstract virtual IMeter Instance(MeterOptions options);
    public abstract virtual IMeter Instance(MeterOptions options, Func`1<T> builder);
    public abstract virtual IMeter Instance(MeterOptions options, MetricTags tags);
    public abstract virtual IMeter Instance(MeterOptions options, MetricTags tags, Func`1<T> builder);
}
public interface App.Metrics.Meter.ITickingMeter {
    public abstract virtual void Tick();
}
public class App.Metrics.Meter.MeterOptions : MetricValueOptionsBase {
    [CompilerGeneratedAttribute]
private TimeUnit <RateUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportSetItems>k__BackingField;
    public TimeUnit RateUnit { get; public set; }
    public bool ReportSetItems { get; public set; }
    [CompilerGeneratedAttribute]
public TimeUnit get_RateUnit();
    [CompilerGeneratedAttribute]
public void set_RateUnit(TimeUnit value);
    [CompilerGeneratedAttribute]
public bool get_ReportSetItems();
    [CompilerGeneratedAttribute]
public void set_ReportSetItems(bool value);
}
public class App.Metrics.Meter.MeterValue : object {
    public static IComparer`1<SetItem> SetItemComparer;
    private static SetItem[] NoItems;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FifteenMinuteRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FiveMinuteRate>k__BackingField;
    [CompilerGeneratedAttribute]
private SetItem[] <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MeanRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OneMinuteRate>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <RateUnit>k__BackingField;
    public long Count { get; }
    public double FifteenMinuteRate { get; }
    public double FiveMinuteRate { get; }
    public SetItem[] Items { get; }
    public double MeanRate { get; }
    public double OneMinuteRate { get; }
    public TimeUnit RateUnit { get; }
    public MeterValue(long count, double meanRate, double oneMinuteRate, double fiveMinuteRate, double fifteenMinuteRate, TimeUnit rateUnit, SetItem[] items);
    public MeterValue(long count, double meanRate, double oneMinuteRate, double fiveMinuteRate, double fifteenMinuteRate, TimeUnit rateUnit);
    private static MeterValue();
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public double get_FifteenMinuteRate();
    [CompilerGeneratedAttribute]
public double get_FiveMinuteRate();
    [CompilerGeneratedAttribute]
public SetItem[] get_Items();
    [CompilerGeneratedAttribute]
public double get_MeanRate();
    [CompilerGeneratedAttribute]
public double get_OneMinuteRate();
    [CompilerGeneratedAttribute]
public TimeUnit get_RateUnit();
    public MeterValue Scale(TimeUnit unit);
}
public class App.Metrics.Meter.MeterValueSource : MetricValueSourceBase`1<MeterValue> {
    [CompilerGeneratedAttribute]
private TimeUnit <RateUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportSetItems>k__BackingField;
    public TimeUnit RateUnit { get; }
    public bool ReportSetItems { get; }
    public MeterValueSource(string name, IMetricValueProvider`1<MeterValue> value, Unit unit, TimeUnit rateUnit, MetricTags tags, bool resetOnReporting, bool reportSetItems);
    [CompilerGeneratedAttribute]
public TimeUnit get_RateUnit();
    [CompilerGeneratedAttribute]
public bool get_ReportSetItems();
}
public enum App.Metrics.MeterFields : Enum {
    public int value__;
    public static MeterFields Count;
    public static MeterFields Rate1M;
    public static MeterFields Rate5M;
    public static MeterFields Rate15M;
    public static MeterFields RateMean;
    public static MeterFields SetItem;
    public static MeterFields SetItemPercent;
}
[ExtensionAttribute]
public static class App.Metrics.MetricContextValueSourceEnumerableExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<MetricsContextValueSource> FilterBy(IEnumerable`1<MetricsContextValueSource> valueSources, IFilterMetrics filter);
    [ExtensionAttribute]
public static IEnumerable`1<MetricsContextValueSource> WhereNotEmpty(IEnumerable`1<MetricsContextValueSource> valueSources);
}
public class App.Metrics.MetricFields : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<ApdexFields, string> <Apdex>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<CounterFields, string> <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<GaugeFields, string> <Gauge>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<HistogramFields, string> <Histogram>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<BucketHistogramFields, string> <BucketHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<MeterFields, string> <Meter>k__BackingField;
    public IDictionary`2<ApdexFields, string> Apdex { get; }
    public IDictionary`2<CounterFields, string> Counter { get; }
    public IDictionary`2<GaugeFields, string> Gauge { get; }
    public IDictionary`2<HistogramFields, string> Histogram { get; }
    public IDictionary`2<BucketHistogramFields, string> BucketHistogram { get; }
    public IDictionary`2<MeterFields, string> Meter { get; }
    [CompilerGeneratedAttribute]
public IDictionary`2<ApdexFields, string> get_Apdex();
    [CompilerGeneratedAttribute]
public IDictionary`2<CounterFields, string> get_Counter();
    [CompilerGeneratedAttribute]
public IDictionary`2<GaugeFields, string> get_Gauge();
    [CompilerGeneratedAttribute]
public IDictionary`2<HistogramFields, string> get_Histogram();
    [CompilerGeneratedAttribute]
public IDictionary`2<BucketHistogramFields, string> get_BucketHistogram();
    [CompilerGeneratedAttribute]
public IDictionary`2<MeterFields, string> get_Meter();
}
public class App.Metrics.MetricsContextValueSource : object {
    public static MetricsContextValueSource Empty;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ApdexValueSource> <ApdexScores>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CounterValueSource> <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<GaugeValueSource> <Gauges>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<HistogramValueSource> <Histograms>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<BucketHistogramValueSource> <BucketHistograms>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MeterValueSource> <Meters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TimerValueSource> <Timers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<BucketTimerValueSource> <BucketTimers>k__BackingField;
    public IEnumerable`1<ApdexValueSource> ApdexScores { get; }
    public string Context { get; }
    public IEnumerable`1<CounterValueSource> Counters { get; }
    public IEnumerable`1<GaugeValueSource> Gauges { get; }
    public IEnumerable`1<HistogramValueSource> Histograms { get; }
    public IEnumerable`1<BucketHistogramValueSource> BucketHistograms { get; }
    public IEnumerable`1<MeterValueSource> Meters { get; }
    public IEnumerable`1<TimerValueSource> Timers { get; }
    public IEnumerable`1<BucketTimerValueSource> BucketTimers { get; }
    public MetricsContextValueSource(string context, IEnumerable`1<GaugeValueSource> gauges, IEnumerable`1<CounterValueSource> counters, IEnumerable`1<MeterValueSource> meters, IEnumerable`1<HistogramValueSource> histograms, IEnumerable`1<BucketHistogramValueSource> bucketHistograms, IEnumerable`1<TimerValueSource> timers, IEnumerable`1<BucketTimerValueSource> bucketTimers, IEnumerable`1<ApdexValueSource> apdexScores);
    private static MetricsContextValueSource();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ApdexValueSource> get_ApdexScores();
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CounterValueSource> get_Counters();
    [CompilerGeneratedAttribute]
public IEnumerable`1<GaugeValueSource> get_Gauges();
    [CompilerGeneratedAttribute]
public IEnumerable`1<HistogramValueSource> get_Histograms();
    [CompilerGeneratedAttribute]
public IEnumerable`1<BucketHistogramValueSource> get_BucketHistograms();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MeterValueSource> get_Meters();
    [CompilerGeneratedAttribute]
public IEnumerable`1<TimerValueSource> get_Timers();
    [CompilerGeneratedAttribute]
public IEnumerable`1<BucketTimerValueSource> get_BucketTimers();
    public MetricsContextValueSource Filter(IFilterMetrics filter);
    public bool IsNotEmpty();
}
public class App.Metrics.MetricsDataValueSource : object {
    public static MetricsDataValueSource Empty;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MetricsContextValueSource> <Contexts>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    public IEnumerable`1<MetricsContextValueSource> Contexts { get; }
    public DateTime Timestamp { get; }
    public MetricsDataValueSource(DateTime timestamp, IEnumerable`1<MetricsContextValueSource> contexts);
    private static MetricsDataValueSource();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MetricsContextValueSource> get_Contexts();
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    public MetricsDataValueSource Filter(IFilterMetrics filter);
}
public class App.Metrics.MetricSetItem : ValueType {
    private string _key;
    private String[] _keys;
    private string _value;
    private String[] _values;
    private static String[] EmptyArray;
    public static MetricSetItem Empty;
    public int Count { get; }
    public MetricSetItem(string key, string value);
    public MetricSetItem(String[] keys, String[] values);
    private static MetricSetItem();
    public int get_Count();
    public static bool Equals(MetricSetItem left, MetricSetItem right);
    public static bool op_Equality(MetricSetItem left, MetricSetItem right);
    public static bool op_Inequality(MetricSetItem left, MetricSetItem right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(MetricSetItem other);
}
public class App.Metrics.MetricsOptions : object {
    private static string DefaultContext;
    [CompilerGeneratedAttribute]
private string <DefaultContextLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private GlobalMetricTags <GlobalTags>k__BackingField;
    [CompilerGeneratedAttribute]
private ContextualMetricTagProviders <ContextualTags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportingEnabled>k__BackingField;
    public string DefaultContextLabel { get; public set; }
    public GlobalMetricTags GlobalTags { get; public set; }
    public ContextualMetricTagProviders ContextualTags { get; public set; }
    public bool Enabled { get; public set; }
    public bool ReportingEnabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultContextLabel();
    [CompilerGeneratedAttribute]
public void set_DefaultContextLabel(string value);
    [CompilerGeneratedAttribute]
public GlobalMetricTags get_GlobalTags();
    [CompilerGeneratedAttribute]
public void set_GlobalTags(GlobalMetricTags value);
    [CompilerGeneratedAttribute]
public ContextualMetricTagProviders get_ContextualTags();
    [CompilerGeneratedAttribute]
public void set_ContextualTags(ContextualMetricTagProviders value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReportingEnabled();
    [CompilerGeneratedAttribute]
public void set_ReportingEnabled(bool value);
}
[ExtensionAttribute]
public static class App.Metrics.MetricTagExtensions : object {
    [ExtensionAttribute]
public static MetricTags FromDictionary(Dictionary`2<string, string> source);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToDictionary(MetricTags source, Func`2<string, string> tagValueFormatter);
}
public class App.Metrics.MetricTags : ValueType {
    private string _key;
    private String[] _keys;
    private string _value;
    private String[] _values;
    private static String[] EmptyArray;
    public static MetricTags Empty;
    public int Count { get; }
    public String[] Keys { get; }
    public String[] Values { get; }
    public MetricTags(string key, string value);
    public MetricTags(String[] keys, String[] values);
    private static MetricTags();
    public int get_Count();
    public String[] get_Keys();
    public String[] get_Values();
    public static MetricTags Concat(MetricTags tags1, MetricTags tags2);
    public static MetricTags Concat(MetricTags tags1, Dictionary`2<string, string> tags2);
    public static bool Equals(MetricTags left, MetricTags right);
    public static MetricTags FromSetItemString(string setItem);
    public static bool op_Equality(MetricTags left, MetricTags right);
    public static bool op_Inequality(MetricTags left, MetricTags right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string AsMetricName(string metricName);
    public sealed virtual bool Equals(MetricTags other);
}
public enum App.Metrics.MetricType : Enum {
    public int value__;
    public static MetricType Gauge;
    public static MetricType Counter;
    public static MetricType Meter;
    public static MetricType Histogram;
    public static MetricType BucketHistogram;
    public static MetricType Timer;
    public static MetricType BucketTimer;
    public static MetricType Apdex;
}
[ExtensionAttribute]
public static class App.Metrics.MetricValueExtensions : object {
    [ExtensionAttribute]
public static void AddApdexValues(ApdexValue apdex, IDictionary`2<string, object> values, IDictionary`2<ApdexFields, string> fields);
    [ExtensionAttribute]
public static void AddHistogramValues(HistogramValue histogram, IDictionary`2<string, object> values, IDictionary`2<HistogramFields, string> fields);
    [ExtensionAttribute]
public static void AddBucketHistogramValues(BucketHistogramValue histogram, IDictionary`2<string, object> values, IDictionary`2<string, string> fields);
    [ExtensionAttribute]
public static void AddBucketTimerValues(BucketTimerValue timer, IDictionary`2<string, object> values, IDictionary`2<string, string> fields);
    [ExtensionAttribute]
public static void AddMeterSetItemValues(SetItem meterSetItem, IDictionary`2<string, object> values, IDictionary`2<MeterFields, string> fields);
    [ExtensionAttribute]
public static void AddMeterValues(MeterValue meter, IDictionary`2<string, object> values, IDictionary`2<MeterFields, string> fields);
}
public abstract class App.Metrics.MetricValueOptionsBase : object {
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Unit <MeasurementUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetOnReporting>k__BackingField;
    public string Context { get; public set; }
    public Unit MeasurementUnit { get; public set; }
    public string Name { get; public set; }
    public MetricTags Tags { get; public set; }
    public bool ResetOnReporting { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    [CompilerGeneratedAttribute]
public Unit get_MeasurementUnit();
    [CompilerGeneratedAttribute]
public void set_MeasurementUnit(Unit value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public MetricTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(MetricTags value);
    [CompilerGeneratedAttribute]
public bool get_ResetOnReporting();
    [CompilerGeneratedAttribute]
public void set_ResetOnReporting(bool value);
}
public abstract class App.Metrics.MetricValueSourceBase`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsMultidimensional>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MultidimensionalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Unit <Unit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetOnReporting>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetricValueProvider`1<T> <ValueProvider>k__BackingField;
    public bool IsMultidimensional { get; }
    public string MultidimensionalName { get; }
    public string Name { get; }
    public MetricTags Tags { get; }
    public Unit Unit { get; }
    public bool ResetOnReporting { get; }
    public T Value { get; }
    public IMetricValueProvider`1<T> ValueProvider { get; }
    protected MetricValueSourceBase`1(string name, IMetricValueProvider`1<T> valueProvider, Unit unit, MetricTags tags, bool resetOnReporting);
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensional();
    [CompilerGeneratedAttribute]
public string get_MultidimensionalName();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public MetricTags get_Tags();
    [CompilerGeneratedAttribute]
public Unit get_Unit();
    [CompilerGeneratedAttribute]
public bool get_ResetOnReporting();
    public T get_Value();
    [CompilerGeneratedAttribute]
public IMetricValueProvider`1<T> get_ValueProvider();
}
public abstract class App.Metrics.MetricValueWithSamplingOption : MetricValueOptionsBase {
    [CompilerGeneratedAttribute]
private Func`1<IReservoir> <Reservoir>k__BackingField;
    public Func`1<IReservoir> Reservoir { get; public set; }
    [CompilerGeneratedAttribute]
public Func`1<IReservoir> get_Reservoir();
    [CompilerGeneratedAttribute]
public void set_Reservoir(Func`1<IReservoir> value);
}
public interface App.Metrics.Registry.IMetricContextRegistry {
    public string Context { get; }
    public IMetricRegistryManager DataProvider { get; }
    public abstract virtual string get_Context();
    public abstract virtual IMetricRegistryManager get_DataProvider();
    public abstract virtual IApdex Apdex(ApdexOptions options, Func`1<T> builder);
    public abstract virtual IApdex Apdex(ApdexOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual void ClearAllMetrics();
    public abstract virtual ICounter Counter(CounterOptions options, Func`1<T> builder);
    public abstract virtual ICounter Counter(CounterOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual IGauge Gauge(GaugeOptions options, Func`1<T> builder);
    public abstract virtual IGauge Gauge(GaugeOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual IHistogram Histogram(HistogramOptions options, Func`1<T> builder);
    public abstract virtual IHistogram Histogram(HistogramOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual IBucketHistogram BucketHistogram(BucketHistogramOptions options, Func`1<T> builder);
    public abstract virtual IBucketHistogram BucketHistogram(BucketHistogramOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual IMeter Meter(MeterOptions options, Func`1<T> builder);
    public abstract virtual IMeter Meter(MeterOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual ITimer Timer(TimerOptions options, Func`1<T> builder);
    public abstract virtual ITimer Timer(TimerOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual ITimer BucketTimer(BucketTimerOptions options, Func`1<T> builder);
    public abstract virtual ITimer BucketTimer(BucketTimerOptions options, MetricTags tags, Func`1<T> builder);
}
public interface App.Metrics.Registry.IMetricRegistryManager {
    public IEnumerable`1<ApdexValueSource> ApdexScores { get; }
    public IEnumerable`1<CounterValueSource> Counters { get; }
    public IEnumerable`1<GaugeValueSource> Gauges { get; }
    public IEnumerable`1<HistogramValueSource> Histograms { get; }
    public IEnumerable`1<BucketHistogramValueSource> BucketHistograms { get; }
    public IEnumerable`1<MeterValueSource> Meters { get; }
    public IEnumerable`1<TimerValueSource> Timers { get; }
    public IEnumerable`1<BucketTimerValueSource> BucketTimers { get; }
    public abstract virtual IEnumerable`1<ApdexValueSource> get_ApdexScores();
    public abstract virtual IEnumerable`1<CounterValueSource> get_Counters();
    public abstract virtual IEnumerable`1<GaugeValueSource> get_Gauges();
    public abstract virtual IEnumerable`1<HistogramValueSource> get_Histograms();
    public abstract virtual IEnumerable`1<BucketHistogramValueSource> get_BucketHistograms();
    public abstract virtual IEnumerable`1<MeterValueSource> get_Meters();
    public abstract virtual IEnumerable`1<TimerValueSource> get_Timers();
    public abstract virtual IEnumerable`1<BucketTimerValueSource> get_BucketTimers();
}
public interface App.Metrics.Registry.IMetricsRegistry {
    public abstract virtual IApdex Apdex(ApdexOptions options, Func`1<T> builder);
    public abstract virtual IApdex Apdex(ApdexOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual void Clear();
    public abstract virtual ICounter Counter(CounterOptions options, Func`1<T> builder);
    public abstract virtual ICounter Counter(CounterOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual void Disable();
    public abstract virtual IGauge Gauge(GaugeOptions options, Func`1<T> builder);
    public abstract virtual IGauge Gauge(GaugeOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual MetricsDataValueSource GetData(IFilterMetrics filter);
    public abstract virtual IHistogram Histogram(HistogramOptions options, Func`1<T> builder);
    public abstract virtual IHistogram Histogram(HistogramOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual IBucketHistogram BucketHistogram(BucketHistogramOptions options, Func`1<T> builder);
    public abstract virtual IBucketHistogram BucketHistogram(BucketHistogramOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual IMeter Meter(MeterOptions options, Func`1<T> builder);
    public abstract virtual IMeter Meter(MeterOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual void RemoveContext(string context);
    public abstract virtual ITimer Timer(TimerOptions options, Func`1<T> builder);
    public abstract virtual ITimer Timer(TimerOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual ITimer BucketTimer(BucketTimerOptions options, Func`1<T> builder);
    public abstract virtual ITimer BucketTimer(BucketTimerOptions options, MetricTags tags, Func`1<T> builder);
}
public interface App.Metrics.Reporting.IReportMetrics {
    public IFilterMetrics Filter { get; public set; }
    public TimeSpan FlushInterval { get; public set; }
    public IMetricsOutputFormatter Formatter { get; public set; }
    public abstract virtual IFilterMetrics get_Filter();
    public abstract virtual void set_Filter(IFilterMetrics value);
    public abstract virtual TimeSpan get_FlushInterval();
    public abstract virtual void set_FlushInterval(TimeSpan value);
    public abstract virtual IMetricsOutputFormatter get_Formatter();
    public abstract virtual void set_Formatter(IMetricsOutputFormatter value);
    public abstract virtual Task`1<bool> FlushAsync(MetricsDataValueSource metricsData, CancellationToken cancellationToken);
}
public interface App.Metrics.Reporting.IRunMetricsReports {
    public abstract virtual IEnumerable`1<Task> RunAllAsync(CancellationToken cancellationToken);
    public abstract virtual Task RunAsync(CancellationToken cancellationToken);
}
public interface App.Metrics.ReservoirSampling.IRescalingReservoir {
    public abstract virtual void Rescale();
}
public interface App.Metrics.ReservoirSampling.IReservoir {
    public abstract virtual IReservoirSnapshot GetSnapshot(bool resetReservoir);
    public abstract virtual IReservoirSnapshot GetSnapshot();
    public abstract virtual void Reset();
    public abstract virtual void Update(long value, string userValue);
    public abstract virtual void Update(long value);
}
public interface App.Metrics.ReservoirSampling.IReservoirSnapshot {
    public long Count { get; }
    public long Max { get; }
    public string MaxUserValue { get; }
    public double Mean { get; }
    public double Median { get; }
    public long Min { get; }
    public string MinUserValue { get; }
    public double Percentile75 { get; }
    public double Percentile95 { get; }
    public double Percentile98 { get; }
    public double Percentile99 { get; }
    public double Percentile999 { get; }
    public int Size { get; }
    public double StdDev { get; }
    public double Sum { get; }
    public IEnumerable`1<long> Values { get; }
    public abstract virtual long get_Count();
    public abstract virtual long get_Max();
    public abstract virtual string get_MaxUserValue();
    public abstract virtual double get_Mean();
    public abstract virtual double get_Median();
    public abstract virtual long get_Min();
    public abstract virtual string get_MinUserValue();
    public abstract virtual double get_Percentile75();
    public abstract virtual double get_Percentile95();
    public abstract virtual double get_Percentile98();
    public abstract virtual double get_Percentile99();
    public abstract virtual double get_Percentile999();
    public abstract virtual int get_Size();
    public abstract virtual double get_StdDev();
    public abstract virtual double get_Sum();
    public abstract virtual IEnumerable`1<long> get_Values();
    public abstract virtual double GetValue(double quantile);
}
public class App.Metrics.ScaledValueProvider`1 : object {
    private Func`2<T, T> _scalingFunction;
    [CompilerGeneratedAttribute]
private IMetricValueProvider`1<T> <ValueProvider>k__BackingField;
    public T Value { get; }
    public IMetricValueProvider`1<T> ValueProvider { get; }
    public ScaledValueProvider`1(IMetricValueProvider`1<T> valueProvider, Func`2<T, T> transformation);
    public sealed virtual T get_Value();
    [CompilerGeneratedAttribute]
public IMetricValueProvider`1<T> get_ValueProvider();
    public sealed virtual T GetValue(bool resetMetric);
}
public interface App.Metrics.Scheduling.IMeterTickerScheduler {
    public abstract virtual void ScheduleTick(ITickingMeter meter);
    public abstract virtual void RemoveSchedule(ITickingMeter meter);
}
public interface App.Metrics.Scheduling.IReservoirRescaleScheduler {
    public abstract virtual void RemoveSchedule(IRescalingReservoir reservoir);
    public abstract virtual void ScheduleReScaling(IRescalingReservoir reservoir);
}
public class App.Metrics.Serialization.EnvironmentInfoSerializer : object {
    [AsyncStateMachineAttribute("App.Metrics.Serialization.EnvironmentInfoSerializer/<Serialize>d__0")]
public ValueTask Serialize(IEnvInfoWriter writer, EnvironmentInfo envInfo);
}
public interface App.Metrics.Serialization.IEnvInfoWriter {
    public abstract virtual ValueTask Write(EnvironmentInfo envInfo);
}
public interface App.Metrics.Serialization.IMetricSnapshotWriter {
    public abstract virtual void Write(string context, string name, string field, object value, MetricTags tags, DateTime timestamp);
    public abstract virtual void Write(string context, string name, IEnumerable`1<string> columns, IEnumerable`1<object> values, MetricTags tags, DateTime timestamp);
}
public class App.Metrics.Serialization.MetricSnapshotSerializer : object {
    public void Serialize(IMetricSnapshotWriter writer, MetricsDataValueSource metricsData, MetricFields fields);
    private static void BuildApdexPayload(string context, MetricValueSourceBase`1<ApdexValue> valueSource, IMetricSnapshotWriter writer, IDictionary`2<ApdexFields, string> fields, DateTime timestamp);
    private static void BuildCounterPayload(string context, MetricValueSourceBase`1<CounterValue> valueSource, IMetricSnapshotWriter writer, IDictionary`2<CounterFields, string> fields, DateTime timestamp);
    private static void BuildGaugePayload(string context, MetricValueSourceBase`1<double> valueSource, IMetricSnapshotWriter writer, IDictionary`2<GaugeFields, string> fields, DateTime timestamp);
    private static void BuildHistogramPayload(string context, MetricValueSourceBase`1<HistogramValue> valueSource, IMetricSnapshotWriter writer, IDictionary`2<HistogramFields, string> fields, DateTime timestamp);
    private static void BuildBucketHistogramPayload(string context, MetricValueSourceBase`1<BucketHistogramValue> valueSource, IMetricSnapshotWriter writer, IDictionary`2<string, string> fields, DateTime timestamp);
    private static void BuildBucketTimerPayload(string context, MetricValueSourceBase`1<BucketTimerValue> valueSource, IMetricSnapshotWriter writer, IDictionary`2<string, string> fields, DateTime timestamp);
    private static void BuildMeterPayload(string context, MetricValueSourceBase`1<MeterValue> valueSource, IMetricSnapshotWriter writer, IDictionary`2<MeterFields, string> fields, DateTime timestamp);
    private static void BuildMetricPayload(string context, MetricValueSourceBase`1<TMetric> valueSource, IMetricSnapshotWriter writer, MetricFields fields, DateTime timestamp);
    private static void BuildTimerPayload(string context, MetricValueSourceBase`1<TimerValue> valueSource, IMetricSnapshotWriter writer, IDictionary`2<MeterFields, string> meterFields, IDictionary`2<HistogramFields, string> histogramFields, DateTime timestamp);
}
[ExtensionAttribute]
public static class App.Metrics.Serialization.MetricSnapshotWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteApdex(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<ApdexValue> valueSource, IDictionary`2<ApdexFields, string> fields, DateTime timestamp);
    [ExtensionAttribute]
public static void WriteCounter(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<CounterValue> valueSource, CounterValueSource counterValueSource, IDictionary`2<CounterFields, string> fields, DateTime timestamp);
    [ExtensionAttribute]
public static void WriteGauge(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<double> valueSource, IDictionary`2<GaugeFields, string> fields, DateTime timestamp);
    [ExtensionAttribute]
public static void WriteHistogram(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<HistogramValue> valueSource, IDictionary`2<HistogramFields, string> fields, DateTime timestamp);
    [ExtensionAttribute]
public static void WriteBucketHistogram(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<BucketHistogramValue> valueSource, IDictionary`2<string, string> fields, DateTime timestamp);
    [ExtensionAttribute]
public static void WriteBucketTimer(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<BucketTimerValue> valueSource, IDictionary`2<string, string> fields, DateTime timestamp);
    [ExtensionAttribute]
public static void WriteMeter(IMetricSnapshotWriter writer, string context, MeterValueSource valueSource, IDictionary`2<MeterFields, string> fields, DateTime timestamp);
    [ExtensionAttribute]
public static void WriteTimer(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<TimerValue> valueSource, IDictionary`2<MeterFields, string> meterFields, IDictionary`2<HistogramFields, string> histogramFields, DateTime timestamp);
    private static MetricTags ConcatIntrinsicMetricTags(MetricValueSourceBase`1<T> valueSource);
    private static MetricTags ConcatMetricTags(MetricValueSourceBase`1<T> valueSource, MetricTags setItemTags);
    private static MetricTags ConcatMetricTags(MetricValueSourceBase`1<T> valueSource);
    private static void WriteMetric(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<T> valueSource, IDictionary`2<string, object> data, DateTime timestamp);
    private static void WriteMetricValue(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<T> valueSource, string field, object value, DateTime timestamp);
    private static void WriteMetricWithSetItems(IMetricSnapshotWriter writer, string context, MetricValueSourceBase`1<T> valueSource, MetricTags setItemTags, IDictionary`2<string, object> itemData, string metricSetItemSuffix, DateTime timestamp);
}
public interface App.Metrics.Timer.IBuildTimerMetrics {
    public abstract virtual ITimerMetric Build(IHistogramMetric histogram, IClock clock);
    public abstract virtual ITimerMetric Build(Func`1<IReservoir> reservoir, IClock clock);
    public abstract virtual ITimerMetric Build(IHistogramMetric histogram, IMeterMetric meter, IClock clock);
    public abstract virtual ITimerMetric Build(Func`1<IReservoir> reservoir, IMeterMetric meter, IClock clock);
}
public interface App.Metrics.Timer.IMeasureTimerMetrics {
    public abstract virtual void Time(TimerOptions options, Action action);
    public abstract virtual void Time(TimerOptions options, MetricTags tags, Action action);
    public abstract virtual void Time(TimerOptions options, Action action, string userValue);
    public abstract virtual void Time(TimerOptions options, MetricTags tags, Action action, string userValue);
    public abstract virtual TimerContext Time(TimerOptions options, MetricTags tags, string userValue);
    public abstract virtual TimerContext Time(TimerOptions options, string userValue);
    public abstract virtual TimerContext Time(TimerOptions options, MetricTags tags);
    public abstract virtual TimerContext Time(TimerOptions options);
    public abstract virtual void Time(TimerOptions options, MetricTags tags, long time);
    public abstract virtual void Time(TimerOptions options, long time);
}
public interface App.Metrics.Timer.IProvideTimerMetrics {
    public abstract virtual ITimer Instance(TimerOptions options);
    public abstract virtual ITimer Instance(TimerOptions options, MetricTags tags);
    public abstract virtual ITimer Instance(TimerOptions options, Func`1<T> builder);
    public abstract virtual ITimer Instance(TimerOptions options, MetricTags tags, Func`1<T> builder);
    public abstract virtual ITimer WithHistogram(TimerOptions options, Func`1<T> histogramMetricBuilder);
    public abstract virtual ITimer WithHistogram(TimerOptions options, MetricTags tags, Func`1<T> histogramMetricBuilder);
}
public interface App.Metrics.Timer.ITimer {
    public abstract virtual long CurrentTime();
    public abstract virtual long EndRecording();
    public abstract virtual TimerContext NewContext(string userValue);
    public abstract virtual TimerContext NewContext();
    public abstract virtual void Record(long time, TimeUnit unit, string userValue);
    public abstract virtual void Record(long time, TimeUnit unit);
    public abstract virtual long StartRecording();
    public abstract virtual void Time(Action action, string userValue);
    public abstract virtual void Time(Action action);
    public abstract virtual T Time(Func`1<T> action, string userValue);
    public abstract virtual T Time(Func`1<T> action);
}
public interface App.Metrics.Timer.ITimerMetric {
}
public class App.Metrics.Timer.TimerContext : ValueType {
    private long _start;
    private ITimer _timer;
    private string _userValue;
    public TimeSpan Elapsed { get; }
    public TimerContext(ITimer timer, string userValue);
    public TimeSpan get_Elapsed();
    public sealed virtual void Dispose();
    public void TrackUserValue(string value);
}
public class App.Metrics.Timer.TimerOptions : MetricValueWithSamplingOption {
    [CompilerGeneratedAttribute]
private TimeUnit <DurationUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <RateUnit>k__BackingField;
    public TimeUnit DurationUnit { get; public set; }
    public TimeUnit RateUnit { get; public set; }
    [CompilerGeneratedAttribute]
public TimeUnit get_DurationUnit();
    [CompilerGeneratedAttribute]
public void set_DurationUnit(TimeUnit value);
    [CompilerGeneratedAttribute]
public TimeUnit get_RateUnit();
    [CompilerGeneratedAttribute]
public void set_RateUnit(TimeUnit value);
}
public class App.Metrics.Timer.TimerValue : object {
    [CompilerGeneratedAttribute]
private long <ActiveSessions>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramValue <Histogram>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterValue <Rate>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <DurationUnit>k__BackingField;
    public long ActiveSessions { get; }
    public HistogramValue Histogram { get; }
    public MeterValue Rate { get; }
    public TimeUnit DurationUnit { get; }
    public TimerValue(MeterValue rate, HistogramValue histogram, long activeSessions, TimeUnit durationUnit);
    [CompilerGeneratedAttribute]
public long get_ActiveSessions();
    [CompilerGeneratedAttribute]
public HistogramValue get_Histogram();
    [CompilerGeneratedAttribute]
public MeterValue get_Rate();
    [CompilerGeneratedAttribute]
public TimeUnit get_DurationUnit();
    public TimerValue Scale(TimeUnit rate, TimeUnit duration);
}
public class App.Metrics.Timer.TimerValueSource : MetricValueSourceBase`1<TimerValue> {
    [CompilerGeneratedAttribute]
private TimeUnit <DurationUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeUnit <RateUnit>k__BackingField;
    public TimeUnit DurationUnit { get; }
    public TimeUnit RateUnit { get; }
    public TimerValueSource(string name, IMetricValueProvider`1<TimerValue> value, Unit unit, TimeUnit rateUnit, TimeUnit durationUnit, MetricTags tags, bool restOnReporting);
    [CompilerGeneratedAttribute]
public TimeUnit get_DurationUnit();
    [CompilerGeneratedAttribute]
public TimeUnit get_RateUnit();
}
public enum App.Metrics.TimeUnit : Enum {
    public int value__;
    public static TimeUnit Nanoseconds;
    public static TimeUnit Microseconds;
    public static TimeUnit Milliseconds;
    public static TimeUnit Seconds;
    public static TimeUnit Minutes;
    public static TimeUnit Hours;
    public static TimeUnit Days;
}
[ExtensionAttribute]
public static class App.Metrics.TimeUnitExtensions : object {
    private static Int64[0...,0...] ConversionFactors;
    private static IReadOnlyDictionary`2<string, TimeUnit> TimeUnitValueMapping;
    private static IReadOnlyDictionary`2<TimeUnit, string> ValueTimeUnitMapping;
    private static TimeUnitExtensions();
    [ExtensionAttribute]
public static long Convert(TimeUnit sourceUnit, TimeUnit targetUnit, long value);
    [ExtensionAttribute]
public static TimeUnit FromUnit(string unit);
    [ExtensionAttribute]
public static double ScalingFactorFor(TimeUnit sourceUnit, TimeUnit targetUnit);
    [ExtensionAttribute]
public static long ToDays(TimeUnit unit, long value);
    [ExtensionAttribute]
public static long ToHours(TimeUnit unit, long value);
    [ExtensionAttribute]
public static long ToMicroseconds(TimeUnit unit, long value);
    [ExtensionAttribute]
public static long ToMilliseconds(TimeUnit unit, long value);
    [ExtensionAttribute]
public static long ToMinutes(TimeUnit unit, long value);
    [ExtensionAttribute]
public static long ToNanoseconds(TimeUnit unit, long value);
    [ExtensionAttribute]
public static long ToSeconds(TimeUnit unit, long value);
    [ExtensionAttribute]
public static string Unit(TimeUnit unit);
    private static Int64[0...,0...] BuildConversionFactorsMatrix();
}
[DebuggerDisplayAttribute("{Name}")]
public class App.Metrics.Unit : ValueType {
    public static Unit Bits;
    public static Unit Bytes;
    public static Unit Calls;
    public static Unit Commands;
    public static Unit Connections;
    public static Unit Errors;
    public static Unit Events;
    public static Unit Items;
    public static Unit KiloBytes;
    public static Unit MegaBytes;
    public static Unit GigaBytes;
    public static Unit TeraBytes;
    public static Unit PetaBytes;
    public static Unit None;
    public static Unit Percent;
    public static Unit Requests;
    public static Unit Results;
    public static Unit Threads;
    public static Unit Warnings;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    private Unit(string name);
    private static Unit();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    public static Unit Custom(string name);
    public static bool op_Equality(Unit left, Unit right);
    public static Unit op_Implicit(string name);
    public static bool op_Inequality(Unit left, Unit right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool Equals(Unit other);
    public string FormatCount(long value);
    public string FormatDuration(double value, Nullable`1<TimeUnit> timeUnit);
    public string FormatRate(double value, TimeUnit timeUnit);
    public string FormatValue(double value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class System.Collections.Generic.DictionaryExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void AddIfNotNanOrInfinity(IDictionary`2<string, object> values, string key, double value);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void AddIfPresent(IDictionary`2<string, object> values, string key, string value);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static IDictionary`2<TKey, TValue> MergeDifference(IDictionary`2<TKey, TValue> first, IDictionary`2<TKey, TValue> second);
}
[ExtensionAttribute]
public static class System.Collections.Generic.MetricFieldNamesMappingExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void TryAddValuesForKeyIfNotNanOrInfinity(IDictionary`2<TKey, string> fieldMapping, IDictionary`2<string, object> values, TKey key, double value);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void TryAddValuesForKeyIfPresent(IDictionary`2<TKey, string> fieldMapping, IDictionary`2<string, object> values, TKey key, string value);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void TryAddValuesForKey(IDictionary`2<TKey, string> fieldMapping, IDictionary`2<string, object> values, TKey key, int value);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void TryAddValuesForKey(IDictionary`2<TKey, string> fieldMapping, IDictionary`2<string, object> values, TKey key, long value);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void TryAddValuesForKey(IDictionary`2<TKey, string> fieldMapping, IDictionary`2<string, object> values, TKey key, double value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
