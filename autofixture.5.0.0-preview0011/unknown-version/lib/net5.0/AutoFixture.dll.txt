public class AutoFixture.AutoPropertiesTarget : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public AutoPropertiesTarget(ISpecimenBuilder builder);
    public sealed virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    public sealed virtual object Create(object request, ISpecimenContext context);
    [IteratorStateMachineAttribute("AutoFixture.AutoPropertiesTarget/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
}
public class AutoFixture.BehaviorRoot : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public BehaviorRoot(ISpecimenBuilder builder);
    public sealed virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    public sealed virtual object Create(object request, ISpecimenContext context);
    [IteratorStateMachineAttribute("AutoFixture.BehaviorRoot/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
}
public class AutoFixture.BooleanSwitch : object {
    private bool b;
    private object syncRoot;
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public bool Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public bool CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.ByteSequenceGenerator : object {
    private byte b;
    private object syncRoot;
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public byte Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public byte CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.CharSequenceGenerator : object {
    private char c;
    private object syncRoot;
    public sealed virtual object Create(object request, ISpecimenContext context);
    private char Create();
}
[ExtensionAttribute]
public static class AutoFixture.CollectionFiller : object {
    [ExtensionAttribute]
public static void AddMany(ICollection`1<T> collection, Func`1<T> creator, int repeatCount);
    [ExtensionAttribute]
public static void AddManyTo(IFixture fixture, ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddManyTo(IFixture fixture, ICollection`1<T> collection, int repeatCount);
    [ExtensionAttribute]
public static void AddManyTo(IFixture fixture, ICollection`1<T> collection, Func`1<T> creator);
}
public class AutoFixture.CompositeCustomization : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICustomization> <Customizations>k__BackingField;
    public IEnumerable`1<ICustomization> Customizations { get; }
    public CompositeCustomization(IEnumerable`1<ICustomization> customizations);
    public CompositeCustomization(ICustomization[] customizations);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ICustomization> get_Customizations();
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.ConstrainedStringGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static string Create(int minimumLength, int maximumLength, ISpecimenContext context);
}
public class AutoFixture.ConstructorCustomization : object {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodQuery <Query>k__BackingField;
    public Type TargetType { get; }
    public IMethodQuery Query { get; }
    public ConstructorCustomization(Type targetType, IMethodQuery query);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public IMethodQuery get_Query();
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.CurrentDateTimeCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.CurrentDateTimeGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
[ExtensionAttribute]
public static class AutoFixture.CustomizationExtensions : object {
    [ExtensionAttribute]
public static ICustomization ToCustomization(ISpecimenBuilder builder);
}
public class AutoFixture.CustomizationNode : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public CustomizationNode(ISpecimenBuilder builder);
    public sealed virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    public sealed virtual object Create(object request, ISpecimenContext context);
    [IteratorStateMachineAttribute("AutoFixture.CustomizationNode/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
}
public class AutoFixture.DataAnnotations.DataAnnotationsSupportNode : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public DataAnnotationsSupportNode(ISpecimenBuilder builder);
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    public sealed virtual object Create(object request, ISpecimenContext context);
    public sealed virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    [IteratorStateMachineAttribute("AutoFixture.DataAnnotations.DataAnnotationsSupportNode/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class AutoFixture.DataAnnotations.EnumDataTypeAttributeRelay : object {
    private ISpecimenBuilder enumGenerator;
    private IRequestMemberTypeResolver requestMemberTypeResolver;
    public IRequestMemberTypeResolver RequestMemberTypeResolver { get; public set; }
    public EnumDataTypeAttributeRelay(ISpecimenBuilder enumGenerator);
    public IRequestMemberTypeResolver get_RequestMemberTypeResolver();
    public void set_RequestMemberTypeResolver(IRequestMemberTypeResolver value);
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.DataAnnotations.EnumRangedRequestRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.DataAnnotations.MinAndMaxLengthAttributeRelay : object {
    private IRequestMemberTypeResolver requestMemberTypeResolver;
    public IRequestMemberTypeResolver RequestMemberTypeResolver { get; public set; }
    public IRequestMemberTypeResolver get_RequestMemberTypeResolver();
    public void set_RequestMemberTypeResolver(IRequestMemberTypeResolver value);
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.DataAnnotations.NoDataAnnotationsCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.DataAnnotations.NumericRangedRequestRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.DataAnnotations.RangeAttributeRelay : object {
    private IRequestMemberTypeResolver requestMemberTypeResolver;
    public IRequestMemberTypeResolver RequestMemberTypeResolver { get; public set; }
    public IRequestMemberTypeResolver get_RequestMemberTypeResolver();
    public void set_RequestMemberTypeResolver(IRequestMemberTypeResolver value);
    public sealed virtual object Create(object request, ISpecimenContext context);
    private Type GetMemberType(RangeAttribute rangeAttribute, object request);
}
[PreserveInRequestPathAttribute]
public class AutoFixture.DataAnnotations.RangedRequest : object {
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OperandType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Maximum>k__BackingField;
    public Type MemberType { get; }
    public Type OperandType { get; }
    public object Minimum { get; }
    public object Maximum { get; }
    public RangedRequest(Type memberType, Type operandType, object minimum, object maximum);
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public Type get_OperandType();
    [CompilerGeneratedAttribute]
public object get_Minimum();
    [CompilerGeneratedAttribute]
public object get_Maximum();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RangedRequest other);
    public virtual int GetHashCode();
    public object GetConvertedMinimum(Type targetType);
    public object GetConvertedMaximum(Type targetType);
    public virtual string ToString();
    private static object GetConvertedRangeBoundary(object attributeValue, Type conversionType);
}
public class AutoFixture.DataAnnotations.RegularExpressionAttributeRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.DataAnnotations.StringLengthAttributeRelay : object {
    private IRequestMemberTypeResolver requestMemberTypeResolver;
    public IRequestMemberTypeResolver RequestMemberTypeResolver { get; public set; }
    public IRequestMemberTypeResolver get_RequestMemberTypeResolver();
    public void set_RequestMemberTypeResolver(IRequestMemberTypeResolver value);
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.DataAnnotations.TimeSpanRangedRequestRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static object CreateRangedTimeSpanSpecimen(RangedRequest rangedRequest, ISpecimenContext context);
    private static TimeSpanRange ParseTimeSpanRange(RangedRequest rangedRequest);
    private static object RandomizeTimeSpanInRange(TimeSpanRange range, ISpecimenContext context);
}
public class AutoFixture.DecimalSequenceGenerator : object {
    private decimal d;
    private object syncRoot;
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public decimal Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public decimal CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.DefaultEngineParts : DefaultRelays {
    private IEnumerable`1<ISpecimenBuilder> primitiveBuilders;
    public DefaultEngineParts(IEnumerable`1<ISpecimenBuilder> primitiveBuilders);
    public DefaultEngineParts(ISpecimenBuilder[] primitiveBuilders);
    public virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
}
public class AutoFixture.DefaultPrimitiveBuilders : object {
    [IteratorStateMachineAttribute("AutoFixture.DefaultPrimitiveBuilders/<GetEnumerator>d__0")]
public virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class AutoFixture.DefaultRelays : object {
    [IteratorStateMachineAttribute("AutoFixture.DefaultRelays/<GetEnumerator>d__0")]
public virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class AutoFixture.DictionaryFiller : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use the instance method Execute instead.", "True")]
public static void AddMany(object specimen, ISpecimenContext context);
    public sealed virtual void Execute(object specimen, ISpecimenContext context);
}
public class AutoFixture.DisposableTrackingCustomization : object {
    private DisposableTrackingBehavior behavior;
    public DisposableTrackingBehavior Behavior { get; }
    public DisposableTrackingBehavior get_Behavior();
    public sealed virtual void Customize(IFixture fixture);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class AutoFixture.DomainName : object {
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    public string Domain { get; }
    public DomainName(string domainName);
    [CompilerGeneratedAttribute]
public string get_Domain();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class AutoFixture.DomainNameGenerator : object {
    private ElementsBuilder`1<string> fictitiousDomainBuilder;
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.DoubleSequenceGenerator : object {
    private double d;
    private object syncRoot;
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public double Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public double CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Dsl.CompositeNodeComposer`1 : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilderNode <Node>k__BackingField;
    public ISpecimenBuilderNode Node { get; }
    public CompositeNodeComposer`1(ISpecimenBuilderNode node);
    [CompilerGeneratedAttribute]
public ISpecimenBuilderNode get_Node();
    public sealed virtual IPostprocessComposer`1<T> FromSeed(Func`2<T, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(ISpecimenBuilder factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`1<T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`2<TInput, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`3<TInput1, TInput2, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`4<TInput1, TInput2, TInput3, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`5<TInput1, TInput2, TInput3, TInput4, T> factory);
    public ISpecimenBuilder Compose();
    public sealed virtual IPostprocessComposer`1<T> Do(Action`1<T> action);
    public sealed virtual IPostprocessComposer`1<T> OmitAutoProperties();
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, TProperty value);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`1<TProperty> valueFactory);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`2<TInput, TProperty> valueFactory);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, ISpecimenBuilder builder);
    public sealed virtual IPostprocessComposer`1<T> WithAutoProperties();
    public sealed virtual IPostprocessComposer`1<T> Without(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public sealed virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    public sealed virtual object Create(object request, ISpecimenContext context);
    [IteratorStateMachineAttribute("AutoFixture.Dsl.CompositeNodeComposer`1/<GetEnumerator>d__23")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("This class is deprecated and will be removed in future versions of AutoFixture. Please file an issue on GitHub if you need this class in your project.")]
public class AutoFixture.Dsl.CompositePostprocessComposer`1 : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPostprocessComposer`1<T>> <Composers>k__BackingField;
    public IEnumerable`1<IPostprocessComposer`1<T>> Composers { get; }
    public CompositePostprocessComposer`1(IEnumerable`1<IPostprocessComposer`1<T>> composers);
    public CompositePostprocessComposer`1(IPostprocessComposer`1[] composers);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IPostprocessComposer`1<T>> get_Composers();
    public sealed virtual IPostprocessComposer`1<T> Do(Action`1<T> action);
    public sealed virtual IPostprocessComposer`1<T> OmitAutoProperties();
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, TProperty value);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`1<TProperty> valueFactory);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`2<TInput, TProperty> valueFactory);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, ISpecimenBuilder builder);
    public sealed virtual IPostprocessComposer`1<T> WithAutoProperties();
    public sealed virtual IPostprocessComposer`1<T> Without(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public interface AutoFixture.Dsl.ICustomizationComposer`1 {
}
public interface AutoFixture.Dsl.IFactoryComposer`1 {
    public abstract virtual IPostprocessComposer`1<T> FromSeed(Func`2<T, T> factory);
    public abstract virtual IPostprocessComposer`1<T> FromFactory(ISpecimenBuilder factory);
    public abstract virtual IPostprocessComposer`1<T> FromFactory(Func`1<T> factory);
    public abstract virtual IPostprocessComposer`1<T> FromFactory(Func`2<TInput, T> factory);
    public abstract virtual IPostprocessComposer`1<T> FromFactory(Func`3<TInput1, TInput2, T> factory);
    public abstract virtual IPostprocessComposer`1<T> FromFactory(Func`4<TInput1, TInput2, TInput3, T> factory);
    public abstract virtual IPostprocessComposer`1<T> FromFactory(Func`5<TInput1, TInput2, TInput3, TInput4, T> factory);
}
public interface AutoFixture.Dsl.IPostprocessComposer`1 {
    public abstract virtual IPostprocessComposer`1<T> Do(Action`1<T> action);
    public abstract virtual IPostprocessComposer`1<T> OmitAutoProperties();
    public abstract virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public abstract virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, TProperty value);
    public abstract virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`1<TProperty> valueFactory);
    public abstract virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`2<TInput, TProperty> valueFactory);
    public abstract virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, ISpecimenBuilder builder);
    public abstract virtual IPostprocessComposer`1<T> WithAutoProperties();
    public abstract virtual IPostprocessComposer`1<T> Without(Expression`1<Func`2<T, TProperty>> propertyPicker);
}
public class AutoFixture.Dsl.NodeComposer`1 : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public NodeComposer`1(ISpecimenBuilder builder);
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    public sealed virtual IPostprocessComposer`1<T> FromSeed(Func`2<T, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(ISpecimenBuilder factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`1<T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`2<TInput, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`3<TInput1, TInput2, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`4<TInput1, TInput2, TInput3, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`5<TInput1, TInput2, TInput3, TInput4, T> factory);
    public ISpecimenBuilder Compose();
    public sealed virtual IPostprocessComposer`1<T> Do(Action`1<T> action);
    private static NodeComposer`1<T> WithDoNode(Action`1<T> action, ISpecimenBuilderNode graph, ISpecimenBuilderNode container);
    public sealed virtual IPostprocessComposer`1<T> OmitAutoProperties();
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, TProperty value);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`1<TProperty> valueFactory);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`2<TInput, TProperty> valueFactory);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, ISpecimenBuilder builder);
    private IPostprocessComposer`1<T> WithCommand(Expression`1<Func`2<T, TProperty>> propertyPicker, ISpecimenCommand command);
    public sealed virtual IPostprocessComposer`1<T> WithAutoProperties();
    public sealed virtual IPostprocessComposer`1<T> Without(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public NodeComposer`1<T> WithAutoProperties(bool enable);
    private NodeComposer`1<T> WithFactory(ISpecimenBuilder factory);
    private static IRequestSpecification CreateSpecification();
    public sealed virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    public sealed virtual object Create(object request, ISpecimenContext context);
    [IteratorStateMachineAttribute("AutoFixture.Dsl.NodeComposer`1/<GetEnumerator>d__28")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private NodeComposer`1<T> GetGraphWithAutoPropertiesNode();
    private static Postprocessor FindAutoPropertiesNode(ISpecimenBuilderNode graph);
    private static ISpecimenBuilderNode ExcludeMemberFromAutoProperties(MemberInfo member, ISpecimenBuilderNode graph);
    private static ISpecimenBuilderNode WithoutSeedIgnoringRelay(ISpecimenBuilderNode graph);
    private static ISpecimenBuilderNode FindContainer(ISpecimenBuilderNode graph);
}
public class AutoFixture.Dsl.NullComposer`1 : object {
    private Func`1<ISpecimenBuilder> compose;
    public NullComposer`1(ISpecimenBuilder builder);
    public NullComposer`1(Func`1<ISpecimenBuilder> factory);
    public sealed virtual IPostprocessComposer`1<T> FromSeed(Func`2<T, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(ISpecimenBuilder factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`1<T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`2<TInput, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`3<TInput1, TInput2, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`4<TInput1, TInput2, TInput3, T> factory);
    public sealed virtual IPostprocessComposer`1<T> FromFactory(Func`5<TInput1, TInput2, TInput3, TInput4, T> factory);
    public sealed virtual IPostprocessComposer`1<T> Do(Action`1<T> action);
    public sealed virtual IPostprocessComposer`1<T> OmitAutoProperties();
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, TProperty value);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`1<TProperty> valueFactory);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`2<TInput, TProperty> valueFactory);
    public sealed virtual IPostprocessComposer`1<T> With(Expression`1<Func`2<T, TProperty>> propertyPicker, ISpecimenBuilder builder);
    public sealed virtual IPostprocessComposer`1<T> WithAutoProperties();
    public sealed virtual IPostprocessComposer`1<T> Without(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public ISpecimenBuilder Compose();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.ElementsBuilder`1 : object {
    private T[] elements;
    private RandomNumericSequenceGenerator sequence;
    public ElementsBuilder`1(T[] elements);
    public ElementsBuilder`1(IEnumerable`1<T> elements);
    public sealed virtual object Create(object request, ISpecimenContext context);
    private int GetNextIndex();
}
public class AutoFixture.EmailAddressLocalPart : object {
    [CompilerGeneratedAttribute]
private string <LocalPart>k__BackingField;
    public string LocalPart { get; }
    public EmailAddressLocalPart(string localPart);
    [CompilerGeneratedAttribute]
public string get_LocalPart();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class AutoFixture.EmailAddressLocalPartGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
[ExtensionAttribute]
internal static class AutoFixture.EnumerableExtensions : object {
    private static MethodInfo BuildTypedArrayMethodInfo;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> items, T item);
    [ExtensionAttribute]
public static IEnumerable`1<T> Insert(IEnumerable`1<T> items, int index, T item);
    [ExtensionAttribute]
public static IEnumerable`1<T> RemoveAt(IEnumerable`1<T> items, int index);
    [ExtensionAttribute]
public static IEnumerable`1<T> SetItem(IEnumerable`1<T> items, int index, T item);
    [ExtensionAttribute]
public static object ToTypedArray(IEnumerable items, Type elementType);
    private static object BuildTypedArray(IEnumerable items);
}
public class AutoFixture.EnumGenerator : object {
    private Dictionary`2<Type, IEnumerator> enumerators;
    private object syncRoot;
    public sealed virtual object Create(object request, ISpecimenContext context);
    private object CreateValue(Type t);
    private IEnumerator EnsureGenerator(Type t);
}
public class AutoFixture.Fixture : object {
    private MultipleRelay multiple;
    private ISpecimenBuilderNode graph;
    private SingletonSpecimenBuilderNodeStackAdapterCollection behaviors;
    private SpecimenBuilderNodeAdapterCollection customizer;
    private SpecimenBuilderNodeAdapterCollection residueCollector;
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Engine>k__BackingField;
    public IList`1<ISpecimenBuilderTransformation> Behaviors { get; }
    public IList`1<ISpecimenBuilder> Customizations { get; }
    public ISpecimenBuilder Engine { get; }
    public bool OmitAutoProperties { get; public set; }
    public int RepeatCount { get; public set; }
    public IList`1<ISpecimenBuilder> ResidueCollectors { get; }
    private bool EnableAutoProperties { get; }
    public Fixture(DefaultRelays engineParts);
    public Fixture(ISpecimenBuilder engine, MultipleRelay multiple);
    public sealed virtual IList`1<ISpecimenBuilderTransformation> get_Behaviors();
    public sealed virtual IList`1<ISpecimenBuilder> get_Customizations();
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Engine();
    public sealed virtual bool get_OmitAutoProperties();
    public sealed virtual void set_OmitAutoProperties(bool value);
    public sealed virtual int get_RepeatCount();
    public sealed virtual void set_RepeatCount(int value);
    public sealed virtual IList`1<ISpecimenBuilder> get_ResidueCollectors();
    public sealed virtual ICustomizationComposer`1<T> Build();
    public sealed virtual IFixture Customize(ICustomization customization);
    public sealed virtual void Customize(Func`2<ICustomizationComposer`1<T>, ISpecimenBuilder> composerTransformation);
    public sealed virtual object Create(object request, ISpecimenContext context);
    [IteratorStateMachineAttribute("AutoFixture.Fixture/<GetEnumerator>d__27")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private bool get_EnableAutoProperties();
    private void UpdateGraphAndSetupAdapters(ISpecimenBuilderNode newGraph);
    private void UpdateGraphAndSetupAdapters(ISpecimenBuilderNode newGraph, IEnumerable`1<ISpecimenBuilderTransformation> existingBehaviors);
    private void UpdateCustomizer();
    private void UpdateResidueCollector();
    private void UpdateBehaviors(ISpecimenBuilderTransformation[] existingTransformations);
    private Postprocessor FindAutoPropertiesPostProcessor();
    private static ISpecimenBuilder MakeFixedBuilder(T value);
    private static ISpecimenBuilder MakeQueryBasedBuilderForMatchingType(Type matchingType, IMethodQuery query);
    private static ISpecimenBuilder MakeQueryBasedBuilderForMatchingType(Type matchingType, IMethodQuery query, ISpecimenCommand command);
    [CompilerGeneratedAttribute]
private ISpecimenBuilderNode <Build>b__23_0(ISpecimenBuilderNode n);
    [CompilerGeneratedAttribute]
private void <UpdateCustomizer>b__33_1(object _, SpecimenBuilderNodeEventArgs args);
    [CompilerGeneratedAttribute]
private void <UpdateResidueCollector>b__34_1(object _, SpecimenBuilderNodeEventArgs args);
    [CompilerGeneratedAttribute]
private void <UpdateBehaviors>b__35_1(object _, SpecimenBuilderNodeEventArgs args);
}
[ExtensionAttribute]
public static class AutoFixture.FixtureFreezer : object {
    [ExtensionAttribute]
public static T Freeze(IFixture fixture);
    [ExtensionAttribute]
public static T Freeze(IFixture fixture, Func`2<ICustomizationComposer`1<T>, ISpecimenBuilder> composerTransformation);
}
[ExtensionAttribute]
public static class AutoFixture.FixtureRegistrar : object {
    [ExtensionAttribute]
public static void Inject(IFixture fixture, T item);
    [ExtensionAttribute]
public static void Register(IFixture fixture, Func`1<T> creator);
    [ExtensionAttribute]
public static void Register(IFixture fixture, Func`2<TInput, T> creator);
    [ExtensionAttribute]
public static void Register(IFixture fixture, Func`3<TInput1, TInput2, T> creator);
    [ExtensionAttribute]
public static void Register(IFixture fixture, Func`4<TInput1, TInput2, TInput3, T> creator);
    [ExtensionAttribute]
public static void Register(IFixture fixture, Func`5<TInput1, TInput2, TInput3, TInput4, T> creator);
}
[ExtensionAttribute]
public static class AutoFixture.FixtureRepeater : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> Repeat(IFixture fixture, Func`1<T> function);
}
public class AutoFixture.FreezeOnMatchCustomization : object {
    [CompilerGeneratedAttribute]
private object <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestSpecification <Matcher>k__BackingField;
    [ObsoleteAttribute("Please use the Request property instead.")]
public Type TargetType { get; }
    public object Request { get; }
    public IRequestSpecification Matcher { get; }
    public FreezeOnMatchCustomization(object request);
    public FreezeOnMatchCustomization(object request, IRequestSpecification matcher);
    public Type get_TargetType();
    [CompilerGeneratedAttribute]
public object get_Request();
    [CompilerGeneratedAttribute]
public IRequestSpecification get_Matcher();
    public sealed virtual void Customize(IFixture fixture);
    private void FreezeSpecimenForMatchingRequests(IFixture fixture);
    private ISpecimenBuilder FreezeSpecimen(IFixture fixture);
}
public class AutoFixture.FreezingCustomization : object {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RegisteredType>k__BackingField;
    public Type TargetType { get; }
    public Type RegisteredType { get; }
    public FreezingCustomization(Type targetType);
    public FreezingCustomization(Type targetType, Type registeredType);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public Type get_RegisteredType();
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.Generator`1 : object {
    private ISpecimenBuilder builder;
    public Generator`1(ISpecimenBuilder builder);
    [IteratorStateMachineAttribute("AutoFixture.Generator`1/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class AutoFixture.GuidGenerator : object {
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public static Guid Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public static Guid CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public interface AutoFixture.ICustomization {
    public abstract virtual void Customize(IFixture fixture);
}
public interface AutoFixture.IFixture {
    public IList`1<ISpecimenBuilderTransformation> Behaviors { get; }
    public IList`1<ISpecimenBuilder> Customizations { get; }
    public bool OmitAutoProperties { get; public set; }
    public int RepeatCount { get; public set; }
    public IList`1<ISpecimenBuilder> ResidueCollectors { get; }
    public abstract virtual IList`1<ISpecimenBuilderTransformation> get_Behaviors();
    public abstract virtual IList`1<ISpecimenBuilder> get_Customizations();
    public abstract virtual bool get_OmitAutoProperties();
    public abstract virtual void set_OmitAutoProperties(bool value);
    public abstract virtual int get_RepeatCount();
    public abstract virtual void set_RepeatCount(int value);
    public abstract virtual IList`1<ISpecimenBuilder> get_ResidueCollectors();
    public abstract virtual ICustomizationComposer`1<T> Build();
    public abstract virtual IFixture Customize(ICustomization customization);
    public abstract virtual void Customize(Func`2<ICustomizationComposer`1<T>, ISpecimenBuilder> composerTransformation);
}
public class AutoFixture.IncrementingDateTimeCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.Int16SequenceGenerator : object {
    private short s;
    private object syncRoot;
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public short Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public short CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Int32SequenceGenerator : object {
    private int i;
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public int Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public int CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Int64SequenceGenerator : object {
    private long l;
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public long Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public long CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
[ObsoleteAttribute("Please use a 'AutoFixture.Kernel.FilteringSpecimenBuilder' instead.", "True")]
public class AutoFixture.InvariantCultureGenerator : object {
    private ExactTypeSpecification cultureTypeSpecification;
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public interface AutoFixture.IParameterCustomizationSource {
    public abstract virtual ICustomization GetCustomization(ParameterInfo parameter);
}
public interface AutoFixture.IRequestMemberTypeResolver {
    public abstract virtual bool TryGetMemberType(object request, Type& memberType);
}
public class AutoFixture.Kernel.AbstractTypeSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.ActionSpecimenCommand`1 : object {
    private Action`2<T, ISpecimenContext> action;
    public ActionSpecimenCommand`1(Action`1<T> action);
    public ActionSpecimenCommand`1(Action`2<T, ISpecimenContext> action);
    public sealed virtual void Execute(object specimen, ISpecimenContext context);
}
public class AutoFixture.Kernel.AndPropertyQuery : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPropertyQuery> <Queries>k__BackingField;
    public IEnumerable`1<IPropertyQuery> Queries { get; }
    public AndPropertyQuery(IPropertyQuery[] queries);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IPropertyQuery> get_Queries();
    public sealed virtual IEnumerable`1<PropertyInfo> SelectProperties(Type type);
}
public class AutoFixture.Kernel.AndRequestSpecification : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRequestSpecification> <Specifications>k__BackingField;
    public IEnumerable`1<IRequestSpecification> Specifications { get; }
    public AndRequestSpecification(IRequestSpecification[] specifications);
    public AndRequestSpecification(IEnumerable`1<IRequestSpecification> specifications);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRequestSpecification> get_Specifications();
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.AnyTypeSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.ArrayFavoringConstructorQuery : object {
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
public class AutoFixture.Kernel.ArrayRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.AsyncEnumerableRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.AutoPropertiesCommand : AutoPropertiesCommand`1<object> {
    [CompilerGeneratedAttribute]
private Type <ExplicitSpecimenType>k__BackingField;
    public Type ExplicitSpecimenType { get; }
    public AutoPropertiesCommand(Type specimenType);
    public AutoPropertiesCommand(IRequestSpecification specification);
    public AutoPropertiesCommand(Type specimenType, IRequestSpecification specification);
    [CompilerGeneratedAttribute]
public Type get_ExplicitSpecimenType();
    protected virtual Type GetSpecimenType(object specimen);
}
[ObsoleteAttribute("The generic version of the AutoPropertiesCommand is no longer used and will be removed in future versions. Please use the non-generic version of the AutoPropertiesCommand type.")]
public class AutoFixture.Kernel.AutoPropertiesCommand`1 : object {
    [CompilerGeneratedAttribute]
private IRequestSpecification <Specification>k__BackingField;
    public IRequestSpecification Specification { get; }
    public AutoPropertiesCommand`1(IRequestSpecification specification);
    [CompilerGeneratedAttribute]
public IRequestSpecification get_Specification();
    [ObsoleteAttribute("This method is no longer used and will be removed in future versions. Please use the Execute(object, ISpecimenContext) overload instead.")]
public sealed virtual void Execute(T specimen, ISpecimenContext context);
    [ObsoleteAttribute("This method is no longer used and will be removed in future versions. Please use the this.Specification.IsSpecifiedBy(request) method instead.")]
public sealed virtual bool IsSatisfiedBy(object request);
    protected virtual Type GetSpecimenType(object specimen);
    private IEnumerable`1<FieldInfo> GetFields(object specimen);
    private IEnumerable`1<PropertyInfo> GetProperties(object specimen);
    public sealed virtual void Execute(object specimen, ISpecimenContext context);
    [CompilerGeneratedAttribute]
private bool <GetFields>b__8_0(FieldInfo fi);
    [CompilerGeneratedAttribute]
private bool <GetProperties>b__9_0(PropertyInfo pi);
}
public class AutoFixture.Kernel.BindingCommand`2 : object {
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ISpecimenContext, TProperty> <ValueCreator>k__BackingField;
    public MemberInfo Member { get; }
    public Func`2<ISpecimenContext, TProperty> ValueCreator { get; }
    public BindingCommand`2(Expression`1<Func`2<T, TProperty>> propertyPicker);
    public BindingCommand`2(Expression`1<Func`2<T, TProperty>> propertyPicker, TProperty propertyValue);
    public BindingCommand`2(Expression`1<Func`2<T, TProperty>> propertyPicker, Func`2<ISpecimenContext, TProperty> valueCreator);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public Func`2<ISpecimenContext, TProperty> get_ValueCreator();
    [ObsoleteAttribute("This method is no longer used and will be removed in future versions. Please use the Execute(object, ISpecimenContext) overload instead.")]
public sealed virtual void Execute(T specimen, ISpecimenContext context);
    [ObsoleteAttribute("This method is no longer used and will be removed in future versions. Please use this.Member property for specification instead.")]
public sealed virtual bool IsSatisfiedBy(object request);
    private TProperty CreateAnonymousValue(ISpecimenContext container);
    public sealed virtual void Execute(object specimen, ISpecimenContext context);
    private static void TrySetValue(object specimen, object value, Type targetType, Action`2<object, object> setValue);
}
[ObsoleteAttribute("This relay has been deprecated, use "new TypeRelay(typeof(ICollection<>), typeof(List<>))" instead.")]
public class AutoFixture.Kernel.CollectionRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
[ObsoleteAttribute("This specification is obsolete. Use ExactTypeSpecification(typeof(Collection<>)) instead.")]
public class AutoFixture.Kernel.CollectionSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.CompositeMethodQuery : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IMethodQuery> <Queries>k__BackingField;
    public IEnumerable`1<IMethodQuery> Queries { get; }
    public CompositeMethodQuery(IEnumerable`1<IMethodQuery> queries);
    public CompositeMethodQuery(IMethodQuery[] queries);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IMethodQuery> get_Queries();
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
public class AutoFixture.Kernel.CompositeSpecimenBuilder : object {
    private ISpecimenBuilder[] composedBuilders;
    public IEnumerable`1<ISpecimenBuilder> Builders { get; }
    public CompositeSpecimenBuilder(IEnumerable`1<ISpecimenBuilder> builders);
    public CompositeSpecimenBuilder(ISpecimenBuilder[] builders);
    public IEnumerable`1<ISpecimenBuilder> get_Builders();
    public sealed virtual object Create(object request, ISpecimenContext context);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static ISpecimenBuilder ComposeIfMultiple(IEnumerable`1<ISpecimenBuilder> builders);
    internal static ISpecimenBuilderNode UnwrapIfSingle(ISpecimenBuilderNode node);
}
public class AutoFixture.Kernel.CompositeSpecimenCommand : object {
    private ISpecimenCommand[] commands;
    public IEnumerable`1<ISpecimenCommand> Commands { get; }
    public CompositeSpecimenCommand(IEnumerable`1<ISpecimenCommand> commands);
    public CompositeSpecimenCommand(ISpecimenCommand[] commands);
    public IEnumerable`1<ISpecimenCommand> get_Commands();
    public sealed virtual void Execute(object specimen, ISpecimenContext context);
}
public class AutoFixture.Kernel.ConstrainedStringRequest : object {
    [CompilerGeneratedAttribute]
private int <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumLength>k__BackingField;
    public int MinimumLength { get; }
    public int MaximumLength { get; }
    public ConstrainedStringRequest(int minimumLength, int maximumLength);
    public ConstrainedStringRequest(int maximumLength);
    [CompilerGeneratedAttribute]
public int get_MinimumLength();
    [CompilerGeneratedAttribute]
public int get_MaximumLength();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ConstrainedStringRequest other);
}
public class AutoFixture.Kernel.ConstructorMethod : object {
    private ParameterInfo[] paramInfos;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    public ConstructorInfo Constructor { get; }
    public IEnumerable`1<ParameterInfo> Parameters { get; }
    public ConstructorMethod(ConstructorInfo constructor);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Constructor();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IEnumerable`1<ParameterInfo> get_Parameters();
    public sealed virtual object Invoke(IEnumerable`1<object> parameters);
    public sealed virtual bool Equals(ConstructorMethod other);
}
public class AutoFixture.Kernel.Criterion`1 : object {
    [CompilerGeneratedAttribute]
private T <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<T> <Comparer>k__BackingField;
    public T Target { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public Criterion`1(T target, IEqualityComparer`1<T> comparer);
    public sealed virtual bool Equals(T other);
    public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public T get_Target();
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<T> get_Comparer();
    public virtual int GetHashCode();
}
public class AutoFixture.Kernel.DelegateGenerator : object {
    [CompilerGeneratedAttribute]
private IRequestSpecification <Specification>k__BackingField;
    public IRequestSpecification Specification { get; }
    public DelegateGenerator(IRequestSpecification delegateSpecification);
    [CompilerGeneratedAttribute]
public IRequestSpecification get_Specification();
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static IEnumerable`1<ParameterExpression> CreateMethodSpecimenParameters(MethodInfo request);
    private static Expression CreateMethodSpecimenBody(MethodInfo request, ISpecimenContext context);
}
public class AutoFixture.Kernel.DelegateSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("This relay has been deprecated, use "new TypeRelay(typeof(IDictionary<>), typeof(Dictionary<>))" instead.")]
public class AutoFixture.Kernel.DictionaryRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
[ObsoleteAttribute("This specification is obsolete. Use ExactTypeSpecification(typeof(Dictionary<,>)) instead.")]
public class AutoFixture.Kernel.DictionarySpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.DirectBaseTypeSpecification : object {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public Type TargetType { get; }
    public DirectBaseTypeSpecification(Type targetType);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    public sealed virtual bool IsSatisfiedBy(object request);
    private static bool IsRequestForType(object request);
    private bool IsTargetTypeOrItsDirectBase(object request);
    private bool IsSameAsTargetType(object request);
    private bool IsDirectBaseOfTargetType(object request);
}
public class AutoFixture.Kernel.DisposableTracker : object {
    private HashSet`1<IDisposable> disposables;
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public IEnumerable`1<IDisposable> Disposables { get; }
    public DisposableTracker(ISpecimenBuilder builder);
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    public IEnumerable`1<IDisposable> get_Disposables();
    public sealed virtual object Create(object request, ISpecimenContext context);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    [IteratorStateMachineAttribute("AutoFixture.Kernel.DisposableTracker/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class AutoFixture.Kernel.DisposableTrackingBehavior : object {
    private List`1<DisposableTracker> trackers;
    public IEnumerable`1<DisposableTracker> Trackers { get; }
    public IEnumerable`1<DisposableTracker> get_Trackers();
    public sealed virtual ISpecimenBuilderNode Transform(ISpecimenBuilder builder);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class AutoFixture.Kernel.EnumerableEnvy : object {
    [ExtensionAttribute]
public static IEnumerable`1<object> ConvertObjectType(IEnumerable`1<object> enumerable, Type type);
}
public class AutoFixture.Kernel.EnumerableFavoringConstructorQuery : object {
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
public class AutoFixture.Kernel.EnumerableRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.EnumeratorRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.EqualRequestSpecification : object {
    [CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer <Comparer>k__BackingField;
    public object Target { get; }
    public IEqualityComparer Comparer { get; }
    public EqualRequestSpecification(object target);
    public EqualRequestSpecification(object target, IEqualityComparer comparer);
    public sealed virtual bool IsSatisfiedBy(object request);
    [CompilerGeneratedAttribute]
public object get_Target();
    [CompilerGeneratedAttribute]
public IEqualityComparer get_Comparer();
}
public class AutoFixture.Kernel.ExactTypeSpecification : object {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public Type TargetType { get; }
    public ExactTypeSpecification(Type type);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    public sealed virtual bool IsSatisfiedBy(object request);
    private bool IsOpenGenericDefinitionEqual(Type request);
}
[ExtensionAttribute]
internal static class AutoFixture.Kernel.ExpressionReflector : object {
    [ExtensionAttribute]
internal static MemberExpression GetWritableMember(LambdaExpression propertyPicker);
    internal static void VerifyIsNonNestedWritableMemberExpression(LambdaExpression expression);
    [ExtensionAttribute]
private static Expression UnwrapIfConversionExpression(Expression exp);
}
public class AutoFixture.Kernel.FactoryMethodQuery : object {
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
public class AutoFixture.Kernel.FalseRequestSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.FieldRequestRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.FieldSpecification : object {
    private Type targetType;
    private string targetName;
    private IEquatable`1<FieldInfo> target;
    [ObsoleteAttribute("This value is only available if the constructor taking a target type and name is used. Otherwise, it'll be null. Use with caution. This property will be removed in a future version of AutoFixture.", "True")]
public Type TargetType { get; }
    [ObsoleteAttribute("This value is only available if the constructor taking a target type and name is used. Otherwise, it'll be null. Use with caution. This property will be removed in a future version of AutoFixture.", "True")]
public string TargetName { get; }
    public FieldSpecification(Type targetType, string targetName);
    public FieldSpecification(IEquatable`1<FieldInfo> target);
    private static IEquatable`1<FieldInfo> CreateDefaultTarget(Type targetType, string targetName);
    public Type get_TargetType();
    public string get_TargetName();
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.FieldTypeAndNameCriterion : object {
    [CompilerGeneratedAttribute]
private IEquatable`1<Type> <TypeCriterion>k__BackingField;
    [CompilerGeneratedAttribute]
private IEquatable`1<string> <NameCriterion>k__BackingField;
    public IEquatable`1<Type> TypeCriterion { get; }
    public IEquatable`1<string> NameCriterion { get; }
    public FieldTypeAndNameCriterion(IEquatable`1<Type> typeCriterion, IEquatable`1<string> nameCriterion);
    public sealed virtual bool Equals(FieldInfo other);
    [CompilerGeneratedAttribute]
public IEquatable`1<Type> get_TypeCriterion();
    [CompilerGeneratedAttribute]
public IEquatable`1<string> get_NameCriterion();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class AutoFixture.Kernel.FilteringSpecimenBuilder : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestSpecification <Specification>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public IRequestSpecification Specification { get; }
    public FilteringSpecimenBuilder(ISpecimenBuilder builder, IRequestSpecification specification);
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    [CompilerGeneratedAttribute]
public IRequestSpecification get_Specification();
    public sealed virtual object Create(object request, ISpecimenContext context);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    [IteratorStateMachineAttribute("AutoFixture.Kernel.FilteringSpecimenBuilder/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class AutoFixture.Kernel.FiniteSequenceRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.FiniteSequenceRequest : object {
    private object request;
    private int count;
    public FiniteSequenceRequest(object request, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public IEnumerable`1<object> CreateRequests();
    public sealed virtual bool Equals(FiniteSequenceRequest other);
}
public class AutoFixture.Kernel.FixedBuilder : object {
    private object specimen;
    public FixedBuilder(object specimen);
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.GenericCollectionPropertyQuery : object {
    public sealed virtual IEnumerable`1<PropertyInfo> SelectProperties(Type type);
}
public class AutoFixture.Kernel.GenericMethod : object {
    private ParameterInfo[] parametersInfo;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodFactory <Factory>k__BackingField;
    public IEnumerable`1<ParameterInfo> Parameters { get; }
    public MethodInfo Method { get; }
    public IMethodFactory Factory { get; }
    public GenericMethod(MethodInfo method, IMethodFactory factory);
    public sealed virtual IEnumerable`1<ParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public IMethodFactory get_Factory();
    private static IEnumerable`1<Tuple`2<Type, Type>> ResolveGenericType(Type argument, Type parameter);
    private static IEnumerable`1<Type> GetTypeArguments(Type type);
    private static MethodInfo InferMethodInfo(MethodInfo methodInfo, IEnumerable`1<object> arguments);
    private static Type GetArgumentTypeOrObjectType(object argument);
    public sealed virtual object Invoke(IEnumerable`1<object> parameters);
}
public class AutoFixture.Kernel.GreedyConstructorQuery : object {
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
[ObsoleteAttribute("This specification is obsolete. Use ExactTypeSpecification(typeof(HashSet<>)) instead.")]
public class AutoFixture.Kernel.HashSetSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.IllegalRequestException : Exception {
    public IllegalRequestException(string message);
    public IllegalRequestException(string message, Exception innerException);
}
public interface AutoFixture.Kernel.IMethod {
    public IEnumerable`1<ParameterInfo> Parameters { get; }
    public abstract virtual IEnumerable`1<ParameterInfo> get_Parameters();
    public abstract virtual object Invoke(IEnumerable`1<object> parameters);
}
public interface AutoFixture.Kernel.IMethodFactory {
    public abstract virtual IMethod Create(MethodInfo methodInfo);
}
public interface AutoFixture.Kernel.IMethodQuery {
    public abstract virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
public class AutoFixture.Kernel.ImplementedInterfaceSpecification : object {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public Type TargetType { get; }
    public ImplementedInterfaceSpecification(Type targetType);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    public sealed virtual bool IsSatisfiedBy(object request);
    private static bool IsRequestForType(object request);
    private bool IsTargetTypeOrImplementedInterface(object request);
    private bool IsSameAsTargetType(object request);
    private bool IsInterfaceImplementedByTargetType(object request);
}
public class AutoFixture.Kernel.InstanceMethod : object {
    private ParameterInfo[] paramInfos;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Owner>k__BackingField;
    public MethodInfo Method { get; }
    public object Owner { get; }
    public IEnumerable`1<ParameterInfo> Parameters { get; }
    public InstanceMethod(MethodInfo instanceMethod, object owner);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public object get_Owner();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IEnumerable`1<ParameterInfo> get_Parameters();
    public sealed virtual object Invoke(IEnumerable`1<object> parameters);
    public sealed virtual bool Equals(InstanceMethod other);
}
public class AutoFixture.Kernel.InstanceMethodQuery : object {
    [CompilerGeneratedAttribute]
private object <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public object Owner { get; }
    public string MethodName { get; }
    public InstanceMethodQuery(object owner, string methodName);
    [CompilerGeneratedAttribute]
public object get_Owner();
    [CompilerGeneratedAttribute]
public string get_MethodName();
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
public class AutoFixture.Kernel.IntPtrGuard : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.InverseRequestSpecification : object {
    [CompilerGeneratedAttribute]
private IRequestSpecification <Specification>k__BackingField;
    public IRequestSpecification Specification { get; }
    public InverseRequestSpecification(IRequestSpecification specification);
    [CompilerGeneratedAttribute]
public IRequestSpecification get_Specification();
    public sealed virtual bool IsSatisfiedBy(object request);
}
public interface AutoFixture.Kernel.IPropertyQuery {
    public abstract virtual IEnumerable`1<PropertyInfo> SelectProperties(Type type);
}
public interface AutoFixture.Kernel.IRecursionHandler {
    public abstract virtual object HandleRecursiveRequest(object request, IEnumerable`1<object> recordedRequests);
}
public interface AutoFixture.Kernel.IRequestSpecification {
    public abstract virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("Use ISpecimenCommand instead of Execute, and IRequestSpecification for the IsSatisfiedBy functionality.", "True")]
public interface AutoFixture.Kernel.ISpecifiedSpecimenCommand`1 {
    public abstract virtual void Execute(T specimen, ISpecimenContext context);
}
public interface AutoFixture.Kernel.ISpecimenBuilder {
    public abstract virtual object Create(object request, ISpecimenContext context);
}
public interface AutoFixture.Kernel.ISpecimenBuilderNode {
    public abstract virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
}
public interface AutoFixture.Kernel.ISpecimenBuilderTransformation {
    public abstract virtual ISpecimenBuilderNode Transform(ISpecimenBuilder builder);
}
public interface AutoFixture.Kernel.ISpecimenCommand {
    public abstract virtual void Execute(object specimen, ISpecimenContext context);
}
public interface AutoFixture.Kernel.ISpecimenContext {
    public abstract virtual object Resolve(object request);
}
public class AutoFixture.Kernel.ListFavoringConstructorQuery : object {
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
[ObsoleteAttribute("This relay has been deprecated, use "new TypeRelay(typeof(IList<>), typeof(List<>))" instead.")]
public class AutoFixture.Kernel.ListRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
[ObsoleteAttribute("This specification is obsolete. Use ExactTypeSpecification(typeof(List<>)) instead.")]
public class AutoFixture.Kernel.ListSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.MemberInfoEqualityComparer : object {
    public sealed virtual bool Equals(MemberInfo x, MemberInfo y);
    public sealed virtual int GetHashCode(MemberInfo obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private static bool AreTypesRelated(Type x, Type y);
}
public class AutoFixture.Kernel.MethodInvoker : object {
    [CompilerGeneratedAttribute]
private IMethodQuery <Query>k__BackingField;
    public IMethodQuery Query { get; }
    public MethodInvoker(IMethodQuery query);
    [CompilerGeneratedAttribute]
public IMethodQuery get_Query();
    public sealed virtual object Create(object request, ISpecimenContext context);
    private IEnumerable`1<IMethod> GetConstructors(object request);
    private static bool IsValueValid(object value);
}
public class AutoFixture.Kernel.MissingParametersSupplyingMethod : object {
    [CompilerGeneratedAttribute]
private IMethod <Method>k__BackingField;
    public IMethod Method { get; }
    public IEnumerable`1<ParameterInfo> Parameters { get; }
    public MissingParametersSupplyingMethod(IMethod method);
    [CompilerGeneratedAttribute]
public IMethod get_Method();
    public sealed virtual IEnumerable`1<ParameterInfo> get_Parameters();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MissingParametersSupplyingMethod other);
    private static IEnumerable`1<object> GetArguments(IEnumerable`1<ParameterInfo> parameters, Object[] arguments);
    private static object GetDefault(ParameterInfo parameter);
    public sealed virtual object Invoke(IEnumerable`1<object> parameters);
}
public class AutoFixture.Kernel.MissingParametersSupplyingMethodFactory : object {
    [CompilerGeneratedAttribute]
private object <Owner>k__BackingField;
    public object Owner { get; }
    public MissingParametersSupplyingMethodFactory(object owner);
    [CompilerGeneratedAttribute]
public object get_Owner();
    public sealed virtual IMethod Create(MethodInfo methodInfo);
}
public class AutoFixture.Kernel.MissingParametersSupplyingStaticMethodFactory : object {
    public sealed virtual IMethod Create(MethodInfo methodInfo);
}
public class AutoFixture.Kernel.ModestConstructorQuery : object {
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
}
public class AutoFixture.Kernel.MultidimensionalArrayRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static bool IsMultidimensionalArray(Type type);
    private static object CreateMultidimensionalArray(Type arrayType, ISpecimenContext context);
    private static Type MakeJaggedArrayType(Type elementType, int dimension);
    private static int GetInnerLength(Array jagged, int dimension);
    private static void Copy(Array array, int dimension, Array jagged, Int32[] indices);
    private static void CopyNextDimension(Array array, int dimension, Array jagged, Int32[] indices);
    private static void CopyLastDimension(Array array, Array jagged, Int32[] indices);
}
public class AutoFixture.Kernel.MultipleRelay : object {
    private int count;
    public int Count { get; public set; }
    public int get_Count();
    public void set_Count(int value);
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.MultipleRequest : object {
    [CompilerGeneratedAttribute]
private object <Request>k__BackingField;
    public object Request { get; }
    public MultipleRequest(object request);
    [CompilerGeneratedAttribute]
public object get_Request();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MultipleRequest other);
}
[ObsoleteAttribute("This relay is obsolete and will be removed in future versions. The reason is that it causes recursion overflow for many requests if you forget to add IEnumerable<T> customization.")]
public class AutoFixture.Kernel.MultipleToEnumerableRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static object GetInnerRequest(MultipleRequest multipleRequest);
}
public class AutoFixture.Kernel.MutableValueTypeWarningThrower : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.NoConstructorsSpecification : object {
    private IMethodQuery modestConstructorQuery;
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.NoSpecimen : object {
    private object request;
    [ObsoleteAttribute("The Request property is being retired in future versions of AutoFixture, as it has turned out that no one uses it. If you're seeing this warning in AutoFixture 3.x, and, despite expectations, have a real need to use the Request property, please provide feedback on https://github.com/AutoFixture/AutoFixture/issues/475.", "True")]
public object Request { get; }
    [ObsoleteAttribute("Use NoSpecimen() instead of NoSpecimen(object). The Request property, and this constructor that populates it, is being retired in future versions of AutoFixture, as it has turned out that no one uses it. You can still use the parameterless NoSpecimen constructor overload. The NoSpecimen class itself will remain. If you're seeing this warning in AutoFixture 3.x, and, despite expectations, have a real need to use the Request property, please provide feedback on https://github.com/AutoFixture/AutoFixture/issues/475 .", "True")]
public NoSpecimen(object request);
    public object get_Request();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NoSpecimen other);
}
public class AutoFixture.Kernel.NoSpecimenOutputGuard : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestSpecification <Specification>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public IRequestSpecification Specification { get; }
    public NoSpecimenOutputGuard(ISpecimenBuilder builder);
    public NoSpecimenOutputGuard(ISpecimenBuilder builder, IRequestSpecification specification);
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    [CompilerGeneratedAttribute]
public IRequestSpecification get_Specification();
    public sealed virtual object Create(object request, ISpecimenContext context);
    public sealed virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    [IteratorStateMachineAttribute("AutoFixture.Kernel.NoSpecimenOutputGuard/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class AutoFixture.Kernel.NullableEnumRequestSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("This class will be removed in a future version of AutoFixture. Instead, use an instance of RecursionGuard, composed with an instance of NullRecursionHandler.", "True")]
public class AutoFixture.Kernel.NullRecursionGuard : RecursionGuard {
    public NullRecursionGuard(ISpecimenBuilder builder);
    public NullRecursionGuard(ISpecimenBuilder builder, IEqualityComparer comparer);
    [ObsoleteAttribute("This class will be removed in a future version of AutoFixture. Instead, use an instance of RecursionGuard, composed with an instance of NullRecursionHandler.", "True")]
public virtual object HandleRecursiveRequest(object request);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
}
public class AutoFixture.Kernel.NullRecursionHandler : object {
    public sealed virtual object HandleRecursiveRequest(object request, IEnumerable`1<object> recordedRequests);
}
[ObsoleteAttribute("This specification is obsolete. Use ExactTypeSpecification(typeof(ObservableCollection<>)) instead.")]
public class AutoFixture.Kernel.ObservableCollectionSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("Remove these shims when target members are completely removed.")]
internal static class AutoFixture.Kernel.ObsoletedMemberShims : object {
    public static object RecursionGuard_HandleRecursiveRequest(RecursionGuard guard, object request);
    public static Action`2<object, ISpecimenContext> Postprocessor_GetAction(Postprocessor postprocessor);
    public static void Postprocessor_SetAction(Postprocessor postprocessor, Action`2<object, ISpecimenContext> action);
}
public class AutoFixture.Kernel.OmitArrayParameterRequestRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.OmitEnumerableParameterRequestRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.OmitFixtureSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("This class will be removed in a future version of AutoFixture. Instead, use an instance of RecursionGuard, composed with an instance of OmitOnRecursionHandler.", "True")]
public class AutoFixture.Kernel.OmitOnRecursionGuard : RecursionGuard {
    public OmitOnRecursionGuard(ISpecimenBuilder builder);
    public OmitOnRecursionGuard(ISpecimenBuilder builder, IEqualityComparer comparer);
    [ObsoleteAttribute("This class will be removed in a future version of AutoFixture. Instead, use an instance of RecursionGuard, composed with an instance of OmitOnRecursionHandler.", "True")]
public virtual object HandleRecursiveRequest(object request);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
}
public class AutoFixture.Kernel.OmitOnRecursionHandler : object {
    public sealed virtual object HandleRecursiveRequest(object request, IEnumerable`1<object> recordedRequests);
}
public class AutoFixture.Kernel.OmitSpecimen : object {
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OmitSpecimen other);
    public virtual int GetHashCode();
}
public class AutoFixture.Kernel.Omitter : object {
    [CompilerGeneratedAttribute]
private IRequestSpecification <Specification>k__BackingField;
    public IRequestSpecification Specification { get; }
    public Omitter(IRequestSpecification specification);
    public sealed virtual object Create(object request, ISpecimenContext context);
    [CompilerGeneratedAttribute]
public IRequestSpecification get_Specification();
}
public class AutoFixture.Kernel.OrRequestSpecification : object {
    private IRequestSpecification[] specifications;
    public IEnumerable`1<IRequestSpecification> Specifications { get; }
    public OrRequestSpecification(IRequestSpecification[] specifications);
    public OrRequestSpecification(IEnumerable`1<IRequestSpecification> specifications);
    public IEnumerable`1<IRequestSpecification> get_Specifications();
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.ParameterRequestRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
internal class AutoFixture.Kernel.ParameterScore : object {
    private int score;
    internal ParameterScore(Type parentType, Type targetType, IEnumerable`1<ParameterInfo> parameters);
    public sealed virtual int CompareTo(ParameterScore other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static int CalculateScore(Type parentType, Type targetType, IEnumerable`1<ParameterInfo> parameters);
    private static bool IsExactMatch(Type targetType, ParameterInfo p);
}
public class AutoFixture.Kernel.ParameterSpecification : object {
    private Type targetType;
    private string targetName;
    private IEquatable`1<ParameterInfo> target;
    [ObsoleteAttribute("This value is only available if the constructor taking a target type and name is used. Otherwise, it'll be null. Use with caution. This property will be removed in a future version of AutoFixture.", "True")]
public Type TargetType { get; }
    [ObsoleteAttribute("This value is only available if the constructor taking a target type and name is used. Otherwise, it'll be null. Use with caution. This property will be removed in a future version of AutoFixture.", "True")]
public string TargetName { get; }
    public ParameterSpecification(Type targetType, string targetName);
    public ParameterSpecification(IEquatable`1<ParameterInfo> target);
    private static IEquatable`1<ParameterInfo> CreateDefaultTarget(Type targetType, string targetName);
    public Type get_TargetType();
    public string get_TargetName();
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.ParameterTypeAndNameCriterion : object {
    [CompilerGeneratedAttribute]
private IEquatable`1<Type> <TypeCriterion>k__BackingField;
    [CompilerGeneratedAttribute]
private IEquatable`1<string> <NameCriterion>k__BackingField;
    public IEquatable`1<Type> TypeCriterion { get; }
    public IEquatable`1<string> NameCriterion { get; }
    public ParameterTypeAndNameCriterion(IEquatable`1<Type> typeCriterion, IEquatable`1<string> nameCriterion);
    public sealed virtual bool Equals(ParameterInfo other);
    [CompilerGeneratedAttribute]
public IEquatable`1<Type> get_TypeCriterion();
    [CompilerGeneratedAttribute]
public IEquatable`1<string> get_NameCriterion();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class AutoFixture.Kernel.Postprocessor : Postprocessor`1<object> {
    [ObsoleteAttribute("Use Postprocessor(ISpecimenBuilder, ISpecimenCommand) instead", "True")]
public Postprocessor(ISpecimenBuilder builder, Action`1<object> action);
    [ObsoleteAttribute("Use Postprocessor(ISpecimenBuilder, ISpecimenCommand) instead", "True")]
public Postprocessor(ISpecimenBuilder builder, Action`2<object, ISpecimenContext> action);
    [ObsoleteAttribute("Use Postprocessor(ISpecimenBuilder, ISpecimenCommand, IRequestSpecification) instead", "True")]
public Postprocessor(ISpecimenBuilder builder, Action`2<object, ISpecimenContext> action, IRequestSpecification specification);
    public Postprocessor(ISpecimenBuilder builder, ISpecimenCommand command);
    public Postprocessor(ISpecimenBuilder builder, ISpecimenCommand command, IRequestSpecification specification);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
}
[ObsoleteAttribute("The generic version of the Postprocessor is no longer used and will be removed in future versions. Please use the non-generic version of the Postprocessor type.")]
public class AutoFixture.Kernel.Postprocessor`1 : object {
    private Action`2<T, ISpecimenContext> action;
    [CompilerGeneratedAttribute]
private ISpecimenCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestSpecification <Specification>k__BackingField;
    [ObsoleteAttribute("Use the Command property instead.", "True")]
public Action`2<T, ISpecimenContext> Action { get; internal set; }
    public ISpecimenCommand Command { get; }
    public ISpecimenBuilder Builder { get; }
    public IRequestSpecification Specification { get; }
    [ObsoleteAttribute("Use Postprocessor(ISpecimenBuilder, ISpecimenCommand) instead", "True")]
public Postprocessor`1(ISpecimenBuilder builder, Action`1<T> action);
    [ObsoleteAttribute("Use Postprocessor(ISpecimenBuilder, ISpecimenCommand) instead", "True")]
public Postprocessor`1(ISpecimenBuilder builder, Action`2<T, ISpecimenContext> action);
    public Postprocessor`1(ISpecimenBuilder builder, ISpecimenCommand command);
    [ObsoleteAttribute("Use Postprocessor(ISpecimenBuilder, ISpecimenCommand, IRequestSpecification) instead", "True")]
public Postprocessor`1(ISpecimenBuilder builder, Action`2<T, ISpecimenContext> action, IRequestSpecification specification);
    public Postprocessor`1(ISpecimenBuilder builder, ISpecimenCommand command, IRequestSpecification specification);
    public Action`2<T, ISpecimenContext> get_Action();
    internal void set_Action(Action`2<T, ISpecimenContext> value);
    [CompilerGeneratedAttribute]
public ISpecimenCommand get_Command();
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    [CompilerGeneratedAttribute]
public IRequestSpecification get_Specification();
    public sealed virtual object Create(object request, ISpecimenContext context);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    [IteratorStateMachineAttribute("AutoFixture.Kernel.Postprocessor`1/<GetEnumerator>d__20")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(T s, ISpecimenContext c);
}
[AttributeUsageAttribute("4")]
internal class AutoFixture.Kernel.PreserveInRequestPathAttribute : Attribute {
}
public class AutoFixture.Kernel.PropertyRequestRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.PropertySpecification : object {
    private Type targetType;
    private string targetName;
    private IEquatable`1<PropertyInfo> target;
    [ObsoleteAttribute("This value is only available if the constructor taking a target type and name is used. Otherwise, it'll be null. Use with caution. This property will be removed in a future version of AutoFixture.", "True")]
public Type TargetType { get; }
    [ObsoleteAttribute("This value is only available if the constructor taking a target type and name is used. Otherwise, it'll be null. Use with caution. This property will be removed in a future version of AutoFixture.", "True")]
public string TargetName { get; }
    public PropertySpecification(Type targetType, string targetName);
    public PropertySpecification(IEquatable`1<PropertyInfo> target);
    private static IEquatable`1<PropertyInfo> CreateDefaultTarget(Type targetType, string targetName);
    public Type get_TargetType();
    public string get_TargetName();
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.PropertyTypeAndNameCriterion : object {
    [CompilerGeneratedAttribute]
private IEquatable`1<Type> <TypeCriterion>k__BackingField;
    [CompilerGeneratedAttribute]
private IEquatable`1<string> <NameCriterion>k__BackingField;
    public IEquatable`1<Type> TypeCriterion { get; }
    public IEquatable`1<string> NameCriterion { get; }
    public PropertyTypeAndNameCriterion(IEquatable`1<Type> typeCriterion, IEquatable`1<string> nameCriterion);
    public sealed virtual bool Equals(PropertyInfo other);
    public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public IEquatable`1<Type> get_TypeCriterion();
    [CompilerGeneratedAttribute]
public IEquatable`1<string> get_NameCriterion();
    public virtual int GetHashCode();
}
[PreserveInRequestPathAttribute]
public class AutoFixture.Kernel.RangedNumberRequest : object {
    [CompilerGeneratedAttribute]
private Type <OperandType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Maximum>k__BackingField;
    public Type OperandType { get; }
    public object Minimum { get; }
    public object Maximum { get; }
    public RangedNumberRequest(Type operandType, object minimum, object maximum);
    [CompilerGeneratedAttribute]
public Type get_OperandType();
    [CompilerGeneratedAttribute]
public object get_Minimum();
    [CompilerGeneratedAttribute]
public object get_Maximum();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RangedNumberRequest other);
    public virtual string ToString();
}
public class AutoFixture.Kernel.RangedSequenceRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static bool TryGetSequenceLength(RangedSequenceRequest rsr, ISpecimenContext ctx, Int32& length);
}
public class AutoFixture.Kernel.RangedSequenceRequest : object {
    [CompilerGeneratedAttribute]
private object <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public object Request { get; }
    public int MinLength { get; }
    public int MaxLength { get; }
    public RangedSequenceRequest(object request, int minLength, int maxLength);
    [CompilerGeneratedAttribute]
public object get_Request();
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    public sealed virtual bool Equals(RangedSequenceRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class AutoFixture.Kernel.ReadonlyCollectionPropertiesCommand : object {
    [CompilerGeneratedAttribute]
private IPropertyQuery <PropertyQuery>k__BackingField;
    public IPropertyQuery PropertyQuery { get; }
    public ReadonlyCollectionPropertiesCommand(IPropertyQuery propertyQuery);
    [CompilerGeneratedAttribute]
public IPropertyQuery get_PropertyQuery();
    public sealed virtual void Execute(object specimen, ISpecimenContext context);
}
public class AutoFixture.Kernel.ReadonlyCollectionPropertiesSpecification : object {
    public static IPropertyQuery DefaultPropertyQuery;
    [CompilerGeneratedAttribute]
private IPropertyQuery <PropertyQuery>k__BackingField;
    public IPropertyQuery PropertyQuery { get; }
    public ReadonlyCollectionPropertiesSpecification(IPropertyQuery propertyQuery);
    private static ReadonlyCollectionPropertiesSpecification();
    [CompilerGeneratedAttribute]
public IPropertyQuery get_PropertyQuery();
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("This relay has been deprecated, use "new TypeRelay(typeof(IReadOnlyCollection<>), typeof(List<>))" instead.")]
public class AutoFixture.Kernel.ReadOnlyCollectionRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.ReadonlyPropertyQuery : object {
    public sealed virtual IEnumerable`1<PropertyInfo> SelectProperties(Type type);
}
public class AutoFixture.Kernel.RecursionGuard : object {
    private ThreadLocal`1<Stack`1<object>> requestsByThread;
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private IRecursionHandler <RecursionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecursionDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer <Comparer>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public IRecursionHandler RecursionHandler { get; }
    public int RecursionDepth { get; }
    public IEqualityComparer Comparer { get; }
    protected IEnumerable RecordedRequests { get; }
    [ObsoleteAttribute("This constructor overload is obsolete and will be removed in a future version of AutoFixture. Please use RecursionGuard(ISpecimenBuilder, IRecursionHandler) instead.", "True")]
public RecursionGuard(ISpecimenBuilder builder);
    public RecursionGuard(ISpecimenBuilder builder, IRecursionHandler recursionHandler);
    public RecursionGuard(ISpecimenBuilder builder, IRecursionHandler recursionHandler, int recursionDepth);
    [ObsoleteAttribute("This constructor overload is obsolete and will be removed in a future version of AutoFixture. Please use RecursionGuard(ISpecimenBuilder, IRecursionHandler, IEqualityComparer, int) instead.", "True")]
public RecursionGuard(ISpecimenBuilder builder, IEqualityComparer comparer);
    [ObsoleteAttribute("This constructor overload is obsolete and will be removed in a future version of AutoFixture. Please use RecursionGuard(ISpecimenBuilder, IRecursionHandler, IEqualityComparer, int) instead.", "True")]
public RecursionGuard(ISpecimenBuilder builder, IRecursionHandler recursionHandler, IEqualityComparer comparer);
    public RecursionGuard(ISpecimenBuilder builder, IRecursionHandler recursionHandler, IEqualityComparer comparer, int recursionDepth);
    private Stack`1<object> GetMonitoredRequestsForCurrentThread();
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    [CompilerGeneratedAttribute]
public IRecursionHandler get_RecursionHandler();
    [CompilerGeneratedAttribute]
public int get_RecursionDepth();
    [CompilerGeneratedAttribute]
public IEqualityComparer get_Comparer();
    protected IEnumerable get_RecordedRequests();
    [ObsoleteAttribute("This method will be removed in a future version of AutoFixture. Use IRecursionHandler.HandleRecursiveRequest instead.", "True")]
public virtual object HandleRecursiveRequest(object request);
    public sealed virtual object Create(object request, ISpecimenContext context);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    [IteratorStateMachineAttribute("AutoFixture.Kernel.RecursionGuard/<GetEnumerator>d__25")]
public virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class AutoFixture.Kernel.RegularExpressionRequest : object {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; }
    public RegularExpressionRequest(string pattern);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RegularExpressionRequest other);
}
public class AutoFixture.Kernel.RequestTraceEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Request>k__BackingField;
    public int Depth { get; }
    public object Request { get; }
    public RequestTraceEventArgs(object request, int depth);
    [CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public object get_Request();
}
public class AutoFixture.Kernel.SeededFactory`1 : object {
    [CompilerGeneratedAttribute]
private Func`2<T, T> <Factory>k__BackingField;
    public Func`2<T, T> Factory { get; }
    public SeededFactory`1(Func`2<T, T> factory);
    [CompilerGeneratedAttribute]
public Func`2<T, T> get_Factory();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.SeededRequest : object {
    [CompilerGeneratedAttribute]
private object <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Request>k__BackingField;
    public object Seed { get; }
    public object Request { get; }
    public SeededRequest(object request, object seed);
    [CompilerGeneratedAttribute]
public object get_Seed();
    [CompilerGeneratedAttribute]
public object get_Request();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SeededRequest other);
}
public class AutoFixture.Kernel.SeedIgnoringRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.SeedRequestSpecification : object {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public Type TargetType { get; }
    public SeedRequestSpecification(Type type);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("This specification is obsolete. Use ExactTypeSpecification(typeof(SortedDictionary<,>)) instead.")]
public class AutoFixture.Kernel.SortedDictionarySpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("This specification is obsolete. Use ExactTypeSpecification(typeof(SortedList<,>)) instead.")]
public class AutoFixture.Kernel.SortedListSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("This specification is obsolete. Use ExactTypeSpecification(typeof(SortedSet<>)) instead.")]
public class AutoFixture.Kernel.SortedSetSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ObsoleteAttribute("This class is no longer used, and will be removed in future versions.", "True")]
public class AutoFixture.Kernel.SpecifiedNullCommand`2 : object {
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    public MemberInfo Member { get; }
    public SpecifiedNullCommand`2(Expression`1<Func`2<T, TProperty>> propertyPicker);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    public sealed virtual void Execute(T specimen, ISpecimenContext context);
    public sealed virtual bool IsSatisfiedBy(object request);
}
[ExtensionAttribute]
public static class AutoFixture.Kernel.SpecimenBuilderNode : object {
    [ExtensionAttribute]
public static bool GraphEquals(ISpecimenBuilderNode first, ISpecimenBuilderNode second);
    [ExtensionAttribute]
public static bool GraphEquals(ISpecimenBuilderNode first, ISpecimenBuilderNode second, IEqualityComparer`1<ISpecimenBuilder> comparer);
    [ExtensionAttribute]
internal static ISpecimenBuilderNode ReplaceNodes(ISpecimenBuilderNode graph, IEnumerable`1<ISpecimenBuilder> with, Func`2<ISpecimenBuilderNode, bool> when);
    [ExtensionAttribute]
internal static ISpecimenBuilderNode ReplaceNodes(ISpecimenBuilderNode graph, ISpecimenBuilderNode with, Func`2<ISpecimenBuilderNode, bool> when);
    [ExtensionAttribute]
internal static ISpecimenBuilderNode ReplaceNodes(ISpecimenBuilderNode graph, Func`2<ISpecimenBuilderNode, ISpecimenBuilderNode> with, Func`2<ISpecimenBuilderNode, bool> when);
    [ExtensionAttribute]
internal static ISpecimenBuilderNode FindFirstNodeOrDefault(ISpecimenBuilderNode graph, Func`2<ISpecimenBuilderNode, bool> predicate);
    [ExtensionAttribute]
internal static ISpecimenBuilderNode FindFirstNode(ISpecimenBuilderNode graph, Func`2<ISpecimenBuilderNode, bool> predicate);
}
public static class AutoFixture.Kernel.SpecimenBuilderNodeFactory : object {
    public static NodeComposer`1<T> CreateComposer();
    public static FilteringSpecimenBuilder CreateTypedNode(Type targetType, ISpecimenBuilder factory);
}
public class AutoFixture.Kernel.SpecimenContext : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public SpecimenContext(ISpecimenBuilder builder);
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    public sealed virtual object Resolve(object request);
}
public class AutoFixture.Kernel.SpecimenCreatedEventArgs : RequestTraceEventArgs {
    [CompilerGeneratedAttribute]
private object <Specimen>k__BackingField;
    public object Specimen { get; }
    public SpecimenCreatedEventArgs(object request, object specimen, int depth);
    [CompilerGeneratedAttribute]
public object get_Specimen();
}
public class AutoFixture.Kernel.SpecimenFactory`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<T> <Factory>k__BackingField;
    public Func`1<T> Factory { get; }
    public SpecimenFactory`1(Func`1<T> factory);
    [CompilerGeneratedAttribute]
public Func`1<T> get_Factory();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.SpecimenFactory`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<TInput, T> <Factory>k__BackingField;
    public Func`2<TInput, T> Factory { get; }
    public SpecimenFactory`2(Func`2<TInput, T> factory);
    [CompilerGeneratedAttribute]
public Func`2<TInput, T> get_Factory();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.SpecimenFactory`3 : object {
    [CompilerGeneratedAttribute]
private Func`3<TInput1, TInput2, T> <Factory>k__BackingField;
    public Func`3<TInput1, TInput2, T> Factory { get; }
    public SpecimenFactory`3(Func`3<TInput1, TInput2, T> factory);
    [CompilerGeneratedAttribute]
public Func`3<TInput1, TInput2, T> get_Factory();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.SpecimenFactory`4 : object {
    [CompilerGeneratedAttribute]
private Func`4<TInput1, TInput2, TInput3, T> <Factory>k__BackingField;
    public Func`4<TInput1, TInput2, TInput3, T> Factory { get; }
    public SpecimenFactory`4(Func`4<TInput1, TInput2, TInput3, T> factory);
    [CompilerGeneratedAttribute]
public Func`4<TInput1, TInput2, TInput3, T> get_Factory();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.SpecimenFactory`5 : object {
    [CompilerGeneratedAttribute]
private Func`5<TInput1, TInput2, TInput3, TInput4, T> <Factory>k__BackingField;
    public Func`5<TInput1, TInput2, TInput3, TInput4, T> Factory { get; }
    public SpecimenFactory`5(Func`5<TInput1, TInput2, TInput3, TInput4, T> factory);
    [CompilerGeneratedAttribute]
public Func`5<TInput1, TInput2, TInput3, TInput4, T> get_Factory();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.StableFiniteSequenceRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.StaticMethod : object {
    private ParameterInfo[] paramInfos;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; }
    public IEnumerable`1<ParameterInfo> Parameters { get; }
    public StaticMethod(MethodInfo methodInfo);
    public StaticMethod(MethodInfo methodInfo, ParameterInfo[] methodParameters);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public sealed virtual IEnumerable`1<ParameterInfo> get_Parameters();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual object Invoke(IEnumerable`1<object> parameters);
    public sealed virtual bool Equals(StaticMethod other);
    private static ParameterInfo[] GetMethodParameters(MethodInfo methodInfo);
}
public class AutoFixture.Kernel.TemplateMethodQuery : object {
    [CompilerGeneratedAttribute]
private MethodInfo <Template>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Owner>k__BackingField;
    public MethodInfo Template { get; }
    public object Owner { get; }
    public TemplateMethodQuery(MethodInfo template);
    public TemplateMethodQuery(MethodInfo template, object owner);
    [CompilerGeneratedAttribute]
public MethodInfo get_Template();
    [CompilerGeneratedAttribute]
public object get_Owner();
    public sealed virtual IEnumerable`1<IMethod> SelectMethods(Type type);
    private IMethodFactory GetMethodFactory(MethodInfo method);
    private bool Compare(Type parameterType, Type templateParameterType);
    private static Type[] GetTypeArguments(Type type);
    [CompilerGeneratedAttribute]
private bool <SelectMethods>b__8_0(MethodInfo method);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType6`2<<>f__AnonymousType5`2<MethodInfo, ParameterInfo[]>, ParameterInfo[]> <SelectMethods>b__8_2(<>f__AnonymousType5`2<MethodInfo, ParameterInfo[]> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private bool <SelectMethods>b__8_6(<>f__AnonymousType7`2<<>f__AnonymousType6`2<<>f__AnonymousType5`2<MethodInfo, ParameterInfo[]>, ParameterInfo[]>, LateBindingParameterScore> <>h__TransparentIdentifier2);
    [CompilerGeneratedAttribute]
private GenericMethod <SelectMethods>b__8_7(<>f__AnonymousType7`2<<>f__AnonymousType6`2<<>f__AnonymousType5`2<MethodInfo, ParameterInfo[]>, ParameterInfo[]>, LateBindingParameterScore> <>h__TransparentIdentifier2);
}
public class AutoFixture.Kernel.TerminatingSpecimenBuilder : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.Kernel.TerminatingWithPathSpecimenBuilder : object {
    private ThreadLocal`1<Stack`1<object>> requestsByThread;
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    private static string TypeMappingOptionsHelp;
    public ISpecimenBuilder Builder { get; }
    public IEnumerable`1<object> SpecimenRequests { get; }
    public TerminatingWithPathSpecimenBuilder(ISpecimenBuilder builder);
    private Stack`1<object> GetPathForCurrentThread();
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    public IEnumerable`1<object> get_SpecimenRequests();
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static string BuildCoreMessageTemplate(object request, Exception innerException);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    [IteratorStateMachineAttribute("AutoFixture.Kernel.TerminatingWithPathSpecimenBuilder/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("This class will be removed in a future version of AutoFixture. Instead, use an instance of RecursionGuard, composed with an instance of ThrowingRecursionHandler.", "True")]
public class AutoFixture.Kernel.ThrowingRecursionGuard : RecursionGuard {
    public ThrowingRecursionGuard(ISpecimenBuilder builder, IEqualityComparer comparer);
    public ThrowingRecursionGuard(ISpecimenBuilder builder);
    [ObsoleteAttribute("This class will be removed in a future version of AutoFixture. Instead, use an instance of RecursionGuard, composed with an instance of ThrowingRecursionHandler.", "True")]
public virtual object HandleRecursiveRequest(object request);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
}
public class AutoFixture.Kernel.ThrowingRecursionHandler : object {
    public sealed virtual object HandleRecursiveRequest(object request, IEnumerable`1<object> recordedRequests);
}
public class AutoFixture.Kernel.TraceWriter : object {
    private TextWriter writer;
    private Action`3<TextWriter, object, int> writeRequest;
    private Action`3<TextWriter, object, int> writeSpecimen;
    [CompilerGeneratedAttribute]
private TracingBuilder <Tracer>k__BackingField;
    public TracingBuilder Tracer { get; }
    public Action`3<TextWriter, object, int> TraceRequestFormatter { get; public set; }
    public Action`3<TextWriter, object, int> TraceSpecimenFormatter { get; public set; }
    public TraceWriter(TextWriter writer, TracingBuilder tracer);
    [CompilerGeneratedAttribute]
public TracingBuilder get_Tracer();
    public Action`3<TextWriter, object, int> get_TraceRequestFormatter();
    public void set_TraceRequestFormatter(Action`3<TextWriter, object, int> value);
    public Action`3<TextWriter, object, int> get_TraceSpecimenFormatter();
    public void set_TraceSpecimenFormatter(Action`3<TextWriter, object, int> value);
    public sealed virtual object Create(object request, ISpecimenContext context);
    public virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    [IteratorStateMachineAttribute("AutoFixture.Kernel.TraceWriter/<GetEnumerator>d__15")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class AutoFixture.Kernel.TracingBuilder : object {
    private IRequestSpecification filter;
    private int depth;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestTraceEventArgs> SpecimenRequested;
    [CompilerGeneratedAttribute]
private EventHandler`1<SpecimenCreatedEventArgs> SpecimenCreated;
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public IRequestSpecification Filter { get; public set; }
    public TracingBuilder(ISpecimenBuilder builder);
    [CompilerGeneratedAttribute]
public void add_SpecimenRequested(EventHandler`1<RequestTraceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SpecimenRequested(EventHandler`1<RequestTraceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SpecimenCreated(EventHandler`1<SpecimenCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SpecimenCreated(EventHandler`1<SpecimenCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    public IRequestSpecification get_Filter();
    public void set_Filter(IRequestSpecification value);
    public sealed virtual object Create(object request, ISpecimenContext context);
    protected virtual void OnSpecimenCreated(SpecimenCreatedEventArgs e);
    protected virtual void OnSpecimenRequested(RequestTraceEventArgs e);
}
public class AutoFixture.Kernel.TrueRequestSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.TypeArgumentsCannotBeInferredException : Exception {
    public TypeArgumentsCannotBeInferredException(MethodInfo methodInfo);
    public TypeArgumentsCannotBeInferredException(string message);
    public TypeArgumentsCannotBeInferredException(string message, Exception innerException);
    private static string GetFriendlyName(Type type);
}
[ExtensionAttribute]
internal static class AutoFixture.Kernel.TypeEnvy : object {
    public static TAttribute GetAttribute(object candidate);
    [ExtensionAttribute]
public static bool TryGetSingleGenericTypeArgument(Type currentType, Type expectedGenericDefinition, Type& argument);
    [ExtensionAttribute]
public static bool IsNumberType(Type type);
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
}
public class AutoFixture.Kernel.TypeRelay : object {
    private IRequestSpecification fromSpecification;
    [CompilerGeneratedAttribute]
private Type <From>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <To>k__BackingField;
    public Type From { get; }
    public Type To { get; }
    public TypeRelay(Type from, Type to);
    [CompilerGeneratedAttribute]
public Type get_From();
    [CompilerGeneratedAttribute]
public Type get_To();
    public sealed virtual object Create(object request, ISpecimenContext context);
    private Type GetRedirectedTypeRequest(Type originalRequest);
}
[ObsoleteAttribute("This class is no longer used, and will be removed in future versions.", "True")]
public class AutoFixture.Kernel.UnspecifiedSpecimenCommand`1 : object {
    [CompilerGeneratedAttribute]
private Action`1<T> <Action>k__BackingField;
    public Action`1<T> Action { get; }
    public UnspecifiedSpecimenCommand`1(Action`1<T> action);
    [CompilerGeneratedAttribute]
public Action`1<T> get_Action();
    public sealed virtual void Execute(T specimen, ISpecimenContext context);
    public sealed virtual bool IsSatisfiedBy(object request);
}
public class AutoFixture.Kernel.ValueTypeSpecification : object {
    public sealed virtual bool IsSatisfiedBy(object request);
    private static bool IsValueTypeButNotPrimitiveOrEnum(Type type);
}
public class AutoFixture.LambdaExpressionGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.LazyRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.MailAddressGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static object TryCreateMailAddress(ISpecimenContext context);
}
[ObsoleteAttribute("This relay is obsolete and will be removed in future versions. The reason is that it causes recursion overflow for "many" requests if you forget to add IEnumerable<T> customization.
Please use the following code snippet instead:
fixture.Customizations.Add(  new FilteringSpecimenBuilder(    new FixedBuilder(      SEQUENCE_TO_RETURN),    new EqualRequestSpecification(      new MultipleRequest(        new SeededRequest(          typeof(T),          default(T))))));

If you need that often, please create an extension method inside your project.")]
public class AutoFixture.MapCreateManyToEnumerable : object {
    public sealed virtual void Customize(IFixture fixture);
}
[ObsoleteAttribute("This customization is no longer needed as builders are available out-of-the-box. It will be removed in future version of AutoFixture.")]
public class AutoFixture.MultipleCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.MutableValueTypeGenerator : object {
    private IRequestSpecification valueTypeWithoutConstructorsSpecification;
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.NoAutoPropertiesCustomization : object {
    private Type targetType;
    public NoAutoPropertiesCustomization(Type targetType);
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.NullRecursionBehavior : object {
    private static int DefaultRecursionDepth;
    private int recursionDepth;
    public NullRecursionBehavior(int recursionDepth);
    public sealed virtual ISpecimenBuilderNode Transform(ISpecimenBuilder builder);
}
public class AutoFixture.NumericSequenceGenerator : object {
    private long value;
    public sealed virtual object Create(object request, ISpecimenContext context);
    private object CreateNumericSpecimen(Type request);
    private long GetNextNumber();
}
public class AutoFixture.NumericSequencePerTypeCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.ObjectCreationException : Exception {
    public ObjectCreationException(string message);
    public ObjectCreationException(string message, Exception innerException);
}
internal class AutoFixture.ObjectCreationExceptionWithPath : ObjectCreationException {
    public ObjectCreationExceptionWithPath(string message);
    public ObjectCreationExceptionWithPath(string message, IEnumerable`1<object> requests);
    public ObjectCreationExceptionWithPath(string message, Exception innerException);
    public ObjectCreationExceptionWithPath(string message, IEnumerable`1<object> requests, Exception innerException);
    private static string FormatRequestsPath(IEnumerable`1<object> requests);
    private static bool ShouldDisplayRequestInPath(object request);
    private static string FormatInnerExceptionMessages(Exception ex);
    private static string Indent(int level);
}
public class AutoFixture.OmitOnRecursionBehavior : object {
    private static int DefaultRecursionDepth;
    private int recursionDepth;
    public OmitOnRecursionBehavior(int recursionDepth);
    public sealed virtual ISpecimenBuilderNode Transform(ISpecimenBuilder builder);
}
public class AutoFixture.RandomBooleanSequenceCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.RandomBooleanSequenceGenerator : object {
    private RandomNumericSequenceGenerator randomBooleanNumbers;
    public sealed virtual object Create(object request, ISpecimenContext context);
    private bool GenerateBoolean(ISpecimenContext context);
}
public class AutoFixture.RandomCharSequenceGenerator : object {
    private RandomNumericSequenceGenerator randomPrintableCharNumbers;
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.RandomDateTimeSequenceGenerator : object {
    private RandomNumericSequenceGenerator randomizer;
    public RandomDateTimeSequenceGenerator(DateTime minDate, DateTime maxDate);
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static bool IsNotDateTimeRequest(object request);
    private object CreateRandomDate(ISpecimenContext context);
    private long GetRandomNumberOfTicks(ISpecimenContext context);
}
[ObsoleteAttribute("The RandomNumericSequenceGenerator is now used by default, therefore this customization is no longer needed and will be removed in future versions of AutoFixture.")]
public class AutoFixture.RandomNumericSequenceCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.RandomNumericSequenceGenerator : object {
    private Int64[] limits;
    private object syncRoot;
    private Random random;
    private HashSet`1<long> numbers;
    private long lower;
    private long upper;
    private long count;
    public IEnumerable`1<long> Limits { get; }
    public RandomNumericSequenceGenerator(IEnumerable`1<long> limits);
    public RandomNumericSequenceGenerator(Int64[] limits);
    public IEnumerable`1<long> get_Limits();
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static void ValidateThatLimitsAreStrictlyAscending(Int64[] limits);
    private object CreateRandom(Type request);
    private long GetNextRandom();
    private void EvaluateRange();
    private void CreateRange();
    private long GetUpperRangeFromLimits();
    private long GetNextInt64InRange();
    [CompilerGeneratedAttribute]
private bool <CreateRange>b__17_0(long x);
}
[ObsoleteAttribute("The RandomRangedNumberGenerator is now used by default, therefore this customization is no longer needed and will be removed in future versions of AutoFixture.")]
public class AutoFixture.RandomRangedNumberCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.RandomRangedNumberGenerator : object {
    private ConcurrentDictionary`2<RangedNumberRequest, ISpecimenBuilder> generatorMap;
    public sealed virtual object Create(object request, ISpecimenContext context);
    private ISpecimenBuilder SelectGenerator(RangedNumberRequest request);
    private static ISpecimenBuilder CreateRandomGenerator(RangedNumberRequest request);
}
public class AutoFixture.RangedNumberGenerator : object {
    private object syncRoot;
    private object rangedValue;
    public sealed virtual object Create(object request, ISpecimenContext context);
    private void CreateAnonymous(RangedNumberRequest range, IComparable value);
    private static object Add(object a, object b);
    private static TypeCode GetTypeCode(object request);
}
public class AutoFixture.ReadonlyCollectionPropertiesBehavior : object {
    [CompilerGeneratedAttribute]
private IPropertyQuery <PropertyQuery>k__BackingField;
    public IPropertyQuery PropertyQuery { get; }
    public ReadonlyCollectionPropertiesBehavior(IPropertyQuery propertyQuery);
    [CompilerGeneratedAttribute]
public IPropertyQuery get_PropertyQuery();
    public sealed virtual ISpecimenBuilderNode Transform(ISpecimenBuilder builder);
}
public class AutoFixture.RegularExpressionGenerator : object {
    private Random random;
    private object syncRoot;
    public sealed virtual object Create(object request, ISpecimenContext context);
    private object GenerateRegularExpression(RegularExpressionRequest request);
    private int GenerateSeed();
}
public class AutoFixture.RequestMemberTypeResolver : object {
    public sealed virtual bool TryGetMemberType(object request, Type& memberType);
}
public class AutoFixture.ResidueCollectorNode : object {
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public ISpecimenBuilder Builder { get; }
    public ResidueCollectorNode(ISpecimenBuilder builder);
    public sealed virtual ISpecimenBuilderNode Compose(IEnumerable`1<ISpecimenBuilder> builders);
    public sealed virtual object Create(object request, ISpecimenContext context);
    [IteratorStateMachineAttribute("AutoFixture.ResidueCollectorNode/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
}
public class AutoFixture.SByteSequenceGenerator : object {
    private sbyte s;
    private object syncRoot;
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public sbyte Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
[CLSCompliantAttribute("False")]
public sbyte CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.SingleSequenceGenerator : object {
    private float f;
    private object syncRoot;
    [ObsoleteAttribute("Please use the Create(request, context) method as this overload will be removed to make API uniform.")]
public float Create();
    [ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public float CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.SingletonSpecimenBuilderNodeStackAdapterCollection : Collection`1<ISpecimenBuilderTransformation> {
    private Func`2<ISpecimenBuilderNode, bool> isWrappedGraph;
    [CompilerGeneratedAttribute]
private EventHandler`1<SpecimenBuilderNodeEventArgs> GraphChanged;
    [CompilerGeneratedAttribute]
private ISpecimenBuilderNode <Graph>k__BackingField;
    public ISpecimenBuilderNode Graph { get; private set; }
    public SingletonSpecimenBuilderNodeStackAdapterCollection(ISpecimenBuilderNode graph, Func`2<ISpecimenBuilderNode, bool> wrappedGraphPredicate, ISpecimenBuilderTransformation[] transformations);
    [CompilerGeneratedAttribute]
public void add_GraphChanged(EventHandler`1<SpecimenBuilderNodeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GraphChanged(EventHandler`1<SpecimenBuilderNodeEventArgs> value);
    [CompilerGeneratedAttribute]
public ISpecimenBuilderNode get_Graph();
    [CompilerGeneratedAttribute]
private void set_Graph(ISpecimenBuilderNode value);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, ISpecimenBuilderTransformation item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, ISpecimenBuilderTransformation item);
    protected virtual void OnGraphChanged(SpecimenBuilderNodeEventArgs e);
    private void UpdateGraph();
}
[DefaultMemberAttribute("Item")]
public class AutoFixture.SpecimenBuilderNodeAdapterCollection : object {
    private Func`2<ISpecimenBuilderNode, bool> isAdaptedBuilder;
    private ISpecimenBuilderNode adaptedBuilderNode;
    private ISpecimenBuilderNode graph;
    [CompilerGeneratedAttribute]
private EventHandler`1<SpecimenBuilderNodeEventArgs> GraphChanged;
    private ISpecimenBuilderNode AdaptedBuilderNode { get; }
    private IEnumerable`1<ISpecimenBuilder> AdaptedBuilders { get; }
    public ISpecimenBuilder Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ISpecimenBuilderNode Graph { get; private set; }
    public SpecimenBuilderNodeAdapterCollection(ISpecimenBuilderNode graph, Func`2<ISpecimenBuilderNode, bool> adaptedBuilderPredicate);
    private ISpecimenBuilderNode get_AdaptedBuilderNode();
    private void InvalidateCachedAdaptedBuilderNode();
    private IEnumerable`1<ISpecimenBuilder> get_AdaptedBuilders();
    [CompilerGeneratedAttribute]
public void add_GraphChanged(EventHandler`1<SpecimenBuilderNodeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GraphChanged(EventHandler`1<SpecimenBuilderNodeEventArgs> value);
    public sealed virtual int IndexOf(ISpecimenBuilder item);
    public sealed virtual void Insert(int index, ISpecimenBuilder item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual ISpecimenBuilder get_Item(int index);
    public sealed virtual void set_Item(int index, ISpecimenBuilder value);
    public sealed virtual void Add(ISpecimenBuilder item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ISpecimenBuilder item);
    public sealed virtual void CopyTo(ISpecimenBuilder[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(ISpecimenBuilder item);
    public sealed virtual IEnumerator`1<ISpecimenBuilder> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ISpecimenBuilderNode get_Graph();
    private void set_Graph(ISpecimenBuilderNode value);
    protected virtual void OnGraphChanged(SpecimenBuilderNodeEventArgs e);
    private void Mutate(IEnumerable`1<ISpecimenBuilder> builders);
    private ISpecimenBuilderNode FindAdaptedSpecimenBuilderNode();
}
public class AutoFixture.SpecimenBuilderNodeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ISpecimenBuilderNode <Graph>k__BackingField;
    public ISpecimenBuilderNode Graph { get; }
    public SpecimenBuilderNodeEventArgs(ISpecimenBuilderNode graph);
    [CompilerGeneratedAttribute]
public ISpecimenBuilderNode get_Graph();
}
[ExtensionAttribute]
public static class AutoFixture.SpecimenCommand : object {
    [ExtensionAttribute]
public static void Do(ISpecimenBuilder builder, Action`1<T> action);
    [ExtensionAttribute]
public static void Do(ISpecimenBuilder builder, Action`2<T1, T2> action);
    [ExtensionAttribute]
public static void Do(ISpecimenBuilder builder, Action`3<T1, T2, T3> action);
    [ExtensionAttribute]
public static void Do(ISpecimenBuilder builder, Action`4<T1, T2, T3, T4> action);
}
[ExtensionAttribute]
public static class AutoFixture.SpecimenFactory : object {
    [ExtensionAttribute]
public static T Create(ISpecimenContext context);
    [ExtensionAttribute]
[ObsoleteAttribute("Please move over to using Create<T>() as this method will be removed in the next release", "True")]
public static T CreateAnonymous(ISpecimenContext context);
    [ExtensionAttribute]
[ObsoleteAttribute("For compatibility to AutoFixture version 2. This method will be removed, please move to using Create<T>()", "True")]
public static T CreateAnonymous(IFixture fixture);
    [ExtensionAttribute]
public static T Create(ISpecimenBuilder builder);
    [ExtensionAttribute]
public static T Create(IPostprocessComposer`1<T> composer);
    [ExtensionAttribute]
[ObsoleteAttribute("Please move over to using Create<T>() as this method will be removed in the next release", "True")]
public static T CreateAnonymous(IPostprocessComposer`1<T> composer);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateMany(ISpecimenBuilder builder);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateMany(ISpecimenContext context);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateMany(IPostprocessComposer`1<T> composer);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateMany(ISpecimenBuilder builder, int count);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateMany(ISpecimenContext context, int count);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateMany(IPostprocessComposer`1<T> composer, int count);
    [ExtensionAttribute]
internal static object Create(ISpecimenBuilder composer, Type type);
    internal static IEnumerable`1<object> CreateMany(ISpecimenContext context, Type type);
    [ExtensionAttribute]
private static ISpecimenContext CreateContext(ISpecimenBuilder builder);
}
[ExtensionAttribute]
public static class AutoFixture.SpecimenQuery : object {
    [ExtensionAttribute]
public static TResult Get(ISpecimenBuilder builder, Func`2<T, TResult> function);
    [ExtensionAttribute]
public static TResult Get(ISpecimenBuilder builder, Func`3<T1, T2, TResult> function);
    [ExtensionAttribute]
public static TResult Get(ISpecimenBuilder builder, Func`4<T1, T2, T3, TResult> function);
    [ExtensionAttribute]
public static TResult Get(ISpecimenBuilder builder, Func`5<T1, T2, T3, T4, TResult> function);
}
[ObsoleteAttribute("The StableFiniteSequenceRelay is now used by default, therefore this customization is no longer needed and will be removed in future versions of AutoFixture.")]
public class AutoFixture.StableFiniteSequenceCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.StrictlyMonotonicallyIncreasingDateTimeGenerator : object {
    private DateTime seed;
    private int baseValue;
    public StrictlyMonotonicallyIncreasingDateTimeGenerator(DateTime seed);
    public sealed virtual object Create(object request, ISpecimenContext context);
    private int GetNextNumberInSequence();
}
public class AutoFixture.StringGenerator : object {
    [CompilerGeneratedAttribute]
private Func`1<object> <Factory>k__BackingField;
    public Func`1<object> Factory { get; }
    public StringGenerator(Func`1<object> specimenFactory);
    [CompilerGeneratedAttribute]
public Func`1<object> get_Factory();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.StringSeedRelay : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.SupportMutableValueTypesCustomization : object {
    public sealed virtual void Customize(IFixture fixture);
}
public class AutoFixture.TaskGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static object CreateGenericTask(Type resultType, ISpecimenContext context);
    private static object CreateNonGenericTask();
    private static object CreateTask(Type resultType, object result);
}
public class AutoFixture.ThrowingRecursionBehavior : object {
    public sealed virtual ISpecimenBuilderNode Transform(ISpecimenBuilder builder);
}
public class AutoFixture.TracingBehavior : object {
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    public TextWriter Writer { get; }
    public TracingBehavior(TextWriter writer);
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    public sealed virtual ISpecimenBuilderNode Transform(ISpecimenBuilder builder);
}
public class AutoFixture.TypeGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.UInt16SequenceGenerator : object {
    private ushort u;
    private object syncRoot;
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public ushort CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.UInt32SequenceGenerator : object {
    private object syncRoot;
    private UInt32 u;
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public UInt32 CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.UInt64SequenceGenerator : object {
    private object syncRoot;
    private ulong u;
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Please move over to using Create() as this method will be removed in the next release", "True")]
public ulong CreateAnonymous();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.UnwrapMemberRequest : object {
    private IRequestMemberTypeResolver requestMemberTypeResolver;
    [CompilerGeneratedAttribute]
private ISpecimenBuilder <Builder>k__BackingField;
    public IRequestMemberTypeResolver MemberTypeResolver { get; public set; }
    public ISpecimenBuilder Builder { get; }
    public UnwrapMemberRequest(ISpecimenBuilder builder);
    public IRequestMemberTypeResolver get_MemberTypeResolver();
    public void set_MemberTypeResolver(IRequestMemberTypeResolver value);
    [CompilerGeneratedAttribute]
public ISpecimenBuilder get_Builder();
    public sealed virtual object Create(object request, ISpecimenContext context);
}
public class AutoFixture.UriGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
    private static Uri MakeUri(UriScheme scheme, string authority);
}
public class AutoFixture.UriScheme : object {
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    public string Scheme { get; }
    public UriScheme(string scheme);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public string get_Scheme();
    public sealed virtual bool Equals(UriScheme other);
    private static bool IsValid(string scheme);
}
public class AutoFixture.UriSchemeGenerator : object {
    public sealed virtual object Create(object request, ISpecimenContext context);
}
[ObsoleteAttribute("Please use a 'AutoFixture.Kernel.FilteringSpecimenBuilder' instead.", "True")]
public class AutoFixture.Utf8EncodingGenerator : object {
    private ExactTypeSpecification encodingTypeSpecification;
    public sealed virtual object Create(object request, ISpecimenContext context);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
