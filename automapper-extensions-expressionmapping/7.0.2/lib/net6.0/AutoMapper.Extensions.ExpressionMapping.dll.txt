[ExtensionAttribute]
internal static class AutoMapper.ExpressionExtensions : object {
    [ExtensionAttribute]
public static Expression MemberAccesses(IEnumerable`1<MemberInfo> members, Expression obj);
    [ExtensionAttribute]
public static IEnumerable`1<MemberExpression> GetMembers(Expression expression);
    [IteratorStateMachineAttribute("AutoMapper.ExpressionExtensions/<GetMembers>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<MemberExpression> GetMembers(MemberExpression expression);
    [ExtensionAttribute]
public static bool IsMemberPath(LambdaExpression exp);
}
[ExtensionAttribute]
internal static class AutoMapper.ExpressionHelpers : object {
    public static MemberExpression MemberAccesses(string members, Expression obj);
    [ExtensionAttribute]
public static Expression ReplaceParameters(LambdaExpression exp, Expression[] replace);
    [ExtensionAttribute]
public static Expression Replace(Expression exp, Expression old, Expression replace);
    [IteratorStateMachineAttribute("AutoMapper.ExpressionHelpers/<GetMemberPath>d__3")]
private static IEnumerable`1<MemberInfo> GetMemberPath(Type type, string fullMemberName);
    private static Type GetCurrentType(MemberInfo member, Type type);
}
internal static class AutoMapper.Extensions.ExpressionMapping.AnonymousTypeFactory : object {
    private static int classCount;
    public static Type CreateAnonymousType(IEnumerable`1<MemberInfo> memberDetails);
    public static Type CreateAnonymousType(IDictionary`2<string, Type> memberDetails);
    private static string GetAnonymousTypeName();
}
[ExtensionAttribute]
public static class AutoMapper.Extensions.ExpressionMapping.ConfigurationExtensions : object {
    [ExtensionAttribute]
public static IMapperConfigurationExpression AddExpressionMapping(IMapperConfigurationExpression config);
}
public enum AutoMapper.Extensions.ExpressionMapping.ElementTypeFlags : Enum {
    public int value__;
    public static ElementTypeFlags None;
    public static ElementTypeFlags BreakKeyValuePair;
}
[ExtensionAttribute]
public static class AutoMapper.Extensions.ExpressionMapping.ElementTypeHelper : object {
    public static Type GetElementType(Type enumerableType);
    public static Type[] GetElementTypes(Type enumerableType, ElementTypeFlags flags);
    public static Type[] GetElementTypes(Type enumerableType, IEnumerable enumerable, ElementTypeFlags flags);
    [ExtensionAttribute]
public static Type GetReadOnlyDictionaryType(Type type);
    [ExtensionAttribute]
public static Type GetDictionaryType(Type type);
    public static Expression ToType(Expression expression, Type type);
}
[ExtensionAttribute]
internal static class AutoMapper.Extensions.ExpressionMapping.Extensions.VisitorExtensions : object {
    [ExtensionAttribute]
public static bool IsMemberExpression(Expression expression);
    private static bool IsMemberOrParameterExpression(Expression expression);
    [ExtensionAttribute]
public static string GetPropertyFullName(Expression expression);
    [ExtensionAttribute]
public static Expression GetUnconvertedExpression(Expression expression);
    [ExtensionAttribute]
public static Expression ConvertTypeIfNecessary(Expression expression, Type memberType);
    [ExtensionAttribute]
public static MemberExpression GetMemberExpression(LambdaExpression expr);
    [ExtensionAttribute]
public static MemberExpression GetMemberExpression(Expression expr);
    [ExtensionAttribute]
public static ParameterExpression GetParameterExpression(Expression expression);
    [ExtensionAttribute]
public static Expression GetBaseOfMemberExpression(MemberExpression expression);
    [ExtensionAttribute]
public static MemberExpression MemberAccesses(Expression exp, List`1<PropertyMapInfo> list);
    [ExtensionAttribute]
public static string GetMemberFullName(LambdaExpression expr);
    [ExtensionAttribute]
public static List`1<Type> GetUnderlyingGenericTypes(Type type);
    [ExtensionAttribute]
public static bool IsEnumType(Type type);
}
internal class AutoMapper.Extensions.ExpressionMapping.FindMemberExpressionsVisitor : ExpressionVisitor {
    private Expression _newParentExpression;
    private List`1<MemberExpression> _memberExpressions;
    public MemberExpression Result { get; }
    internal FindMemberExpressionsVisitor(Expression newParentExpression);
    public MemberExpression get_Result();
    protected virtual Expression VisitMember(MemberExpression node);
    [CompilerGeneratedAttribute]
private string <get_Result>b__4_4(string result, string next);
}
internal class AutoMapper.Extensions.ExpressionMapping.Impl.ConstantExpressionReplacementVisitor : ExpressionVisitor {
    private IDictionary`2<string, object> _paramValues;
    public ConstantExpressionReplacementVisitor(IDictionary`2<string, object> paramValues);
    protected virtual Expression VisitMember(MemberExpression node);
}
internal class AutoMapper.Extensions.ExpressionMapping.Impl.ElementOperatorSearcher : ExpressionVisitor {
    [CompilerGeneratedAttribute]
private bool <ContainsElementOperator>k__BackingField;
    public bool ContainsElementOperator { get; private set; }
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    [CompilerGeneratedAttribute]
public bool get_ContainsElementOperator();
    [CompilerGeneratedAttribute]
private void set_ContainsElementOperator(bool value);
}
public interface AutoMapper.Extensions.ExpressionMapping.Impl.IQueryDataSourceInjection`1 {
    public abstract virtual ISourceInjectedQueryable`1<TDestination> For();
    public abstract virtual ISourceInjectedQueryable`1<TDestination> For(object parameters, Expression`1[] membersToExpand);
    public abstract virtual ISourceInjectedQueryable`1<TDestination> For(Expression`1[] membersToExpand);
    public abstract virtual ISourceInjectedQueryable`1<TDestination> For(IDictionary`2<string, object> parameters, String[] membersToExpand);
    public abstract virtual IQueryDataSourceInjection`1<TSource> UsingInspector(SourceInjectedQueryInspector inspector);
    public abstract virtual IQueryDataSourceInjection`1<TSource> BeforeProjection(ExpressionVisitor[] visitors);
    public abstract virtual IQueryDataSourceInjection`1<TSource> AfterProjection(ExpressionVisitor[] visitors);
    public abstract virtual IQueryDataSourceInjection`1<TSource> OnError(Action`1<Exception> exceptionHandler);
}
public interface AutoMapper.Extensions.ExpressionMapping.Impl.ISourceInjectedQueryable`1 {
    public abstract virtual IQueryable`1<T> OnEnumerated(Action`1<IEnumerable`1<object>> enumerationHandler);
    public abstract virtual IQueryable`1<T> AsQueryable();
}
internal class AutoMapper.Extensions.ExpressionMapping.Impl.MethodNodeReplacer`1 : ExpressionVisitor {
    private MethodCallExpression _foundExpression;
    private static MethodInfo QueryableWhereMethod;
    [CompilerGeneratedAttribute]
private MethodInfo <ReplacedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <ElementOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FoundElementOperator>k__BackingField;
    public MethodInfo ReplacedMethod { get; private set; }
    public MethodInfo ElementOperator { get; private set; }
    public bool FoundElementOperator { get; private set; }
    public MethodNodeReplacer`1(MethodCallExpression foundExpression);
    private static MethodNodeReplacer`1();
    private static MethodInfo FindQueryableWhereMethod();
    [CompilerGeneratedAttribute]
public MethodInfo get_ReplacedMethod();
    [CompilerGeneratedAttribute]
private void set_ReplacedMethod(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_ElementOperator();
    [CompilerGeneratedAttribute]
private void set_ElementOperator(MethodInfo value);
    [CompilerGeneratedAttribute]
public bool get_FoundElementOperator();
    [CompilerGeneratedAttribute]
private void set_FoundElementOperator(bool value);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
}
public class AutoMapper.Extensions.ExpressionMapping.Impl.QueryDataSourceInjection`1 : object {
    private IQueryable`1<TSource> _dataSource;
    private IMapper _mapper;
    private List`1<ExpressionVisitor> _beforeMappingVisitors;
    private List`1<ExpressionVisitor> _afterMappingVisitors;
    private ExpressionVisitor _sourceExpressionTracer;
    private ExpressionVisitor _destinationExpressionTracer;
    private Action`1<Exception> _exceptionHandler;
    private IEnumerable`1<IEnumerable`1<MemberInfo>> _membersToExpand;
    private IDictionary`2<string, object> _parameters;
    private SourceInjectedQueryInspector _inspector;
    public QueryDataSourceInjection`1(IQueryable`1<TSource> dataSource, IMapper mapper);
    public sealed virtual ISourceInjectedQueryable`1<TDestination> For();
    public sealed virtual ISourceInjectedQueryable`1<TDestination> For(object parameters, Expression`1[] membersToExpand);
    public sealed virtual ISourceInjectedQueryable`1<TDestination> For(Expression`1[] membersToExpand);
    public sealed virtual ISourceInjectedQueryable`1<TDestination> For(IDictionary`2<string, object> parameters, String[] membersToExpand);
    public sealed virtual IQueryDataSourceInjection`1<TSource> UsingInspector(SourceInjectedQueryInspector inspector);
    public sealed virtual IQueryDataSourceInjection`1<TSource> BeforeProjection(ExpressionVisitor[] visitors);
    public sealed virtual IQueryDataSourceInjection`1<TSource> AfterProjection(ExpressionVisitor[] visitors);
    public sealed virtual IQueryDataSourceInjection`1<TSource> OnError(Action`1<Exception> exceptionHandler);
    private ISourceInjectedQueryable`1<TDestination> CreateQueryable();
    private static IDictionary`2<string, object> GetParameters(object parameters);
    [CompilerGeneratedAttribute]
private bool <BeforeProjection>b__16_0(ExpressionVisitor visitor);
    [CompilerGeneratedAttribute]
private bool <AfterProjection>b__17_0(ExpressionVisitor visitor);
}
internal class AutoMapper.Extensions.ExpressionMapping.Impl.ReplaceableMethodNodeFinder`1 : ExpressionVisitor {
    [CompilerGeneratedAttribute]
private MethodCallExpression <MethodNode>k__BackingField;
    private bool _ignoredMethodFound;
    private static String[] IgnoredMethods;
    public MethodCallExpression MethodNode { get; private set; }
    private static ReplaceableMethodNodeFinder`1();
    [CompilerGeneratedAttribute]
public MethodCallExpression get_MethodNode();
    [CompilerGeneratedAttribute]
private void set_MethodNode(MethodCallExpression value);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
}
public class AutoMapper.Extensions.ExpressionMapping.Impl.SourceInjectedQueryInspector : object {
    [CompilerGeneratedAttribute]
private Action`2<Expression, object> <SourceResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<object> <DestResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Type, Expression> <StartQueryExecuteInterceptor>k__BackingField;
    public Action`2<Expression, object> SourceResult { get; public set; }
    public Action`1<object> DestResult { get; public set; }
    public Action`2<Type, Expression> StartQueryExecuteInterceptor { get; public set; }
    [CompilerGeneratedAttribute]
public Action`2<Expression, object> get_SourceResult();
    [CompilerGeneratedAttribute]
public void set_SourceResult(Action`2<Expression, object> value);
    [CompilerGeneratedAttribute]
public Action`1<object> get_DestResult();
    [CompilerGeneratedAttribute]
public void set_DestResult(Action`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<Type, Expression> get_StartQueryExecuteInterceptor();
    [CompilerGeneratedAttribute]
public void set_StartQueryExecuteInterceptor(Action`2<Type, Expression> value);
}
public class AutoMapper.Extensions.ExpressionMapping.Impl.SourceInjectedQueryProvider`2 : object {
    private IMapper _mapper;
    private IQueryable`1<TSource> _dataSource;
    private IQueryable`1<TDestination> _destQuery;
    private IEnumerable`1<ExpressionVisitor> _beforeVisitors;
    private IEnumerable`1<ExpressionVisitor> _afterVisitors;
    private IDictionary`2<string, object> _parameters;
    private IEnumerable`1<IEnumerable`1<MemberInfo>> _membersToExpand;
    private Action`1<Exception> _exceptionHandler;
    [CompilerGeneratedAttribute]
private SourceInjectedQueryInspector <Inspector>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<object>> <EnumerationHandler>k__BackingField;
    private static MethodInfo QueryableSelectMethod;
    public SourceInjectedQueryInspector Inspector { get; public set; }
    internal Action`1<IEnumerable`1<object>> EnumerationHandler { get; internal set; }
    public SourceInjectedQueryProvider`2(IMapper mapper, IQueryable`1<TSource> dataSource, IQueryable`1<TDestination> destQuery, IEnumerable`1<ExpressionVisitor> beforeVisitors, IEnumerable`1<ExpressionVisitor> afterVisitors, Action`1<Exception> exceptionHandler, IDictionary`2<string, object> parameters, IEnumerable`1<IEnumerable`1<MemberInfo>> membersToExpand);
    private static SourceInjectedQueryProvider`2();
    [CompilerGeneratedAttribute]
public SourceInjectedQueryInspector get_Inspector();
    [CompilerGeneratedAttribute]
public void set_Inspector(SourceInjectedQueryInspector value);
    [CompilerGeneratedAttribute]
internal Action`1<IEnumerable`1<object>> get_EnumerationHandler();
    [CompilerGeneratedAttribute]
internal void set_EnumerationHandler(Action`1<IEnumerable`1<object>> value);
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public sealed virtual object Execute(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    private LambdaExpression[] GetMapExpressions(QueryExpressions queryExpressions);
    private static Expression Select(Expression source, LambdaExpression lambda);
    private static IQueryable Select(IQueryable source, LambdaExpression lambda);
    private object InvokeSourceQuery(Type sourceResultType, Expression sourceExpression);
    private static bool IsProjection(Type resultType);
    private static bool IsProjection(Type resultType, Expression sourceExpression);
    private static bool IsProjection(Type resultType);
    private static Type CreateSourceResultType(Type destResultType);
    private Expression ConvertDestinationExpressionToSourceExpression(Expression expression);
    private static MethodInfo FindQueryableSelectMethod();
}
public class AutoMapper.Extensions.ExpressionMapping.Impl.SourceSourceInjectedQuery`2 : object {
    private Action`1<Exception> _exceptionHandler;
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<object>> <EnumerationHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryProvider <Provider>k__BackingField;
    internal Action`1<IEnumerable`1<object>> EnumerationHandler { get; internal set; }
    internal IDictionary`2<string, object> Parameters { get; internal set; }
    public Type ElementType { get; }
    public Expression Expression { get; }
    public IQueryProvider Provider { get; }
    public SourceSourceInjectedQuery`2(IQueryable`1<TSource> dataSource, IQueryable`1<TDestination> destQuery, IMapper mapper, IEnumerable`1<ExpressionVisitor> beforeVisitors, IEnumerable`1<ExpressionVisitor> afterVisitors, Action`1<Exception> exceptionHandler, IDictionary`2<string, object> parameters, IEnumerable`1<IEnumerable`1<MemberInfo>> membersToExpand, SourceInjectedQueryInspector inspector);
    internal SourceSourceInjectedQuery`2(IQueryProvider provider, Expression expression, Action`1<IEnumerable`1<object>> enumerationHandler, Action`1<Exception> exceptionHandler);
    public sealed virtual IQueryable`1<TDestination> OnEnumerated(Action`1<IEnumerable`1<object>> enumerationHandler);
    public sealed virtual IQueryable`1<TDestination> AsQueryable();
    [CompilerGeneratedAttribute]
internal Action`1<IEnumerable`1<object>> get_EnumerationHandler();
    [CompilerGeneratedAttribute]
internal void set_EnumerationHandler(Action`1<IEnumerable`1<object>> value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
internal void set_Parameters(IDictionary`2<string, object> value);
    public sealed virtual IEnumerator`1<TDestination> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryProvider get_Provider();
}
public class AutoMapper.Extensions.ExpressionMapping.MapIncludesVisitor : XpressionMapperVisitor {
    public MapIncludesVisitor(IMapper mapper, IConfigurationProvider configurationProvider, Dictionary`2<Type, Type> typeMappings);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitMember(MemberExpression node);
    [CompilerGeneratedAttribute]
private Expression <VisitMember>g__GetMappedMemberExpression|2_0(Expression parentExpression, List`1<PropertyMapInfo> propertyMapInfoList, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static Expression <VisitMember>g__GetExpressionForInclude|2_1(MemberExpression memberExpression);
    [CompilerGeneratedAttribute]
internal static MemberExpression <VisitMember>g__GetMemberExpression|2_2(FindMemberExpressionsVisitor visitor, Expression mappedExpression);
}
[ExtensionAttribute]
public static class AutoMapper.Extensions.ExpressionMapping.MapperExtensions : object {
    [ExtensionAttribute]
public static LambdaExpression MapExpression(IMapper mapper, LambdaExpression expression, Type sourceExpressionType, Type destExpressionType);
    [ExtensionAttribute]
private static TDestDelegate _MapExpression(IMapper mapper, TSourceDelegate expression);
    [ExtensionAttribute]
private static MethodInfo GetMapExpressionMethod(string methodName);
    [ExtensionAttribute]
public static object MapObject(IMapper mapper, object obj, Type sourceType, Type destType);
    private static TDest _MapObject(IMapper mapper, TSource source);
    [ExtensionAttribute]
private static MethodInfo GetMapObjectMethod(string methodName);
    [ExtensionAttribute]
public static TDestDelegate MapExpression(IMapper mapper, LambdaExpression expression);
    [ExtensionAttribute]
private static TDestDelegate MapExpression(IMapper mapper, LambdaExpression expression, Func`3<IConfigurationProvider, Dictionary`2<Type, Type>, XpressionMapperVisitor> getVisitor, Func`2<Type, bool> shouldConvertMappedBodyToDestType);
    private static TDestDelegate MapExpression(IConfigurationProvider configurationProvider, LambdaExpression expression, Type typeSourceFunc, Type typeDestFunc, Func`3<IConfigurationProvider, Dictionary`2<Type, Type>, XpressionMapperVisitor> getVisitor, Func`2<Type, bool> shouldConvertMappedBodyToDestType);
    [ExtensionAttribute]
private static bool IsFuncType(Type type);
    [ExtensionAttribute]
public static TDestDelegate MapExpression(IMapper mapper, TSourceDelegate expression);
    [ExtensionAttribute]
public static TDestDelegate MapExpressionAsInclude(IMapper mapper, LambdaExpression expression);
    [ExtensionAttribute]
public static TDestDelegate MapExpressionAsInclude(IMapper mapper, TSourceDelegate expression);
    [ExtensionAttribute]
public static ICollection`1<TDestDelegate> MapExpressionList(IMapper mapper, ICollection`1<TSourceDelegate> collection);
    [ExtensionAttribute]
public static ICollection`1<TDestDelegate> MapExpressionList(IMapper mapper, IEnumerable`1<LambdaExpression> collection);
    [ExtensionAttribute]
public static ICollection`1<TDestDelegate> MapIncludesList(IMapper mapper, ICollection`1<TSourceDelegate> collection);
    [ExtensionAttribute]
public static ICollection`1<TDestDelegate> MapIncludesList(IMapper mapper, IEnumerable`1<LambdaExpression> collection);
    [ExtensionAttribute]
public static List`1<ParameterExpression> GetDestinationParameterExpressions(LambdaExpression expression, MapperInfoDictionary infoDictionary, Dictionary`2<Type, Type> typeMappings);
    [ExtensionAttribute]
public static Dictionary`2<Type, Type> AddTypeMapping(Dictionary`2<Type, Type> typeMappings, IConfigurationProvider configurationProvider);
    [ExtensionAttribute]
private static bool HasUnderlyingType(Type type);
    [ExtensionAttribute]
private static void AddUnderlyingTypes(Dictionary`2<Type, Type> typeMappings, IConfigurationProvider configurationProvider, Type sourceType, Type destType);
    [ExtensionAttribute]
public static Dictionary`2<Type, Type> AddTypeMapping(Dictionary`2<Type, Type> typeMappings, IConfigurationProvider configurationProvider, Type sourceType, Type destType);
    [ExtensionAttribute]
private static void AddIncludedTypeMaps(Dictionary`2<Type, Type> typeMappings, IConfigurationProvider configurationProvider, Type source, Type dest);
    [ExtensionAttribute]
public static Type ReplaceType(Dictionary`2<Type, Type> typeMappings, Type sourceType);
    [ExtensionAttribute]
private static Dictionary`2<Type, Type> AddTypeMappingsFromDelegates(Dictionary`2<Type, Type> typeMappings, IConfigurationProvider configurationProvider, Type sourceType, Type destType);
    [ExtensionAttribute]
private static void DoAddTypeMappingsFromDelegates(Dictionary`2<Type, Type> typeMappings, IConfigurationProvider configurationProvider, List`1<Type> sourceArguments, List`1<Type> destArguments);
    [ExtensionAttribute]
private static void DoAddTypeMappings(Dictionary`2<Type, Type> typeMappings, IConfigurationProvider configurationProvider, List`1<Type> sourceArguments, List`1<Type> destArguments);
    [ExtensionAttribute]
private static Type GetSourceMemberType(PropertyMap propertyMap);
    [ExtensionAttribute]
private static void FindChildPropertyTypeMaps(Dictionary`2<Type, Type> typeMappings, IConfigurationProvider ConfigurationProvider, Type source, Type dest);
    [CompilerGeneratedAttribute]
internal static TDestDelegate <MapExpression>g__CreateVisitor|8_0(Dictionary`2<Type, Type> typeMappings, <>c__DisplayClass8_0`1& );
    [CompilerGeneratedAttribute]
internal static TDestDelegate <MapExpression>g__MapBody|8_1(Dictionary`2<Type, Type> typeMappings, XpressionMapperVisitor visitor, <>c__DisplayClass8_0`1& );
    [CompilerGeneratedAttribute]
internal static TDestDelegate <MapExpression>g__GetLambda|8_2(Dictionary`2<Type, Type> typeMappings, XpressionMapperVisitor visitor, Expression mappedBody, <>c__DisplayClass8_0`1& );
    [CompilerGeneratedAttribute]
internal static Expression <MapExpression>g__ConvertBody|8_3(<>c__DisplayClass8_0`1& , <>c__DisplayClass8_1`1& );
    [CompilerGeneratedAttribute]
internal static void <AddIncludedTypeMaps>g__AddTypeMaps|22_0(TypeMap typeMap, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
internal static void <FindChildPropertyTypeMaps>g__FindMaps|28_0(List`1<PropertyMap> maps, <>c__DisplayClass28_0& );
    [CompilerGeneratedAttribute]
internal static void <FindChildPropertyTypeMaps>g__AddChildMappings|28_1(Type sourcePropertyType, Type destPropertyType, <>c__DisplayClass28_0& );
}
public class AutoMapper.Extensions.ExpressionMapping.MapperInfoDictionary : Dictionary`2<ParameterExpression, MapperInfo> {
    public MapperInfoDictionary(ParameterExpressionEqualityComparer comparer);
    public void Add(ParameterExpression key, Dictionary`2<Type, Type> typeMappings);
}
public class AutoMapper.Extensions.ExpressionMapping.MemberVisitor : ExpressionVisitor {
    private List`1<MemberInfo> _members;
    public IEnumerable`1<MemberInfo> MemberPath { get; }
    public static IEnumerable`1<MemberInfo> GetMemberPath(Expression expression);
    protected virtual Expression VisitMember(MemberExpression node);
    public IEnumerable`1<MemberInfo> get_MemberPath();
}
internal class AutoMapper.Extensions.ExpressionMapping.NullsafeQueryRewriter : ExpressionVisitor {
    private static LockingConcurrentDictionary`2<Type, Expression> Cache;
    private static NullsafeQueryRewriter();
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private static Expression BeSafe(Expression target, Expression expression, Func`2<Expression, Expression> update);
    private static bool IsSafe(Expression expression);
    private static Expression Fallback(Type type);
    private static Expression CollectionFallback(Type definition, Type type);
    private static bool IsExtensionMethod(MethodInfo element);
    private static bool IsNullableOrReferenceType(Type type);
}
public class AutoMapper.Extensions.ExpressionMapping.ParameterExpressionEqualityComparer : object {
    public sealed virtual bool Equals(ParameterExpression x, ParameterExpression y);
    public sealed virtual int GetHashCode(ParameterExpression obj);
}
internal class AutoMapper.Extensions.ExpressionMapping.PrependParentNameVisitor : ExpressionVisitor {
    [CompilerGeneratedAttribute]
private ParameterExpression <CurrentParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <NewParameter>k__BackingField;
    public ParameterExpression CurrentParameter { get; }
    public string ParentFullName { get; }
    public Expression NewParameter { get; }
    public PrependParentNameVisitor(ParameterExpression currentParameter, string parentFullName, Expression newParameter);
    [CompilerGeneratedAttribute]
public ParameterExpression get_CurrentParameter();
    [CompilerGeneratedAttribute]
public string get_ParentFullName();
    [CompilerGeneratedAttribute]
public Expression get_NewParameter();
    protected virtual Expression VisitParameter(ParameterExpression node);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class AutoMapper.Extensions.ExpressionMapping.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string cannotCreateBinaryExpressionFormat { get; }
    internal static string cantRemapExpression { get; }
    internal static string customResolversNotSupported { get; }
    internal static string expressionMapValueTypeMustMatchFormat { get; }
    internal static string includeExpressionTooComplex { get; }
    internal static string invalidArgumentCount { get; }
    internal static string invalidExpErr { get; }
    internal static string makeParentTypesMatchForMembersOfLiteralsFormat { get; }
    internal static string mappedMemberIsChildOfTheParameterFormat { get; }
    internal static string mapperInfoDictionaryIsNull { get; }
    internal static string mustBeExpressions { get; }
    internal static string srcMemberCannotBeNullFormat { get; }
    internal static string typeMappingsDictionaryIsNull { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_cannotCreateBinaryExpressionFormat();
    internal static string get_cantRemapExpression();
    internal static string get_customResolversNotSupported();
    internal static string get_expressionMapValueTypeMustMatchFormat();
    internal static string get_includeExpressionTooComplex();
    internal static string get_invalidArgumentCount();
    internal static string get_invalidExpErr();
    internal static string get_makeParentTypesMatchForMembersOfLiteralsFormat();
    internal static string get_mappedMemberIsChildOfTheParameterFormat();
    internal static string get_mapperInfoDictionaryIsNull();
    internal static string get_mustBeExpressions();
    internal static string get_srcMemberCannotBeNullFormat();
    internal static string get_typeMappingsDictionaryIsNull();
}
[ExtensionAttribute]
public static class AutoMapper.Extensions.ExpressionMapping.QueryableExtensions : object {
    [ExtensionAttribute]
public static IQueryDataSourceInjection`1<TSource> UseAsDataSource(IQueryable`1<TSource> dataSource, IConfigurationProvider config);
    [ExtensionAttribute]
public static IQueryDataSourceInjection`1<TSource> UseAsDataSource(IQueryable`1<TSource> dataSource, IMapper mapper);
}
[ExtensionAttribute]
internal static class AutoMapper.Extensions.ExpressionMapping.ReflectionExtensions : object {
    [ExtensionAttribute]
public static object MapMember(ResolutionContext context, MemberInfo member, object value, object destination);
    [ExtensionAttribute]
public static void SetMemberValue(MemberInfo propertyOrField, object target, object value);
    [ExtensionAttribute]
public static object GetMemberValue(MemberInfo propertyOrField, object target);
    public static IEnumerable`1<MemberInfo> GetMemberPath(Type type, string fullMemberName);
    public static IEnumerable`1<IEnumerable`1<MemberInfo>> GetMemberPaths(Type type, String[] membersToExpand);
    public static IEnumerable`1<IEnumerable`1<MemberInfo>> GetMemberPaths(Expression`1[] membersToExpand);
    public static MemberInfo FindProperty(LambdaExpression lambdaExpression);
    [ExtensionAttribute]
public static Type GetMemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static IEnumerable`1<TypeInfo> GetDefinedTypes(Assembly assembly);
    [ExtensionAttribute]
public static bool GetHasDefaultValue(ParameterInfo info);
    [ExtensionAttribute]
public static bool GetIsConstructedGenericType(Type type);
}
internal class AutoMapper.Extensions.ExpressionMapping.ReplaceExpressionVisitor : ExpressionVisitor {
    private Expression _oldExpression;
    private Expression _newExpression;
    public ReplaceExpressionVisitor(Expression oldExpression, Expression newExpression);
    public virtual Expression Visit(Expression node);
}
internal class AutoMapper.Extensions.ExpressionMapping.Structures.DeclaringMemberKey : object {
    [CompilerGeneratedAttribute]
private MemberInfo <DeclaringMemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeclaringMemberFullName>k__BackingField;
    public MemberInfo DeclaringMemberInfo { get; public set; }
    public string DeclaringMemberFullName { get; public set; }
    public DeclaringMemberKey(MemberInfo declaringMemberInfo, string declaringMemberFullName);
    [CompilerGeneratedAttribute]
public MemberInfo get_DeclaringMemberInfo();
    [CompilerGeneratedAttribute]
public void set_DeclaringMemberInfo(MemberInfo value);
    [CompilerGeneratedAttribute]
public string get_DeclaringMemberFullName();
    [CompilerGeneratedAttribute]
public void set_DeclaringMemberFullName(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DeclaringMemberKey other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class AutoMapper.Extensions.ExpressionMapping.Structures.MapperInfo : object {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestType>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <NewParameter>k__BackingField;
    public Type SourceType { get; public set; }
    public Type DestType { get; public set; }
    public ParameterExpression NewParameter { get; public set; }
    public MapperInfo(ParameterExpression newParameter, Type sourceType, Type destType);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DestType();
    [CompilerGeneratedAttribute]
public void set_DestType(Type value);
    [CompilerGeneratedAttribute]
public ParameterExpression get_NewParameter();
    [CompilerGeneratedAttribute]
public void set_NewParameter(ParameterExpression value);
}
internal class AutoMapper.Extensions.ExpressionMapping.Structures.MemberAssignmentInfo : object {
    [CompilerGeneratedAttribute]
private PropertyMap <PropertyMap>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberAssignment <MemberAssignment>k__BackingField;
    public PropertyMap PropertyMap { get; public set; }
    public MemberAssignment MemberAssignment { get; public set; }
    public MemberAssignmentInfo(PropertyMap propertyMap, MemberAssignment memberAssignment);
    [CompilerGeneratedAttribute]
public PropertyMap get_PropertyMap();
    [CompilerGeneratedAttribute]
public void set_PropertyMap(PropertyMap value);
    [CompilerGeneratedAttribute]
public MemberAssignment get_MemberAssignment();
    [CompilerGeneratedAttribute]
public void set_MemberAssignment(MemberAssignment value);
}
internal class AutoMapper.Extensions.ExpressionMapping.Structures.MemberBindingGroup : object {
    [CompilerGeneratedAttribute]
private DeclaringMemberKey <DeclaringMemberKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRootMemberAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NewType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MemberAssignmentInfo> <MemberAssignmentInfos>k__BackingField;
    public DeclaringMemberKey DeclaringMemberKey { get; public set; }
    public bool IsRootMemberAssignment { get; public set; }
    public Type NewType { get; public set; }
    public List`1<MemberAssignmentInfo> MemberAssignmentInfos { get; public set; }
    public MemberBindingGroup(DeclaringMemberKey declaringMemberKey, bool isRootMemberAssignment, Type newType, List`1<MemberAssignmentInfo> memberAssignmentInfos);
    [CompilerGeneratedAttribute]
public DeclaringMemberKey get_DeclaringMemberKey();
    [CompilerGeneratedAttribute]
public void set_DeclaringMemberKey(DeclaringMemberKey value);
    [CompilerGeneratedAttribute]
public bool get_IsRootMemberAssignment();
    [CompilerGeneratedAttribute]
public void set_IsRootMemberAssignment(bool value);
    [CompilerGeneratedAttribute]
public Type get_NewType();
    [CompilerGeneratedAttribute]
public void set_NewType(Type value);
    [CompilerGeneratedAttribute]
public List`1<MemberAssignmentInfo> get_MemberAssignmentInfos();
    [CompilerGeneratedAttribute]
public void set_MemberAssignmentInfos(List`1<MemberAssignmentInfo> value);
}
public class AutoMapper.Extensions.ExpressionMapping.Structures.PropertyMapInfo : object {
    [CompilerGeneratedAttribute]
private LambdaExpression <CustomExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MemberInfo> <DestinationPropertyInfos>k__BackingField;
    public LambdaExpression CustomExpression { get; public set; }
    public List`1<MemberInfo> DestinationPropertyInfos { get; public set; }
    public PropertyMapInfo(LambdaExpression customExpression, List`1<MemberInfo> destinationPropertyInfos);
    [CompilerGeneratedAttribute]
public LambdaExpression get_CustomExpression();
    [CompilerGeneratedAttribute]
public void set_CustomExpression(LambdaExpression value);
    [CompilerGeneratedAttribute]
public List`1<MemberInfo> get_DestinationPropertyInfos();
    [CompilerGeneratedAttribute]
public void set_DestinationPropertyInfos(List`1<MemberInfo> value);
}
[ExtensionAttribute]
internal static class AutoMapper.Extensions.ExpressionMapping.TypeMapHelper : object {
    [ExtensionAttribute]
public static bool CanMapConstant(IConfigurationProvider config, Type sourceType, Type destType);
    [ExtensionAttribute]
public static MemberMap GetMemberMapByDestinationProperty(TypeMap typeMap, string destinationPropertyName);
    [ExtensionAttribute]
public static TypeMap CheckIfTypeMapExists(IConfigurationProvider config, Type sourceType, Type destinationType);
    [ExtensionAttribute]
public static string GetDestinationName(MemberMap memberMap);
    [ExtensionAttribute]
public static PathMap FindPathMapByDestinationFullPath(TypeMap typeMap, string destinationFullPath);
    private static Exception PropertyConfigurationException(TypeMap typeMap, String[] unmappedPropertyNames);
    private static Exception MissingMapException(Type sourceType, Type destinationType);
    [CompilerGeneratedAttribute]
internal static bool <CanMapConstant>g__BothTypesAreEnums|0_0(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanMapConstant>g__BothTypesAreEnumerable|0_1(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanMapConstant>g__BothTypesAreDictionary|0_2(<>c__DisplayClass0_0& );
}
public class AutoMapper.Extensions.ExpressionMapping.XpressionMapperVisitor : ExpressionVisitor {
    [CompilerGeneratedAttribute]
private MapperInfoDictionary <InfoDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Type, Type> <TypeMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationProvider <ConfigurationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IMapper <Mapper>k__BackingField;
    private IConfigurationProvider anonymousTypesConfigurationProvider;
    private MapperConfigurationExpression anonymousTypesBaseMappings;
    public MapperInfoDictionary InfoDictionary { get; }
    public Dictionary`2<Type, Type> TypeMappings { get; }
    protected IConfigurationProvider ConfigurationProvider { get; }
    protected IMapper Mapper { get; }
    public XpressionMapperVisitor(IMapper mapper, IConfigurationProvider configurationProvider, Dictionary`2<Type, Type> typeMappings);
    [CompilerGeneratedAttribute]
public MapperInfoDictionary get_InfoDictionary();
    [CompilerGeneratedAttribute]
public Dictionary`2<Type, Type> get_TypeMappings();
    [CompilerGeneratedAttribute]
protected IConfigurationProvider get_ConfigurationProvider();
    [CompilerGeneratedAttribute]
protected IMapper get_Mapper();
    protected virtual Expression VisitParameter(ParameterExpression node);
    private object GetConstantValue(object constantObject, string fullName, Type parentType);
    protected virtual Expression VisitMember(MemberExpression node);
    protected MemberExpression GetMemberExpressionFromMemberMaps(string fullName, Expression visitedParentExpr);
    private Expression GetMemberExpressionFromCustomExpression(PropertyMapInfo lastWithCustExpression, PropertyMapInfo lastInList, List`1<PropertyMapInfo> beforeCustExpression, List`1<PropertyMapInfo> afterCustExpression, Expression visitedParentExpr);
    private bool ShouldConvertMemberExpression(Type initialType, Type mappedType);
    protected Expression GetMemberExpressionFromCustomExpression(List`1<PropertyMapInfo> propertyMapInfoList, PropertyMapInfo lastWithCustExpression, Expression mappedParentExpr);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitNew(NewExpression node);
    private static bool IsAnonymousType(Type type);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    private void ConfigureAnonymousTypeMaps(Type oldType, Type newAnonymousType);
    private MemberInitExpression GetAnonymousTypeMemberInitExpression(Dictionary`2<string, Expression> bindingExpressions, Type oldType);
    private MemberInitExpression GetMemberInit(MemberBindingGroup memberBindingGroup);
    private MemberBinding DoBind(MemberInfo sourceMember, Expression initial, Expression mapped);
    private MemberInfo GetSourceMember(PropertyMap propertyMap);
    private MemberInfo GetParentMember(PropertyMap propertyMap);
    private MemberInfo GetSourceParentMember(PropertyMap propertyMap);
    private string BuildParentFullName(PropertyMap propertyMap);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitConditional(ConditionalExpression c);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private void ConvertTypesIfNecessary(ParameterInfo[] parameters, List`1<Expression> listOfArgumentsForNewMethod, MethodInfo mInfo);
    protected string BuildFullName(List`1<PropertyMapInfo> propertyMapInfoList);
    private static void AddPropertyMapInfo(Type parentType, string name, List`1<PropertyMapInfo> propertyMapInfoList);
    private bool GenericTypeDefinitionsAreEquivalent(Type typeSource, Type typeDestination);
    protected void FindDestinationFullName(Type typeSource, Type typeDestination, string sourceFullName, List`1<PropertyMapInfo> propertyMapInfoList);
    [CompilerGeneratedAttribute]
private Expression <VisitMember>g__GetMappedMemberExpression|17_0(Expression parentExpression, List`1<PropertyMapInfo> propertyMapInfoList, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static Expression <GetMemberExpressionFromCustomExpression>g__PrependParentMemberExpression|19_0(PrependParentNameVisitor visitor, <>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
private Expression <VisitMemberInit>b__25_1(MemberAssignment binding);
    [CompilerGeneratedAttribute]
internal static Expression <VisitBinary>g__DoVisitBinary|34_0(Expression newLeft, Expression newRight, Expression conversion, <>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
internal static bool <VisitBinary>g__TypesChanged|34_1(<>c__DisplayClass34_0& , <>c__DisplayClass34_1& );
    [CompilerGeneratedAttribute]
internal static Expression <VisitConditional>g__DoVisitConditional|35_0(Expression test, Expression ifTrue, Expression ifFalse, <>c__DisplayClass35_0& );
    [CompilerGeneratedAttribute]
private Expression <VisitTypeBinary>g__MapTypeBinary|36_0(Expression mapped, <>c__DisplayClass36_0& );
    [CompilerGeneratedAttribute]
private Expression <VisitUnary>g__DoVisitUnary|37_0(Expression updated, <>c__DisplayClass37_0& );
}
[DefaultMemberAttribute("Item")]
internal class AutoMapper.LockingConcurrentDictionary`2 : ValueType {
    private ConcurrentDictionary`2<TKey, Lazy`1<TValue>> _dictionary;
    private Func`2<TKey, Lazy`1<TValue>> _valueFactory;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public LockingConcurrentDictionary`2(Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key);
    public TValue GetOrAdd(TKey key, Func`2<TKey, Lazy`1<TValue>> valueFactory);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public bool ContainsKey(TKey key);
    public ICollection`1<TKey> get_Keys();
}
public class AutoMapper.Mappers.ExpressionMapper : object {
    private static MethodInfo MapMethodInfo;
    private static ExpressionMapper();
    private static TDestination Map(TSource expression, IConfigurationProvider configurationProvider);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configurationProvider, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
[ExtensionAttribute]
internal static class AutoMapper.TypeExtensions : object {
    private static HashSet`1<string> NonNetStandardLiteralTypes;
    private static HashSet`1<Type> LiteralTypes { get; }
    private static Type[] _literalTypes { get; }
    private static TypeExtensions();
    [ExtensionAttribute]
public static bool Has(Type type);
    [ExtensionAttribute]
public static Type GetGenericTypeDefinitionIfGeneric(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericParameters(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> GetDeclaredConstructors(Type type);
    [ExtensionAttribute]
public static MethodInfo GetAddMethod(EventInfo eventInfo);
    [ExtensionAttribute]
public static MethodInfo GetRemoveMethod(EventInfo eventInfo);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetDeclaredMembers(Type type);
    [IteratorStateMachineAttribute("AutoMapper.TypeExtensions/<GetTypeInheritance>d__8")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetTypeInheritance(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetDeclaredMethods(Type type);
    [ExtensionAttribute]
public static MethodInfo GetDeclaredMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetDeclaredMethod(Type type, string name, Type[] parameters);
    [ExtensionAttribute]
public static ConstructorInfo GetDeclaredConstructor(Type type, Type[] parameters);
    [ExtensionAttribute]
private static TMethod MatchParameters(IEnumerable`1<TMethod> methods, Type[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetAllMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetDeclaredProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetDeclaredProperty(Type type, string name);
    [ExtensionAttribute]
public static Object[] GetCustomAttributes(Type type, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsStatic(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static bool IsStatic(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsStatic(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool IsPublic(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> PropertiesWithAnInaccessibleSetter(Type type);
    [ExtensionAttribute]
public static bool HasAnInaccessibleSetter(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsPublic(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool IsNotPublic(ConstructorInfo constructorInfo);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type other);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsLiteralType(Type type);
    private static HashSet`1<Type> get_LiteralTypes();
    private static Type[] get__literalTypes();
    [ExtensionAttribute]
public static bool IsInstanceOfType(Type type, object o);
    [ExtensionAttribute]
public static PropertyInfo[] GetProperties(Type type);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo propertyInfo, bool ignored);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo propertyInfo, bool ignored);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static FieldInfo GetField(Type type, string name);
    [ExtensionAttribute]
public static bool IsQueryableType(Type type);
    [ExtensionAttribute]
public static Type GetGenericElementType(Type type);
    [ExtensionAttribute]
public static bool IsEnumerableType(Type type);
    [ExtensionAttribute]
public static Type ReplaceItemType(Type targetType, Type oldType, Type newType);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
