[AttributeUsageAttribute("1036")]
public class AutoMapper.AutoMapAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReverseMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConstructUsingServiceLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableCtorValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeAllDerived>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AsProxy>k__BackingField;
    public Type SourceType { get; }
    public bool ReverseMap { get; public set; }
    public bool ConstructUsingServiceLocator { get; public set; }
    public int MaxDepth { get; public set; }
    public bool PreserveReferences { get; public set; }
    public bool DisableCtorValidation { get; public set; }
    public bool IncludeAllDerived { get; public set; }
    public Type TypeConverter { get; public set; }
    public bool AsProxy { get; public set; }
    public AutoMapAttribute(Type sourceType);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public bool get_ReverseMap();
    [CompilerGeneratedAttribute]
public void set_ReverseMap(bool value);
    [CompilerGeneratedAttribute]
public bool get_ConstructUsingServiceLocator();
    [CompilerGeneratedAttribute]
public void set_ConstructUsingServiceLocator(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxDepth();
    [CompilerGeneratedAttribute]
public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
public bool get_PreserveReferences();
    [CompilerGeneratedAttribute]
public void set_PreserveReferences(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableCtorValidation();
    [CompilerGeneratedAttribute]
public void set_DisableCtorValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeAllDerived();
    [CompilerGeneratedAttribute]
public void set_IncludeAllDerived(bool value);
    [CompilerGeneratedAttribute]
public Type get_TypeConverter();
    [CompilerGeneratedAttribute]
public void set_TypeConverter(Type value);
    [CompilerGeneratedAttribute]
public bool get_AsProxy();
    [CompilerGeneratedAttribute]
public void set_AsProxy(bool value);
    public void ApplyConfiguration(IMappingExpression mappingExpression);
}
public class AutoMapper.AutoMapperConfigurationException : Exception {
    [CompilerGeneratedAttribute]
private TypeMapConfigErrors[] <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypePair> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberMap <MemberMap>k__BackingField;
    public TypeMapConfigErrors[] Errors { get; }
    public Nullable`1<TypePair> Types { get; }
    public MemberMap MemberMap { get; public set; }
    public string Message { get; }
    public string StackTrace { get; }
    public AutoMapperConfigurationException(string message);
    public AutoMapperConfigurationException(string message, Exception inner);
    public AutoMapperConfigurationException(TypeMapConfigErrors[] errors);
    public AutoMapperConfigurationException(TypePair types);
    [CompilerGeneratedAttribute]
public TypeMapConfigErrors[] get_Errors();
    [CompilerGeneratedAttribute]
public Nullable`1<TypePair> get_Types();
    [CompilerGeneratedAttribute]
public MemberMap get_MemberMap();
    [CompilerGeneratedAttribute]
public void set_MemberMap(MemberMap value);
    public virtual string get_Message();
    public virtual string get_StackTrace();
}
public class AutoMapper.AutoMapperMappingException : Exception {
    private string _message;
    [CompilerGeneratedAttribute]
private Nullable`1<TypePair> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberMap <MemberMap>k__BackingField;
    public Nullable`1<TypePair> Types { get; public set; }
    public TypeMap TypeMap { get; public set; }
    public MemberMap MemberMap { get; public set; }
    public string Message { get; }
    public string StackTrace { get; }
    public AutoMapperMappingException(string message);
    public AutoMapperMappingException(string message, Exception innerException);
    public AutoMapperMappingException(string message, Exception innerException, TypePair types);
    public AutoMapperMappingException(string message, Exception innerException, TypeMap typeMap);
    public AutoMapperMappingException(string message, Exception innerException, MemberMap memberMap);
    [CompilerGeneratedAttribute]
public Nullable`1<TypePair> get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(Nullable`1<TypePair> value);
    [CompilerGeneratedAttribute]
public TypeMap get_TypeMap();
    [CompilerGeneratedAttribute]
public void set_TypeMap(TypeMap value);
    [CompilerGeneratedAttribute]
public MemberMap get_MemberMap();
    [CompilerGeneratedAttribute]
public void set_MemberMap(MemberMap value);
    public virtual string get_Message();
    public virtual string get_StackTrace();
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Annotations.IgnoreAttribute : Attribute {
    public sealed virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Annotations.MapAtRuntimeAttribute : Attribute {
    public sealed virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Annotations.MappingOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public MappingOrderAttribute(int value);
    [CompilerGeneratedAttribute]
public int get_Value();
    public sealed virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Annotations.NullSubstituteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public NullSubstituteAttribute(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    public sealed virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Annotations.SourceMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public SourceMemberAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Annotations.UseExistingValueAttribute : Attribute {
    public sealed virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Annotations.ValueConverterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public ValueConverterAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    public sealed virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
[AttributeUsageAttribute("384")]
public class AutoMapper.Configuration.Annotations.ValueResolverAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public ValueResolverAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    public sealed virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
[IsReadOnlyAttribute]
public class AutoMapper.Configuration.ConditionParameters`3 : ValueType {
    [CompilerGeneratedAttribute]
private TSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private TDestination <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private TMember <SourceMember>k__BackingField;
    [CompilerGeneratedAttribute]
private TMember <DestinationMember>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolutionContext <Context>k__BackingField;
    public TSource Source { get; public set; }
    public TDestination Destination { get; public set; }
    public TMember SourceMember { get; public set; }
    public TMember DestinationMember { get; public set; }
    public ResolutionContext Context { get; public set; }
    public ConditionParameters`3(TSource Source, TDestination Destination, TMember SourceMember, TMember DestinationMember, ResolutionContext Context);
    [CompilerGeneratedAttribute]
public TSource get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(TSource value);
    [CompilerGeneratedAttribute]
public TDestination get_Destination();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Destination(TDestination value);
    [CompilerGeneratedAttribute]
public TMember get_SourceMember();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceMember(TMember value);
    [CompilerGeneratedAttribute]
public TMember get_DestinationMember();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DestinationMember(TMember value);
    [CompilerGeneratedAttribute]
public ResolutionContext get_Context();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Context(ResolutionContext value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ConditionParameters`3<TSource, TDestination, TMember> left, ConditionParameters`3<TSource, TDestination, TMember> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ConditionParameters`3<TSource, TDestination, TMember> left, ConditionParameters`3<TSource, TDestination, TMember> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConditionParameters`3<TSource, TDestination, TMember> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(TSource& Source, TDestination& Destination, TMember& SourceMember, TMember& DestinationMember, ResolutionContext& Context);
}
[IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
public class AutoMapper.Configuration.ConfigurationValidator : ValueType {
    [CompilerGeneratedAttribute]
private IGlobalConfigurationExpression <Expression>k__BackingField;
    public IGlobalConfigurationExpression Expression { get; public set; }
    public ConfigurationValidator(IGlobalConfigurationExpression Expression);
    [CompilerGeneratedAttribute]
public IGlobalConfigurationExpression get_Expression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Expression(IGlobalConfigurationExpression value);
    private void Validate(ValidationContext context);
    public void AssertConfigurationExpressionIsValid(IGlobalConfiguration config, IEnumerable`1<TypeMap> typeMaps);
    public void AssertConfigurationIsValid(IGlobalConfiguration config, IEnumerable`1<TypeMap> typeMaps);
    private void DryRunTypeMap(IGlobalConfiguration config, HashSet`1<TypeMap> typeMapsChecked, TypePair types, TypeMap typeMap, MemberMap memberMap);
    private void CheckPropertyMaps(IGlobalConfiguration config, HashSet`1<TypeMap> typeMapsChecked, TypeMap typeMap);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ConfigurationValidator left, ConfigurationValidator right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ConfigurationValidator left, ConfigurationValidator right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConfigurationValidator other);
    [CompilerGeneratedAttribute]
public void Deconstruct(IGlobalConfigurationExpression& Expression);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.Configuration.Conventions.ConventionsNameSplitMember : NameSplitMember {
    public sealed virtual bool IsMatch(ProfileMap options, TypeDetails sourceType, Type destType, Type destMemberType, string nameToSearch, List`1<MemberInfo> resolvers, bool isReverseMap);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.Configuration.Conventions.DefaultNameSplitMember : NameSplitMember {
    public sealed virtual bool IsMatch(ProfileMap options, TypeDetails sourceType, Type destType, Type destMemberType, string nameToSearch, List`1<MemberInfo> resolvers, bool isReverseMap);
    [CompilerGeneratedAttribute]
private bool <IsMatch>g__Found|0_0(<>c__DisplayClass0_0& );
}
public interface AutoMapper.Configuration.Conventions.ISourceToDestinationNameMapper {
    public abstract virtual MemberInfo GetSourceMember(TypeDetails sourceTypeDetails, Type destType, Type destMemberType, string nameToSearch);
    public abstract virtual void Merge(ISourceToDestinationNameMapper other);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.Configuration.Conventions.MemberConfiguration : object {
    private NameSplitMember _nameSplitMember;
    [CompilerGeneratedAttribute]
private INamingConvention <SourceNamingConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private INamingConvention <DestinationNamingConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ISourceToDestinationNameMapper> <NameToMemberMappers>k__BackingField;
    public INamingConvention SourceNamingConvention { get; public set; }
    public INamingConvention DestinationNamingConvention { get; public set; }
    public List`1<ISourceToDestinationNameMapper> NameToMemberMappers { get; }
    [CompilerGeneratedAttribute]
public INamingConvention get_SourceNamingConvention();
    [CompilerGeneratedAttribute]
public void set_SourceNamingConvention(INamingConvention value);
    [CompilerGeneratedAttribute]
public INamingConvention get_DestinationNamingConvention();
    [CompilerGeneratedAttribute]
public void set_DestinationNamingConvention(INamingConvention value);
    [CompilerGeneratedAttribute]
public List`1<ISourceToDestinationNameMapper> get_NameToMemberMappers();
    public bool IsMatch(ProfileMap options, TypeDetails sourceTypeDetails, Type destType, Type destMemberType, string nameToSearch, List`1<MemberInfo> resolvers, bool isReverseMap);
    public MemberInfo GetSourceMember(TypeDetails sourceTypeDetails, Type destType, Type destMemberType, string nameToSearch);
    public void Seal();
    public void Merge(MemberConfiguration other);
}
[IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
public class AutoMapper.Configuration.Conventions.MemberNameReplacer : ValueType {
    [CompilerGeneratedAttribute]
private string <OriginalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewValue>k__BackingField;
    public string OriginalValue { get; public set; }
    public string NewValue { get; public set; }
    public MemberNameReplacer(string OriginalValue, string NewValue);
    [CompilerGeneratedAttribute]
public string get_OriginalValue();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OriginalValue(string value);
    [CompilerGeneratedAttribute]
public string get_NewValue();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewValue(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MemberNameReplacer left, MemberNameReplacer right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MemberNameReplacer left, MemberNameReplacer right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MemberNameReplacer other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& OriginalValue, String& NewValue);
}
[EditorBrowsableAttribute("1")]
public abstract class AutoMapper.Configuration.Conventions.NameSplitMember : object {
    [CompilerGeneratedAttribute]
private MemberConfiguration <Parent>k__BackingField;
    public MemberConfiguration Parent { get; public set; }
    [CompilerGeneratedAttribute]
public MemberConfiguration get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(MemberConfiguration value);
    public abstract virtual bool IsMatch(ProfileMap options, TypeDetails sourceType, Type destType, Type destMemberType, string nameToSearch, List`1<MemberInfo> resolvers, bool isReverseMap);
}
public class AutoMapper.Configuration.Conventions.PrePostfixName : object {
    [CompilerGeneratedAttribute]
private List`1<string> <DestinationPrefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <DestinationPostfixes>k__BackingField;
    public List`1<string> DestinationPrefixes { get; }
    public List`1<string> DestinationPostfixes { get; }
    [CompilerGeneratedAttribute]
public List`1<string> get_DestinationPrefixes();
    [CompilerGeneratedAttribute]
public List`1<string> get_DestinationPostfixes();
    public sealed virtual MemberInfo GetSourceMember(TypeDetails sourceTypeDetails, Type destType, Type destMemberType, string nameToSearch);
    public sealed virtual void Merge(ISourceToDestinationNameMapper other);
}
public class AutoMapper.Configuration.Conventions.ReplaceName : object {
    [CompilerGeneratedAttribute]
private List`1<MemberNameReplacer> <MemberNameReplacers>k__BackingField;
    public List`1<MemberNameReplacer> MemberNameReplacers { get; }
    [CompilerGeneratedAttribute]
public List`1<MemberNameReplacer> get_MemberNameReplacers();
    public sealed virtual MemberInfo GetSourceMember(TypeDetails sourceTypeDetails, Type destType, Type destMemberType, string nameToSearch);
    public sealed virtual void Merge(ISourceToDestinationNameMapper other);
    private String[] PossibleNames(string nameToSearch);
    [CompilerGeneratedAttribute]
private ValueTuple`2<MemberInfo, String[]> <GetSourceMember>b__3_0(MemberInfo mi);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.Configuration.CtorParamConfigurationExpression`2 : object {
    [CompilerGeneratedAttribute]
private string <CtorParamName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    private List`1<Action`1<ConstructorParameterMap>> _ctorParamActions;
    public string CtorParamName { get; }
    public Type SourceType { get; }
    public CtorParamConfigurationExpression`2(string ctorParamName, Type sourceType);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CtorParamName();
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    public sealed virtual void MapFrom(Expression`1<Func`2<TSource, TMember>> sourceMember);
    public sealed virtual void MapFrom(Func`3<TSource, ResolutionContext, TMember> resolver);
    public sealed virtual void MapFrom(string sourceMembersPath);
    public sealed virtual void ExplicitExpansion(bool value);
    public sealed virtual void Configure(TypeMap typeMap);
}
public interface AutoMapper.Configuration.ICtorParamConfigurationExpression {
    public abstract virtual void MapFrom(string sourceMembersPath);
    public abstract virtual void ExplicitExpansion(bool value);
}
public interface AutoMapper.Configuration.ICtorParamConfigurationExpression`1 {
    public abstract virtual void MapFrom(Expression`1<Func`2<TSource, TMember>> sourceMember);
    public abstract virtual void MapFrom(Func`3<TSource, ResolutionContext, TMember> resolver);
}
public interface AutoMapper.Configuration.ICtorParameterConfiguration {
    public string CtorParamName { get; }
    public abstract virtual string get_CtorParamName();
    public abstract virtual void Configure(TypeMap typeMap);
}
public interface AutoMapper.Configuration.IMemberConfigurationProvider {
    public abstract virtual void ApplyConfiguration(IMemberConfigurationExpression memberConfigurationExpression);
}
public interface AutoMapper.Configuration.IPathConfigurationExpression`3 {
    public abstract virtual void MapFrom(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public abstract virtual void Ignore();
    public abstract virtual void Condition(Func`2<ConditionParameters`3<TSource, TDestination, TMember>, bool> condition);
}
public interface AutoMapper.Configuration.IPropertyMapConfiguration {
    public MemberInfo DestinationMember { get; }
    public LambdaExpression SourceExpression { get; }
    public bool Ignored { get; }
    public abstract virtual void Configure(TypeMap typeMap);
    public abstract virtual MemberInfo get_DestinationMember();
    public abstract virtual LambdaExpression get_SourceExpression();
    public abstract virtual LambdaExpression GetDestinationExpression();
    public abstract virtual IPropertyMapConfiguration Reverse();
    public virtual bool get_Ignored();
}
public interface AutoMapper.Configuration.ISourceMemberConfiguration {
    public abstract virtual void Configure(TypeMap typeMap);
}
public interface AutoMapper.Configuration.ISourceMemberConfigurationExpression {
    public abstract virtual void DoNotValidate();
}
public class AutoMapper.Configuration.MappingExpression : MappingExpressionBase`3<object, object, IMappingExpression> {
    [CompilerGeneratedAttribute]
private String[] <IncludedMembersNames>k__BackingField;
    public String[] IncludedMembersNames { get; internal set; }
    public MappingExpression(TypePair types, MemberList memberList);
    public MappingExpression(TypeMap typeMap);
    [CompilerGeneratedAttribute]
public String[] get_IncludedMembersNames();
    [CompilerGeneratedAttribute]
internal void set_IncludedMembersNames(String[] value);
    public sealed virtual IMappingExpression ReverseMap();
    public sealed virtual IMappingExpression IncludeMembers(String[] memberNames);
    public sealed virtual void ForAllMembers(Action`1<IMemberConfigurationExpression> memberOptions);
    public sealed virtual IMappingExpression ForMember(string name, Action`1<IMemberConfigurationExpression> memberOptions);
    protected virtual void IgnoreDestinationMember(MemberInfo property, bool ignorePaths);
    internal MemberConfigurationExpression ForMember(MemberInfo destinationProperty, Action`1<IMemberConfigurationExpression> memberOptions);
}
public class AutoMapper.Configuration.MappingExpression`2 : MappingExpressionBase`3<TSource, TDestination, IMappingExpression`2<TSource, TDestination>> {
    public MappingExpression`2(MemberList memberList, bool projection);
    public MappingExpression`2(MemberList memberList, Type sourceType, Type destinationType);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForPath(Expression`1<Func`2<TDestination, TMember>> destinationMember, Action`1<IPathConfigurationExpression`3<TSource, TDestination, TMember>> memberOptions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForMember(Expression`1<Func`2<TDestination, TMember>> destinationMember, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, TMember>> memberOptions);
    private void IncludeMembersCore(LambdaExpression[] memberExpressions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> IncludeMembers(Expression`1[] memberExpressions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForMember(string name, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public sealed virtual void ForAllMembers(Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public sealed virtual IMappingExpression`2<TSource, TDestination> Include();
    public sealed virtual IMappingExpression`2<TSource, TDestination> IncludeBase();
    public sealed virtual IMappingExpression`2<TSource, TDestination> ForSourceMember(Expression`1<Func`2<TSource, object>> sourceMember, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public sealed virtual void As();
    public sealed virtual IMappingExpression`2<TSource, TDestination> AddTransform(Expression`1<Func`2<TValue, TValue>> transformer);
    public sealed virtual IMappingExpression`2<TDestination, TSource> ReverseMap();
    private IMappingExpression`2<TSource, TDestination> ForDestinationMember(MemberInfo destinationProperty, Action`1<MemberConfigurationExpression`3<TSource, TDestination, TMember>> memberOptions);
    protected virtual void IgnoreDestinationMember(MemberInfo property, bool ignorePaths);
    private sealed virtual override IProjectionExpression`2<TSource, TDestination> AutoMapper.IProjectionExpression<TSource,TDestination>.ForMember(Expression`1<Func`2<TDestination, TMember>> destinationMember, Action`1<IProjectionMemberConfiguration`3<TSource, TDestination, TMember>> memberOptions);
    private sealed virtual override IProjectionExpression`2<TSource, TDestination> AutoMapper.IProjectionExpression<TSource,TDestination,AutoMapper.IProjectionExpression<TSource,TDestination>>.AddTransform(Expression`1<Func`2<TValue, TValue>> transformer);
    private sealed virtual override IProjectionExpression`2<TSource, TDestination> AutoMapper.IProjectionExpression<TSource,TDestination,AutoMapper.IProjectionExpression<TSource,TDestination>>.IncludeMembers(Expression`1[] memberExpressions);
    private sealed virtual override IProjectionExpression`2<TSource, TDestination> AutoMapper.IProjectionExpressionBase<TSource,TDestination,AutoMapper.IProjectionExpression<TSource,TDestination>>.MaxDepth(int depth);
    private sealed virtual override IProjectionExpression`2<TSource, TDestination> AutoMapper.IProjectionExpressionBase<TSource,TDestination,AutoMapper.IProjectionExpression<TSource,TDestination>>.ValidateMemberList(MemberList memberList);
    private sealed virtual override IProjectionExpression`2<TSource, TDestination> AutoMapper.IProjectionExpressionBase<TSource,TDestination,AutoMapper.IProjectionExpression<TSource,TDestination>>.ConstructUsing(Expression`1<Func`2<TSource, TDestination>> ctor);
    private sealed virtual override IProjectionExpression`2<TSource, TDestination> AutoMapper.IProjectionExpressionBase<TSource,TDestination,AutoMapper.IProjectionExpression<TSource,TDestination>>.ForCtorParam(string ctorParamName, Action`1<ICtorParamConfigurationExpression`1<TSource>> paramOptions);
}
public abstract class AutoMapper.Configuration.MappingExpressionBase`3 : TypeMapConfiguration {
    protected MappingExpressionBase`3(MemberList memberList);
    protected MappingExpressionBase`3(MemberList memberList, Type sourceType, Type destinationType);
    protected MappingExpressionBase`3(MemberList memberList, TypePair types);
    public sealed virtual void As(Type typeOverride);
    public sealed virtual TMappingExpression MaxDepth(int depth);
    public sealed virtual TMappingExpression ConstructUsingServiceLocator();
    public sealed virtual TMappingExpression BeforeMap(Action`2<TSource, TDestination> beforeFunction);
    private TMappingExpression BeforeMapCore(Expression`1<Action`3<TSource, TDestination, ResolutionContext>> expr);
    public sealed virtual TMappingExpression BeforeMap(Action`3<TSource, TDestination, ResolutionContext> beforeFunction);
    public sealed virtual TMappingExpression BeforeMap();
    public sealed virtual TMappingExpression AfterMap();
    private static void CallMapAction(TSource source, TDestination destination, ResolutionContext context);
    public sealed virtual TMappingExpression AfterMap(Action`2<TSource, TDestination> afterFunction);
    private TMappingExpression AfterMapCore(Expression`1<Action`3<TSource, TDestination, ResolutionContext>> expr);
    public sealed virtual TMappingExpression AfterMap(Action`3<TSource, TDestination, ResolutionContext> afterFunction);
    public sealed virtual TMappingExpression PreserveReferences();
    public sealed virtual TMappingExpression DisableCtorValidation();
    public sealed virtual TMappingExpression ValidateMemberList(MemberList memberList);
    public sealed virtual TMappingExpression IncludeAllDerived();
    public sealed virtual TMappingExpression Include(Type otherSourceType, Type otherDestinationType);
    public sealed virtual TMappingExpression IncludeBase(Type sourceBase, Type destinationBase);
    public sealed virtual TMappingExpression ForSourceMember(string sourceMemberName, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public sealed virtual TMappingExpression ConstructUsing(Expression`1<Func`2<TSource, TDestination>> ctor);
    private TMappingExpression ConstructUsingCore(LambdaExpression ctor);
    public sealed virtual TMappingExpression ConstructUsing(Func`3<TSource, ResolutionContext, TDestination> ctor);
    public sealed virtual void ConvertUsing(Type typeConverterType);
    public sealed virtual void ConvertUsing(Func`3<TSource, TDestination, TDestination> mappingFunction);
    private void ConvertUsingCore(Expression`1<Func`4<TSource, TDestination, ResolutionContext, TDestination>> expr);
    private void SetTypeConverter(TypeConverter typeConverter);
    public sealed virtual void ConvertUsing(Func`4<TSource, TDestination, ResolutionContext, TDestination> mappingFunction);
    public sealed virtual void ConvertUsing(ITypeConverter`2<TSource, TDestination> converter);
    public sealed virtual void ConvertUsing();
    public sealed virtual TMappingExpression ForCtorParam(string ctorParamName, Action`1<ICtorParamConfigurationExpression`1<TSource>> paramOptions);
    public sealed virtual TMappingExpression IgnoreAllPropertiesWithAnInaccessibleSetter();
    public sealed virtual TMappingExpression IgnoreAllSourcePropertiesWithAnInaccessibleSetter();
    private static IEnumerable`1<PropertyInfo> PropertiesWithAnInaccessibleSetter(Type type);
    public sealed virtual void ConvertUsing(Expression`1<Func`2<TSource, TDestination>> mappingFunction);
    public sealed virtual TMappingExpression AsProxy();
}
public class AutoMapper.Configuration.MemberConfigurationExpression : MemberConfigurationExpression`3<object, object, object> {
    public MemberConfigurationExpression(MemberInfo destinationMember, Type sourceType);
    public sealed virtual void MapFrom(Type valueResolverType);
    public sealed virtual void MapFrom(Type valueResolverType, string sourceMemberName);
    public sealed virtual void MapFrom(IMemberValueResolver`4<TSource, TDestination, TSourceMember, TDestMember> resolver, string sourceMemberName);
    public sealed virtual void ConvertUsing(Type valueConverterType);
    public sealed virtual void ConvertUsing(Type valueConverterType, string sourceMemberName);
    public sealed virtual void ConvertUsing(IValueConverter`2<TSourceMember, TDestinationMember> valueConverter, string sourceMemberName);
    private void ConvertUsingCore(Type valueConverterType, string sourceMemberName);
}
public class AutoMapper.Configuration.MemberConfigurationExpression`3 : object {
    private MemberInfo[] _sourceMembers;
    private Type _sourceType;
    [CompilerGeneratedAttribute]
private List`1<Action`1<PropertyMap>> <PropertyMapActions>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <DestinationMember>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SourceExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    protected List`1<Action`1<PropertyMap>> PropertyMapActions { get; }
    public MemberInfo DestinationMember { get; }
    public LambdaExpression SourceExpression { get; private set; }
    public bool Ignored { get; private set; }
    public MemberConfigurationExpression`3(MemberInfo destinationMember, Type sourceType);
    [CompilerGeneratedAttribute]
protected List`1<Action`1<PropertyMap>> get_PropertyMapActions();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_DestinationMember();
    public sealed virtual void MapAtRuntime();
    public sealed virtual void NullSubstitute(object nullSubstitute);
    public sealed virtual void MapFrom();
    protected void MapFromCore(ClassValueResolver config);
    protected void SetResolver(IValueResolver config);
    public sealed virtual void MapFrom(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public sealed virtual void MapFrom(string sourceMemberName);
    private void MapFromCore(Expression`1<Func`2<TSource, TSourceMember>> sourceMember, string sourceMemberName);
    public sealed virtual void MapFrom(IValueResolver`3<TSource, TDestination, TMember> valueResolver);
    public sealed virtual void MapFrom(IMemberValueResolver`4<TSource, TDestination, TSourceMember, TMember> valueResolver, Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public sealed virtual void MapFrom(Func`3<TSource, TDestination, TResult> mappingFunction);
    public sealed virtual void MapFrom(Func`4<TSource, TDestination, TMember, TResult> mappingFunction);
    public sealed virtual void MapFrom(Func`5<TSource, TDestination, TMember, ResolutionContext, TResult> mappingFunction);
    private void MapFromFunc(Expression`1<Func`5<TSource, TDestination, TMember, ResolutionContext, TResult>> expr);
    public sealed virtual void MapFrom(Expression`1<Func`2<TSource, TSourceMember>> mapExpression);
    internal void MapFromExpression(LambdaExpression sourceExpression);
    public sealed virtual void MapFrom(string sourceMembersPath);
    public sealed virtual void Condition(Func`6<TSource, TDestination, TMember, TMember, ResolutionContext, bool> condition);
    public sealed virtual void Condition(Func`5<TSource, TDestination, TMember, TMember, bool> condition);
    public sealed virtual void Condition(Func`4<TSource, TDestination, TMember, bool> condition);
    public sealed virtual void Condition(Func`3<TSource, TDestination, bool> condition);
    public sealed virtual void Condition(Func`2<TSource, bool> condition);
    private void ConditionCore(Expression`1<Func`6<TSource, TDestination, TMember, TMember, ResolutionContext, bool>> expr);
    public sealed virtual void PreCondition(Func`2<TSource, bool> condition);
    public sealed virtual void PreCondition(Func`2<ResolutionContext, bool> condition);
    public sealed virtual void PreCondition(Func`3<TSource, ResolutionContext, bool> condition);
    public sealed virtual void PreCondition(Func`4<TSource, TDestination, ResolutionContext, bool> condition);
    private void PreConditionCore(Expression`1<Func`4<TSource, TDestination, ResolutionContext, bool>> expr);
    public sealed virtual void AddTransform(Expression`1<Func`2<TMember, TMember>> transformer);
    public sealed virtual void ExplicitExpansion(bool value);
    public sealed virtual void Ignore();
    public void Ignore(bool ignorePaths);
    public sealed virtual void AllowNull();
    public sealed virtual void DoNotAllowNull();
    private void SetAllowNull(bool value);
    public sealed virtual void UseDestinationValue();
    private void SetUseDestinationValue(bool value);
    public sealed virtual void SetMappingOrder(int mappingOrder);
    public sealed virtual void ConvertUsing();
    public sealed virtual void ConvertUsing(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public sealed virtual void ConvertUsing(string sourceMemberName);
    public sealed virtual void ConvertUsing(IValueConverter`2<TSourceMember, TMember> valueConverter);
    public sealed virtual void ConvertUsing(IValueConverter`2<TSourceMember, TMember> valueConverter, Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public sealed virtual void ConvertUsing(IValueConverter`2<TSourceMember, TMember> valueConverter, string sourceMemberName);
    private void ConvertUsingCore(Expression`1<Func`2<TSource, TSourceMember>> sourceMember, string sourceMemberName);
    protected void ConvertUsingCore(ValueConverter converter);
    private void ConvertUsingCore(IValueConverter`2<TSourceMember, TMember> valueConverter, Expression`1<Func`2<TSource, TSourceMember>> sourceMember, string sourceMemberName);
    public sealed virtual void Configure(TypeMap typeMap);
    private void Apply(PropertyMap propertyMap);
    [CompilerGeneratedAttribute]
public sealed virtual LambdaExpression get_SourceExpression();
    [CompilerGeneratedAttribute]
private void set_SourceExpression(LambdaExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Ignored();
    [CompilerGeneratedAttribute]
private void set_Ignored(bool value);
    public sealed virtual LambdaExpression GetDestinationExpression();
    public sealed virtual IPropertyMapConfiguration Reverse();
    public sealed virtual void DoNotUseDestinationValue();
}
public class AutoMapper.Configuration.PathConfigurationExpression`3 : object {
    private LambdaExpression _destinationExpression;
    private LambdaExpression _sourceExpression;
    [CompilerGeneratedAttribute]
private List`1<Action`1<PathMap>> <PathMapActions>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberPath <MemberPath>k__BackingField;
    private List`1<Action`1<PathMap>> PathMapActions { get; }
    public MemberPath MemberPath { get; }
    public MemberInfo DestinationMember { get; }
    public LambdaExpression SourceExpression { get; }
    public PathConfigurationExpression`3(LambdaExpression destinationExpression, Stack`1<Member> chain);
    [CompilerGeneratedAttribute]
private List`1<Action`1<PathMap>> get_PathMapActions();
    [CompilerGeneratedAttribute]
public MemberPath get_MemberPath();
    public sealed virtual MemberInfo get_DestinationMember();
    public sealed virtual void MapFrom(Expression`1<Func`2<TSource, TSourceMember>> sourceExpression);
    public sealed virtual void Ignore();
    public void MapFromUntyped(LambdaExpression sourceExpression);
    public sealed virtual void Configure(TypeMap typeMap);
    private void Apply(PathMap pathMap);
    internal static IPropertyMapConfiguration Create(LambdaExpression destination, LambdaExpression source);
    public sealed virtual LambdaExpression get_SourceExpression();
    public sealed virtual LambdaExpression GetDestinationExpression();
    public sealed virtual IPropertyMapConfiguration Reverse();
    public sealed virtual void Condition(Func`2<ConditionParameters`3<TSource, TDestination, TMember>, bool> condition);
}
public class AutoMapper.Configuration.SourceMappingExpression : object {
    private MemberInfo _sourceMember;
    private List`1<Action`1<SourceMemberConfig>> _sourceMemberActions;
    public SourceMappingExpression(MemberInfo sourceMember);
    public sealed virtual void DoNotValidate();
    public sealed virtual void Configure(TypeMap typeMap);
}
public class AutoMapper.Configuration.SourceMemberConfig : object {
    private bool _ignored;
    [CompilerGeneratedAttribute]
private MemberInfo <SourceMember>k__BackingField;
    public MemberInfo SourceMember { get; }
    public SourceMemberConfig(MemberInfo sourceMember);
    [CompilerGeneratedAttribute]
public MemberInfo get_SourceMember();
    public void Ignore();
    public bool IsIgnored();
}
[EditorBrowsableAttribute("1")]
public abstract class AutoMapper.Configuration.TypeMapConfiguration : object {
    private List`1<ValueTransformerConfiguration> _valueTransformers;
    private Features`1<IMappingFeature> _features;
    private List`1<ISourceMemberConfiguration> _sourceMemberConfigurations;
    private List`1<ICtorParameterConfiguration> _ctorParamConfigurations;
    private List`1<IPropertyMapConfiguration> _memberConfigurations;
    private MemberList _memberList;
    private TypePair _types;
    [CompilerGeneratedAttribute]
private Type <DestinationTypeOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Projection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReverseMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTypeConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMapConfiguration <ReverseMapExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action`1<TypeMap>> <TypeMapActions>k__BackingField;
    public Type DestinationTypeOverride { get; protected set; }
    protected bool Projection { get; protected set; }
    public TypePair Types { get; }
    public bool IsReverseMap { get; public set; }
    public bool HasTypeConverter { get; protected set; }
    public TypeMap TypeMap { get; private set; }
    public Type SourceType { get; }
    public Type DestinationType { get; }
    public Features`1<IMappingFeature> Features { get; }
    public TypeMapConfiguration ReverseTypeMap { get; }
    public List`1<ValueTransformerConfiguration> ValueTransformers { get; }
    protected TypeMapConfiguration ReverseMapExpression { get; protected set; }
    protected List`1<Action`1<TypeMap>> TypeMapActions { get; }
    protected List`1<IPropertyMapConfiguration> MemberConfigurations { get; }
    protected List`1<ISourceMemberConfiguration> SourceMemberConfigurations { get; }
    protected List`1<ICtorParameterConfiguration> CtorParamConfigurations { get; }
    protected TypeMapConfiguration(MemberList memberList, Type sourceType, Type destinationType);
    protected TypeMapConfiguration(MemberList memberList, TypePair types);
    [CompilerGeneratedAttribute]
public Type get_DestinationTypeOverride();
    [CompilerGeneratedAttribute]
protected void set_DestinationTypeOverride(Type value);
    [CompilerGeneratedAttribute]
protected bool get_Projection();
    [CompilerGeneratedAttribute]
protected void set_Projection(bool value);
    public TypePair get_Types();
    [CompilerGeneratedAttribute]
public bool get_IsReverseMap();
    [CompilerGeneratedAttribute]
public void set_IsReverseMap(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasTypeConverter();
    [CompilerGeneratedAttribute]
protected void set_HasTypeConverter(bool value);
    [CompilerGeneratedAttribute]
public TypeMap get_TypeMap();
    [CompilerGeneratedAttribute]
private void set_TypeMap(TypeMap value);
    public Type get_SourceType();
    public Type get_DestinationType();
    public sealed virtual Features`1<IMappingFeature> get_Features();
    public TypeMapConfiguration get_ReverseTypeMap();
    public sealed virtual List`1<ValueTransformerConfiguration> get_ValueTransformers();
    [CompilerGeneratedAttribute]
protected TypeMapConfiguration get_ReverseMapExpression();
    [CompilerGeneratedAttribute]
protected void set_ReverseMapExpression(TypeMapConfiguration value);
    [CompilerGeneratedAttribute]
protected List`1<Action`1<TypeMap>> get_TypeMapActions();
    protected List`1<IPropertyMapConfiguration> get_MemberConfigurations();
    protected List`1<ISourceMemberConfiguration> get_SourceMemberConfigurations();
    protected List`1<ICtorParameterConfiguration> get_CtorParamConfigurations();
    public void Configure(TypeMap typeMap, List`1<MemberInfo> sourceMembers);
    protected void ReverseMapCore(TypeMapConfiguration reverseMap);
    private void AddCtorParamConfigurations(TypeMap typeMap);
    private void AddSourceMembersConfigurations(TypeMap typeMap);
    private void AddValueTransformers(TypeMap typeMap);
    private void ConfigureReverseMap(TypeMap typeMap);
    private void MapDestinationCtorToSource(TypeMap typeMap, List`1<MemberInfo> sourceMembers);
    protected IEnumerable`1<IPropertyMapConfiguration> MapToSourceMembers();
    private void ReverseIncludedMembers(TypeMap typeMap);
    private void ReverseSourceMembers(TypeMap typeMap);
    private void ReverseSourceMembers(MemberPath memberPath, LambdaExpression customExpression);
    protected void ForSourceMemberCore(string sourceMemberName, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    protected void ForSourceMemberCore(MemberInfo memberInfo, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    protected void IncludeCore(Type derivedSourceType, Type derivedDestinationType);
    protected void IncludeBaseCore(Type sourceBase, Type destinationBase);
    public IPropertyMapConfiguration GetDestinationMemberConfiguration(MemberInfo destinationMember);
    protected abstract virtual void IgnoreDestinationMember(MemberInfo property, bool ignorePaths);
    [CompilerGeneratedAttribute]
private bool <MapDestinationCtorToSource>g__IsConfigured|60_0(ParameterInfo parameter);
}
[IsReadOnlyAttribute]
public class AutoMapper.Configuration.ValidationContext : ValueType {
    [CompilerGeneratedAttribute]
private TypePair <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberMap <MemberMap>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectMapper <ObjectMapper>k__BackingField;
    public TypePair Types { get; public set; }
    public MemberMap MemberMap { get; public set; }
    public TypeMap TypeMap { get; public set; }
    public IObjectMapper ObjectMapper { get; public set; }
    public ValidationContext(TypePair Types, MemberMap MemberMap, TypeMap TypeMap, IObjectMapper ObjectMapper);
    [CompilerGeneratedAttribute]
public TypePair get_Types();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Types(TypePair value);
    [CompilerGeneratedAttribute]
public MemberMap get_MemberMap();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MemberMap(MemberMap value);
    [CompilerGeneratedAttribute]
public TypeMap get_TypeMap();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeMap(TypeMap value);
    [CompilerGeneratedAttribute]
public IObjectMapper get_ObjectMapper();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectMapper(IObjectMapper value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ValidationContext left, ValidationContext right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ValidationContext left, ValidationContext right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValidationContext other);
    [CompilerGeneratedAttribute]
public void Deconstruct(TypePair& Types, MemberMap& MemberMap, TypeMap& TypeMap, IObjectMapper& ObjectMapper);
}
[DefaultMemberAttribute("Item")]
[EditorBrowsableAttribute("1")]
public class AutoMapper.ConstructorMap : object {
    private Nullable`1<bool> _canResolve;
    private List`1<ConstructorParameterMap> _ctorParams;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Ctor>k__BackingField;
    public ConstructorInfo Ctor { get; private set; }
    public IReadOnlyCollection`1<ConstructorParameterMap> CtorParams { get; }
    public bool CanResolve { get; public set; }
    public ConstructorParameterMap Item { get; }
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Ctor();
    [CompilerGeneratedAttribute]
private void set_Ctor(ConstructorInfo value);
    public IReadOnlyCollection`1<ConstructorParameterMap> get_CtorParams();
    public void Reset(ConstructorInfo ctor);
    public bool get_CanResolve();
    public void set_CanResolve(bool value);
    private bool ParametersCanResolve();
    public ConstructorParameterMap get_Item(string name);
    public void AddParameter(ParameterInfo parameter, IEnumerable`1<MemberInfo> sourceMembers, TypeMap typeMap);
    public bool ApplyMap(TypeMap typeMap, IncludedMember includedMember);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.ConstructorParameterMap : MemberMap {
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludedMember <IncludedMember>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo[] <SourceMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExplicitExpansion>k__BackingField;
    public ParameterInfo Parameter { get; }
    public Type DestinationType { get; }
    public IncludedMember IncludedMember { get; protected set; }
    public MemberInfo[] SourceMembers { get; public set; }
    public string DestinationName { get; }
    public Nullable`1<bool> ExplicitExpansion { get; public set; }
    public ConstructorParameterMap(TypeMap typeMap, ParameterInfo parameter, MemberInfo[] sourceMembers);
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    public virtual Type get_DestinationType();
    [CompilerGeneratedAttribute]
public virtual IncludedMember get_IncludedMember();
    [CompilerGeneratedAttribute]
protected virtual void set_IncludedMember(IncludedMember value);
    [CompilerGeneratedAttribute]
public virtual MemberInfo[] get_SourceMembers();
    [CompilerGeneratedAttribute]
public virtual void set_SourceMembers(MemberInfo[] value);
    public virtual string get_DestinationName();
    public Expression DefaultValue(IGlobalConfiguration configuration);
    public virtual string ToString();
    public bool ApplyMap(ConstructorParameterMap inheritedParameterMap, IncludedMember includedMember);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<bool> get_ExplicitExpansion();
    [CompilerGeneratedAttribute]
public virtual void set_ExplicitExpansion(Nullable`1<bool> value);
}
[IsReadOnlyAttribute]
public class AutoMapper.ContextCacheKey : ValueType {
    [CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestinationType>k__BackingField;
    public object Source { get; public set; }
    public Type DestinationType { get; public set; }
    public ContextCacheKey(object Source, Type DestinationType);
    [CompilerGeneratedAttribute]
public object get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(object value);
    [CompilerGeneratedAttribute]
public Type get_DestinationType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DestinationType(Type value);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ContextCacheKey other);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ContextCacheKey left, ContextCacheKey right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ContextCacheKey left, ContextCacheKey right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public void Deconstruct(Object& Source, Type& DestinationType);
}
public class AutoMapper.DuplicateTypeMapConfigurationException : Exception {
    [CompilerGeneratedAttribute]
private TypeMapConfigErrors[] <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public TypeMapConfigErrors[] Errors { get; }
    public string Message { get; }
    public DuplicateTypeMapConfigurationException(TypeMapConfigErrors[] errors);
    [CompilerGeneratedAttribute]
public TypeMapConfigErrors[] get_Errors();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
}
public class AutoMapper.ExactMatchNamingConvention : object {
    public static ExactMatchNamingConvention Instance;
    public string SeparatorCharacter { get; }
    private static ExactMatchNamingConvention();
    public sealed virtual String[] Split(string _);
    public sealed virtual string get_SeparatorCharacter();
}
public class AutoMapper.Execution.ClassTypeConverter : TypeConverter {
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ConverterInterface>k__BackingField;
    public Type ConverterType { get; private set; }
    public Type ConverterInterface { get; }
    public ClassTypeConverter(Type converterType, Type converterInterface);
    [CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
private void set_ConverterType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ConverterInterface();
    public virtual Expression GetExpression(IGlobalConfiguration configuration, ParameterExpression[] parameters);
    public virtual void CloseGenerics(TypeMapConfiguration openMapConfig, TypePair closedTypes);
}
public class AutoMapper.Execution.ClassValueResolver : ValueResolverConfig {
    public ClassValueResolver(Type concreteType, Type interfaceType);
    public ClassValueResolver(object instance, Type interfaceType);
    public sealed virtual Expression GetExpression(IGlobalConfiguration configuration, MemberMap memberMap, Expression source, Expression destination, Expression destinationMember);
    public sealed virtual MemberInfo GetSourceMember(MemberMap _);
}
public class AutoMapper.Execution.ConvertParameterReplaceVisitor : ParameterReplaceVisitor {
    public virtual Expression Replace(Expression target, Expression oldNode, Expression newNode);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class AutoMapper.Execution.ExpressionBuilder : object {
    public static MethodInfo ObjectToString;
    public static Expression True;
    public static Expression Null;
    public static Expression Empty;
    public static Expression Zero;
    public static ParameterExpression ExceptionParameter;
    public static ParameterExpression ContextParameter;
    public static MethodInfo IListClear;
    private static MethodInfo ContextCreate;
    private static MethodInfo OverTypeDepthMethod;
    private static MethodCallExpression CheckContextCall;
    private static MethodInfo ContextMapMethod;
    private static MethodInfo ArrayEmptyMethod;
    private static ParameterExpression Disposable;
    private static ReadOnlyCollection`1<ParameterExpression> DisposableArray;
    private static MethodInfo DisposeMethod;
    private static Expression DisposeCall;
    private static ParameterExpression Index;
    private static BinaryExpression ResetIndex;
    private static UnaryExpression IncrementIndex;
    private static ExpressionBuilder();
    [ExtensionAttribute]
public static Expression ReplaceParameters(IGlobalConfiguration configuration, LambdaExpression initialLambda, Expression newParameter);
    [ExtensionAttribute]
public static Expression ReplaceParameters(IGlobalConfiguration configuration, LambdaExpression initialLambda, Expression[] newParameters);
    [ExtensionAttribute]
public static Expression ConvertReplaceParameters(IGlobalConfiguration configuration, LambdaExpression initialLambda, Expression newParameter);
    [ExtensionAttribute]
public static Expression ConvertReplaceParameters(IGlobalConfiguration configuration, LambdaExpression initialLambda, Expression[] newParameters);
    [ExtensionAttribute]
public static DefaultExpression Default(IGlobalConfiguration configuration, Type type);
    [ExtensionAttribute]
public static ValueTuple`2<List`1<ParameterExpression>, List`1<Expression>> Scratchpad(IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, TypePair typePair, Expression source, MemberMap memberMap, Expression destination);
    [ExtensionAttribute]
public static Expression NullCheckSource(IGlobalConfiguration configuration, ProfileMap profileMap, Expression source, Expression destination, Expression mapExpression, MemberMap memberMap);
    public static Expression ServiceLocator(Type type);
    public static Expression ContextMap(TypePair typePair, Expression sourceParameter, Expression destinationParameter, MemberMap memberMap);
    public static Expression CheckContext(TypeMap typeMap);
    public static Expression OverMaxDepth(TypeMap typeMap);
    [ExtensionAttribute]
public static Expression NullSubstitute(MemberMap memberMap, Expression sourceExpression);
    [ExtensionAttribute]
public static Expression ApplyTransformers(MemberMap memberMap, Expression source, IGlobalConfiguration configuration);
    [ExtensionAttribute]
private static Expression ApplyTransformers(MemberMap memberMap, Expression result, IGlobalConfiguration configuration, IEnumerable`1<ValueTransformerConfiguration> transformers);
    [ExtensionAttribute]
public static LambdaExpression Lambda(MemberInfo member);
    [ExtensionAttribute]
public static LambdaExpression Lambda(MemberInfo[] members);
    [ExtensionAttribute]
public static Expression Chain(MemberInfo[] members, Expression target);
    [ExtensionAttribute]
public static MemberInfo[] GetMembersChain(LambdaExpression lambda);
    [ExtensionAttribute]
public static MemberInfo GetMember(LambdaExpression lambda);
    [ExtensionAttribute]
public static MemberInfo[] ToMemberInfos(Stack`1<Member> chain);
    [ExtensionAttribute]
public static Stack`1<Member> GetChain(Expression expression);
    [ExtensionAttribute]
public static IEnumerable`1<MemberExpression> GetMemberExpressions(Expression expression);
    [ExtensionAttribute]
public static bool IsMemberPath(LambdaExpression lambda, Stack`1& members);
    public static LambdaExpression MemberAccessLambda(Type type, string memberPath, TypeMap typeMap);
    public static Expression ForEach(List`1<ParameterExpression> variables, List`1<Expression> statements, ParameterExpression loopVar, Expression collection, Expression loopContent);
    public static MemberExpression Property(Expression target, string name);
    public static MethodCallExpression Call(Expression target, string name);
    public static MethodCallExpression Call(Expression target, string name, Expression[] arguments);
    [ExtensionAttribute]
public static Expression ToObject(Expression expression);
    public static Expression ToType(Expression expression, Type type);
    [ExtensionAttribute]
public static Expression ReplaceParameters(LambdaExpression initialLambda, Expression newParameter);
    [ExtensionAttribute]
private static Expression Replace(ParameterReplaceVisitor visitor, LambdaExpression initialLambda, Expression newParameter);
    [ExtensionAttribute]
private static Expression Replace(ParameterReplaceVisitor visitor, LambdaExpression initialLambda, Expression[] newParameters);
    [ExtensionAttribute]
public static Expression Replace(Expression exp, Expression old, Expression replace);
    [ExtensionAttribute]
public static Expression NullCheck(Expression expression, IGlobalConfiguration configuration, MemberMap memberMap, Expression defaultValue, IncludedMember includedMember);
    [ExtensionAttribute]
public static Expression IfNullElse(Expression expression, Expression then, Expression else);
    [CompilerGeneratedAttribute]
internal static Expression <NullCheckSource>g__ClearDestinationCollection|27_0(<>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
internal static Expression <NullCheckSource>g__DefaultDestination|27_1(<>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
internal static Expression <ForEach>g__ForEachArrayItem|45_0(List`1<ParameterExpression> variables, List`1<Expression> statements, ParameterExpression loopVar, Expression array, Expression loopContent);
    [CompilerGeneratedAttribute]
internal static Expression <ForEach>g__Using|45_1(List`1<Expression> statements, Expression target, Expression body);
    [CompilerGeneratedAttribute]
internal static Expression <NullCheck>g__NullCheck|55_0(Expression variable, <>c__DisplayClass55_0& );
    [CompilerGeneratedAttribute]
internal static Expression <NullCheck>g__UpdateTarget|55_1(Expression sourceExpression, Expression newTarget);
    [CompilerGeneratedAttribute]
internal static MethodCallExpression <NullCheck>g__ExtensionMethod|55_2(MethodInfo method, Expression newTarget, ReadOnlyCollection`1<Expression> args);
}
public class AutoMapper.Execution.ExpressionResolver : LambdaValueResolver {
    public LambdaExpression ProjectToExpression { get; }
    public ExpressionResolver(LambdaExpression lambda);
    public sealed virtual Expression GetExpression(IGlobalConfiguration configuration, MemberMap memberMap, Expression source, Expression _, Expression destinationMember);
    public sealed virtual MemberInfo GetSourceMember(MemberMap _);
    public sealed virtual LambdaExpression get_ProjectToExpression();
}
public class AutoMapper.Execution.ExpressionTypeConverter : LambdaTypeConverter {
    public LambdaExpression ProjectToExpression { get; }
    public ExpressionTypeConverter(LambdaExpression lambda);
    public virtual LambdaExpression get_ProjectToExpression();
}
public class AutoMapper.Execution.FuncResolver : LambdaValueResolver {
    public FuncResolver(LambdaExpression lambda);
    public sealed virtual Expression GetExpression(IGlobalConfiguration configuration, MemberMap memberMap, Expression source, Expression destination, Expression destinationMember);
    public sealed virtual MemberInfo GetSourceMember(MemberMap _);
}
public interface AutoMapper.Execution.IValueResolver {
    public Type ResolvedType { get; }
    public string SourceMemberName { get; }
    public LambdaExpression ProjectToExpression { get; }
    public abstract virtual Expression GetExpression(IGlobalConfiguration configuration, MemberMap memberMap, Expression source, Expression destination, Expression destinationMember);
    public abstract virtual MemberInfo GetSourceMember(MemberMap memberMap);
    public abstract virtual Type get_ResolvedType();
    public virtual string get_SourceMemberName();
    public virtual LambdaExpression get_ProjectToExpression();
    public virtual IValueResolver CloseGenerics(TypeMap typeMap);
}
public class AutoMapper.Execution.LambdaTypeConverter : TypeConverter {
    [CompilerGeneratedAttribute]
private LambdaExpression <Lambda>k__BackingField;
    public LambdaExpression Lambda { get; }
    public LambdaTypeConverter(LambdaExpression lambda);
    [CompilerGeneratedAttribute]
public LambdaExpression get_Lambda();
    public virtual Expression GetExpression(IGlobalConfiguration configuration, ParameterExpression[] parameters);
}
public abstract class AutoMapper.Execution.LambdaValueResolver : object {
    [CompilerGeneratedAttribute]
private LambdaExpression <Lambda>k__BackingField;
    public LambdaExpression Lambda { get; }
    public Type ResolvedType { get; }
    protected LambdaValueResolver(LambdaExpression lambda);
    [CompilerGeneratedAttribute]
public LambdaExpression get_Lambda();
    public sealed virtual Type get_ResolvedType();
}
[IsReadOnlyAttribute]
public class AutoMapper.Execution.Member : ValueType {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Target>k__BackingField;
    public Expression Expression { get; public set; }
    public MemberInfo MemberInfo { get; public set; }
    public Expression Target { get; public set; }
    public Member(Expression Expression, MemberInfo MemberInfo, Expression Target);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MemberInfo(MemberInfo value);
    [CompilerGeneratedAttribute]
public Expression get_Target();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Target(Expression value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Member left, Member right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Member left, Member right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Member other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Expression& Expression, MemberInfo& MemberInfo, Expression& Target);
}
public class AutoMapper.Execution.MemberPathResolver : object {
    private MemberInfo[] _members;
    public Type ResolvedType { get; }
    public LambdaExpression ProjectToExpression { get; }
    public MemberPathResolver(MemberInfo[] members);
    public sealed virtual Type get_ResolvedType();
    public sealed virtual Expression GetExpression(IGlobalConfiguration configuration, MemberMap memberMap, Expression source, Expression destination, Expression destinationMember);
    public sealed virtual MemberInfo GetSourceMember(MemberMap memberMap);
    public sealed virtual LambdaExpression get_ProjectToExpression();
    public sealed virtual IValueResolver CloseGenerics(TypeMap typeMap);
}
[EditorBrowsableAttribute("1")]
public static class AutoMapper.Execution.ObjectFactory : object {
    private static Expression EmptyString;
    private static LockingConcurrentDictionary`2<Type, Func`1<object>> CtorCache;
    private static ObjectFactory();
    public static object CreateInstance(Type type);
    private static Func`1<object> GenerateConstructor(Type type);
    public static object CreateInterfaceProxy(Type interfaceType);
    public static Expression GenerateConstructorExpression(Type type, IGlobalConfiguration configuration);
    private static Expression CallConstructor(Type type, IGlobalConfiguration configuration);
    private static Expression CreateInterfaceExpression(Type type);
    private static Type[] GetIEnumerableArguments(Type type);
    private static Expression CreateCollection(Type type, Type collectionType, Type[] genericArguments);
    private static Expression CreateReadOnlyDictionary(Type[] typeArguments);
    private static Expression InvalidType(Type type, string message);
}
public class AutoMapper.Execution.ParameterReplaceVisitor : ReplaceVisitorBase {
    protected virtual Expression VisitParameter(ParameterExpression node);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Name}-{Type.Name}")]
public class AutoMapper.Execution.PropertyDescription : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public bool CanWrite { get; public set; }
    public PropertyDescription(string Name, Type Type, bool CanWrite);
    public PropertyDescription(PropertyInfo property);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(Type value);
    [CompilerGeneratedAttribute]
public bool get_CanWrite();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanWrite(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PropertyDescription left, PropertyDescription right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PropertyDescription left, PropertyDescription right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PropertyDescription other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, Type& Type, Boolean& CanWrite);
}
public abstract class AutoMapper.Execution.ProxyBase : object {
    protected void NotifyPropertyChanged(PropertyChangedEventHandler handler, string method);
}
public static class AutoMapper.Execution.ProxyGenerator : object {
    private static MethodInfo DelegateCombine;
    private static MethodInfo DelegateRemove;
    private static EventInfo PropertyChanged;
    private static ConstructorInfo ProxyBaseCtor;
    private static ModuleBuilder ProxyModule;
    private static LockingConcurrentDictionary`2<TypeDescription, Type> ProxyTypes;
    private static ProxyGenerator();
    private static ModuleBuilder CreateProxyModule();
    private static Type EmitProxy(TypeDescription typeDescription);
    public static Type GetProxyType(Type interfaceType);
    public static Type GetSimilarType(Type sourceType, IEnumerable`1<PropertyDescription> additionalProperties);
    [CompilerGeneratedAttribute]
internal static TypeBuilder <EmitProxy>g__GenerateType|7_0(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitProxy>g__GeneratePropertyChanged|7_1(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitProxy>g__EventAccessor|7_2(MethodInfo method, MethodInfo delegateMethod, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitProxy>g__GenerateFields|7_3(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static List`1<PropertyDescription> <EmitProxy>g__PropertiesToImplement|7_4(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitProxy>g__GenerateConstructor|7_5(<>c__DisplayClass7_0& );
}
public class AutoMapper.Execution.ReplaceVisitor : ReplaceVisitorBase {
    public virtual Expression Visit(Expression node);
}
public class AutoMapper.Execution.ReplaceVisitorBase : ExpressionVisitor {
    private protected Expression _oldNode;
    private protected Expression _newNode;
    public virtual Expression Replace(Expression target, Expression oldNode, Expression newNode);
}
public abstract class AutoMapper.Execution.TypeConverter : object {
    public LambdaExpression ProjectToExpression { get; }
    public abstract virtual Expression GetExpression(IGlobalConfiguration configuration, ParameterExpression[] parameters);
    public virtual void CloseGenerics(TypeMapConfiguration openMapConfig, TypePair closedTypes);
    public virtual LambdaExpression get_ProjectToExpression();
}
[IsReadOnlyAttribute]
public class AutoMapper.Execution.TypeDescription : ValueType {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyDescription[] <AdditionalProperties>k__BackingField;
    public Type Type { get; public set; }
    public PropertyDescription[] AdditionalProperties { get; public set; }
    public TypeDescription(Type Type, PropertyDescription[] AdditionalProperties);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(Type value);
    [CompilerGeneratedAttribute]
public PropertyDescription[] get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AdditionalProperties(PropertyDescription[] value);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TypeDescription other);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TypeDescription left, TypeDescription right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TypeDescription left, TypeDescription right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public void Deconstruct(Type& Type, PropertyDescription[]& AdditionalProperties);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class AutoMapper.Execution.TypeMapPlanBuilder : ValueType {
    private static MethodInfo MappingError;
    private static MethodInfo IncTypeDepthInfo;
    private static MethodInfo DecTypeDepthInfo;
    private static MethodInfo CacheDestinationMethod;
    private static MethodInfo GetDestinationMethod;
    private IGlobalConfiguration _configuration;
    private ParameterExpression _destination;
    private ParameterExpression _initialDestination;
    private ParameterExpression[] _parameters;
    private TypeMap _typeMap;
    private ParameterExpression _source;
    private List`1<ParameterExpression> _variables;
    private List`1<Expression> _expressions;
    private CatchBlock[] _catches;
    public Type DestinationType { get; }
    public TypeMapPlanBuilder(IGlobalConfiguration configuration, TypeMap typeMap);
    private static TypeMapPlanBuilder();
    public Type get_DestinationType();
    private static AutoMapperMappingException MemberMappingError(Exception innerException, MemberMap memberMap);
    private ParameterExpression[] GetParameters(ParameterExpression first, ParameterExpression second);
    public LambdaExpression CreateMapperLambda();
    private void IncludeMembers();
    private static void CheckForCycles(IGlobalConfiguration configuration, TypeMap typeMap, HashSet`1<TypeMap> typeMapsPath);
    private Expression CreateDestinationFunc();
    private Expression ReplaceParameters(LambdaExpression lambda);
    private Expression CreateAssignmentFunc(Expression createDestination);
    private void AddAfterMap(List`1<Expression> actions);
    private void AddPathMaps(List`1<Expression> actions);
    private void AddBeforeMap(List`1<Expression> actions);
    private void AddPropertyMaps(List`1<Expression> actions);
    private Expression TryPathMap(PathMap pathMap);
    private Expression CreateMapperFunc(Expression assignmentFunc);
    private Expression CheckReferencesCache(Expression valueBuilder);
    private Expression CreateNewDestinationFunc();
    private Expression ConstructorMapping(ConstructorMap constructorMap);
    private Expression CreateConstructorParameterExpression(ConstructorParameterMap ctorParamMap);
    private Expression TryMemberMap(MemberMap memberMap, Expression memberMapExpression);
    private Expression CreatePropertyMapFunc(MemberMap memberMap, Expression destination, MemberInfo destinationMember);
    private Expression DestinationMemberValue(MemberMap memberMap, Expression destinationMemberGetter, bool destinationMemberReadOnly);
    private void Precondition(MemberMap memberMap, ParameterExpression customSource);
    private ParameterExpression SetVariables(Expression valueResolver, ParameterExpression resolvedValueVariable, Expression mappedMember);
    private Expression MapMember(MemberMap memberMap, ParameterExpression resolvedValue, Expression destinationMemberValue);
    private Expression BuildValueResolverFunc(MemberMap memberMap, Expression customSource, Expression destValueExpr);
    private ParameterExpression GetCustomSource(MemberMap memberMap);
    [CompilerGeneratedAttribute]
internal static void <CreateMapperLambda>g__Clear|19_0(HashSet`1& typeMapsPath);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<MemberMap> <CheckForCycles>g__MemberMaps|21_0(<>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static TypeMap <CheckForCycles>g__ResolveMemberTypeMap|21_1(MemberMap memberMap, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
[ConditionalAttribute("DEBUG")]
internal static void <CheckForCycles>g__Trace|21_2(TypeMap typeMap, TypeMap memberTypeMap, MemberMap memberMap);
    [CompilerGeneratedAttribute]
[ConditionalAttribute("DEBUG")]
internal static void <CheckForCycles>g__TraceInline|21_3(TypeMap typeMap, MemberMap memberMap);
    [CompilerGeneratedAttribute]
internal static Expression <TryPathMap>g__GetSetter|29_0(MemberExpression memberExpression);
}
public class AutoMapper.Execution.ValueConverter : ValueResolverConfig {
    public ValueConverter(Type concreteType, Type interfaceType);
    public ValueConverter(object instance, Type interfaceType);
    public sealed virtual Expression GetExpression(IGlobalConfiguration configuration, MemberMap memberMap, Expression source, Expression _, Expression destinationMember);
    public sealed virtual MemberInfo GetSourceMember(MemberMap memberMap);
    [CompilerGeneratedAttribute]
private AutoMapperConfigurationException <GetExpression>g__BuildExceptionMessage|2_0();
}
public abstract class AutoMapper.Execution.ValueResolverConfig : object {
    private protected Expression _instance;
    [CompilerGeneratedAttribute]
private Type <ConcreteType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <InterfaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SourceMemberLambda>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceMemberName>k__BackingField;
    public Type ConcreteType { get; }
    public Type InterfaceType { get; }
    public LambdaExpression SourceMemberLambda { get; public set; }
    public string SourceMemberName { get; public set; }
    public Type ResolvedType { get; }
    protected ValueResolverConfig(Type concreteType, Type interfaceType, Expression instance);
    protected ValueResolverConfig(object instance, Type interfaceType);
    [CompilerGeneratedAttribute]
public Type get_ConcreteType();
    [CompilerGeneratedAttribute]
public Type get_InterfaceType();
    [CompilerGeneratedAttribute]
public LambdaExpression get_SourceMemberLambda();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceMemberLambda(LambdaExpression value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceMemberName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceMemberName(string value);
    public sealed virtual Type get_ResolvedType();
}
[ExtensionAttribute]
public static class AutoMapper.Features.FeatureExtensions : object {
    [ExtensionAttribute]
public static IMapperConfigurationExpression SetFeature(IMapperConfigurationExpression configuration, IGlobalFeature feature);
    [ExtensionAttribute]
public static IMappingExpression`2<TSource, TDestination> SetFeature(IMappingExpression`2<TSource, TDestination> mapping, IMappingFeature feature);
    [ExtensionAttribute]
internal static void Configure(Features`1<IGlobalFeature> features, MapperConfiguration mapperConfiguration);
    [ExtensionAttribute]
public static void ReverseTo(Features`1<IMappingFeature> features, Features`1<IMappingFeature> reversedFeatures);
    [ExtensionAttribute]
internal static void Configure(Features`1<IMappingFeature> features, TypeMap typeMap);
    [ExtensionAttribute]
internal static void Seal(Features`1<IRuntimeFeature> features, IGlobalConfiguration configuration);
}
public class AutoMapper.Features.Features`1 : object {
    private List`1<TFeature> _features;
    public int Count { get; }
    public int get_Count();
    public TFeatureToFind Get();
    public void Set(TFeature feature);
    private int IndexOf(Type featureType);
    public Enumerator<TFeature> GetEnumerator();
}
public interface AutoMapper.Features.IGlobalFeature {
    public abstract virtual void Configure(IGlobalConfiguration configuration);
}
public interface AutoMapper.Features.IMappingFeature {
    public abstract virtual void Configure(TypeMap typeMap);
    public abstract virtual IMappingFeature Reverse();
}
public interface AutoMapper.Features.IRuntimeFeature {
    public abstract virtual void Seal(IGlobalConfiguration configuration);
}
public interface AutoMapper.IConfigurationProvider {
    public abstract virtual void AssertConfigurationIsValid();
    public abstract virtual IMapper CreateMapper();
    public abstract virtual IMapper CreateMapper(Func`2<Type, object> serviceCtor);
    public abstract virtual LambdaExpression BuildExecutionPlan(Type sourceType, Type destinationType);
    public abstract virtual void CompileMappings();
}
internal interface AutoMapper.IInternalRuntimeMapper {
    public ResolutionContext DefaultContext { get; }
    public Func`2<Type, object> ServiceCtor { get; }
    public abstract virtual TDestination Map(TSource source, TDestination destination, ResolutionContext context, Type sourceType, Type destinationType, MemberMap memberMap);
    public abstract virtual ResolutionContext get_DefaultContext();
    public abstract virtual Func`2<Type, object> get_ServiceCtor();
}
public interface AutoMapper.IMapper {
    public IConfigurationProvider ConfigurationProvider { get; }
    public abstract virtual TDestination Map(object source, Action`1<IMappingOperationOptions`2<object, TDestination>> opts);
    public abstract virtual TDestination Map(TSource source, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    public abstract virtual TDestination Map(TSource source, TDestination destination, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    public abstract virtual object Map(object source, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions`2<object, object>> opts);
    public abstract virtual object Map(object source, object destination, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions`2<object, object>> opts);
    public abstract virtual IConfigurationProvider get_ConfigurationProvider();
    public abstract virtual IQueryable`1<TDestination> ProjectTo(IQueryable source, object parameters, Expression`1[] membersToExpand);
    public abstract virtual IQueryable`1<TDestination> ProjectTo(IQueryable source, IDictionary`2<string, object> parameters, String[] membersToExpand);
    public abstract virtual IQueryable ProjectTo(IQueryable source, Type destinationType, IDictionary`2<string, object> parameters, String[] membersToExpand);
}
public interface AutoMapper.IMapperBase {
    public abstract virtual TDestination Map(object source);
    public abstract virtual TDestination Map(TSource source);
    public abstract virtual TDestination Map(TSource source, TDestination destination);
    public abstract virtual object Map(object source, Type sourceType, Type destinationType);
    public abstract virtual object Map(object source, object destination, Type sourceType, Type destinationType);
}
public interface AutoMapper.IMapperConfigurationExpression {
    public abstract virtual void AddProfile(Profile profile);
    public abstract virtual void AddProfile();
    public abstract virtual void AddProfile(Type profileType);
    public abstract virtual void AddProfiles(IEnumerable`1<Profile> enumerableOfProfiles);
    public abstract virtual void AddMaps(IEnumerable`1<Assembly> assembliesToScan);
    public abstract virtual void AddMaps(Assembly[] assembliesToScan);
    public abstract virtual void AddMaps(IEnumerable`1<string> assemblyNamesToScan);
    public abstract virtual void AddMaps(String[] assemblyNamesToScan);
    public abstract virtual void AddMaps(IEnumerable`1<Type> typesFromAssembliesContainingMappingDefinitions);
    public abstract virtual void AddMaps(Type[] typesFromAssembliesContainingMappingDefinitions);
    public abstract virtual void ConstructServicesUsing(Func`2<Type, object> constructor);
    public abstract virtual void CreateProfile(string profileName, Action`1<IProfileExpression> config);
}
public interface AutoMapper.IMappingAction`2 {
    public abstract virtual void Process(TSource source, TDestination destination, ResolutionContext context);
}
public interface AutoMapper.IMappingExpression {
    public abstract virtual IMappingExpression IncludeMembers(String[] memberNames);
    public abstract virtual IMappingExpression ReverseMap();
    public abstract virtual void ForAllMembers(Action`1<IMemberConfigurationExpression> memberOptions);
    public abstract virtual IMappingExpression ForMember(string name, Action`1<IMemberConfigurationExpression> memberOptions);
}
public interface AutoMapper.IMappingExpression`2 {
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForPath(Expression`1<Func`2<TDestination, TMember>> destinationMember, Action`1<IPathConfigurationExpression`3<TSource, TDestination, TMember>> memberOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForMember(Expression`1<Func`2<TDestination, TMember>> destinationMember, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, TMember>> memberOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForMember(string name, Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public abstract virtual void ForAllMembers(Action`1<IMemberConfigurationExpression`3<TSource, TDestination, object>> memberOptions);
    public abstract virtual IMappingExpression`2<TSource, TDestination> Include();
    public abstract virtual IMappingExpression`2<TSource, TDestination> IncludeBase();
    public abstract virtual IMappingExpression`2<TSource, TDestination> ForSourceMember(Expression`1<Func`2<TSource, object>> sourceMember, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public abstract virtual IMappingExpression`2<TDestination, TSource> ReverseMap();
    public abstract virtual void As();
}
public interface AutoMapper.IMappingExpressionBase`3 {
    public abstract virtual TMappingExpression DisableCtorValidation();
    public abstract virtual TMappingExpression ConstructUsingServiceLocator();
    public abstract virtual TMappingExpression PreserveReferences();
    public abstract virtual TMappingExpression BeforeMap(Action`2<TSource, TDestination> beforeFunction);
    public abstract virtual TMappingExpression BeforeMap(Action`3<TSource, TDestination, ResolutionContext> beforeFunction);
    public abstract virtual TMappingExpression BeforeMap();
    public abstract virtual TMappingExpression AfterMap(Action`2<TSource, TDestination> afterFunction);
    public abstract virtual TMappingExpression AfterMap(Action`3<TSource, TDestination, ResolutionContext> afterFunction);
    public abstract virtual TMappingExpression AfterMap();
    public abstract virtual TMappingExpression IncludeAllDerived();
    public abstract virtual TMappingExpression Include(Type derivedSourceType, Type derivedDestinationType);
    public abstract virtual TMappingExpression IncludeBase(Type sourceBase, Type destinationBase);
    public abstract virtual TMappingExpression ForSourceMember(string sourceMemberName, Action`1<ISourceMemberConfigurationExpression> memberOptions);
    public abstract virtual TMappingExpression IgnoreAllPropertiesWithAnInaccessibleSetter();
    public abstract virtual TMappingExpression IgnoreAllSourcePropertiesWithAnInaccessibleSetter();
    public abstract virtual TMappingExpression ConstructUsing(Func`3<TSource, ResolutionContext, TDestination> ctor);
    public abstract virtual void As(Type typeOverride);
    public abstract virtual TMappingExpression AsProxy();
    public abstract virtual void ConvertUsing(Type typeConverterType);
    public abstract virtual void ConvertUsing(Func`3<TSource, TDestination, TDestination> mappingFunction);
    public abstract virtual void ConvertUsing(Func`4<TSource, TDestination, ResolutionContext, TDestination> mappingFunction);
    public abstract virtual void ConvertUsing(ITypeConverter`2<TSource, TDestination> converter);
    public abstract virtual void ConvertUsing();
}
public interface AutoMapper.IMappingOperationOptions {
    public Func`2<Type, object> ServiceCtor { get; }
    public object State { get; public set; }
    public Dictionary`2<string, object> Items { get; }
    public abstract virtual Func`2<Type, object> get_ServiceCtor();
    public abstract virtual void ConstructServicesUsing(Func`2<Type, object> constructor);
    public abstract virtual object get_State();
    public abstract virtual void set_State(object value);
    public abstract virtual Dictionary`2<string, object> get_Items();
    public abstract virtual void BeforeMap(Action`2<object, object> beforeFunction);
    public abstract virtual void AfterMap(Action`2<object, object> afterFunction);
}
public interface AutoMapper.IMappingOperationOptions`2 {
    public abstract virtual void BeforeMap(Action`2<TSource, TDestination> beforeFunction);
    public abstract virtual void AfterMap(Action`2<TSource, TDestination> afterFunction);
}
public interface AutoMapper.IMemberConfigurationExpression {
    public abstract virtual void MapFrom(Type valueResolverType);
    public abstract virtual void MapFrom(Type valueResolverType, string sourceMemberName);
    public abstract virtual void MapFrom(IMemberValueResolver`4<TSource, TDestination, TSourceMember, TDestMember> valueResolver, string sourceMemberName);
    public abstract virtual void ConvertUsing(Type valueConverterType);
    public abstract virtual void ConvertUsing(Type valueConverterType, string sourceMemberName);
    public abstract virtual void ConvertUsing(IValueConverter`2<TSourceMember, TDestinationMember> valueConverter, string sourceMemberName);
}
public interface AutoMapper.IMemberConfigurationExpression`3 {
    public MemberInfo DestinationMember { get; }
    public abstract virtual void MapAtRuntime();
    public abstract virtual void MapFrom();
    public abstract virtual void MapFrom(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public abstract virtual void MapFrom(string sourceMemberName);
    public abstract virtual void MapFrom(IValueResolver`3<TSource, TDestination, TMember> valueResolver);
    public abstract virtual void MapFrom(IMemberValueResolver`4<TSource, TDestination, TSourceMember, TMember> valueResolver, Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public abstract virtual void MapFrom(Func`3<TSource, TDestination, TResult> mappingFunction);
    public abstract virtual void MapFrom(Func`4<TSource, TDestination, TMember, TResult> mappingFunction);
    public abstract virtual void MapFrom(Func`5<TSource, TDestination, TMember, ResolutionContext, TResult> mappingFunction);
    public abstract virtual void MapFrom(string sourceMembersPath);
    public abstract virtual void SetMappingOrder(int mappingOrder);
    public abstract virtual void DoNotUseDestinationValue();
    public abstract virtual void UseDestinationValue();
    public abstract virtual void Condition(Func`6<TSource, TDestination, TMember, TMember, ResolutionContext, bool> condition);
    public abstract virtual void Condition(Func`5<TSource, TDestination, TMember, TMember, bool> condition);
    public abstract virtual void Condition(Func`4<TSource, TDestination, TMember, bool> condition);
    public abstract virtual void Condition(Func`3<TSource, TDestination, bool> condition);
    public abstract virtual void Condition(Func`2<TSource, bool> condition);
    public abstract virtual void PreCondition(Func`2<TSource, bool> condition);
    public abstract virtual void PreCondition(Func`2<ResolutionContext, bool> condition);
    public abstract virtual void PreCondition(Func`3<TSource, ResolutionContext, bool> condition);
    public abstract virtual void PreCondition(Func`4<TSource, TDestination, ResolutionContext, bool> condition);
    public abstract virtual MemberInfo get_DestinationMember();
    public abstract virtual void ConvertUsing();
    public abstract virtual void ConvertUsing(Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public abstract virtual void ConvertUsing(string sourceMemberName);
    public abstract virtual void ConvertUsing(IValueConverter`2<TSourceMember, TMember> valueConverter);
    public abstract virtual void ConvertUsing(IValueConverter`2<TSourceMember, TMember> valueConverter, Expression`1<Func`2<TSource, TSourceMember>> sourceMember);
    public abstract virtual void ConvertUsing(IValueConverter`2<TSourceMember, TMember> valueConverter, string sourceMemberName);
}
public interface AutoMapper.IMemberValueResolver`4 {
    public abstract virtual TDestMember Resolve(TSource source, TDestination destination, TSourceMember sourceMember, TDestMember destMember, ResolutionContext context);
}
public interface AutoMapper.INamingConvention {
    public string SeparatorCharacter { get; }
    public abstract virtual String[] Split(string input);
    public abstract virtual string get_SeparatorCharacter();
}
[EditorBrowsableAttribute("1")]
[DebuggerDisplayAttribute("{MemberExpression}, {TypeMap}")]
public class AutoMapper.IncludedMember : object {
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MemberExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <ProjectToCustomSource>k__BackingField;
    public TypeMap TypeMap { get; }
    public LambdaExpression MemberExpression { get; }
    public ParameterExpression Variable { get; }
    public LambdaExpression ProjectToCustomSource { get; }
    public IncludedMember(TypeMap typeMap, LambdaExpression memberExpression);
    private IncludedMember(TypeMap typeMap, LambdaExpression memberExpression, ParameterExpression variable, LambdaExpression projectToCustomSource);
    public IncludedMember Chain(IncludedMember other, IGlobalConfiguration configuration);
    public static LambdaExpression Chain(LambdaExpression customSource, LambdaExpression lambda);
    [CompilerGeneratedAttribute]
public TypeMap get_TypeMap();
    [CompilerGeneratedAttribute]
public LambdaExpression get_MemberExpression();
    [CompilerGeneratedAttribute]
public ParameterExpression get_Variable();
    [CompilerGeneratedAttribute]
public LambdaExpression get_ProjectToCustomSource();
    public LambdaExpression Chain(LambdaExpression lambda);
    public LambdaExpression Chain(LambdaExpression lambda, IncludedMember includedMember, IGlobalConfiguration configuration);
    public sealed virtual bool Equals(IncludedMember other);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class AutoMapper.Internal.ConstructorParameters : ValueType {
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo[] <Parameters>k__BackingField;
    public ConstructorInfo Constructor { get; public set; }
    public ParameterInfo[] Parameters { get; public set; }
    public int ParametersCount { get; }
    public ConstructorParameters(ConstructorInfo Constructor, ParameterInfo[] Parameters);
    public ConstructorParameters(ConstructorInfo constructor);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Constructor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Constructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public ParameterInfo[] get_Parameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Parameters(ParameterInfo[] value);
    public int get_ParametersCount();
    public bool AllParametersOptional();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ConstructorParameters left, ConstructorParameters right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ConstructorParameters left, ConstructorParameters right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConstructorParameters other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ConstructorInfo& Constructor, ParameterInfo[]& Parameters);
}
[EditorBrowsableAttribute("1")]
public interface AutoMapper.Internal.IGlobalConfiguration {
    public Features`1<IRuntimeFeature> Features { get; }
    public IProjectionBuilder ProjectionBuilder { get; }
    public bool EnableNullPropagationForQueryMapping { get; }
    public Func`2<Type, object> ServiceCtor { get; }
    public int MaxExecutionPlanDepth { get; }
    public int RecursiveQueriesMaxDepth { get; }
    public ProfileMap[] Profiles { get; }
    public ParameterExpression[] Parameters { get; }
    public List`1<MemberInfo> SourceMembers { get; }
    public List`1<ParameterExpression> Variables { get; }
    public List`1<Expression> Expressions { get; }
    public HashSet`1<TypeMap> TypeMapsPath { get; }
    public CatchBlock[] Catches { get; }
    public abstract virtual TypeMap ResolveAssociatedTypeMap(TypePair types);
    public abstract virtual IReadOnlyCollection`1<TypeMap> GetAllTypeMaps();
    public abstract virtual TypeMap FindTypeMapFor(Type sourceType, Type destinationType);
    public abstract virtual TypeMap FindTypeMapFor(TypePair typePair);
    public abstract virtual TypeMap FindTypeMapFor();
    public abstract virtual TypeMap ResolveTypeMap(Type sourceType, Type destinationType);
    public abstract virtual TypeMap ResolveTypeMap(TypePair typePair);
    public abstract virtual void AssertConfigurationIsValid(TypeMap typeMap);
    public abstract virtual void AssertConfigurationIsValid(string profileName);
    public abstract virtual void AssertConfigurationIsValid();
    public abstract virtual IEnumerable`1<IObjectMapper> GetMappers();
    public abstract virtual Features`1<IRuntimeFeature> get_Features();
    public abstract virtual IObjectMapper FindMapper(TypePair types);
    public abstract virtual IProjectionBuilder get_ProjectionBuilder();
    public abstract virtual Func`4<TSource, TDestination, ResolutionContext, TDestination> GetExecutionPlan(MapRequest& modreq(System.Runtime.InteropServices.InAttribute) mapRequest);
    public abstract virtual void RegisterTypeMap(TypeMap typeMap);
    public abstract virtual LambdaExpression BuildExecutionPlan(MapRequest& modreq(System.Runtime.InteropServices.InAttribute) mapRequest);
    public abstract virtual bool get_EnableNullPropagationForQueryMapping();
    public abstract virtual Func`2<Type, object> get_ServiceCtor();
    public abstract virtual int get_MaxExecutionPlanDepth();
    public abstract virtual int get_RecursiveQueriesMaxDepth();
    public abstract virtual ProfileMap[] get_Profiles();
    public abstract virtual TypeMap GetIncludedTypeMap(TypePair typePair);
    public abstract virtual TypeMap GetIncludedTypeMap(Type sourceType, Type destinationType);
    public abstract virtual TypeMap[] GetIncludedTypeMaps(IReadOnlyCollection`1<TypePair> includedTypes);
    public abstract virtual void RegisterAsMap(TypeMapConfiguration typeMapConfiguration);
    public abstract virtual ParameterExpression[] get_Parameters();
    public abstract virtual List`1<MemberInfo> get_SourceMembers();
    public abstract virtual List`1<ParameterExpression> get_Variables();
    public abstract virtual List`1<Expression> get_Expressions();
    public abstract virtual HashSet`1<TypeMap> get_TypeMapsPath();
    public abstract virtual CatchBlock[] get_Catches();
    public abstract virtual DefaultExpression GetDefault(Type type);
    public abstract virtual ParameterReplaceVisitor ParameterReplaceVisitor();
    public abstract virtual ConvertParameterReplaceVisitor ConvertParameterReplaceVisitor();
}
[EditorBrowsableAttribute("1")]
public interface AutoMapper.Internal.IGlobalConfigurationExpression {
    public Func`2<Type, object> ServiceCtor { get; }
    public IReadOnlyCollection`1<IProfileConfiguration> Profiles { get; }
    public Features`1<IGlobalFeature> Features { get; }
    public List`1<IObjectMapper> Mappers { get; }
    public int MaxExecutionPlanDepth { get; public set; }
    public List`1<Action`1<ValidationContext>> Validators { get; }
    public List`1<IProjectionMapper> ProjectionMappers { get; }
    public int RecursiveQueriesMaxDepth { get; public set; }
    public abstract virtual Func`2<Type, object> get_ServiceCtor();
    public abstract virtual IReadOnlyCollection`1<IProfileConfiguration> get_Profiles();
    public abstract virtual Features`1<IGlobalFeature> get_Features();
    public abstract virtual List`1<IObjectMapper> get_Mappers();
    public abstract virtual void Validator(Action`1<ValidationContext> validator);
    public abstract virtual int get_MaxExecutionPlanDepth();
    public abstract virtual void set_MaxExecutionPlanDepth(int value);
    public abstract virtual List`1<Action`1<ValidationContext>> get_Validators();
    public abstract virtual List`1<IProjectionMapper> get_ProjectionMappers();
    public abstract virtual int get_RecursiveQueriesMaxDepth();
    public abstract virtual void set_RecursiveQueriesMaxDepth(int value);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class AutoMapper.Internal.InternalApi : object {
    [ExtensionAttribute]
public static IGlobalConfiguration Internal(IConfigurationProvider configuration);
    [ExtensionAttribute]
public static IGlobalConfigurationExpression Internal(IMapperConfigurationExpression configuration);
    [ExtensionAttribute]
public static IProfileExpressionInternal Internal(IProfileExpression profile);
}
[EditorBrowsableAttribute("1")]
public interface AutoMapper.Internal.IProfileExpressionInternal {
    public List`1<string> Prefixes { get; }
    public List`1<string> Postfixes { get; }
    public MemberConfiguration MemberConfiguration { get; }
    public Nullable`1<bool> EnableNullPropagationForQueryMapping { get; public set; }
    public Nullable`1<bool> MethodMappingEnabled { get; public set; }
    public Nullable`1<bool> FieldMappingEnabled { get; public set; }
    public abstract virtual List`1<string> get_Prefixes();
    public abstract virtual List`1<string> get_Postfixes();
    public abstract virtual MemberConfiguration get_MemberConfiguration();
    public abstract virtual Nullable`1<bool> get_EnableNullPropagationForQueryMapping();
    public abstract virtual void set_EnableNullPropagationForQueryMapping(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_MethodMappingEnabled();
    public abstract virtual void set_MethodMappingEnabled(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_FieldMappingEnabled();
    public abstract virtual void set_FieldMappingEnabled(Nullable`1<bool> value);
    public abstract virtual void ForAllMaps(Action`2<TypeMap, IMappingExpression> configuration);
    public abstract virtual void ForAllPropertyMaps(Func`2<PropertyMap, bool> condition, Action`2<PropertyMap, IMemberConfigurationExpression> memberOptions);
}
[IsReadOnlyAttribute]
public class AutoMapper.Internal.LockingConcurrentDictionary`2 : ValueType {
    private Func`2<TKey, Lazy`1<TValue>> _valueFactory;
    private ConcurrentDictionary`2<TKey, Lazy`1<TValue>> _dictionary;
    public bool IsDefault { get; }
    public LockingConcurrentDictionary`2(Func`2<TKey, TValue> valueFactory, int capacity);
    public TValue GetOrAdd(TKey& key);
    public bool get_IsDefault();
}
public class AutoMapper.Internal.Mappers.AssignableMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.CollectionMapper : object {
    private static MethodInfo IListAdd;
    private static CollectionMapper();
    public sealed virtual Nullable`1<TypePair> GetAssociatedTypes(TypePair context);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
    private static Expression CreateNameValueCollection(Expression sourceExpression);
    [CompilerGeneratedAttribute]
internal static Expression <MapExpression>g__MapReadOnlyCollection|3_0(Type genericCollectionType, Type genericReadOnlyCollectionType, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static Expression <MapExpression>g__MapCollectionCore|3_1(Expression destExpression, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <MapExpression>g__GetDestinationType|3_2(<>c__DisplayClass3_1& );
    [CompilerGeneratedAttribute]
internal static void <MapExpression>g__UseDestinationValue|3_3(<>c__DisplayClass3_0& , <>c__DisplayClass3_1& );
    [CompilerGeneratedAttribute]
internal static Expression <MapExpression>g__CheckContext|3_4(<>c__DisplayClass3_0& , <>c__DisplayClass3_1& );
}
public class AutoMapper.Internal.Mappers.ConstructorMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    private static ConstructorInfo GetConstructor(Type sourceType, Type destinationType);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.ConversionOperatorMapper : object {
    private string _operatorName;
    public ConversionOperatorMapper(string operatorName);
    public sealed virtual bool IsMatch(TypePair context);
    private MethodInfo GetConversionOperator(Type sourceType, Type destinationType);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.ConvertMapper : object {
    public static bool IsPrimitive(Type type);
    public sealed virtual bool IsMatch(TypePair types);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.EnumToEnumMapper : object {
    private static MethodInfo TryParseMethod;
    private static EnumToEnumMapper();
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.FromDynamicMapper : object {
    private static MethodInfo MapMethodInfo;
    private static FromDynamicMapper();
    private static object Map(object source, object destination, Type destinationType, ResolutionContext context, ProfileMap profileMap);
    private static object GetDynamically(string memberName, object target);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.FromStringDictionaryMapper : object {
    private static MethodInfo MapDynamicMethod;
    private static FromStringDictionaryMapper();
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
    private static object MapDynamic(IDictionary`2<string, object> source, object boxedDestination, Type destinationType, ResolutionContext context, ProfileMap profileMap);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<object, int> <MapDynamic>g__MatchSource|3_0(string name, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <MapDynamic>g__MapInnerProperties|3_1(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static object <MapDynamic>g__GetInnerDestination|3_4(<>c__DisplayClass3_0& , <>c__DisplayClass3_2& );
}
public interface AutoMapper.Internal.Mappers.IObjectMapper {
    public abstract virtual bool IsMatch(TypePair context);
    public abstract virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
    public virtual Nullable`1<TypePair> GetAssociatedTypes(TypePair initialTypes);
}
public class AutoMapper.Internal.Mappers.KeyValueMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public static bool IsKeyValue(Type type);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
internal static class AutoMapper.Internal.Mappers.MapperRegistry : object {
    public static List`1<IObjectMapper> Mappers();
}
public class AutoMapper.Internal.Mappers.MultidimensionalArrayFiller : object {
    private Int32[] _indices;
    private Array _destination;
    public MultidimensionalArrayFiller(Array destination);
    public void NewValue(object value);
}
public class AutoMapper.Internal.Mappers.NullableDestinationMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
    public sealed virtual Nullable`1<TypePair> GetAssociatedTypes(TypePair initialTypes);
    private TypePair GetAssociatedTypes(Type sourceType, Type destinationType);
}
public class AutoMapper.Internal.Mappers.NullableSourceMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
    public sealed virtual Nullable`1<TypePair> GetAssociatedTypes(TypePair initialTypes);
    private TypePair GetAssociatedTypes(Type sourceType, Type destinationType);
}
public abstract class AutoMapper.Internal.Mappers.ObjectMapper`2 : object {
    private static MethodInfo MapMethod;
    private static ObjectMapper`2();
    public virtual bool IsMatch(TypePair context);
    public abstract virtual TDestination Map(TSource source, TDestination destination, Type sourceType, Type destinationType, ResolutionContext context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.ParseStringMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    private static bool HasParse(Type type);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.StringToEnumMapper : object {
    private static MethodInfo EqualsMethod;
    private static MethodInfo ParseMethod;
    private static PropertyInfo Length;
    private static StringToEnumMapper();
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
    internal static Expression CheckEnumMember(Expression sourceExpression, Type enumType, Expression defaultExpression, MethodInfo comparison);
    public static bool StringCompareOrdinalIgnoreCase(string x, string y);
}
public class AutoMapper.Internal.Mappers.ToDynamicMapper : object {
    private static MethodInfo MapMethodInfo;
    private static ToDynamicMapper();
    private static object Map(object source, object destination, Type destinationType, ResolutionContext context, ProfileMap profileMap);
    private static void SetDynamically(string memberName, object target, object value);
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.ToStringDictionaryMapper : object {
    private static MethodInfo MembersDictionaryMethodInfo;
    private static ToStringDictionaryMapper();
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
    private static Dictionary`2<string, object> MembersDictionary(object source, ProfileMap profileMap);
}
public class AutoMapper.Internal.Mappers.ToStringMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
public class AutoMapper.Internal.Mappers.UnderlyingTypeEnumMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public sealed virtual Expression MapExpression(IGlobalConfiguration configuration, ProfileMap profileMap, MemberMap memberMap, Expression sourceExpression, Expression destExpression);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{RequestedTypes.SourceType.Name}, {RequestedTypes.DestinationType.Name} : {RuntimeTypes.SourceType.Name}, {RuntimeTypes.DestinationType.Name}")]
public class AutoMapper.Internal.MapRequest : ValueType {
    [CompilerGeneratedAttribute]
private TypePair <RequestedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private TypePair <RuntimeTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberMap <MemberMap>k__BackingField;
    public TypePair RequestedTypes { get; public set; }
    public TypePair RuntimeTypes { get; public set; }
    public MemberMap MemberMap { get; public set; }
    public MapRequest(TypePair RequestedTypes, TypePair RuntimeTypes, MemberMap MemberMap);
    [CompilerGeneratedAttribute]
public TypePair get_RequestedTypes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RequestedTypes(TypePair value);
    [CompilerGeneratedAttribute]
public TypePair get_RuntimeTypes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RuntimeTypes(TypePair value);
    [CompilerGeneratedAttribute]
public MemberMap get_MemberMap();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MemberMap(MemberMap value);
    public sealed virtual bool Equals(MapRequest other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MapRequest left, MapRequest right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MapRequest left, MapRequest right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public void Deconstruct(TypePair& RequestedTypes, TypePair& RuntimeTypes, MemberMap& MemberMap);
}
[IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
public class AutoMapper.Internal.MemberPath : ValueType {
    [CompilerGeneratedAttribute]
private MemberInfo[] <Members>k__BackingField;
    public static MemberPath Empty;
    public MemberInfo[] Members { get; public set; }
    public MemberInfo Last { get; }
    public MemberInfo First { get; }
    public int Length { get; }
    public MemberPath(MemberInfo[] Members);
    public MemberPath(Stack`1<Member> members);
    private static MemberPath();
    [CompilerGeneratedAttribute]
public MemberInfo[] get_Members();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Members(MemberInfo[] value);
    public MemberInfo get_Last();
    public MemberInfo get_First();
    public int get_Length();
    public sealed virtual bool Equals(MemberPath other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool StartsWith(MemberPath path);
    public MemberPath Concat(IEnumerable`1<MemberInfo> memberInfos);
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MemberPath left, MemberPath right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MemberPath left, MemberPath right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public void Deconstruct(MemberInfo[]& Members);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class AutoMapper.Internal.PrimitiveHelper : object {
    [ExtensionAttribute]
public static bool TryAdd(List`1<T> list, T value);
    [ExtensionAttribute]
public static List`1<T> TryAdd(List`1<T> list, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnly(T item);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> NullCheck(IReadOnlyCollection`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IReadOnlyCollection`1<T> collection, IReadOnlyCollection`1<T> otherCollection);
    [ExtensionAttribute]
public static void CheckIsDerivedFrom(TypePair types, TypePair baseTypes);
    [ExtensionAttribute]
public static bool IsCollection(TypePair context);
    [ExtensionAttribute]
public static bool IsEnumToEnum(TypePair context);
    [ExtensionAttribute]
public static bool IsUnderlyingTypeToEnum(TypePair context);
    [ExtensionAttribute]
public static bool IsEnumToUnderlyingType(TypePair context);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class AutoMapper.Internal.ReflectionHelper : object {
    [ExtensionAttribute]
public static Type FirstParameterType(MethodBase method);
    public static Type GetElementType(Type type);
    public static Type GetEnumerableElementType(Type type);
    [ExtensionAttribute]
public static TypeMap[] GetIncludedTypeMaps(IGlobalConfiguration configuration, TypeMap typeMap);
    [ExtensionAttribute]
public static bool IsPublic(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool Has(MemberInfo member);
    [ExtensionAttribute]
public static bool CanBeSet(MemberInfo member);
    [ExtensionAttribute]
public static Expression GetDefaultValue(ParameterInfo parameter, IGlobalConfiguration configuration);
    [ExtensionAttribute]
public static object MapMember(ResolutionContext context, MemberInfo member, object source, object destination);
    [ExtensionAttribute]
public static void SetMemberValue(MemberInfo propertyOrField, object target, object value);
    private static ArgumentOutOfRangeException Expected(MemberInfo propertyOrField);
    [ExtensionAttribute]
public static object GetMemberValue(MemberInfo propertyOrField, object target);
    public static MemberInfo[] GetMemberPath(Type type, string fullMemberName, TypeMap typeMap);
    public static MemberInfo[] GetMemberPath(Type type, String[] memberNames, TypeMap typeMap);
    public static MemberInfo FindProperty(LambdaExpression lambdaExpression);
    [ExtensionAttribute]
public static Type GetMemberType(MemberInfo member);
    [CompilerGeneratedAttribute]
internal static Type <GetMemberPath>g__GetCurrentType|13_0(Type type);
}
[DebuggerDisplayAttribute("{Type}")]
[EditorBrowsableAttribute("1")]
public class AutoMapper.Internal.TypeDetails : object {
    private Dictionary`2<string, MemberInfo> _nameToMember;
    private ConstructorParameters[] _constructors;
    private MemberInfo[] _readAccessors;
    private MemberInfo[] _writeAccessors;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ProfileMap <Config>k__BackingField;
    public Type Type { get; }
    public ProfileMap Config { get; }
    public MemberInfo[] ReadAccessors { get; }
    public MemberInfo[] WriteAccessors { get; }
    public ConstructorParameters[] Constructors { get; }
    public TypeDetails(Type type, ProfileMap config);
    private ConstructorParameters[] GetConstructors();
    public static IEnumerable`1<ConstructorParameters> GetConstructors(Type type, ProfileMap profileMap);
    public MemberInfo GetMember(string name);
    public static String[] PossibleNames(string memberName, List`1<string> prefixes, List`1<string> postfixes);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public ProfileMap get_Config();
    public MemberInfo[] get_ReadAccessors();
    public MemberInfo[] get_WriteAccessors();
    public ConstructorParameters[] get_Constructors();
    private MemberInfo[] BuildReadAccessors();
    private MemberInfo[] BuildWriteAccessors();
    private static bool PropertyReadable(PropertyInfo propertyInfo);
    private static bool FieldReadable(FieldInfo fieldInfo);
    private static bool PropertyWritable(PropertyInfo propertyInfo);
    private static bool FieldWritable(FieldInfo fieldInfo);
    private IEnumerable`1<Type> GetTypeInheritance();
    private IEnumerable`1<PropertyInfo> GetProperties(Func`2<PropertyInfo, bool> propertyAvailableFor);
    private IEnumerable`1<MemberInfo> GetFields(Func`2<FieldInfo, bool> fieldAvailableFor);
    [CompilerGeneratedAttribute]
private void <GetMember>g__SetNameToMember|7_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberInfo> <GetMember>g__AddMethods|7_1(IEnumerable`1<MemberInfo> accessors);
    [CompilerGeneratedAttribute]
private bool <GetMember>b__7_5(MethodInfo m);
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <GetMember>g__GetPublicNoArgMethods|7_2();
    [CompilerGeneratedAttribute]
private bool <GetMember>b__7_6(MethodInfo m);
    [CompilerGeneratedAttribute]
private void <GetMember>g__CheckPrePostfixes|7_3(MemberInfo member);
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberInfo> <GetMember>g__GetNoArgExtensionMethods|7_4(IEnumerable`1<MethodInfo> sourceExtensionMethodSearch);
    [CompilerGeneratedAttribute]
private bool <GetMember>b__7_7(MethodInfo method);
    [CompilerGeneratedAttribute]
internal static void <PossibleNames>g__PostFixes|9_0(List`1& result, List`1<string> postfixes, string name);
}
[ExtensionAttribute]
public static class AutoMapper.Internal.TypeExtensions : object {
    public static BindingFlags InstanceFlags;
    public static BindingFlags StaticFlags;
    [ExtensionAttribute]
public static MethodInfo StaticGenericMethod(Type type, string methodName, int parametersCount);
    [ExtensionAttribute]
public static void CheckIsDerivedFrom(Type derivedType, Type baseType);
    [ExtensionAttribute]
public static bool IsDynamic(Type type);
    [IteratorStateMachineAttribute("AutoMapper.Internal.TypeExtensions/<BaseClassesAndInterfaces>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<Type> BaseClassesAndInterfaces(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetInheritedProperty(Type type, string name);
    [ExtensionAttribute]
private static PropertyInfo GetBaseProperty(Type type, string name);
    [ExtensionAttribute]
public static FieldInfo GetInheritedField(Type type, string name);
    [ExtensionAttribute]
private static FieldInfo GetBaseField(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetInheritedMethod(Type type, string name);
    [ExtensionAttribute]
private static MethodInfo GetBaseMethod(Type type, string name);
    [ExtensionAttribute]
public static MemberInfo GetFieldOrProperty(Type type, string name);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static Type GetICollectionType(Type type);
    [ExtensionAttribute]
public static bool IsCollection(Type type);
    [ExtensionAttribute]
public static bool IsListType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type, Type genericType);
    [ExtensionAttribute]
public static Type GetIEnumerableType(Type type);
    [ExtensionAttribute]
public static Type GetGenericInterface(Type type, Type genericInterface);
    [ExtensionAttribute]
public static ConstructorInfo[] GetDeclaredConstructors(Type type);
    [ExtensionAttribute]
public static int GenericParametersCount(Type type);
    [IteratorStateMachineAttribute("AutoMapper.Internal.TypeExtensions/<GetTypeInheritance>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetTypeInheritance(Type type);
    [ExtensionAttribute]
public static MethodInfo GetStaticMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetInstanceMethod(Type type, string name);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{SourceType.Name}, {DestinationType.Name}")]
public class AutoMapper.Internal.TypePair : ValueType {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestinationType>k__BackingField;
    public Type SourceType { get; public set; }
    public Type DestinationType { get; public set; }
    public bool IsConstructedGenericType { get; }
    public bool ContainsGenericParameters { get; }
    public TypePair(Type SourceType, Type DestinationType);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DestinationType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DestinationType(Type value);
    public bool get_IsConstructedGenericType();
    public bool get_ContainsGenericParameters();
    public TypePair CloseGenericTypes(TypePair closedTypes);
    public Type ITypeConverter();
    public TypePair GetTypeDefinitionIfGeneric();
    private static Type GetTypeDefinitionIfGeneric(Type type);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TypePair left, TypePair right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TypePair left, TypePair right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TypePair other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Type& SourceType, Type& DestinationType);
}
public interface AutoMapper.IProfileConfiguration {
    public Nullable`1<bool> FieldMappingEnabled { get; }
    public Nullable`1<bool> MethodMappingEnabled { get; }
    public Nullable`1<bool> ConstructorMappingEnabled { get; }
    public Nullable`1<bool> AllowNullDestinationValues { get; }
    public Nullable`1<bool> AllowNullCollections { get; }
    public Nullable`1<bool> EnableNullPropagationForQueryMapping { get; }
    public IReadOnlyCollection`1<Action`2<TypeMap, IMappingExpression>> AllTypeMapActions { get; }
    public IReadOnlyCollection`1<PropertyMapAction> AllPropertyMapActions { get; }
    public IReadOnlyCollection`1<MethodInfo> SourceExtensionMethods { get; }
    public Func`2<PropertyInfo, bool> ShouldMapProperty { get; }
    public Func`2<FieldInfo, bool> ShouldMapField { get; }
    public Func`2<MethodInfo, bool> ShouldMapMethod { get; }
    public Func`2<ConstructorInfo, bool> ShouldUseConstructor { get; }
    public string ProfileName { get; }
    public IReadOnlyCollection`1<string> GlobalIgnores { get; }
    public INamingConvention SourceMemberNamingConvention { get; }
    public INamingConvention DestinationMemberNamingConvention { get; }
    public IReadOnlyCollection`1<TypeMapConfiguration> TypeMapConfigs { get; }
    public IReadOnlyCollection`1<TypeMapConfiguration> OpenTypeMapConfigs { get; }
    public IReadOnlyCollection`1<ValueTransformerConfiguration> ValueTransformers { get; }
    public abstract virtual Nullable`1<bool> get_FieldMappingEnabled();
    public abstract virtual Nullable`1<bool> get_MethodMappingEnabled();
    public abstract virtual Nullable`1<bool> get_ConstructorMappingEnabled();
    public abstract virtual Nullable`1<bool> get_AllowNullDestinationValues();
    public abstract virtual Nullable`1<bool> get_AllowNullCollections();
    public abstract virtual Nullable`1<bool> get_EnableNullPropagationForQueryMapping();
    public abstract virtual IReadOnlyCollection`1<Action`2<TypeMap, IMappingExpression>> get_AllTypeMapActions();
    public abstract virtual IReadOnlyCollection`1<PropertyMapAction> get_AllPropertyMapActions();
    public abstract virtual IReadOnlyCollection`1<MethodInfo> get_SourceExtensionMethods();
    public abstract virtual Func`2<PropertyInfo, bool> get_ShouldMapProperty();
    public abstract virtual Func`2<FieldInfo, bool> get_ShouldMapField();
    public abstract virtual Func`2<MethodInfo, bool> get_ShouldMapMethod();
    public abstract virtual Func`2<ConstructorInfo, bool> get_ShouldUseConstructor();
    public abstract virtual string get_ProfileName();
    public abstract virtual IReadOnlyCollection`1<string> get_GlobalIgnores();
    public abstract virtual INamingConvention get_SourceMemberNamingConvention();
    public abstract virtual INamingConvention get_DestinationMemberNamingConvention();
    public abstract virtual IReadOnlyCollection`1<TypeMapConfiguration> get_TypeMapConfigs();
    public abstract virtual IReadOnlyCollection`1<TypeMapConfiguration> get_OpenTypeMapConfigs();
    public abstract virtual IReadOnlyCollection`1<ValueTransformerConfiguration> get_ValueTransformers();
}
public interface AutoMapper.IProfileExpression {
    public Nullable`1<bool> AllowNullDestinationValues { get; public set; }
    public Nullable`1<bool> AllowNullCollections { get; public set; }
    public INamingConvention SourceMemberNamingConvention { get; public set; }
    public INamingConvention DestinationMemberNamingConvention { get; public set; }
    public Func`2<PropertyInfo, bool> ShouldMapProperty { get; public set; }
    public Func`2<FieldInfo, bool> ShouldMapField { get; public set; }
    public Func`2<MethodInfo, bool> ShouldMapMethod { get; public set; }
    public Func`2<ConstructorInfo, bool> ShouldUseConstructor { get; public set; }
    public string ProfileName { get; }
    public List`1<ValueTransformerConfiguration> ValueTransformers { get; }
    public abstract virtual void DisableConstructorMapping();
    public abstract virtual IMappingExpression`2<TSource, TDestination> CreateMap();
    public abstract virtual IMappingExpression`2<TSource, TDestination> CreateMap(MemberList memberList);
    public abstract virtual IProjectionExpression`2<TSource, TDestination> CreateProjection();
    public abstract virtual IProjectionExpression`2<TSource, TDestination> CreateProjection(MemberList memberList);
    public abstract virtual IMappingExpression CreateMap(Type sourceType, Type destinationType);
    public abstract virtual IMappingExpression CreateMap(Type sourceType, Type destinationType, MemberList memberList);
    public abstract virtual void ClearPrefixes();
    public abstract virtual void RecognizePrefixes(String[] prefixes);
    public abstract virtual void RecognizePostfixes(String[] postfixes);
    public abstract virtual void ReplaceMemberName(string original, string newValue);
    public abstract virtual void RecognizeDestinationPrefixes(String[] prefixes);
    public abstract virtual void RecognizeDestinationPostfixes(String[] postfixes);
    public abstract virtual void AddGlobalIgnore(string propertyNameStartingWith);
    public abstract virtual Nullable`1<bool> get_AllowNullDestinationValues();
    public abstract virtual void set_AllowNullDestinationValues(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_AllowNullCollections();
    public abstract virtual void set_AllowNullCollections(Nullable`1<bool> value);
    public abstract virtual INamingConvention get_SourceMemberNamingConvention();
    public abstract virtual void set_SourceMemberNamingConvention(INamingConvention value);
    public abstract virtual INamingConvention get_DestinationMemberNamingConvention();
    public abstract virtual void set_DestinationMemberNamingConvention(INamingConvention value);
    public abstract virtual Func`2<PropertyInfo, bool> get_ShouldMapProperty();
    public abstract virtual void set_ShouldMapProperty(Func`2<PropertyInfo, bool> value);
    public abstract virtual Func`2<FieldInfo, bool> get_ShouldMapField();
    public abstract virtual void set_ShouldMapField(Func`2<FieldInfo, bool> value);
    public abstract virtual Func`2<MethodInfo, bool> get_ShouldMapMethod();
    public abstract virtual void set_ShouldMapMethod(Func`2<MethodInfo, bool> value);
    public abstract virtual Func`2<ConstructorInfo, bool> get_ShouldUseConstructor();
    public abstract virtual void set_ShouldUseConstructor(Func`2<ConstructorInfo, bool> value);
    public abstract virtual string get_ProfileName();
    public abstract virtual void IncludeSourceExtensionMethods(Type type);
    public abstract virtual List`1<ValueTransformerConfiguration> get_ValueTransformers();
}
public interface AutoMapper.IProjectionExpression`2 {
    public abstract virtual IProjectionExpression`2<TSource, TDestination> ForMember(Expression`1<Func`2<TDestination, TMember>> destinationMember, Action`1<IProjectionMemberConfiguration`3<TSource, TDestination, TMember>> memberOptions);
}
public interface AutoMapper.IProjectionExpression`3 {
    public abstract virtual TMappingExpression AddTransform(Expression`1<Func`2<TValue, TValue>> transformer);
    public abstract virtual TMappingExpression IncludeMembers(Expression`1[] memberExpressions);
}
public interface AutoMapper.IProjectionExpressionBase`3 {
    public Features`1<IMappingFeature> Features { get; }
    public List`1<ValueTransformerConfiguration> ValueTransformers { get; }
    public abstract virtual Features`1<IMappingFeature> get_Features();
    public abstract virtual TMappingExpression MaxDepth(int depth);
    public abstract virtual List`1<ValueTransformerConfiguration> get_ValueTransformers();
    public abstract virtual TMappingExpression ValidateMemberList(MemberList memberList);
    public abstract virtual TMappingExpression ConstructUsing(Expression`1<Func`2<TSource, TDestination>> ctor);
    public abstract virtual TMappingExpression ForCtorParam(string ctorParamName, Action`1<ICtorParamConfigurationExpression`1<TSource>> paramOptions);
    public abstract virtual void ConvertUsing(Expression`1<Func`2<TSource, TDestination>> mappingExpression);
}
public interface AutoMapper.IProjectionMemberConfiguration`3 {
    public abstract virtual void NullSubstitute(object nullSubstitute);
    public abstract virtual void MapFrom(Expression`1<Func`2<TSource, TSourceMember>> mapExpression);
    public abstract virtual void Ignore();
    public abstract virtual void AllowNull();
    public abstract virtual void DoNotAllowNull();
    public abstract virtual void ExplicitExpansion(bool value);
    public abstract virtual void AddTransform(Expression`1<Func`2<TMember, TMember>> transformer);
}
public interface AutoMapper.IRuntimeMapper {
}
public interface AutoMapper.ITypeConverter`2 {
    public abstract virtual TDestination Convert(TSource source, TDestination destination, ResolutionContext context);
}
public interface AutoMapper.IValueConverter`2 {
    public abstract virtual TDestinationMember Convert(TSourceMember sourceMember, ResolutionContext context);
}
public interface AutoMapper.IValueResolver`3 {
    public abstract virtual TDestMember Resolve(TSource source, TDestination destination, TDestMember destMember, ResolutionContext context);
}
internal class AutoMapper.LazyValue`1 : ValueType {
    private Func`1<T> _factory;
    private T _value;
    public T Value { get; }
    public LazyValue`1(Func`1<T> factory);
    public T get_Value();
}
public class AutoMapper.LowerUnderscoreNamingConvention : object {
    public static LowerUnderscoreNamingConvention Instance;
    public string SeparatorCharacter { get; }
    private static LowerUnderscoreNamingConvention();
    public sealed virtual string get_SeparatorCharacter();
    public sealed virtual String[] Split(string input);
}
public class AutoMapper.Mapper : object {
    private IGlobalConfiguration _configuration;
    private Func`2<Type, object> _serviceCtor;
    [CompilerGeneratedAttribute]
private ResolutionContext <DefaultContext>k__BackingField;
    internal ResolutionContext DefaultContext { get; }
    private ResolutionContext AutoMapper.IInternalRuntimeMapper.DefaultContext { get; }
    private Func`2<Type, object> AutoMapper.IInternalRuntimeMapper.ServiceCtor { get; }
    public IConfigurationProvider ConfigurationProvider { get; }
    public Mapper(IConfigurationProvider configuration);
    public Mapper(IConfigurationProvider configuration, Func`2<Type, object> serviceCtor);
    [CompilerGeneratedAttribute]
internal ResolutionContext get_DefaultContext();
    private sealed virtual override ResolutionContext AutoMapper.IInternalRuntimeMapper.get_DefaultContext();
    private sealed virtual override Func`2<Type, object> AutoMapper.IInternalRuntimeMapper.get_ServiceCtor();
    public sealed virtual IConfigurationProvider get_ConfigurationProvider();
    public sealed virtual TDestination Map(object source);
    public sealed virtual TDestination Map(object source, Action`1<IMappingOperationOptions`2<object, TDestination>> opts);
    public sealed virtual TDestination Map(TSource source);
    public sealed virtual TDestination Map(TSource source, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    public sealed virtual TDestination Map(TSource source, TDestination destination);
    public sealed virtual TDestination Map(TSource source, TDestination destination, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts);
    public sealed virtual object Map(object source, Type sourceType, Type destinationType);
    public sealed virtual object Map(object source, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions`2<object, object>> opts);
    public sealed virtual object Map(object source, object destination, Type sourceType, Type destinationType);
    private static void CheckDestination(object destination, Type destinationType);
    public sealed virtual object Map(object source, object destination, Type sourceType, Type destinationType, Action`1<IMappingOperationOptions`2<object, object>> opts);
    public sealed virtual IQueryable`1<TDestination> ProjectTo(IQueryable source, object parameters, Expression`1[] membersToExpand);
    public sealed virtual IQueryable`1<TDestination> ProjectTo(IQueryable source, IDictionary`2<string, object> parameters, String[] membersToExpand);
    public sealed virtual IQueryable ProjectTo(IQueryable source, Type destinationType, IDictionary`2<string, object> parameters, String[] membersToExpand);
    private sealed virtual override TDestination AutoMapper.IInternalRuntimeMapper.Map(TSource source, TDestination destination, ResolutionContext context, Type sourceType, Type destinationType, MemberMap memberMap);
    private TDestination MapWithOptions(TSource source, TDestination destination, Action`1<IMappingOperationOptions`2<TSource, TDestination>> opts, Type sourceType, Type destinationType);
    private TDestination MapCore(TSource source, TDestination destination, ResolutionContext context, Type sourceType, Type destinationType, MemberMap memberMap);
}
public class AutoMapper.MapperConfiguration : object {
    private static MethodInfo MappingError;
    private IObjectMapper[] _mappers;
    private Dictionary`2<TypePair, TypeMap> _configuredMaps;
    private Dictionary`2<TypePair, TypeMap> _resolvedMaps;
    private LockingConcurrentDictionary`2<TypePair, TypeMap> _runtimeMaps;
    private LazyValue`1<ProjectionBuilder> _projectionBuilder;
    private LockingConcurrentDictionary`2<MapRequest, Delegate> _executionPlans;
    private ConfigurationValidator _validator;
    private Features`1<IRuntimeFeature> _features;
    private bool _hasOpenMaps;
    private HashSet`1<TypeMap> _typeMapsPath;
    private List`1<MemberInfo> _sourceMembers;
    private List`1<ParameterExpression> _variables;
    private ParameterExpression[] _parameters;
    private CatchBlock[] _catches;
    private List`1<Expression> _expressions;
    private Dictionary`2<Type, DefaultExpression> _defaults;
    private ParameterReplaceVisitor _parameterReplaceVisitor;
    private ConvertParameterReplaceVisitor _convertParameterReplaceVisitor;
    private List`1<Type> _typesInheritance;
    [CompilerGeneratedAttribute]
private ProfileMap <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ProfileMap[] <Profiles>k__BackingField;
    private IGlobalConfigurationExpression ConfigurationExpression { get; }
    private IProjectionBuilder AutoMapper.Internal.IGlobalConfiguration.ProjectionBuilder { get; }
    private Func`2<Type, object> AutoMapper.Internal.IGlobalConfiguration.ServiceCtor { get; }
    private bool AutoMapper.Internal.IGlobalConfiguration.EnableNullPropagationForQueryMapping { get; }
    private int AutoMapper.Internal.IGlobalConfiguration.MaxExecutionPlanDepth { get; }
    private ProfileMap Configuration { get; }
    private ProfileMap[] AutoMapper.Internal.IGlobalConfiguration.Profiles { get; }
    internal ProfileMap[] Profiles { get; }
    private int AutoMapper.Internal.IGlobalConfiguration.RecursiveQueriesMaxDepth { get; }
    private Features`1<IRuntimeFeature> AutoMapper.Internal.IGlobalConfiguration.Features { get; }
    private List`1<MemberInfo> AutoMapper.Internal.IGlobalConfiguration.SourceMembers { get; }
    private List`1<ParameterExpression> AutoMapper.Internal.IGlobalConfiguration.Variables { get; }
    private List`1<Expression> AutoMapper.Internal.IGlobalConfiguration.Expressions { get; }
    private HashSet`1<TypeMap> AutoMapper.Internal.IGlobalConfiguration.TypeMapsPath { get; }
    private ParameterExpression[] AutoMapper.Internal.IGlobalConfiguration.Parameters { get; }
    private CatchBlock[] AutoMapper.Internal.IGlobalConfiguration.Catches { get; }
    public MapperConfiguration(MapperConfigurationExpression configurationExpression);
    public MapperConfiguration(Action`1<IMapperConfigurationExpression> configure);
    private static MapperConfiguration();
    private static MapperConfigurationExpression Build(Action`1<IMapperConfigurationExpression> configure);
    public sealed virtual void AssertConfigurationIsValid();
    public sealed virtual IMapper CreateMapper();
    public sealed virtual IMapper CreateMapper(Func`2<Type, object> serviceCtor);
    public sealed virtual void CompileMappings();
    public sealed virtual LambdaExpression BuildExecutionPlan(Type sourceType, Type destinationType);
    private sealed virtual override LambdaExpression AutoMapper.Internal.IGlobalConfiguration.BuildExecutionPlan(MapRequest& modreq(System.Runtime.InteropServices.InAttribute) mapRequest);
    private IGlobalConfigurationExpression get_ConfigurationExpression();
    private ProjectionBuilder CreateProjectionBuilder();
    private sealed virtual override IProjectionBuilder AutoMapper.Internal.IGlobalConfiguration.get_ProjectionBuilder();
    private sealed virtual override Func`2<Type, object> AutoMapper.Internal.IGlobalConfiguration.get_ServiceCtor();
    private sealed virtual override bool AutoMapper.Internal.IGlobalConfiguration.get_EnableNullPropagationForQueryMapping();
    private sealed virtual override int AutoMapper.Internal.IGlobalConfiguration.get_MaxExecutionPlanDepth();
    [CompilerGeneratedAttribute]
private ProfileMap get_Configuration();
    private sealed virtual override ProfileMap[] AutoMapper.Internal.IGlobalConfiguration.get_Profiles();
    [CompilerGeneratedAttribute]
internal ProfileMap[] get_Profiles();
    private sealed virtual override int AutoMapper.Internal.IGlobalConfiguration.get_RecursiveQueriesMaxDepth();
    private sealed virtual override Features`1<IRuntimeFeature> AutoMapper.Internal.IGlobalConfiguration.get_Features();
    private sealed virtual override List`1<MemberInfo> AutoMapper.Internal.IGlobalConfiguration.get_SourceMembers();
    private sealed virtual override List`1<ParameterExpression> AutoMapper.Internal.IGlobalConfiguration.get_Variables();
    private sealed virtual override List`1<Expression> AutoMapper.Internal.IGlobalConfiguration.get_Expressions();
    private sealed virtual override HashSet`1<TypeMap> AutoMapper.Internal.IGlobalConfiguration.get_TypeMapsPath();
    private sealed virtual override ParameterExpression[] AutoMapper.Internal.IGlobalConfiguration.get_Parameters();
    private sealed virtual override CatchBlock[] AutoMapper.Internal.IGlobalConfiguration.get_Catches();
    private sealed virtual override ConvertParameterReplaceVisitor AutoMapper.Internal.IGlobalConfiguration.ConvertParameterReplaceVisitor();
    private sealed virtual override ParameterReplaceVisitor AutoMapper.Internal.IGlobalConfiguration.ParameterReplaceVisitor();
    private sealed virtual override DefaultExpression AutoMapper.Internal.IGlobalConfiguration.GetDefault(Type type);
    private sealed virtual override Func`4<TSource, TDestination, ResolutionContext, TDestination> AutoMapper.Internal.IGlobalConfiguration.GetExecutionPlan(MapRequest& modreq(System.Runtime.InteropServices.InAttribute) mapRequest);
    private Delegate GetExecutionPlan(MapRequest& mapRequest);
    private sealed virtual override TypeMap AutoMapper.Internal.IGlobalConfiguration.ResolveAssociatedTypeMap(TypePair types);
    public static AutoMapperMappingException GetMappingError(Exception innerException, MapRequest& mapRequest);
    private sealed virtual override IReadOnlyCollection`1<TypeMap> AutoMapper.Internal.IGlobalConfiguration.GetAllTypeMaps();
    private sealed virtual override TypeMap AutoMapper.Internal.IGlobalConfiguration.FindTypeMapFor(Type sourceType, Type destinationType);
    private sealed virtual override TypeMap AutoMapper.Internal.IGlobalConfiguration.FindTypeMapFor();
    private sealed virtual override TypeMap AutoMapper.Internal.IGlobalConfiguration.FindTypeMapFor(TypePair typePair);
    private TypeMap FindTypeMapFor(Type sourceType, Type destinationType);
    private TypeMap FindTypeMapFor(TypePair typePair);
    private sealed virtual override TypeMap AutoMapper.Internal.IGlobalConfiguration.ResolveTypeMap(Type sourceType, Type destinationType);
    private sealed virtual override TypeMap AutoMapper.Internal.IGlobalConfiguration.ResolveTypeMap(TypePair typePair);
    private TypeMap ResolveTypeMap(TypePair typePair);
    private TypeMap GetTypeMap(TypePair initialTypes);
    private sealed virtual override IEnumerable`1<IObjectMapper> AutoMapper.Internal.IGlobalConfiguration.GetMappers();
    private sealed virtual override TypeMap[] AutoMapper.Internal.IGlobalConfiguration.GetIncludedTypeMaps(IReadOnlyCollection`1<TypePair> includedTypes);
    private sealed virtual override TypeMap AutoMapper.Internal.IGlobalConfiguration.GetIncludedTypeMap(Type sourceType, Type destinationType);
    private sealed virtual override TypeMap AutoMapper.Internal.IGlobalConfiguration.GetIncludedTypeMap(TypePair pair);
    private TypeMap GetIncludedTypeMap(TypePair pair);
    private sealed virtual override IObjectMapper AutoMapper.Internal.IGlobalConfiguration.FindMapper(TypePair types);
    private IObjectMapper FindMapper(TypePair types);
    private sealed virtual override void AutoMapper.Internal.IGlobalConfiguration.RegisterTypeMap(TypeMap typeMap);
    private sealed virtual override void AutoMapper.Internal.IGlobalConfiguration.AssertConfigurationIsValid(TypeMap typeMap);
    private sealed virtual override void AutoMapper.Internal.IGlobalConfiguration.AssertConfigurationIsValid(string profileName);
    private sealed virtual override void AutoMapper.Internal.IGlobalConfiguration.AssertConfigurationIsValid();
    private sealed virtual override void AutoMapper.Internal.IGlobalConfiguration.RegisterAsMap(TypeMapConfiguration typeMapConfiguration);
    [CompilerGeneratedAttribute]
private void <.ctor>g__Seal|20_0();
    [CompilerGeneratedAttribute]
private void <.ctor>g__GetDerivedTypeMaps|20_1(TypeMap typeMap, List`1<TypeMap> typeMaps);
    [CompilerGeneratedAttribute]
private Delegate <.ctor>g__CompileExecutionPlan|20_2(MapRequest mapRequest);
    [CompilerGeneratedAttribute]
internal static LambdaExpression <AutoMapper.Internal.IGlobalConfiguration.BuildExecutionPlan>g__GenerateTypeMapExpression|28_0(TypePair requestedTypes, TypeMap typeMap);
    [CompilerGeneratedAttribute]
internal static Expression <AutoMapper.Internal.IGlobalConfiguration.BuildExecutionPlan>g__CheckNullValueType|28_1(Expression expression, Type runtimeType);
    [CompilerGeneratedAttribute]
private LambdaExpression <AutoMapper.Internal.IGlobalConfiguration.BuildExecutionPlan>g__GenerateObjectMapperExpression|28_2(MapRequest& mapRequest, IObjectMapper mapper);
    [CompilerGeneratedAttribute]
internal static void <GetTypeMap>g__GetTypeInheritance|80_0(List`1<Type> types, Type type);
    [CompilerGeneratedAttribute]
private TypeMap <GetTypeMap>g__FindClosedGenericTypeMapFor|80_1(TypePair typePair);
    [CompilerGeneratedAttribute]
private TypeMap <GetTypeMap>g__FindClosedGenericMap|80_2(TypePair typePair);
}
public class AutoMapper.MapperConfigurationExpression : Profile {
    private List`1<Profile> _profiles;
    private List`1<Action`1<ValidationContext>> _validators;
    private List`1<IObjectMapper> _mappers;
    private Func`2<Type, object> _serviceCtor;
    private List`1<IProjectionMapper> _projectionMappers;
    [CompilerGeneratedAttribute]
private int <AutoMapper.Internal.IGlobalConfigurationExpression.MaxExecutionPlanDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AutoMapper.Internal.IGlobalConfigurationExpression.RecursiveQueriesMaxDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Features`1<IGlobalFeature> <AutoMapper.Internal.IGlobalConfigurationExpression.Features>k__BackingField;
    private int AutoMapper.Internal.IGlobalConfigurationExpression.MaxExecutionPlanDepth { get; private set; }
    private List`1<Action`1<ValidationContext>> AutoMapper.Internal.IGlobalConfigurationExpression.Validators { get; }
    private List`1<IProjectionMapper> AutoMapper.Internal.IGlobalConfigurationExpression.ProjectionMappers { get; }
    private int AutoMapper.Internal.IGlobalConfigurationExpression.RecursiveQueriesMaxDepth { get; private set; }
    private IReadOnlyCollection`1<IProfileConfiguration> AutoMapper.Internal.IGlobalConfigurationExpression.Profiles { get; }
    private Func`2<Type, object> AutoMapper.Internal.IGlobalConfigurationExpression.ServiceCtor { get; }
    private List`1<IObjectMapper> AutoMapper.Internal.IGlobalConfigurationExpression.Mappers { get; }
    private Features`1<IGlobalFeature> AutoMapper.Internal.IGlobalConfigurationExpression.Features { get; }
    private sealed virtual override void AutoMapper.Internal.IGlobalConfigurationExpression.Validator(Action`1<ValidationContext> validator);
    [CompilerGeneratedAttribute]
private sealed virtual override int AutoMapper.Internal.IGlobalConfigurationExpression.get_MaxExecutionPlanDepth();
    [CompilerGeneratedAttribute]
private sealed virtual override void AutoMapper.Internal.IGlobalConfigurationExpression.set_MaxExecutionPlanDepth(int value);
    private sealed virtual override List`1<Action`1<ValidationContext>> AutoMapper.Internal.IGlobalConfigurationExpression.get_Validators();
    private sealed virtual override List`1<IProjectionMapper> AutoMapper.Internal.IGlobalConfigurationExpression.get_ProjectionMappers();
    [CompilerGeneratedAttribute]
private sealed virtual override int AutoMapper.Internal.IGlobalConfigurationExpression.get_RecursiveQueriesMaxDepth();
    [CompilerGeneratedAttribute]
private sealed virtual override void AutoMapper.Internal.IGlobalConfigurationExpression.set_RecursiveQueriesMaxDepth(int value);
    private sealed virtual override IReadOnlyCollection`1<IProfileConfiguration> AutoMapper.Internal.IGlobalConfigurationExpression.get_Profiles();
    private sealed virtual override Func`2<Type, object> AutoMapper.Internal.IGlobalConfigurationExpression.get_ServiceCtor();
    public sealed virtual void CreateProfile(string profileName, Action`1<IProfileExpression> config);
    private sealed virtual override List`1<IObjectMapper> AutoMapper.Internal.IGlobalConfigurationExpression.get_Mappers();
    [CompilerGeneratedAttribute]
private sealed virtual override Features`1<IGlobalFeature> AutoMapper.Internal.IGlobalConfigurationExpression.get_Features();
    public sealed virtual void AddProfile(Profile profile);
    public sealed virtual void AddProfile();
    public sealed virtual void AddProfile(Type profileType);
    public sealed virtual void AddProfiles(IEnumerable`1<Profile> enumerableOfProfiles);
    public sealed virtual void AddMaps(IEnumerable`1<Assembly> assembliesToScan);
    public sealed virtual void AddMaps(Assembly[] assembliesToScan);
    public sealed virtual void AddMaps(IEnumerable`1<string> assemblyNamesToScan);
    public sealed virtual void AddMaps(String[] assemblyNamesToScan);
    public sealed virtual void AddMaps(IEnumerable`1<Type> typesFromAssembliesContainingMappingDefinitions);
    public sealed virtual void AddMaps(Type[] typesFromAssembliesContainingMappingDefinitions);
    private void AddMapsCore(IEnumerable`1<Assembly> assembliesToScan);
    public sealed virtual void ConstructServicesUsing(Func`2<Type, object> constructor);
}
public class AutoMapper.MappingOperationOptions`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<Type, object> <ServiceCtor>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<TSource, TDestination> <BeforeMapAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<TSource, TDestination> <AfterMapAction>k__BackingField;
    public Func`2<Type, object> ServiceCtor { get; private set; }
    public Dictionary`2<string, object> Items { get; }
    public object State { get; public set; }
    public Action`2<TSource, TDestination> BeforeMapAction { get; private set; }
    public Action`2<TSource, TDestination> AfterMapAction { get; private set; }
    public MappingOperationOptions`2(Func`2<Type, object> serviceCtor);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Type, object> get_ServiceCtor();
    [CompilerGeneratedAttribute]
private void set_ServiceCtor(Func`2<Type, object> value);
    public sealed virtual Dictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public sealed virtual object get_State();
    [CompilerGeneratedAttribute]
public sealed virtual void set_State(object value);
    [CompilerGeneratedAttribute]
public Action`2<TSource, TDestination> get_BeforeMapAction();
    [CompilerGeneratedAttribute]
private void set_BeforeMapAction(Action`2<TSource, TDestination> value);
    [CompilerGeneratedAttribute]
public Action`2<TSource, TDestination> get_AfterMapAction();
    [CompilerGeneratedAttribute]
private void set_AfterMapAction(Action`2<TSource, TDestination> value);
    public sealed virtual void BeforeMap(Action`2<TSource, TDestination> beforeFunction);
    public sealed virtual void AfterMap(Action`2<TSource, TDestination> afterFunction);
    public sealed virtual void ConstructServicesUsing(Func`2<Type, object> constructor);
    private sealed virtual override void AutoMapper.IMappingOperationOptions.BeforeMap(Action`2<object, object> beforeFunction);
    private sealed virtual override void AutoMapper.IMappingOperationOptions.AfterMap(Action`2<object, object> afterFunction);
}
public enum AutoMapper.MemberList : Enum {
    public int value__;
    public static MemberList Destination;
    public static MemberList Source;
    public static MemberList None;
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.MemberMap : object {
    private protected Type _sourceType;
    internal static MemberMap Instance;
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inline>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueResolver <Resolver>k__BackingField;
    public TypeMap TypeMap { get; protected set; }
    public LambdaExpression CustomMapExpression { get; }
    public bool IsResolveConfigured { get; }
    public Type SourceType { get; }
    public MemberInfo[] SourceMembers { get; public set; }
    public IncludedMember IncludedMember { get; protected set; }
    public string DestinationName { get; }
    public Type DestinationType { get; protected set; }
    public bool CanResolveValue { get; }
    public bool IsMapped { get; }
    public bool Ignored { get; public set; }
    public Nullable`1<bool> ExplicitExpansion { get; public set; }
    public bool Inline { get; public set; }
    public Nullable`1<bool> AllowNull { get; public set; }
    public bool CanBeSet { get; }
    public Nullable`1<bool> UseDestinationValue { get; public set; }
    public object NullSubstitute { get; public set; }
    public LambdaExpression PreCondition { get; public set; }
    public LambdaExpression Condition { get; public set; }
    public IValueResolver Resolver { get; protected set; }
    public IReadOnlyCollection`1<ValueTransformerConfiguration> ValueTransformers { get; }
    public MemberInfo SourceMember { get; }
    public bool MustUseDestination { get; }
    public bool AllowsNullDestinationValues { get; }
    public ProfileMap Profile { get; }
    private Type AutoMapper.Execution.IValueResolver.ResolvedType { get; }
    protected MemberMap(TypeMap typeMap);
    private static MemberMap();
    [CompilerGeneratedAttribute]
public TypeMap get_TypeMap();
    [CompilerGeneratedAttribute]
protected void set_TypeMap(TypeMap value);
    public LambdaExpression get_CustomMapExpression();
    public bool get_IsResolveConfigured();
    public void MapFrom(LambdaExpression lambda);
    public void SetResolver(IValueResolver resolver);
    public virtual Type get_SourceType();
    public virtual MemberInfo[] get_SourceMembers();
    public virtual void set_SourceMembers(MemberInfo[] value);
    public virtual IncludedMember get_IncludedMember();
    protected virtual void set_IncludedMember(IncludedMember value);
    public virtual string get_DestinationName();
    public virtual Type get_DestinationType();
    protected virtual void set_DestinationType(Type value);
    public virtual TypePair Types();
    public bool get_CanResolveValue();
    public bool get_IsMapped();
    public virtual bool get_Ignored();
    public virtual void set_Ignored(bool value);
    public virtual Nullable`1<bool> get_ExplicitExpansion();
    public virtual void set_ExplicitExpansion(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public virtual bool get_Inline();
    [CompilerGeneratedAttribute]
public virtual void set_Inline(bool value);
    public virtual Nullable`1<bool> get_AllowNull();
    public virtual void set_AllowNull(Nullable`1<bool> value);
    public virtual bool get_CanBeSet();
    public virtual Nullable`1<bool> get_UseDestinationValue();
    public virtual void set_UseDestinationValue(Nullable`1<bool> value);
    public virtual object get_NullSubstitute();
    public virtual void set_NullSubstitute(object value);
    public virtual LambdaExpression get_PreCondition();
    public virtual void set_PreCondition(LambdaExpression value);
    public virtual LambdaExpression get_Condition();
    public virtual void set_Condition(LambdaExpression value);
    [CompilerGeneratedAttribute]
public IValueResolver get_Resolver();
    [CompilerGeneratedAttribute]
protected void set_Resolver(IValueResolver value);
    public virtual IReadOnlyCollection`1<ValueTransformerConfiguration> get_ValueTransformers();
    public MemberInfo get_SourceMember();
    public string GetSourceMemberName();
    public bool get_MustUseDestination();
    public void MapFrom(string sourceMembersPath, MemberInfo[] members);
    public virtual string ToString();
    public Expression ChainSourceMembers(Expression source);
    public Expression ChainSourceMembers(IGlobalConfiguration configuration, Expression source, Expression defaultValue);
    public bool get_AllowsNullDestinationValues();
    public ProfileMap get_Profile();
    protected Type GetSourceType();
    public void MapByConvention(MemberInfo[] sourceMembers);
    protected bool ApplyInheritedMap(MemberMap inheritedMap);
    private sealed virtual override Expression AutoMapper.Execution.IValueResolver.GetExpression(IGlobalConfiguration configuration, MemberMap memberMap, Expression source, Expression destination, Expression destinationMember);
    private sealed virtual override MemberInfo AutoMapper.Execution.IValueResolver.GetSourceMember(MemberMap memberMap);
    private sealed virtual override Type AutoMapper.Execution.IValueResolver.get_ResolvedType();
}
public class AutoMapper.PascalCaseNamingConvention : object {
    public static PascalCaseNamingConvention Instance;
    public string SeparatorCharacter { get; }
    private static PascalCaseNamingConvention();
    public sealed virtual string get_SeparatorCharacter();
    public sealed virtual String[] Split(string input);
}
[DebuggerDisplayAttribute("{DestinationExpression}")]
[EditorBrowsableAttribute("1")]
public class AutoMapper.PathMap : MemberMap {
    [CompilerGeneratedAttribute]
private LambdaExpression <DestinationExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberPath <MemberPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludedMember <IncludedMember>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <Condition>k__BackingField;
    public Type SourceType { get; }
    public LambdaExpression DestinationExpression { get; }
    public MemberPath MemberPath { get; }
    public Type DestinationType { get; }
    public string DestinationName { get; }
    public bool CanBeSet { get; }
    public bool Ignored { get; public set; }
    public IncludedMember IncludedMember { get; protected set; }
    public LambdaExpression Condition { get; public set; }
    public PathMap(PathMap pathMap, TypeMap typeMap, IncludedMember includedMember);
    public PathMap(LambdaExpression destinationExpression, MemberPath memberPath, TypeMap typeMap);
    public virtual Type get_SourceType();
    [CompilerGeneratedAttribute]
public LambdaExpression get_DestinationExpression();
    [CompilerGeneratedAttribute]
public MemberPath get_MemberPath();
    public virtual Type get_DestinationType();
    public virtual string get_DestinationName();
    public virtual bool get_CanBeSet();
    [CompilerGeneratedAttribute]
public virtual bool get_Ignored();
    [CompilerGeneratedAttribute]
public virtual void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public virtual IncludedMember get_IncludedMember();
    [CompilerGeneratedAttribute]
protected virtual void set_IncludedMember(IncludedMember value);
    [CompilerGeneratedAttribute]
public virtual LambdaExpression get_Condition();
    [CompilerGeneratedAttribute]
public virtual void set_Condition(LambdaExpression value);
}
public class AutoMapper.Profile : object {
    private List`1<string> _prefixes;
    private List`1<string> _postfixes;
    private List`1<TypeMapConfiguration> _typeMapConfigs;
    private PrePostfixName _prePostfixName;
    private ReplaceName _replaceName;
    private MemberConfiguration _memberConfiguration;
    private List`1<PropertyMapAction> _allPropertyMapActions;
    private List`1<Action`2<TypeMap, IMappingExpression>> _allTypeMapActions;
    private List`1<string> _globalIgnores;
    private List`1<TypeMapConfiguration> _openTypeMapConfigs;
    private List`1<MethodInfo> _sourceExtensionMethods;
    private List`1<ValueTransformerConfiguration> _valueTransformerConfigs;
    private Nullable`1<bool> _constructorMappingEnabled;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AutoMapper.Internal.IProfileExpressionInternal.MethodMappingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AutoMapper.Internal.IProfileExpressionInternal.FieldMappingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProfileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowNullDestinationValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowNullCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AutoMapper.Internal.IProfileExpressionInternal.EnableNullPropagationForQueryMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<PropertyInfo, bool> <ShouldMapProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<FieldInfo, bool> <ShouldMapField>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<MethodInfo, bool> <ShouldMapMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ConstructorInfo, bool> <ShouldUseConstructor>k__BackingField;
    private MemberConfiguration AutoMapper.Internal.IProfileExpressionInternal.MemberConfiguration { get; }
    private Nullable`1<bool> AutoMapper.IProfileConfiguration.ConstructorMappingEnabled { get; }
    private Nullable`1<bool> AutoMapper.Internal.IProfileExpressionInternal.MethodMappingEnabled { get; private set; }
    private Nullable`1<bool> AutoMapper.IProfileConfiguration.MethodMappingEnabled { get; }
    private Nullable`1<bool> AutoMapper.Internal.IProfileExpressionInternal.FieldMappingEnabled { get; private set; }
    private Nullable`1<bool> AutoMapper.IProfileConfiguration.FieldMappingEnabled { get; }
    private Nullable`1<bool> AutoMapper.IProfileConfiguration.EnableNullPropagationForQueryMapping { get; }
    private IReadOnlyCollection`1<PropertyMapAction> AutoMapper.IProfileConfiguration.AllPropertyMapActions { get; }
    private IReadOnlyCollection`1<Action`2<TypeMap, IMappingExpression>> AutoMapper.IProfileConfiguration.AllTypeMapActions { get; }
    private IReadOnlyCollection`1<string> AutoMapper.IProfileConfiguration.GlobalIgnores { get; }
    private IReadOnlyCollection`1<MethodInfo> AutoMapper.IProfileConfiguration.SourceExtensionMethods { get; }
    private IReadOnlyCollection`1<TypeMapConfiguration> AutoMapper.IProfileConfiguration.TypeMapConfigs { get; }
    private IReadOnlyCollection`1<TypeMapConfiguration> AutoMapper.IProfileConfiguration.OpenTypeMapConfigs { get; }
    private IReadOnlyCollection`1<ValueTransformerConfiguration> AutoMapper.IProfileConfiguration.ValueTransformers { get; }
    public string ProfileName { get; }
    public Nullable`1<bool> AllowNullDestinationValues { get; public set; }
    public Nullable`1<bool> AllowNullCollections { get; public set; }
    private Nullable`1<bool> AutoMapper.Internal.IProfileExpressionInternal.EnableNullPropagationForQueryMapping { get; private set; }
    public Func`2<PropertyInfo, bool> ShouldMapProperty { get; public set; }
    public Func`2<FieldInfo, bool> ShouldMapField { get; public set; }
    public Func`2<MethodInfo, bool> ShouldMapMethod { get; public set; }
    public Func`2<ConstructorInfo, bool> ShouldUseConstructor { get; public set; }
    public INamingConvention SourceMemberNamingConvention { get; public set; }
    public INamingConvention DestinationMemberNamingConvention { get; public set; }
    public List`1<ValueTransformerConfiguration> ValueTransformers { get; }
    private List`1<string> AutoMapper.Internal.IProfileExpressionInternal.Prefixes { get; }
    private List`1<string> AutoMapper.Internal.IProfileExpressionInternal.Postfixes { get; }
    protected internal Profile(string profileName);
    protected internal Profile(string profileName, Action`1<IProfileExpression> configurationAction);
    private sealed virtual override MemberConfiguration AutoMapper.Internal.IProfileExpressionInternal.get_MemberConfiguration();
    private sealed virtual override Nullable`1<bool> AutoMapper.IProfileConfiguration.get_ConstructorMappingEnabled();
    [CompilerGeneratedAttribute]
private sealed virtual override Nullable`1<bool> AutoMapper.Internal.IProfileExpressionInternal.get_MethodMappingEnabled();
    [CompilerGeneratedAttribute]
private sealed virtual override void AutoMapper.Internal.IProfileExpressionInternal.set_MethodMappingEnabled(Nullable`1<bool> value);
    private sealed virtual override Nullable`1<bool> AutoMapper.IProfileConfiguration.get_MethodMappingEnabled();
    [CompilerGeneratedAttribute]
private sealed virtual override Nullable`1<bool> AutoMapper.Internal.IProfileExpressionInternal.get_FieldMappingEnabled();
    [CompilerGeneratedAttribute]
private sealed virtual override void AutoMapper.Internal.IProfileExpressionInternal.set_FieldMappingEnabled(Nullable`1<bool> value);
    private sealed virtual override Nullable`1<bool> AutoMapper.IProfileConfiguration.get_FieldMappingEnabled();
    private sealed virtual override Nullable`1<bool> AutoMapper.IProfileConfiguration.get_EnableNullPropagationForQueryMapping();
    private sealed virtual override IReadOnlyCollection`1<PropertyMapAction> AutoMapper.IProfileConfiguration.get_AllPropertyMapActions();
    private sealed virtual override IReadOnlyCollection`1<Action`2<TypeMap, IMappingExpression>> AutoMapper.IProfileConfiguration.get_AllTypeMapActions();
    private sealed virtual override IReadOnlyCollection`1<string> AutoMapper.IProfileConfiguration.get_GlobalIgnores();
    private sealed virtual override IReadOnlyCollection`1<MethodInfo> AutoMapper.IProfileConfiguration.get_SourceExtensionMethods();
    private sealed virtual override IReadOnlyCollection`1<TypeMapConfiguration> AutoMapper.IProfileConfiguration.get_TypeMapConfigs();
    private sealed virtual override IReadOnlyCollection`1<TypeMapConfiguration> AutoMapper.IProfileConfiguration.get_OpenTypeMapConfigs();
    private sealed virtual override IReadOnlyCollection`1<ValueTransformerConfiguration> AutoMapper.IProfileConfiguration.get_ValueTransformers();
    [CompilerGeneratedAttribute]
public virtual string get_ProfileName();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_AllowNullDestinationValues();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AllowNullDestinationValues(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_AllowNullCollections();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AllowNullCollections(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
private sealed virtual override Nullable`1<bool> AutoMapper.Internal.IProfileExpressionInternal.get_EnableNullPropagationForQueryMapping();
    [CompilerGeneratedAttribute]
private sealed virtual override void AutoMapper.Internal.IProfileExpressionInternal.set_EnableNullPropagationForQueryMapping(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<PropertyInfo, bool> get_ShouldMapProperty();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldMapProperty(Func`2<PropertyInfo, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<FieldInfo, bool> get_ShouldMapField();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldMapField(Func`2<FieldInfo, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<MethodInfo, bool> get_ShouldMapMethod();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldMapMethod(Func`2<MethodInfo, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<ConstructorInfo, bool> get_ShouldUseConstructor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldUseConstructor(Func`2<ConstructorInfo, bool> value);
    public sealed virtual INamingConvention get_SourceMemberNamingConvention();
    public sealed virtual void set_SourceMemberNamingConvention(INamingConvention value);
    public sealed virtual INamingConvention get_DestinationMemberNamingConvention();
    public sealed virtual void set_DestinationMemberNamingConvention(INamingConvention value);
    public sealed virtual List`1<ValueTransformerConfiguration> get_ValueTransformers();
    private sealed virtual override List`1<string> AutoMapper.Internal.IProfileExpressionInternal.get_Prefixes();
    private sealed virtual override List`1<string> AutoMapper.Internal.IProfileExpressionInternal.get_Postfixes();
    public sealed virtual void DisableConstructorMapping();
    private sealed virtual override void AutoMapper.Internal.IProfileExpressionInternal.ForAllMaps(Action`2<TypeMap, IMappingExpression> configuration);
    private sealed virtual override void AutoMapper.Internal.IProfileExpressionInternal.ForAllPropertyMaps(Func`2<PropertyMap, bool> condition, Action`2<PropertyMap, IMemberConfigurationExpression> configuration);
    public sealed virtual IProjectionExpression`2<TSource, TDestination> CreateProjection();
    public sealed virtual IProjectionExpression`2<TSource, TDestination> CreateProjection(MemberList memberList);
    public sealed virtual IMappingExpression`2<TSource, TDestination> CreateMap();
    public sealed virtual IMappingExpression`2<TSource, TDestination> CreateMap(MemberList memberList);
    private IMappingExpression`2<TSource, TDestination> CreateMapCore(MemberList memberList, bool projection);
    public sealed virtual IMappingExpression CreateMap(Type sourceType, Type destinationType);
    public sealed virtual IMappingExpression CreateMap(Type sourceType, Type destinationType, MemberList memberList);
    public sealed virtual void ClearPrefixes();
    public sealed virtual void ReplaceMemberName(string original, string newValue);
    public sealed virtual void RecognizePrefixes(String[] prefixes);
    public sealed virtual void RecognizePostfixes(String[] postfixes);
    public sealed virtual void RecognizeDestinationPrefixes(String[] prefixes);
    public sealed virtual void RecognizeDestinationPostfixes(String[] postfixes);
    public sealed virtual void AddGlobalIgnore(string propertyNameStartingWith);
    public sealed virtual void IncludeSourceExtensionMethods(Type type);
}
[DebuggerDisplayAttribute("{Name}")]
[EditorBrowsableAttribute("1")]
public class AutoMapper.ProfileMap : object {
    private static HashSet`1<string> EmptyHashSet;
    private TypeMapConfiguration[] _typeMapConfigs;
    private Dictionary`2<TypePair, TypeMapConfiguration> _openTypeMapConfigs;
    private Dictionary`2<Type, TypeDetails> _typeDetails;
    private LazyValue`1<ConcurrentDictionary`2<Type, TypeDetails>> _runtimeTypeDetails;
    [CompilerGeneratedAttribute]
private int <TypeMapsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNullCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNullDestinationValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConstructorMappingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableNullPropagationForQueryMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MethodMappingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FieldMappingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<FieldInfo, bool> <ShouldMapField>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<PropertyInfo, bool> <ShouldMapProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<MethodInfo, bool> <ShouldMapMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ConstructorInfo, bool> <ShouldUseConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PropertyMapAction> <AllPropertyMapActions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Action`2<TypeMap, IMappingExpression>> <AllTypeMapActions>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <GlobalIgnores>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberConfiguration <MemberConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <SourceExtensionMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Prefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Postfixes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ValueTransformerConfiguration> <ValueTransformers>k__BackingField;
    public int OpenTypeMapsCount { get; }
    public int TypeMapsCount { get; private set; }
    public bool AllowNullCollections { get; }
    public bool AllowNullDestinationValues { get; }
    public bool ConstructorMappingEnabled { get; }
    public bool EnableNullPropagationForQueryMapping { get; }
    public bool MethodMappingEnabled { get; }
    public bool FieldMappingEnabled { get; }
    public string Name { get; }
    public Func`2<FieldInfo, bool> ShouldMapField { get; }
    public Func`2<PropertyInfo, bool> ShouldMapProperty { get; }
    public Func`2<MethodInfo, bool> ShouldMapMethod { get; }
    public Func`2<ConstructorInfo, bool> ShouldUseConstructor { get; }
    public IEnumerable`1<PropertyMapAction> AllPropertyMapActions { get; }
    public IEnumerable`1<Action`2<TypeMap, IMappingExpression>> AllTypeMapActions { get; }
    public HashSet`1<string> GlobalIgnores { get; }
    public MemberConfiguration MemberConfiguration { get; }
    public IEnumerable`1<MethodInfo> SourceExtensionMethods { get; }
    public List`1<string> Prefixes { get; }
    public List`1<string> Postfixes { get; }
    public IReadOnlyCollection`1<ValueTransformerConfiguration> ValueTransformers { get; }
    public ProfileMap(IProfileConfiguration profile, IGlobalConfigurationExpression configuration);
    private static ProfileMap();
    public int get_OpenTypeMapsCount();
    [CompilerGeneratedAttribute]
public int get_TypeMapsCount();
    [CompilerGeneratedAttribute]
private void set_TypeMapsCount(int value);
    internal void Clear();
    [CompilerGeneratedAttribute]
public bool get_AllowNullCollections();
    [CompilerGeneratedAttribute]
public bool get_AllowNullDestinationValues();
    [CompilerGeneratedAttribute]
public bool get_ConstructorMappingEnabled();
    [CompilerGeneratedAttribute]
public bool get_EnableNullPropagationForQueryMapping();
    [CompilerGeneratedAttribute]
public bool get_MethodMappingEnabled();
    [CompilerGeneratedAttribute]
public bool get_FieldMappingEnabled();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Func`2<FieldInfo, bool> get_ShouldMapField();
    [CompilerGeneratedAttribute]
public Func`2<PropertyInfo, bool> get_ShouldMapProperty();
    [CompilerGeneratedAttribute]
public Func`2<MethodInfo, bool> get_ShouldMapMethod();
    [CompilerGeneratedAttribute]
public Func`2<ConstructorInfo, bool> get_ShouldUseConstructor();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PropertyMapAction> get_AllPropertyMapActions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Action`2<TypeMap, IMappingExpression>> get_AllTypeMapActions();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_GlobalIgnores();
    [CompilerGeneratedAttribute]
public MemberConfiguration get_MemberConfiguration();
    [CompilerGeneratedAttribute]
public IEnumerable`1<MethodInfo> get_SourceExtensionMethods();
    [CompilerGeneratedAttribute]
public List`1<string> get_Prefixes();
    [CompilerGeneratedAttribute]
public List`1<string> get_Postfixes();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ValueTransformerConfiguration> get_ValueTransformers();
    public TypeDetails CreateTypeDetails(Type type);
    public void Register(IGlobalConfiguration configuration);
    private void BuildTypeMap(IGlobalConfiguration configuration, TypeMapConfiguration config);
    public void Configure(IGlobalConfiguration configuration);
    private void Configure(TypeMapConfiguration typeMapConfiguration, IGlobalConfiguration configuration);
    private static void IncludeAllDerived(IGlobalConfiguration configuration, TypeMap typeMap);
    private void Configure(TypeMap typeMap, IGlobalConfiguration configuration);
    public TypeMap CreateClosedGenericTypeMap(TypeMapConfiguration openMapConfig, TypePair closedTypes, IGlobalConfiguration configuration);
    public TypeMapConfiguration GetGenericMap(TypePair genericPair);
    private void ApplyBaseMaps(TypeMap derivedMap, TypeMap currentMap, IGlobalConfiguration configuration);
    private void ApplyMemberMaps(TypeMap currentMap, IGlobalConfiguration configuration);
    private void ApplyDerivedMaps(TypeMap baseMap, TypeMap typeMap, IGlobalConfiguration configuration);
    public bool MapDestinationPropertyToSource(TypeDetails sourceTypeDetails, Type destType, Type destMemberType, string destMemberName, List`1<MemberInfo> members, bool reverseNamingConventions);
    public bool AllowsNullDestinationValuesFor(MemberMap memberMap);
    public bool AllowsNullCollectionsFor(MemberMap memberMap);
}
[DebuggerDisplayAttribute("{DestinationMember.Name}")]
[EditorBrowsableAttribute("1")]
public class AutoMapper.PropertyMap : MemberMap {
    private MemberMapDetails _details;
    [CompilerGeneratedAttribute]
private MemberInfo <DestinationMember>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestinationType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo[] <SourceMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    private MemberMapDetails Details { get; }
    public MemberInfo DestinationMember { get; }
    public string DestinationName { get; }
    public Type DestinationType { get; protected set; }
    public MemberInfo[] SourceMembers { get; public set; }
    public bool CanBeSet { get; }
    public bool Ignored { get; public set; }
    public IncludedMember IncludedMember { get; }
    public Nullable`1<bool> AllowNull { get; public set; }
    public Nullable`1<int> MappingOrder { get; public set; }
    public Nullable`1<bool> ExplicitExpansion { get; public set; }
    public Nullable`1<bool> UseDestinationValue { get; public set; }
    public object NullSubstitute { get; public set; }
    public LambdaExpression PreCondition { get; public set; }
    public LambdaExpression Condition { get; public set; }
    public IReadOnlyCollection`1<ValueTransformerConfiguration> ValueTransformers { get; }
    public PropertyMap(MemberInfo destinationMember, Type destinationMemberType, TypeMap typeMap);
    public PropertyMap(PropertyMap inheritedMappedProperty, TypeMap typeMap);
    public PropertyMap(PropertyMap includedMemberMap, TypeMap typeMap, IncludedMember includedMember);
    private MemberMapDetails get_Details();
    [CompilerGeneratedAttribute]
public MemberInfo get_DestinationMember();
    public virtual string get_DestinationName();
    [CompilerGeneratedAttribute]
public virtual Type get_DestinationType();
    [CompilerGeneratedAttribute]
protected virtual void set_DestinationType(Type value);
    [CompilerGeneratedAttribute]
public virtual MemberInfo[] get_SourceMembers();
    [CompilerGeneratedAttribute]
public virtual void set_SourceMembers(MemberInfo[] value);
    public virtual bool get_CanBeSet();
    [CompilerGeneratedAttribute]
public virtual bool get_Ignored();
    [CompilerGeneratedAttribute]
public virtual void set_Ignored(bool value);
    public void ApplyInheritedPropertyMap(PropertyMap inheritedMap);
    public virtual IncludedMember get_IncludedMember();
    public virtual Nullable`1<bool> get_AllowNull();
    public virtual void set_AllowNull(Nullable`1<bool> value);
    public Nullable`1<int> get_MappingOrder();
    public void set_MappingOrder(Nullable`1<int> value);
    public virtual Nullable`1<bool> get_ExplicitExpansion();
    public virtual void set_ExplicitExpansion(Nullable`1<bool> value);
    public virtual Nullable`1<bool> get_UseDestinationValue();
    public virtual void set_UseDestinationValue(Nullable`1<bool> value);
    public virtual object get_NullSubstitute();
    public virtual void set_NullSubstitute(object value);
    public virtual LambdaExpression get_PreCondition();
    public virtual void set_PreCondition(LambdaExpression value);
    public virtual LambdaExpression get_Condition();
    public virtual void set_Condition(LambdaExpression value);
    public void AddValueTransformation(ValueTransformerConfiguration config);
    public virtual IReadOnlyCollection`1<ValueTransformerConfiguration> get_ValueTransformers();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__2_0(MemberInfo m);
}
[IsReadOnlyAttribute]
public class AutoMapper.PropertyMapAction : ValueType {
    [CompilerGeneratedAttribute]
private Func`2<PropertyMap, bool> <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<PropertyMap, IMemberConfigurationExpression> <Action>k__BackingField;
    public Func`2<PropertyMap, bool> Condition { get; public set; }
    public Action`2<PropertyMap, IMemberConfigurationExpression> Action { get; public set; }
    public PropertyMapAction(Func`2<PropertyMap, bool> Condition, Action`2<PropertyMap, IMemberConfigurationExpression> Action);
    [CompilerGeneratedAttribute]
public Func`2<PropertyMap, bool> get_Condition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Condition(Func`2<PropertyMap, bool> value);
    [CompilerGeneratedAttribute]
public Action`2<PropertyMap, IMemberConfigurationExpression> get_Action();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Action(Action`2<PropertyMap, IMemberConfigurationExpression> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PropertyMapAction left, PropertyMapAction right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PropertyMapAction left, PropertyMapAction right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PropertyMapAction other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& Condition, Action`2& Action);
}
[ExtensionAttribute]
public static class AutoMapper.QueryableExtensions.Extensions : object {
    private static MethodInfo SelectMethod;
    private static Extensions();
    private static IQueryable Select(IQueryable source, LambdaExpression lambda);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, IConfigurationProvider configuration, object parameters, Expression`1[] membersToExpand);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, IConfigurationProvider configuration, Expression`1[] membersToExpand);
    [ExtensionAttribute]
public static IQueryable`1<TDestination> ProjectTo(IQueryable source, IConfigurationProvider configuration, IDictionary`2<string, object> parameters, String[] membersToExpand);
    [ExtensionAttribute]
public static IQueryable ProjectTo(IQueryable source, Type destinationType, IConfigurationProvider configuration);
    [ExtensionAttribute]
public static IQueryable ProjectTo(IQueryable source, Type destinationType, IConfigurationProvider configuration, IDictionary`2<string, object> parameters, String[] membersToExpand);
    [ExtensionAttribute]
private static IQueryable`1<TResult> ToCore(IQueryable source, IConfigurationProvider configuration, object parameters, IEnumerable`1<MemberInfo[]> memberPathsToExpand);
    [ExtensionAttribute]
private static IQueryable ToCore(IQueryable source, Type destinationType, IConfigurationProvider configuration, object parameters, IEnumerable`1<MemberInfo[]> memberPathsToExpand);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.QueryableExtensions.Impl.AssignableProjectionMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public Expression Project(IGlobalConfiguration configuration, ProjectionRequest& request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
    private sealed virtual override Expression AutoMapper.QueryableExtensions.Impl.IProjectionMapper.Project(IGlobalConfiguration configuration, ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.QueryableExtensions.Impl.EnumerableProjectionMapper : object {
    private static MethodInfo SelectMethod;
    private static MethodInfo ToArrayMethod;
    private static MethodInfo ToListMethod;
    private static EnumerableProjectionMapper();
    public sealed virtual bool IsMatch(TypePair context);
    public Expression Project(IGlobalConfiguration configuration, ProjectionRequest& request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
    private static Expression Select(Expression source, LambdaExpression lambda);
    private sealed virtual override Expression AutoMapper.QueryableExtensions.Impl.IProjectionMapper.Project(IGlobalConfiguration configuration, ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.QueryableExtensions.Impl.EnumProjectionMapper : object {
    public Expression Project(IGlobalConfiguration configuration, ProjectionRequest& request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
    public sealed virtual bool IsMatch(TypePair context);
    private sealed virtual override Expression AutoMapper.QueryableExtensions.Impl.IProjectionMapper.Project(IGlobalConfiguration configuration, ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
}
[EditorBrowsableAttribute("1")]
public interface AutoMapper.QueryableExtensions.Impl.IProjectionBuilder {
    public abstract virtual QueryExpressions GetProjection(Type sourceType, Type destinationType, object parameters, MemberPath[] membersToExpand);
    public abstract virtual QueryExpressions CreateProjection(ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, LetPropertyMaps letPropertyMaps);
}
[EditorBrowsableAttribute("1")]
public interface AutoMapper.QueryableExtensions.Impl.IProjectionMapper {
    public abstract virtual bool IsMatch(TypePair context);
    public abstract virtual Expression Project(IGlobalConfiguration configuration, ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.QueryableExtensions.Impl.LetPropertyMaps : object {
    private protected Stack`1<MemberProjection> _currentPath;
    private MemberPath _parentPath;
    [CompilerGeneratedAttribute]
private Dictionary`2<ProjectionRequest, int> <BuiltProjections>k__BackingField;
    [CompilerGeneratedAttribute]
private IGlobalConfiguration <Configuration>k__BackingField;
    protected Dictionary`2<ProjectionRequest, int> BuiltProjections { get; }
    public int Count { get; }
    public IGlobalConfiguration Configuration { get; }
    public bool IsDefault { get; }
    protected internal LetPropertyMaps(IGlobalConfiguration configuration, MemberPath parentPath, Dictionary`2<ProjectionRequest, int> builtProjections);
    [CompilerGeneratedAttribute]
protected Dictionary`2<ProjectionRequest, int> get_BuiltProjections();
    public int IncrementDepth(ProjectionRequest& request);
    public virtual Expression GetSubQueryMarker(LambdaExpression letExpression);
    public void Push(MemberProjection memberProjection);
    public MemberPath GetCurrentPath();
    public void Pop();
    public virtual int get_Count();
    [CompilerGeneratedAttribute]
public IGlobalConfiguration get_Configuration();
    public virtual LetPropertyMaps New();
    public virtual QueryExpressions GetSubQueryExpression(ProjectionBuilder builder, Expression projection, TypeMap typeMap, ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, ParameterExpression instanceParameter);
    public virtual bool get_IsDefault();
}
public class AutoMapper.QueryableExtensions.Impl.MemberProjection : object {
    [CompilerGeneratedAttribute]
private MemberMap <MemberMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public MemberMap MemberMap { get; public set; }
    public Expression Expression { get; public set; }
    public MemberProjection(MemberMap MemberMap);
    [CompilerGeneratedAttribute]
private MemberProjection(MemberProjection original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public MemberMap get_MemberMap();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MemberMap(MemberMap value);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(Expression value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MemberProjection left, MemberProjection right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MemberProjection left, MemberProjection right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(MemberProjection other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public MemberProjection <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(MemberMap& MemberMap);
}
internal class AutoMapper.QueryableExtensions.Impl.NullableSourceProjectionMapper : object {
    public Expression Project(IGlobalConfiguration configuration, ProjectionRequest& request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
    public sealed virtual bool IsMatch(TypePair context);
    private sealed virtual override Expression AutoMapper.QueryableExtensions.Impl.IProjectionMapper.Project(IGlobalConfiguration configuration, ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
}
internal abstract class AutoMapper.QueryableExtensions.Impl.ParameterExpressionVisitor : ExpressionVisitor {
    public static Expression SetParameters(object parameters, Expression expression);
    protected abstract virtual Expression GetValue(string name);
    protected virtual Expression VisitMember(MemberExpression node);
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.QueryableExtensions.Impl.ProjectionBuilder : object {
    private LockingConcurrentDictionary`2<ProjectionRequest, QueryExpressions> _projectionCache;
    private IGlobalConfiguration _configuration;
    private IProjectionMapper[] _projectionMappers;
    public ProjectionBuilder(IGlobalConfiguration configuration, IProjectionMapper[] projectionMappers);
    internal static List`1<IProjectionMapper> DefaultProjectionMappers();
    public sealed virtual QueryExpressions GetProjection(Type sourceType, Type destinationType, object parameters, MemberPath[] membersToExpand);
    private QueryExpressions CreateProjection(ProjectionRequest request);
    private ValueTuple`2<TypeMap, TypeMap[]> PolymorphicMaps(ProjectionRequest& request);
    private TypeMap[] PolymorphicMaps(TypeMap typeMap);
    public QueryExpressions CreateProjection(ProjectionRequest& request, LetPropertyMaps letPropertyMaps);
    private QueryExpressions CreateProjection(ProjectionRequest& request, LetPropertyMaps letPropertyMaps, TypeMap typeMap, TypeMap[] polymorphicMaps);
    private Expression CreateProjection(ProjectionRequest& request, LetPropertyMaps letPropertyMaps, TypeMap typeMap, TypeMap[] polymorphicMaps, Expression source);
    private static AutoMapperMappingException CannotMap(MemberMap memberMap, Type sourceType);
    private sealed virtual override QueryExpressions AutoMapper.QueryableExtensions.Impl.IProjectionBuilder.CreateProjection(ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, LetPropertyMaps letPropertyMaps);
    [CompilerGeneratedAttribute]
private Expression <CreateProjection>g__CreateProjectionCore|11_0(ProjectionRequest request, LetPropertyMaps letPropertyMaps, TypeMap typeMap, Expression instanceParameter);
    [CompilerGeneratedAttribute]
internal static bool <CreateProjection>g__NullSubstitute|11_10(<>c__DisplayClass11_1& , <>c__DisplayClass11_3& );
    [CompilerGeneratedAttribute]
private IProjectionMapper <CreateProjection>g__GetProjectionMapper|11_8(<>c__DisplayClass11_1& , <>c__DisplayClass11_2& );
}
[IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
[DebuggerDisplayAttribute("{SourceType.Name}, {DestinationType.Name}")]
public class AutoMapper.QueryableExtensions.Impl.ProjectionRequest : ValueType {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestinationType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberPath[] <MembersToExpand>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ProjectionRequest> <PreviousRequests>k__BackingField;
    public Type SourceType { get; public set; }
    public Type DestinationType { get; public set; }
    public MemberPath[] MembersToExpand { get; public set; }
    public ICollection`1<ProjectionRequest> PreviousRequests { get; public set; }
    public bool AlreadyExists { get; }
    public ProjectionRequest(Type SourceType, Type DestinationType, MemberPath[] MembersToExpand, ICollection`1<ProjectionRequest> PreviousRequests);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DestinationType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DestinationType(Type value);
    [CompilerGeneratedAttribute]
public MemberPath[] get_MembersToExpand();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MembersToExpand(MemberPath[] value);
    [CompilerGeneratedAttribute]
public ICollection`1<ProjectionRequest> get_PreviousRequests();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreviousRequests(ICollection`1<ProjectionRequest> value);
    public ProjectionRequest InnerRequest(Type sourceType, Type destinationType);
    public bool get_AlreadyExists();
    public sealed virtual bool Equals(ProjectionRequest other);
    public virtual int GetHashCode();
    public bool ShouldExpand(MemberPath currentPath);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ProjectionRequest left, ProjectionRequest right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ProjectionRequest left, ProjectionRequest right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public void Deconstruct(Type& SourceType, Type& DestinationType, MemberPath[]& MembersToExpand, ICollection`1& PreviousRequests);
}
[IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
public class AutoMapper.QueryableExtensions.Impl.QueryExpressions : ValueType {
    [CompilerGeneratedAttribute]
private LambdaExpression <Projection>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <LetClause>k__BackingField;
    public LambdaExpression Projection { get; public set; }
    public LambdaExpression LetClause { get; public set; }
    public bool Empty { get; }
    public QueryExpressions(LambdaExpression Projection, LambdaExpression LetClause);
    public QueryExpressions(Expression projection, ParameterExpression parameter);
    [CompilerGeneratedAttribute]
public LambdaExpression get_Projection();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Projection(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_LetClause();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LetClause(LambdaExpression value);
    public bool get_Empty();
    public T Chain(T source, Func`3<T, LambdaExpression, T> select);
    internal QueryExpressions Prepare(bool enableNullPropagationForQueryMapping, object parameters);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(QueryExpressions left, QueryExpressions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(QueryExpressions left, QueryExpressions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(QueryExpressions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(LambdaExpression& Projection, LambdaExpression& LetClause);
    [CompilerGeneratedAttribute]
internal static LambdaExpression <Prepare>g__Prepare|13_0(Expression cachedExpression, <>c__DisplayClass13_0& );
}
[EditorBrowsableAttribute("1")]
public class AutoMapper.QueryableExtensions.Impl.StringProjectionMapper : object {
    public sealed virtual bool IsMatch(TypePair context);
    public Expression Project(IGlobalConfiguration configuration, ProjectionRequest& request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
    private sealed virtual override Expression AutoMapper.QueryableExtensions.Impl.IProjectionMapper.Project(IGlobalConfiguration configuration, ProjectionRequest& modreq(System.Runtime.InteropServices.InAttribute) request, Expression resolvedSource, LetPropertyMaps letPropertyMaps);
}
public class AutoMapper.QueryableExtensions.MemberVisitor : ExpressionVisitor {
    private List`1<MemberInfo> _members;
    public static MemberInfo[] GetMemberPath(Expression expression);
    protected virtual Expression VisitMember(MemberExpression node);
}
internal class AutoMapper.QueryableExtensions.NullsafeQueryRewriter : ExpressionVisitor {
    private static LockingConcurrentDictionary`2<Type, Expression> Cache;
    private static NullsafeQueryRewriter();
    public static Expression NullCheck(Expression expression);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    private static Expression BeSafe(Expression target, Expression expression, Func`2<Expression, Expression> update);
    private static bool IsSafe(Expression expression);
    private static Expression Fallback(Type type);
    private static Expression CollectionFallback(Type definition, Type type);
    private static bool IsExtensionMethod(MethodInfo element);
    private static bool IsNullableOrReferenceType(Type type);
}
public class AutoMapper.ResolutionContext : object {
    private Dictionary`2<ContextCacheKey, object> _instanceCache;
    private Dictionary`2<TypePair, int> _typeDepth;
    private IInternalRuntimeMapper _mapper;
    private IMappingOperationOptions _options;
    public object State { get; }
    public Dictionary`2<string, object> Items { get; }
    public IRuntimeMapper Mapper { get; }
    private ResolutionContext AutoMapper.IInternalRuntimeMapper.DefaultContext { get; }
    public Dictionary`2<ContextCacheKey, object> InstanceCache { get; }
    private Dictionary`2<TypePair, int> TypeDepth { get; }
    internal bool IsDefault { get; }
    private Func`2<Type, object> AutoMapper.IInternalRuntimeMapper.ServiceCtor { get; }
    internal ResolutionContext(IInternalRuntimeMapper mapper, IMappingOperationOptions options);
    public object get_State();
    public Dictionary`2<string, object> get_Items();
    public bool TryGetItems(Dictionary`2& items);
    public IRuntimeMapper get_Mapper();
    private sealed virtual override ResolutionContext AutoMapper.IInternalRuntimeMapper.get_DefaultContext();
    public Dictionary`2<ContextCacheKey, object> get_InstanceCache();
    private Dictionary`2<TypePair, int> get_TypeDepth();
    private sealed virtual override TDestination AutoMapper.IMapperBase.Map(object source);
    private sealed virtual override TDestination AutoMapper.IMapperBase.Map(TSource source);
    private sealed virtual override TDestination AutoMapper.IMapperBase.Map(TSource source, TDestination destination);
    private sealed virtual override object AutoMapper.IMapperBase.Map(object source, Type sourceType, Type destinationType);
    private sealed virtual override object AutoMapper.IMapperBase.Map(object source, object destination, Type sourceType, Type destinationType);
    private sealed virtual override TDestination AutoMapper.IInternalRuntimeMapper.Map(TSource source, TDestination destination, ResolutionContext context, Type sourceType, Type destinationType, MemberMap memberMap);
    internal object CreateInstance(Type type);
    private Func`2<Type, object> ServiceCtor();
    internal object GetDestination(object source, Type destinationType);
    internal void CacheDestination(object source, Type destinationType, object destination);
    internal void IncrementTypeDepth(TypeMap typeMap);
    internal void DecrementTypeDepth(TypeMap typeMap);
    internal bool OverTypeDepth(TypeMap typeMap);
    internal bool get_IsDefault();
    private sealed virtual override Func`2<Type, object> AutoMapper.IInternalRuntimeMapper.get_ServiceCtor();
    internal static void CheckContext(ResolutionContext& resolutionContext);
    internal TDestination MapInternal(TSource source, TDestination destination, MemberMap memberMap);
    internal object Map(object source, object destination, Type sourceType, Type destinationType, MemberMap memberMap);
    private void CheckDefault();
    private static void ThrowInvalidMap();
}
[DebuggerDisplayAttribute("{SourceType.Name} -> {DestinationType.Name}")]
[EditorBrowsableAttribute("1")]
public class AutoMapper.TypeMap : object {
    private static LambdaExpression EmptyLambda;
    private static MethodInfo CreateProxyMethod;
    private TypeMapDetails _details;
    private List`1<PropertyMap> _propertyMaps;
    private bool _sealed;
    [CompilerGeneratedAttribute]
private bool <Projection>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MapExpression>k__BackingField;
    public TypePair Types;
    [CompilerGeneratedAttribute]
private ConstructorMap <ConstructorMap>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDetails <SourceTypeDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDetails <DestinationTypeDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private ProfileMap <Profile>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeConverter <TypeConverter>k__BackingField;
    public Features`1<IRuntimeFeature> Features { get; }
    private TypeMapDetails Details { get; }
    public bool HasDetails { get; }
    public bool Projection { get; public set; }
    public LambdaExpression MapExpression { get; private set; }
    public ConstructorMap ConstructorMap { get; public set; }
    public TypeDetails SourceTypeDetails { get; private set; }
    public TypeDetails DestinationTypeDetails { get; private set; }
    public Type SourceType { get; }
    public Type DestinationType { get; }
    public ProfileMap Profile { get; }
    public LambdaExpression CustomMapExpression { get; }
    public LambdaExpression CustomCtorFunction { get; public set; }
    public LambdaExpression CustomCtorExpression { get; }
    public bool IncludeAllDerivedTypes { get; public set; }
    public MemberList ConfiguredMemberList { get; public set; }
    public IReadOnlyCollection`1<TypePair> IncludedDerivedTypes { get; }
    public IReadOnlyCollection`1<TypePair> IncludedBaseTypes { get; }
    public IReadOnlyCollection`1<LambdaExpression> BeforeMapActions { get; }
    public IReadOnlyCollection`1<LambdaExpression> AfterMapActions { get; }
    public IReadOnlyCollection`1<ValueTransformerConfiguration> ValueTransformers { get; }
    public bool PreserveReferences { get; public set; }
    public int MaxDepth { get; public set; }
    public bool DisableConstructorValidation { get; public set; }
    public IReadOnlyCollection`1<PropertyMap> PropertyMaps { get; }
    public IReadOnlyCollection`1<PathMap> PathMaps { get; }
    public IEnumerable`1<MemberMap> MemberMaps { get; }
    public bool PassesCtorValidation { get; }
    public MemberInfo[] DestinationSetters { get; }
    public ConstructorParameters[] DestinationConstructors { get; }
    public bool ConstructorMapping { get; }
    public bool CustomConstruction { get; }
    public bool HasTypeConverter { get; }
    public TypeConverter TypeConverter { get; public set; }
    public bool ShouldCheckForValid { get; }
    public LambdaExpression[] IncludedMembers { get; public set; }
    public String[] IncludedMembersNames { get; public set; }
    public IReadOnlyCollection`1<IncludedMember> IncludedMembersTypeMaps { get; }
    public bool HasIncludedMembers { get; }
    public bool HasDerivedTypesToInclude { get; }
    public TypeMap(Type sourceType, Type destinationType, ProfileMap profile, TypeMapConfiguration typeMapConfiguration, List`1<MemberInfo> sourceMembers);
    private static TypeMap();
    public string CheckRecord();
    public Features`1<IRuntimeFeature> get_Features();
    private TypeMapDetails get_Details();
    public bool get_HasDetails();
    public void CheckProjection();
    public static Exception MissingMapException(TypePair types);
    public static Exception MissingMapException(Type sourceType, Type destinationType);
    [CompilerGeneratedAttribute]
public bool get_Projection();
    [CompilerGeneratedAttribute]
public void set_Projection(bool value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MapExpression();
    [CompilerGeneratedAttribute]
private void set_MapExpression(LambdaExpression value);
    public Expression Invoke(Expression source, Expression destination);
    internal bool CanConstructorMap();
    [CompilerGeneratedAttribute]
public ConstructorMap get_ConstructorMap();
    [CompilerGeneratedAttribute]
public void set_ConstructorMap(ConstructorMap value);
    [CompilerGeneratedAttribute]
public TypeDetails get_SourceTypeDetails();
    [CompilerGeneratedAttribute]
private void set_SourceTypeDetails(TypeDetails value);
    [CompilerGeneratedAttribute]
public TypeDetails get_DestinationTypeDetails();
    [CompilerGeneratedAttribute]
private void set_DestinationTypeDetails(TypeDetails value);
    public Type get_SourceType();
    public Type get_DestinationType();
    [CompilerGeneratedAttribute]
public ProfileMap get_Profile();
    public LambdaExpression get_CustomMapExpression();
    public LambdaExpression get_CustomCtorFunction();
    public void set_CustomCtorFunction(LambdaExpression value);
    public LambdaExpression get_CustomCtorExpression();
    public bool get_IncludeAllDerivedTypes();
    public void set_IncludeAllDerivedTypes(bool value);
    public MemberList get_ConfiguredMemberList();
    public void set_ConfiguredMemberList(MemberList value);
    public IReadOnlyCollection`1<TypePair> get_IncludedDerivedTypes();
    public IReadOnlyCollection`1<TypePair> get_IncludedBaseTypes();
    public IReadOnlyCollection`1<LambdaExpression> get_BeforeMapActions();
    public IReadOnlyCollection`1<LambdaExpression> get_AfterMapActions();
    public IReadOnlyCollection`1<ValueTransformerConfiguration> get_ValueTransformers();
    public bool get_PreserveReferences();
    public void set_PreserveReferences(bool value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public bool get_DisableConstructorValidation();
    public void set_DisableConstructorValidation(bool value);
    public IReadOnlyCollection`1<PropertyMap> get_PropertyMaps();
    public IReadOnlyCollection`1<PathMap> get_PathMaps();
    public IEnumerable`1<MemberMap> get_MemberMaps();
    public bool get_PassesCtorValidation();
    public MemberInfo[] get_DestinationSetters();
    public ConstructorParameters[] get_DestinationConstructors();
    public bool get_ConstructorMapping();
    public bool get_CustomConstruction();
    public bool get_HasTypeConverter();
    [CompilerGeneratedAttribute]
public TypeConverter get_TypeConverter();
    [CompilerGeneratedAttribute]
public void set_TypeConverter(TypeConverter value);
    public bool get_ShouldCheckForValid();
    public LambdaExpression[] get_IncludedMembers();
    public void set_IncludedMembers(LambdaExpression[] value);
    public String[] get_IncludedMembersNames();
    public void set_IncludedMembersNames(String[] value);
    public IReadOnlyCollection`1<IncludedMember> get_IncludedMembersTypeMaps();
    public Type MakeGenericType(Type type);
    public bool get_HasIncludedMembers();
    public IEnumerable`1<LambdaExpression> GetAllIncludedMembers();
    public bool ConstructorParameterMatches(string destinationPropertyName);
    private void AddPropertyMap(MemberInfo destProperty, Type destinationPropertyType, List`1<MemberInfo> sourceMembers);
    private void AddPropertyMap(PropertyMap propertyMap);
    public String[] GetUnmappedPropertyNames();
    public PropertyMap FindOrCreatePropertyMapFor(MemberInfo destinationProperty, Type destinationPropertyType);
    private void CheckDifferent(TypePair types);
    internal void IgnorePaths(MemberInfo destinationMember);
    public bool get_HasDerivedTypesToInclude();
    public void Seal(IGlobalConfiguration configuration);
    public List`1<PropertyMap> OrderedPropertyMaps();
    public void IncludeDerivedTypes(TypePair derivedTypes);
    public void IncludeBaseTypes(TypePair baseTypes);
    public void AddBeforeMapAction(LambdaExpression beforeMap);
    public void AddAfterMapAction(LambdaExpression afterMap);
    public void AddValueTransformation(ValueTransformerConfiguration config);
    public void ConstructUsingServiceLocator();
    internal LambdaExpression CreateMapperLambda(IGlobalConfiguration configuration);
    private PropertyMap GetPropertyMap(string name);
    private PropertyMap GetPropertyMap(PropertyMap propertyMap);
    public void AsProxy();
    internal void CopyInheritedMapsTo(TypeMap typeMap);
    public void CloseGenerics(TypeMapConfiguration openMapConfig, TypePair closedTypes);
    public bool AddMemberMap(IncludedMember includedMember);
    public PathMap FindOrCreatePathMapFor(LambdaExpression destinationExpression, MemberPath path, TypeMap typeMap);
    public void AddInheritedMap(TypeMap inheritedTypeMap);
    public SourceMemberConfig FindOrCreateSourceMemberConfigFor(MemberInfo sourceMember);
    [CompilerGeneratedAttribute]
private LambdaExpression <GetAllIncludedMembers>b__113_0(string name);
    [CompilerGeneratedAttribute]
private bool <GetUnmappedPropertyNames>b__117_1(string p);
    [CompilerGeneratedAttribute]
private bool <GetUnmappedPropertyNames>b__117_4(string memberName);
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberMap> <GetUnmappedPropertyNames>g__MappedMembers|117_5();
    [CompilerGeneratedAttribute]
private bool <OrderedPropertyMaps>g__HasMappingOrder|124_1();
}
[IsReadOnlyAttribute]
public class AutoMapper.ValueTransformerConfiguration : ValueType {
    [CompilerGeneratedAttribute]
private Type <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <TransformerExpression>k__BackingField;
    public Type ValueType { get; public set; }
    public LambdaExpression TransformerExpression { get; public set; }
    public ValueTransformerConfiguration(Type ValueType, LambdaExpression TransformerExpression);
    [CompilerGeneratedAttribute]
public Type get_ValueType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ValueType(Type value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_TransformerExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TransformerExpression(LambdaExpression value);
    public bool IsMatch(MemberMap memberMap);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ValueTransformerConfiguration left, ValueTransformerConfiguration right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ValueTransformerConfiguration left, ValueTransformerConfiguration right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueTransformerConfiguration other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Type& ValueType, LambdaExpression& TransformerExpression);
}
[ExtensionAttribute]
public static class AutoMapper.ValueTransformerConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Add(List`1<ValueTransformerConfiguration> valueTransformers, Expression`1<Func`2<TValue, TValue>> transformer);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`1<IMapperConfigurationExpression> configAction);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Assembly[] assemblies);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`1<IMapperConfigurationExpression> configAction, Assembly[] assemblies);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`2<IServiceProvider, IMapperConfigurationExpression> configAction, Assembly[] assemblies);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`1<IMapperConfigurationExpression> configAction, IEnumerable`1<Assembly> assemblies, ServiceLifetime serviceLifetime);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`2<IServiceProvider, IMapperConfigurationExpression> configAction, IEnumerable`1<Assembly> assemblies, ServiceLifetime serviceLifetime);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, IEnumerable`1<Assembly> assemblies, ServiceLifetime serviceLifetime);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Type[] profileAssemblyMarkerTypes);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`1<IMapperConfigurationExpression> configAction, Type[] profileAssemblyMarkerTypes);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`2<IServiceProvider, IMapperConfigurationExpression> configAction, Type[] profileAssemblyMarkerTypes);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`1<IMapperConfigurationExpression> configAction, IEnumerable`1<Type> profileAssemblyMarkerTypes, ServiceLifetime serviceLifetime);
    [ExtensionAttribute]
public static IServiceCollection AddAutoMapper(IServiceCollection services, Action`2<IServiceProvider, IMapperConfigurationExpression> configAction, IEnumerable`1<Type> profileAssemblyMarkerTypes, ServiceLifetime serviceLifetime);
    private static IServiceCollection AddAutoMapperClasses(IServiceCollection services, Action`2<IServiceProvider, IMapperConfigurationExpression> configAction, IEnumerable`1<Assembly> assembliesToScan, ServiceLifetime serviceLifetime);
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
