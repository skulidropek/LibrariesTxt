public static class ICSharpCode.AvalonEdit.AvalonEditCommands : object {
    public static RoutedCommand ToggleOverstrike;
    public static RoutedCommand DeleteLine;
    public static RoutedCommand RemoveLeadingWhitespace;
    public static RoutedCommand RemoveTrailingWhitespace;
    public static RoutedCommand ConvertToUppercase;
    public static RoutedCommand ConvertToLowercase;
    public static RoutedCommand ConvertToTitleCase;
    public static RoutedCommand InvertCase;
    public static RoutedCommand ConvertTabsToSpaces;
    public static RoutedCommand ConvertSpacesToTabs;
    public static RoutedCommand ConvertLeadingTabsToSpaces;
    public static RoutedCommand ConvertLeadingSpacesToTabs;
    public static RoutedCommand IndentSelection;
    private static AvalonEditCommands();
}
internal class ICSharpCode.AvalonEdit.CodeCompletion.CollapseIfSingleOverloadConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class ICSharpCode.AvalonEdit.CodeCompletion.CompletionList : Control {
    private bool isFiltering;
    public static DependencyProperty EmptyTemplateProperty;
    [CompilerGeneratedAttribute]
private EventHandler InsertionRequested;
    private CompletionListBox listBox;
    private ObservableCollection`1<ICompletionData> completionData;
    private string currentText;
    private ObservableCollection`1<ICompletionData> currentList;
    public bool IsFiltering { get; public set; }
    public ControlTemplate EmptyTemplate { get; public set; }
    public CompletionListBox ListBox { get; }
    public ScrollViewer ScrollViewer { get; }
    public IList`1<ICompletionData> CompletionData { get; }
    public ICompletionData SelectedItem { get; public set; }
    private static CompletionList();
    public bool get_IsFiltering();
    public void set_IsFiltering(bool value);
    public ControlTemplate get_EmptyTemplate();
    public void set_EmptyTemplate(ControlTemplate value);
    [CompilerGeneratedAttribute]
public void add_InsertionRequested(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InsertionRequested(EventHandler value);
    public void RequestInsertion(EventArgs e);
    public virtual void OnApplyTemplate();
    public CompletionListBox get_ListBox();
    public ScrollViewer get_ScrollViewer();
    public IList`1<ICompletionData> get_CompletionData();
    protected virtual void OnKeyDown(KeyEventArgs e);
    public void HandleKey(KeyEventArgs e);
    protected virtual void OnMouseDoubleClick(MouseButtonEventArgs e);
    public ICompletionData get_SelectedItem();
    public void set_SelectedItem(ICompletionData value);
    public void ScrollIntoView(ICompletionData item);
    public void add_SelectionChanged(SelectionChangedEventHandler value);
    public void remove_SelectionChanged(SelectionChangedEventHandler value);
    public void SelectItem(string text);
    private void SelectItemFiltering(string query);
    private void SelectItemWithStart(string query);
    private void SelectIndexCentered(int bestIndex);
    private int GetMatchQuality(string itemText, string query);
    private static bool CamelCaseMatch(string text, string query);
    [CompilerGeneratedAttribute]
private bool <OnMouseDoubleClick>b__24_0(DependencyObject obj);
}
public class ICSharpCode.AvalonEdit.CodeCompletion.CompletionListBox : ListBox {
    internal ScrollViewer scrollViewer;
    public int FirstVisibleItem { get; public set; }
    public int VisibleItemCount { get; }
    public virtual void OnApplyTemplate();
    public int get_FirstVisibleItem();
    public void set_FirstVisibleItem(int value);
    public int get_VisibleItemCount();
    public void ClearSelection();
    public void SelectIndex(int index);
    public void CenterViewOn(int index);
}
public class ICSharpCode.AvalonEdit.CodeCompletion.CompletionWindow : CompletionWindowBase {
    private CompletionList completionList;
    private ToolTip toolTip;
    [CompilerGeneratedAttribute]
private bool <CloseAutomatically>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CloseWhenCaretAtBeginning>k__BackingField;
    public CompletionList CompletionList { get; }
    public bool CloseAutomatically { get; public set; }
    protected bool CloseOnFocusLost { get; }
    public bool CloseWhenCaretAtBeginning { get; public set; }
    public CompletionWindow(TextArea textArea);
    public CompletionList get_CompletionList();
    private void toolTip_Closed(object sender, RoutedEventArgs e);
    private void completionList_SelectionChanged(object sender, SelectionChangedEventArgs e);
    private void completionList_InsertionRequested(object sender, EventArgs e);
    private void AttachEvents();
    protected virtual void DetachEvents();
    protected virtual void OnClosed(EventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    private void textArea_PreviewTextInput(object sender, TextCompositionEventArgs e);
    private void textArea_MouseWheel(object sender, MouseWheelEventArgs e);
    private UIElement GetScrollEventTarget();
    [CompilerGeneratedAttribute]
public bool get_CloseAutomatically();
    [CompilerGeneratedAttribute]
public void set_CloseAutomatically(bool value);
    protected virtual bool get_CloseOnFocusLost();
    [CompilerGeneratedAttribute]
public bool get_CloseWhenCaretAtBeginning();
    [CompilerGeneratedAttribute]
public void set_CloseWhenCaretAtBeginning(bool value);
    private void CaretPositionChanged(object sender, EventArgs e);
}
public class ICSharpCode.AvalonEdit.CodeCompletion.CompletionWindowBase : Window {
    [CompilerGeneratedAttribute]
private TextArea <TextArea>k__BackingField;
    private Window parentWindow;
    private TextDocument document;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUp>k__BackingField;
    private InputHandler myInputHandler;
    private bool sourceIsInitialized;
    private Point visualLocation;
    private Point visualLocationTop;
    [CompilerGeneratedAttribute]
private bool <ExpectInsertionBeforeStart>k__BackingField;
    public TextArea TextArea { get; private set; }
    public int StartOffset { get; public set; }
    public int EndOffset { get; public set; }
    protected bool IsUp { get; private set; }
    protected bool CloseOnFocusLost { get; }
    private bool IsTextAreaFocused { get; }
    public bool ExpectInsertionBeforeStart { get; public set; }
    private static CompletionWindowBase();
    public CompletionWindowBase(TextArea textArea);
    [CompilerGeneratedAttribute]
public TextArea get_TextArea();
    [CompilerGeneratedAttribute]
private void set_TextArea(TextArea value);
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    [CompilerGeneratedAttribute]
public void set_StartOffset(int value);
    [CompilerGeneratedAttribute]
public int get_EndOffset();
    [CompilerGeneratedAttribute]
public void set_EndOffset(int value);
    [CompilerGeneratedAttribute]
protected bool get_IsUp();
    [CompilerGeneratedAttribute]
private void set_IsUp(bool value);
    private void AttachEvents();
    protected virtual void DetachEvents();
    private void TextViewScrollOffsetChanged(object sender, EventArgs e);
    private void TextAreaDocumentChanged(object sender, EventArgs e);
    private void TextAreaLostFocus(object sender, RoutedEventArgs e);
    private void parentWindow_LocationChanged(object sender, EventArgs e);
    protected virtual void OnDeactivated(EventArgs e);
    protected static bool RaiseEventPair(UIElement target, RoutedEvent previewEvent, RoutedEvent event, RoutedEventArgs args);
    private void OnMouseUp(object sender, MouseButtonEventArgs e);
    protected virtual void ActivateParentWindow();
    private void CloseIfFocusLost();
    protected virtual bool get_CloseOnFocusLost();
    private bool get_IsTextAreaFocused();
    protected virtual void OnSourceInitialized(EventArgs e);
    protected virtual void OnClosed(EventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected void SetPosition(TextViewPosition position);
    protected void UpdatePosition();
    protected virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    [CompilerGeneratedAttribute]
public bool get_ExpectInsertionBeforeStart();
    [CompilerGeneratedAttribute]
public void set_ExpectInsertionBeforeStart(bool value);
    private void textArea_Document_Changing(object sender, DocumentChangeEventArgs e);
}
public interface ICSharpCode.AvalonEdit.CodeCompletion.ICompletionData {
    public ImageSource Image { get; }
    public string Text { get; }
    public object Content { get; }
    public object Description { get; }
    public double Priority { get; }
    public abstract virtual ImageSource get_Image();
    public abstract virtual string get_Text();
    public abstract virtual object get_Content();
    public abstract virtual object get_Description();
    public abstract virtual double get_Priority();
    public abstract virtual void Complete(TextArea textArea, ISegment completionSegment, EventArgs insertionRequestEventArgs);
}
public class ICSharpCode.AvalonEdit.CodeCompletion.InsightWindow : CompletionWindowBase {
    [CompilerGeneratedAttribute]
private bool <CloseAutomatically>k__BackingField;
    public bool CloseAutomatically { get; public set; }
    protected bool CloseOnFocusLost { get; }
    private static InsightWindow();
    public InsightWindow(TextArea textArea);
    protected virtual void OnSourceInitialized(EventArgs e);
    [CompilerGeneratedAttribute]
public bool get_CloseAutomatically();
    [CompilerGeneratedAttribute]
public void set_CloseAutomatically(bool value);
    protected virtual bool get_CloseOnFocusLost();
    private void AttachEvents();
    protected virtual void DetachEvents();
    private void CaretPositionChanged(object sender, EventArgs e);
}
internal class ICSharpCode.AvalonEdit.CodeCompletion.InsightWindowTemplateSelector : DataTemplateSelector {
    public virtual DataTemplate SelectTemplate(object item, DependencyObject container);
}
public interface ICSharpCode.AvalonEdit.CodeCompletion.IOverloadProvider {
    public int SelectedIndex { get; public set; }
    public int Count { get; }
    public string CurrentIndexText { get; }
    public object CurrentHeader { get; }
    public object CurrentContent { get; }
    public abstract virtual int get_SelectedIndex();
    public abstract virtual void set_SelectedIndex(int value);
    public abstract virtual int get_Count();
    public abstract virtual string get_CurrentIndexText();
    public abstract virtual object get_CurrentHeader();
    public abstract virtual object get_CurrentContent();
}
public class ICSharpCode.AvalonEdit.CodeCompletion.OverloadInsightWindow : InsightWindow {
    private OverloadViewer overloadViewer;
    public IOverloadProvider Provider { get; public set; }
    public OverloadInsightWindow(TextArea textArea);
    public IOverloadProvider get_Provider();
    public void set_Provider(IOverloadProvider value);
    protected virtual void OnKeyDown(KeyEventArgs e);
}
public class ICSharpCode.AvalonEdit.CodeCompletion.OverloadViewer : Control {
    public static DependencyProperty TextProperty;
    public static DependencyProperty ProviderProperty;
    public string Text { get; public set; }
    public IOverloadProvider Provider { get; public set; }
    private static OverloadViewer();
    public string get_Text();
    public void set_Text(string value);
    public virtual void OnApplyTemplate();
    public IOverloadProvider get_Provider();
    public void set_Provider(IOverloadProvider value);
    public void ChangeIndex(int relativeIndexChange);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__5_0(object sender, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__5_1(object sender, RoutedEventArgs e);
}
public enum ICSharpCode.AvalonEdit.Document.AnchorMovementType : Enum {
    public int value__;
    public static AnchorMovementType Default;
    public static AnchorMovementType BeforeInsertion;
    public static AnchorMovementType AfterInsertion;
}
public class ICSharpCode.AvalonEdit.Document.AnchorSegment : object {
    private TextAnchor start;
    private TextAnchor end;
    public int Offset { get; }
    public int Length { get; }
    public int EndOffset { get; }
    public AnchorSegment(TextAnchor start, TextAnchor end);
    public AnchorSegment(TextDocument document, ISegment segment);
    public AnchorSegment(TextDocument document, int offset, int length);
    public sealed virtual int get_Offset();
    public sealed virtual int get_Length();
    public sealed virtual int get_EndOffset();
    public virtual string ToString();
}
public enum ICSharpCode.AvalonEdit.Document.CaretPositioningMode : Enum {
    public int value__;
    public static CaretPositioningMode Normal;
    public static CaretPositioningMode WordBorder;
    public static CaretPositioningMode WordStart;
    public static CaretPositioningMode WordStartOrSymbol;
    public static CaretPositioningMode WordBorderOrSymbol;
    public static CaretPositioningMode EveryCodepoint;
}
public enum ICSharpCode.AvalonEdit.Document.CharacterClass : Enum {
    public int value__;
    public static CharacterClass Other;
    public static CharacterClass Whitespace;
    public static CharacterClass IdentifierPart;
    public static CharacterClass LineTerminator;
    public static CharacterClass CombiningMark;
}
public class ICSharpCode.AvalonEdit.Document.DocumentChangeEventArgs : TextChangeEventArgs {
    private OffsetChangeMap modreq(System.Runtime.CompilerServices.IsVolatile) offsetChangeMap;
    public OffsetChangeMap OffsetChangeMap { get; }
    internal OffsetChangeMap OffsetChangeMapOrNull { get; }
    public DocumentChangeEventArgs(int offset, string removedText, string insertedText);
    public DocumentChangeEventArgs(int offset, string removedText, string insertedText, OffsetChangeMap offsetChangeMap);
    public DocumentChangeEventArgs(int offset, ITextSource removedText, ITextSource insertedText, OffsetChangeMap offsetChangeMap);
    public OffsetChangeMap get_OffsetChangeMap();
    internal OffsetChangeMapEntry CreateSingleChangeMapEntry();
    internal OffsetChangeMap get_OffsetChangeMapOrNull();
    public virtual int GetNewOffset(int offset, AnchorMovementType movementType);
    private void SetOffsetChangeMap(OffsetChangeMap offsetChangeMap);
    public virtual TextChangeEventArgs Invert();
}
internal class ICSharpCode.AvalonEdit.Document.DocumentChangeOperation : object {
    private TextDocument document;
    private DocumentChangeEventArgs change;
    public DocumentChangeOperation(TextDocument document, DocumentChangeEventArgs change);
    public sealed virtual void Undo(UndoStack stack);
    public sealed virtual void Redo(UndoStack stack);
    public sealed virtual void Undo();
    public sealed virtual void Redo();
}
public class ICSharpCode.AvalonEdit.Document.DocumentLine : object {
    internal bool isDeleted;
    private int totalLength;
    private byte delimiterLength;
    internal DocumentLine left;
    internal DocumentLine right;
    internal DocumentLine parent;
    internal bool color;
    internal int nodeTotalCount;
    internal int nodeTotalLength;
    public bool IsDeleted { get; }
    public int LineNumber { get; }
    public int Offset { get; }
    public int EndOffset { get; }
    public int Length { get; }
    public int TotalLength { get; internal set; }
    public int DelimiterLength { get; internal set; }
    public DocumentLine NextLine { get; }
    public DocumentLine PreviousLine { get; }
    private IDocumentLine ICSharpCode.AvalonEdit.Document.IDocumentLine.NextLine { get; }
    private IDocumentLine ICSharpCode.AvalonEdit.Document.IDocumentLine.PreviousLine { get; }
    internal DocumentLine LeftMost { get; }
    internal DocumentLine RightMost { get; }
    internal DocumentLine(TextDocument document);
    [ConditionalAttribute("DEBUG")]
private void DebugVerifyAccess();
    public sealed virtual bool get_IsDeleted();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_Offset();
    public sealed virtual int get_EndOffset();
    public sealed virtual int get_Length();
    public sealed virtual int get_TotalLength();
    internal void set_TotalLength(int value);
    public sealed virtual int get_DelimiterLength();
    internal void set_DelimiterLength(int value);
    public DocumentLine get_NextLine();
    public DocumentLine get_PreviousLine();
    private sealed virtual override IDocumentLine ICSharpCode.AvalonEdit.Document.IDocumentLine.get_NextLine();
    private sealed virtual override IDocumentLine ICSharpCode.AvalonEdit.Document.IDocumentLine.get_PreviousLine();
    public virtual string ToString();
    internal void ResetLine();
    internal DocumentLine InitLineNode();
    internal DocumentLine get_LeftMost();
    internal DocumentLine get_RightMost();
}
internal class ICSharpCode.AvalonEdit.Document.DocumentLineTree : object {
    private TextDocument document;
    private DocumentLine root;
    internal static bool RED;
    internal static bool BLACK;
    public int LineCount { get; }
    private DocumentLine System.Collections.Generic.IList<ICSharpCode.AvalonEdit.Document.DocumentLine>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.Count { get; }
    private bool System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.IsReadOnly { get; }
    public DocumentLineTree(TextDocument document);
    internal static void UpdateAfterChildrenChange(DocumentLine node);
    private static void UpdateAfterRotateLeft(DocumentLine node);
    private static void UpdateAfterRotateRight(DocumentLine node);
    public void RebuildTree(List`1<DocumentLine> documentLines);
    internal static int GetTreeHeight(int size);
    private DocumentLine BuildTree(DocumentLine[] nodes, int start, int end, int subtreeHeight);
    private DocumentLine GetNodeByIndex(int index);
    internal static int GetIndexFromNode(DocumentLine node);
    private DocumentLine GetNodeByOffset(int offset);
    internal static int GetOffsetFromNode(DocumentLine node);
    public DocumentLine GetByNumber(int number);
    public DocumentLine GetByOffset(int offset);
    public int get_LineCount();
    public void RemoveLine(DocumentLine line);
    public DocumentLine InsertLineAfter(DocumentLine line, int totalLength);
    private void InsertAfter(DocumentLine node, DocumentLine newLine);
    private void InsertAsLeft(DocumentLine parentNode, DocumentLine newNode);
    private void InsertAsRight(DocumentLine parentNode, DocumentLine newNode);
    private void FixTreeOnInsert(DocumentLine node);
    private void RemoveNode(DocumentLine removedNode);
    private void FixTreeOnDelete(DocumentLine node, DocumentLine parentNode);
    private void ReplaceNode(DocumentLine replacedNode, DocumentLine newNode);
    private void RotateLeft(DocumentLine p);
    private void RotateRight(DocumentLine p);
    private static DocumentLine Sibling(DocumentLine node);
    private static DocumentLine Sibling(DocumentLine node, DocumentLine parentNode);
    private static bool GetColor(DocumentLine node);
    private sealed virtual override DocumentLine System.Collections.Generic.IList<ICSharpCode.AvalonEdit.Document.DocumentLine>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<ICSharpCode.AvalonEdit.Document.DocumentLine>.set_Item(int index, DocumentLine value);
    private sealed virtual override int System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.get_IsReadOnly();
    private sealed virtual override int System.Collections.Generic.IList<ICSharpCode.AvalonEdit.Document.DocumentLine>.IndexOf(DocumentLine item);
    private sealed virtual override void System.Collections.Generic.IList<ICSharpCode.AvalonEdit.Document.DocumentLine>.Insert(int index, DocumentLine item);
    private sealed virtual override void System.Collections.Generic.IList<ICSharpCode.AvalonEdit.Document.DocumentLine>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.Add(DocumentLine item);
    private sealed virtual override void System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.Contains(DocumentLine item);
    private sealed virtual override void System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.CopyTo(DocumentLine[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<ICSharpCode.AvalonEdit.Document.DocumentLine>.Remove(DocumentLine item);
    public sealed virtual IEnumerator`1<DocumentLine> GetEnumerator();
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Document.DocumentLineTree/<Enumerate>d__49")]
private IEnumerator`1<DocumentLine> Enumerate();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class ICSharpCode.AvalonEdit.Document.DocumentTextWriter : TextWriter {
    private IDocument document;
    private int insertionOffset;
    public int InsertionOffset { get; public set; }
    public Encoding Encoding { get; }
    public DocumentTextWriter(IDocument document, int insertionOffset);
    public int get_InsertionOffset();
    public void set_InsertionOffset(int value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual Encoding get_Encoding();
}
public interface ICSharpCode.AvalonEdit.Document.IDocument {
    public string Text { get; public set; }
    public int LineCount { get; }
    public string FileName { get; }
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextChanging(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextChanging(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextChanged(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextChanged(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChangeCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChangeCompleted(EventHandler value);
    public abstract virtual int get_LineCount();
    public abstract virtual IDocumentLine GetLineByNumber(int lineNumber);
    public abstract virtual IDocumentLine GetLineByOffset(int offset);
    public abstract virtual int GetOffset(int line, int column);
    public abstract virtual int GetOffset(TextLocation location);
    public abstract virtual TextLocation GetLocation(int offset);
    public abstract virtual void Insert(int offset, string text);
    public abstract virtual void Insert(int offset, ITextSource text);
    public abstract virtual void Insert(int offset, string text, AnchorMovementType defaultAnchorMovementType);
    public abstract virtual void Insert(int offset, ITextSource text, AnchorMovementType defaultAnchorMovementType);
    public abstract virtual void Remove(int offset, int length);
    public abstract virtual void Replace(int offset, int length, string newText);
    public abstract virtual void Replace(int offset, int length, ITextSource newText);
    public abstract virtual void StartUndoableAction();
    public abstract virtual void EndUndoableAction();
    public abstract virtual IDisposable OpenUndoGroup();
    public abstract virtual ITextAnchor CreateAnchor(int offset);
    public abstract virtual string get_FileName();
    [CompilerGeneratedAttribute]
public abstract virtual void add_FileNameChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FileNameChanged(EventHandler value);
}
public interface ICSharpCode.AvalonEdit.Document.IDocumentLine {
    public int TotalLength { get; }
    public int DelimiterLength { get; }
    public int LineNumber { get; }
    public IDocumentLine PreviousLine { get; }
    public IDocumentLine NextLine { get; }
    public bool IsDeleted { get; }
    public abstract virtual int get_TotalLength();
    public abstract virtual int get_DelimiterLength();
    public abstract virtual int get_LineNumber();
    public abstract virtual IDocumentLine get_PreviousLine();
    public abstract virtual IDocumentLine get_NextLine();
    public abstract virtual bool get_IsDeleted();
}
public interface ICSharpCode.AvalonEdit.Document.ILineTracker {
    public abstract virtual void BeforeRemoveLine(DocumentLine line);
    public abstract virtual void SetLineLength(DocumentLine line, int newTotalLength);
    public abstract virtual void LineInserted(DocumentLine insertionPos, DocumentLine newLine);
    public abstract virtual void RebuildDocument();
    public abstract virtual void ChangeComplete(DocumentChangeEventArgs e);
}
public interface ICSharpCode.AvalonEdit.Document.ISegment {
    public int Offset { get; }
    public int Length { get; }
    public int EndOffset { get; }
    public abstract virtual int get_Offset();
    public abstract virtual int get_Length();
    public abstract virtual int get_EndOffset();
}
[ExtensionAttribute]
public static class ICSharpCode.AvalonEdit.Document.ISegmentExtensions : object {
    [ExtensionAttribute]
public static bool Contains(ISegment segment, int offset, int length);
    [ExtensionAttribute]
public static bool Contains(ISegment thisSegment, ISegment segment);
}
internal interface ICSharpCode.AvalonEdit.Document.ISegmentTree {
    public abstract virtual void Add(TextSegment s);
    public abstract virtual void Remove(TextSegment s);
    public abstract virtual void UpdateAugmentedData(TextSegment s);
}
public interface ICSharpCode.AvalonEdit.Document.ITextAnchor {
    public TextLocation Location { get; }
    public int Offset { get; }
    public AnchorMovementType MovementType { get; public set; }
    public bool SurviveDeletion { get; public set; }
    public bool IsDeleted { get; }
    public int Line { get; }
    public int Column { get; }
    public abstract virtual TextLocation get_Location();
    public abstract virtual int get_Offset();
    public abstract virtual AnchorMovementType get_MovementType();
    public abstract virtual void set_MovementType(AnchorMovementType value);
    public abstract virtual bool get_SurviveDeletion();
    public abstract virtual void set_SurviveDeletion(bool value);
    public abstract virtual bool get_IsDeleted();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Deleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Deleted(EventHandler value);
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
}
public interface ICSharpCode.AvalonEdit.Document.ITextSource {
    public ITextSourceVersion Version { get; }
    public int TextLength { get; }
    public string Text { get; }
    public abstract virtual ITextSourceVersion get_Version();
    public abstract virtual ITextSource CreateSnapshot();
    public abstract virtual ITextSource CreateSnapshot(int offset, int length);
    public abstract virtual TextReader CreateReader();
    public abstract virtual TextReader CreateReader(int offset, int length);
    public abstract virtual int get_TextLength();
    public abstract virtual string get_Text();
    public abstract virtual char GetCharAt(int offset);
    public abstract virtual string GetText(int offset, int length);
    public abstract virtual string GetText(ISegment segment);
    public abstract virtual void WriteTextTo(TextWriter writer);
    public abstract virtual void WriteTextTo(TextWriter writer, int offset, int length);
    public abstract virtual int IndexOf(char c, int startIndex, int count);
    public abstract virtual int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public abstract virtual int IndexOf(string searchText, int startIndex, int count, StringComparison comparisonType);
    public abstract virtual int LastIndexOf(char c, int startIndex, int count);
    public abstract virtual int LastIndexOf(string searchText, int startIndex, int count, StringComparison comparisonType);
}
public interface ICSharpCode.AvalonEdit.Document.ITextSourceVersion {
    public abstract virtual bool BelongsToSameDocumentAs(ITextSourceVersion other);
    public abstract virtual int CompareAge(ITextSourceVersion other);
    public abstract virtual IEnumerable`1<TextChangeEventArgs> GetChangesTo(ITextSourceVersion other);
    public abstract virtual int MoveOffsetTo(ITextSourceVersion other, int oldOffset, AnchorMovementType movement);
}
public interface ICSharpCode.AvalonEdit.Document.IUndoableOperation {
    public abstract virtual void Undo();
    public abstract virtual void Redo();
}
internal interface ICSharpCode.AvalonEdit.Document.IUndoableOperationWithContext {
    public abstract virtual void Undo(UndoStack stack);
    public abstract virtual void Redo(UndoStack stack);
}
internal class ICSharpCode.AvalonEdit.Document.LineManager : object {
    private TextDocument document;
    private DocumentLineTree documentLineTree;
    private ILineTracker[] lineTrackers;
    public LineManager(DocumentLineTree documentLineTree, TextDocument document);
    internal void UpdateListOfLineTrackers();
    public void Rebuild();
    public void Remove(int offset, int length);
    private void RemoveLine(DocumentLine lineToRemove);
    public void Insert(int offset, ITextSource text);
    private DocumentLine InsertLineAfter(DocumentLine line, int length);
    private DocumentLine SetLineLength(DocumentLine line, int newTotalLength);
    public void ChangeComplete(DocumentChangeEventArgs e);
}
internal static class ICSharpCode.AvalonEdit.Document.NewLineFinder : object {
    private static Char[] newline;
    internal static String[] NewlineStrings;
    private static NewLineFinder();
    internal static SimpleSegment NextNewLine(string text, int offset);
    internal static SimpleSegment NextNewLine(ITextSource text, int offset);
}
public class ICSharpCode.AvalonEdit.Document.OffsetChangeMap : Collection`1<OffsetChangeMapEntry> {
    public static OffsetChangeMap Empty;
    private bool isFrozen;
    public bool IsFrozen { get; }
    internal OffsetChangeMap(int capacity);
    private OffsetChangeMap(IList`1<OffsetChangeMapEntry> entries, bool isFrozen);
    private static OffsetChangeMap();
    public static OffsetChangeMap FromSingleElement(OffsetChangeMapEntry entry);
    public int GetNewOffset(int offset, AnchorMovementType movementType);
    public bool IsValidForDocumentChange(int offset, int removalLength, int insertionLength);
    public OffsetChangeMap Invert();
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, OffsetChangeMapEntry item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, OffsetChangeMapEntry item);
    private void CheckFrozen();
    public bool get_IsFrozen();
    public void Freeze();
}
public class ICSharpCode.AvalonEdit.Document.OffsetChangeMapEntry : ValueType {
    private int offset;
    private UInt32 insertionLengthWithMovementFlag;
    private UInt32 removalLengthWithDeletionFlag;
    public int Offset { get; }
    public int InsertionLength { get; }
    public int RemovalLength { get; }
    public bool RemovalNeverCausesAnchorDeletion { get; }
    public bool DefaultAnchorMovementIsBeforeInsertion { get; }
    public OffsetChangeMapEntry(int offset, int removalLength, int insertionLength);
    public OffsetChangeMapEntry(int offset, int removalLength, int insertionLength, bool removalNeverCausesAnchorDeletion, bool defaultAnchorMovementIsBeforeInsertion);
    public int get_Offset();
    public int get_InsertionLength();
    public int get_RemovalLength();
    public bool get_RemovalNeverCausesAnchorDeletion();
    public bool get_DefaultAnchorMovementIsBeforeInsertion();
    public int GetNewOffset(int oldOffset, AnchorMovementType movementType);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OffsetChangeMapEntry other);
    public static bool op_Equality(OffsetChangeMapEntry left, OffsetChangeMapEntry right);
    public static bool op_Inequality(OffsetChangeMapEntry left, OffsetChangeMapEntry right);
}
public enum ICSharpCode.AvalonEdit.Document.OffsetChangeMappingType : Enum {
    public int value__;
    public static OffsetChangeMappingType Normal;
    public static OffsetChangeMappingType RemoveAndInsert;
    public static OffsetChangeMappingType CharacterReplace;
    public static OffsetChangeMappingType KeepAnchorBeforeInsertion;
}
public class ICSharpCode.AvalonEdit.Document.RopeTextSource : object {
    private Rope`1<char> rope;
    private ITextSourceVersion version;
    public string Text { get; }
    public int TextLength { get; }
    public ITextSourceVersion Version { get; }
    public RopeTextSource(Rope`1<char> rope);
    public RopeTextSource(Rope`1<char> rope, ITextSourceVersion version);
    public Rope`1<char> GetRope();
    public sealed virtual string get_Text();
    public sealed virtual int get_TextLength();
    public sealed virtual char GetCharAt(int offset);
    public sealed virtual string GetText(int offset, int length);
    public sealed virtual string GetText(ISegment segment);
    public sealed virtual TextReader CreateReader();
    public sealed virtual TextReader CreateReader(int offset, int length);
    public sealed virtual ITextSource CreateSnapshot();
    public sealed virtual ITextSource CreateSnapshot(int offset, int length);
    public sealed virtual int IndexOf(char c, int startIndex, int count);
    public sealed virtual int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public sealed virtual int LastIndexOf(char c, int startIndex, int count);
    public sealed virtual ITextSourceVersion get_Version();
    public sealed virtual int IndexOf(string searchText, int startIndex, int count, StringComparison comparisonType);
    public sealed virtual int LastIndexOf(string searchText, int startIndex, int count, StringComparison comparisonType);
    public sealed virtual void WriteTextTo(TextWriter writer);
    public sealed virtual void WriteTextTo(TextWriter writer, int offset, int length);
}
internal class ICSharpCode.AvalonEdit.Document.SimpleSegment : ValueType {
    public static SimpleSegment Invalid;
    public int Offset;
    public int Length;
    private int ICSharpCode.AvalonEdit.Document.ISegment.Offset { get; }
    private int ICSharpCode.AvalonEdit.Document.ISegment.Length { get; }
    public int EndOffset { get; }
    public SimpleSegment(int offset, int length);
    public SimpleSegment(ISegment segment);
    private static SimpleSegment();
    public static SimpleSegment GetOverlap(ISegment segment1, ISegment segment2);
    private sealed virtual override int ICSharpCode.AvalonEdit.Document.ISegment.get_Offset();
    private sealed virtual override int ICSharpCode.AvalonEdit.Document.ISegment.get_Length();
    public sealed virtual int get_EndOffset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SimpleSegment other);
    public static bool op_Equality(SimpleSegment left, SimpleSegment right);
    public static bool op_Inequality(SimpleSegment left, SimpleSegment right);
    public virtual string ToString();
}
public class ICSharpCode.AvalonEdit.Document.StringTextSource : object {
    public static StringTextSource Empty;
    private string text;
    private ITextSourceVersion version;
    public ITextSourceVersion Version { get; }
    public int TextLength { get; }
    public string Text { get; }
    public StringTextSource(string text);
    public StringTextSource(string text, ITextSourceVersion version);
    private static StringTextSource();
    public sealed virtual ITextSourceVersion get_Version();
    public sealed virtual int get_TextLength();
    public sealed virtual string get_Text();
    public sealed virtual ITextSource CreateSnapshot();
    public sealed virtual ITextSource CreateSnapshot(int offset, int length);
    public sealed virtual TextReader CreateReader();
    public sealed virtual TextReader CreateReader(int offset, int length);
    public sealed virtual void WriteTextTo(TextWriter writer);
    public sealed virtual void WriteTextTo(TextWriter writer, int offset, int length);
    public sealed virtual char GetCharAt(int offset);
    public sealed virtual string GetText(int offset, int length);
    public sealed virtual string GetText(ISegment segment);
    public sealed virtual int IndexOf(char c, int startIndex, int count);
    public sealed virtual int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public sealed virtual int IndexOf(string searchText, int startIndex, int count, StringComparison comparisonType);
    public sealed virtual int LastIndexOf(char c, int startIndex, int count);
    public sealed virtual int LastIndexOf(string searchText, int startIndex, int count, StringComparison comparisonType);
}
public class ICSharpCode.AvalonEdit.Document.TextAnchor : object {
    private TextDocument document;
    internal TextAnchorNode node;
    [CompilerGeneratedAttribute]
private AnchorMovementType <MovementType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SurviveDeletion>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler Deleted;
    public TextDocument Document { get; }
    public AnchorMovementType MovementType { get; public set; }
    public bool SurviveDeletion { get; public set; }
    public bool IsDeleted { get; }
    public int Offset { get; }
    public int Line { get; }
    public int Column { get; }
    public TextLocation Location { get; }
    internal TextAnchor(TextDocument document);
    public TextDocument get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual AnchorMovementType get_MovementType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MovementType(AnchorMovementType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SurviveDeletion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SurviveDeletion(bool value);
    public sealed virtual bool get_IsDeleted();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Deleted(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Deleted(EventHandler value);
    internal void OnDeleted(DelayedEvents delayedEvents);
    public sealed virtual int get_Offset();
    public sealed virtual int get_Line();
    public sealed virtual int get_Column();
    public sealed virtual TextLocation get_Location();
    public virtual string ToString();
}
internal class ICSharpCode.AvalonEdit.Document.TextAnchorNode : WeakReference {
    internal TextAnchorNode left;
    internal TextAnchorNode right;
    internal TextAnchorNode parent;
    internal bool color;
    internal int length;
    internal int totalLength;
    internal TextAnchorNode LeftMost { get; }
    internal TextAnchorNode RightMost { get; }
    internal TextAnchorNode Successor { get; }
    internal TextAnchorNode Predecessor { get; }
    public TextAnchorNode(TextAnchor anchor);
    internal TextAnchorNode get_LeftMost();
    internal TextAnchorNode get_RightMost();
    internal TextAnchorNode get_Successor();
    internal TextAnchorNode get_Predecessor();
    public virtual string ToString();
}
internal class ICSharpCode.AvalonEdit.Document.TextAnchorTree : object {
    private TextDocument document;
    private List`1<TextAnchorNode> nodesToDelete;
    private TextAnchorNode root;
    internal static bool RED;
    internal static bool BLACK;
    public TextAnchorTree(TextDocument document);
    [ConditionalAttribute("DEBUG")]
private static void Log(string text);
    private void InsertText(int offset, int length, bool defaultAnchorMovementIsBeforeInsertion);
    private TextAnchorNode FindActualBeginNode(TextAnchorNode node);
    private void PerformInsertText(TextAnchorNode beginNode, TextAnchorNode endNode, int length, bool defaultAnchorMovementIsBeforeInsertion);
    private void SwapAnchors(TextAnchorNode n1, TextAnchorNode n2);
    public void HandleTextChange(OffsetChangeMapEntry entry, DelayedEvents delayedEvents);
    private void MarkNodeForDelete(TextAnchorNode node);
    private void DeleteMarkedNodes();
    private TextAnchorNode FindNode(Int32& offset);
    private void UpdateAugmentedData(TextAnchorNode n);
    public TextAnchor CreateAnchor(int offset);
    private void InsertBefore(TextAnchorNode node, TextAnchorNode newNode);
    private void InsertAsLeft(TextAnchorNode parentNode, TextAnchorNode newNode);
    private void InsertAsRight(TextAnchorNode parentNode, TextAnchorNode newNode);
    private void FixTreeOnInsert(TextAnchorNode node);
    private void RemoveNode(TextAnchorNode removedNode);
    private void FixTreeOnDelete(TextAnchorNode node, TextAnchorNode parentNode);
    private void ReplaceNode(TextAnchorNode replacedNode, TextAnchorNode newNode);
    private void RotateLeft(TextAnchorNode p);
    private void RotateRight(TextAnchorNode p);
    private static TextAnchorNode Sibling(TextAnchorNode node);
    private static TextAnchorNode Sibling(TextAnchorNode node, TextAnchorNode parentNode);
    private static bool GetColor(TextAnchorNode node);
    [ConditionalAttribute("DATACONSISTENCYTEST")]
internal void CheckProperties();
}
public class ICSharpCode.AvalonEdit.Document.TextChangeEventArgs : EventArgs {
    private int offset;
    private ITextSource removedText;
    private ITextSource insertedText;
    public int Offset { get; }
    public ITextSource RemovedText { get; }
    public int RemovalLength { get; }
    public ITextSource InsertedText { get; }
    public int InsertionLength { get; }
    public TextChangeEventArgs(int offset, string removedText, string insertedText);
    public TextChangeEventArgs(int offset, ITextSource removedText, ITextSource insertedText);
    public int get_Offset();
    public ITextSource get_RemovedText();
    public int get_RemovalLength();
    public ITextSource get_InsertedText();
    public int get_InsertionLength();
    public virtual int GetNewOffset(int offset, AnchorMovementType movementType);
    public virtual TextChangeEventArgs Invert();
}
public class ICSharpCode.AvalonEdit.Document.TextDocument : object {
    private object lockObject;
    private Thread owner;
    private Rope`1<char> rope;
    private DocumentLineTree lineTree;
    private LineManager lineManager;
    private TextAnchorTree anchorTree;
    private TextSourceVersionProvider versionProvider;
    private WeakReference cachedText;
    [CompilerGeneratedAttribute]
private EventHandler TextChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<DocumentChangeEventArgs> Changing;
    [CompilerGeneratedAttribute]
private EventHandler`1<TextChangeEventArgs> textChanging;
    [CompilerGeneratedAttribute]
private EventHandler`1<DocumentChangeEventArgs> Changed;
    [CompilerGeneratedAttribute]
private EventHandler`1<TextChangeEventArgs> textChanged;
    private int beginUpdateCount;
    [CompilerGeneratedAttribute]
private EventHandler UpdateStarted;
    [CompilerGeneratedAttribute]
private EventHandler UpdateFinished;
    private int oldTextLength;
    private int oldLineCount;
    private bool fireTextChanged;
    internal bool inDocumentChanging;
    private ObservableCollection`1<ILineTracker> lineTrackers;
    private UndoStack undoStack;
    private IServiceProvider serviceProvider;
    private string fileName;
    [CompilerGeneratedAttribute]
private EventHandler FileNameChanged;
    public string Text { get; public set; }
    public int TextLength { get; }
    public ITextSourceVersion Version { get; }
    public bool IsInUpdate { get; }
    public IList`1<DocumentLine> Lines { get; }
    public IList`1<ILineTracker> LineTrackers { get; }
    public UndoStack UndoStack { get; public set; }
    public int LineCount { get; }
    public IServiceProvider ServiceProvider { get; public set; }
    public string FileName { get; public set; }
    public TextDocument(IEnumerable`1<char> initialText);
    public TextDocument(ITextSource initialText);
    public void VerifyAccess();
    public void SetOwnerThread(Thread newOwner);
    private static IEnumerable`1<char> GetTextFromTextSource(ITextSource textSource);
    private void ThrowIfRangeInvalid(int offset, int length);
    public sealed virtual string GetText(int offset, int length);
    public sealed virtual string GetText(ISegment segment);
    public sealed virtual int IndexOf(char c, int startIndex, int count);
    public sealed virtual int LastIndexOf(char c, int startIndex, int count);
    public sealed virtual int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public sealed virtual int IndexOf(string searchText, int startIndex, int count, StringComparison comparisonType);
    public sealed virtual int LastIndexOf(string searchText, int startIndex, int count, StringComparison comparisonType);
    public sealed virtual char GetCharAt(int offset);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
    [CompilerGeneratedAttribute]
public void add_TextChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TextChanged(EventHandler value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.IDocument.add_ChangeCompleted(EventHandler value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.IDocument.remove_ChangeCompleted(EventHandler value);
    public sealed virtual int get_TextLength();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Changing(EventHandler`1<DocumentChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Changing(EventHandler`1<DocumentChangeEventArgs> value);
    [CompilerGeneratedAttribute]
private void add_textChanging(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_textChanging(EventHandler`1<TextChangeEventArgs> value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.IDocument.add_TextChanging(EventHandler`1<TextChangeEventArgs> value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.IDocument.remove_TextChanging(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Changed(EventHandler`1<DocumentChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Changed(EventHandler`1<DocumentChangeEventArgs> value);
    [CompilerGeneratedAttribute]
private void add_textChanged(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_textChanged(EventHandler`1<TextChangeEventArgs> value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.IDocument.add_TextChanged(EventHandler`1<TextChangeEventArgs> value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.IDocument.remove_TextChanged(EventHandler`1<TextChangeEventArgs> value);
    public sealed virtual ITextSource CreateSnapshot();
    public sealed virtual ITextSource CreateSnapshot(int offset, int length);
    public sealed virtual ITextSourceVersion get_Version();
    public sealed virtual TextReader CreateReader();
    public sealed virtual TextReader CreateReader(int offset, int length);
    public sealed virtual void WriteTextTo(TextWriter writer);
    public sealed virtual void WriteTextTo(TextWriter writer, int offset, int length);
    public bool get_IsInUpdate();
    public IDisposable RunUpdate();
    public void BeginUpdate();
    public void EndUpdate();
    [CompilerGeneratedAttribute]
public void add_UpdateStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UpdateStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_UpdateFinished(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UpdateFinished(EventHandler value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.IDocument.StartUndoableAction();
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.IDocument.EndUndoableAction();
    private sealed virtual override IDisposable ICSharpCode.AvalonEdit.Document.IDocument.OpenUndoGroup();
    internal void FireChangeEvents();
    private void OnPropertyChanged(string propertyName);
    public sealed virtual void Insert(int offset, string text);
    public sealed virtual void Insert(int offset, ITextSource text);
    public sealed virtual void Insert(int offset, string text, AnchorMovementType defaultAnchorMovementType);
    public sealed virtual void Insert(int offset, ITextSource text, AnchorMovementType defaultAnchorMovementType);
    public void Remove(ISegment segment);
    public sealed virtual void Remove(int offset, int length);
    public void Replace(ISegment segment, string text);
    public void Replace(ISegment segment, ITextSource text);
    public sealed virtual void Replace(int offset, int length, string text);
    public sealed virtual void Replace(int offset, int length, ITextSource text);
    public void Replace(int offset, int length, string text, OffsetChangeMappingType offsetChangeMappingType);
    public void Replace(int offset, int length, ITextSource text, OffsetChangeMappingType offsetChangeMappingType);
    public void Replace(int offset, int length, string text, OffsetChangeMap offsetChangeMap);
    public void Replace(int offset, int length, ITextSource text, OffsetChangeMap offsetChangeMap);
    private void DoReplace(int offset, int length, ITextSource newText, OffsetChangeMap offsetChangeMap);
    public IList`1<DocumentLine> get_Lines();
    public DocumentLine GetLineByNumber(int number);
    private sealed virtual override IDocumentLine ICSharpCode.AvalonEdit.Document.IDocument.GetLineByNumber(int lineNumber);
    public DocumentLine GetLineByOffset(int offset);
    private sealed virtual override IDocumentLine ICSharpCode.AvalonEdit.Document.IDocument.GetLineByOffset(int offset);
    public sealed virtual int GetOffset(TextLocation location);
    public sealed virtual int GetOffset(int line, int column);
    public sealed virtual TextLocation GetLocation(int offset);
    public IList`1<ILineTracker> get_LineTrackers();
    public UndoStack get_UndoStack();
    public void set_UndoStack(UndoStack value);
    public TextAnchor CreateAnchor(int offset);
    private sealed virtual override ITextAnchor ICSharpCode.AvalonEdit.Document.IDocument.CreateAnchor(int offset);
    public sealed virtual int get_LineCount();
    [ConditionalAttribute("DEBUG")]
internal void DebugVerifyAccess();
    internal string GetLineTreeAsString();
    internal string GetTextAnchorTreeAsString();
    public IServiceProvider get_ServiceProvider();
    public void set_ServiceProvider(IServiceProvider value);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FileNameChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FileNameChanged(EventHandler value);
    private void OnFileNameChanged(EventArgs e);
    public sealed virtual string get_FileName();
    public void set_FileName(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__10_0(object <p0>, NotifyCollectionChangedEventArgs <p1>);
}
public static class ICSharpCode.AvalonEdit.Document.TextDocumentWeakEventManager : object {
}
[TypeConverterAttribute("ICSharpCode.AvalonEdit.Document.TextLocationConverter")]
public class ICSharpCode.AvalonEdit.Document.TextLocation : ValueType {
    public static TextLocation Empty;
    private int column;
    private int line;
    public int Line { get; }
    public int Column { get; }
    public bool IsEmpty { get; }
    public TextLocation(int line, int column);
    private static TextLocation();
    public int get_Line();
    public int get_Column();
    public bool get_IsEmpty();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextLocation other);
    public static bool op_Equality(TextLocation left, TextLocation right);
    public static bool op_Inequality(TextLocation left, TextLocation right);
    public static bool op_LessThan(TextLocation left, TextLocation right);
    public static bool op_GreaterThan(TextLocation left, TextLocation right);
    public static bool op_LessThanOrEqual(TextLocation left, TextLocation right);
    public static bool op_GreaterThanOrEqual(TextLocation left, TextLocation right);
    public sealed virtual int CompareTo(TextLocation other);
}
public class ICSharpCode.AvalonEdit.Document.TextLocationConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class ICSharpCode.AvalonEdit.Document.TextSegment : object {
    internal ISegmentTree ownerTree;
    internal TextSegment left;
    internal TextSegment right;
    internal TextSegment parent;
    internal bool color;
    internal int nodeLength;
    internal int totalNodeLength;
    internal int segmentLength;
    internal int distanceToMaxEnd;
    private int ICSharpCode.AvalonEdit.Document.ISegment.Offset { get; }
    protected bool IsConnectedToCollection { get; }
    public int StartOffset { get; public set; }
    public int EndOffset { get; public set; }
    public int Length { get; public set; }
    internal TextSegment LeftMost { get; }
    internal TextSegment RightMost { get; }
    internal TextSegment Successor { get; }
    internal TextSegment Predecessor { get; }
    private sealed virtual override int ICSharpCode.AvalonEdit.Document.ISegment.get_Offset();
    protected bool get_IsConnectedToCollection();
    public int get_StartOffset();
    public void set_StartOffset(int value);
    public sealed virtual int get_EndOffset();
    public void set_EndOffset(int value);
    public sealed virtual int get_Length();
    public void set_Length(int value);
    protected virtual void OnSegmentChanged();
    internal TextSegment get_LeftMost();
    internal TextSegment get_RightMost();
    internal TextSegment get_Successor();
    internal TextSegment get_Predecessor();
    public virtual string ToString();
}
public class ICSharpCode.AvalonEdit.Document.TextSegmentCollection`1 : object {
    private int count;
    private TextSegment root;
    private bool isConnectedToDocument;
    internal static bool RED;
    internal static bool BLACK;
    public T FirstSegment { get; }
    public T LastSegment { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public TextSegmentCollection`1(TextDocument textDocument);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    public void UpdateOffsets(DocumentChangeEventArgs e);
    private void OnDocumentChanged(DocumentChangeEventArgs e);
    public void UpdateOffsets(OffsetChangeMapEntry change);
    private void UpdateOffsetsInternal(OffsetChangeMapEntry change);
    private void InsertText(int offset, int length);
    private void ReplaceText(OffsetChangeMapEntry change);
    public sealed virtual void Add(T item);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ISegmentTree.Add(TextSegment s);
    private void AddSegment(TextSegment node);
    private void InsertBefore(TextSegment node, TextSegment newNode);
    public T GetNextSegment(T segment);
    public T GetPreviousSegment(T segment);
    public T get_FirstSegment();
    public T get_LastSegment();
    public T FindFirstSegmentWithStartAfter(int startOffset);
    private TextSegment FindNode(Int32& offset);
    public ReadOnlyCollection`1<T> FindSegmentsContaining(int offset);
    public ReadOnlyCollection`1<T> FindOverlappingSegments(ISegment segment);
    public ReadOnlyCollection`1<T> FindOverlappingSegments(int offset, int length);
    private void FindOverlappingSegments(List`1<T> results, TextSegment node, int low, int high);
    private void UpdateAugmentedData(TextSegment node);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ISegmentTree.UpdateAugmentedData(TextSegment node);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ISegmentTree.Remove(TextSegment s);
    private void RemoveSegment(TextSegment s);
    private void Disconnect(TextSegment s, int offset);
    public sealed virtual void Clear();
    [ConditionalAttribute("DATACONSISTENCYTEST")]
internal void CheckProperties();
    internal string GetTreeAsString();
    private void InsertAsLeft(TextSegment parentNode, TextSegment newNode);
    private void InsertAsRight(TextSegment parentNode, TextSegment newNode);
    private void FixTreeOnInsert(TextSegment node);
    private void RemoveNode(TextSegment removedNode);
    private void FixTreeOnDelete(TextSegment node, TextSegment parentNode);
    private void ReplaceNode(TextSegment replacedNode, TextSegment newNode);
    private void RotateLeft(TextSegment p);
    private void RotateRight(TextSegment p);
    private static TextSegment Sibling(TextSegment node);
    private static TextSegment Sibling(TextSegment node, TextSegment parentNode);
    private static bool GetColor(TextSegment node);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Document.TextSegmentCollection`1/<GetEnumerator>d__56")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class ICSharpCode.AvalonEdit.Document.TextSourceVersionProvider : object {
    private Version currentVersion;
    public ITextSourceVersion CurrentVersion { get; }
    public ITextSourceVersion get_CurrentVersion();
    public void AppendChange(TextChangeEventArgs change);
}
public static class ICSharpCode.AvalonEdit.Document.TextUtilities : object {
    private static String[] c0Table;
    private static String[] delAndC1Table;
    private static TextUtilities();
    public static int FindNextNewLine(ITextSource text, int offset, String& newLineType);
    public static bool IsNewLine(string newLine);
    public static string NormalizeNewLines(string input, string newLine);
    public static string GetNewLineFromDocument(IDocument document, int lineNumber);
    public static string GetControlCharacterName(char controlCharacter);
    public static ISegment GetWhitespaceAfter(ITextSource textSource, int offset);
    public static ISegment GetWhitespaceBefore(ITextSource textSource, int offset);
    public static ISegment GetLeadingWhitespace(TextDocument document, DocumentLine documentLine);
    public static ISegment GetTrailingWhitespace(TextDocument document, DocumentLine documentLine);
    public static ISegment GetSingleIndentationSegment(ITextSource textSource, int offset, int indentationSize);
    public static CharacterClass GetCharacterClass(char c);
    private static CharacterClass GetCharacterClass(char highSurrogate, char lowSurrogate);
    private static CharacterClass GetCharacterClass(UnicodeCategory c);
    public static int GetNextCaretPosition(ITextSource textSource, int offset, LogicalDirection direction, CaretPositioningMode mode);
    private static bool IsNormal(CaretPositioningMode mode);
    private static bool StopBetweenCharacters(CaretPositioningMode mode, CharacterClass charBefore, CharacterClass charAfter);
}
internal class ICSharpCode.AvalonEdit.Document.UndoOperationGroup : object {
    private IUndoableOperation[] undolist;
    public UndoOperationGroup(Deque`1<IUndoableOperation> stack, int numops);
    public sealed virtual void Undo();
    public sealed virtual void Undo(UndoStack stack);
    public sealed virtual void Redo();
    public sealed virtual void Redo(UndoStack stack);
}
public class ICSharpCode.AvalonEdit.Document.UndoStack : object {
    internal static int StateListen;
    internal static int StatePlayback;
    internal static int StatePlaybackModifyDocument;
    internal int state;
    private Deque`1<IUndoableOperation> undostack;
    private Deque`1<IUndoableOperation> redostack;
    private int sizeLimit;
    private int undoGroupDepth;
    private int actionCountInUndoGroup;
    private int optionalActionCount;
    private object lastGroupDescriptor;
    private bool allowContinue;
    private int elementsOnUndoUntilOriginalFile;
    private bool isOriginalFile;
    private List`1<TextDocument> affectedDocuments;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool IsOriginalFile { get; }
    public bool AcceptChanges { get; }
    public bool CanUndo { get; }
    public bool CanRedo { get; }
    public int SizeLimit { get; public set; }
    public object LastGroupDescriptor { get; }
    public bool get_IsOriginalFile();
    private void RecalcIsOriginalFile();
    public void MarkAsOriginalFile();
    public void DiscardOriginalFileMarker();
    private void FileModified(int newElementsOnUndoStack);
    public bool get_AcceptChanges();
    public bool get_CanUndo();
    public bool get_CanRedo();
    public int get_SizeLimit();
    public void set_SizeLimit(int value);
    private void EnforceSizeLimit();
    public object get_LastGroupDescriptor();
    public void StartUndoGroup();
    public void StartUndoGroup(object groupDescriptor);
    public void StartContinuedUndoGroup(object groupDescriptor);
    public void EndUndoGroup();
    private void ThrowIfUndoGroupOpen();
    internal void RegisterAffectedDocument(TextDocument document);
    private void CallEndUpdateOnAffectedDocuments();
    public void Undo();
    internal void RunUndo(IUndoableOperation op);
    public void Redo();
    internal void RunRedo(IUndoableOperation op);
    public void Push(IUndoableOperation operation);
    public void PushOptional(IUndoableOperation operation);
    private void Push(IUndoableOperation operation, bool isOptional);
    public void ClearRedoStack();
    public void ClearAll();
    internal void Push(TextDocument document, DocumentChangeEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private void NotifyPropertyChanged(string propertyName);
}
public class ICSharpCode.AvalonEdit.Document.WeakLineTracker : object {
    private TextDocument textDocument;
    private WeakReference targetObject;
    private WeakLineTracker(TextDocument textDocument, ILineTracker targetTracker);
    public static WeakLineTracker Register(TextDocument textDocument, ILineTracker targetTracker);
    public void Deregister();
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.BeforeRemoveLine(DocumentLine line);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.SetLineLength(DocumentLine line, int newTotalLength);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.LineInserted(DocumentLine insertionPos, DocumentLine newLine);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.RebuildDocument();
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.ChangeComplete(DocumentChangeEventArgs e);
}
public abstract class ICSharpCode.AvalonEdit.Editing.AbstractMargin : FrameworkElement {
    public static DependencyProperty TextViewProperty;
    private bool wasAutoAddedToTextView;
    private TextDocument document;
    public TextView TextView { get; public set; }
    public TextDocument Document { get; }
    private static AbstractMargin();
    public TextView get_TextView();
    public void set_TextView(TextView value);
    private static void OnTextViewChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e);
    private sealed virtual override void ICSharpCode.AvalonEdit.Rendering.ITextViewConnect.AddToTextView(TextView textView);
    private sealed virtual override void ICSharpCode.AvalonEdit.Rendering.ITextViewConnect.RemoveFromTextView(TextView textView);
    public TextDocument get_Document();
    protected virtual void OnTextViewChanged(TextView oldTextView, TextView newTextView);
    private void TextViewDocumentChanged(object sender, EventArgs e);
    protected virtual void OnDocumentChanged(TextDocument oldDocument, TextDocument newDocument);
}
public class ICSharpCode.AvalonEdit.Editing.Caret : object {
    private TextArea textArea;
    private TextView textView;
    private CaretLayer caretAdorner;
    private bool visible;
    private double desiredXPos;
    private TextViewPosition position;
    private bool isInVirtualSpace;
    private int storedCaretOffset;
    [CompilerGeneratedAttribute]
private EventHandler PositionChanged;
    private bool raisePositionChangedOnUpdateFinished;
    private bool visualColumnValid;
    internal static double MinimumDistanceToViewBorder;
    private bool showScheduled;
    private bool hasWin32Caret;
    public TextViewPosition Position { get; public set; }
    internal TextViewPosition NonValidatedPosition { get; }
    public TextLocation Location { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int VisualColumn { get; public set; }
    public bool IsInVirtualSpace { get; }
    public int Offset { get; public set; }
    public double DesiredXPos { get; public set; }
    public Brush CaretBrush { get; public set; }
    internal Caret(TextArea textArea);
    internal void UpdateIfVisible();
    private void TextView_VisualLinesChanged(object sender, EventArgs e);
    private void TextView_ScrollOffsetChanged(object sender, EventArgs e);
    public TextViewPosition get_Position();
    public void set_Position(TextViewPosition value);
    internal TextViewPosition get_NonValidatedPosition();
    public TextLocation get_Location();
    public void set_Location(TextLocation value);
    public int get_Line();
    public void set_Line(int value);
    public int get_Column();
    public void set_Column(int value);
    public int get_VisualColumn();
    public void set_VisualColumn(int value);
    public bool get_IsInVirtualSpace();
    internal void OnDocumentChanging();
    internal void OnDocumentChanged(DocumentChangeEventArgs e);
    public int get_Offset();
    public void set_Offset(int value);
    public double get_DesiredXPos();
    public void set_DesiredXPos(double value);
    private void ValidatePosition();
    [CompilerGeneratedAttribute]
public void add_PositionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PositionChanged(EventHandler value);
    private void RaisePositionChanged();
    internal void OnDocumentUpdateFinished();
    private void ValidateVisualColumn();
    private void InvalidateVisualColumn();
    private void RevalidateVisualColumn(VisualLine visualLine);
    private Rect CalcCaretRectangle(VisualLine visualLine);
    private Rect CalcCaretOverstrikeRectangle(VisualLine visualLine);
    public Rect CalculateCaretRectangle();
    public void BringCaretToView();
    internal void BringCaretToView(double border);
    public void Show();
    private void ShowInternal();
    public void Hide();
    [ConditionalAttribute("DEBUG")]
private static void Log(string text);
    public Brush get_CaretBrush();
    public void set_CaretBrush(Brush value);
}
internal class ICSharpCode.AvalonEdit.Editing.CaretLayer : Layer {
    private TextArea textArea;
    private bool isVisible;
    private Rect caretRectangle;
    private DispatcherTimer caretBlinkTimer;
    private bool blink;
    internal Brush CaretBrush;
    public CaretLayer(TextArea textArea);
    private void caretBlinkTimer_Tick(object sender, EventArgs e);
    public void Show(Rect caretRectangle);
    public void Hide();
    private void StartBlinkAnimation();
    private void StopBlinkAnimation();
    protected virtual void OnRender(DrawingContext drawingContext);
}
internal enum ICSharpCode.AvalonEdit.Editing.CaretMovementType : Enum {
    public int value__;
    public static CaretMovementType None;
    public static CaretMovementType CharLeft;
    public static CaretMovementType CharRight;
    public static CaretMovementType Backspace;
    public static CaretMovementType WordLeft;
    public static CaretMovementType WordRight;
    public static CaretMovementType LineUp;
    public static CaretMovementType LineDown;
    public static CaretMovementType PageUp;
    public static CaretMovementType PageDown;
    public static CaretMovementType LineStart;
    public static CaretMovementType LineEnd;
    public static CaretMovementType DocumentStart;
    public static CaretMovementType DocumentEnd;
}
internal static class ICSharpCode.AvalonEdit.Editing.CaretNavigationCommandHandler : object {
    private static List`1<CommandBinding> CommandBindings;
    private static List`1<InputBinding> InputBindings;
    private static CaretNavigationCommandHandler();
    public static TextAreaInputHandler Create(TextArea textArea);
    private static void AddBinding(ICommand command, ModifierKeys modifiers, Key key, ExecutedRoutedEventHandler handler);
    private static void OnSelectAll(object target, ExecutedRoutedEventArgs args);
    private static TextArea GetTextArea(object target);
    private static ExecutedRoutedEventHandler OnMoveCaret(CaretMovementType direction);
    private static ExecutedRoutedEventHandler OnMoveCaretExtendSelection(CaretMovementType direction);
    private static ExecutedRoutedEventHandler OnMoveCaretBoxSelection(CaretMovementType direction);
    internal static void MoveCaret(TextArea textArea, CaretMovementType direction);
    internal static TextViewPosition GetNewCaretPosition(TextView textView, TextViewPosition caretPosition, CaretMovementType direction, bool enableVirtualSpace, Double& desiredXPos);
    private static TextViewPosition GetStartOfLineCaretPosition(int oldVC, VisualLine visualLine, TextLine textLine, bool enableVirtualSpace);
    private static TextViewPosition GetEndOfLineCaretPosition(VisualLine visualLine, TextLine textLine);
    private static TextViewPosition GetNextCaretPosition(TextView textView, TextViewPosition caretPosition, VisualLine visualLine, CaretPositioningMode mode, bool enableVirtualSpace);
    private static TextViewPosition GetPrevCaretPosition(TextView textView, TextViewPosition caretPosition, VisualLine visualLine, CaretPositioningMode mode, bool enableVirtualSpace);
    private static TextViewPosition GetUpDownCaretPosition(TextView textView, TextViewPosition caretPosition, CaretMovementType direction, VisualLine visualLine, TextLine textLine, bool enableVirtualSpace, Double& xPos);
}
public static class ICSharpCode.AvalonEdit.Editing.CaretWeakEventManager : object {
}
public static class ICSharpCode.AvalonEdit.Editing.DottedLineMargin : object {
    private static object tag;
    private static DottedLineMargin();
    public static UIElement Create();
    public static bool IsDottedLineMargin(UIElement element);
}
public class ICSharpCode.AvalonEdit.Editing.DragDropException : Exception {
    public DragDropException(string message);
    public DragDropException(string message, Exception innerException);
    protected DragDropException(SerializationInfo info, StreamingContext context);
}
internal static class ICSharpCode.AvalonEdit.Editing.EditingCommandHandler : object {
    private static List`1<CommandBinding> CommandBindings;
    private static List`1<InputBinding> InputBindings;
    private static string LineSelectedType;
    private static EditingCommandHandler();
    public static TextAreaInputHandler Create(TextArea textArea);
    private static void AddBinding(ICommand command, ModifierKeys modifiers, Key key, ExecutedRoutedEventHandler handler);
    private static TextArea GetTextArea(object target);
    private static void TransformSelectedLines(Action`2<TextArea, DocumentLine> transformLine, object target, ExecutedRoutedEventArgs args, DefaultSegmentType defaultSegmentType);
    private static void TransformSelectedSegments(Action`2<TextArea, ISegment> transformSegment, object target, ExecutedRoutedEventArgs args, DefaultSegmentType defaultSegmentType);
    private static void OnEnter(object target, ExecutedRoutedEventArgs args);
    private static void OnTab(object target, ExecutedRoutedEventArgs args);
    private static void OnShiftTab(object target, ExecutedRoutedEventArgs args);
    private static ExecutedRoutedEventHandler OnDelete(CaretMovementType caretMovement);
    private static void CanDelete(object target, CanExecuteRoutedEventArgs args);
    private static void CanCutOrCopy(object target, CanExecuteRoutedEventArgs args);
    private static void OnCopy(object target, ExecutedRoutedEventArgs args);
    private static void OnCut(object target, ExecutedRoutedEventArgs args);
    private static bool CopySelectedText(TextArea textArea);
    public static bool ConfirmDataFormat(TextArea textArea, DataObject dataObject, string format);
    private static bool CopyWholeLine(TextArea textArea, DocumentLine line);
    private static void CanPaste(object target, CanExecuteRoutedEventArgs args);
    private static void OnPaste(object target, ExecutedRoutedEventArgs args);
    internal static string GetTextToPaste(DataObjectPastingEventArgs pastingEventArgs, TextArea textArea);
    private static void OnToggleOverstrike(object target, ExecutedRoutedEventArgs args);
    private static void OnDeleteLine(object target, ExecutedRoutedEventArgs args);
    private static void OnRemoveLeadingWhitespace(object target, ExecutedRoutedEventArgs args);
    private static void OnRemoveTrailingWhitespace(object target, ExecutedRoutedEventArgs args);
    private static void OnConvertTabsToSpaces(object target, ExecutedRoutedEventArgs args);
    private static void OnConvertLeadingTabsToSpaces(object target, ExecutedRoutedEventArgs args);
    private static void ConvertTabsToSpaces(TextArea textArea, ISegment segment);
    private static void OnConvertSpacesToTabs(object target, ExecutedRoutedEventArgs args);
    private static void OnConvertLeadingSpacesToTabs(object target, ExecutedRoutedEventArgs args);
    private static void ConvertSpacesToTabs(TextArea textArea, ISegment segment);
    private static void ConvertCase(Func`2<string, string> transformText, object target, ExecutedRoutedEventArgs args);
    private static void OnConvertToUpperCase(object target, ExecutedRoutedEventArgs args);
    private static void OnConvertToLowerCase(object target, ExecutedRoutedEventArgs args);
    private static void OnConvertToTitleCase(object target, ExecutedRoutedEventArgs args);
    private static void OnInvertCase(object target, ExecutedRoutedEventArgs args);
    private static string InvertCase(string text);
    private static void OnIndentSelection(object target, ExecutedRoutedEventArgs args);
}
internal class ICSharpCode.AvalonEdit.Editing.EmptySelection : Selection {
    public TextViewPosition StartPosition { get; }
    public TextViewPosition EndPosition { get; }
    public ISegment SurroundingSegment { get; }
    public IEnumerable`1<SelectionSegment> Segments { get; }
    public int Length { get; }
    public EmptySelection(TextArea textArea);
    public virtual Selection UpdateOnDocumentChange(DocumentChangeEventArgs e);
    public virtual TextViewPosition get_StartPosition();
    public virtual TextViewPosition get_EndPosition();
    public virtual ISegment get_SurroundingSegment();
    public virtual Selection SetEndpoint(TextViewPosition endPosition);
    public virtual Selection StartSelectionOrSetEndpoint(TextViewPosition startPosition, TextViewPosition endPosition);
    public virtual IEnumerable`1<SelectionSegment> get_Segments();
    public virtual string GetText();
    public virtual void ReplaceSelectionWithText(string newText);
    public virtual int get_Length();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[ExtensionAttribute]
internal static class ICSharpCode.AvalonEdit.Editing.ImeNativeWrapper : object {
    private static int CPS_CANCEL;
    private static int NI_COMPOSITIONSTR;
    private static int GCS_COMPSTR;
    public static int WM_IME_COMPOSITION;
    public static int WM_IME_SETCONTEXT;
    public static int WM_INPUTLANGCHANGE;
    [ThreadStaticAttribute]
private static bool textFrameworkThreadMgrInitialized;
    [ThreadStaticAttribute]
private static ITfThreadMgr textFrameworkThreadMgr;
    private static Rect EMPTY_RECT;
    private static ImeNativeWrapper();
    public static IntPtr ImmAssociateContext(IntPtr hWnd, IntPtr hIMC);
    internal static IntPtr ImmGetContext(IntPtr hWnd);
    internal static IntPtr ImmGetDefaultIMEWnd(IntPtr hWnd);
    internal static bool ImmReleaseContext(IntPtr hWnd, IntPtr hIMC);
    private static bool ImmNotifyIME(IntPtr hIMC, int dwAction, int dwIndex, int dwValue);
    private static bool ImmSetCompositionWindow(IntPtr hIMC, CompositionForm& form);
    private static bool ImmSetCompositionFont(IntPtr hIMC, LOGFONT& font);
    private static bool ImmGetCompositionFont(IntPtr hIMC, LOGFONT& font);
    private static int TF_CreateThreadMgr(ITfThreadMgr& threadMgr);
    public static ITfThreadMgr GetTextFrameworkThreadManager();
    public static bool NotifyIme(IntPtr hIMC);
    public static bool SetCompositionWindow(HwndSource source, IntPtr hIMC, TextArea textArea);
    public static bool SetCompositionFont(HwndSource source, IntPtr hIMC, TextArea textArea);
    [ExtensionAttribute]
private static Rect GetBounds(TextView textView, HwndSource source);
    [ExtensionAttribute]
private static Rect GetCharacterBounds(TextView textView, TextViewPosition pos, HwndSource source);
}
internal class ICSharpCode.AvalonEdit.Editing.ImeSupport : object {
    private TextArea textArea;
    private IntPtr currentContext;
    private IntPtr previousContext;
    private IntPtr defaultImeWnd;
    private HwndSource hwndSource;
    private EventHandler requerySuggestedHandler;
    private bool isReadOnly;
    public ImeSupport(TextArea textArea);
    private void OnRequerySuggested(object sender, EventArgs e);
    private void TextAreaOptionChanged(object sender, PropertyChangedEventArgs e);
    public void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    private void UpdateImeEnabled();
    private void ClearContext();
    private void CreateContext();
    private IntPtr WndProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public void UpdateCompositionWindow();
}
public interface ICSharpCode.AvalonEdit.Editing.IReadOnlySectionProvider {
    public abstract virtual bool CanInsert(int offset);
    public abstract virtual IEnumerable`1<ISegment> GetDeletableSegments(ISegment segment);
}
public interface ICSharpCode.AvalonEdit.Editing.ITextAreaInputHandler {
    public TextArea TextArea { get; }
    public abstract virtual TextArea get_TextArea();
    public abstract virtual void Attach();
    public abstract virtual void Detach();
}
[GuidAttribute("aa80e801-2021-11d2-93e0-0060b067b86e")]
[InterfaceTypeAttribute("1")]
internal interface ICSharpCode.AvalonEdit.Editing.ITfThreadMgr {
    public abstract virtual void Activate(Int32& clientId);
    public abstract virtual void Deactivate();
    public abstract virtual void CreateDocumentMgr(IntPtr& docMgr);
    public abstract virtual void EnumDocumentMgrs(IntPtr& enumDocMgrs);
    public abstract virtual void GetFocus(IntPtr& docMgr);
    public abstract virtual void SetFocus(IntPtr docMgr);
    public abstract virtual void AssociateFocus(IntPtr hwnd, IntPtr newDocMgr, IntPtr& prevDocMgr);
    public abstract virtual void IsThreadFocus(Boolean& isFocus);
    public abstract virtual void GetFunctionProvider(Guid& classId, IntPtr& funcProvider);
    public abstract virtual void EnumFunctionProviders(IntPtr& enumProviders);
    public abstract virtual void GetGlobalCompartment(IntPtr& compartmentMgr);
}
public class ICSharpCode.AvalonEdit.Editing.LineNumberMargin : AbstractMargin {
    private TextArea textArea;
    protected Typeface typeface;
    protected double emSize;
    protected int maxLineNumberLength;
    private AnchorSegment selectionStart;
    private bool selecting;
    private static LineNumberMargin();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected virtual void OnTextViewChanged(TextView oldTextView, TextView newTextView);
    protected virtual void OnDocumentChanged(TextDocument oldDocument, TextDocument newDocument);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void OnDocumentLineCountChanged();
    private void TextViewVisualLinesChanged(object sender, EventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    private SimpleSegment GetTextLineSegment(MouseEventArgs e);
    private void ExtendSelection(SimpleSegment currentSeg);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
}
public enum ICSharpCode.AvalonEdit.Editing.MouseSelectionMode : Enum {
    public int value__;
    public static MouseSelectionMode None;
    public static MouseSelectionMode PossibleDragStart;
    public static MouseSelectionMode Drag;
    public static MouseSelectionMode Normal;
    public static MouseSelectionMode WholeWord;
    public static MouseSelectionMode WholeLine;
    public static MouseSelectionMode Rectangular;
}
internal class ICSharpCode.AvalonEdit.Editing.NoReadOnlySections : object {
    public static NoReadOnlySections Instance;
    private static NoReadOnlySections();
    public sealed virtual bool CanInsert(int offset);
    public sealed virtual IEnumerable`1<ISegment> GetDeletableSegments(ISegment segment);
}
internal class ICSharpCode.AvalonEdit.Editing.ReadOnlySectionDocument : object {
    public static ReadOnlySectionDocument Instance;
    private static ReadOnlySectionDocument();
    public sealed virtual bool CanInsert(int offset);
    public sealed virtual IEnumerable`1<ISegment> GetDeletableSegments(ISegment segment);
}
public class ICSharpCode.AvalonEdit.Editing.RectangleSelection : Selection {
    public static RoutedUICommand BoxSelectLeftByCharacter;
    public static RoutedUICommand BoxSelectRightByCharacter;
    public static RoutedUICommand BoxSelectLeftByWord;
    public static RoutedUICommand BoxSelectRightByWord;
    public static RoutedUICommand BoxSelectUpByLine;
    public static RoutedUICommand BoxSelectDownByLine;
    public static RoutedUICommand BoxSelectToLineStart;
    public static RoutedUICommand BoxSelectToLineEnd;
    private TextDocument document;
    private int startLine;
    private int endLine;
    private double startXPos;
    private double endXPos;
    private int topLeftOffset;
    private int bottomRightOffset;
    private TextViewPosition start;
    private TextViewPosition end;
    private List`1<SelectionSegment> segments;
    public static string RectangularSelectionDataType;
    public int Length { get; }
    public bool EnableVirtualSpace { get; }
    public ISegment SurroundingSegment { get; }
    public IEnumerable`1<SelectionSegment> Segments { get; }
    public TextViewPosition StartPosition { get; }
    public TextViewPosition EndPosition { get; }
    public RectangleSelection(TextArea textArea, TextViewPosition start, TextViewPosition end);
    private RectangleSelection(TextArea textArea, int startLine, double startXPos, TextViewPosition end);
    private RectangleSelection(TextArea textArea, TextViewPosition start, int endLine, double endXPos);
    private static RectangleSelection();
    private static RoutedUICommand Command(string name);
    private void InitDocument();
    private static double GetXPos(TextArea textArea, TextViewPosition pos);
    private void CalculateSegments();
    private TextViewPosition GetStart();
    private TextViewPosition GetEnd();
    public virtual string GetText();
    public virtual Selection StartSelectionOrSetEndpoint(TextViewPosition startPosition, TextViewPosition endPosition);
    public virtual int get_Length();
    public virtual bool get_EnableVirtualSpace();
    public virtual ISegment get_SurroundingSegment();
    public virtual IEnumerable`1<SelectionSegment> get_Segments();
    public virtual TextViewPosition get_StartPosition();
    public virtual TextViewPosition get_EndPosition();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Selection SetEndpoint(TextViewPosition endPosition);
    private int GetVisualColumnFromXPos(int line, double xPos);
    public virtual Selection UpdateOnDocumentChange(DocumentChangeEventArgs e);
    public virtual void ReplaceSelectionWithText(string newText);
    private void ReplaceSingleLineText(TextArea textArea, SelectionSegment lineSegment, string newText, Int32& insertionLength);
    public static bool PerformRectangularPaste(TextArea textArea, TextViewPosition startPosition, string text, bool selectInsertedText);
    public virtual DataObject CreateDataObject(TextArea textArea);
    public virtual string ToString();
}
public abstract class ICSharpCode.AvalonEdit.Editing.Selection : object {
    internal TextArea textArea;
    public TextViewPosition StartPosition { get; }
    public TextViewPosition EndPosition { get; }
    public IEnumerable`1<SelectionSegment> Segments { get; }
    public ISegment SurroundingSegment { get; }
    public bool IsEmpty { get; }
    public bool EnableVirtualSpace { get; }
    public int Length { get; }
    public bool IsMultiline { get; }
    protected Selection(TextArea textArea);
    public static Selection Create(TextArea textArea, int startOffset, int endOffset);
    internal static Selection Create(TextArea textArea, TextViewPosition start, TextViewPosition end);
    public static Selection Create(TextArea textArea, ISegment segment);
    public abstract virtual TextViewPosition get_StartPosition();
    public abstract virtual TextViewPosition get_EndPosition();
    public abstract virtual IEnumerable`1<SelectionSegment> get_Segments();
    public abstract virtual ISegment get_SurroundingSegment();
    public abstract virtual void ReplaceSelectionWithText(string newText);
    internal string AddSpacesIfRequired(string newText, TextViewPosition start, TextViewPosition end);
    private bool InsertVirtualSpaces(string newText, TextViewPosition start, TextViewPosition end);
    private bool IsInVirtualSpace(TextViewPosition pos);
    public abstract virtual Selection UpdateOnDocumentChange(DocumentChangeEventArgs e);
    public virtual bool get_IsEmpty();
    public virtual bool get_EnableVirtualSpace();
    public abstract virtual int get_Length();
    public abstract virtual Selection SetEndpoint(TextViewPosition endPosition);
    public abstract virtual Selection StartSelectionOrSetEndpoint(TextViewPosition startPosition, TextViewPosition endPosition);
    public virtual bool get_IsMultiline();
    public virtual string GetText();
    public string CreateHtmlFragment(HtmlOptions options);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public virtual bool Contains(int offset);
    public virtual DataObject CreateDataObject(TextArea textArea);
}
internal class ICSharpCode.AvalonEdit.Editing.SelectionColorizer : ColorizingTransformer {
    private TextArea textArea;
    public SelectionColorizer(TextArea textArea);
    protected virtual void Colorize(ITextRunConstructionContext context);
    [CompilerGeneratedAttribute]
private void <Colorize>b__2_0(VisualLineElement element);
}
internal class ICSharpCode.AvalonEdit.Editing.SelectionLayer : Layer {
    private TextArea textArea;
    public SelectionLayer(TextArea textArea);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual void OnRender(DrawingContext drawingContext);
}
internal class ICSharpCode.AvalonEdit.Editing.SelectionMouseHandler : object {
    private TextArea textArea;
    private MouseSelectionMode mode;
    private AnchorSegment startWord;
    private Point possibleDragStartMousePos;
    private bool enableTextDragDrop;
    private object currentDragDescriptor;
    private TextArea ICSharpCode.AvalonEdit.Editing.ITextAreaInputHandler.TextArea { get; }
    public MouseSelectionMode MouseSelectionMode { get; public set; }
    internal SelectionMouseHandler(TextArea textArea);
    private static SelectionMouseHandler();
    private static void OnLostMouseCapture(object sender, MouseEventArgs e);
    private sealed virtual override TextArea ICSharpCode.AvalonEdit.Editing.ITextAreaInputHandler.get_TextArea();
    private sealed virtual override void ICSharpCode.AvalonEdit.Editing.ITextAreaInputHandler.Attach();
    private sealed virtual override void ICSharpCode.AvalonEdit.Editing.ITextAreaInputHandler.Detach();
    private void AttachDragDrop();
    private void DetachDragDrop();
    private void textArea_OptionChanged(object sender, PropertyChangedEventArgs e);
    private void textArea_DocumentChanged(object sender, EventArgs e);
    private void textArea_DragEnter(object sender, DragEventArgs e);
    private void textArea_DragOver(object sender, DragEventArgs e);
    private DragDropEffects GetEffect(DragEventArgs e);
    private void textArea_DragLeave(object sender, DragEventArgs e);
    private void textArea_Drop(object sender, DragEventArgs e);
    private void OnDragException(Exception ex);
    private void textArea_GiveFeedback(object sender, GiveFeedbackEventArgs e);
    private void textArea_QueryContinueDrag(object sender, QueryContinueDragEventArgs e);
    private void StartDrag();
    private void textArea_QueryCursor(object sender, QueryCursorEventArgs e);
    private void textArea_MouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    public MouseSelectionMode get_MouseSelectionMode();
    public void set_MouseSelectionMode(MouseSelectionMode value);
    private SimpleSegment GetWordAtMousePosition(MouseEventArgs e);
    private SimpleSegment GetLineAtMousePosition(MouseEventArgs e);
    private int GetOffsetFromMousePosition(MouseEventArgs e, Int32& visualColumn, Boolean& isAtEndOfLine);
    private int GetOffsetFromMousePosition(Point positionRelativeToTextView, Int32& visualColumn, Boolean& isAtEndOfLine);
    private int GetOffsetFromMousePositionFirstTextLineOnly(Point positionRelativeToTextView, Int32& visualColumn);
    private void textArea_MouseMove(object sender, MouseEventArgs e);
    private void SetCaretOffsetToMousePosition(MouseEventArgs e);
    private void SetCaretOffsetToMousePosition(MouseEventArgs e, ISegment allowedSegment);
    private void ExtendSelectionToMouse(MouseEventArgs e);
    private void textArea_MouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    [CompilerGeneratedAttribute]
private AnchorSegment <StartDrag>b__25_0(SelectionSegment s);
}
public class ICSharpCode.AvalonEdit.Editing.SelectionSegment : object {
    private int startOffset;
    private int endOffset;
    private int startVC;
    private int endVC;
    public int StartOffset { get; }
    public int EndOffset { get; }
    public int StartVisualColumn { get; }
    public int EndVisualColumn { get; }
    private int ICSharpCode.AvalonEdit.Document.ISegment.Offset { get; }
    public int Length { get; }
    public SelectionSegment(int startOffset, int endOffset);
    public SelectionSegment(int startOffset, int startVC, int endOffset, int endVC);
    public int get_StartOffset();
    public sealed virtual int get_EndOffset();
    public int get_StartVisualColumn();
    public int get_EndVisualColumn();
    private sealed virtual override int ICSharpCode.AvalonEdit.Document.ISegment.get_Offset();
    public sealed virtual int get_Length();
    public virtual string ToString();
}
internal class ICSharpCode.AvalonEdit.Editing.SimpleSelection : Selection {
    private TextViewPosition start;
    private TextViewPosition end;
    private int startOffset;
    private int endOffset;
    public IEnumerable`1<SelectionSegment> Segments { get; }
    public ISegment SurroundingSegment { get; }
    public TextViewPosition StartPosition { get; }
    public TextViewPosition EndPosition { get; }
    public bool IsEmpty { get; }
    public int Length { get; }
    internal SimpleSelection(TextArea textArea, TextViewPosition start, TextViewPosition end);
    public virtual IEnumerable`1<SelectionSegment> get_Segments();
    public virtual ISegment get_SurroundingSegment();
    public virtual void ReplaceSelectionWithText(string newText);
    public virtual TextViewPosition get_StartPosition();
    public virtual TextViewPosition get_EndPosition();
    public virtual Selection UpdateOnDocumentChange(DocumentChangeEventArgs e);
    public virtual bool get_IsEmpty();
    public virtual int get_Length();
    public virtual Selection SetEndpoint(TextViewPosition endPosition);
    public virtual Selection StartSelectionOrSetEndpoint(TextViewPosition startPosition, TextViewPosition endPosition);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class ICSharpCode.AvalonEdit.Editing.TextArea : Control {
    internal ImeSupport ime;
    [CompilerGeneratedAttribute]
private TextAreaDefaultInputHandler <DefaultInputHandler>k__BackingField;
    private ITextAreaInputHandler activeInputHandler;
    private bool isChangingInputHandler;
    [CompilerGeneratedAttribute]
private EventHandler ActiveInputHandlerChanged;
    private ImmutableStack`1<TextAreaStackedInputHandler> stackedInputHandlers;
    public static DependencyProperty DocumentProperty;
    [CompilerGeneratedAttribute]
private EventHandler DocumentChanged;
    public static DependencyProperty OptionsProperty;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler OptionChanged;
    private TextView textView;
    private IScrollInfo scrollInfo;
    internal Selection emptySelection;
    private Selection selection;
    [CompilerGeneratedAttribute]
private EventHandler SelectionChanged;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionForegroundProperty;
    public static DependencyProperty SelectionBorderProperty;
    public static DependencyProperty SelectionCornerRadiusProperty;
    private bool ensureSelectionValidRequested;
    private int allowCaretOutsideSelection;
    private Caret caret;
    private ObservableCollection`1<UIElement> leftMargins;
    private IReadOnlySectionProvider readOnlySectionProvider;
    private ScrollViewer scrollOwner;
    private bool canVerticallyScroll;
    private bool canHorizontallyScroll;
    [CompilerGeneratedAttribute]
private TextCompositionEventHandler TextEntering;
    [CompilerGeneratedAttribute]
private TextCompositionEventHandler TextEntered;
    public static DependencyProperty IndentationStrategyProperty;
    private bool isMouseCursorHidden;
    public static DependencyProperty OverstrikeModeProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<TextEventArgs> TextCopied;
    public TextAreaDefaultInputHandler DefaultInputHandler { get; private set; }
    public ITextAreaInputHandler ActiveInputHandler { get; public set; }
    public ImmutableStack`1<TextAreaStackedInputHandler> StackedInputHandlers { get; }
    public TextDocument Document { get; public set; }
    public TextEditorOptions Options { get; public set; }
    public TextView TextView { get; }
    public Selection Selection { get; public set; }
    public Brush SelectionBrush { get; public set; }
    public Brush SelectionForeground { get; public set; }
    public Pen SelectionBorder { get; public set; }
    public double SelectionCornerRadius { get; public set; }
    public MouseSelectionMode MouseSelectionMode { get; public set; }
    public Caret Caret { get; }
    public ObservableCollection`1<UIElement> LeftMargins { get; }
    public IReadOnlySectionProvider ReadOnlySectionProvider { get; public set; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanVerticallyScroll { get; private set; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanHorizontallyScroll { get; private set; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.VerticalOffset { get; }
    private ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.ScrollOwner { get; private set; }
    public IIndentationStrategy IndentationStrategy { get; public set; }
    public bool OverstrikeMode { get; public set; }
    private static TextArea();
    protected TextArea(TextView textView);
    [CompilerGeneratedAttribute]
public TextAreaDefaultInputHandler get_DefaultInputHandler();
    [CompilerGeneratedAttribute]
private void set_DefaultInputHandler(TextAreaDefaultInputHandler value);
    public ITextAreaInputHandler get_ActiveInputHandler();
    public void set_ActiveInputHandler(ITextAreaInputHandler value);
    [CompilerGeneratedAttribute]
public void add_ActiveInputHandlerChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ActiveInputHandlerChanged(EventHandler value);
    public ImmutableStack`1<TextAreaStackedInputHandler> get_StackedInputHandlers();
    public void PushStackedInputHandler(TextAreaStackedInputHandler inputHandler);
    public void PopStackedInputHandler(TextAreaStackedInputHandler inputHandler);
    public sealed virtual TextDocument get_Document();
    public void set_Document(TextDocument value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DocumentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DocumentChanged(EventHandler value);
    private static void OnDocumentChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e);
    private void OnDocumentChanged(TextDocument oldValue, TextDocument newValue);
    public sealed virtual TextEditorOptions get_Options();
    public void set_Options(TextEditorOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OptionChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OptionChanged(PropertyChangedEventHandler value);
    protected virtual void OnOptionChanged(PropertyChangedEventArgs e);
    private static void OnOptionsChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e);
    private void OnOptionsChanged(TextEditorOptions oldValue, TextEditorOptions newValue);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void OnDocumentChanging();
    private void OnDocumentChanged(DocumentChangeEventArgs e);
    private void OnUpdateStarted();
    private void OnUpdateFinished();
    public TextView get_TextView();
    public virtual void OnApplyTemplate();
    [CompilerGeneratedAttribute]
public void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanged(EventHandler value);
    public Selection get_Selection();
    public void set_Selection(Selection value);
    public void ClearSelection();
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public Brush get_SelectionForeground();
    public void set_SelectionForeground(Brush value);
    public Pen get_SelectionBorder();
    public void set_SelectionBorder(Pen value);
    public double get_SelectionCornerRadius();
    public void set_SelectionCornerRadius(double value);
    public MouseSelectionMode get_MouseSelectionMode();
    public void set_MouseSelectionMode(MouseSelectionMode value);
    private void RequestSelectionValidation();
    private void EnsureSelectionValid();
    public IDisposable AllowCaretOutsideSelection();
    public Caret get_Caret();
    private void CaretPositionChanged(object sender, EventArgs e);
    public ObservableCollection`1<UIElement> get_LeftMargins();
    private void leftMargins_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    public IReadOnlySectionProvider get_ReadOnlySectionProvider();
    public void set_ReadOnlySectionProvider(IReadOnlySectionProvider value);
    private void ApplyScrollInfo();
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanVerticallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanVerticallyScroll(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanHorizontallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanHorizontallyScroll(bool value);
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_HorizontalOffset();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_VerticalOffset();
    private sealed virtual override ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.get_ScrollOwner();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_ScrollOwner(ScrollViewer value);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(double offset);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetVerticalOffset(double offset);
    private sealed virtual override Rect System.Windows.Controls.Primitives.IScrollInfo.MakeVisible(Visual visual, Rect rectangle);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_TextEntering(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TextEntering(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_TextEntered(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TextEntered(TextCompositionEventHandler value);
    protected virtual void OnTextEntering(TextCompositionEventArgs e);
    protected virtual void OnTextEntered(TextCompositionEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    public void PerformTextInput(string text);
    public void PerformTextInput(TextCompositionEventArgs e);
    private void ReplaceSelectionWithNewLine();
    internal void RemoveSelectedText();
    internal void ReplaceSelectionWithText(string newText);
    internal ISegment[] GetDeletableSegments(ISegment segment);
    public IIndentationStrategy get_IndentationStrategy();
    public void set_IndentationStrategy(IIndentationStrategy value);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnPreviewKeyUp(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    private void AttachTypingEvents();
    private void ShowMouseCursor();
    private void HideMouseCursor();
    public bool get_OverstrikeMode();
    public void set_OverstrikeMode(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    public virtual object GetService(Type serviceType);
    [CompilerGeneratedAttribute]
public void add_TextCopied(EventHandler`1<TextEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TextCopied(EventHandler`1<TextEventArgs> value);
    internal void OnTextCopied(TextEventArgs e);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
private void <AllowCaretOutsideSelection>b__84_0();
    [CompilerGeneratedAttribute]
private void <AttachTypingEvents>b__164_0(object <p0>, MouseEventArgs <p1>);
    [CompilerGeneratedAttribute]
private void <AttachTypingEvents>b__164_1(object <p0>, MouseEventArgs <p1>);
    [CompilerGeneratedAttribute]
private void <AttachTypingEvents>b__164_2(object <p0>, MouseEventArgs <p1>);
    [CompilerGeneratedAttribute]
private void <AttachTypingEvents>b__164_3(object <p0>, TouchEventArgs <p1>);
    [CompilerGeneratedAttribute]
private void <AttachTypingEvents>b__164_4(object <p0>, TouchEventArgs <p1>);
    [CompilerGeneratedAttribute]
private void <AttachTypingEvents>b__164_5(object <p0>, TouchEventArgs <p1>);
}
internal class ICSharpCode.AvalonEdit.Editing.TextAreaAutomationPeer : FrameworkElementAutomationPeer {
    private TextArea TextArea { get; }
    internal IRawElementProviderSimple Provider { get; }
    public bool IsReadOnly { get; }
    public string Value { get; }
    public ITextRangeProvider DocumentRange { get; }
    public SupportedTextSelection SupportedTextSelection { get; }
    public TextAreaAutomationPeer(TextArea owner);
    private void OnSelectionChanged(object sender, EventArgs e);
    private TextArea get_TextArea();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    internal IRawElementProviderSimple get_Provider();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void SetValue(string value);
    public sealed virtual string get_Value();
    public sealed virtual ITextRangeProvider get_DocumentRange();
    public sealed virtual ITextRangeProvider[] GetSelection();
    public sealed virtual ITextRangeProvider[] GetVisibleRanges();
    public sealed virtual ITextRangeProvider RangeFromChild(IRawElementProviderSimple childElement);
    public sealed virtual ITextRangeProvider RangeFromPoint(Point screenLocation);
    public sealed virtual SupportedTextSelection get_SupportedTextSelection();
    public virtual object GetPattern(PatternInterface patternInterface);
    [CompilerGeneratedAttribute]
private TextRangeProvider <GetSelection>b__14_0(SelectionSegment s);
}
public class ICSharpCode.AvalonEdit.Editing.TextAreaDefaultInputHandler : TextAreaInputHandler {
    [CompilerGeneratedAttribute]
private TextAreaInputHandler <CaretNavigation>k__BackingField;
    [CompilerGeneratedAttribute]
private TextAreaInputHandler <Editing>k__BackingField;
    [CompilerGeneratedAttribute]
private ITextAreaInputHandler <MouseSelection>k__BackingField;
    public TextAreaInputHandler CaretNavigation { get; private set; }
    public TextAreaInputHandler Editing { get; private set; }
    public ITextAreaInputHandler MouseSelection { get; private set; }
    public TextAreaDefaultInputHandler(TextArea textArea);
    [CompilerGeneratedAttribute]
public TextAreaInputHandler get_CaretNavigation();
    [CompilerGeneratedAttribute]
private void set_CaretNavigation(TextAreaInputHandler value);
    [CompilerGeneratedAttribute]
public TextAreaInputHandler get_Editing();
    [CompilerGeneratedAttribute]
private void set_Editing(TextAreaInputHandler value);
    [CompilerGeneratedAttribute]
public ITextAreaInputHandler get_MouseSelection();
    [CompilerGeneratedAttribute]
private void set_MouseSelection(ITextAreaInputHandler value);
    internal static KeyBinding CreateFrozenKeyBinding(ICommand command, ModifierKeys modifiers, Key key);
    internal static void WorkaroundWPFMemoryLeak(List`1<InputBinding> inputBindings);
    private UndoStack GetUndoStack();
    private void ExecuteUndo(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteUndo(object sender, CanExecuteRoutedEventArgs e);
    private void ExecuteRedo(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteRedo(object sender, CanExecuteRoutedEventArgs e);
}
public class ICSharpCode.AvalonEdit.Editing.TextAreaInputHandler : object {
    private ObserveAddRemoveCollection`1<CommandBinding> commandBindings;
    private ObserveAddRemoveCollection`1<InputBinding> inputBindings;
    private ObserveAddRemoveCollection`1<ITextAreaInputHandler> nestedInputHandlers;
    private TextArea textArea;
    private bool isAttached;
    public TextArea TextArea { get; }
    public bool IsAttached { get; }
    public ICollection`1<CommandBinding> CommandBindings { get; }
    public ICollection`1<InputBinding> InputBindings { get; }
    public ICollection`1<ITextAreaInputHandler> NestedInputHandlers { get; }
    public TextAreaInputHandler(TextArea textArea);
    public sealed virtual TextArea get_TextArea();
    public bool get_IsAttached();
    public ICollection`1<CommandBinding> get_CommandBindings();
    private void CommandBinding_Added(CommandBinding commandBinding);
    private void CommandBinding_Removed(CommandBinding commandBinding);
    public ICollection`1<InputBinding> get_InputBindings();
    private void InputBinding_Added(InputBinding inputBinding);
    private void InputBinding_Removed(InputBinding inputBinding);
    public void AddBinding(ICommand command, ModifierKeys modifiers, Key key, ExecutedRoutedEventHandler handler);
    public ICollection`1<ITextAreaInputHandler> get_NestedInputHandlers();
    private void NestedInputHandler_Added(ITextAreaInputHandler handler);
    private void NestedInputHandler_Removed(ITextAreaInputHandler handler);
    public virtual void Attach();
    public virtual void Detach();
}
public abstract class ICSharpCode.AvalonEdit.Editing.TextAreaStackedInputHandler : object {
    private TextArea textArea;
    public TextArea TextArea { get; }
    protected TextAreaStackedInputHandler(TextArea textArea);
    public sealed virtual TextArea get_TextArea();
    public virtual void Attach();
    public virtual void Detach();
    public virtual void OnPreviewKeyDown(KeyEventArgs e);
    public virtual void OnPreviewKeyUp(KeyEventArgs e);
}
public class ICSharpCode.AvalonEdit.Editing.TextEventArgs : EventArgs {
    private string text;
    public string Text { get; }
    public TextEventArgs(string text);
    public string get_Text();
}
internal class ICSharpCode.AvalonEdit.Editing.TextRangeProvider : object {
    private TextArea textArea;
    private TextDocument doc;
    private ISegment segment;
    private string ID { get; }
    public TextRangeProvider(TextArea textArea, TextDocument doc, ISegment segment);
    public TextRangeProvider(TextArea textArea, TextDocument doc, int offset, int length);
    private string get_ID();
    [ConditionalAttribute("DEBUG")]
private static void Log(string format, Object[] args);
    public sealed virtual void AddToSelection();
    public sealed virtual ITextRangeProvider Clone();
    public sealed virtual bool Compare(ITextRangeProvider range);
    private int GetEndpoint(TextPatternRangeEndpoint endpoint);
    public sealed virtual int CompareEndpoints(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    public sealed virtual void ExpandToEnclosingUnit(TextUnit unit);
    private void ExpandToEnclosingUnit(CaretPositioningMode mode);
    public sealed virtual ITextRangeProvider FindAttribute(int attribute, object value, bool backward);
    public sealed virtual ITextRangeProvider FindText(string text, bool backward, bool ignoreCase);
    public sealed virtual object GetAttributeValue(int attribute);
    public sealed virtual Double[] GetBoundingRectangles();
    public sealed virtual IRawElementProviderSimple[] GetChildren();
    public sealed virtual IRawElementProviderSimple GetEnclosingElement();
    public sealed virtual string GetText(int maxLength);
    public sealed virtual int Move(TextUnit unit, int count);
    public sealed virtual void MoveEndpointByRange(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    private void SetEndpoint(TextPatternRangeEndpoint endpoint, int targetOffset);
    public sealed virtual int MoveEndpointByUnit(TextPatternRangeEndpoint endpoint, TextUnit unit, int count);
    private int MoveOffset(int offset, CaretPositioningMode mode, int count);
    public sealed virtual void RemoveFromSelection();
    public sealed virtual void ScrollIntoView(bool alignToTop);
    public sealed virtual void Select();
}
public class ICSharpCode.AvalonEdit.Editing.TextSegmentReadOnlySectionProvider`1 : object {
    private TextSegmentCollection`1<T> segments;
    public TextSegmentCollection`1<T> Segments { get; }
    public TextSegmentReadOnlySectionProvider`1(TextDocument textDocument);
    public TextSegmentReadOnlySectionProvider`1(TextSegmentCollection`1<T> segments);
    public TextSegmentCollection`1<T> get_Segments();
    public virtual bool CanInsert(int offset);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Editing.TextSegmentReadOnlySectionProvider`1/<GetDeletableSegments>d__6")]
public virtual IEnumerable`1<ISegment> GetDeletableSegments(ISegment segment);
}
public class ICSharpCode.AvalonEdit.Folding.FoldingElementGenerator : VisualLineElementGenerator {
    private List`1<TextView> textViews;
    private FoldingManager foldingManager;
    public static Brush DefaultTextBrush;
    private static Brush textBrush;
    public FoldingManager FoldingManager { get; public set; }
    public static Brush TextBrush { get; public set; }
    private static FoldingElementGenerator();
    public FoldingManager get_FoldingManager();
    public void set_FoldingManager(FoldingManager value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Rendering.ITextViewConnect.AddToTextView(TextView textView);
    private sealed virtual override void ICSharpCode.AvalonEdit.Rendering.ITextViewConnect.RemoveFromTextView(TextView textView);
    public virtual void StartGeneration(ITextRunConstructionContext context);
    public virtual int GetFirstInterestedOffset(int startOffset);
    public virtual VisualLineElement ConstructElement(int offset);
    public static Brush get_TextBrush();
    public static void set_TextBrush(Brush value);
}
public class ICSharpCode.AvalonEdit.Folding.FoldingManager : object {
    internal TextDocument document;
    internal List`1<TextView> textViews;
    private TextSegmentCollection`1<FoldingSection> foldings;
    private bool isFirstUpdate;
    public IEnumerable`1<FoldingSection> AllFoldings { get; }
    public FoldingManager(TextDocument document);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void OnDocumentChanged(DocumentChangeEventArgs e);
    internal void AddToTextView(TextView textView);
    internal void RemoveFromTextView(TextView textView);
    internal void Redraw();
    internal void Redraw(FoldingSection fs);
    public FoldingSection CreateFolding(int startOffset, int endOffset);
    public void RemoveFolding(FoldingSection fs);
    public void Clear();
    public IEnumerable`1<FoldingSection> get_AllFoldings();
    public int GetNextFoldedFoldingStart(int startOffset);
    public FoldingSection GetNextFolding(int startOffset);
    public ReadOnlyCollection`1<FoldingSection> GetFoldingsAt(int startOffset);
    public ReadOnlyCollection`1<FoldingSection> GetFoldingsContaining(int offset);
    public void UpdateFoldings(IEnumerable`1<NewFolding> newFoldings, int firstErrorOffset);
    public static FoldingManager Install(TextArea textArea);
    public static void Uninstall(FoldingManager manager);
}
public class ICSharpCode.AvalonEdit.Folding.FoldingMargin : AbstractMargin {
    [CompilerGeneratedAttribute]
private FoldingManager <FoldingManager>k__BackingField;
    internal static double SizeFactor;
    public static DependencyProperty FoldingMarkerBrushProperty;
    public static DependencyProperty FoldingMarkerBackgroundBrushProperty;
    public static DependencyProperty SelectedFoldingMarkerBrushProperty;
    public static DependencyProperty SelectedFoldingMarkerBackgroundBrushProperty;
    private List`1<FoldingMarginMarker> markers;
    private Pen foldingControlPen;
    private Pen selectedFoldingControlPen;
    public FoldingManager FoldingManager { get; public set; }
    public Brush FoldingMarkerBrush { get; public set; }
    public Brush FoldingMarkerBackgroundBrush { get; public set; }
    public Brush SelectedFoldingMarkerBrush { get; public set; }
    public Brush SelectedFoldingMarkerBackgroundBrush { get; public set; }
    protected int VisualChildrenCount { get; }
    private static FoldingMargin();
    [CompilerGeneratedAttribute]
public FoldingManager get_FoldingManager();
    [CompilerGeneratedAttribute]
public void set_FoldingManager(FoldingManager value);
    public static Brush GetFoldingMarkerBrush(DependencyObject obj);
    public static void SetFoldingMarkerBrush(DependencyObject obj, Brush value);
    public Brush get_FoldingMarkerBrush();
    public void set_FoldingMarkerBrush(Brush value);
    public static Brush GetFoldingMarkerBackgroundBrush(DependencyObject obj);
    public static void SetFoldingMarkerBackgroundBrush(DependencyObject obj, Brush value);
    public Brush get_FoldingMarkerBackgroundBrush();
    public void set_FoldingMarkerBackgroundBrush(Brush value);
    public static Brush GetSelectedFoldingMarkerBrush(DependencyObject obj);
    public static void SetSelectedFoldingMarkerBrush(DependencyObject obj, Brush value);
    public Brush get_SelectedFoldingMarkerBrush();
    public void set_SelectedFoldingMarkerBrush(Brush value);
    public static Brush GetSelectedFoldingMarkerBackgroundBrush(DependencyObject obj);
    public static void SetSelectedFoldingMarkerBackgroundBrush(DependencyObject obj, Brush value);
    public Brush get_SelectedFoldingMarkerBackgroundBrush();
    public void set_SelectedFoldingMarkerBackgroundBrush(Brush value);
    private static void OnUpdateBrushes(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnTextViewChanged(TextView oldTextView, TextView newTextView);
    private void TextViewVisualLinesChanged(object sender, EventArgs e);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    private static Pen MakeFrozenPen(Brush brush);
    protected virtual void OnRender(DrawingContext drawingContext);
    private void CalculateFoldLinesForFoldingsActiveAtStart(List`1<TextLine> allTextLines, Pen[] colors, Pen[] endMarker);
    private void CalculateFoldLinesForMarkers(List`1<TextLine> allTextLines, Pen[] colors, Pen[] endMarker);
    private void DrawFoldLines(DrawingContext drawingContext, Pen[] colors, Pen[] endMarker);
    private double GetVisualPos(VisualLine vl, TextLine tl, double pixelHeight);
    private int GetTextLineIndexFromOffset(List`1<TextLine> textLines, int offset);
    [CompilerGeneratedAttribute]
private void <TextViewVisualLinesChanged>b__34_0(object <p0>, DependencyPropertyChangedEventArgs <p1>);
}
internal class ICSharpCode.AvalonEdit.Folding.FoldingMarginMarker : UIElement {
    internal VisualLine VisualLine;
    internal FoldingSection FoldingSection;
    private bool isExpanded;
    private static double MarginSizeFactor;
    public bool IsExpanded { get; public set; }
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual Size MeasureCore(Size availableSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
}
public class ICSharpCode.AvalonEdit.Folding.FoldingSection : TextSegment {
    private FoldingManager manager;
    private bool isFolded;
    internal CollapsedLineSection[] collapsedSections;
    private string title;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    public bool IsFolded { get; public set; }
    public string Title { get; public set; }
    public string TextContent { get; }
    public object Tag { get; public set; }
    internal FoldingSection(FoldingManager manager, int startOffset, int endOffset);
    public bool get_IsFolded();
    public void set_IsFolded(bool value);
    internal void ValidateCollapsedLineSections();
    protected virtual void OnSegmentChanged();
    public string get_Title();
    public void set_Title(string value);
    public string get_TextContent();
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
    private void RemoveCollapsedLineSection();
}
public class ICSharpCode.AvalonEdit.Folding.NewFolding : object {
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefinition>k__BackingField;
    public int StartOffset { get; public set; }
    public int EndOffset { get; public set; }
    public string Name { get; public set; }
    public bool DefaultClosed { get; public set; }
    public bool IsDefinition { get; public set; }
    private int ICSharpCode.AvalonEdit.Document.ISegment.Offset { get; }
    private int ICSharpCode.AvalonEdit.Document.ISegment.Length { get; }
    public NewFolding(int start, int end);
    [CompilerGeneratedAttribute]
public int get_StartOffset();
    [CompilerGeneratedAttribute]
public void set_StartOffset(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndOffset();
    [CompilerGeneratedAttribute]
public void set_EndOffset(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_DefaultClosed();
    [CompilerGeneratedAttribute]
public void set_DefaultClosed(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDefinition();
    [CompilerGeneratedAttribute]
public void set_IsDefinition(bool value);
    private sealed virtual override int ICSharpCode.AvalonEdit.Document.ISegment.get_Offset();
    private sealed virtual override int ICSharpCode.AvalonEdit.Document.ISegment.get_Length();
}
public class ICSharpCode.AvalonEdit.Folding.XmlFoldingStrategy : object {
    [CompilerGeneratedAttribute]
private bool <ShowAttributesWhenFolded>k__BackingField;
    public bool ShowAttributesWhenFolded { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ShowAttributesWhenFolded();
    [CompilerGeneratedAttribute]
public void set_ShowAttributesWhenFolded(bool value);
    public void UpdateFoldings(FoldingManager manager, TextDocument document);
    public IEnumerable`1<NewFolding> CreateNewFoldings(TextDocument document, Int32& firstErrorOffset);
    public IEnumerable`1<NewFolding> CreateNewFoldings(TextDocument document, XmlReader reader, Int32& firstErrorOffset);
    private static int GetOffset(TextDocument document, XmlReader reader);
    private static void CreateCommentFold(TextDocument document, List`1<NewFolding> foldMarkers, XmlReader reader);
    private XmlFoldStart CreateElementFoldStart(TextDocument document, XmlReader reader);
    private static void CreateElementFold(TextDocument document, List`1<NewFolding> foldMarkers, XmlReader reader, XmlFoldStart foldStart);
    private static string GetAttributeFoldText(XmlReader reader);
    private static string XmlEncodeAttributeValue(string attributeValue, char quoteChar);
}
internal class ICSharpCode.AvalonEdit.Folding.XmlFoldStart : NewFolding {
    internal int StartLine;
}
public class ICSharpCode.AvalonEdit.Highlighting.DocumentHighlighter : object {
    private CompressingTreeList`1<ImmutableStack`1<HighlightingSpan>> storedSpanStacks;
    private CompressingTreeList`1<bool> isValid;
    private IDocument document;
    private IHighlightingDefinition definition;
    private HighlightingEngine engine;
    private WeakLineTracker weakLineTracker;
    private bool isHighlighting;
    private bool isInHighlightingGroup;
    private bool isDisposed;
    private ImmutableStack`1<HighlightingSpan> initialSpanStack;
    private int firstInvalidLine;
    [CompilerGeneratedAttribute]
private HighlightingStateChangedEventHandler HighlightingStateChanged;
    public IDocument Document { get; }
    public ImmutableStack`1<HighlightingSpan> InitialSpanStack { get; public set; }
    public HighlightingColor DefaultTextColor { get; }
    public DocumentHighlighter(TextDocument document, IHighlightingDefinition definition);
    public sealed virtual IDocument get_Document();
    public sealed virtual void Dispose();
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.BeforeRemoveLine(DocumentLine line);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.SetLineLength(DocumentLine line, int newTotalLength);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.LineInserted(DocumentLine insertionPos, DocumentLine newLine);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.RebuildDocument();
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.ChangeComplete(DocumentChangeEventArgs e);
    public ImmutableStack`1<HighlightingSpan> get_InitialSpanStack();
    public void set_InitialSpanStack(ImmutableStack`1<HighlightingSpan> value);
    public void InvalidateHighlighting();
    private void InvalidateSpanStacks();
    public sealed virtual HighlightedLine HighlightLine(int lineNumber);
    public ImmutableStack`1<HighlightingSpan> GetSpanStack(int lineNumber);
    public sealed virtual IEnumerable`1<HighlightingColor> GetColorStack(int lineNumber);
    private void CheckIsHighlighting();
    public sealed virtual void UpdateHighlightingState(int lineNumber);
    private void HighlightUpTo(int targetLineNumber);
    private void UpdateTreeList(int lineNumber);
    private static bool EqualSpanStacks(ImmutableStack`1<HighlightingSpan> a, ImmutableStack`1<HighlightingSpan> b);
    [CompilerGeneratedAttribute]
public sealed virtual void add_HighlightingStateChanged(HighlightingStateChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_HighlightingStateChanged(HighlightingStateChangedEventHandler value);
    protected virtual void OnHighlightStateChanged(int fromLineNumber, int toLineNumber);
    public sealed virtual HighlightingColor get_DefaultTextColor();
    public sealed virtual void BeginHighlighting();
    public sealed virtual void EndHighlighting();
    public sealed virtual HighlightingColor GetNamedColor(string name);
}
[ObsoleteAttribute("Use RichText / RichTextModel instead")]
public class ICSharpCode.AvalonEdit.Highlighting.HighlightedInlineBuilder : object {
    private string text;
    private List`1<int> stateChangeOffsets;
    private List`1<HighlightingColor> stateChanges;
    public string Text { get; }
    public HighlightedInlineBuilder(string text);
    public HighlightedInlineBuilder(RichText text);
    private HighlightedInlineBuilder(string text, List`1<int> offsets, List`1<HighlightingColor> states);
    private static HighlightingBrush MakeBrush(Brush b);
    private int GetIndexForOffset(int offset);
    public string get_Text();
    public void SetHighlighting(int offset, int length, HighlightingColor color);
    public void SetForeground(int offset, int length, Brush brush);
    public void SetBackground(int offset, int length, Brush brush);
    public void SetFontWeight(int offset, int length, FontWeight weight);
    public void SetFontStyle(int offset, int length, FontStyle style);
    public Run[] CreateRuns();
    public RichText ToRichText();
    public HighlightedInlineBuilder Clone();
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightedLine : object {
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentLine <DocumentLine>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<HighlightedSection> <Sections>k__BackingField;
    public IDocument Document { get; private set; }
    public IDocumentLine DocumentLine { get; private set; }
    public IList`1<HighlightedSection> Sections { get; private set; }
    public HighlightedLine(IDocument document, IDocumentLine documentLine);
    [CompilerGeneratedAttribute]
public IDocument get_Document();
    [CompilerGeneratedAttribute]
private void set_Document(IDocument value);
    [CompilerGeneratedAttribute]
public IDocumentLine get_DocumentLine();
    [CompilerGeneratedAttribute]
private void set_DocumentLine(IDocumentLine value);
    [CompilerGeneratedAttribute]
public IList`1<HighlightedSection> get_Sections();
    [CompilerGeneratedAttribute]
private void set_Sections(IList`1<HighlightedSection> value);
    public void ValidateInvariants();
    public void MergeWith(HighlightedLine additionalLine);
    private void Insert(Int32& pos, Int32& newSectionStart, int insertionEndPos, HighlightingColor color, Stack`1<int> insertionStack);
    internal void WriteTo(RichTextWriter writer);
    internal void WriteTo(RichTextWriter writer, int startOffset, int endOffset);
    public string ToHtml(HtmlOptions options);
    public string ToHtml(int startOffset, int endOffset, HtmlOptions options);
    public virtual string ToString();
    [ObsoleteAttribute("Use ToRichText() instead")]
public HighlightedInlineBuilder ToInlineBuilder();
    public RichTextModel ToRichTextModel();
    public RichText ToRichText();
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightedSection : object {
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightingColor <Color>k__BackingField;
    public int Offset { get; public set; }
    public int Length { get; public set; }
    private int ICSharpCode.AvalonEdit.Document.ISegment.EndOffset { get; }
    public HighlightingColor Color { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    private sealed virtual override int ICSharpCode.AvalonEdit.Document.ISegment.get_EndOffset();
    [CompilerGeneratedAttribute]
public HighlightingColor get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(HighlightingColor value);
    public virtual string ToString();
}
public abstract class ICSharpCode.AvalonEdit.Highlighting.HighlightingBrush : object {
    public abstract virtual Brush GetBrush(ITextRunConstructionContext context);
    public virtual Nullable`1<Color> GetColor(ITextRunConstructionContext context);
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingColor : object {
    internal static HighlightingColor Empty;
    private string name;
    private FontFamily fontFamily;
    private Nullable`1<int> fontSize;
    private Nullable`1<FontWeight> fontWeight;
    private Nullable`1<FontStyle> fontStyle;
    private Nullable`1<bool> underline;
    private Nullable`1<bool> strikethrough;
    private HighlightingBrush foreground;
    private HighlightingBrush background;
    private bool frozen;
    public string Name { get; public set; }
    public FontFamily FontFamily { get; public set; }
    public Nullable`1<int> FontSize { get; public set; }
    public Nullable`1<FontWeight> FontWeight { get; public set; }
    public Nullable`1<FontStyle> FontStyle { get; public set; }
    public Nullable`1<bool> Underline { get; public set; }
    public Nullable`1<bool> Strikethrough { get; public set; }
    public HighlightingBrush Foreground { get; public set; }
    public HighlightingBrush Background { get; public set; }
    public bool IsFrozen { get; }
    internal bool IsEmptyForMerge { get; }
    protected HighlightingColor(SerializationInfo info, StreamingContext context);
    private static HighlightingColor();
    public string get_Name();
    public void set_Name(string value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public Nullable`1<int> get_FontSize();
    public void set_FontSize(Nullable`1<int> value);
    public Nullable`1<FontWeight> get_FontWeight();
    public void set_FontWeight(Nullable`1<FontWeight> value);
    public Nullable`1<FontStyle> get_FontStyle();
    public void set_FontStyle(Nullable`1<FontStyle> value);
    public Nullable`1<bool> get_Underline();
    public void set_Underline(Nullable`1<bool> value);
    public Nullable`1<bool> get_Strikethrough();
    public void set_Strikethrough(Nullable`1<bool> value);
    public HighlightingBrush get_Foreground();
    public void set_Foreground(HighlightingBrush value);
    public HighlightingBrush get_Background();
    public void set_Background(HighlightingBrush value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToCss();
    public virtual string ToString();
    public virtual void Freeze();
    public sealed virtual bool get_IsFrozen();
    public virtual HighlightingColor Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public sealed virtual bool Equals(object obj);
    public virtual bool Equals(HighlightingColor other);
    public virtual int GetHashCode();
    public void MergeWith(HighlightingColor color);
    internal bool get_IsEmptyForMerge();
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingColorizer : DocumentColorizingTransformer {
    private IHighlightingDefinition definition;
    private TextView textView;
    private IHighlighter highlighter;
    private bool isFixedHighlighter;
    private bool isInHighlightingGroup;
    private DocumentLine lastColorizedLine;
    private int lineNumberBeingColorized;
    public HighlightingColorizer(IHighlightingDefinition definition);
    public HighlightingColorizer(IHighlighter highlighter);
    private void textView_DocumentChanged(object sender, EventArgs e);
    protected virtual void DeregisterServices(TextView textView);
    protected virtual void RegisterServices(TextView textView);
    protected virtual IHighlighter CreateHighlighter(TextView textView, TextDocument document);
    protected virtual void OnAddToTextView(TextView textView);
    protected virtual void OnRemoveFromTextView(TextView textView);
    private void textView_VisualLineConstructionStarting(object sender, VisualLineConstructionStartEventArgs e);
    private void textView_VisualLinesChanged(object sender, EventArgs e);
    protected virtual void Colorize(ITextRunConstructionContext context);
    protected virtual void ColorizeLine(DocumentLine line);
    internal static bool IsEmptyColor(HighlightingColor color);
    protected virtual void ApplyColorToElement(VisualLineElement element, HighlightingColor color);
    internal static void ApplyColorToElement(VisualLineElement element, HighlightingColor color, ITextRunConstructionContext context);
    private void OnHighlightStateChanged(int fromLineNumber, int toLineNumber);
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingDefinitionInvalidException : Exception {
    public HighlightingDefinitionInvalidException(string message);
    public HighlightingDefinitionInvalidException(string message, Exception innerException);
    protected HighlightingDefinitionInvalidException(SerializationInfo info, StreamingContext context);
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingDefinitionTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingEngine : object {
    private HighlightingRuleSet mainRuleSet;
    private ImmutableStack`1<HighlightingSpan> spanStack;
    private string lineText;
    private int lineStartOffset;
    private int position;
    private HighlightedLine highlightedLine;
    private static HighlightingRuleSet emptyRuleSet;
    private Stack`1<HighlightedSection> highlightedSectionStack;
    private HighlightedSection lastPoppedSection;
    public ImmutableStack`1<HighlightingSpan> CurrentSpanStack { get; public set; }
    private HighlightingRuleSet CurrentRuleSet { get; }
    public HighlightingEngine(HighlightingRuleSet mainRuleSet);
    private static HighlightingEngine();
    public ImmutableStack`1<HighlightingSpan> get_CurrentSpanStack();
    public void set_CurrentSpanStack(ImmutableStack`1<HighlightingSpan> value);
    public HighlightedLine HighlightLine(IDocument document, IDocumentLine line);
    public void ScanLine(IDocument document, IDocumentLine line);
    private void HighlightLineInternal();
    private void HighlightNonSpans(int until);
    private HighlightingRuleSet get_CurrentRuleSet();
    private void ResetColorStack();
    private void PushColor(HighlightingColor color);
    private void PopColor();
    private void PopAllColors();
    private static Match Minimum(Match[] arr, Match endSpanMatch);
    private static Match[] AllocateMatchArray(int count);
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingManager : object {
    private object lockObj;
    private Dictionary`2<string, IHighlightingDefinition> highlightingsByName;
    private Dictionary`2<string, IHighlightingDefinition> highlightingsByExtension;
    private List`1<IHighlightingDefinition> allHighlightings;
    public ReadOnlyCollection`1<IHighlightingDefinition> HighlightingDefinitions { get; }
    public static HighlightingManager Instance { get; }
    public sealed virtual IHighlightingDefinition GetDefinition(string name);
    public ReadOnlyCollection`1<IHighlightingDefinition> get_HighlightingDefinitions();
    public IHighlightingDefinition GetDefinitionByExtension(string extension);
    public void RegisterHighlighting(string name, String[] extensions, IHighlightingDefinition highlighting);
    public void RegisterHighlighting(string name, String[] extensions, Func`1<IHighlightingDefinition> lazyLoadedHighlighting);
    public static HighlightingManager get_Instance();
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingRule : object {
    [CompilerGeneratedAttribute]
private Regex <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightingColor <Color>k__BackingField;
    public Regex Regex { get; public set; }
    public HighlightingColor Color { get; public set; }
    [CompilerGeneratedAttribute]
public Regex get_Regex();
    [CompilerGeneratedAttribute]
public void set_Regex(Regex value);
    [CompilerGeneratedAttribute]
public HighlightingColor get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(HighlightingColor value);
    public virtual string ToString();
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingRuleSet : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<HighlightingSpan> <Spans>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<HighlightingRule> <Rules>k__BackingField;
    public string Name { get; public set; }
    public IList`1<HighlightingSpan> Spans { get; private set; }
    public IList`1<HighlightingRule> Rules { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<HighlightingSpan> get_Spans();
    [CompilerGeneratedAttribute]
private void set_Spans(IList`1<HighlightingSpan> value);
    [CompilerGeneratedAttribute]
public IList`1<HighlightingRule> get_Rules();
    [CompilerGeneratedAttribute]
private void set_Rules(IList`1<HighlightingRule> value);
    public virtual string ToString();
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingSpan : object {
    [CompilerGeneratedAttribute]
private Regex <StartExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Regex <EndExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightingRuleSet <RuleSet>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightingColor <StartColor>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightingColor <SpanColor>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightingColor <EndColor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpanColorIncludesStart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpanColorIncludesEnd>k__BackingField;
    public Regex StartExpression { get; public set; }
    public Regex EndExpression { get; public set; }
    public HighlightingRuleSet RuleSet { get; public set; }
    public HighlightingColor StartColor { get; public set; }
    public HighlightingColor SpanColor { get; public set; }
    public HighlightingColor EndColor { get; public set; }
    public bool SpanColorIncludesStart { get; public set; }
    public bool SpanColorIncludesEnd { get; public set; }
    [CompilerGeneratedAttribute]
public Regex get_StartExpression();
    [CompilerGeneratedAttribute]
public void set_StartExpression(Regex value);
    [CompilerGeneratedAttribute]
public Regex get_EndExpression();
    [CompilerGeneratedAttribute]
public void set_EndExpression(Regex value);
    [CompilerGeneratedAttribute]
public HighlightingRuleSet get_RuleSet();
    [CompilerGeneratedAttribute]
public void set_RuleSet(HighlightingRuleSet value);
    [CompilerGeneratedAttribute]
public HighlightingColor get_StartColor();
    [CompilerGeneratedAttribute]
public void set_StartColor(HighlightingColor value);
    [CompilerGeneratedAttribute]
public HighlightingColor get_SpanColor();
    [CompilerGeneratedAttribute]
public void set_SpanColor(HighlightingColor value);
    [CompilerGeneratedAttribute]
public HighlightingColor get_EndColor();
    [CompilerGeneratedAttribute]
public void set_EndColor(HighlightingColor value);
    [CompilerGeneratedAttribute]
public bool get_SpanColorIncludesStart();
    [CompilerGeneratedAttribute]
public void set_SpanColorIncludesStart(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpanColorIncludesEnd();
    [CompilerGeneratedAttribute]
public void set_SpanColorIncludesEnd(bool value);
    public virtual string ToString();
}
public class ICSharpCode.AvalonEdit.Highlighting.HighlightingStateChangedEventHandler : MulticastDelegate {
    public HighlightingStateChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(int fromLineNumber, int toLineNumber);
    public virtual IAsyncResult BeginInvoke(int fromLineNumber, int toLineNumber, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class ICSharpCode.AvalonEdit.Highlighting.HtmlClipboard : object {
    private static string BuildHeader(int startHTML, int endHTML, int startFragment, int endFragment);
    public static void SetHtml(DataObject dataObject, string htmlFragment);
    public static string CreateHtmlFragment(IDocument document, IHighlighter highlighter, ISegment segment, HtmlOptions options);
}
public class ICSharpCode.AvalonEdit.Highlighting.HtmlOptions : object {
    [CompilerGeneratedAttribute]
private int <TabSize>k__BackingField;
    public int TabSize { get; public set; }
    public HtmlOptions(TextEditorOptions options);
    [CompilerGeneratedAttribute]
public int get_TabSize();
    [CompilerGeneratedAttribute]
public void set_TabSize(int value);
    public virtual void WriteStyleAttributeForColor(TextWriter writer, HighlightingColor color);
    public virtual bool ColorNeedsSpanForStyling(HighlightingColor color);
}
internal class ICSharpCode.AvalonEdit.Highlighting.HtmlRichTextWriter : RichTextWriter {
    private TextWriter htmlWriter;
    private HtmlOptions options;
    private Stack`1<string> endTagStack;
    private bool spaceNeedsEscaping;
    private bool hasSpace;
    private bool needIndentation;
    private int indentationLevel;
    private static Char[] specialChars;
    public Encoding Encoding { get; }
    public HtmlRichTextWriter(TextWriter htmlWriter, HtmlOptions options);
    private static HtmlRichTextWriter();
    public virtual Encoding get_Encoding();
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    private void FlushSpace(bool nextIsWhitespace);
    private void WriteIndentation();
    public virtual void Write(char value);
    private void WriteChar(char c);
    public virtual void Write(string value);
    private void WriteIndentationAndSpace();
    private void WriteSimpleString(string value);
    public virtual void Indent();
    public virtual void Unindent();
    protected virtual void BeginUnhandledSpan();
    public virtual void EndSpan();
    public virtual void BeginSpan(Color foregroundColor);
    public virtual void BeginSpan(FontFamily fontFamily);
    public virtual void BeginSpan(FontStyle fontStyle);
    public virtual void BeginSpan(FontWeight fontWeight);
    public virtual void BeginSpan(HighlightingColor highlightingColor);
    public virtual void BeginHyperlinkSpan(Uri uri);
}
public interface ICSharpCode.AvalonEdit.Highlighting.IHighlighter {
    public IDocument Document { get; }
    public HighlightingColor DefaultTextColor { get; }
    public abstract virtual IDocument get_Document();
    public abstract virtual IEnumerable`1<HighlightingColor> GetColorStack(int lineNumber);
    public abstract virtual HighlightedLine HighlightLine(int lineNumber);
    public abstract virtual void UpdateHighlightingState(int lineNumber);
    [CompilerGeneratedAttribute]
public abstract virtual void add_HighlightingStateChanged(HighlightingStateChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HighlightingStateChanged(HighlightingStateChangedEventHandler value);
    public abstract virtual void BeginHighlighting();
    public abstract virtual void EndHighlighting();
    public abstract virtual HighlightingColor GetNamedColor(string name);
    public abstract virtual HighlightingColor get_DefaultTextColor();
}
[TypeConverterAttribute("ICSharpCode.AvalonEdit.Highlighting.HighlightingDefinitionTypeConverter")]
public interface ICSharpCode.AvalonEdit.Highlighting.IHighlightingDefinition {
    public string Name { get; }
    public HighlightingRuleSet MainRuleSet { get; }
    public IEnumerable`1<HighlightingColor> NamedHighlightingColors { get; }
    public IDictionary`2<string, string> Properties { get; }
    public abstract virtual string get_Name();
    public abstract virtual HighlightingRuleSet get_MainRuleSet();
    public abstract virtual HighlightingRuleSet GetNamedRuleSet(string name);
    public abstract virtual HighlightingColor GetNamedColor(string name);
    public abstract virtual IEnumerable`1<HighlightingColor> get_NamedHighlightingColors();
    public abstract virtual IDictionary`2<string, string> get_Properties();
}
public interface ICSharpCode.AvalonEdit.Highlighting.IHighlightingDefinitionReferenceResolver {
    public abstract virtual IHighlightingDefinition GetDefinition(string name);
}
internal static class ICSharpCode.AvalonEdit.Highlighting.Resources : object {
    private static string Prefix;
    private static Resources();
    public static Stream OpenStream(string name);
    internal static void RegisterBuiltInHighlightings(DefaultHighlightingManager hlm);
}
public class ICSharpCode.AvalonEdit.Highlighting.RichText : object {
    public static RichText Empty;
    private string text;
    internal Int32[] stateChangeOffsets;
    internal HighlightingColor[] stateChanges;
    public string Text { get; }
    public int Length { get; }
    public RichText(string text, RichTextModel model);
    internal RichText(string text, Int32[] offsets, HighlightingColor[] states);
    private static RichText();
    public string get_Text();
    public int get_Length();
    private int GetIndexForOffset(int offset);
    private int GetEnd(int index);
    public HighlightingColor GetHighlightingAt(int offset);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Highlighting.RichText/<GetHighlightedSections>d__13")]
public IEnumerable`1<HighlightedSection> GetHighlightedSections(int offset, int length);
    public RichTextModel ToRichTextModel();
    public virtual string ToString();
    public Run[] CreateRuns();
    internal static void ApplyColorToTextElement(TextElement r, HighlightingColor state);
    public string ToHtml(HtmlOptions options);
    public string ToHtml(int offset, int length, HtmlOptions options);
    public RichText Substring(int offset, int length);
    public static RichText Concat(RichText[] texts);
    public static RichText op_Addition(RichText a, RichText b);
    public static RichText op_Implicit(string text);
}
public class ICSharpCode.AvalonEdit.Highlighting.RichTextColorizer : DocumentColorizingTransformer {
    private RichTextModel richTextModel;
    public RichTextColorizer(RichTextModel richTextModel);
    protected virtual void ColorizeLine(DocumentLine line);
}
public class ICSharpCode.AvalonEdit.Highlighting.RichTextModel : object {
    private List`1<int> stateChangeOffsets;
    private List`1<HighlightingColor> stateChanges;
    internal RichTextModel(Int32[] stateChangeOffsets, HighlightingColor[] stateChanges);
    private int GetIndexForOffset(int offset);
    private int GetIndexForOffsetUseExistingSegment(int offset);
    private int GetEnd(int index);
    public void UpdateOffsets(TextChangeEventArgs e);
    public void UpdateOffsets(OffsetChangeMap change);
    public void UpdateOffsets(OffsetChangeMapEntry change);
    private void UpdateOffsets(Func`3<int, AnchorMovementType, int> updateOffset);
    internal void Append(int offset, Int32[] newOffsets, HighlightingColor[] newColors);
    public HighlightingColor GetHighlightingAt(int offset);
    public void ApplyHighlighting(int offset, int length, HighlightingColor color);
    public void SetHighlighting(int offset, int length, HighlightingColor color);
    public void SetForeground(int offset, int length, HighlightingBrush brush);
    public void SetBackground(int offset, int length, HighlightingBrush brush);
    public void SetFontWeight(int offset, int length, FontWeight weight);
    public void SetFontStyle(int offset, int length, FontStyle style);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Highlighting.RichTextModel/<GetHighlightedSections>d__19")]
public IEnumerable`1<HighlightedSection> GetHighlightedSections(int offset, int length);
    public Run[] CreateRuns(ITextSource textSource);
}
internal class ICSharpCode.AvalonEdit.Highlighting.RichTextModelWriter : PlainRichTextWriter {
    private RichTextModel richTextModel;
    private DocumentTextWriter documentTextWriter;
    private Stack`1<HighlightingColor> colorStack;
    private HighlightingColor currentColor;
    private int currentColorBegin;
    public int InsertionOffset { get; public set; }
    public RichTextModelWriter(RichTextModel richTextModel, IDocument document, int insertionOffset);
    public int get_InsertionOffset();
    public void set_InsertionOffset(int value);
    protected virtual void BeginUnhandledSpan();
    private void BeginColorSpan();
    public virtual void EndSpan();
    protected virtual void AfterWrite();
    public virtual void BeginSpan(Color foregroundColor);
    public virtual void BeginSpan(FontFamily fontFamily);
    public virtual void BeginSpan(FontStyle fontStyle);
    public virtual void BeginSpan(FontWeight fontWeight);
    public virtual void BeginSpan(HighlightingColor highlightingColor);
}
public class ICSharpCode.AvalonEdit.Highlighting.SimpleHighlightingBrush : HighlightingBrush {
    private SolidColorBrush brush;
    internal SimpleHighlightingBrush(SolidColorBrush brush);
    public SimpleHighlightingBrush(Color color);
    private SimpleHighlightingBrush(SerializationInfo info, StreamingContext context);
    public virtual Brush GetBrush(ITextRunConstructionContext context);
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class ICSharpCode.AvalonEdit.Highlighting.SystemColorHighlightingBrush : HighlightingBrush {
    private PropertyInfo property;
    public SystemColorHighlightingBrush(PropertyInfo property);
    private SystemColorHighlightingBrush(SerializationInfo info, StreamingContext context);
    public virtual Brush GetBrush(ITextRunConstructionContext context);
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class ICSharpCode.AvalonEdit.Highlighting.Xshd.HighlightingLoader : object {
    public static XshdSyntaxDefinition LoadXshd(XmlReader reader);
    internal static XshdSyntaxDefinition LoadXshd(XmlReader reader, bool skipValidation);
    private static Exception WrapException(Exception ex, int lineNumber, int linePosition);
    internal static string FormatExceptionMessage(string message, int lineNumber, int linePosition);
    internal static XmlReader GetValidatingReader(XmlReader input, bool ignoreWhitespace, XmlSchemaSet schemaSet);
    internal static XmlSchemaSet LoadSchemaSet(XmlReader schemaInput);
    public static IHighlightingDefinition Load(XshdSyntaxDefinition syntaxDefinition, IHighlightingDefinitionReferenceResolver resolver);
    public static IHighlightingDefinition Load(XmlReader reader, IHighlightingDefinitionReferenceResolver resolver);
}
public interface ICSharpCode.AvalonEdit.Highlighting.Xshd.IXshdVisitor {
    public abstract virtual object VisitRuleSet(XshdRuleSet ruleSet);
    public abstract virtual object VisitColor(XshdColor color);
    public abstract virtual object VisitKeywords(XshdKeywords keywords);
    public abstract virtual object VisitSpan(XshdSpan span);
    public abstract virtual object VisitImport(XshdImport import);
    public abstract virtual object VisitRule(XshdRule rule);
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.SaveXshdVisitor : object {
    public static string Namespace;
    private XmlWriter writer;
    public SaveXshdVisitor(XmlWriter writer);
    public void WriteDefinition(XshdSyntaxDefinition definition);
    private sealed virtual override object ICSharpCode.AvalonEdit.Highlighting.Xshd.IXshdVisitor.VisitRuleSet(XshdRuleSet ruleSet);
    private void WriteBoolAttribute(string attributeName, Nullable`1<bool> value);
    private void WriteRuleSetReference(XshdReference`1<XshdRuleSet> ruleSetReference);
    private void WriteColorReference(XshdReference`1<XshdColor> color);
    private void WriteColorAttributes(XshdColor color);
    private sealed virtual override object ICSharpCode.AvalonEdit.Highlighting.Xshd.IXshdVisitor.VisitColor(XshdColor color);
    private sealed virtual override object ICSharpCode.AvalonEdit.Highlighting.Xshd.IXshdVisitor.VisitKeywords(XshdKeywords keywords);
    private sealed virtual override object ICSharpCode.AvalonEdit.Highlighting.Xshd.IXshdVisitor.VisitSpan(XshdSpan span);
    private void WriteBeginEndElement(string elementName, string regex, XshdReference`1<XshdColor> colorReference);
    private sealed virtual override object ICSharpCode.AvalonEdit.Highlighting.Xshd.IXshdVisitor.VisitImport(XshdImport import);
    private sealed virtual override object ICSharpCode.AvalonEdit.Highlighting.Xshd.IXshdVisitor.VisitRule(XshdRule rule);
}
internal class ICSharpCode.AvalonEdit.Highlighting.Xshd.V1Loader : object {
    private static XmlSchemaSet schemaSet;
    private char ruleSetEscapeCharacter;
    private static XmlSchemaSet SchemaSet { get; }
    private static XmlSchemaSet get_SchemaSet();
    public static XshdSyntaxDefinition LoadDefinition(XmlReader reader, bool skipValidation);
    private XshdSyntaxDefinition ParseDefinition(XmlElement syntaxDefinition);
    private static XshdColor GetColorFromElement(XmlElement element);
    private static XshdReference`1<XshdColor> GetColorReference(XmlElement element);
    private static HighlightingBrush ParseColor(string c);
    private XshdRuleSet ImportRuleSet(XmlElement element);
    private static XshdRule ImportMarkPrevNext(XmlElement el, bool markFollowing);
    private XshdSpan ImportSpan(XmlElement element);
    private static string ImportRegex(string expr, bool singleWord, Nullable`1<bool> startOfLine);
}
internal static class ICSharpCode.AvalonEdit.Highlighting.Xshd.V2Loader : object {
    public static string Namespace;
    private static XmlSchemaSet schemaSet;
    internal static ColorConverter ColorConverter;
    internal static FontWeightConverter FontWeightConverter;
    internal static FontStyleConverter FontStyleConverter;
    private static XmlSchemaSet SchemaSet { get; }
    private static V2Loader();
    private static XmlSchemaSet get_SchemaSet();
    public static XshdSyntaxDefinition LoadDefinition(XmlReader reader, bool skipValidation);
    private static XshdSyntaxDefinition ParseDefinition(XmlReader reader);
    private static void ParseElements(ICollection`1<XshdElement> c, XmlReader reader);
    private static XshdElement ParseProperty(XmlReader reader);
    private static XshdRuleSet ParseRuleSet(XmlReader reader);
    private static XshdRule ParseRule(XmlReader reader);
    private static XshdKeywords ParseKeywords(XmlReader reader);
    private static XshdImport ParseImport(XmlReader reader);
    private static XshdSpan ParseSpan(XmlReader reader);
    private static Exception Error(XmlReader reader, string message);
    private static Exception Error(IXmlLineInfo lineInfo, string message);
    private static void SetPosition(XshdElement element, XmlReader reader);
    private static XshdReference`1<XshdRuleSet> ParseRuleSetReference(XmlReader reader);
    private static void CheckElementName(XmlReader reader, string name);
    private static XshdColor ParseNamedColor(XmlReader reader);
    private static XshdReference`1<XshdColor> ParseColorReference(XmlReader reader);
    private static XshdColor ParseColorAttributes(XmlReader reader);
    private static HighlightingBrush ParseColor(IXmlLineInfo lineInfo, string color);
    private static Nullable`1<int> ParseFontSize(IXmlLineInfo lineInfo, string size);
    private static FontFamily ParseFontFamily(IXmlLineInfo lineInfo, string family);
    internal static SystemColorHighlightingBrush GetSystemColorBrush(IXmlLineInfo lineInfo, string name);
    private static HighlightingBrush FixedColorHighlightingBrush(Nullable`1<Color> color);
    private static Nullable`1<FontWeight> ParseFontWeight(string fontWeight);
    private static Nullable`1<FontStyle> ParseFontStyle(string fontStyle);
}
internal class ICSharpCode.AvalonEdit.Highlighting.Xshd.XmlHighlightingDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private Dictionary`2<string, HighlightingRuleSet> ruleSetDict;
    private Dictionary`2<string, HighlightingColor> colorDict;
    [OptionalFieldAttribute]
private Dictionary`2<string, string> propDict;
    [CompilerGeneratedAttribute]
private HighlightingRuleSet <MainRuleSet>k__BackingField;
    public string Name { get; private set; }
    public HighlightingRuleSet MainRuleSet { get; private set; }
    public IEnumerable`1<HighlightingColor> NamedHighlightingColors { get; }
    public IDictionary`2<string, string> Properties { get; }
    public XmlHighlightingDefinition(XshdSyntaxDefinition xshd, IHighlightingDefinitionReferenceResolver resolver);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    private static Exception Error(XshdElement element, string message);
    [CompilerGeneratedAttribute]
public sealed virtual HighlightingRuleSet get_MainRuleSet();
    [CompilerGeneratedAttribute]
private void set_MainRuleSet(HighlightingRuleSet value);
    public sealed virtual HighlightingRuleSet GetNamedRuleSet(string name);
    public sealed virtual HighlightingColor GetNamedColor(string name);
    public sealed virtual IEnumerable`1<HighlightingColor> get_NamedHighlightingColors();
    public virtual string ToString();
    public sealed virtual IDictionary`2<string, string> get_Properties();
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdColor : XshdElement {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FontFamily <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FontSize>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightingBrush <Foreground>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightingBrush <Background>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FontWeight> <FontWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Underline>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Strikethrough>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FontStyle> <FontStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExampleText>k__BackingField;
    public string Name { get; public set; }
    public FontFamily FontFamily { get; public set; }
    public Nullable`1<int> FontSize { get; public set; }
    public HighlightingBrush Foreground { get; public set; }
    public HighlightingBrush Background { get; public set; }
    public Nullable`1<FontWeight> FontWeight { get; public set; }
    public Nullable`1<bool> Underline { get; public set; }
    public Nullable`1<bool> Strikethrough { get; public set; }
    public Nullable`1<FontStyle> FontStyle { get; public set; }
    public string ExampleText { get; public set; }
    protected XshdColor(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public FontFamily get_FontFamily();
    [CompilerGeneratedAttribute]
public void set_FontFamily(FontFamily value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FontSize();
    [CompilerGeneratedAttribute]
public void set_FontSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public HighlightingBrush get_Foreground();
    [CompilerGeneratedAttribute]
public void set_Foreground(HighlightingBrush value);
    [CompilerGeneratedAttribute]
public HighlightingBrush get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(HighlightingBrush value);
    [CompilerGeneratedAttribute]
public Nullable`1<FontWeight> get_FontWeight();
    [CompilerGeneratedAttribute]
public void set_FontWeight(Nullable`1<FontWeight> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Underline();
    [CompilerGeneratedAttribute]
public void set_Underline(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Strikethrough();
    [CompilerGeneratedAttribute]
public void set_Strikethrough(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<FontStyle> get_FontStyle();
    [CompilerGeneratedAttribute]
public void set_FontStyle(Nullable`1<FontStyle> value);
    [CompilerGeneratedAttribute]
public string get_ExampleText();
    [CompilerGeneratedAttribute]
public void set_ExampleText(string value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual object AcceptVisitor(IXshdVisitor visitor);
}
public abstract class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdElement : object {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    public int LineNumber { get; public set; }
    public int ColumnNumber { get; public set; }
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public void set_ColumnNumber(int value);
    public abstract virtual object AcceptVisitor(IXshdVisitor visitor);
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdImport : XshdElement {
    [CompilerGeneratedAttribute]
private XshdReference`1<XshdRuleSet> <RuleSetReference>k__BackingField;
    public XshdReference`1<XshdRuleSet> RuleSetReference { get; public set; }
    [CompilerGeneratedAttribute]
public XshdReference`1<XshdRuleSet> get_RuleSetReference();
    [CompilerGeneratedAttribute]
public void set_RuleSetReference(XshdReference`1<XshdRuleSet> value);
    public virtual object AcceptVisitor(IXshdVisitor visitor);
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdKeywords : XshdElement {
    [CompilerGeneratedAttribute]
private XshdReference`1<XshdColor> <ColorReference>k__BackingField;
    private NullSafeCollection`1<string> words;
    public XshdReference`1<XshdColor> ColorReference { get; public set; }
    public IList`1<string> Words { get; }
    [CompilerGeneratedAttribute]
public XshdReference`1<XshdColor> get_ColorReference();
    [CompilerGeneratedAttribute]
public void set_ColorReference(XshdReference`1<XshdColor> value);
    public IList`1<string> get_Words();
    public virtual object AcceptVisitor(IXshdVisitor visitor);
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdProperty : XshdElement {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; public set; }
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public virtual object AcceptVisitor(IXshdVisitor visitor);
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdReference`1 : ValueType {
    private string referencedDefinition;
    private string referencedElement;
    private T inlineElement;
    public string ReferencedDefinition { get; }
    public string ReferencedElement { get; }
    public T InlineElement { get; }
    public XshdReference`1(string referencedDefinition, string referencedElement);
    public XshdReference`1(T inlineElement);
    public string get_ReferencedDefinition();
    public string get_ReferencedElement();
    public T get_InlineElement();
    public object AcceptVisitor(IXshdVisitor visitor);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(XshdReference`1<T> other);
    public virtual int GetHashCode();
    private static int GetHashCode(object o);
    public static bool op_Equality(XshdReference`1<T> left, XshdReference`1<T> right);
    public static bool op_Inequality(XshdReference`1<T> left, XshdReference`1<T> right);
}
public enum ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdRegexType : Enum {
    public int value__;
    public static XshdRegexType Default;
    public static XshdRegexType IgnorePatternWhitespace;
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdRule : XshdElement {
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private XshdRegexType <RegexType>k__BackingField;
    [CompilerGeneratedAttribute]
private XshdReference`1<XshdColor> <ColorReference>k__BackingField;
    public string Regex { get; public set; }
    public XshdRegexType RegexType { get; public set; }
    public XshdReference`1<XshdColor> ColorReference { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Regex();
    [CompilerGeneratedAttribute]
public void set_Regex(string value);
    [CompilerGeneratedAttribute]
public XshdRegexType get_RegexType();
    [CompilerGeneratedAttribute]
public void set_RegexType(XshdRegexType value);
    [CompilerGeneratedAttribute]
public XshdReference`1<XshdColor> get_ColorReference();
    [CompilerGeneratedAttribute]
public void set_ColorReference(XshdReference`1<XshdColor> value);
    public virtual object AcceptVisitor(IXshdVisitor visitor);
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdRuleSet : XshdElement {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IgnoreCase>k__BackingField;
    private NullSafeCollection`1<XshdElement> elements;
    public string Name { get; public set; }
    public Nullable`1<bool> IgnoreCase { get; public set; }
    public IList`1<XshdElement> Elements { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(Nullable`1<bool> value);
    public IList`1<XshdElement> get_Elements();
    public void AcceptElements(IXshdVisitor visitor);
    public virtual object AcceptVisitor(IXshdVisitor visitor);
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdSpan : XshdElement {
    [CompilerGeneratedAttribute]
private string <BeginRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private XshdRegexType <BeginRegexType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private XshdRegexType <EndRegexType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Multiline>k__BackingField;
    [CompilerGeneratedAttribute]
private XshdReference`1<XshdRuleSet> <RuleSetReference>k__BackingField;
    [CompilerGeneratedAttribute]
private XshdReference`1<XshdColor> <SpanColorReference>k__BackingField;
    [CompilerGeneratedAttribute]
private XshdReference`1<XshdColor> <BeginColorReference>k__BackingField;
    [CompilerGeneratedAttribute]
private XshdReference`1<XshdColor> <EndColorReference>k__BackingField;
    public string BeginRegex { get; public set; }
    public XshdRegexType BeginRegexType { get; public set; }
    public string EndRegex { get; public set; }
    public XshdRegexType EndRegexType { get; public set; }
    public bool Multiline { get; public set; }
    public XshdReference`1<XshdRuleSet> RuleSetReference { get; public set; }
    public XshdReference`1<XshdColor> SpanColorReference { get; public set; }
    public XshdReference`1<XshdColor> BeginColorReference { get; public set; }
    public XshdReference`1<XshdColor> EndColorReference { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BeginRegex();
    [CompilerGeneratedAttribute]
public void set_BeginRegex(string value);
    [CompilerGeneratedAttribute]
public XshdRegexType get_BeginRegexType();
    [CompilerGeneratedAttribute]
public void set_BeginRegexType(XshdRegexType value);
    [CompilerGeneratedAttribute]
public string get_EndRegex();
    [CompilerGeneratedAttribute]
public void set_EndRegex(string value);
    [CompilerGeneratedAttribute]
public XshdRegexType get_EndRegexType();
    [CompilerGeneratedAttribute]
public void set_EndRegexType(XshdRegexType value);
    [CompilerGeneratedAttribute]
public bool get_Multiline();
    [CompilerGeneratedAttribute]
public void set_Multiline(bool value);
    [CompilerGeneratedAttribute]
public XshdReference`1<XshdRuleSet> get_RuleSetReference();
    [CompilerGeneratedAttribute]
public void set_RuleSetReference(XshdReference`1<XshdRuleSet> value);
    [CompilerGeneratedAttribute]
public XshdReference`1<XshdColor> get_SpanColorReference();
    [CompilerGeneratedAttribute]
public void set_SpanColorReference(XshdReference`1<XshdColor> value);
    [CompilerGeneratedAttribute]
public XshdReference`1<XshdColor> get_BeginColorReference();
    [CompilerGeneratedAttribute]
public void set_BeginColorReference(XshdReference`1<XshdColor> value);
    [CompilerGeneratedAttribute]
public XshdReference`1<XshdColor> get_EndColorReference();
    [CompilerGeneratedAttribute]
public void set_EndColorReference(XshdReference`1<XshdColor> value);
    public virtual object AcceptVisitor(IXshdVisitor visitor);
}
public class ICSharpCode.AvalonEdit.Highlighting.Xshd.XshdSyntaxDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<XshdElement> <Elements>k__BackingField;
    public string Name { get; public set; }
    public IList`1<string> Extensions { get; private set; }
    public IList`1<XshdElement> Elements { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Extensions();
    [CompilerGeneratedAttribute]
private void set_Extensions(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<XshdElement> get_Elements();
    [CompilerGeneratedAttribute]
private void set_Elements(IList`1<XshdElement> value);
    public void AcceptElements(IXshdVisitor visitor);
}
public class ICSharpCode.AvalonEdit.Indentation.CSharp.CSharpIndentationStrategy : DefaultIndentationStrategy {
    private string indentationString;
    public string IndentationString { get; public set; }
    public CSharpIndentationStrategy(TextEditorOptions options);
    public string get_IndentationString();
    public void set_IndentationString(string value);
    public void Indent(IDocumentAccessor document, bool keepEmptyLines);
    public virtual void IndentLine(TextDocument document, DocumentLine line);
    public virtual void IndentLines(TextDocument document, int beginLine, int endLine);
}
public interface ICSharpCode.AvalonEdit.Indentation.CSharp.IDocumentAccessor {
    public bool IsReadOnly { get; }
    public int LineNumber { get; }
    public string Text { get; public set; }
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual int get_LineNumber();
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    public abstract virtual bool MoveNext();
}
internal class ICSharpCode.AvalonEdit.Indentation.CSharp.IndentationReformatter : object {
    private StringBuilder wordBuilder;
    private Stack`1<Block> blocks;
    private Block block;
    private bool inString;
    private bool inChar;
    private bool verbatim;
    private bool escape;
    private bool lineComment;
    private bool blockComment;
    private char lastRealChar;
    public void Reformat(IDocumentAccessor doc, IndentationSettings set);
    public void Init();
    public void Step(IDocumentAccessor doc, IndentationSettings set);
    private static string Repeat(string text, int count);
    private static bool IsSingleStatementKeyword(string keyword);
    private static bool TrimEnd(IDocumentAccessor doc);
}
internal class ICSharpCode.AvalonEdit.Indentation.CSharp.IndentationSettings : object {
    public string IndentString;
    public bool LeaveEmptyLines;
}
public class ICSharpCode.AvalonEdit.Indentation.CSharp.TextDocumentAccessor : object {
    private TextDocument doc;
    private int minLine;
    private int maxLine;
    private int num;
    private string text;
    private DocumentLine line;
    private bool lineDirty;
    public bool IsReadOnly { get; }
    public int LineNumber { get; }
    public string Text { get; public set; }
    public TextDocumentAccessor(TextDocument document);
    public TextDocumentAccessor(TextDocument document, int minLine, int maxLine);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_LineNumber();
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
    public sealed virtual bool MoveNext();
}
public class ICSharpCode.AvalonEdit.Indentation.DefaultIndentationStrategy : object {
    public virtual void IndentLine(TextDocument document, DocumentLine line);
    public virtual void IndentLines(TextDocument document, int beginLine, int endLine);
}
public interface ICSharpCode.AvalonEdit.Indentation.IIndentationStrategy {
    public abstract virtual void IndentLine(TextDocument document, DocumentLine line);
    public abstract virtual void IndentLines(TextDocument document, int beginLine, int endLine);
}
public interface ICSharpCode.AvalonEdit.ITextEditorComponent {
    public TextDocument Document { get; }
    public TextEditorOptions Options { get; }
    public abstract virtual TextDocument get_Document();
    [CompilerGeneratedAttribute]
public abstract virtual void add_DocumentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DocumentChanged(EventHandler value);
    public abstract virtual TextEditorOptions get_Options();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OptionChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OptionChanged(PropertyChangedEventHandler value);
}
public class ICSharpCode.AvalonEdit.Rendering.BackgroundGeometryBuilder : object {
    private double cornerRadius;
    [CompilerGeneratedAttribute]
private bool <AlignToWholePixels>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BorderThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtendToFullWidthAtLineEnd>k__BackingField;
    private PathFigureCollection figures;
    private PathFigure figure;
    private int insertionIndex;
    private double lastTop;
    private double lastBottom;
    private double lastLeft;
    private double lastRight;
    public double CornerRadius { get; public set; }
    public bool AlignToWholePixels { get; public set; }
    public double BorderThickness { get; public set; }
    public bool ExtendToFullWidthAtLineEnd { get; public set; }
    public double get_CornerRadius();
    public void set_CornerRadius(double value);
    [CompilerGeneratedAttribute]
public bool get_AlignToWholePixels();
    [CompilerGeneratedAttribute]
public void set_AlignToWholePixels(bool value);
    [CompilerGeneratedAttribute]
public double get_BorderThickness();
    [CompilerGeneratedAttribute]
public void set_BorderThickness(double value);
    [CompilerGeneratedAttribute]
public bool get_ExtendToFullWidthAtLineEnd();
    [CompilerGeneratedAttribute]
public void set_ExtendToFullWidthAtLineEnd(bool value);
    public void AddSegment(TextView textView, ISegment segment);
    public void AddRectangle(TextView textView, Rect rectangle);
    private void AddRectangle(Size pixelSize, Rect r);
    public static IEnumerable`1<Rect> GetRectsForSegment(TextView textView, ISegment segment, bool extendToFullWidthAtLineEnd);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Rendering.BackgroundGeometryBuilder/<GetRectsForSegmentImpl>d__21")]
private static IEnumerable`1<Rect> GetRectsForSegmentImpl(TextView textView, ISegment segment, bool extendToFullWidthAtLineEnd);
    public static IEnumerable`1<Rect> GetRectsFromVisualSegment(TextView textView, VisualLine line, int startVC, int endVC);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Rendering.BackgroundGeometryBuilder/<ProcessTextLines>d__23")]
private static IEnumerable`1<Rect> ProcessTextLines(TextView textView, VisualLine visualLine, int segmentStartVC, int segmentEndVC);
    public void AddRectangle(double left, double top, double right, double bottom);
    private ArcSegment MakeArc(double x, double y, SweepDirection dir);
    private static LineSegment MakeLineSegment(double x, double y);
    public void CloseFigure();
    public Geometry CreateGeometry();
}
public class ICSharpCode.AvalonEdit.Rendering.CollapsedLineSection : object {
    private DocumentLine start;
    private DocumentLine end;
    private HeightTree heightTree;
    private static string ID;
    public bool IsCollapsed { get; }
    public DocumentLine Start { get; internal set; }
    public DocumentLine End { get; internal set; }
    internal CollapsedLineSection(HeightTree heightTree, DocumentLine start, DocumentLine end);
    public bool get_IsCollapsed();
    public DocumentLine get_Start();
    internal void set_Start(DocumentLine value);
    public DocumentLine get_End();
    internal void set_End(DocumentLine value);
    public void Uncollapse();
    public virtual string ToString();
}
public abstract class ICSharpCode.AvalonEdit.Rendering.ColorizingTransformer : object {
    [CompilerGeneratedAttribute]
private IList`1<VisualLineElement> <CurrentElements>k__BackingField;
    protected IList`1<VisualLineElement> CurrentElements { get; private set; }
    [CompilerGeneratedAttribute]
protected IList`1<VisualLineElement> get_CurrentElements();
    [CompilerGeneratedAttribute]
private void set_CurrentElements(IList`1<VisualLineElement> value);
    public sealed virtual void Transform(ITextRunConstructionContext context, IList`1<VisualLineElement> elements);
    protected abstract virtual void Colorize(ITextRunConstructionContext context);
    protected void ChangeVisualElements(int visualStartColumn, int visualEndColumn, Action`1<VisualLineElement> action);
    protected virtual void OnAddToTextView(TextView textView);
    protected virtual void OnRemoveFromTextView(TextView textView);
    private sealed virtual override void ICSharpCode.AvalonEdit.Rendering.ITextViewConnect.AddToTextView(TextView textView);
    private sealed virtual override void ICSharpCode.AvalonEdit.Rendering.ITextViewConnect.RemoveFromTextView(TextView textView);
}
internal class ICSharpCode.AvalonEdit.Rendering.ColumnRulerRenderer : object {
    private Pen pen;
    private int column;
    private TextView textView;
    public static Color DefaultForeground;
    public KnownLayer Layer { get; }
    public ColumnRulerRenderer(TextView textView);
    private static ColumnRulerRenderer();
    public sealed virtual KnownLayer get_Layer();
    public void SetRuler(int column, Pen pen);
    public sealed virtual void Draw(TextView textView, DrawingContext drawingContext);
}
internal class ICSharpCode.AvalonEdit.Rendering.CurrentLineHighlightRenderer : object {
    private int line;
    private TextView textView;
    public static Color DefaultBackground;
    public static Color DefaultBorder;
    [CompilerGeneratedAttribute]
private Brush <BackgroundBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private Pen <BorderPen>k__BackingField;
    public int Line { get; public set; }
    public KnownLayer Layer { get; }
    public Brush BackgroundBrush { get; public set; }
    public Pen BorderPen { get; public set; }
    public CurrentLineHighlightRenderer(TextView textView);
    private static CurrentLineHighlightRenderer();
    public int get_Line();
    public void set_Line(int value);
    public sealed virtual KnownLayer get_Layer();
    [CompilerGeneratedAttribute]
public Brush get_BackgroundBrush();
    [CompilerGeneratedAttribute]
public void set_BackgroundBrush(Brush value);
    [CompilerGeneratedAttribute]
public Pen get_BorderPen();
    [CompilerGeneratedAttribute]
public void set_BorderPen(Pen value);
    public sealed virtual void Draw(TextView textView, DrawingContext drawingContext);
}
public class ICSharpCode.AvalonEdit.Rendering.DefaultTextRunTypographyProperties : TextRunTypographyProperties {
    public FontVariants Variants { get; }
    public bool StylisticSet1 { get; }
    public bool StylisticSet2 { get; }
    public bool StylisticSet3 { get; }
    public bool StylisticSet4 { get; }
    public bool StylisticSet5 { get; }
    public bool StylisticSet6 { get; }
    public bool StylisticSet7 { get; }
    public bool StylisticSet8 { get; }
    public bool StylisticSet9 { get; }
    public bool StylisticSet10 { get; }
    public bool StylisticSet11 { get; }
    public bool StylisticSet12 { get; }
    public bool StylisticSet13 { get; }
    public bool StylisticSet14 { get; }
    public bool StylisticSet15 { get; }
    public bool StylisticSet16 { get; }
    public bool StylisticSet17 { get; }
    public bool StylisticSet18 { get; }
    public bool StylisticSet19 { get; }
    public bool StylisticSet20 { get; }
    public int StylisticAlternates { get; }
    public int StandardSwashes { get; }
    public bool StandardLigatures { get; }
    public bool SlashedZero { get; }
    public FontNumeralStyle NumeralStyle { get; }
    public FontNumeralAlignment NumeralAlignment { get; }
    public bool MathematicalGreek { get; }
    public bool Kerning { get; }
    public bool HistoricalLigatures { get; }
    public bool HistoricalForms { get; }
    public FontFraction Fraction { get; }
    public FontEastAsianWidths EastAsianWidths { get; }
    public FontEastAsianLanguage EastAsianLanguage { get; }
    public bool EastAsianExpertForms { get; }
    public bool DiscretionaryLigatures { get; }
    public int ContextualSwashes { get; }
    public bool ContextualLigatures { get; }
    public bool ContextualAlternates { get; }
    public bool CaseSensitiveForms { get; }
    public bool CapitalSpacing { get; }
    public FontCapitals Capitals { get; }
    public int AnnotationAlternates { get; }
    public virtual FontVariants get_Variants();
    public virtual bool get_StylisticSet1();
    public virtual bool get_StylisticSet2();
    public virtual bool get_StylisticSet3();
    public virtual bool get_StylisticSet4();
    public virtual bool get_StylisticSet5();
    public virtual bool get_StylisticSet6();
    public virtual bool get_StylisticSet7();
    public virtual bool get_StylisticSet8();
    public virtual bool get_StylisticSet9();
    public virtual bool get_StylisticSet10();
    public virtual bool get_StylisticSet11();
    public virtual bool get_StylisticSet12();
    public virtual bool get_StylisticSet13();
    public virtual bool get_StylisticSet14();
    public virtual bool get_StylisticSet15();
    public virtual bool get_StylisticSet16();
    public virtual bool get_StylisticSet17();
    public virtual bool get_StylisticSet18();
    public virtual bool get_StylisticSet19();
    public virtual bool get_StylisticSet20();
    public virtual int get_StylisticAlternates();
    public virtual int get_StandardSwashes();
    public virtual bool get_StandardLigatures();
    public virtual bool get_SlashedZero();
    public virtual FontNumeralStyle get_NumeralStyle();
    public virtual FontNumeralAlignment get_NumeralAlignment();
    public virtual bool get_MathematicalGreek();
    public virtual bool get_Kerning();
    public virtual bool get_HistoricalLigatures();
    public virtual bool get_HistoricalForms();
    public virtual FontFraction get_Fraction();
    public virtual FontEastAsianWidths get_EastAsianWidths();
    public virtual FontEastAsianLanguage get_EastAsianLanguage();
    public virtual bool get_EastAsianExpertForms();
    public virtual bool get_DiscretionaryLigatures();
    public virtual int get_ContextualSwashes();
    public virtual bool get_ContextualLigatures();
    public virtual bool get_ContextualAlternates();
    public virtual bool get_CaseSensitiveForms();
    public virtual bool get_CapitalSpacing();
    public virtual FontCapitals get_Capitals();
    public virtual int get_AnnotationAlternates();
}
public abstract class ICSharpCode.AvalonEdit.Rendering.DocumentColorizingTransformer : ColorizingTransformer {
    private DocumentLine currentDocumentLine;
    private int firstLineStart;
    private int currentDocumentLineStartOffset;
    private int currentDocumentLineEndOffset;
    [CompilerGeneratedAttribute]
private ITextRunConstructionContext <CurrentContext>k__BackingField;
    protected ITextRunConstructionContext CurrentContext { get; private set; }
    [CompilerGeneratedAttribute]
protected ITextRunConstructionContext get_CurrentContext();
    [CompilerGeneratedAttribute]
private void set_CurrentContext(ITextRunConstructionContext value);
    protected virtual void Colorize(ITextRunConstructionContext context);
    protected abstract virtual void ColorizeLine(DocumentLine line);
    protected void ChangeLinePart(int startOffset, int endOffset, Action`1<VisualLineElement> action);
}
public class ICSharpCode.AvalonEdit.Rendering.FormattedTextElement : VisualLineElement {
    internal FormattedText formattedText;
    internal string text;
    internal TextLine textLine;
    [CompilerGeneratedAttribute]
private LineBreakCondition <BreakBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private LineBreakCondition <BreakAfter>k__BackingField;
    public LineBreakCondition BreakBefore { get; public set; }
    public LineBreakCondition BreakAfter { get; public set; }
    public FormattedTextElement(string text, int documentLength);
    public FormattedTextElement(TextLine text, int documentLength);
    public FormattedTextElement(FormattedText text, int documentLength);
    [CompilerGeneratedAttribute]
public LineBreakCondition get_BreakBefore();
    [CompilerGeneratedAttribute]
public void set_BreakBefore(LineBreakCondition value);
    [CompilerGeneratedAttribute]
public LineBreakCondition get_BreakAfter();
    [CompilerGeneratedAttribute]
public void set_BreakAfter(LineBreakCondition value);
    public virtual TextRun CreateTextRun(int startVisualColumn, ITextRunConstructionContext context);
    public static TextLine PrepareText(TextFormatter formatter, string text, TextRunProperties properties);
}
public class ICSharpCode.AvalonEdit.Rendering.FormattedTextRun : TextEmbeddedObject {
    private FormattedTextElement element;
    private TextRunProperties properties;
    public FormattedTextElement Element { get; }
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public FormattedTextRun(FormattedTextElement element, TextRunProperties properties);
    public FormattedTextElement get_Element();
    public virtual LineBreakCondition get_BreakBefore();
    public virtual LineBreakCondition get_BreakAfter();
    public virtual bool get_HasFixedSize();
    public virtual CharacterBufferReference get_CharacterBufferReference();
    public virtual int get_Length();
    public virtual TextRunProperties get_Properties();
    public virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
}
internal class ICSharpCode.AvalonEdit.Rendering.GlobalTextRunProperties : TextRunProperties {
    internal Typeface typeface;
    internal double fontRenderingEmSize;
    internal Brush foregroundBrush;
    internal Brush backgroundBrush;
    internal CultureInfo cultureInfo;
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public double FontHintingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public Brush ForegroundBrush { get; }
    public Brush BackgroundBrush { get; }
    public CultureInfo CultureInfo { get; }
    public TextEffectCollection TextEffects { get; }
    public virtual Typeface get_Typeface();
    public virtual double get_FontRenderingEmSize();
    public virtual double get_FontHintingEmSize();
    public virtual TextDecorationCollection get_TextDecorations();
    public virtual Brush get_ForegroundBrush();
    public virtual Brush get_BackgroundBrush();
    public virtual CultureInfo get_CultureInfo();
    public virtual TextEffectCollection get_TextEffects();
}
internal class ICSharpCode.AvalonEdit.Rendering.HeightTree : object {
    private TextDocument document;
    private HeightTreeNode root;
    private WeakLineTracker weakLineTracker;
    private double defaultLineHeight;
    private bool inRemoval;
    private List`1<HeightTreeNode> nodesToCheckForMerging;
    private static bool RED;
    private static bool BLACK;
    public bool IsDisposed { get; }
    public double DefaultLineHeight { get; public set; }
    public int LineCount { get; }
    public double TotalHeight { get; }
    private IEnumerable`1<HeightTreeNode> AllNodes { get; }
    public HeightTree(TextDocument document, double defaultLineHeight);
    public sealed virtual void Dispose();
    public bool get_IsDisposed();
    public double get_DefaultLineHeight();
    public void set_DefaultLineHeight(double value);
    private HeightTreeNode GetNode(DocumentLine ls);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.ChangeComplete(DocumentChangeEventArgs e);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.SetLineLength(DocumentLine ls, int newTotalLength);
    public sealed virtual void RebuildDocument();
    private HeightTreeNode BuildTree(HeightTreeNode[] nodes, int start, int end, int subtreeHeight);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.BeforeRemoveLine(DocumentLine line);
    private sealed virtual override void ICSharpCode.AvalonEdit.Document.ILineTracker.LineInserted(DocumentLine insertionPos, DocumentLine newLine);
    private HeightTreeNode InsertAfter(HeightTreeNode node, DocumentLine newLine);
    private static void UpdateAfterChildrenChange(HeightTreeNode node);
    private static void UpdateAugmentedData(HeightTreeNode node, UpdateAfterChildrenChangeRecursionMode mode);
    private void UpdateAfterRotateLeft(HeightTreeNode node);
    private void UpdateAfterRotateRight(HeightTreeNode node);
    private void BeforeNodeRemove(HeightTreeNode removedNode);
    private void BeforeNodeReplace(HeightTreeNode removedNode, HeightTreeNode newNode, HeightTreeNode newNodeOldParent);
    private void BeginRemoval();
    private void EndRemoval();
    private void MergeCollapsedSectionsIfPossible(HeightTreeNode node);
    private HeightTreeNode GetNodeByIndex(int index);
    private HeightTreeNode GetNodeByVisualPosition(double position);
    private static double GetVisualPositionFromNode(HeightTreeNode node);
    public DocumentLine GetLineByNumber(int number);
    public DocumentLine GetLineByVisualPosition(double position);
    public double GetVisualPosition(DocumentLine line);
    public double GetHeight(DocumentLine line);
    public void SetHeight(DocumentLine line, double val);
    public bool GetIsCollapsed(int lineNumber);
    public CollapsedLineSection CollapseText(DocumentLine start, DocumentLine end);
    public int get_LineCount();
    public double get_TotalHeight();
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Rendering.HeightTree/<get_AllNodes>d__46")]
private IEnumerable`1<HeightTreeNode> get_AllNodes();
    internal IEnumerable`1<CollapsedLineSection> GetAllCollapsedSections();
    private void InsertAsLeft(HeightTreeNode parentNode, HeightTreeNode newNode);
    private void InsertAsRight(HeightTreeNode parentNode, HeightTreeNode newNode);
    private void FixTreeOnInsert(HeightTreeNode node);
    private void RemoveNode(HeightTreeNode removedNode);
    private void FixTreeOnDelete(HeightTreeNode node, HeightTreeNode parentNode);
    private void ReplaceNode(HeightTreeNode replacedNode, HeightTreeNode newNode);
    private void RotateLeft(HeightTreeNode p);
    private void RotateRight(HeightTreeNode p);
    private static HeightTreeNode Sibling(HeightTreeNode node);
    private static HeightTreeNode Sibling(HeightTreeNode node, HeightTreeNode parentNode);
    private static bool GetColor(HeightTreeNode node);
    private static bool GetIsCollapedFromNode(HeightTreeNode node);
    internal void AddCollapsedSection(CollapsedLineSection section, int sectionLength);
    private void AddRemoveCollapsedSection(CollapsedLineSection section, int sectionLength, bool add);
    private static void AddRemoveCollapsedSectionDown(CollapsedLineSection section, HeightTreeNode node, int sectionLength, bool add);
    public void Uncollapse(CollapsedLineSection section);
}
internal class ICSharpCode.AvalonEdit.Rendering.HeightTreeLineNode : ValueType {
    internal double height;
    internal List`1<CollapsedLineSection> collapsedSections;
    internal bool IsDirectlyCollapsed { get; }
    internal double TotalHeight { get; }
    internal HeightTreeLineNode(double height);
    internal bool get_IsDirectlyCollapsed();
    internal void AddDirectlyCollapsed(CollapsedLineSection section);
    internal void RemoveDirectlyCollapsed(CollapsedLineSection section);
    internal double get_TotalHeight();
}
internal class ICSharpCode.AvalonEdit.Rendering.HeightTreeNode : object {
    internal DocumentLine documentLine;
    internal HeightTreeLineNode lineNode;
    internal HeightTreeNode left;
    internal HeightTreeNode right;
    internal HeightTreeNode parent;
    internal bool color;
    internal int totalCount;
    internal double totalHeight;
    internal List`1<CollapsedLineSection> collapsedSections;
    internal HeightTreeNode LeftMost { get; }
    internal HeightTreeNode RightMost { get; }
    internal HeightTreeNode Successor { get; }
    internal bool IsDirectlyCollapsed { get; }
    internal HeightTreeNode(DocumentLine documentLine, double height);
    internal HeightTreeNode get_LeftMost();
    internal HeightTreeNode get_RightMost();
    internal HeightTreeNode get_Successor();
    internal bool get_IsDirectlyCollapsed();
    internal void AddDirectlyCollapsed(CollapsedLineSection section);
    internal void RemoveDirectlyCollapsed(CollapsedLineSection section);
}
public interface ICSharpCode.AvalonEdit.Rendering.IBackgroundRenderer {
    public KnownLayer Layer { get; }
    public abstract virtual KnownLayer get_Layer();
    public abstract virtual void Draw(TextView textView, DrawingContext drawingContext);
}
internal interface ICSharpCode.AvalonEdit.Rendering.IBuiltinElementGenerator {
    public abstract virtual void FetchOptions(TextEditorOptions options);
}
public class ICSharpCode.AvalonEdit.Rendering.InlineObjectElement : VisualLineElement {
    [CompilerGeneratedAttribute]
private UIElement <Element>k__BackingField;
    public UIElement Element { get; private set; }
    public InlineObjectElement(int documentLength, UIElement element);
    [CompilerGeneratedAttribute]
public UIElement get_Element();
    [CompilerGeneratedAttribute]
private void set_Element(UIElement value);
    public virtual TextRun CreateTextRun(int startVisualColumn, ITextRunConstructionContext context);
}
public class ICSharpCode.AvalonEdit.Rendering.InlineObjectRun : TextEmbeddedObject {
    private UIElement element;
    private int length;
    private TextRunProperties properties;
    internal Size desiredSize;
    [CompilerGeneratedAttribute]
private VisualLine <VisualLine>k__BackingField;
    public UIElement Element { get; }
    public VisualLine VisualLine { get; internal set; }
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public InlineObjectRun(int length, TextRunProperties properties, UIElement element);
    public UIElement get_Element();
    [CompilerGeneratedAttribute]
public VisualLine get_VisualLine();
    [CompilerGeneratedAttribute]
internal void set_VisualLine(VisualLine value);
    public virtual LineBreakCondition get_BreakBefore();
    public virtual LineBreakCondition get_BreakAfter();
    public virtual bool get_HasFixedSize();
    public virtual CharacterBufferReference get_CharacterBufferReference();
    public virtual int get_Length();
    public virtual TextRunProperties get_Properties();
    public virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
}
public interface ICSharpCode.AvalonEdit.Rendering.ITextRunConstructionContext {
    public TextDocument Document { get; }
    public TextView TextView { get; }
    public VisualLine VisualLine { get; }
    public TextRunProperties GlobalTextRunProperties { get; }
    public abstract virtual TextDocument get_Document();
    public abstract virtual TextView get_TextView();
    public abstract virtual VisualLine get_VisualLine();
    public abstract virtual TextRunProperties get_GlobalTextRunProperties();
    public abstract virtual StringSegment GetText(int offset, int length);
}
public interface ICSharpCode.AvalonEdit.Rendering.ITextViewConnect {
    public abstract virtual void AddToTextView(TextView textView);
    public abstract virtual void RemoveFromTextView(TextView textView);
}
public interface ICSharpCode.AvalonEdit.Rendering.IVisualLineTransformer {
    public abstract virtual void Transform(ITextRunConstructionContext context, IList`1<VisualLineElement> elements);
}
public enum ICSharpCode.AvalonEdit.Rendering.KnownLayer : Enum {
    public int value__;
    public static KnownLayer Background;
    public static KnownLayer Selection;
    public static KnownLayer Text;
    public static KnownLayer Caret;
}
internal class ICSharpCode.AvalonEdit.Rendering.Layer : UIElement {
    protected TextView textView;
    protected KnownLayer knownLayer;
    public Layer(TextView textView, KnownLayer knownLayer);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual void OnRender(DrawingContext drawingContext);
}
public enum ICSharpCode.AvalonEdit.Rendering.LayerInsertionPosition : Enum {
    public int value__;
    public static LayerInsertionPosition Below;
    public static LayerInsertionPosition Replace;
    public static LayerInsertionPosition Above;
}
internal class ICSharpCode.AvalonEdit.Rendering.LayerPosition : object {
    internal static DependencyProperty LayerPositionProperty;
    internal KnownLayer KnownLayer;
    internal LayerInsertionPosition Position;
    public LayerPosition(KnownLayer knownLayer, LayerInsertionPosition position);
    private static LayerPosition();
    public static void SetLayerPosition(UIElement layer, LayerPosition value);
    public static LayerPosition GetLayerPosition(UIElement layer);
    public sealed virtual int CompareTo(LayerPosition other);
}
public class ICSharpCode.AvalonEdit.Rendering.LinkElementGenerator : VisualLineElementGenerator {
    internal static Regex defaultLinkRegex;
    internal static Regex defaultMailRegex;
    private Regex linkRegex;
    [CompilerGeneratedAttribute]
private bool <RequireControlModifierForClick>k__BackingField;
    public bool RequireControlModifierForClick { get; public set; }
    protected LinkElementGenerator(Regex regex);
    private static LinkElementGenerator();
    [CompilerGeneratedAttribute]
public bool get_RequireControlModifierForClick();
    [CompilerGeneratedAttribute]
public void set_RequireControlModifierForClick(bool value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Rendering.IBuiltinElementGenerator.FetchOptions(TextEditorOptions options);
    private Match GetMatch(int startOffset, Int32& matchOffset);
    public virtual int GetFirstInterestedOffset(int startOffset);
    public virtual VisualLineElement ConstructElement(int offset);
    protected virtual VisualLineElement ConstructElementFromMatch(Match m);
    protected virtual Uri GetUriFromMatch(Match match);
}
internal class ICSharpCode.AvalonEdit.Rendering.MailLinkElementGenerator : LinkElementGenerator {
    protected virtual Uri GetUriFromMatch(Match match);
}
public class ICSharpCode.AvalonEdit.Rendering.MouseHoverLogic : object {
    private UIElement target;
    private DispatcherTimer mouseHoverTimer;
    private Point mouseHoverStartPoint;
    private MouseEventArgs mouseHoverLastEventArgs;
    private bool mouseHovering;
    [CompilerGeneratedAttribute]
private EventHandler`1<MouseEventArgs> MouseHover;
    [CompilerGeneratedAttribute]
private EventHandler`1<MouseEventArgs> MouseHoverStopped;
    private bool disposed;
    public MouseHoverLogic(UIElement target);
    private void MouseHoverLogicMouseMove(object sender, MouseEventArgs e);
    private void MouseHoverLogicMouseEnter(object sender, MouseEventArgs e);
    private void StartHovering(MouseEventArgs e);
    private void MouseHoverLogicMouseLeave(object sender, MouseEventArgs e);
    private void StopHovering();
    private void OnMouseHoverTimerElapsed(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
public void add_MouseHover(EventHandler`1<MouseEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MouseHover(EventHandler`1<MouseEventArgs> value);
    protected virtual void OnMouseHover(MouseEventArgs e);
    [CompilerGeneratedAttribute]
public void add_MouseHoverStopped(EventHandler`1<MouseEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MouseHoverStopped(EventHandler`1<MouseEventArgs> value);
    protected virtual void OnMouseHoverStopped(MouseEventArgs e);
    public sealed virtual void Dispose();
}
internal class ICSharpCode.AvalonEdit.Rendering.SimpleTextSource : TextSource {
    private string text;
    private TextRunProperties properties;
    public SimpleTextSource(string text, TextRunProperties properties);
    public virtual TextRun GetTextRun(int textSourceCharacterIndex);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
}
internal class ICSharpCode.AvalonEdit.Rendering.SingleCharacterElementGenerator : VisualLineElementGenerator {
    [CompilerGeneratedAttribute]
private bool <ShowSpaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowTabs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowBoxForControlCharacters>k__BackingField;
    public bool ShowSpaces { get; public set; }
    public bool ShowTabs { get; public set; }
    public bool ShowBoxForControlCharacters { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ShowSpaces();
    [CompilerGeneratedAttribute]
public void set_ShowSpaces(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowTabs();
    [CompilerGeneratedAttribute]
public void set_ShowTabs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowBoxForControlCharacters();
    [CompilerGeneratedAttribute]
public void set_ShowBoxForControlCharacters(bool value);
    private sealed virtual override void ICSharpCode.AvalonEdit.Rendering.IBuiltinElementGenerator.FetchOptions(TextEditorOptions options);
    public virtual int GetFirstInterestedOffset(int startOffset);
    public virtual VisualLineElement ConstructElement(int offset);
}
internal class ICSharpCode.AvalonEdit.Rendering.TextLayer : Layer {
    internal int index;
    private List`1<VisualLineDrawingVisual> visuals;
    protected int VisualChildrenCount { get; }
    public TextLayer(TextView textView);
    internal void SetVisualLines(ICollection`1<VisualLine> visualLines);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual void ArrangeCore(Rect finalRect);
}
public class ICSharpCode.AvalonEdit.Rendering.TextView : FrameworkElement {
    private ColumnRulerRenderer columnRulerRenderer;
    private CurrentLineHighlightRenderer currentLineHighlighRenderer;
    public static DependencyProperty DocumentProperty;
    private TextDocument document;
    private HeightTree heightTree;
    [CompilerGeneratedAttribute]
private EventHandler DocumentChanged;
    public static DependencyProperty OptionsProperty;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler OptionChanged;
    private ObserveAddRemoveCollection`1<VisualLineElementGenerator> elementGenerators;
    private ObserveAddRemoveCollection`1<IVisualLineTransformer> lineTransformers;
    private SingleCharacterElementGenerator singleCharacterElementGenerator;
    private LinkElementGenerator linkElementGenerator;
    private MailLinkElementGenerator mailLinkElementGenerator;
    internal TextLayer textLayer;
    private LayerCollection layers;
    private List`1<InlineObjectRun> inlineObjects;
    private List`1<VisualLine> visualLinesWithOutstandingInlineObjects;
    public static DependencyProperty NonPrintableCharacterBrushProperty;
    public static DependencyProperty LinkTextForegroundBrushProperty;
    public static DependencyProperty LinkTextBackgroundBrushProperty;
    public static DependencyProperty LinkTextUnderlineProperty;
    private DispatcherOperation invalidateMeasureOperation;
    private List`1<VisualLine> allVisualLines;
    private ReadOnlyCollection`1<VisualLine> visibleVisualLines;
    private double clippedPixelsOnTop;
    private List`1<VisualLine> newVisualLines;
    [CompilerGeneratedAttribute]
private EventHandler`1<VisualLineConstructionStartEventArgs> VisualLineConstructionStarting;
    [CompilerGeneratedAttribute]
private EventHandler VisualLinesChanged;
    private static double AdditionalHorizontalScrollAmount;
    private Size lastAvailableSize;
    private bool inMeasure;
    private TextFormatter formatter;
    internal TextViewCachedElements cachedElements;
    private ObserveAddRemoveCollection`1<IBackgroundRenderer> backgroundRenderers;
    private Size scrollExtent;
    private Vector scrollOffset;
    private Size scrollViewport;
    private bool canVerticallyScroll;
    private bool canHorizontallyScroll;
    [CompilerGeneratedAttribute]
private EventHandler ScrollOffsetChanged;
    [CompilerGeneratedAttribute]
private ScrollViewer <System.Windows.Controls.Primitives.IScrollInfo.ScrollOwner>k__BackingField;
    private bool defaultTextMetricsValid;
    private double wideSpaceWidth;
    private double defaultLineHeight;
    private double defaultBaseline;
    [ThreadStaticAttribute]
private static bool invalidCursor;
    private ServiceContainer services;
    public static RoutedEvent PreviewMouseHoverEvent;
    public static RoutedEvent MouseHoverEvent;
    public static RoutedEvent PreviewMouseHoverStoppedEvent;
    public static RoutedEvent MouseHoverStoppedEvent;
    private MouseHoverLogic hoverLogic;
    public static DependencyProperty ColumnRulerPenProperty;
    public static DependencyProperty CurrentLineBackgroundProperty;
    public static DependencyProperty CurrentLineBorderProperty;
    public TextDocument Document { get; public set; }
    internal double FontSize { get; }
    public TextEditorOptions Options { get; public set; }
    public IList`1<VisualLineElementGenerator> ElementGenerators { get; }
    public IList`1<IVisualLineTransformer> LineTransformers { get; }
    public UIElementCollection Layers { get; }
    protected int VisualChildrenCount { get; }
    protected IEnumerator LogicalChildren { get; }
    public Brush NonPrintableCharacterBrush { get; public set; }
    public Brush LinkTextForegroundBrush { get; public set; }
    public Brush LinkTextBackgroundBrush { get; public set; }
    public bool LinkTextUnderline { get; public set; }
    public ReadOnlyCollection`1<VisualLine> VisualLines { get; }
    public bool VisualLinesValid { get; }
    public IList`1<IBackgroundRenderer> BackgroundRenderers { get; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanVerticallyScroll { get; private set; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanHorizontallyScroll { get; private set; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportHeight { get; }
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public Vector ScrollOffset { get; }
    private ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.ScrollOwner { get; private set; }
    public double WideSpaceWidth { get; }
    public double DefaultLineHeight { get; }
    public double DefaultBaseline { get; }
    public ServiceContainer Services { get; }
    public double DocumentHeight { get; }
    public Pen ColumnRulerPen { get; public set; }
    public Brush CurrentLineBackground { get; public set; }
    public Pen CurrentLineBorder { get; public set; }
    public int HighlightedLine { get; public set; }
    public double EmptyLineSelectionWidth { get; }
    private static TextView();
    public sealed virtual TextDocument get_Document();
    public void set_Document(TextDocument value);
    private static void OnDocumentChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e);
    internal double get_FontSize();
    [CompilerGeneratedAttribute]
public sealed virtual void add_DocumentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DocumentChanged(EventHandler value);
    private void OnDocumentChanged(TextDocument oldValue, TextDocument newValue);
    private void RecreateTextFormatter();
    private void RecreateCachedElements();
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    public sealed virtual TextEditorOptions get_Options();
    public void set_Options(TextEditorOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OptionChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OptionChanged(PropertyChangedEventHandler value);
    protected virtual void OnOptionChanged(PropertyChangedEventArgs e);
    private static void OnOptionsChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e);
    private void OnOptionsChanged(TextEditorOptions oldValue, TextEditorOptions newValue);
    public IList`1<VisualLineElementGenerator> get_ElementGenerators();
    private void ElementGenerator_Added(VisualLineElementGenerator generator);
    private void ElementGenerator_Removed(VisualLineElementGenerator generator);
    public IList`1<IVisualLineTransformer> get_LineTransformers();
    private void LineTransformer_Added(IVisualLineTransformer lineTransformer);
    private void LineTransformer_Removed(IVisualLineTransformer lineTransformer);
    private void UpdateBuiltinElementGeneratorsFromOptions();
    private void AddRemoveDefaultElementGeneratorOnDemand(T& generator, bool demand);
    public UIElementCollection get_Layers();
    private void LayersChanged();
    public void InsertLayer(UIElement layer, KnownLayer referencedLayer, LayerInsertionPosition position);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual IEnumerator get_LogicalChildren();
    internal void AddInlineObject(InlineObjectRun inlineObject);
    private void MeasureInlineObjects();
    private void RemoveInlineObjects(VisualLine visualLine);
    private void RemoveInlineObjectsNow();
    private void RemoveInlineObjectRun(InlineObjectRun ior, bool keepElement);
    public Brush get_NonPrintableCharacterBrush();
    public void set_NonPrintableCharacterBrush(Brush value);
    public Brush get_LinkTextForegroundBrush();
    public void set_LinkTextForegroundBrush(Brush value);
    public Brush get_LinkTextBackgroundBrush();
    public void set_LinkTextBackgroundBrush(Brush value);
    public bool get_LinkTextUnderline();
    public void set_LinkTextUnderline(bool value);
    public void Redraw();
    public void Redraw(DispatcherPriority redrawPriority);
    public void Redraw(VisualLine visualLine, DispatcherPriority redrawPriority);
    public void Redraw(int offset, int length, DispatcherPriority redrawPriority);
    public void InvalidateLayer(KnownLayer knownLayer);
    public void InvalidateLayer(KnownLayer knownLayer, DispatcherPriority priority);
    public void Redraw(ISegment segment, DispatcherPriority redrawPriority);
    private void ClearVisualLines();
    private void DisposeVisualLine(VisualLine visualLine);
    private void InvalidateMeasure(DispatcherPriority priority);
    public VisualLine GetVisualLine(int documentLineNumber);
    public VisualLine GetOrConstructVisualLine(DocumentLine documentLine);
    public ReadOnlyCollection`1<VisualLine> get_VisualLines();
    public bool get_VisualLinesValid();
    [CompilerGeneratedAttribute]
public void add_VisualLineConstructionStarting(EventHandler`1<VisualLineConstructionStartEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_VisualLineConstructionStarting(EventHandler`1<VisualLineConstructionStartEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_VisualLinesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_VisualLinesChanged(EventHandler value);
    public void EnsureVisualLines();
    protected virtual Size MeasureOverride(Size availableSize);
    private double CreateAndMeasureVisualLines(Size availableSize);
    private TextRunProperties CreateGlobalTextRunProperties();
    private VisualLineTextParagraphProperties CreateParagraphProperties(TextRunProperties defaultTextRunProperties);
    private VisualLine BuildVisualLine(DocumentLine documentLine, TextRunProperties globalTextRunProperties, VisualLineTextParagraphProperties paragraphProperties, VisualLineElementGenerator[] elementGeneratorsArray, IVisualLineTransformer[] lineTransformersArray, Size availableSize);
    private static int GetIndentationVisualColumn(VisualLine visualLine);
    protected virtual Size ArrangeOverride(Size finalSize);
    public IList`1<IBackgroundRenderer> get_BackgroundRenderers();
    private void BackgroundRenderer_Added(IBackgroundRenderer renderer);
    private void BackgroundRenderer_Removed(IBackgroundRenderer renderer);
    protected virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal void RenderBackground(DrawingContext drawingContext, KnownLayer layer);
    internal void ArrangeTextLayer(IList`1<VisualLineDrawingVisual> visuals);
    private void ClearScrollData();
    private bool SetScrollData(Size viewport, Size extent, Vector offset);
    private void OnScrollChange();
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanVerticallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanVerticallyScroll(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanHorizontallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanHorizontallyScroll(bool value);
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual double get_VerticalOffset();
    public Vector get_ScrollOffset();
    [CompilerGeneratedAttribute]
public void add_ScrollOffsetChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ScrollOffsetChanged(EventHandler value);
    private void SetScrollOffset(Vector vector);
    [CompilerGeneratedAttribute]
private sealed virtual override ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.get_ScrollOwner();
    [CompilerGeneratedAttribute]
private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_ScrollOwner(ScrollViewer value);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelRight();
    public double get_WideSpaceWidth();
    public double get_DefaultLineHeight();
    public double get_DefaultBaseline();
    private void InvalidateDefaultTextMetrics();
    private void CalculateDefaultTextMetrics();
    private static double ValidateVisualOffset(double offset);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(double offset);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetVerticalOffset(double offset);
    private sealed virtual override Rect System.Windows.Controls.Primitives.IScrollInfo.MakeVisible(Visual visual, Rect rectangle);
    public virtual void MakeVisible(Rect rectangle);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    public static void InvalidateCursor();
    internal void InvalidateCursorIfMouseWithinTextView();
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    public VisualLine GetVisualLineFromVisualTop(double visualTop);
    public double GetVisualTopByDocumentLine(int line);
    private VisualLineElement GetVisualLineElementFromPosition(Point visualPosition);
    public Point GetVisualPosition(TextViewPosition position, VisualYPosition yPositionMode);
    public Nullable`1<TextViewPosition> GetPosition(Point visualPosition);
    public Nullable`1<TextViewPosition> GetPositionFloor(Point visualPosition);
    public ServiceContainer get_Services();
    public virtual object GetService(Type serviceType);
    private void ConnectToTextView(object obj);
    private void DisconnectFromTextView(object obj);
    public void add_PreviewMouseHover(MouseEventHandler value);
    public void remove_PreviewMouseHover(MouseEventHandler value);
    public void add_MouseHover(MouseEventHandler value);
    public void remove_MouseHover(MouseEventHandler value);
    public void add_PreviewMouseHoverStopped(MouseEventHandler value);
    public void remove_PreviewMouseHoverStopped(MouseEventHandler value);
    public void add_MouseHoverStopped(MouseEventHandler value);
    public void remove_MouseHoverStopped(MouseEventHandler value);
    private void RaiseHoverEventPair(MouseEventArgs e, RoutedEvent tunnelingEvent, RoutedEvent bubblingEvent);
    public CollapsedLineSection CollapseLines(DocumentLine start, DocumentLine end);
    public double get_DocumentHeight();
    public DocumentLine GetDocumentLineByVisualTop(double visualTop);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private static Pen CreateFrozenPen(SolidColorBrush brush);
    public Pen get_ColumnRulerPen();
    public void set_ColumnRulerPen(Pen value);
    public Brush get_CurrentLineBackground();
    public void set_CurrentLineBackground(Brush value);
    public Pen get_CurrentLineBorder();
    public void set_CurrentLineBorder(Pen value);
    public int get_HighlightedLine();
    public void set_HighlightedLine(int value);
    public virtual double get_EmptyLineSelectionWidth();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object sender, MouseEventArgs e);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_1(object sender, MouseEventArgs e);
    [CompilerGeneratedAttribute]
private bool <RemoveInlineObjectsNow>b__63_0(InlineObjectRun ior);
    [CompilerGeneratedAttribute]
private void <InvalidateMeasure>b__91_0();
}
internal class ICSharpCode.AvalonEdit.Rendering.TextViewCachedElements : object {
    private TextFormatter formatter;
    private Dictionary`2<string, TextLine> nonPrintableCharacterTexts;
    public TextLine GetTextForNonPrintableCharacter(string text, ITextRunConstructionContext context);
    public sealed virtual void Dispose();
}
public static class ICSharpCode.AvalonEdit.Rendering.TextViewWeakEventManager : object {
}
public class ICSharpCode.AvalonEdit.Rendering.VisualLine : object {
    private TextView textView;
    private List`1<VisualLineElement> elements;
    internal bool hasInlineObjects;
    private LifetimePhase phase;
    [CompilerGeneratedAttribute]
private TextDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentLine <FirstDocumentLine>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentLine <LastDocumentLine>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<VisualLineElement> <Elements>k__BackingField;
    private ReadOnlyCollection`1<TextLine> textLines;
    [CompilerGeneratedAttribute]
private int <VisualLength>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private double <VisualTop>k__BackingField;
    private VisualLineDrawingVisual visual;
    public TextDocument Document { get; private set; }
    public DocumentLine FirstDocumentLine { get; private set; }
    public DocumentLine LastDocumentLine { get; private set; }
    public ReadOnlyCollection`1<VisualLineElement> Elements { get; private set; }
    public ReadOnlyCollection`1<TextLine> TextLines { get; }
    public int StartOffset { get; }
    public int VisualLength { get; private set; }
    public int VisualLengthWithEndOfLineMarker { get; }
    public double Height { get; private set; }
    public double VisualTop { get; internal set; }
    public bool IsDisposed { get; }
    internal VisualLine(TextView textView, DocumentLine firstDocumentLine);
    [CompilerGeneratedAttribute]
public TextDocument get_Document();
    [CompilerGeneratedAttribute]
private void set_Document(TextDocument value);
    [CompilerGeneratedAttribute]
public DocumentLine get_FirstDocumentLine();
    [CompilerGeneratedAttribute]
private void set_FirstDocumentLine(DocumentLine value);
    [CompilerGeneratedAttribute]
public DocumentLine get_LastDocumentLine();
    [CompilerGeneratedAttribute]
private void set_LastDocumentLine(DocumentLine value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<VisualLineElement> get_Elements();
    [CompilerGeneratedAttribute]
private void set_Elements(ReadOnlyCollection`1<VisualLineElement> value);
    public ReadOnlyCollection`1<TextLine> get_TextLines();
    public int get_StartOffset();
    [CompilerGeneratedAttribute]
public int get_VisualLength();
    [CompilerGeneratedAttribute]
private void set_VisualLength(int value);
    public int get_VisualLengthWithEndOfLineMarker();
    [CompilerGeneratedAttribute]
public double get_Height();
    [CompilerGeneratedAttribute]
private void set_Height(double value);
    [CompilerGeneratedAttribute]
public double get_VisualTop();
    [CompilerGeneratedAttribute]
internal void set_VisualTop(double value);
    internal void ConstructVisualElements(ITextRunConstructionContext context, VisualLineElementGenerator[] generators);
    private void PerformVisualElementConstruction(VisualLineElementGenerator[] generators);
    private void CalculateOffsets();
    internal void RunTransformers(ITextRunConstructionContext context, IVisualLineTransformer[] transformers);
    public void ReplaceElement(int elementIndex, VisualLineElement[] newElements);
    public void ReplaceElement(int elementIndex, int count, VisualLineElement[] newElements);
    internal void SetTextLines(List`1<TextLine> textLines);
    public int GetVisualColumn(int relativeTextOffset);
    public int GetRelativeOffset(int visualColumn);
    public TextLine GetTextLine(int visualColumn);
    public TextLine GetTextLine(int visualColumn, bool isAtEndOfLine);
    public double GetTextLineVisualYPosition(TextLine textLine, VisualYPosition yPositionMode);
    public int GetTextLineVisualStartColumn(TextLine textLine);
    public TextLine GetTextLineByVisualYPosition(double visualTop);
    public Point GetVisualPosition(int visualColumn, VisualYPosition yPositionMode);
    internal Point GetVisualPosition(int visualColumn, bool isAtEndOfLine, VisualYPosition yPositionMode);
    public double GetTextLineVisualXPosition(TextLine textLine, int visualColumn);
    public int GetVisualColumn(Point point);
    public int GetVisualColumn(Point point, bool allowVirtualSpace);
    internal int GetVisualColumn(Point point, bool allowVirtualSpace, Boolean& isAtEndOfLine);
    public int GetVisualColumn(TextLine textLine, double xPos, bool allowVirtualSpace);
    public int ValidateVisualColumn(TextViewPosition position, bool allowVirtualSpace);
    public int ValidateVisualColumn(int offset, int visualColumn, bool allowVirtualSpace);
    public int GetVisualColumnFloor(Point point);
    public int GetVisualColumnFloor(Point point, bool allowVirtualSpace);
    internal int GetVisualColumnFloor(Point point, bool allowVirtualSpace, Boolean& isAtEndOfLine);
    public TextViewPosition GetTextViewPosition(int visualColumn);
    public TextViewPosition GetTextViewPosition(Point visualPosition, bool allowVirtualSpace);
    public TextViewPosition GetTextViewPositionFloor(Point visualPosition, bool allowVirtualSpace);
    public bool get_IsDisposed();
    internal void Dispose();
    public int GetNextCaretPosition(int visualColumn, LogicalDirection direction, CaretPositioningMode mode, bool allowVirtualSpace);
    private static bool HasStopsInVirtualSpace(CaretPositioningMode mode);
    private static bool HasImplicitStopAtLineStart(CaretPositioningMode mode);
    private static bool HasImplicitStopAtLineEnd(CaretPositioningMode mode);
    internal VisualLineDrawingVisual Render();
}
public class ICSharpCode.AvalonEdit.Rendering.VisualLineConstructionStartEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DocumentLine <FirstLineInView>k__BackingField;
    public DocumentLine FirstLineInView { get; private set; }
    public VisualLineConstructionStartEventArgs(DocumentLine firstLineInView);
    [CompilerGeneratedAttribute]
public DocumentLine get_FirstLineInView();
    [CompilerGeneratedAttribute]
private void set_FirstLineInView(DocumentLine value);
}
internal class ICSharpCode.AvalonEdit.Rendering.VisualLineDrawingVisual : DrawingVisual {
    public VisualLine VisualLine;
    public double Height;
    internal bool IsAdded;
    public VisualLineDrawingVisual(VisualLine visualLine, FlowDirection flow);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
}
public abstract class ICSharpCode.AvalonEdit.Rendering.VisualLineElement : object {
    [CompilerGeneratedAttribute]
private int <VisualLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VisualColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RelativeTextOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private VisualLineElementTextRunProperties <TextRunProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private Brush <BackgroundBrush>k__BackingField;
    public int VisualLength { get; private set; }
    public int DocumentLength { get; private set; }
    public int VisualColumn { get; internal set; }
    public int RelativeTextOffset { get; internal set; }
    public VisualLineElementTextRunProperties TextRunProperties { get; private set; }
    public Brush BackgroundBrush { get; public set; }
    public bool CanSplit { get; }
    public bool HandlesLineBorders { get; }
    protected VisualLineElement(int visualLength, int documentLength);
    [CompilerGeneratedAttribute]
public int get_VisualLength();
    [CompilerGeneratedAttribute]
private void set_VisualLength(int value);
    [CompilerGeneratedAttribute]
public int get_DocumentLength();
    [CompilerGeneratedAttribute]
private void set_DocumentLength(int value);
    [CompilerGeneratedAttribute]
public int get_VisualColumn();
    [CompilerGeneratedAttribute]
internal void set_VisualColumn(int value);
    [CompilerGeneratedAttribute]
public int get_RelativeTextOffset();
    [CompilerGeneratedAttribute]
internal void set_RelativeTextOffset(int value);
    [CompilerGeneratedAttribute]
public VisualLineElementTextRunProperties get_TextRunProperties();
    [CompilerGeneratedAttribute]
private void set_TextRunProperties(VisualLineElementTextRunProperties value);
    [CompilerGeneratedAttribute]
public Brush get_BackgroundBrush();
    [CompilerGeneratedAttribute]
public void set_BackgroundBrush(Brush value);
    internal void SetTextRunProperties(VisualLineElementTextRunProperties p);
    public abstract virtual TextRun CreateTextRun(int startVisualColumn, ITextRunConstructionContext context);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int visualColumnLimit, ITextRunConstructionContext context);
    public virtual bool get_CanSplit();
    public virtual void Split(int splitVisualColumn, IList`1<VisualLineElement> elements, int elementIndex);
    protected void SplitHelper(VisualLineElement firstPart, VisualLineElement secondPart, int splitVisualColumn, int splitRelativeTextOffset);
    public virtual int GetVisualColumn(int relativeTextOffset);
    public virtual int GetRelativeOffset(int visualColumn);
    public virtual int GetNextCaretPosition(int visualColumn, LogicalDirection direction, CaretPositioningMode mode);
    public virtual bool IsWhitespace(int visualColumn);
    public virtual bool get_HandlesLineBorders();
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
}
public abstract class ICSharpCode.AvalonEdit.Rendering.VisualLineElementGenerator : object {
    [CompilerGeneratedAttribute]
private ITextRunConstructionContext <CurrentContext>k__BackingField;
    internal int cachedInterest;
    protected ITextRunConstructionContext CurrentContext { get; private set; }
    [CompilerGeneratedAttribute]
protected ITextRunConstructionContext get_CurrentContext();
    [CompilerGeneratedAttribute]
private void set_CurrentContext(ITextRunConstructionContext value);
    public virtual void StartGeneration(ITextRunConstructionContext context);
    public virtual void FinishGeneration();
    public abstract virtual int GetFirstInterestedOffset(int startOffset);
    public abstract virtual VisualLineElement ConstructElement(int offset);
}
public class ICSharpCode.AvalonEdit.Rendering.VisualLineElementTextRunProperties : TextRunProperties {
    private Brush backgroundBrush;
    private BaselineAlignment baselineAlignment;
    private CultureInfo cultureInfo;
    private double fontHintingEmSize;
    private double fontRenderingEmSize;
    private Brush foregroundBrush;
    private Typeface typeface;
    private TextDecorationCollection textDecorations;
    private TextEffectCollection textEffects;
    private TextRunTypographyProperties typographyProperties;
    private NumberSubstitution numberSubstitution;
    public Brush BackgroundBrush { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public CultureInfo CultureInfo { get; }
    public double FontHintingEmSize { get; }
    public double FontRenderingEmSize { get; }
    public Brush ForegroundBrush { get; }
    public Typeface Typeface { get; }
    public TextDecorationCollection TextDecorations { get; }
    public TextEffectCollection TextEffects { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public VisualLineElementTextRunProperties(TextRunProperties textRunProperties);
    public virtual VisualLineElementTextRunProperties Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public virtual Brush get_BackgroundBrush();
    public void SetBackgroundBrush(Brush value);
    public virtual BaselineAlignment get_BaselineAlignment();
    public void SetBaselineAlignment(BaselineAlignment value);
    public virtual CultureInfo get_CultureInfo();
    public void SetCultureInfo(CultureInfo value);
    public virtual double get_FontHintingEmSize();
    public void SetFontHintingEmSize(double value);
    public virtual double get_FontRenderingEmSize();
    public void SetFontRenderingEmSize(double value);
    public virtual Brush get_ForegroundBrush();
    public void SetForegroundBrush(Brush value);
    public virtual Typeface get_Typeface();
    public void SetTypeface(Typeface value);
    public virtual TextDecorationCollection get_TextDecorations();
    public void SetTextDecorations(TextDecorationCollection value);
    public virtual TextEffectCollection get_TextEffects();
    public void SetTextEffects(TextEffectCollection value);
    public virtual TextRunTypographyProperties get_TypographyProperties();
    public void SetTypographyProperties(TextRunTypographyProperties value);
    public virtual NumberSubstitution get_NumberSubstitution();
    public void SetNumberSubstitution(NumberSubstitution value);
}
public class ICSharpCode.AvalonEdit.Rendering.VisualLineLinkText : VisualLineText {
    [CompilerGeneratedAttribute]
private Uri <NavigateUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireControlModifierForClick>k__BackingField;
    public Uri NavigateUri { get; public set; }
    public string TargetName { get; public set; }
    public bool RequireControlModifierForClick { get; public set; }
    public VisualLineLinkText(VisualLine parentVisualLine, int length);
    [CompilerGeneratedAttribute]
public Uri get_NavigateUri();
    [CompilerGeneratedAttribute]
public void set_NavigateUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public void set_TargetName(string value);
    [CompilerGeneratedAttribute]
public bool get_RequireControlModifierForClick();
    [CompilerGeneratedAttribute]
public void set_RequireControlModifierForClick(bool value);
    public virtual TextRun CreateTextRun(int startVisualColumn, ITextRunConstructionContext context);
    protected virtual bool LinkIsClickable();
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual VisualLineText CreateInstance(int length);
}
public class ICSharpCode.AvalonEdit.Rendering.VisualLinesInvalidException : Exception {
    public VisualLinesInvalidException(string message);
    public VisualLinesInvalidException(string message, Exception innerException);
    protected VisualLinesInvalidException(SerializationInfo info, StreamingContext context);
}
public class ICSharpCode.AvalonEdit.Rendering.VisualLineText : VisualLineElement {
    private VisualLine parentVisualLine;
    public VisualLine ParentVisualLine { get; }
    public bool CanSplit { get; }
    public VisualLineText(VisualLine parentVisualLine, int length);
    public VisualLine get_ParentVisualLine();
    protected virtual VisualLineText CreateInstance(int length);
    public virtual TextRun CreateTextRun(int startVisualColumn, ITextRunConstructionContext context);
    public virtual bool IsWhitespace(int visualColumn);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int visualColumnLimit, ITextRunConstructionContext context);
    public virtual bool get_CanSplit();
    public virtual void Split(int splitVisualColumn, IList`1<VisualLineElement> elements, int elementIndex);
    public virtual int GetRelativeOffset(int visualColumn);
    public virtual int GetVisualColumn(int relativeTextOffset);
    public virtual int GetNextCaretPosition(int visualColumn, LogicalDirection direction, CaretPositioningMode mode);
}
internal class ICSharpCode.AvalonEdit.Rendering.VisualLineTextParagraphProperties : TextParagraphProperties {
    internal TextRunProperties defaultTextRunProperties;
    internal TextWrapping textWrapping;
    internal double tabSize;
    internal double indent;
    internal bool firstLineInParagraph;
    internal FlowDirection flowDirection;
    public double DefaultIncrementalTab { get; }
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextWrapping TextWrapping { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public double Indent { get; }
    public virtual double get_DefaultIncrementalTab();
    public virtual FlowDirection get_FlowDirection();
    public virtual TextAlignment get_TextAlignment();
    public virtual double get_LineHeight();
    public virtual bool get_FirstLineInParagraph();
    public virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextWrapping get_TextWrapping();
    public virtual TextMarkerProperties get_TextMarkerProperties();
    public virtual double get_Indent();
}
internal class ICSharpCode.AvalonEdit.Rendering.VisualLineTextSource : TextSource {
    [CompilerGeneratedAttribute]
private VisualLine <VisualLine>k__BackingField;
    [CompilerGeneratedAttribute]
private TextView <TextView>k__BackingField;
    [CompilerGeneratedAttribute]
private TextDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRunProperties <GlobalTextRunProperties>k__BackingField;
    private string cachedString;
    private int cachedStringOffset;
    public VisualLine VisualLine { get; private set; }
    public TextView TextView { get; public set; }
    public TextDocument Document { get; public set; }
    public TextRunProperties GlobalTextRunProperties { get; public set; }
    public VisualLineTextSource(VisualLine visualLine);
    [CompilerGeneratedAttribute]
public sealed virtual VisualLine get_VisualLine();
    [CompilerGeneratedAttribute]
private void set_VisualLine(VisualLine value);
    [CompilerGeneratedAttribute]
public sealed virtual TextView get_TextView();
    [CompilerGeneratedAttribute]
public void set_TextView(TextView value);
    [CompilerGeneratedAttribute]
public sealed virtual TextDocument get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(TextDocument value);
    [CompilerGeneratedAttribute]
public sealed virtual TextRunProperties get_GlobalTextRunProperties();
    [CompilerGeneratedAttribute]
public void set_GlobalTextRunProperties(TextRunProperties value);
    public virtual TextRun GetTextRun(int textSourceCharacterIndex);
    private TextRun CreateTextRunForNewLine();
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    public sealed virtual StringSegment GetText(int offset, int length);
}
public enum ICSharpCode.AvalonEdit.Rendering.VisualYPosition : Enum {
    public int value__;
    public static VisualYPosition LineTop;
    public static VisualYPosition TextTop;
    public static VisualYPosition LineBottom;
    public static VisualYPosition LineMiddle;
    public static VisualYPosition TextBottom;
    public static VisualYPosition TextMiddle;
    public static VisualYPosition Baseline;
}
public class ICSharpCode.AvalonEdit.Search.DropDownButton : ButtonBase {
    public static DependencyProperty DropDownContentProperty;
    protected static DependencyPropertyKey IsDropDownContentOpenPropertyKey;
    public static DependencyProperty IsDropDownContentOpenProperty;
    public Popup DropDownContent { get; public set; }
    public bool IsDropDownContentOpen { get; protected set; }
    private static DropDownButton();
    public Popup get_DropDownContent();
    public void set_DropDownContent(Popup value);
    public bool get_IsDropDownContentOpen();
    protected void set_IsDropDownContentOpen(bool value);
    protected virtual void OnClick();
    private void DropDownContent_Closed(object sender, EventArgs e);
}
public interface ICSharpCode.AvalonEdit.Search.ISearchResult {
    public abstract virtual string ReplaceWith(string replacement);
}
public interface ICSharpCode.AvalonEdit.Search.ISearchStrategy {
    public abstract virtual IEnumerable`1<ISearchResult> FindAll(ITextSource document, int offset, int length);
    public abstract virtual ISearchResult FindNext(ITextSource document, int offset, int length);
}
public class ICSharpCode.AvalonEdit.Search.Localization : object {
    public string MatchCaseText { get; }
    public string MatchWholeWordsText { get; }
    public string UseRegexText { get; }
    public string FindNextText { get; }
    public string FindPreviousText { get; }
    public string ErrorText { get; }
    public string NoMatchesFoundText { get; }
    public virtual string get_MatchCaseText();
    public virtual string get_MatchWholeWordsText();
    public virtual string get_UseRegexText();
    public virtual string get_FindNextText();
    public virtual string get_FindPreviousText();
    public virtual string get_ErrorText();
    public virtual string get_NoMatchesFoundText();
}
internal class ICSharpCode.AvalonEdit.Search.RegexSearchStrategy : object {
    private Regex searchPattern;
    private bool matchWholeWords;
    public RegexSearchStrategy(Regex searchPattern, bool matchWholeWords);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Search.RegexSearchStrategy/<FindAll>d__3")]
public sealed virtual IEnumerable`1<ISearchResult> FindAll(ITextSource document, int offset, int length);
    private static bool IsWordBorder(ITextSource document, int offset);
    public sealed virtual ISearchResult FindNext(ITextSource document, int offset, int length);
    public sealed virtual bool Equals(ISearchStrategy other);
}
public static class ICSharpCode.AvalonEdit.Search.SearchCommands : object {
    public static RoutedCommand FindNext;
    public static RoutedCommand FindPrevious;
    public static RoutedCommand CloseSearchPanel;
    private static SearchCommands();
}
public class ICSharpCode.AvalonEdit.Search.SearchInputHandler : TextAreaInputHandler {
    private SearchPanel panel;
    internal SearchInputHandler(TextArea textArea, SearchPanel panel);
    internal void RegisterGlobalCommands(CommandBindingCollection commandBindings);
    private void RegisterCommands(ICollection`1<CommandBinding> commandBindings);
    private void ExecuteFind(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteWithOpenSearchPanel(object sender, CanExecuteRoutedEventArgs e);
    private void ExecuteFindNext(object sender, ExecutedRoutedEventArgs e);
    private void ExecuteFindPrevious(object sender, ExecutedRoutedEventArgs e);
    private void ExecuteCloseSearchPanel(object sender, ExecutedRoutedEventArgs e);
    public void add_SearchOptionsChanged(EventHandler`1<SearchOptionsChangedEventArgs> value);
    public void remove_SearchOptionsChanged(EventHandler`1<SearchOptionsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private void <ExecuteFind>b__4_0();
}
public enum ICSharpCode.AvalonEdit.Search.SearchMode : Enum {
    public int value__;
    public static SearchMode Normal;
    public static SearchMode RegEx;
    public static SearchMode Wildcard;
}
public class ICSharpCode.AvalonEdit.Search.SearchOptionsChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <SearchPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchCase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WholeWords>k__BackingField;
    public string SearchPattern { get; private set; }
    public bool MatchCase { get; private set; }
    public bool UseRegex { get; private set; }
    public bool WholeWords { get; private set; }
    public SearchOptionsChangedEventArgs(string searchPattern, bool matchCase, bool useRegex, bool wholeWords);
    [CompilerGeneratedAttribute]
public string get_SearchPattern();
    [CompilerGeneratedAttribute]
private void set_SearchPattern(string value);
    [CompilerGeneratedAttribute]
public bool get_MatchCase();
    [CompilerGeneratedAttribute]
private void set_MatchCase(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseRegex();
    [CompilerGeneratedAttribute]
private void set_UseRegex(bool value);
    [CompilerGeneratedAttribute]
public bool get_WholeWords();
    [CompilerGeneratedAttribute]
private void set_WholeWords(bool value);
}
public class ICSharpCode.AvalonEdit.Search.SearchPanel : Control {
    private TextArea textArea;
    private SearchInputHandler handler;
    private TextDocument currentDocument;
    private SearchResultBackgroundRenderer renderer;
    private TextBox searchTextBox;
    private Popup dropdownPopup;
    private SearchPanelAdorner adorner;
    public static DependencyProperty UseRegexProperty;
    public static DependencyProperty MatchCaseProperty;
    public static DependencyProperty WholeWordsProperty;
    public static DependencyProperty SearchPatternProperty;
    public static DependencyProperty MarkerBrushProperty;
    public static DependencyProperty MarkerPenProperty;
    public static DependencyProperty MarkerCornerRadiusProperty;
    public static DependencyProperty LocalizationProperty;
    private ISearchStrategy strategy;
    private ToolTip messageView;
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<SearchOptionsChangedEventArgs> SearchOptionsChanged;
    public bool UseRegex { get; public set; }
    public bool MatchCase { get; public set; }
    public bool WholeWords { get; public set; }
    public string SearchPattern { get; public set; }
    public Brush MarkerBrush { get; public set; }
    public Pen MarkerPen { get; public set; }
    public double MarkerCornerRadius { get; public set; }
    public Localization Localization { get; public set; }
    public bool IsClosed { get; private set; }
    private static SearchPanel();
    public bool get_UseRegex();
    public void set_UseRegex(bool value);
    public bool get_MatchCase();
    public void set_MatchCase(bool value);
    public bool get_WholeWords();
    public void set_WholeWords(bool value);
    public string get_SearchPattern();
    public void set_SearchPattern(string value);
    public Brush get_MarkerBrush();
    public void set_MarkerBrush(Brush value);
    private static void MarkerBrushChangedCallback(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Pen get_MarkerPen();
    public void set_MarkerPen(Pen value);
    private static void MarkerPenChangedCallback(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_MarkerCornerRadius();
    public void set_MarkerCornerRadius(double value);
    private static void MarkerCornerRadiusChangedCallback(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Localization get_Localization();
    public void set_Localization(Localization value);
    private static void SearchPatternChangedCallback(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void UpdateSearch();
    public static SearchPanel Install(TextEditor editor);
    public static SearchPanel Install(TextArea textArea);
    public void RegisterCommands(CommandBindingCollection commandBindings);
    public void Uninstall();
    private void AttachInternal(TextArea textArea);
    private void textArea_DocumentChanged(object sender, EventArgs e);
    private void textArea_Document_TextChanged(object sender, EventArgs e);
    public virtual void OnApplyTemplate();
    private void ValidateSearchText();
    public void Reactivate();
    public void FindNext();
    public void FindPrevious();
    private void DoSearch(bool changeSelection);
    private void SelectResult(SearchResult result);
    private void SearchLayerKeyDown(object sender, KeyEventArgs e);
    [CompilerGeneratedAttribute]
public bool get_IsClosed();
    [CompilerGeneratedAttribute]
private void set_IsClosed(bool value);
    public void Close();
    public void Open();
    [CompilerGeneratedAttribute]
public void add_SearchOptionsChanged(EventHandler`1<SearchOptionsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SearchOptionsChanged(EventHandler`1<SearchOptionsChangedEventArgs> value);
    protected virtual void OnSearchOptionsChanged(SearchOptionsChangedEventArgs e);
    [CompilerGeneratedAttribute]
private void <AttachInternal>b__51_0(object sender, ExecutedRoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <AttachInternal>b__51_1(object sender, ExecutedRoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <AttachInternal>b__51_2(object sender, ExecutedRoutedEventArgs e);
}
internal class ICSharpCode.AvalonEdit.Search.SearchPanelAdorner : Adorner {
    private SearchPanel panel;
    protected int VisualChildrenCount { get; }
    public SearchPanelAdorner(TextArea textArea, SearchPanel panel);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual Size ArrangeOverride(Size finalSize);
}
public class ICSharpCode.AvalonEdit.Search.SearchPatternException : Exception {
    public SearchPatternException(string message);
    public SearchPatternException(string message, Exception innerException);
    protected SearchPatternException(SerializationInfo info, StreamingContext context);
}
internal class ICSharpCode.AvalonEdit.Search.SearchResult : TextSegment {
    [CompilerGeneratedAttribute]
private Match <Data>k__BackingField;
    public Match Data { get; public set; }
    [CompilerGeneratedAttribute]
public Match get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Match value);
    public sealed virtual string ReplaceWith(string replacement);
}
internal class ICSharpCode.AvalonEdit.Search.SearchResultBackgroundRenderer : object {
    private TextSegmentCollection`1<SearchResult> currentResults;
    [CompilerGeneratedAttribute]
private Brush <MarkerBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private Pen <MarkerPen>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MarkerCornerRadius>k__BackingField;
    public TextSegmentCollection`1<SearchResult> CurrentResults { get; }
    public KnownLayer Layer { get; }
    public Brush MarkerBrush { get; public set; }
    public Pen MarkerPen { get; public set; }
    public double MarkerCornerRadius { get; public set; }
    public TextSegmentCollection`1<SearchResult> get_CurrentResults();
    public sealed virtual KnownLayer get_Layer();
    [CompilerGeneratedAttribute]
public Brush get_MarkerBrush();
    [CompilerGeneratedAttribute]
public void set_MarkerBrush(Brush value);
    [CompilerGeneratedAttribute]
public Pen get_MarkerPen();
    [CompilerGeneratedAttribute]
public void set_MarkerPen(Pen value);
    [CompilerGeneratedAttribute]
public double get_MarkerCornerRadius();
    [CompilerGeneratedAttribute]
public void set_MarkerCornerRadius(double value);
    public sealed virtual void Draw(TextView textView, DrawingContext drawingContext);
}
public static class ICSharpCode.AvalonEdit.Search.SearchStrategyFactory : object {
    public static ISearchStrategy Create(string searchPattern, bool ignoreCase, bool matchWholeWords, SearchMode mode);
    private static string ConvertWildcardsToRegex(string searchPattern);
}
public class ICSharpCode.AvalonEdit.Snippets.AnchorElement : object {
    private AnchorSegment segment;
    private InsertionContext context;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool IsEditable { get; }
    public ISegment Segment { get; }
    public string Text { get; public set; }
    public string Name { get; private set; }
    public AnchorElement(AnchorSegment segment, string name, InsertionContext context);
    public sealed virtual bool get_IsEditable();
    public sealed virtual ISegment get_Segment();
    public string get_Text();
    public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public sealed virtual void OnInsertionCompleted();
    public sealed virtual void Deactivate(SnippetEventArgs e);
}
internal class ICSharpCode.AvalonEdit.Snippets.BoundActiveElement : object {
    private InsertionContext context;
    private SnippetReplaceableTextElement targetSnippetElement;
    private SnippetBoundElement boundElement;
    internal IReplaceableActiveElement targetElement;
    private AnchorSegment segment;
    public bool IsEditable { get; }
    public ISegment Segment { get; }
    public BoundActiveElement(InsertionContext context, SnippetReplaceableTextElement targetSnippetElement, SnippetBoundElement boundElement, AnchorSegment segment);
    public sealed virtual void OnInsertionCompleted();
    private void targetElement_TextChanged(object sender, EventArgs e);
    public sealed virtual void Deactivate(SnippetEventArgs e);
    public sealed virtual bool get_IsEditable();
    public sealed virtual ISegment get_Segment();
}
public enum ICSharpCode.AvalonEdit.Snippets.DeactivateReason : Enum {
    public int value__;
    public static DeactivateReason Unknown;
    public static DeactivateReason Deleted;
    public static DeactivateReason NoActiveElements;
    public static DeactivateReason InputHandlerDetached;
    public static DeactivateReason ReturnPressed;
    public static DeactivateReason EscapePressed;
}
public interface ICSharpCode.AvalonEdit.Snippets.IActiveElement {
    public bool IsEditable { get; }
    public ISegment Segment { get; }
    public abstract virtual void OnInsertionCompleted();
    public abstract virtual void Deactivate(SnippetEventArgs e);
    public abstract virtual bool get_IsEditable();
    public abstract virtual ISegment get_Segment();
}
public class ICSharpCode.AvalonEdit.Snippets.InsertionContext : object {
    private Status currentStatus;
    [CompilerGeneratedAttribute]
private TextArea <TextArea>k__BackingField;
    [CompilerGeneratedAttribute]
private TextDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indentation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tab>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LineTerminator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InsertionPosition>k__BackingField;
    private int startPosition;
    private AnchorSegment wholeSnippetAnchor;
    private bool deactivateIfSnippetEmpty;
    private Dictionary`2<SnippetElement, IActiveElement> elementMap;
    private List`1<IActiveElement> registeredElements;
    private SnippetInputHandler myInputHandler;
    [CompilerGeneratedAttribute]
private EventHandler InsertionCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<SnippetEventArgs> Deactivated;
    public TextArea TextArea { get; private set; }
    public TextDocument Document { get; private set; }
    public string SelectedText { get; private set; }
    public string Indentation { get; private set; }
    public string Tab { get; private set; }
    public string LineTerminator { get; private set; }
    public int InsertionPosition { get; public set; }
    public int StartPosition { get; }
    public IEnumerable`1<IActiveElement> ActiveElements { get; }
    public InsertionContext(TextArea textArea, int insertionPosition);
    [CompilerGeneratedAttribute]
public TextArea get_TextArea();
    [CompilerGeneratedAttribute]
private void set_TextArea(TextArea value);
    [CompilerGeneratedAttribute]
public TextDocument get_Document();
    [CompilerGeneratedAttribute]
private void set_Document(TextDocument value);
    [CompilerGeneratedAttribute]
public string get_SelectedText();
    [CompilerGeneratedAttribute]
private void set_SelectedText(string value);
    [CompilerGeneratedAttribute]
public string get_Indentation();
    [CompilerGeneratedAttribute]
private void set_Indentation(string value);
    [CompilerGeneratedAttribute]
public string get_Tab();
    [CompilerGeneratedAttribute]
private void set_Tab(string value);
    [CompilerGeneratedAttribute]
public string get_LineTerminator();
    [CompilerGeneratedAttribute]
private void set_LineTerminator(string value);
    [CompilerGeneratedAttribute]
public int get_InsertionPosition();
    [CompilerGeneratedAttribute]
public void set_InsertionPosition(int value);
    public int get_StartPosition();
    public void InsertText(string text);
    public void RegisterActiveElement(SnippetElement owner, IActiveElement element);
    public IActiveElement GetActiveElement(SnippetElement owner);
    public IEnumerable`1<IActiveElement> get_ActiveElements();
    public void RaiseInsertionCompleted(EventArgs e);
    [CompilerGeneratedAttribute]
public void add_InsertionCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InsertionCompleted(EventHandler value);
    public void Deactivate(SnippetEventArgs e);
    [CompilerGeneratedAttribute]
public void add_Deactivated(EventHandler`1<SnippetEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Deactivated(EventHandler`1<SnippetEventArgs> value);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    public void Link(ISegment mainElement, ISegment[] boundElements);
}
public interface ICSharpCode.AvalonEdit.Snippets.IReplaceableActiveElement {
    public string Text { get; }
    public abstract virtual string get_Text();
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextChanged(EventHandler value);
}
internal class ICSharpCode.AvalonEdit.Snippets.ReplaceableActiveElement : object {
    private InsertionContext context;
    private int startOffset;
    private int endOffset;
    private TextAnchor start;
    private TextAnchor end;
    private bool isCaretInside;
    private Renderer background;
    private Renderer foreground;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler TextChanged;
    public string Text { get; private set; }
    public bool IsEditable { get; }
    public ISegment Segment { get; }
    public ReplaceableActiveElement(InsertionContext context, int startOffset, int endOffset);
    private void AnchorDeleted(object sender, EventArgs e);
    public sealed virtual void OnInsertionCompleted();
    public sealed virtual void Deactivate(SnippetEventArgs e);
    private void Caret_PositionChanged(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    private string GetText();
    [CompilerGeneratedAttribute]
public sealed virtual void add_TextChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TextChanged(EventHandler value);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    public sealed virtual bool get_IsEditable();
    public sealed virtual ISegment get_Segment();
}
public class ICSharpCode.AvalonEdit.Snippets.Snippet : SnippetContainerElement {
    public void Insert(TextArea textArea);
}
public class ICSharpCode.AvalonEdit.Snippets.SnippetAnchorElement : SnippetElement {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public SnippetAnchorElement(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public virtual void Insert(InsertionContext context);
}
public class ICSharpCode.AvalonEdit.Snippets.SnippetBoundElement : SnippetElement {
    private SnippetReplaceableTextElement targetElement;
    public SnippetReplaceableTextElement TargetElement { get; public set; }
    public SnippetReplaceableTextElement get_TargetElement();
    public void set_TargetElement(SnippetReplaceableTextElement value);
    public virtual string ConvertText(string input);
    public virtual void Insert(InsertionContext context);
    public virtual Inline ToTextRun();
}
public class ICSharpCode.AvalonEdit.Snippets.SnippetCaretElement : SnippetElement {
    [OptionalFieldAttribute]
private bool setCaretOnlyIfTextIsSelected;
    public SnippetCaretElement(bool setCaretOnlyIfTextIsSelected);
    public virtual void Insert(InsertionContext context);
    internal static void SetCaret(InsertionContext context);
}
public class ICSharpCode.AvalonEdit.Snippets.SnippetContainerElement : SnippetElement {
    private NullSafeCollection`1<SnippetElement> elements;
    public IList`1<SnippetElement> Elements { get; }
    public IList`1<SnippetElement> get_Elements();
    public virtual void Insert(InsertionContext context);
    public virtual Inline ToTextRun();
}
public abstract class ICSharpCode.AvalonEdit.Snippets.SnippetElement : object {
    public abstract virtual void Insert(InsertionContext context);
    public virtual Inline ToTextRun();
}
public class ICSharpCode.AvalonEdit.Snippets.SnippetEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DeactivateReason <Reason>k__BackingField;
    public DeactivateReason Reason { get; private set; }
    public SnippetEventArgs(DeactivateReason reason);
    [CompilerGeneratedAttribute]
public DeactivateReason get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(DeactivateReason value);
}
internal class ICSharpCode.AvalonEdit.Snippets.SnippetInputHandler : TextAreaStackedInputHandler {
    private InsertionContext context;
    public SnippetInputHandler(InsertionContext context);
    public virtual void Attach();
    public virtual void Detach();
    public virtual void OnPreviewKeyDown(KeyEventArgs e);
    private void SelectElement(IActiveElement element);
    private IActiveElement FindNextEditableElement(int offset, bool backwards);
}
public class ICSharpCode.AvalonEdit.Snippets.SnippetReplaceableTextElement : SnippetTextElement {
    public virtual void Insert(InsertionContext context);
    public virtual Inline ToTextRun();
}
public class ICSharpCode.AvalonEdit.Snippets.SnippetSelectionElement : SnippetElement {
    [CompilerGeneratedAttribute]
private int <Indentation>k__BackingField;
    public int Indentation { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Indentation();
    [CompilerGeneratedAttribute]
public void set_Indentation(int value);
    public virtual void Insert(InsertionContext context);
}
public class ICSharpCode.AvalonEdit.Snippets.SnippetTextElement : SnippetElement {
    private string text;
    public string Text { get; public set; }
    public string get_Text();
    public void set_Text(string value);
    public virtual void Insert(InsertionContext context);
    public virtual Inline ToTextRun();
}
[LocalizabilityAttribute]
[ContentPropertyAttribute("Text")]
public class ICSharpCode.AvalonEdit.TextEditor : Control {
    public static DependencyProperty DocumentProperty;
    [CompilerGeneratedAttribute]
private EventHandler DocumentChanged;
    public static DependencyProperty OptionsProperty;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler OptionChanged;
    [CompilerGeneratedAttribute]
private EventHandler TextChanged;
    private TextArea textArea;
    private ScrollViewer scrollViewer;
    public static DependencyProperty SyntaxHighlightingProperty;
    private IVisualLineTransformer colorizer;
    public static DependencyProperty WordWrapProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty IsModifiedProperty;
    public static DependencyProperty ShowLineNumbersProperty;
    public static DependencyProperty LineNumbersForegroundProperty;
    public static DependencyProperty EncodingProperty;
    public static RoutedEvent PreviewMouseHoverEvent;
    public static RoutedEvent MouseHoverEvent;
    public static RoutedEvent PreviewMouseHoverStoppedEvent;
    public static RoutedEvent MouseHoverStoppedEvent;
    public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    public static DependencyProperty VerticalScrollBarVisibilityProperty;
    public TextDocument Document { get; public set; }
    public TextEditorOptions Options { get; public set; }
    [LocalizabilityAttribute]
[DefaultValueAttribute("")]
public string Text { get; public set; }
    public TextArea TextArea { get; }
    internal ScrollViewer ScrollViewer { get; }
    public IHighlightingDefinition SyntaxHighlighting { get; public set; }
    public bool WordWrap { get; public set; }
    public bool IsReadOnly { get; public set; }
    public bool IsModified { get; public set; }
    public bool ShowLineNumbers { get; public set; }
    public Brush LineNumbersForeground { get; public set; }
    public bool CanRedo { get; }
    public bool CanUndo { get; }
    public double ExtentHeight { get; }
    public double ExtentWidth { get; }
    public double ViewportHeight { get; }
    public double ViewportWidth { get; }
    public double VerticalOffset { get; }
    public double HorizontalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public string SelectedText { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public int CaretOffset { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public int SelectionStart { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public int SelectionLength { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public int LineCount { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public Encoding Encoding { get; public set; }
    public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    private static TextEditor();
    protected TextEditor(TextArea textArea);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual TextDocument get_Document();
    public void set_Document(TextDocument value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DocumentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DocumentChanged(EventHandler value);
    protected virtual void OnDocumentChanged(EventArgs e);
    private static void OnDocumentChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e);
    private void OnDocumentChanged(TextDocument oldValue, TextDocument newValue);
    public sealed virtual TextEditorOptions get_Options();
    public void set_Options(TextEditorOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OptionChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OptionChanged(PropertyChangedEventHandler value);
    protected virtual void OnOptionChanged(PropertyChangedEventArgs e);
    private static void OnOptionsChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e);
    private void OnOptionsChanged(TextEditorOptions oldValue, TextEditorOptions newValue);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    public string get_Text();
    public void set_Text(string value);
    private TextDocument GetDocument();
    [CompilerGeneratedAttribute]
public void add_TextChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TextChanged(EventHandler value);
    protected virtual void OnTextChanged(EventArgs e);
    public virtual void OnApplyTemplate();
    public TextArea get_TextArea();
    internal ScrollViewer get_ScrollViewer();
    private bool CanExecute(RoutedUICommand command);
    private void Execute(RoutedUICommand command);
    public IHighlightingDefinition get_SyntaxHighlighting();
    public void set_SyntaxHighlighting(IHighlightingDefinition value);
    private static void OnSyntaxHighlightingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnSyntaxHighlightingChanged(IHighlightingDefinition newValue);
    protected virtual IVisualLineTransformer CreateColorizer(IHighlightingDefinition highlightingDefinition);
    public bool get_WordWrap();
    public void set_WordWrap(bool value);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    private static void OnIsReadOnlyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsModified();
    public void set_IsModified(bool value);
    private static void OnIsModifiedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private bool HandleIsOriginalChanged(PropertyChangedEventArgs e);
    public bool get_ShowLineNumbers();
    public void set_ShowLineNumbers(bool value);
    private static void OnShowLineNumbersChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Brush get_LineNumbersForeground();
    public void set_LineNumbersForeground(Brush value);
    private static void OnLineNumbersForegroundChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void AppendText(string textData);
    public void BeginChange();
    public void Copy();
    public void Cut();
    public IDisposable DeclareChangeBlock();
    public void Delete();
    public void EndChange();
    public void LineDown();
    public void LineLeft();
    public void LineRight();
    public void LineUp();
    public void PageDown();
    public void PageUp();
    public void PageLeft();
    public void PageRight();
    public void Paste();
    public bool Redo();
    public void ScrollToEnd();
    public void ScrollToHome();
    public void ScrollToHorizontalOffset(double offset);
    public void ScrollToVerticalOffset(double offset);
    public void SelectAll();
    public bool Undo();
    public bool get_CanRedo();
    public bool get_CanUndo();
    public double get_ExtentHeight();
    public double get_ExtentWidth();
    public double get_ViewportHeight();
    public double get_ViewportWidth();
    public double get_VerticalOffset();
    public double get_HorizontalOffset();
    public string get_SelectedText();
    public void set_SelectedText(string value);
    public int get_CaretOffset();
    public void set_CaretOffset(int value);
    public int get_SelectionStart();
    public void set_SelectionStart(int value);
    public int get_SelectionLength();
    public void set_SelectionLength(int value);
    public void Select(int start, int length);
    public int get_LineCount();
    public void Clear();
    public void Load(Stream stream);
    public void Load(string fileName);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public void Save(Stream stream);
    public void Save(string fileName);
    public void add_PreviewMouseHover(MouseEventHandler value);
    public void remove_PreviewMouseHover(MouseEventHandler value);
    public void add_MouseHover(MouseEventHandler value);
    public void remove_MouseHover(MouseEventHandler value);
    public void add_PreviewMouseHoverStopped(MouseEventHandler value);
    public void remove_PreviewMouseHoverStopped(MouseEventHandler value);
    public void add_MouseHoverStopped(MouseEventHandler value);
    public void remove_MouseHoverStopped(MouseEventHandler value);
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    public Nullable`1<TextViewPosition> GetPositionFromPoint(Point point);
    public void ScrollToLine(int line);
    public void ScrollTo(int line, int column);
    public void ScrollTo(int line, int column, VisualYPosition yPositionMode, double referencedVerticalViewPortOffset, double minimumScrollFraction);
}
public class ICSharpCode.AvalonEdit.TextEditorAutomationPeer : FrameworkElementAutomationPeer {
    private TextEditor TextEditor { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    public TextEditorAutomationPeer(TextEditor owner);
    private TextEditor get_TextEditor();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    internal void RaiseIsReadOnlyChanged(bool oldValue, bool newValue);
}
public class ICSharpCode.AvalonEdit.TextEditorOptions : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private bool showSpaces;
    private bool showTabs;
    private bool showEndOfLine;
    private bool showBoxForControlCharacters;
    private bool enableHyperlinks;
    private bool enableEmailHyperlinks;
    private bool requireControlModifierForHyperlinkClick;
    private int indentationSize;
    private bool convertTabsToSpaces;
    private bool cutCopyWholeLine;
    private bool allowScrollBelowDocument;
    private double wordWrapIndentation;
    private bool inheritWordWrapIndentation;
    private bool enableRectangularSelection;
    private bool enableTextDragDrop;
    private bool enableVirtualSpace;
    private bool enableImeSupport;
    private bool showColumnRuler;
    private int columnRulerPosition;
    private bool highlightCurrentLine;
    private bool hideCursorWhileTyping;
    private bool allowToggleOverstrikeMode;
    [DefaultValueAttribute("False")]
public bool ShowSpaces { get; public set; }
    [DefaultValueAttribute("False")]
public bool ShowTabs { get; public set; }
    [DefaultValueAttribute("False")]
public bool ShowEndOfLine { get; public set; }
    [DefaultValueAttribute("True")]
public bool ShowBoxForControlCharacters { get; public set; }
    [DefaultValueAttribute("True")]
public bool EnableHyperlinks { get; public set; }
    [DefaultValueAttribute("True")]
public bool EnableEmailHyperlinks { get; public set; }
    [DefaultValueAttribute("True")]
public bool RequireControlModifierForHyperlinkClick { get; public set; }
    [DefaultValueAttribute("4")]
public int IndentationSize { get; public set; }
    [DefaultValueAttribute("False")]
public bool ConvertTabsToSpaces { get; public set; }
    [BrowsableAttribute("False")]
public string IndentationString { get; }
    [DefaultValueAttribute("True")]
public bool CutCopyWholeLine { get; public set; }
    [DefaultValueAttribute("False")]
public bool AllowScrollBelowDocument { get; public set; }
    [DefaultValueAttribute("0")]
public double WordWrapIndentation { get; public set; }
    [DefaultValueAttribute("True")]
public bool InheritWordWrapIndentation { get; public set; }
    [DefaultValueAttribute("True")]
public bool EnableRectangularSelection { get; public set; }
    [DefaultValueAttribute("True")]
public bool EnableTextDragDrop { get; public set; }
    [DefaultValueAttribute("False")]
public bool EnableVirtualSpace { get; public set; }
    [DefaultValueAttribute("True")]
public bool EnableImeSupport { get; public set; }
    [DefaultValueAttribute("False")]
public bool ShowColumnRuler { get; public set; }
    [DefaultValueAttribute("80")]
public int ColumnRulerPosition { get; public set; }
    [DefaultValueAttribute("False")]
public bool HighlightCurrentLine { get; public set; }
    [DefaultValueAttribute("True")]
public bool HideCursorWhileTyping { get; public set; }
    [DefaultValueAttribute("False")]
public bool AllowToggleOverstrikeMode { get; public set; }
    public TextEditorOptions(TextEditorOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    public virtual bool get_ShowSpaces();
    public virtual void set_ShowSpaces(bool value);
    public virtual bool get_ShowTabs();
    public virtual void set_ShowTabs(bool value);
    public virtual bool get_ShowEndOfLine();
    public virtual void set_ShowEndOfLine(bool value);
    public virtual bool get_ShowBoxForControlCharacters();
    public virtual void set_ShowBoxForControlCharacters(bool value);
    public virtual bool get_EnableHyperlinks();
    public virtual void set_EnableHyperlinks(bool value);
    public virtual bool get_EnableEmailHyperlinks();
    public virtual void set_EnableEmailHyperlinks(bool value);
    public virtual bool get_RequireControlModifierForHyperlinkClick();
    public virtual void set_RequireControlModifierForHyperlinkClick(bool value);
    public virtual int get_IndentationSize();
    public virtual void set_IndentationSize(int value);
    public virtual bool get_ConvertTabsToSpaces();
    public virtual void set_ConvertTabsToSpaces(bool value);
    public string get_IndentationString();
    public virtual string GetIndentationString(int column);
    public virtual bool get_CutCopyWholeLine();
    public virtual void set_CutCopyWholeLine(bool value);
    public virtual bool get_AllowScrollBelowDocument();
    public virtual void set_AllowScrollBelowDocument(bool value);
    public virtual double get_WordWrapIndentation();
    public virtual void set_WordWrapIndentation(double value);
    public virtual bool get_InheritWordWrapIndentation();
    public virtual void set_InheritWordWrapIndentation(bool value);
    public bool get_EnableRectangularSelection();
    public void set_EnableRectangularSelection(bool value);
    public bool get_EnableTextDragDrop();
    public void set_EnableTextDragDrop(bool value);
    public virtual bool get_EnableVirtualSpace();
    public virtual void set_EnableVirtualSpace(bool value);
    public virtual bool get_EnableImeSupport();
    public virtual void set_EnableImeSupport(bool value);
    public virtual bool get_ShowColumnRuler();
    public virtual void set_ShowColumnRuler(bool value);
    public virtual int get_ColumnRulerPosition();
    public virtual void set_ColumnRulerPosition(int value);
    public virtual bool get_HighlightCurrentLine();
    public virtual void set_HighlightCurrentLine(bool value);
    public bool get_HideCursorWhileTyping();
    public void set_HideCursorWhileTyping(bool value);
    public bool get_AllowToggleOverstrikeMode();
    public void set_AllowToggleOverstrikeMode(bool value);
}
public static class ICSharpCode.AvalonEdit.TextEditorWeakEventManager : object {
}
public class ICSharpCode.AvalonEdit.TextViewPosition : ValueType {
    private int line;
    private int column;
    private int visualColumn;
    private bool isAtEndOfLine;
    public TextLocation Location { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int VisualColumn { get; public set; }
    public bool IsAtEndOfLine { get; public set; }
    public TextViewPosition(int line, int column, int visualColumn);
    public TextViewPosition(int line, int column);
    public TextViewPosition(TextLocation location, int visualColumn);
    public TextViewPosition(TextLocation location);
    public TextLocation get_Location();
    public void set_Location(TextLocation value);
    public int get_Line();
    public void set_Line(int value);
    public int get_Column();
    public void set_Column(int value);
    public int get_VisualColumn();
    public void set_VisualColumn(int value);
    public bool get_IsAtEndOfLine();
    public void set_IsAtEndOfLine(bool value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TextViewPosition other);
    public static bool op_Equality(TextViewPosition left, TextViewPosition right);
    public static bool op_Inequality(TextViewPosition left, TextViewPosition right);
    public sealed virtual int CompareTo(TextViewPosition other);
}
internal abstract class ICSharpCode.AvalonEdit.Utils.AbstractFreezable : object {
    private bool isFrozen;
    public bool IsFrozen { get; }
    public sealed virtual bool get_IsFrozen();
    public sealed virtual void Freeze();
    protected virtual void FreezeInternal();
}
internal static class ICSharpCode.AvalonEdit.Utils.Boxes : object {
    public static object True;
    public static object False;
    private static Boxes();
    public static object Box(bool value);
}
internal static class ICSharpCode.AvalonEdit.Utils.BusyManager : object {
    [ThreadStaticAttribute]
private static List`1<object> _activeObjects;
    public static BusyLock Enter(object obj);
}
internal class ICSharpCode.AvalonEdit.Utils.CallbackOnDispose : object {
    private Action action;
    public CallbackOnDispose(Action action);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class ICSharpCode.AvalonEdit.Utils.CharRope : object {
    public static Rope`1<char> Create(string text);
    [ExtensionAttribute]
public static string ToString(Rope`1<char> rope, int startIndex, int length);
    [ExtensionAttribute]
public static void WriteTo(Rope`1<char> rope, TextWriter output, int startIndex, int length);
    [ExtensionAttribute]
public static void AddText(Rope`1<char> rope, string text);
    [ExtensionAttribute]
public static void InsertText(Rope`1<char> rope, int index, string text);
    internal static RopeNode`1<char> InitFromString(string text);
    private static void FillNode(RopeNode`1<char> node, string text, int start);
    [ExtensionAttribute]
internal static void WriteTo(RopeNode`1<char> node, int index, TextWriter output, int count);
    [ExtensionAttribute]
public static int IndexOfAny(Rope`1<char> rope, Char[] anyOf, int startIndex, int length);
    [ExtensionAttribute]
public static int IndexOf(Rope`1<char> rope, string searchText, int startIndex, int length, StringComparison comparisonType);
    [ExtensionAttribute]
public static int LastIndexOf(Rope`1<char> rope, string searchText, int startIndex, int length, StringComparison comparisonType);
}
[DefaultMemberAttribute("Item")]
public class ICSharpCode.AvalonEdit.Utils.CompressingTreeList`1 : object {
    private Func`3<T, T, bool> comparisonFunc;
    private Node<T> root;
    internal static bool RED;
    internal static bool BLACK;
    public T Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public CompressingTreeList`1(IEqualityComparer`1<T> equalityComparer);
    public CompressingTreeList`1(Func`3<T, T, bool> comparisonFunc);
    public void InsertRange(int index, int count, T item);
    private void InsertBefore(Node<T> node, Node<T> newNode);
    public void RemoveRange(int index, int count);
    public void SetRange(int index, int count, T item);
    private Node<T> GetNode(Int32& index);
    private void UpdateAugmentedData(Node<T> node);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public int GetStartOfRun(int index);
    public int GetEndOfRun(int index);
    public void Transform(Func`2<T, T> converter);
    public void TransformRange(int index, int length, Func`2<T, T> converter);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Utils.CompressingTreeList`1/<GetEnumerator>d__30")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void InsertAsLeft(Node<T> parentNode, Node<T> newNode);
    private void InsertAsRight(Node<T> parentNode, Node<T> newNode);
    private void FixTreeOnInsert(Node<T> node);
    private void RemoveNode(Node<T> removedNode);
    private void FixTreeOnDelete(Node<T> node, Node<T> parentNode);
    private void ReplaceNode(Node<T> replacedNode, Node<T> newNode);
    private void RotateLeft(Node<T> p);
    private void RotateRight(Node<T> p);
    private static Node<T> Sibling(Node<T> node);
    private static Node<T> Sibling(Node<T> node, Node<T> parentNode);
    private static bool GetColor(Node<T> node);
    [ConditionalAttribute("DATACONSISTENCYTEST")]
internal void CheckProperties();
    internal string GetTreeAsString();
}
internal static class ICSharpCode.AvalonEdit.Utils.Constants : object {
    public static double PixelPerPoint;
}
internal class ICSharpCode.AvalonEdit.Utils.DelayedEvents : object {
    private Queue`1<EventCall> eventCalls;
    public void DelayedRaise(EventHandler handler, object sender, EventArgs e);
    public void RaiseEvents();
}
[DefaultMemberAttribute("Item")]
public class ICSharpCode.AvalonEdit.Utils.Deque`1 : object {
    private T[] arr;
    private int size;
    private int head;
    private int tail;
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void PushBack(T item);
    public T PopBack();
    public void PushFront(T item);
    public T PopFront();
    private void SetCapacity(int capacity);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Utils.Deque`1/<GetEnumerator>d__15")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
}
public static class ICSharpCode.AvalonEdit.Utils.DocumentPrinter : object {
    public static Block ConvertTextDocumentToBlock(IDocument document, IHighlighter highlighter);
    public static RichText ConvertTextDocumentToRichText(IDocument document, IHighlighter highlighter);
    public static FlowDocument CreateFlowDocumentForEditor(TextEditor editor);
}
internal static class ICSharpCode.AvalonEdit.Utils.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
[ExtensionAttribute]
internal static class ICSharpCode.AvalonEdit.Utils.ExtensionMethods : object {
    public static double Epsilon;
    [ExtensionAttribute]
public static bool IsClose(double d1, double d2);
    [ExtensionAttribute]
public static bool IsClose(Size d1, Size d2);
    [ExtensionAttribute]
public static bool IsClose(Vector d1, Vector d2);
    [ExtensionAttribute]
public static double CoerceValue(double value, double minimum, double maximum);
    [ExtensionAttribute]
public static int CoerceValue(int value, int minimum, int maximum);
    [ExtensionAttribute]
public static Typeface CreateTypeface(FrameworkElement fe);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> elements);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Utils.ExtensionMethods/<Sequence>d__8`1")]
public static IEnumerable`1<T> Sequence(T value);
    [ExtensionAttribute]
public static string GetAttributeOrNull(XmlElement element, string attributeName);
    [ExtensionAttribute]
public static Nullable`1<bool> GetBoolAttribute(XmlElement element, string attributeName);
    [ExtensionAttribute]
public static Nullable`1<bool> GetBoolAttribute(XmlReader reader, string attributeName);
    [ExtensionAttribute]
public static Rect TransformToDevice(Rect rect, Visual visual);
    [ExtensionAttribute]
public static Rect TransformFromDevice(Rect rect, Visual visual);
    [ExtensionAttribute]
public static Size TransformToDevice(Size size, Visual visual);
    [ExtensionAttribute]
public static Size TransformFromDevice(Size size, Visual visual);
    [ExtensionAttribute]
public static Point TransformToDevice(Point point, Visual visual);
    [ExtensionAttribute]
public static Point TransformFromDevice(Point point, Visual visual);
    [ExtensionAttribute]
public static Point ToSystemDrawing(Point p);
    [ExtensionAttribute]
public static Point ToWpf(Point p);
    [ExtensionAttribute]
public static Size ToWpf(Size s);
    [ExtensionAttribute]
public static Rect ToWpf(Rectangle rect);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Utils.ExtensionMethods/<VisualAncestorsAndSelf>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<DependencyObject> VisualAncestorsAndSelf(DependencyObject obj);
    [ConditionalAttribute("DEBUG")]
public static void CheckIsFrozen(Freezable f);
    [ConditionalAttribute("DEBUG")]
public static void Log(bool condition, string format, Object[] args);
}
public static class ICSharpCode.AvalonEdit.Utils.FileReader : object {
    private static Encoding UTF8NoBOM;
    private static FileReader();
    public static bool IsUnicode(Encoding encoding);
    private static bool IsASCIICompatible(Encoding encoding);
    private static Encoding RemoveBOM(Encoding encoding);
    public static string ReadFileContent(Stream stream, Encoding defaultEncoding);
    public static string ReadFileContent(string fileName, Encoding defaultEncoding);
    public static StreamReader OpenFile(string fileName, Encoding defaultEncoding);
    public static StreamReader OpenStream(Stream stream, Encoding defaultEncoding);
    private static StreamReader AutoDetect(Stream fs, byte firstByte, byte secondByte, Encoding defaultEncoding);
}
internal static class ICSharpCode.AvalonEdit.Utils.FreezableHelper : object {
    public static void ThrowIfFrozen(IFreezable freezable);
    public static IList`1<T> FreezeListAndElements(IList`1<T> list);
    public static IList`1<T> FreezeList(IList`1<T> list);
    public static void Freeze(object item);
    public static T FreezeAndReturn(T item);
    public static T GetFrozenClone(T item);
}
internal class ICSharpCode.AvalonEdit.Utils.FunctionNode`1 : RopeNode`1<T> {
    private Func`1<Rope`1<T>> initializer;
    private RopeNode`1<T> cachedResults;
    public FunctionNode`1(int length, Func`1<Rope`1<T>> initializer);
    internal virtual RopeNode`1<T> GetContentNode();
}
internal interface ICSharpCode.AvalonEdit.Utils.IFreezable {
    public bool IsFrozen { get; }
    public abstract virtual bool get_IsFrozen();
    public abstract virtual void Freeze();
}
public class ICSharpCode.AvalonEdit.Utils.ImmutableStack`1 : object {
    public static ImmutableStack`1<T> Empty;
    private T value;
    private ImmutableStack`1<T> next;
    public bool IsEmpty { get; }
    private ImmutableStack`1(T value, ImmutableStack`1<T> next);
    private static ImmutableStack`1();
    public ImmutableStack`1<T> Push(T item);
    public T Peek();
    public T PeekOrDefault();
    public ImmutableStack`1<T> Pop();
    public bool get_IsEmpty();
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Utils.ImmutableStack`1/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
public class ICSharpCode.AvalonEdit.Utils.NullSafeCollection`1 : Collection`1<T> {
    protected virtual void InsertItem(int index, T item);
    protected virtual void SetItem(int index, T item);
}
internal class ICSharpCode.AvalonEdit.Utils.ObserveAddRemoveCollection`1 : Collection`1<T> {
    private Action`1<T> onAdd;
    private Action`1<T> onRemove;
    public ObserveAddRemoveCollection`1(Action`1<T> onAdd, Action`1<T> onRemove);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
}
public static class ICSharpCode.AvalonEdit.Utils.PixelSnapHelpers : object {
    public static Size GetPixelSize(Visual visual);
    public static double PixelAlign(double value, double pixelSize);
    public static Rect PixelAlign(Rect rect, Size pixelSize);
    public static Point Round(Point point, Size pixelSize);
    public static Rect Round(Rect rect, Size pixelSize);
    public static double Round(double value, double pixelSize);
    public static double RoundToOdd(double value, double pixelSize);
}
internal class ICSharpCode.AvalonEdit.Utils.PlainRichTextWriter : RichTextWriter {
    protected TextWriter textWriter;
    private string indentationString;
    private int indentationLevel;
    private char prevChar;
    public string IndentationString { get; public set; }
    public Encoding Encoding { get; }
    public IFormatProvider FormatProvider { get; }
    public string NewLine { get; public set; }
    public PlainRichTextWriter(TextWriter textWriter);
    public string get_IndentationString();
    public void set_IndentationString(string value);
    protected virtual void BeginUnhandledSpan();
    public virtual void EndSpan();
    private void WriteIndentation();
    protected void WriteIndentationIfNecessary();
    protected virtual void AfterWrite();
    public virtual void Write(char value);
    public virtual void Indent();
    public virtual void Unindent();
    public virtual Encoding get_Encoding();
    public virtual IFormatProvider get_FormatProvider();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
}
public class ICSharpCode.AvalonEdit.Utils.PropertyChangedWeakEventManager : WeakEventManagerBase`2<PropertyChangedWeakEventManager, INotifyPropertyChanged> {
    protected virtual void StartListening(INotifyPropertyChanged source);
    protected virtual void StopListening(INotifyPropertyChanged source);
}
internal abstract class ICSharpCode.AvalonEdit.Utils.RichTextWriter : TextWriter {
    protected abstract virtual void BeginUnhandledSpan();
    public void Write(RichText richText);
    public virtual void Write(RichText richText, int offset, int length);
    public virtual void BeginSpan(Color foregroundColor);
    public virtual void BeginSpan(FontWeight fontWeight);
    public virtual void BeginSpan(FontStyle fontStyle);
    public virtual void BeginSpan(FontFamily fontFamily);
    public virtual void BeginSpan(HighlightingColor highlightingColor);
    public virtual void BeginHyperlinkSpan(Uri uri);
    public abstract virtual void EndSpan();
    public abstract virtual void Indent();
    public abstract virtual void Unindent();
}
[DefaultMemberAttribute("Item")]
public class ICSharpCode.AvalonEdit.Utils.Rope`1 : object {
    internal RopeNode`1<T> root;
    private ImmutableStack`1 modreq(System.Runtime.CompilerServices.IsVolatile) lastUsedNodeStack;
    public int Length { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    internal Rope`1(RopeNode`1<T> root);
    public Rope`1(IEnumerable`1<T> input);
    public Rope`1(T[] array, int arrayIndex, int count);
    public Rope`1(int length, Func`1<Rope`1<T>> initializer);
    private static T[] ToArray(IEnumerable`1<T> input);
    public Rope`1<T> Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public sealed virtual void Clear();
    public int get_Length();
    public sealed virtual int get_Count();
    public void InsertRange(int index, Rope`1<T> newElements);
    public void InsertRange(int index, IEnumerable`1<T> newElements);
    public void InsertRange(int index, T[] array, int arrayIndex, int count);
    public void AddRange(IEnumerable`1<T> newElements);
    public void AddRange(Rope`1<T> newElements);
    public void AddRange(T[] array, int arrayIndex, int count);
    public void RemoveRange(int index, int count);
    public void SetRange(int index, T[] array, int arrayIndex, int count);
    public Rope`1<T> GetRange(int index, int count);
    public static Rope`1<T> Concat(Rope`1<T> left, Rope`1<T> right);
    public static Rope`1<T> Concat(Rope`1[] ropes);
    internal void OnChanged();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    internal ImmutableStack`1<RopeCacheEntry<T>> FindNodeUsingCache(int index);
    internal void VerifyRange(int startIndex, int length);
    internal static void VerifyArrayWithRange(T[] array, int arrayIndex, int count);
    public virtual string ToString();
    internal string GetTreeAsString();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int startIndex, int count);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int startIndex, int count);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public T[] ToArray();
    public T[] ToArray(int startIndex, int count);
    [IteratorStateMachineAttribute("ICSharpCode.AvalonEdit.Utils.Rope`1/<Enumerate>d__52")]
private static IEnumerator`1<T> Enumerate(RopeNode`1<T> node);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class ICSharpCode.AvalonEdit.Utils.RopeNode`1 : object {
    internal static int NodeSize;
    internal static RopeNode`1<T> emptyRopeNode;
    internal RopeNode`1<T> left;
    internal RopeNode`1<T> right;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isShared;
    internal int length;
    internal byte height;
    internal T[] contents;
    internal int Balance { get; }
    private static RopeNode`1();
    internal int get_Balance();
    [ConditionalAttribute("DATACONSISTENCYTEST")]
internal void CheckInvariants();
    internal RopeNode`1<T> Clone();
    internal RopeNode`1<T> CloneIfShared();
    internal void Publish();
    internal static RopeNode`1<T> CreateFromArray(T[] arr, int index, int length);
    internal static RopeNode`1<T> CreateNodes(int totalLength);
    private static RopeNode`1<T> CreateNodes(int leafCount, int totalLength);
    internal void Rebalance();
    private void RotateLeft();
    private void RotateRight();
    private void MergeIfPossible();
    internal RopeNode`1<T> StoreElements(int index, T[] array, int arrayIndex, int count);
    internal void CopyTo(int index, T[] array, int arrayIndex, int count);
    internal RopeNode`1<T> SetElement(int offset, T value);
    internal static RopeNode`1<T> Concat(RopeNode`1<T> left, RopeNode`1<T> right);
    private RopeNode`1<T> SplitAfter(int offset);
    internal RopeNode`1<T> Insert(int offset, RopeNode`1<T> newElements);
    internal RopeNode`1<T> Insert(int offset, T[] array, int arrayIndex, int count);
    internal RopeNode`1<T> RemoveRange(int index, int count);
    internal virtual RopeNode`1<T> GetContentNode();
}
public class ICSharpCode.AvalonEdit.Utils.RopeTextReader : TextReader {
    private Stack`1<RopeNode`1<char>> stack;
    private RopeNode`1<char> currentNode;
    private int indexInsideNode;
    public RopeTextReader(Rope`1<char> rope);
    private void GoToLeftMostLeaf();
    public virtual int Peek();
    public virtual int Read();
    private void GoToNextNode();
    public virtual int Read(Char[] buffer, int index, int count);
}
public class ICSharpCode.AvalonEdit.Utils.StringSegment : ValueType {
    private string text;
    private int offset;
    private int count;
    public string Text { get; }
    public int Offset { get; }
    public int Count { get; }
    public StringSegment(string text, int offset, int count);
    public StringSegment(string text);
    public string get_Text();
    public int get_Offset();
    public int get_Count();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringSegment other);
    public virtual int GetHashCode();
    public static bool op_Equality(StringSegment left, StringSegment right);
    public static bool op_Inequality(StringSegment left, StringSegment right);
}
internal static class ICSharpCode.AvalonEdit.Utils.TextFormatterFactory : object {
    public static TextFormatter Create(DependencyObject owner);
    public static bool PropertyChangeAffectsTextFormatter(DependencyProperty dp);
    public static FormattedText CreateFormattedText(FrameworkElement element, string text, Typeface typeface, Nullable`1<double> emSize, Brush foreground);
}
internal static class ICSharpCode.AvalonEdit.Utils.ThrowUtil : object {
    public static T CheckNotNull(T val, string parameterName);
    public static int CheckNotNegative(int val, string parameterName);
    public static int CheckInRangeInclusive(int val, string parameterName, int lower, int upper);
    public static InvalidOperationException NoDocumentAssigned();
    public static InvalidOperationException NoValidCaretPosition();
}
public abstract class ICSharpCode.AvalonEdit.Utils.WeakEventManagerBase`2 : WeakEventManager {
    protected static TManager CurrentManager { get; }
    public static void AddListener(TEventSource source, IWeakEventListener listener);
    public static void RemoveListener(TEventSource source, IWeakEventListener listener);
    protected sealed virtual void StartListening(object source);
    protected sealed virtual void StopListening(object source);
    protected abstract virtual void StartListening(TEventSource source);
    protected abstract virtual void StopListening(TEventSource source);
    protected static TManager get_CurrentManager();
}
internal static class ICSharpCode.AvalonEdit.Utils.Win32 : object {
    public static TimeSpan CaretBlinkTime { get; }
    public static TimeSpan get_CaretBlinkTime();
    public static bool CreateCaret(Visual owner, Size size);
    public static bool SetCaretPosition(Visual owner, Point position);
    public static bool DestroyCaret();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
