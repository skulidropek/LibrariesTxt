[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Animation.Animatable : AvaloniaObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StyledProperty`1<IClock> ClockProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Transitions> TransitionsProperty;
    private bool _transitionsEnabled;
    private bool _isSubscribedToTransitionsCollection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ITransition, TransitionState> _transitionState;
    private NotifyCollectionChangedEventHandler _collectionChanged;
    [NullableAttribute("1")]
private NotifyCollectionChangedEventHandler TransitionsCollectionChangedHandler { get; }
    internal IClock Clock { get; internal set; }
    public Transitions Transitions { get; public set; }
    private static Animatable();
    [NullableContextAttribute("1")]
private NotifyCollectionChangedEventHandler get_TransitionsCollectionChangedHandler();
    internal IClock get_Clock();
    internal void set_Clock(IClock value);
    public Transitions get_Transitions();
    public void set_Transitions(Transitions value);
    internal void EnableTransitions();
    internal void DisableTransitions();
    [NullableContextAttribute("1")]
protected sealed virtual void OnPropertyChangedCore(AvaloniaPropertyChangedEventArgs change);
    [NullableContextAttribute("1")]
private void TransitionsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    [NullableContextAttribute("1")]
private void AddTransitions(IList items);
    [NullableContextAttribute("1")]
private void RemoveTransitions(IList items);
    [NullableContextAttribute("1")]
private object GetAnimationBaseValue(AvaloniaProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.Animation : AvaloniaObject {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static List`1<ValueTuple`3<Func`2<AvaloniaProperty, bool>, Type, Func`1<IAnimator>>> Animators;
    public static DirectProperty`2<Animation, TimeSpan> DurationProperty;
    public static DirectProperty`2<Animation, IterationCount> IterationCountProperty;
    public static DirectProperty`2<Animation, PlaybackDirection> PlaybackDirectionProperty;
    public static DirectProperty`2<Animation, FillMode> FillModeProperty;
    public static DirectProperty`2<Animation, Easing> EasingProperty;
    public static DirectProperty`2<Animation, TimeSpan> DelayProperty;
    public static DirectProperty`2<Animation, TimeSpan> DelayBetweenIterationsProperty;
    public static DirectProperty`2<Animation, double> SpeedRatioProperty;
    private TimeSpan _duration;
    private IterationCount _iterationCount;
    private PlaybackDirection _playbackDirection;
    private FillMode _fillMode;
    private Easing _easing;
    private TimeSpan _delay;
    private TimeSpan _delayBetweenIterations;
    private double _speedRatio;
    [CompilerGeneratedAttribute]
private KeyFrames <Children>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<IAnimationSetter, ValueTuple`2<Type, Func`1<IAnimator>>> s_animators;
    public TimeSpan Duration { get; public set; }
    public IterationCount IterationCount { get; public set; }
    public PlaybackDirection PlaybackDirection { get; public set; }
    public FillMode FillMode { get; public set; }
    public Easing Easing { get; public set; }
    public TimeSpan Delay { get; public set; }
    public TimeSpan DelayBetweenIterations { get; public set; }
    public double SpeedRatio { get; public set; }
    [ContentAttribute]
public KeyFrames Children { get; }
    private static Animation();
    [ObsoleteAttribute("CustomAnimatorBase will be removed before 11.0, use InterpolatingAnimator<T>", "True")]
public static void SetAnimator(IAnimationSetter setter, CustomAnimatorBase value);
    public static void SetAnimator(IAnimationSetter setter, ICustomAnimator value);
    [NullableContextAttribute("0")]
private static void RegisterAnimator();
    [NullableContextAttribute("0")]
public static void RegisterCustomAnimator();
    private static Nullable`1<ValueTuple`2<Type, Func`1<IAnimator>>> GetAnimatorType(AvaloniaProperty property);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public IterationCount get_IterationCount();
    public void set_IterationCount(IterationCount value);
    public PlaybackDirection get_PlaybackDirection();
    public void set_PlaybackDirection(PlaybackDirection value);
    public FillMode get_FillMode();
    public void set_FillMode(FillMode value);
    public Easing get_Easing();
    public void set_Easing(Easing value);
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public TimeSpan get_DelayBetweenIterations();
    public void set_DelayBetweenIterations(TimeSpan value);
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    [CompilerGeneratedAttribute]
public KeyFrames get_Children();
    internal static Nullable`1<ValueTuple`2<Type, Func`1<IAnimator>>> GetAnimator(IAnimationSetter setter);
    private ValueTuple`2<IList`1<IAnimator>, IList`1<IDisposable>> InterpretKeyframes(Animatable control);
    private sealed virtual override IDisposable Avalonia.Animation.IAnimation.Apply(Animatable control, IClock clock, IObservable`1<bool> match, Action onComplete);
    internal IDisposable Apply(Animatable control, IClock clock, IObservable`1<bool> match, Action onComplete);
    public Task RunAsync(Animatable control, CancellationToken cancellationToken);
    internal Task RunAsync(Animatable control, IClock clock);
    private sealed virtual override Task Avalonia.Animation.IAnimation.RunAsync(Animatable control, IClock clock, CancellationToken cancellationToken);
    internal Task RunAsync(Animatable control, IClock clock, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.AnimationInstance`1 : SingleSubscriberObservableBase`1<T> {
    private T _lastInterpValue;
    private T _firstKFValue;
    private Nullable`1<ulong> _iterationCount;
    private ulong _currentIteration;
    private bool _gotFirstKFValue;
    private bool _playbackReversed;
    private FillMode _fillMode;
    private PlaybackDirection _playbackDirection;
    private Animator`1<T> _animator;
    private Animation _animation;
    private Animatable _targetControl;
    private T _neutralValue;
    private double _speedRatioConv;
    private TimeSpan _initialDelay;
    private TimeSpan _iterationDelay;
    private TimeSpan _duration;
    [NullableAttribute("2")]
private Easing _easeFunc;
    [NullableAttribute("2")]
private Action _onCompleteAction;
    private Func`3<double, T, T> _interpolator;
    [NullableAttribute("2")]
private IDisposable _timerSub;
    private IClock _baseClock;
    [NullableAttribute("2")]
private IClock _clock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<AvaloniaPropertyChangedEventArgs> _propertyChangedDelegate;
    public AnimationInstance`1(Animation animation, Animatable control, Animator`1<T> animator, IClock baseClock, Action OnComplete, Func`3<double, T, T> Interpolator);
    private void FetchProperties();
    protected virtual void Unsubscribed();
    protected virtual void Subscribed();
    public void Step(TimeSpan frameTick);
    private void ApplyFinalFill();
    private void DoComplete();
    private void DoDelay();
    private void DoPlayStates();
    private void InternalStep(TimeSpan time);
    private void UpdateNeutralValue();
    private void ControlPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Animation.AnimatorDrivenTransition`2 : object {
    private static TAnimator s_animator;
    private static AnimatorDrivenTransition`2();
    public static IObservable`1<T> Transition(IEasing easing, IObservable`1<double> progress, T oldValue, T newValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Animation.AnimatorKeyFrame : AvaloniaObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<AnimatorKeyFrame, object> ValueProperty;
    [CompilerGeneratedAttribute]
private Type <AnimatorType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<IAnimator> <AnimatorFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Cue <Cue>k__BackingField;
    [CompilerGeneratedAttribute]
private KeySpline <KeySpline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FillBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FillAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    private object _value;
    public Type AnimatorType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<IAnimator> AnimatorFactory { get; }
    public Cue Cue { get; }
    public KeySpline KeySpline { get; }
    public bool FillBefore { get; public set; }
    public bool FillAfter { get; public set; }
    public AvaloniaProperty Property { get; private set; }
    public object Value { get; public set; }
    public AnimatorKeyFrame(Type animatorType, Func`1<IAnimator> animatorFactory, Cue cue, KeySpline keySpline);
    private static AnimatorKeyFrame();
    [CompilerGeneratedAttribute]
public Type get_AnimatorType();
    [CompilerGeneratedAttribute]
public Func`1<IAnimator> get_AnimatorFactory();
    [CompilerGeneratedAttribute]
public Cue get_Cue();
    [CompilerGeneratedAttribute]
public KeySpline get_KeySpline();
    [CompilerGeneratedAttribute]
public bool get_FillBefore();
    [CompilerGeneratedAttribute]
public void set_FillBefore(bool value);
    [CompilerGeneratedAttribute]
public bool get_FillAfter();
    [CompilerGeneratedAttribute]
public void set_FillAfter(bool value);
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(AvaloniaProperty value);
    public object get_Value();
    public void set_Value(object value);
    [NullableContextAttribute("1")]
public IDisposable BindSetter(IAnimationSetter setter, Animatable targetControl);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
public T GetTypedValue();
    [NullableContextAttribute("1")]
internal virtual void BuildDebugDisplay(StringBuilder builder, bool includeContent);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Avalonia.Animation.Animators.Animator`1 : AvaloniaList`1<AnimatorKeyFrame> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    [NullableAttribute("2")]
public AvaloniaProperty Property { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual AvaloniaProperty get_Property();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Property(AvaloniaProperty value);
    public virtual IDisposable Apply(Animation animation, Animatable control, IClock clock, IObservable`1<bool> match, Action onComplete);
    protected T InterpolationHandler(double animationTime, T neutralValue);
    [NullableContextAttribute("0")]
private ValueTuple`2<KeyFrameInfo<T>, KeyFrameInfo<T>> GetKeyFrames(double time, T neutralValue);
    private static T GetTypedValue(object untypedValue, T neutralValue);
    public virtual IDisposable BindAnimation(Animatable control, IObservable`1<T> instance);
    internal IDisposable Run(Animation animation, Animatable control, IClock clock, Action onComplete);
    public abstract virtual T Interpolate(double progress, T oldValue, T newValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.Animators.BaseBrushAnimator : Animator`1<IBrush> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static List`1<ValueTuple`3<Func`2<Type, bool>, Type, Func`1<IAnimator>>> _brushAnimators;
    private static BaseBrushAnimator();
    [NullableContextAttribute("1")]
public static void RegisterBrushAnimator(Func`2<Type, bool> condition);
    [NullableContextAttribute("1")]
public virtual IDisposable Apply(Animation animation, Animatable control, IClock clock, IObservable`1<bool> match, Action onComplete);
    public virtual IBrush Interpolate(double progress, IBrush oldValue, IBrush newValue);
    private bool TryCreateGradientAnimator(IAnimator& animator);
    private bool TryCreateSolidColorBrushAnimator(IAnimator& animator);
    private bool TryCreateCustomRegisteredAnimator(IAnimator& animator);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.Animators.BlurEffectAnimator : EffectAnimatorBase`1<IBlurEffect> {
    private static DoubleAnimator s_doubleAnimator;
    private static BlurEffectAnimator();
    protected virtual IBlurEffect Interpolate(double progress, IBlurEffect oldValue, IBlurEffect newValue);
}
internal class Avalonia.Animation.Animators.BoolAnimator : Animator`1<bool> {
    public virtual bool Interpolate(double progress, bool oldValue, bool newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Animation.Animators.BoxShadowAnimator : Animator`1<BoxShadow> {
    private static ColorAnimator s_colorAnimator;
    private static DoubleAnimator s_doubleAnimator;
    private static BoolAnimator s_boolAnimator;
    private static BoxShadowAnimator();
    public virtual BoxShadow Interpolate(double progress, BoxShadow oldValue, BoxShadow newValue);
}
internal class Avalonia.Animation.Animators.BoxShadowsAnimator : Animator`1<BoxShadows> {
    [NullableAttribute("1")]
private static BoxShadowAnimator s_boxShadowAnimator;
    private static BoxShadowsAnimator();
    public virtual BoxShadows Interpolate(double progress, BoxShadows oldValue, BoxShadows newValue);
}
internal class Avalonia.Animation.Animators.ByteAnimator : Animator`1<byte> {
    private static double maxVal;
    public virtual byte Interpolate(double progress, byte oldValue, byte newValue);
}
internal class Avalonia.Animation.Animators.ColorAnimator : Animator`1<Color> {
    private static double OECF_sRGB(double linear);
    private static double EOCF_sRGB(double srgb);
    public virtual Color Interpolate(double progress, Color oldValue, Color newValue);
    internal static Color InterpolateCore(double progress, Color oldValue, Color newValue);
}
internal class Avalonia.Animation.Animators.CornerRadiusAnimator : Animator`1<CornerRadius> {
    public virtual CornerRadius Interpolate(double progress, CornerRadius oldValue, CornerRadius newValue);
}
internal class Avalonia.Animation.Animators.DecimalAnimator : Animator`1<decimal> {
    public virtual decimal Interpolate(double progress, decimal oldValue, decimal newValue);
}
internal class Avalonia.Animation.Animators.DoubleAnimator : Animator`1<double> {
    public virtual double Interpolate(double progress, double oldValue, double newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.Animators.DropShadowEffectAnimator : EffectAnimatorBase`1<IDropShadowEffect> {
    private static DoubleAnimator s_doubleAnimator;
    private static DropShadowEffectAnimator();
    protected virtual IDropShadowEffect Interpolate(double progress, IDropShadowEffect oldValue, IDropShadowEffect newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.Animators.EffectAnimator : Animator`1<IEffect> {
    private static bool s_Registered;
    public virtual IDisposable Apply(Animation animation, Animatable control, IClock clock, IObservable`1<bool> match, Action onComplete);
    private bool TryCreateAnimator(IAnimator& animator);
    [NullableContextAttribute("2")]
public virtual IEffect Interpolate(double progress, IEffect oldValue, IEffect newValue);
    public static void EnsureRegistered();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Avalonia.Animation.Animators.EffectAnimatorBase`1 : Animator`1<IEffect> {
    public virtual IDisposable BindAnimation(Animatable control, IObservable`1<IEffect> instance);
    protected abstract virtual T Interpolate(double progress, T oldValue, T newValue);
    [NullableContextAttribute("2")]
public virtual IEffect Interpolate(double progress, IEffect oldValue, IEffect newValue);
}
internal class Avalonia.Animation.Animators.FloatAnimator : Animator`1<float> {
    public virtual float Interpolate(double progress, float oldValue, float newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.Animators.GradientBrushAnimator : Animator`1<IGradientBrush> {
    private static RelativePointAnimator s_relativePointAnimator;
    private static RelativeScalarAnimator s_relativeScalarAnimator;
    private static DoubleAnimator s_doubleAnimator;
    private static GradientBrushAnimator();
    [NullableContextAttribute("2")]
public virtual IGradientBrush Interpolate(double progress, IGradientBrush oldValue, IGradientBrush newValue);
    public virtual IDisposable BindAnimation(Animatable control, IObservable`1<IGradientBrush> instance);
    [NullableContextAttribute("2")]
private static ImmutableTransform InterpolateTransform(double progress, ITransform oldTransform, ITransform newTransform);
    private static IReadOnlyList`1<ImmutableGradientStop> InterpolateStops(double progress, IReadOnlyList`1<IGradientStop> oldValue, IReadOnlyList`1<IGradientStop> newValue);
    internal static IGradientBrush ConvertSolidColorBrushToGradient(IGradientBrush gradientBrush, ISolidColorBrush solidColorBrush);
    [CompilerGeneratedAttribute]
internal static IReadOnlyList`1<ImmutableGradientStop> <ConvertSolidColorBrushToGradient>g__CreateStopsFromSolidColorBrush|7_0(ISolidColorBrush solidColorBrush, IReadOnlyList`1<IGradientStop> baseStops);
}
internal class Avalonia.Animation.Animators.Int16Animator : Animator`1<short> {
    private static double maxVal;
    public virtual short Interpolate(double progress, short oldValue, short newValue);
}
internal class Avalonia.Animation.Animators.Int32Animator : Animator`1<int> {
    private static double maxVal;
    public virtual int Interpolate(double progress, int oldValue, int newValue);
}
internal class Avalonia.Animation.Animators.Int64Animator : Animator`1<long> {
    private static double maxVal;
    public virtual long Interpolate(double progress, long oldValue, long newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.Animators.ISolidColorBrushAnimator : Animator`1<ISolidColorBrush> {
    private static DoubleAnimator s_doubleAnimator;
    private static ISolidColorBrushAnimator();
    [NullableContextAttribute("2")]
public virtual ISolidColorBrush Interpolate(double progress, ISolidColorBrush oldValue, ISolidColorBrush newValue);
    public virtual IDisposable BindAnimation(Animatable control, IObservable`1<ISolidColorBrush> instance);
}
internal class Avalonia.Animation.Animators.PointAnimator : Animator`1<Point> {
    public virtual Point Interpolate(double progress, Point oldValue, Point newValue);
}
internal class Avalonia.Animation.Animators.RectAnimator : Animator`1<Rect> {
    public virtual Rect Interpolate(double progress, Rect oldValue, Rect newValue);
}
internal class Avalonia.Animation.Animators.RelativePointAnimator : Animator`1<RelativePoint> {
    [NullableAttribute("1")]
private static PointAnimator s_pointAnimator;
    private static RelativePointAnimator();
    public virtual RelativePoint Interpolate(double progress, RelativePoint oldValue, RelativePoint newValue);
}
internal class Avalonia.Animation.Animators.RelativeScalarAnimator : Animator`1<RelativeScalar> {
    [NullableAttribute("1")]
private static DoubleAnimator s_scalarAnimator;
    private static RelativeScalarAnimator();
    public virtual RelativeScalar Interpolate(double progress, RelativeScalar oldValue, RelativeScalar newValue);
}
internal class Avalonia.Animation.Animators.SizeAnimator : Animator`1<Size> {
    public virtual Size Interpolate(double progress, Size oldValue, Size newValue);
}
internal class Avalonia.Animation.Animators.ThicknessAnimator : Animator`1<Thickness> {
    public virtual Thickness Interpolate(double progress, Thickness oldValue, Thickness newValue);
}
internal class Avalonia.Animation.Animators.TransformAnimator : Animator`1<double> {
    [NullableAttribute("2")]
private DoubleAnimator _doubleAnimator;
    [NullableContextAttribute("1")]
public virtual IDisposable Apply(Animation animation, Animatable control, IClock clock, IObservable`1<bool> obsMatch, Action onComplete);
    public virtual double Interpolate(double p, double o, double n);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.Animators.TransformOperationsAnimator : Animator`1<TransformOperations> {
    public virtual TransformOperations Interpolate(double progress, TransformOperations oldValue, TransformOperations newValue);
    internal static TransformOperations EnsureOperations(ITransform value);
    private sealed virtual override void Avalonia.Collections.IAvaloniaListItemValidator<Avalonia.Animation.AnimatorKeyFrame>.Validate(AnimatorKeyFrame item);
}
internal class Avalonia.Animation.Animators.UInt16Animator : Animator`1<ushort> {
    private static double maxVal;
    public virtual ushort Interpolate(double progress, ushort oldValue, ushort newValue);
}
internal class Avalonia.Animation.Animators.UInt32Animator : Animator`1<UInt32> {
    private static double maxVal;
    public virtual UInt32 Interpolate(double progress, UInt32 oldValue, UInt32 newValue);
}
internal class Avalonia.Animation.Animators.UInt64Animator : Animator`1<ulong> {
    private static double maxVal;
    public virtual ulong Interpolate(double progress, ulong oldValue, ulong newValue);
}
internal class Avalonia.Animation.Animators.VectorAnimator : Animator`1<Vector> {
    public virtual Vector Interpolate(double progress, Vector oldValue, Vector newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Animation.AnimatorTransitionObservable`2 : TransitionObservableBase`1<T> {
    private TAnimator _animator;
    private T _oldValue;
    private T _newValue;
    public AnimatorTransitionObservable`2(TAnimator animator, IObservable`1<double> progress, IEasing easing, T oldValue, T newValue);
    protected virtual T ProduceValue(double progress);
}
public class Avalonia.Animation.BoolTransition : Transition`1<bool> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<bool> DoTransition(IObservable`1<double> progress, bool oldValue, bool newValue);
}
public class Avalonia.Animation.BoxShadowsTransition : Transition`1<BoxShadows> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<BoxShadows> DoTransition(IObservable`1<double> progress, BoxShadows oldValue, BoxShadows newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Animation.BrushTransition : Transition`1<IBrush> {
    private static GradientBrushAnimator s_gradientAnimator;
    private static ISolidColorBrushAnimator s_solidColorBrushAnimator;
    private static BrushTransition();
    [NullableContextAttribute("2")]
internal virtual IObservable`1<IBrush> DoTransition(IObservable`1<double> progress, IBrush oldValue, IBrush newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Animation.Clock : ClockBase {
    private IDisposable _parentSubscription;
    public static IClock GlobalClock { get; }
    public Clock(IClock parent);
    public static IClock get_GlobalClock();
    protected virtual void Stop();
}
internal class Avalonia.Animation.ClockBase : object {
    [NullableAttribute("1")]
private ClockObservable _observable;
    private Nullable`1<TimeSpan> _previousTime;
    private TimeSpan _internalTime;
    [CompilerGeneratedAttribute]
private PlayState <PlayState>k__BackingField;
    protected bool HasSubscriptions { get; }
    public PlayState PlayState { get; public set; }
    protected bool get_HasSubscriptions();
    [CompilerGeneratedAttribute]
public sealed virtual PlayState get_PlayState();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PlayState(PlayState value);
    protected void Pulse(TimeSpan systemTime);
    protected virtual void Stop();
    [NullableContextAttribute("1")]
public sealed virtual IDisposable Subscribe(IObserver`1<TimeSpan> observer);
}
public class Avalonia.Animation.ColorTransition : Transition`1<Color> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<Color> DoTransition(IObservable`1<double> progress, Color oldValue, Color newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.CompositePageTransition : object {
    [CompilerGeneratedAttribute]
private List`1<IPageTransition> <PageTransitions>k__BackingField;
    [ContentAttribute]
public List`1<IPageTransition> PageTransitions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<IPageTransition> get_PageTransitions();
    [CompilerGeneratedAttribute]
public void set_PageTransitions(List`1<IPageTransition> value);
    [NullableContextAttribute("2")]
public sealed virtual Task Start(Visual from, Visual to, bool forward, CancellationToken cancellationToken);
}
public class Avalonia.Animation.CornerRadiusTransition : Transition`1<CornerRadius> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<CornerRadius> DoTransition(IObservable`1<double> progress, CornerRadius oldValue, CornerRadius newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.CrossFade : object {
    private Animation _fadeOutAnimation;
    private Animation _fadeInAnimation;
    public TimeSpan Duration { get; public set; }
    public Easing FadeInEasing { get; public set; }
    public Easing FadeOutEasing { get; public set; }
    public CrossFade(TimeSpan duration);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public Easing get_FadeInEasing();
    public void set_FadeInEasing(Easing value);
    public Easing get_FadeOutEasing();
    public void set_FadeOutEasing(Easing value);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Avalonia.Animation.CrossFade/<Start>d__13")]
public Task Start(Visual from, Visual to, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private sealed virtual override Task Avalonia.Animation.IPageTransition.Start(Visual from, Visual to, bool forward, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[TypeConverterAttribute("Avalonia.Animation.CueTypeConverter")]
public class Avalonia.Animation.Cue : ValueType {
    [CompilerGeneratedAttribute]
private double <CueValue>k__BackingField;
    public double CueValue { get; }
    public Cue(double value);
    [CompilerGeneratedAttribute]
public double get_CueValue();
    [NullableContextAttribute("1")]
public static Cue Parse(string value, CultureInfo culture);
    public sealed virtual bool Equals(double other);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Cue left, Cue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Cue left, Cue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Cue other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.CueTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This class will be removed before 11.0, use InterpolatingAnimator<T>", "True")]
public abstract class Avalonia.Animation.CustomAnimatorBase : object {
    internal Type WrapperType { get; }
    internal abstract virtual IAnimator CreateWrapper();
    internal abstract virtual Type get_WrapperType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This class will be removed before 11.0, use InterpolatingAnimator<T>", "True")]
public abstract class Avalonia.Animation.CustomAnimatorBase`1 : CustomAnimatorBase {
    internal Type WrapperType { get; }
    public abstract virtual T Interpolate(double progress, T oldValue, T newValue);
    internal virtual Type get_WrapperType();
    internal virtual IAnimator CreateWrapper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Animation.DisposeAnimationInstanceSubject`1 : object {
    [NullableAttribute("2")]
private IDisposable _lastInstance;
    private bool _lastMatch;
    private Animator`1<T> _animator;
    private Animation _animation;
    private Animatable _control;
    [NullableAttribute("2")]
private Action _onComplete;
    [NullableAttribute("2")]
private IClock _clock;
    public DisposeAnimationInstanceSubject`1(Animator`1<T> animator, Animation animation, Animatable control, IClock clock, Action onComplete);
    public sealed virtual void Dispose();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    private sealed virtual override void System.IObserver<System.Boolean>.OnNext(bool matchVal);
}
public class Avalonia.Animation.DoubleTransition : Transition`1<double> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<double> DoTransition(IObservable`1<double> progress, double oldValue, double newValue);
}
public class Avalonia.Animation.Easings.BackEaseIn : Easing {
    public virtual double Ease(double p);
}
public class Avalonia.Animation.Easings.BackEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.BackEaseOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.BounceEaseIn : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.BounceEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.BounceEaseOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.CircularEaseIn : Easing {
    public virtual double Ease(double p);
}
public class Avalonia.Animation.Easings.CircularEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.CircularEaseOut : Easing {
    public virtual double Ease(double progress);
}
[ObsoleteAttribute("Use SplineEasing instead")]
public class Avalonia.Animation.Easings.CubicBezierEasing : object {
    [CompilerGeneratedAttribute]
private Point <ControlPoint2>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <ControlPoint1>k__BackingField;
    public Point ControlPoint2 { get; public set; }
    public Point ControlPoint1 { get; public set; }
    [CompilerGeneratedAttribute]
public Point get_ControlPoint2();
    [CompilerGeneratedAttribute]
public void set_ControlPoint2(Point value);
    [CompilerGeneratedAttribute]
public Point get_ControlPoint1();
    [CompilerGeneratedAttribute]
public void set_ControlPoint1(Point value);
    private sealed virtual override double Avalonia.Animation.Easings.IEasing.Ease(double progress);
}
public class Avalonia.Animation.Easings.CubicEaseIn : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.CubicEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.CubicEaseOut : Easing {
    public virtual double Ease(double progress);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeConverterAttribute("Avalonia.Animation.Easings.EasingTypeConverter")]
public abstract class Avalonia.Animation.Easings.Easing : object {
    private static string Namespace;
    public abstract virtual double Ease(double progress);
    [SubtypesFactoryAttribute("Avalonia.Animation.Easings.Easing", "Avalonia.Animation.Easings")]
private static bool TryCreateEasingInstance(string type, Easing& instance);
    public static Easing Parse(string e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.Easings.EasingTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public class Avalonia.Animation.Easings.ElasticEaseIn : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.ElasticEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.ElasticEaseOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.ExponentialEaseIn : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.ExponentialEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.ExponentialEaseOut : Easing {
    public virtual double Ease(double progress);
}
[NotClientImplementableAttribute]
public interface Avalonia.Animation.Easings.IEasing {
    public abstract virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.LinearEasing : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuadraticEaseIn : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuadraticEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuadraticEaseOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuarticEaseIn : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuarticEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuarticEaseOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuinticEaseIn : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuinticEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.QuinticEaseOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.SineEaseIn : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.SineEaseInOut : Easing {
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.SineEaseOut : Easing {
    public virtual double Ease(double progress);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.Easings.SplineEasing : Easing {
    private KeySpline _internalKeySpline;
    public double X1 { get; public set; }
    public double Y1 { get; public set; }
    public double X2 { get; public set; }
    public double Y2 { get; public set; }
    public SplineEasing(double x1, double y1, double x2, double y2);
    public SplineEasing(KeySpline keySpline);
    public double get_X1();
    public void set_X1(double value);
    public double get_Y1();
    public void set_Y1(double value);
    public double get_X2();
    public void set_X2(double value);
    public double get_Y2();
    public void set_Y2(double value);
    public virtual double Ease(double progress);
}
public class Avalonia.Animation.Easings.SpringEasing : Easing {
    [NullableAttribute("1")]
private Spring _internalSpring;
    public double Mass { get; public set; }
    public double Stiffness { get; public set; }
    public double Damping { get; public set; }
    public double InitialVelocity { get; public set; }
    public SpringEasing(double mass, double stiffness, double damping, double initialVelocity);
    public double get_Mass();
    public void set_Mass(double value);
    public double get_Stiffness();
    public void set_Stiffness(double value);
    public double get_Damping();
    public void set_Damping(double value);
    public double get_InitialVelocity();
    public void set_InitialVelocity(double value);
    public virtual double Ease(double progress);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Animation.EffectTransition : Transition`1<IEffect> {
    private static BlurEffectAnimator s_blurEffectAnimator;
    private static DropShadowEffectAnimator s_dropShadowEffectAnimator;
    private static ImmutableBlurEffect s_DefaultBlur;
    private static ImmutableDropShadowDirectionEffect s_DefaultDropShadow;
    private static EffectTransition();
    private bool TryWithAnimator(IObservable`1<double> progress, TAnimator animator, IEffect oldValue, IEffect newValue, TInterface defaultValue, IObservable`1& observable);
    [NullableContextAttribute("2")]
internal virtual IObservable`1<IEffect> DoTransition(IObservable`1<double> progress, IEffect oldValue, IEffect newValue);
}
public enum Avalonia.Animation.FillMode : Enum {
    public int value__;
    public static FillMode None;
    public static FillMode Forward;
    public static FillMode Backward;
    public static FillMode Both;
}
public class Avalonia.Animation.FloatTransition : Transition`1<float> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<float> DoTransition(IObservable`1<double> progress, float oldValue, float newValue);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Animation.IAnimation {
    internal abstract virtual IDisposable Apply(Animatable control, IClock clock, IObservable`1<bool> match, Action onComplete);
    internal abstract virtual Task RunAsync(Animatable control, IClock clock, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
[PrivateApiAttribute]
public interface Avalonia.Animation.IAnimationSetter {
    public AvaloniaProperty Property { get; public set; }
    public object Value { get; public set; }
    public abstract virtual AvaloniaProperty get_Property();
    public abstract virtual void set_Property(AvaloniaProperty value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[NullableContextAttribute("2")]
internal interface Avalonia.Animation.IAnimator {
    public AvaloniaProperty Property { get; public set; }
    public abstract virtual AvaloniaProperty get_Property();
    public abstract virtual void set_Property(AvaloniaProperty value);
    [NullableContextAttribute("1")]
public abstract virtual IDisposable Apply(Animation animation, Animatable control, IClock clock, IObservable`1<bool> match, Action onComplete);
}
internal interface Avalonia.Animation.IClock {
    public PlayState PlayState { get; public set; }
    public abstract virtual PlayState get_PlayState();
    public abstract virtual void set_PlayState(PlayState value);
}
[NullableContextAttribute("1")]
public interface Avalonia.Animation.ICustomAnimator {
    internal Type WrapperType { get; }
    internal abstract virtual IAnimator CreateWrapper();
    internal abstract virtual Type get_WrapperType();
}
internal interface Avalonia.Animation.IGlobalClock {
}
public class Avalonia.Animation.IntegerTransition : Transition`1<int> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<int> DoTransition(IObservable`1<double> progress, int oldValue, int newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Animation.InterpolatingAnimator`1 : object {
    private Type Avalonia.Animation.ICustomAnimator.WrapperType { get; }
    public abstract virtual T Interpolate(double progress, T oldValue, T newValue);
    private sealed virtual override Type Avalonia.Animation.ICustomAnimator.get_WrapperType();
    private sealed virtual override IAnimator Avalonia.Animation.ICustomAnimator.CreateWrapper();
    internal IAnimator CreateWrapper();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Avalonia.Animation.InterpolatingTransitionBase`1 : Transition`1<T> {
    protected abstract virtual T Interpolate(double progress, T from, T to);
    internal virtual IObservable`1<T> DoTransition(IObservable`1<double> progress, T oldValue, T newValue);
}
[NullableContextAttribute("2")]
public interface Avalonia.Animation.IPageTransition {
    public abstract virtual Task Start(Visual from, Visual to, bool forward, CancellationToken cancellationToken);
}
[TypeConverterAttribute("Avalonia.Animation.IterationCountTypeConverter")]
public class Avalonia.Animation.IterationCount : ValueType {
    private IterationType _type;
    private ulong _value;
    public static IterationCount Infinite { get; }
    public IterationType RepeatType { get; }
    public bool IsInfinite { get; }
    public ulong Value { get; }
    public IterationCount(ulong value);
    public IterationCount(ulong value, IterationType type);
    public static IterationCount get_Infinite();
    public IterationType get_RepeatType();
    public bool get_IsInfinite();
    public ulong get_Value();
    public static bool op_Equality(IterationCount a, IterationCount b);
    public static bool op_Inequality(IterationCount rc1, IterationCount rc2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public sealed virtual bool Equals(IterationCount IterationCount);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static IterationCount Parse(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.IterationCountTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public enum Avalonia.Animation.IterationType : Enum {
    public int value__;
    public static IterationType Many;
    public static IterationType Infinite;
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
[PrivateApiAttribute]
public interface Avalonia.Animation.ITransition {
    public AvaloniaProperty Property { get; public set; }
    internal abstract virtual IDisposable Apply(Animatable control, IClock clock, object oldValue, object newValue);
    public abstract virtual AvaloniaProperty get_Property();
    public abstract virtual void set_Property(AvaloniaProperty value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.KeyFrame : AvaloniaObject {
    private TimeSpan _ktimeSpan;
    private Cue _kCue;
    [NullableAttribute("2")]
private KeySpline _kKeySpline;
    [CompilerGeneratedAttribute]
private AvaloniaList`1<IAnimationSetter> <Setters>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyFrameTimingMode <TimingMode>k__BackingField;
    [ContentAttribute]
public AvaloniaList`1<IAnimationSetter> Setters { get; }
    internal KeyFrameTimingMode TimingMode { get; private set; }
    public TimeSpan KeyTime { get; public set; }
    public Cue Cue { get; public set; }
    [NullableAttribute("2")]
public KeySpline KeySpline { get; public set; }
    [CompilerGeneratedAttribute]
public AvaloniaList`1<IAnimationSetter> get_Setters();
    [CompilerGeneratedAttribute]
internal KeyFrameTimingMode get_TimingMode();
    [CompilerGeneratedAttribute]
private void set_TimingMode(KeyFrameTimingMode value);
    public TimeSpan get_KeyTime();
    public void set_KeyTime(TimeSpan value);
    public Cue get_Cue();
    public void set_Cue(Cue value);
    [NullableContextAttribute("2")]
public KeySpline get_KeySpline();
    [NullableContextAttribute("2")]
public void set_KeySpline(KeySpline value);
    internal virtual void BuildDebugDisplay(StringBuilder builder, bool includeContent);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Animation.KeyFrames : AvaloniaList`1<KeyFrame> {
    public KeyFrames(IEnumerable`1<KeyFrame> items);
}
internal enum Avalonia.Animation.KeyFrameTimingMode : Enum {
    public int value__;
    public static KeyFrameTimingMode TimeSpan;
    public static KeyFrameTimingMode Cue;
}
[TypeConverterAttribute("Avalonia.Animation.KeySplineTypeConverter")]
public class Avalonia.Animation.KeySpline : AvaloniaObject {
    private double _controlPointX1;
    private double _controlPointY1;
    private double _controlPointX2;
    private double _controlPointY2;
    private bool _isSpecified;
    private bool _isDirty;
    private double _parameter;
    private double _Bx;
    private double _Cx;
    private double _Cx_Bx;
    private double _three_Cx;
    private double _By;
    private double _Cy;
    private static double _accuracy;
    private static double _fuzz;
    public double ControlPointX1 { get; public set; }
    public double ControlPointY1 { get; public set; }
    public double ControlPointX2 { get; public set; }
    public double ControlPointY2 { get; public set; }
    public KeySpline(double x1, double y1, double x2, double y2);
    [NullableContextAttribute("1")]
public static KeySpline Parse(string value, CultureInfo culture);
    public double get_ControlPointX1();
    public void set_ControlPointX1(double value);
    public double get_ControlPointY1();
    public void set_ControlPointY1(double value);
    public double get_ControlPointX2();
    public void set_ControlPointX2(double value);
    public double get_ControlPointY2();
    public void set_ControlPointY2(double value);
    public double GetSplineProgress(double linearProgress);
    public bool IsValid();
    private static bool IsValidXValue(double value);
    private void Build();
    private static double GetBezierValue(double b, double c, double t);
    private void GetXAndDx(double t, Double& x, Double& dx);
    private void SetParameterFromX(double time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.KeySplineTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Animation.PageSlide : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private SlideAxis <Orientation>k__BackingField;
    [CompilerGeneratedAttribute]
private Easing <SlideInEasing>k__BackingField;
    [CompilerGeneratedAttribute]
private Easing <SlideOutEasing>k__BackingField;
    public TimeSpan Duration { get; public set; }
    public SlideAxis Orientation { get; public set; }
    public Easing SlideInEasing { get; public set; }
    public Easing SlideOutEasing { get; public set; }
    public PageSlide(TimeSpan duration, SlideAxis orientation);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public SlideAxis get_Orientation();
    [CompilerGeneratedAttribute]
public void set_Orientation(SlideAxis value);
    [CompilerGeneratedAttribute]
public Easing get_SlideInEasing();
    [CompilerGeneratedAttribute]
public void set_SlideInEasing(Easing value);
    [CompilerGeneratedAttribute]
public Easing get_SlideOutEasing();
    [CompilerGeneratedAttribute]
public void set_SlideOutEasing(Easing value);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Avalonia.Animation.PageSlide/<Start>d__19")]
public virtual Task Start(Visual from, Visual to, bool forward, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected static Visual GetVisualParent(Visual from, Visual to);
}
public enum Avalonia.Animation.PlaybackDirection : Enum {
    public int value__;
    public static PlaybackDirection Normal;
    public static PlaybackDirection Reverse;
    public static PlaybackDirection Alternate;
    public static PlaybackDirection AlternateReverse;
}
public enum Avalonia.Animation.PlayState : Enum {
    public int value__;
    public static PlayState Run;
    public static PlayState Pause;
    public static PlayState Stop;
}
public class Avalonia.Animation.PointTransition : Transition`1<Point> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<Point> DoTransition(IObservable`1<double> progress, Point oldValue, Point newValue);
}
public class Avalonia.Animation.RelativePointTransition : Transition`1<RelativePoint> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<RelativePoint> DoTransition(IObservable`1<double> progress, RelativePoint oldValue, RelativePoint newValue);
}
public class Avalonia.Animation.Rotate3DTransition : PageSlide {
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Depth>k__BackingField;
    public Nullable`1<double> Depth { get; public set; }
    public Rotate3DTransition(TimeSpan duration, SlideAxis orientation, Nullable`1<double> depth);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(Nullable`1<double> value);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Avalonia.Animation.Rotate3DTransition/<Start>d__6")]
public virtual Task Start(Visual from, Visual to, bool forward, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static KeyFrame <Start>g__CreateKeyFrame|6_0(double cue, double rotation, int zIndex, bool isVisible, <>c__DisplayClass6_0& );
}
public class Avalonia.Animation.SizeTransition : Transition`1<Size> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<Size> DoTransition(IObservable`1<double> progress, Size oldValue, Size newValue);
}
[TypeConverterAttribute("Avalonia.Animation.SpringTypeConverter")]
internal class Avalonia.Animation.Spring : object {
    private SpringSolver _springSolver;
    private double _mass;
    private double _stiffness;
    private double _damping;
    private double _initialVelocity;
    private bool _isDirty;
    public double Mass { get; public set; }
    public double Stiffness { get; public set; }
    public double Damping { get; public set; }
    public double InitialVelocity { get; public set; }
    public Spring(double mass, double stiffness, double damping, double initialVelocity);
    [NullableContextAttribute("1")]
public static Spring Parse(string value, CultureInfo culture);
    public double get_Mass();
    public void set_Mass(double value);
    public double get_Stiffness();
    public void set_Stiffness(double value);
    public double get_Damping();
    public void set_Damping(double value);
    public double get_InitialVelocity();
    public void set_InitialVelocity(double value);
    public double GetSpringProgress(double linearProgress);
    private void Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Animation.SpringTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public class Avalonia.Animation.ThicknessTransition : Transition`1<Thickness> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<Thickness> DoTransition(IObservable`1<double> progress, Thickness oldValue, Thickness newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Animation.TransformOperationsTransition : Transition`1<ITransform> {
    private static TransformOperationsAnimator s_operationsAnimator;
    private static TransformOperationsTransition();
    internal virtual IObservable`1<ITransform> DoTransition(IObservable`1<double> progress, ITransform oldValue, ITransform newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Animation.Transition`1 : TransitionBase {
    private static Transition`1();
    private void OnPropertyPropertyChanged(AvaloniaPropertyChangedEventArgs e);
    internal abstract virtual IObservable`1<T> DoTransition(IObservable`1<double> progress, T oldValue, T newValue);
    internal virtual IDisposable Apply(Animatable control, IClock clock, object oldValue, object newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Animation.TransitionBase : AvaloniaObject {
    public static DirectProperty`2<TransitionBase, TimeSpan> DurationProperty;
    public static DirectProperty`2<TransitionBase, TimeSpan> DelayProperty;
    public static DirectProperty`2<TransitionBase, Easing> EasingProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<TransitionBase, AvaloniaProperty> PropertyProperty;
    private TimeSpan _duration;
    private TimeSpan _delay;
    private Easing _easing;
    [NullableAttribute("2")]
private AvaloniaProperty _prop;
    public TimeSpan Duration { get; public set; }
    public TimeSpan Delay { get; public set; }
    public Easing Easing { get; public set; }
    [NullableAttribute("2")]
public AvaloniaProperty Property { get; public set; }
    private AvaloniaProperty Avalonia.Animation.ITransition.Property { get; private set; }
    private static TransitionBase();
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public Easing get_Easing();
    public void set_Easing(Easing value);
    [NullableContextAttribute("2")]
public AvaloniaProperty get_Property();
    [NullableContextAttribute("2")]
public void set_Property(AvaloniaProperty value);
    private sealed virtual override AvaloniaProperty Avalonia.Animation.ITransition.get_Property();
    private sealed virtual override void Avalonia.Animation.ITransition.set_Property(AvaloniaProperty value);
    private sealed virtual override IDisposable Avalonia.Animation.ITransition.Apply(Animatable control, IClock clock, object oldValue, object newValue);
    internal abstract virtual IDisposable Apply(Animatable control, IClock clock, object oldValue, object newValue);
    internal virtual void BuildDebugDisplay(StringBuilder builder, bool includeContent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Animation.TransitionInstance : SingleSubscriberObservableBase`1<double> {
    [NullableAttribute("2")]
private IDisposable _timerSubscription;
    private TimeSpan _delay;
    private TimeSpan _duration;
    private IClock _baseClock;
    [NullableAttribute("2")]
private TransitionClock _clock;
    public TransitionInstance(IClock clock, TimeSpan delay, TimeSpan duration);
    private void TimerTick(TimeSpan t);
    protected virtual void Unsubscribed();
    protected virtual void Subscribed();
    private sealed virtual override void System.IObserver<System.TimeSpan>.OnCompleted();
    private sealed virtual override void System.IObserver<System.TimeSpan>.OnError(Exception error);
    private sealed virtual override void System.IObserver<System.TimeSpan>.OnNext(TimeSpan value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Avalonia.Animation.TransitionObservableBase`1 : SingleSubscriberObservableBase`1<T> {
    private IEasing _easing;
    private IObservable`1<double> _progress;
    [NullableAttribute("2")]
private IDisposable _progressSubscription;
    protected TransitionObservableBase`1(IObservable`1<double> progress, IEasing easing);
    protected abstract virtual T ProduceValue(double progress);
    protected virtual void Subscribed();
    protected virtual void Unsubscribed();
    private sealed virtual override void System.IObserver<System.Double>.OnCompleted();
    private sealed virtual override void System.IObserver<System.Double>.OnError(Exception error);
    private sealed virtual override void System.IObserver<System.Double>.OnNext(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Animation.Transitions : AvaloniaList`1<ITransition> {
    private sealed virtual override void Avalonia.Collections.IAvaloniaListItemValidator<Avalonia.Animation.ITransition>.Validate(ITransition item);
}
internal static class Avalonia.Animation.Utils.BounceEaseUtils : object {
    internal static double Bounce(double progress);
}
internal static class Avalonia.Animation.Utils.EasingUtils : object {
    internal static double HALFPI;
}
public class Avalonia.Animation.VectorTransition : Transition`1<Vector> {
    [NullableContextAttribute("1")]
internal virtual IObservable`1<Vector> DoTransition(IObservable`1<double> progress, Vector oldValue, Vector newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.AttachedProperty`1 : StyledProperty`1<TValue> {
    internal AttachedProperty`1(string name, Type ownerType, Type hostType, StyledPropertyMetadata`1<TValue> metadata, bool inherits, Func`2<TValue, bool> validate);
    public AttachedProperty`1<TValue> AddOwner(StyledPropertyMetadata`1<TValue> metadata);
}
public class Avalonia.AvaloniaInternalException : Exception {
    [NullableContextAttribute("1")]
public AvaloniaInternalException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.AvaloniaLocator : object {
    [NullableAttribute("2")]
private IAvaloniaDependencyResolver _parentScope;
    [CompilerGeneratedAttribute]
private static IAvaloniaDependencyResolver <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private static AvaloniaLocator <CurrentMutable>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, Func`1<object>> _registry;
    public static IAvaloniaDependencyResolver Current { get; public set; }
    public static AvaloniaLocator CurrentMutable { get; public set; }
    private static AvaloniaLocator();
    public AvaloniaLocator(IAvaloniaDependencyResolver parentScope);
    [CompilerGeneratedAttribute]
public static IAvaloniaDependencyResolver get_Current();
    [CompilerGeneratedAttribute]
public static void set_Current(IAvaloniaDependencyResolver value);
    [CompilerGeneratedAttribute]
public static AvaloniaLocator get_CurrentMutable();
    [CompilerGeneratedAttribute]
public static void set_CurrentMutable(AvaloniaLocator value);
    public sealed virtual object GetService(Type t);
    public RegistrationHelper`1<T> Bind();
    public AvaloniaLocator BindToSelf(T constant);
    public AvaloniaLocator BindToSelfSingleton();
    public static IDisposable EnterScope();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebugDisplay}")]
public class Avalonia.AvaloniaObject : object {
    private ValueStore _values;
    [NullableAttribute("2")]
private AvaloniaObject _inheritanceParent;
    [NullableAttribute("2")]
private PropertyChangedEventHandler _inpcChanged;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<AvaloniaPropertyChangedEventArgs> _propertyChanged;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<AvaloniaObject> _inheritanceChildren;
    [NullableAttribute("2")]
protected internal AvaloniaObject InheritanceParent { get; protected internal set; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public IBinding Item { get; public set; }
    internal string DebugDisplay { get; }
    public void add_PropertyChanged(EventHandler`1<AvaloniaPropertyChangedEventArgs> value);
    public void remove_PropertyChanged(EventHandler`1<AvaloniaPropertyChangedEventArgs> value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
protected internal AvaloniaObject get_InheritanceParent();
    [NullableContextAttribute("2")]
protected internal void set_InheritanceParent(AvaloniaObject value);
    public object get_Item(AvaloniaProperty property);
    public void set_Item(AvaloniaProperty property, object value);
    public IBinding get_Item(IndexerDescriptor binding);
    public void set_Item(IndexerDescriptor binding, IBinding value);
    internal string get_DebugDisplay();
    public bool CheckAccess();
    public void VerifyAccess();
    public void ClearValue(AvaloniaProperty property);
    public void ClearValue(AvaloniaProperty`1<T> property);
    public void ClearValue(StyledProperty`1<T> property);
    public void ClearValue(DirectPropertyBase`1<T> property);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public object GetValue(AvaloniaProperty property);
    public T GetValue(StyledProperty`1<T> property);
    public T GetValue(DirectPropertyBase`1<T> property);
    public Optional`1<T> GetBaseValue(StyledProperty`1<T> property);
    public bool IsAnimating(AvaloniaProperty property);
    public bool IsSet(AvaloniaProperty property);
    [NullableContextAttribute("2")]
public IDisposable SetValue(AvaloniaProperty property, object value, BindingPriority priority);
    public IDisposable SetValue(StyledProperty`1<T> property, T value, BindingPriority priority);
    public void SetValue(DirectPropertyBase`1<T> property, T value);
    public void SetCurrentValue(AvaloniaProperty property, object value);
    public void SetCurrentValue(StyledProperty`1<T> property, T value);
    public BindingExpressionBase Bind(AvaloniaProperty property, IBinding binding);
    public IDisposable Bind(AvaloniaProperty property, IObservable`1<object> source, BindingPriority priority);
    public IDisposable Bind(StyledProperty`1<T> property, IObservable`1<object> source, BindingPriority priority);
    private BindingExpressionBase TryBindStyledPropertyUntyped(AvaloniaProperty property, IObservable`1<object> source, BindingPriority priority);
    public IDisposable Bind(StyledProperty`1<T> property, IObservable`1<T> source, BindingPriority priority);
    public IDisposable Bind(StyledProperty`1<T> property, IObservable`1<BindingValue`1<T>> source, BindingPriority priority);
    public IDisposable Bind(DirectPropertyBase`1<T> property, IObservable`1<object> source);
    private BindingExpressionBase TryBindDirectPropertyUntyped(AvaloniaProperty& property, IObservable`1<object> source);
    public IDisposable Bind(DirectPropertyBase`1<T> property, IObservable`1<T> source);
    public IDisposable Bind(DirectPropertyBase`1<T> property, IObservable`1<BindingValue`1<T>> source);
    public void CoerceValue(AvaloniaProperty property);
    internal BindingExpressionBase Bind(AvaloniaProperty property, IBinding binding, object anchor);
    internal void AddInheritanceChild(AvaloniaObject child);
    internal void RemoveInheritanceChild(AvaloniaObject child);
    private sealed virtual override Delegate[] Avalonia.Diagnostics.IAvaloniaObjectDebug.GetPropertyChangedSubscribers();
    internal AvaloniaPropertyValue GetDiagnosticInternal(AvaloniaProperty property);
    internal ValueStore GetValueStore();
    internal IReadOnlyList`1<AvaloniaObject> GetInheritanceChildren();
    protected virtual void UpdateDataValidation(AvaloniaProperty property, BindingValueType state, Exception error);
    protected virtual void OnPropertyChangedCore(AvaloniaPropertyChangedEventArgs change);
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    protected void RaisePropertyChanged(DirectPropertyBase`1<T> property, T oldValue, T newValue);
    internal void RaisePropertyChanged(AvaloniaProperty`1<T> property, Optional`1<T> oldValue, BindingValue`1<T> newValue, BindingPriority priority, bool isEffectiveValue);
    protected bool SetAndRaise(DirectPropertyBase`1<T> property, T& field, T value);
    internal void SetDirectValueUnchecked(DirectPropertyBase`1<T> property, T value);
    internal void SetDirectValueUnchecked(DirectPropertyBase`1<T> property, BindingValue`1<T> value);
    internal void OnUpdateDataValidation(AvaloniaProperty property, BindingValueType state, Exception error);
    private string GetDescription(object o);
    private void LogPropertySet(AvaloniaProperty`1<T> property, T value, BindingPriority priority);
    internal string GetDebugDisplay(bool includeContent);
    internal virtual void BuildDebugDisplay(StringBuilder builder, bool includeContent);
    private static void ValidatePriority(BindingPriority priority);
    private static void ThrowInvalidPriority(BindingPriority priority);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.AvaloniaObjectExtensions : object {
    [ExtensionAttribute]
public static IBinding ToBinding(IObservable`1<T> source);
    [ExtensionAttribute]
public static IObservable`1<object> GetObservable(AvaloniaObject o, AvaloniaProperty property);
    [ExtensionAttribute]
public static IObservable`1<T> GetObservable(AvaloniaObject o, AvaloniaProperty`1<T> property);
    [ExtensionAttribute]
public static IObservable`1<TResult> GetObservable(AvaloniaObject o, AvaloniaProperty`1<TSource> property, Func`2<TSource, TResult> converter);
    [ExtensionAttribute]
public static IObservable`1<TResult> GetObservable(AvaloniaObject o, AvaloniaProperty property, Func`2<object, TResult> converter);
    [ExtensionAttribute]
public static IObservable`1<BindingValue`1<object>> GetBindingObservable(AvaloniaObject o, AvaloniaProperty property);
    [ExtensionAttribute]
public static IObservable`1<BindingValue`1<TResult>> GetBindingObservable(AvaloniaObject o, AvaloniaProperty property, Func`2<object, TResult> converter);
    [ExtensionAttribute]
public static IObservable`1<BindingValue`1<T>> GetBindingObservable(AvaloniaObject o, AvaloniaProperty`1<T> property);
    [ExtensionAttribute]
public static IObservable`1<BindingValue`1<TResult>> GetBindingObservable(AvaloniaObject o, AvaloniaProperty`1<TSource> property, Func`2<TSource, TResult> converter);
    [ExtensionAttribute]
public static IObservable`1<AvaloniaPropertyChangedEventArgs> GetPropertyChangedObservable(AvaloniaObject o, AvaloniaProperty property);
    [ExtensionAttribute]
public static IDisposable Bind(AvaloniaObject target, AvaloniaProperty`1<T> property, IObservable`1<BindingValue`1<T>> source, BindingPriority priority);
    [ExtensionAttribute]
public static IDisposable Bind(AvaloniaObject target, AvaloniaProperty`1<T> property, IObservable`1<T> source, BindingPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("Use AvaloniaObject.Bind(AvaloniaProperty, IBinding")]
public static IDisposable Bind(AvaloniaObject target, AvaloniaProperty property, IBinding binding, object anchor);
    [ExtensionAttribute]
public static T GetValue(AvaloniaObject target, AvaloniaProperty`1<T> property);
    [ExtensionAttribute]
public static object GetBaseValue(AvaloniaObject target, AvaloniaProperty property);
    [ExtensionAttribute]
public static Optional`1<T> GetBaseValue(AvaloniaObject target, AvaloniaProperty`1<T> property);
    [ExtensionAttribute]
public static IDisposable AddClassHandler(IObservable`1<AvaloniaPropertyChangedEventArgs> observable, Action`2<TTarget, AvaloniaPropertyChangedEventArgs> action);
    [ExtensionAttribute]
public static IDisposable AddClassHandler(IObservable`1<AvaloniaPropertyChangedEventArgs`1<TValue>> observable, Action`2<TTarget, AvaloniaPropertyChangedEventArgs`1<TValue>> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.AvaloniaProperty : object {
    public static object UnsetValue;
    private static int s_nextId;
    private AvaloniaPropertyMetadata _defaultMetadata;
    [NullableAttribute("2")]
private Type _singleHostType;
    [NullableAttribute("2")]
private AvaloniaPropertyMetadata _singleMetadata;
    private Dictionary`2<Type, AvaloniaPropertyMetadata> _metadata;
    private Dictionary`2<Type, AvaloniaPropertyMetadata> _metadataCache;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherits>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttached>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<AvaloniaObject, bool> <Notifying>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public string Name { get; }
    public Type PropertyType { get; }
    public Type OwnerType { get; }
    public bool Inherits { get; private protected set; }
    public bool IsAttached { get; private protected set; }
    public bool IsDirect { get; private protected set; }
    public bool IsReadOnly { get; private protected set; }
    public IObservable`1<AvaloniaPropertyChangedEventArgs> Changed { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Action`2<AvaloniaObject, bool> Notifying { get; }
    internal int Id { get; }
    private bool Avalonia.Data.Core.IPropertyInfo.CanGet { get; }
    private bool Avalonia.Data.Core.IPropertyInfo.CanSet { get; }
    private protected AvaloniaProperty(string name, Type valueType, Type ownerType, Type hostType, AvaloniaPropertyMetadata metadata, Action`2<AvaloniaObject, bool> notifying);
    private protected AvaloniaProperty(AvaloniaProperty source, Type ownerType, AvaloniaPropertyMetadata metadata);
    private static AvaloniaProperty();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_PropertyType();
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
public bool get_Inherits();
    [CompilerGeneratedAttribute]
private protected void set_Inherits(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAttached();
    [CompilerGeneratedAttribute]
private protected void set_IsAttached(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDirect();
    [CompilerGeneratedAttribute]
private protected void set_IsDirect(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private protected void set_IsReadOnly(bool value);
    public IObservable`1<AvaloniaPropertyChangedEventArgs> get_Changed();
    [CompilerGeneratedAttribute]
internal Action`2<AvaloniaObject, bool> get_Notifying();
    [CompilerGeneratedAttribute]
internal int get_Id();
    public static IndexerDescriptor op_LogicalNot(AvaloniaProperty property);
    public static IndexerDescriptor op_OnesComplement(AvaloniaProperty property);
    [NullableContextAttribute("2")]
public static bool op_Equality(AvaloniaProperty a, AvaloniaProperty b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(AvaloniaProperty a, AvaloniaProperty b);
    public void Unregister(Type type);
    public static StyledProperty`1<TValue> Register(string name, TValue defaultValue, bool inherits, BindingMode defaultBindingMode, Func`2<TValue, bool> validate, Func`3<AvaloniaObject, TValue, TValue> coerce, bool enableDataValidation);
    internal static StyledProperty`1<TValue> Register(string name, TValue defaultValue, bool inherits, BindingMode defaultBindingMode, Func`2<TValue, bool> validate, Func`3<AvaloniaObject, TValue, TValue> coerce, bool enableDataValidation, Action`2<AvaloniaObject, bool> notifying);
    public static AttachedProperty`1<TValue> RegisterAttached(string name, TValue defaultValue, bool inherits, BindingMode defaultBindingMode, Func`2<TValue, bool> validate, Func`3<AvaloniaObject, TValue, TValue> coerce);
    public static AttachedProperty`1<TValue> RegisterAttached(string name, Type ownerType, TValue defaultValue, bool inherits, BindingMode defaultBindingMode, Func`2<TValue, bool> validate, Func`3<AvaloniaObject, TValue, TValue> coerce);
    public static DirectProperty`2<TOwner, TValue> RegisterDirect(string name, Func`2<TOwner, TValue> getter, Action`2<TOwner, TValue> setter, TValue unsetValue, BindingMode defaultBindingMode, bool enableDataValidation);
    public IndexerDescriptor Bind();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(AvaloniaProperty other);
    public virtual int GetHashCode();
    public AvaloniaPropertyMetadata GetMetadata();
    public AvaloniaPropertyMetadata GetMetadata(Type type);
    public AvaloniaPropertyMetadata GetMetadata(AvaloniaObject owner);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
public bool IsValidValue(object value);
    public virtual string ToString();
    internal abstract virtual EffectiveValue CreateEffectiveValue(AvaloniaObject o);
    internal abstract virtual void RouteClearValue(AvaloniaObject o);
    internal abstract virtual void RouteCoerceDefaultValue(AvaloniaObject o);
    internal abstract virtual object RouteGetValue(AvaloniaObject o);
    internal abstract virtual object RouteGetBaseValue(AvaloniaObject o);
    [NullableContextAttribute("2")]
internal abstract virtual IDisposable RouteSetValue(AvaloniaObject o, object value, BindingPriority priority);
    internal abstract virtual void RouteSetCurrentValue(AvaloniaObject o, object value);
    internal virtual void RouteSetDirectValueUnchecked(AvaloniaObject o, object value);
    internal abstract virtual IDisposable RouteBind(AvaloniaObject o, IObservable`1<object> source, BindingPriority priority);
    private protected void OverrideMetadata(Type type, AvaloniaPropertyMetadata metadata);
    private protected abstract virtual IObservable`1<AvaloniaPropertyChangedEventArgs> GetChanged();
    private AvaloniaPropertyMetadata GetMetadataFromCache(AvaloniaObject obj);
    private AvaloniaPropertyMetadata GetMetadataFromCache(Type type);
    private AvaloniaPropertyMetadata GetMetadataUncached(Type type);
    private sealed virtual override bool Avalonia.Data.Core.IPropertyInfo.get_CanGet();
    private sealed virtual override bool Avalonia.Data.Core.IPropertyInfo.get_CanSet();
    private sealed virtual override object Avalonia.Data.Core.IPropertyInfo.Get(object target);
    private sealed virtual override void Avalonia.Data.Core.IPropertyInfo.Set(object target, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.AvaloniaProperty`1 : AvaloniaProperty {
    private LightweightSubject`1<AvaloniaPropertyChangedEventArgs`1<TValue>> _changed;
    public IObservable`1<AvaloniaPropertyChangedEventArgs`1<TValue>> Changed { get; }
    private protected AvaloniaProperty`1(string name, Type ownerType, Type hostType, AvaloniaPropertyMetadata metadata, Action`2<AvaloniaObject, bool> notifying);
    private protected AvaloniaProperty`1(AvaloniaProperty`1<TValue> source, Type ownerType, AvaloniaPropertyMetadata metadata);
    public IObservable`1<AvaloniaPropertyChangedEventArgs`1<TValue>> get_Changed();
    internal void NotifyChanged(AvaloniaPropertyChangedEventArgs`1<TValue> e);
    private protected virtual IObservable`1<AvaloniaPropertyChangedEventArgs> GetChanged();
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
private protected BindingValue`1<object> TryConvert(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.AvaloniaPropertyChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private AvaloniaObject <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEffectiveValueChange>k__BackingField;
    public AvaloniaObject Sender { get; }
    public AvaloniaProperty Property { get; }
    [NullableAttribute("2")]
public object OldValue { get; }
    [NullableAttribute("2")]
public object NewValue { get; }
    public BindingPriority Priority { get; private set; }
    internal bool IsEffectiveValueChange { get; private set; }
    public AvaloniaPropertyChangedEventArgs(AvaloniaObject sender, BindingPriority priority);
    internal AvaloniaPropertyChangedEventArgs(AvaloniaObject sender, BindingPriority priority, bool isEffectiveValueChange);
    [CompilerGeneratedAttribute]
public AvaloniaObject get_Sender();
    public AvaloniaProperty get_Property();
    [NullableContextAttribute("2")]
public object get_OldValue();
    [NullableContextAttribute("2")]
public object get_NewValue();
    [CompilerGeneratedAttribute]
public BindingPriority get_Priority();
    [CompilerGeneratedAttribute]
private void set_Priority(BindingPriority value);
    [CompilerGeneratedAttribute]
internal bool get_IsEffectiveValueChange();
    [CompilerGeneratedAttribute]
private void set_IsEffectiveValueChange(bool value);
    protected abstract virtual AvaloniaProperty GetProperty();
    [NullableContextAttribute("2")]
protected abstract virtual object GetOldValue();
    [NullableContextAttribute("2")]
protected abstract virtual object GetNewValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.AvaloniaPropertyChangedEventArgs`1 : AvaloniaPropertyChangedEventArgs {
    [CompilerGeneratedAttribute]
private AvaloniaProperty`1<T> <Property>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Optional`1<T> <OldValue>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private BindingValue`1<T> <NewValue>k__BackingField;
    public AvaloniaProperty`1<T> Property { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Optional`1<T> OldValue { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public BindingValue`1<T> NewValue { get; private set; }
    public AvaloniaPropertyChangedEventArgs`1(AvaloniaObject sender, AvaloniaProperty`1<T> property, Optional`1<T> oldValue, BindingValue`1<T> newValue, BindingPriority priority);
    internal AvaloniaPropertyChangedEventArgs`1(AvaloniaObject sender, AvaloniaProperty`1<T> property, Optional`1<T> oldValue, BindingValue`1<T> newValue, BindingPriority priority, bool isEffectiveValueChange);
    [CompilerGeneratedAttribute]
public AvaloniaProperty`1<T> get_Property();
    [CompilerGeneratedAttribute]
public Optional`1<T> get_OldValue();
    [CompilerGeneratedAttribute]
private void set_OldValue(Optional`1<T> value);
    [CompilerGeneratedAttribute]
public BindingValue`1<T> get_NewValue();
    [CompilerGeneratedAttribute]
private void set_NewValue(BindingValue`1<T> value);
    protected virtual AvaloniaProperty GetProperty();
    [NullableContextAttribute("2")]
protected virtual object GetOldValue();
    [NullableContextAttribute("2")]
protected virtual object GetNewValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.AvaloniaPropertyChangedExtensions : object {
    [ExtensionAttribute]
public static T GetOldValue(AvaloniaPropertyChangedEventArgs e);
    [ExtensionAttribute]
public static T GetNewValue(AvaloniaPropertyChangedEventArgs e);
    [ExtensionAttribute]
public static ValueTuple`2<T, T> GetOldAndNewValue(AvaloniaPropertyChangedEventArgs e);
}
[ExtensionAttribute]
internal static class Avalonia.AvaloniaPropertyExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool CanValueAffectRender(AvaloniaProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.AvaloniaPropertyMetadata : object {
    private BindingMode _defaultBindingMode;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableDataValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public BindingMode DefaultBindingMode { get; }
    public Nullable`1<bool> EnableDataValidation { get; private set; }
    public bool IsReadOnly { get; private set; }
    public AvaloniaPropertyMetadata(BindingMode defaultBindingMode, Nullable`1<bool> enableDataValidation);
    public BindingMode get_DefaultBindingMode();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_EnableDataValidation();
    [CompilerGeneratedAttribute]
private void set_EnableDataValidation(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    public virtual void Merge(AvaloniaPropertyMetadata baseMetadata, AvaloniaProperty property);
    public void Freeze();
    public abstract virtual AvaloniaPropertyMetadata GenerateTypeSafeMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.AvaloniaPropertyRegistry : object {
    private Dictionary`2<int, AvaloniaProperty> _properties;
    private Dictionary`2<Type, Dictionary`2<int, AvaloniaProperty>> _registered;
    private Dictionary`2<Type, Dictionary`2<int, AvaloniaProperty>> _attached;
    private Dictionary`2<Type, Dictionary`2<int, AvaloniaProperty>> _direct;
    private Dictionary`2<Type, List`1<AvaloniaProperty>> _registeredCache;
    private Dictionary`2<Type, List`1<AvaloniaProperty>> _attachedCache;
    private Dictionary`2<Type, List`1<AvaloniaProperty>> _directCache;
    private Dictionary`2<Type, List`1<AvaloniaProperty>> _inheritedCache;
    [CompilerGeneratedAttribute]
private static AvaloniaPropertyRegistry <Instance>k__BackingField;
    private object _unregisteringLocker;
    public static AvaloniaPropertyRegistry Instance { get; }
    internal IReadOnlyCollection`1<AvaloniaProperty> Properties { get; }
    private static AvaloniaPropertyRegistry();
    [CompilerGeneratedAttribute]
public static AvaloniaPropertyRegistry get_Instance();
    internal IReadOnlyCollection`1<AvaloniaProperty> get_Properties();
    public bool UnregisterByModule(IEnumerable`1<Type> types);
    private void Unregister(Dictionary`2<Type, List`1<AvaloniaProperty>> dictionary, Type type);
    private void Unregister(Dictionary`2<Type, Dictionary`2<int, AvaloniaProperty>> dictionary, Type type);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2059")]
public IReadOnlyList`1<AvaloniaProperty> GetRegistered(Type type);
    public IReadOnlyList`1<AvaloniaProperty> GetRegisteredAttached(Type type);
    public IReadOnlyList`1<AvaloniaProperty> GetRegisteredDirect(Type type);
    public IReadOnlyList`1<AvaloniaProperty> GetRegisteredInherited(Type type);
    public IReadOnlyList`1<AvaloniaProperty> GetRegistered(AvaloniaObject o);
    public DirectPropertyBase`1<T> GetRegisteredDirect(AvaloniaObject o, DirectPropertyBase`1<T> property);
    internal AvaloniaProperty GetRegisteredDirectUntyped(AvaloniaObject o, AvaloniaProperty property);
    public AvaloniaProperty FindRegistered(Type type, string name);
    public AvaloniaProperty FindRegistered(AvaloniaObject o, string name);
    public DirectPropertyBase`1<T> FindRegisteredDirect(AvaloniaObject o, DirectPropertyBase`1<T> property);
    private AvaloniaProperty FindRegisteredDirectUntyped(AvaloniaObject o, AvaloniaProperty property);
    [NullableContextAttribute("2")]
internal AvaloniaProperty FindRegistered(int id);
    public bool IsRegistered(Type type, AvaloniaProperty property);
    public bool IsRegistered(object o, AvaloniaProperty property);
    public void Register(Type type, AvaloniaProperty property);
    public void RegisterAttached(Type type, AvaloniaProperty property);
    [CompilerGeneratedAttribute]
internal static bool <IsRegistered>g__ContainsProperty|29_0(IReadOnlyList`1<AvaloniaProperty> properties, AvaloniaProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.ClassBindingManager : object {
    private static Dictionary`2<string, AvaloniaProperty> s_RegisteredProperties;
    private static ClassBindingManager();
    public static IDisposable Bind(StyledElement target, string className, IBinding source, object anchor);
    private static AvaloniaProperty RegisterClassProxyProperty(string className);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Collections.AvaloniaDictionary`2 : object {
    private Dictionary`2<TKey, TValue> _inner;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public AvaloniaDictionary`2(int capacity);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private void NotifyAdd(TKey key, TValue value);
}
[ExtensionAttribute]
public static class Avalonia.Collections.AvaloniaDictionaryExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IDisposable ForEachItem(IAvaloniaReadOnlyDictionary`2<TKey, TValue> collection, Action`2<TKey, TValue> added, Action`2<TKey, TValue> removed, Action reset, bool weakSubscription);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Collections.AvaloniaList`1 : object {
    private List`1<T> _inner;
    [NullableAttribute("2")]
private NotifyCollectionChangedEventHandler _collectionChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private ResetBehavior <ResetBehavior>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IAvaloniaListItemValidator`1<T> <Validator>k__BackingField;
    public int Count { get; }
    public ResetBehavior ResetBehavior { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<T> Validate { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IAvaloniaListItemValidator`1<T> Validator { get; internal set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public int Capacity { get; public set; }
    public AvaloniaList`1(int capacity);
    public AvaloniaList`1(IEnumerable`1<T> items);
    public AvaloniaList`1(T[] items);
    [NullableContextAttribute("2")]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public ResetBehavior get_ResetBehavior();
    [CompilerGeneratedAttribute]
public void set_ResetBehavior(ResetBehavior value);
    public Action`1<T> get_Validate();
    public void set_Validate(Action`1<T> value);
    [CompilerGeneratedAttribute]
internal IAvaloniaListItemValidator`1<T> get_Validator();
    [CompilerGeneratedAttribute]
internal void set_Validator(IAvaloniaListItemValidator`1<T> value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public int get_Capacity();
    public void set_Capacity(int value);
    public virtual void Add(T item);
    public virtual void AddRange(IEnumerable`1<T> items);
    public virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public IEnumerable`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    public virtual void Insert(int index, T item);
    public virtual void InsertRange(int index, IEnumerable`1<T> items);
    public sealed virtual void Move(int oldIndex, int newIndex);
    public sealed virtual void MoveRange(int oldIndex, int count, int newIndex);
    public void EnsureCapacity(int capacity);
    public virtual bool Remove(T item);
    public virtual void RemoveAll(IEnumerable`1<T> items);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override Delegate[] Avalonia.Diagnostics.INotifyCollectionChangedDebug.GetCollectionChangedSubscribers();
    private void NotifyAdd(IList t, int index);
    private void NotifyAdd(T item, int index);
    private void NotifyCountChanged();
    private void NotifyRemove(IList t, int index);
    private void NotifyRemove(T item, int index);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
public class Avalonia.Collections.AvaloniaListConverter`1 : TypeConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Collections.AvaloniaListExtensions : object {
    [ExtensionAttribute]
public static IDisposable ForEachItem(IAvaloniaReadOnlyList`1<T> collection, Action`1<T> added, Action`1<T> removed, Action reset, bool weakSubscription);
    [ExtensionAttribute]
public static IDisposable ForEachItem(IAvaloniaReadOnlyList`1<T> collection, Action`2<int, T> added, Action`2<int, T> removed, Action reset, bool weakSubscription);
    [ExtensionAttribute]
public static IDisposable TrackItemPropertyChanged(IAvaloniaReadOnlyList`1<T> collection, Action`1<Tuple`2<object, PropertyChangedEventArgs>> callback);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Collections.EventArgsCache : object {
    internal static PropertyChangedEventArgs CountPropertyChanged;
    internal static NotifyCollectionChangedEventArgs ResetCollectionChanged;
    private static EventArgsCache();
}
public interface Avalonia.Collections.IAvaloniaDictionary`2 {
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface Avalonia.Collections.IAvaloniaList`1 {
    public int Count { get; }
    public T Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual void AddRange(IEnumerable`1<T> items);
    public abstract virtual void InsertRange(int index, IEnumerable`1<T> items);
    public abstract virtual void Move(int oldIndex, int newIndex);
    public abstract virtual void MoveRange(int oldIndex, int count, int newIndex);
    public abstract virtual void RemoveAll(IEnumerable`1<T> items);
    public abstract virtual void RemoveRange(int index, int count);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Collections.IAvaloniaListItemValidator`1 {
    public abstract virtual void Validate(T item);
}
public interface Avalonia.Collections.IAvaloniaReadOnlyDictionary`2 {
}
public interface Avalonia.Collections.IAvaloniaReadOnlyList`1 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Collections.NotifyCollectionChangedExtensions : object {
    [ExtensionAttribute]
public static IObservable`1<NotifyCollectionChangedEventArgs> GetWeakCollectionChangedObservable(INotifyCollectionChanged collection);
    [ExtensionAttribute]
public static IDisposable WeakSubscribe(INotifyCollectionChanged collection, NotifyCollectionChangedEventHandler handler);
    [ExtensionAttribute]
public static IDisposable WeakSubscribe(INotifyCollectionChanged collection, Action`1<NotifyCollectionChangedEventArgs> handler);
}
internal enum Avalonia.Collections.Pooled.ClearMode : Enum {
    public int value__;
    public static ClearMode Auto;
    public static ClearMode Always;
    public static ClearMode Never;
}
internal enum Avalonia.Collections.Pooled.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument text;
    public static ExceptionArgument values;
    public static ExceptionArgument value;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument task;
    public static ExceptionArgument ch;
    public static ExceptionArgument s;
    public static ExceptionArgument input;
    public static ExceptionArgument list;
    public static ExceptionArgument index;
    public static ExceptionArgument capacity;
    public static ExceptionArgument collection;
    public static ExceptionArgument item;
    public static ExceptionArgument converter;
    public static ExceptionArgument match;
    public static ExceptionArgument count;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument exceptions;
    public static ExceptionArgument exception;
    public static ExceptionArgument enumerable;
    public static ExceptionArgument start;
    public static ExceptionArgument format;
    public static ExceptionArgument culture;
    public static ExceptionArgument comparer;
    public static ExceptionArgument comparable;
    public static ExceptionArgument source;
    public static ExceptionArgument state;
    public static ExceptionArgument length;
    public static ExceptionArgument comparisonType;
    public static ExceptionArgument manager;
    public static ExceptionArgument sourceBytesToCopy;
    public static ExceptionArgument callBack;
    public static ExceptionArgument creationOptions;
    public static ExceptionArgument function;
    public static ExceptionArgument delay;
    public static ExceptionArgument millisecondsDelay;
    public static ExceptionArgument millisecondsTimeout;
    public static ExceptionArgument timeout;
    public static ExceptionArgument type;
    public static ExceptionArgument sourceIndex;
    public static ExceptionArgument sourceArray;
    public static ExceptionArgument destinationIndex;
    public static ExceptionArgument destinationArray;
    public static ExceptionArgument other;
    public static ExceptionArgument newSize;
    public static ExceptionArgument lowerBounds;
    public static ExceptionArgument lengths;
    public static ExceptionArgument len;
    public static ExceptionArgument keys;
    public static ExceptionArgument indices;
    public static ExceptionArgument endIndex;
    public static ExceptionArgument elementType;
    public static ExceptionArgument arrayIndex;
}
internal enum Avalonia.Collections.Pooled.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource Serialization_MissingKeys;
    public static ExceptionResource Serialization_NullKey;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource InvalidOperation_NullArray;
    public static ExceptionResource InvalidOperation_HSCapacityOverflow;
    public static ExceptionResource NotSupported_StringComparison;
    public static ExceptionResource ConcurrentCollection_SyncRoot_NotSupported;
    public static ExceptionResource ArgumentException_OtherNotArrayOfCorrectLength;
    public static ExceptionResource ArgumentOutOfRange_EndIndexStartIndex;
    public static ExceptionResource ArgumentOutOfRange_HugeArrayNotSupported;
    public static ExceptionResource Argument_AddingDuplicate;
    public static ExceptionResource Argument_InvalidArgumentForComparison;
    public static ExceptionResource Arg_LowerBoundsMustMatch;
    public static ExceptionResource Arg_MustBeType;
    public static ExceptionResource InvalidOperation_IComparerFailed;
    public static ExceptionResource NotSupported_FixedSizeCollection;
    public static ExceptionResource Rank_MultiDimNotSupported;
    public static ExceptionResource Arg_TypeNotSupported;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Collections.Pooled.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal interface Avalonia.Collections.Pooled.IReadOnlyPooledList`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> Span { get; }
    public abstract virtual ReadOnlySpan`1<T> get_Span();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Avalonia.Collections.Pooled.ICollectionDebugView`1")]
internal class Avalonia.Collections.Pooled.PooledList`1 : object {
    private static int MaxArrayLength;
    private static int DefaultCapacity;
    private static T[] s_emptyArray;
    private ArrayPool`1<T> _pool;
    [NullableAttribute("2")]
private object _syncRoot;
    private T[] _items;
    private int _size;
    private int _version;
    private bool _clearOnFree;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlySpan`1<T> Avalonia.Collections.Pooled.IReadOnlyPooledList<T>.Span { get; }
    public int Capacity { get; public set; }
    public int Count { get; }
    public ClearMode ClearMode { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public PooledList`1(ClearMode clearMode);
    public PooledList`1(ArrayPool`1<T> customPool);
    public PooledList`1(ClearMode clearMode, ArrayPool`1<T> customPool);
    public PooledList`1(int capacity);
    public PooledList`1(int capacity, bool sizeToCapacity);
    public PooledList`1(int capacity, ClearMode clearMode);
    public PooledList`1(int capacity, ClearMode clearMode, bool sizeToCapacity);
    public PooledList`1(int capacity, ArrayPool`1<T> customPool);
    public PooledList`1(int capacity, ArrayPool`1<T> customPool, bool sizeToCapacity);
    public PooledList`1(int capacity, ClearMode clearMode, ArrayPool`1<T> customPool);
    public PooledList`1(int capacity, ClearMode clearMode, ArrayPool`1<T> customPool, bool sizeToCapacity);
    public PooledList`1(T[] array);
    public PooledList`1(T[] array, ClearMode clearMode);
    public PooledList`1(T[] array, ArrayPool`1<T> customPool);
    public PooledList`1(T[] array, ClearMode clearMode, ArrayPool`1<T> customPool);
    public PooledList`1(ReadOnlySpan`1<T> span);
    public PooledList`1(ReadOnlySpan`1<T> span, ClearMode clearMode);
    public PooledList`1(ReadOnlySpan`1<T> span, ArrayPool`1<T> customPool);
    public PooledList`1(ReadOnlySpan`1<T> span, ClearMode clearMode, ArrayPool`1<T> customPool);
    public PooledList`1(IEnumerable`1<T> collection);
    public PooledList`1(IEnumerable`1<T> collection, ClearMode clearMode);
    public PooledList`1(IEnumerable`1<T> collection, ArrayPool`1<T> customPool);
    public PooledList`1(IEnumerable`1<T> collection, ClearMode clearMode, ArrayPool`1<T> customPool);
    private static PooledList`1();
    public Span`1<T> get_Span();
    private sealed virtual override ReadOnlySpan`1<T> Avalonia.Collections.Pooled.IReadOnlyPooledList<T>.get_Span();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public ClearMode get_ClearMode();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public void AddRange(T[] array);
    public void AddRange(ReadOnlySpan`1<T> span);
    public Span`1<T> AddSpan(int count);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public Span`1<T> AsSpan();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object item);
    public PooledList`1<TOutput> ConvertAll(Func`2<T, TOutput> converter);
    public void CopyTo(Span`1<T> span);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private void EnsureCapacity(int min);
    public bool Exists(Func`2<T, bool> match);
    public bool TryFind(Func`2<T, bool> match, T& result);
    public PooledList`1<T> FindAll(Func`2<T, bool> match);
    public int FindIndex(Func`2<T, bool> match);
    public int FindIndex(int startIndex, Func`2<T, bool> match);
    public int FindIndex(int startIndex, int count, Func`2<T, bool> match);
    public bool TryFindLast(Func`2<T, bool> match, T& result);
    public int FindLastIndex(Func`2<T, bool> match);
    public int FindLastIndex(int startIndex, Func`2<T, bool> match);
    public int FindLastIndex(int startIndex, int count, Func`2<T, bool> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Span`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public void InsertRange(int index, ReadOnlySpan`1<T> span);
    public void InsertRange(int index, T[] array);
    public Span`1<T> InsertSpan(int index, int count);
    private Span`1<T> InsertSpan(int index, int count, bool clearOutput);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Func`2<T, bool> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Func`3<T, T, int> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Func`2<T, bool> match);
    private void ReturnArray();
    private static bool ShouldClear(ClearMode mode);
    public virtual void Dispose();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("Avalonia.Collections.Pooled.StackDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Avalonia.Collections.Pooled.PooledStack`1 : object {
    private ArrayPool`1<T> _pool;
    [NullableAttribute("2")]
private object _syncRoot;
    private T[] _array;
    private int _size;
    private int _version;
    private bool _clearOnFree;
    private static int DefaultCapacity;
    public int Count { get; }
    public ClearMode ClearMode { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public PooledStack`1(ClearMode clearMode);
    public PooledStack`1(ArrayPool`1<T> customPool);
    public PooledStack`1(ClearMode clearMode, ArrayPool`1<T> customPool);
    public PooledStack`1(int capacity);
    public PooledStack`1(int capacity, ClearMode clearMode);
    public PooledStack`1(int capacity, ArrayPool`1<T> customPool);
    public PooledStack`1(int capacity, ClearMode clearMode, ArrayPool`1<T> customPool);
    public PooledStack`1(IEnumerable`1<T> enumerable);
    public PooledStack`1(IEnumerable`1<T> enumerable, ClearMode clearMode);
    public PooledStack`1(IEnumerable`1<T> enumerable, ArrayPool`1<T> customPool);
    public PooledStack`1(IEnumerable`1<T> enumerable, ClearMode clearMode, ArrayPool`1<T> customPool);
    public PooledStack`1(T[] array);
    public PooledStack`1(T[] array, ClearMode clearMode);
    public PooledStack`1(T[] array, ArrayPool`1<T> customPool);
    public PooledStack`1(T[] array, ClearMode clearMode, ArrayPool`1<T> customPool);
    public PooledStack`1(ReadOnlySpan`1<T> span);
    public PooledStack`1(ReadOnlySpan`1<T> span, ClearMode clearMode);
    public PooledStack`1(ReadOnlySpan`1<T> span, ArrayPool`1<T> customPool);
    public PooledStack`1(ReadOnlySpan`1<T> span, ClearMode clearMode, ArrayPool`1<T> customPool);
    public sealed virtual int get_Count();
    public ClearMode get_ClearMode();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public bool Contains(T item);
    public int RemoveWhere(Func`2<T, bool> match);
    public void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(Span`1<T> span);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void TrimExcess();
    public T Peek();
    public bool TryPeek(T& result);
    public T Pop();
    public bool TryPop(T& result);
    public void Push(T item);
    private void PushWithResize(T item);
    public T[] ToArray();
    private void ThrowForEmptyStack();
    private void ReturnArray(T[] replaceWith);
    private static bool ShouldClear(ClearMode mode);
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Collections.Pooled.StackDebugView`1 : object {
    private PooledStack`1<T> _stack;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public StackDebugView`1(PooledStack`1<T> stack);
    public T[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Collections.Pooled.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowArrayTypeMismatchException();
    [DoesNotReturnAttribute]
internal static void ThrowIndexOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_DestinationTooShort();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexException();
    [DoesNotReturnAttribute]
internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowValueArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
    [DoesNotReturnAttribute]
internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    [DoesNotReturnAttribute]
internal static void ThrowWrongKeyTypeArgumentException(T key, Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowWrongValueTypeArgumentException(T value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    [DoesNotReturnAttribute]
internal static void ThrowAddingDuplicateWithKeyArgumentException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowKeyNotFoundException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    [DoesNotReturnAttribute]
internal static void ThrowSerializationException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowSecurityException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowRankException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowUnauthorizedAccessException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException(string objectName, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException();
    [DoesNotReturnAttribute]
internal static void ThrowAggregateException(List`1<Exception> exceptions);
    [DoesNotReturnAttribute]
internal static void ThrowOutOfMemoryException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_Argument_InvalidArrayType();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_EnumCurrent(int index);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_NoValue();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_HandleIsNotInitialized();
    [DoesNotReturnAttribute]
internal static void ThrowFormatException_BadFormatSpecifier();
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    private static InvalidOperationException GetInvalidOperationException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    private static ArgumentException GetArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    private static InvalidOperationException GetInvalidOperationException_EnumCurrent(int index);
    [NullableContextAttribute("2")]
internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    [NullableContextAttribute("0")]
internal static void ThrowForUnsupportedVectorBaseType();
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
public enum Avalonia.Collections.ResetBehavior : Enum {
    public int value__;
    public static ResetBehavior Reset;
    public static ResetBehavior Remove;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Compatibility.NativeLibraryEx : object {
    public static IntPtr Load(string dll, Assembly assembly);
    public static IntPtr Load(string dll);
    public static bool TryGetExport(IntPtr handle, string name, IntPtr& address);
}
internal class Avalonia.Compatibility.OperatingSystemEx : object {
    public static bool IsWindows();
    public static bool IsMacOS();
    public static bool IsMacCatalyst();
    public static bool IsLinux();
    public static bool IsFreeBSD();
    public static bool IsAndroid();
    public static bool IsIOS();
    public static bool IsTvOS();
    public static bool IsBrowser();
    [NullableContextAttribute("1")]
public static bool IsOSPlatform(string platform);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Controls.ChildNameScope : object {
    private INameScope _parentScope;
    private NameScope _inner;
    public bool IsCompleted { get; }
    public ChildNameScope(INameScope parentScope);
    public sealed virtual void Register(string name, object element);
    public sealed virtual SynchronousCompletionAsyncResult`1<object> FindAsync(string name);
    public SynchronousCompletionAsyncResult`1<object> DoFindAsync(string name);
    public sealed virtual object Find(string name);
    public sealed virtual void Complete();
    public sealed virtual bool get_IsCompleted();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Controls.Classes : AvaloniaList`1<string> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SafeEnumerableHashSet`1<IClassesChangedListener> _listeners;
    internal int ListenerCount { get; }
    public Classes(IEnumerable`1<string> items);
    public Classes(String[] items);
    internal int get_ListenerCount();
    public static Classes Parse(string s);
    public virtual void Add(string name);
    public virtual void AddRange(IEnumerable`1<string> names);
    public virtual void Clear();
    public virtual void Insert(int index, string name);
    public virtual void InsertRange(int index, IEnumerable`1<string> names);
    public virtual bool Remove(string name);
    public virtual void RemoveAll(IEnumerable`1<string> names);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public void Replace(IList`1<string> source);
    private sealed virtual override void Avalonia.Controls.IPseudoClasses.Add(string name);
    private sealed virtual override bool Avalonia.Controls.IPseudoClasses.Remove(string name);
    internal void AddListener(IClassesChangedListener listener);
    internal void RemoveListener(IClassesChangedListener listener);
    private void NotifyChanged();
    private static void ThrowIfPseudoclass(string name, string operation);
    public void Set(string name, bool value);
}
internal interface Avalonia.Controls.IClassesChangedListener {
    public abstract virtual void Changed();
}
[NullableContextAttribute("2")]
public interface Avalonia.Controls.IDeferredContent {
    public abstract virtual object Build(IServiceProvider serviceProvider);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Controls.INameScope {
    public bool IsCompleted { get; }
    public abstract virtual void Register(string name, object element);
    public abstract virtual SynchronousCompletionAsyncResult`1<object> FindAsync(string name);
    public abstract virtual object Find(string name);
    public abstract virtual void Complete();
    public abstract virtual bool get_IsCompleted();
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Controls.IPseudoClasses {
    public abstract virtual void Add(string name);
    public abstract virtual bool Remove(string name);
    public abstract virtual bool Contains(string name);
}
[NullableContextAttribute("1")]
public interface Avalonia.Controls.IResourceDictionary {
    public IList`1<IResourceProvider> MergedDictionaries { get; }
    public IDictionary`2<ThemeVariant, IThemeVariantProvider> ThemeDictionaries { get; }
    public abstract virtual IList`1<IResourceProvider> get_MergedDictionaries();
    public abstract virtual IDictionary`2<ThemeVariant, IThemeVariantProvider> get_ThemeDictionaries();
}
[NotClientImplementableAttribute]
public interface Avalonia.Controls.IResourceHost {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResourcesChanged(EventHandler`1<ResourcesChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResourcesChanged(EventHandler`1<ResourcesChangedEventArgs> value);
    [NullableContextAttribute("1")]
public abstract virtual void NotifyHostedResourcesChanged(ResourcesChangedEventArgs e);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Controls.IResourceNode {
    public bool HasResources { get; }
    public abstract virtual bool get_HasResources();
    public abstract virtual bool TryGetResource(object key, ThemeVariant theme, Object& value);
}
[NullableContextAttribute("2")]
public interface Avalonia.Controls.IResourceProvider {
    public IResourceHost Owner { get; }
    public abstract virtual IResourceHost get_Owner();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OwnerChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OwnerChanged(EventHandler value);
    [NullableContextAttribute("1")]
public abstract virtual void AddOwner(IResourceHost owner);
    [NullableContextAttribute("1")]
public abstract virtual void RemoveOwner(IResourceHost owner);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Controls.ISetInheritanceParent {
    public abstract virtual void SetParent(AvaloniaObject parent);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Controls.ISetLogicalParent {
    public abstract virtual void SetParent(ILogical parent);
}
[NullableContextAttribute("2")]
public interface Avalonia.Controls.IThemeVariantProvider {
    public ThemeVariant Key { get; public set; }
    public abstract virtual ThemeVariant get_Key();
    public abstract virtual void set_Key(ThemeVariant value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Avalonia.Controls.Metadata.PseudoClassesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PseudoClasses>k__BackingField;
    public IReadOnlyList`1<string> PseudoClasses { get; }
    public PseudoClassesAttribute(String[] pseudoClasses);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PseudoClasses();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Avalonia.Controls.Metadata.TemplatePartAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public bool IsRequired { get; public set; }
    public TemplatePartAttribute(string name, Type type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Controls.NameScope : object {
    public static AttachedProperty`1<INameScope> NameScopeProperty;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    private Dictionary`2<string, object> _inner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, SynchronousCompletionAsyncResultSource`1<object>> _pendingSearches;
    public bool IsCompleted { get; private set; }
    private static NameScope();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    public static INameScope GetNameScope(StyledElement styled);
    public static void SetNameScope(StyledElement styled, INameScope value);
    public sealed virtual void Register(string name, object element);
    public sealed virtual SynchronousCompletionAsyncResult`1<object> FindAsync(string name);
    public sealed virtual object Find(string name);
    public sealed virtual void Complete();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Controls.NameScopeExtensions : object {
    [ExtensionAttribute]
public static T Find(INameScope nameScope, string name);
    [ExtensionAttribute]
public static T Find(ILogical anchor, string name);
    [ExtensionAttribute]
public static T Get(INameScope nameScope, string name);
    [ExtensionAttribute]
public static T Get(ILogical anchor, string name);
    [ExtensionAttribute]
public static INameScope FindNameScope(ILogical control);
}
public class Avalonia.Controls.NameScopeLocator : object {
    [NullableContextAttribute("1")]
public static IObservable`1<object> Track(INameScope scope, string name);
}
internal interface Avalonia.Controls.Primitives.IInternalScroller {
    public bool CanHorizontallyScroll { get; }
    public bool CanVerticallyScroll { get; }
    public abstract virtual bool get_CanHorizontallyScroll();
    public abstract virtual bool get_CanVerticallyScroll();
}
[ExtensionAttribute]
public static class Avalonia.Controls.PseudolassesExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Set(IPseudoClasses classes, string name, bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Controls.ResourceDictionary : ResourceProvider {
    [NullableAttribute("2")]
private object _lastDeferredItemKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<object, object> _inner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AvaloniaList`1<IResourceProvider> _mergedDictionaries;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AvaloniaDictionary`2<ThemeVariant, IThemeVariantProvider> _themeDictionary;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ThemeVariant <Avalonia.Controls.IThemeVariantProvider.Key>k__BackingField;
    public int Count { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ICollection`1<object> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ICollection`1<object> Values { get; }
    public IList`1<IResourceProvider> MergedDictionaries { get; }
    public IDictionary`2<ThemeVariant, IThemeVariantProvider> ThemeDictionaries { get; }
    [NullableAttribute("2")]
private ThemeVariant Avalonia.Controls.IThemeVariantProvider.Key { get; private set; }
    public bool HasResources { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.IsReadOnly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<object, object> Inner { get; }
    public ResourceDictionary(IResourceHost owner);
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection`1<object> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual IList`1<IResourceProvider> get_MergedDictionaries();
    public sealed virtual IDictionary`2<ThemeVariant, IThemeVariantProvider> get_ThemeDictionaries();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private sealed virtual override ThemeVariant Avalonia.Controls.IThemeVariantProvider.get_Key();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private sealed virtual override void Avalonia.Controls.IThemeVariantProvider.set_Key(ThemeVariant value);
    public sealed virtual bool get_HasResources();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.get_IsReadOnly();
    private Dictionary`2<object, object> get_Inner();
    public sealed virtual void Add(object key, object value);
    public void AddDeferred(object key, Func`2<IServiceProvider, object> factory);
    public void AddDeferred(object key, IDeferredContent deferredContent);
    public void AddNotSharedDeferred(object key, IDeferredContent deferredContent);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(object key);
    public sealed virtual bool Remove(object key);
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetResource(object key, ThemeVariant theme, Object& value);
    public sealed virtual bool TryGetValue(object key, Object& value);
    public void EnsureCapacity(int capacity);
    public sealed virtual IEnumerator`1<KeyValuePair`2<object, object>> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.Add(KeyValuePair`2<object, object> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.Contains(KeyValuePair`2<object, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.Remove(KeyValuePair`2<object, object> item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal bool ContainsDeferredKey(object key);
    protected sealed virtual void OnAddOwner(IResourceHost owner);
    protected sealed virtual void OnRemoveOwner(IResourceHost owner);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <get_MergedDictionaries>b__16_0(IResourceProvider x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <get_MergedDictionaries>b__16_1(IResourceProvider x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <get_ThemeDictionaries>b__18_0(ThemeVariant _, IThemeVariantProvider x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <get_ThemeDictionaries>b__18_1(ThemeVariant _, IThemeVariantProvider x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Controls.ResourceNodeExtensions : object {
    [ExtensionAttribute]
public static object FindResource(IResourceHost control, object key);
    [ExtensionAttribute]
public static bool TryFindResource(IResourceHost control, object key, Object& value);
    [ExtensionAttribute]
public static object FindResource(IResourceHost control, ThemeVariant theme, object key);
    [ExtensionAttribute]
public static bool TryFindResource(IResourceHost control, object key, ThemeVariant theme, Object& value);
    [ExtensionAttribute]
public static bool TryGetResource(IResourceHost control, object key, Object& value);
    [ExtensionAttribute]
public static IObservable`1<object> GetResourceObservable(IResourceHost control, object key, Func`2<object, object> converter);
    [ExtensionAttribute]
public static IObservable`1<object> GetResourceObservable(IResourceProvider resourceProvider, object key, Func`2<object, object> converter);
    [ExtensionAttribute]
public static IObservable`1<object> GetResourceObservable(IResourceProvider resourceProvider, object key, ThemeVariant defaultThemeVariant, Func`2<object, object> converter);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Avalonia.Controls.ResourceProvider : AvaloniaObject {
    private IResourceHost _owner;
    [CompilerGeneratedAttribute]
private EventHandler OwnerChanged;
    public bool HasResources { get; }
    public IResourceHost Owner { get; private set; }
    [NullableContextAttribute("1")]
public ResourceProvider(IResourceHost owner);
    public abstract virtual bool get_HasResources();
    public abstract virtual bool TryGetResource(object key, ThemeVariant theme, Object& value);
    public sealed virtual IResourceHost get_Owner();
    private void set_Owner(IResourceHost value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OwnerChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OwnerChanged(EventHandler value);
    protected void RaiseResourcesChanged();
    [NullableContextAttribute("1")]
protected virtual void OnAddOwner(IResourceHost owner);
    [NullableContextAttribute("1")]
protected virtual void OnRemoveOwner(IResourceHost owner);
    [NullableContextAttribute("1")]
private sealed virtual override void Avalonia.Controls.IResourceProvider.AddOwner(IResourceHost owner);
    [NullableContextAttribute("1")]
private sealed virtual override void Avalonia.Controls.IResourceProvider.RemoveOwner(IResourceHost owner);
}
public class Avalonia.Controls.ResourcesChangedEventArgs : EventArgs {
    [NullableAttribute("1")]
public static ResourcesChangedEventArgs Empty;
    private static ResourcesChangedEventArgs();
}
[NullableContextAttribute("1")]
public interface Avalonia.Controls.Templates.ITemplateResult {
    [NullableAttribute("2")]
public object Result { get; }
    public INameScope NameScope { get; }
    [NullableContextAttribute("2")]
public abstract virtual object get_Result();
    public abstract virtual INameScope get_NameScope();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Controls.Templates.TemplateResult`1 : object {
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private INameScope <NameScope>k__BackingField;
    public T Result { get; }
    public INameScope NameScope { get; }
    [NullableAttribute("2")]
private object Avalonia.Controls.Templates.ITemplateResult.Result { get; }
    public TemplateResult`1(T result, INameScope nameScope);
    [CompilerGeneratedAttribute]
public T get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual INameScope get_NameScope();
    [NullableContextAttribute("2")]
private sealed virtual override object Avalonia.Controls.Templates.ITemplateResult.get_Result();
    public void Deconstruct(T& result, INameScope& scope);
}
[IsReadOnlyAttribute]
public class Avalonia.CornerRadius : ValueType {
    [CompilerGeneratedAttribute]
private double <TopLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TopRight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BottomRight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BottomLeft>k__BackingField;
    public double TopLeft { get; }
    public double TopRight { get; }
    public double BottomRight { get; }
    public double BottomLeft { get; }
    public bool IsUniform { get; }
    public CornerRadius(double uniformRadius);
    public CornerRadius(double top, double bottom);
    public CornerRadius(double topLeft, double topRight, double bottomRight, double bottomLeft);
    [CompilerGeneratedAttribute]
public double get_TopLeft();
    [CompilerGeneratedAttribute]
public double get_TopRight();
    [CompilerGeneratedAttribute]
public double get_BottomRight();
    [CompilerGeneratedAttribute]
public double get_BottomLeft();
    public bool get_IsUniform();
    public sealed virtual bool Equals(CornerRadius other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static CornerRadius Parse(string s);
    public static bool op_Equality(CornerRadius left, CornerRadius right);
    public static bool op_Inequality(CornerRadius left, CornerRadius right);
}
[AttributeUsageAttribute("128")]
public class Avalonia.Data.AssignBindingAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.BindingChainException : Exception {
    [NullableAttribute("1")]
private string _message;
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpressionErrorPoint>k__BackingField;
    public string Expression { get; protected set; }
    public string ExpressionErrorPoint { get; protected set; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableContextAttribute("1")]
public BindingChainException(string message);
    [NullableContextAttribute("1")]
public BindingChainException(string message, string expression, string errorPoint);
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
protected void set_Expression(string value);
    [CompilerGeneratedAttribute]
public string get_ExpressionErrorPoint();
    [CompilerGeneratedAttribute]
protected void set_ExpressionErrorPoint(string value);
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
public enum Avalonia.Data.BindingErrorType : Enum {
    public int value__;
    public static BindingErrorType None;
    public static BindingErrorType Error;
    public static BindingErrorType DataValidationError;
}
[ExtensionAttribute]
internal static class Avalonia.Data.BindingErrorTypeExtensions : object {
    [ExtensionAttribute]
public static BindingValueType ToBindingValueType(BindingErrorType type);
}
public abstract class Avalonia.Data.BindingExpressionBase : object {
    [CompilerGeneratedAttribute]
private BindingMode <Mode>k__BackingField;
    internal BindingMode Mode { get; private protected set; }
    [CompilerGeneratedAttribute]
internal BindingMode get_Mode();
    [CompilerGeneratedAttribute]
private protected void set_Mode(BindingMode value);
    public virtual void Dispose();
    public virtual void UpdateSource();
    public virtual void UpdateTarget();
    [NullableContextAttribute("1")]
internal abstract virtual void Attach(ValueStore valueStore, ImmediateValueFrame frame, AvaloniaObject target, AvaloniaProperty targetProperty, BindingPriority priority);
}
public enum Avalonia.Data.BindingMode : Enum {
    public int value__;
    public static BindingMode Default;
    public static BindingMode OneWay;
    public static BindingMode TwoWay;
    public static BindingMode OneTime;
    public static BindingMode OneWayToSource;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.BindingNotification : object {
    [NullableAttribute("1")]
public static BindingNotification Null;
    [NullableAttribute("1")]
public static BindingNotification UnsetValue;
    private object _value;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingErrorType <ErrorType>k__BackingField;
    public object Value { get; }
    public bool HasValue { get; }
    public Exception Error { get; public set; }
    public BindingErrorType ErrorType { get; public set; }
    public BindingNotification(object value);
    [NullableContextAttribute("1")]
public BindingNotification(Exception error, BindingErrorType errorType);
    [NullableContextAttribute("1")]
public BindingNotification(Exception error, BindingErrorType errorType, object fallbackValue);
    private static BindingNotification();
    public object get_Value();
    public bool get_HasValue();
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public BindingErrorType get_ErrorType();
    [CompilerGeneratedAttribute]
public void set_ErrorType(BindingErrorType value);
    public static bool op_Equality(BindingNotification a, BindingNotification b);
    public static bool op_Inequality(BindingNotification a, BindingNotification b);
    public static object ExtractValue(object o);
    public static object UpdateValue(object o, object value);
    public static object ExtractError(object o);
    public virtual bool Equals(object obj);
    public bool Equals(BindingNotification other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public void AddError(Exception e, BindingErrorType type);
    public void ClearValue();
    public void SetValue(object value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private static bool ExceptionEquals(Exception a, Exception b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Data.BindingOperations : object {
    public static object DoNothing;
    private static BindingOperations();
    [ObsoleteAttribute("This API may be removed in Avalonia 12. If you depend on this API, please open an issue with details of your use-case.")]
public static IDisposable Apply(AvaloniaObject target, AvaloniaProperty property, InstancedBinding binding);
    [ObsoleteAttribute("Use the Apply(AvaloniaObject, AvaloniaProperty, InstancedBinding) overload.")]
public static IDisposable Apply(AvaloniaObject target, AvaloniaProperty property, InstancedBinding binding, object anchor);
    public static BindingExpressionBase GetBindingExpressionBase(AvaloniaObject target, AvaloniaProperty property);
}
public enum Avalonia.Data.BindingPriority : Enum {
    public int value__;
    public static BindingPriority Animation;
    public static BindingPriority LocalValue;
    public static BindingPriority StyleTrigger;
    public static BindingPriority Template;
    public static BindingPriority Style;
    public static BindingPriority Inherited;
    public static BindingPriority Unset;
    [ObsoleteAttribute("Use Template priority")]
[EditorBrowsableAttribute("1")]
public static BindingPriority TemplatedParent;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Avalonia.Data.BindingValue`1 : ValueType {
    private T _value;
    [CompilerGeneratedAttribute]
private BindingValueType <Type>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    public bool HasError { get; }
    public bool HasValue { get; }
    public BindingValueType Type { get; }
    public T Value { get; }
    [NullableAttribute("2")]
public Exception Error { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static BindingValue`1<T> Unset { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static BindingValue`1<T> DoNothing { get; }
    public BindingValue`1(T value);
    [NullableContextAttribute("2")]
private BindingValue`1(BindingValueType type, T value, Exception error);
    public bool get_HasError();
    public bool get_HasValue();
    [CompilerGeneratedAttribute]
public BindingValueType get_Type();
    public T get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    public Optional`1<T> ToOptional();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public object ToUntyped();
    public BindingValue`1<T> WithValue(T value);
    [NullableContextAttribute("2")]
public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
    [NullableContextAttribute("2")]
public TResult GetValueOrDefault();
    [NullableContextAttribute("2")]
public TResult GetValueOrDefault(TResult defaultValue);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
public static BindingValue`1<T> FromUntyped(object value);
    [RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
public static BindingValue`1<T> FromUntyped(object value, Type targetType);
    public static BindingValue`1<T> op_Implicit(T value);
    public static BindingValue`1<T> op_Implicit(Optional`1<T> optional);
    public static BindingValue`1<T> get_Unset();
    public static BindingValue`1<T> get_DoNothing();
    public static BindingValue`1<T> BindingError(Exception e);
    public static BindingValue`1<T> BindingError(Exception e, T fallbackValue);
    public static BindingValue`1<T> BindingError(Exception e, Optional`1<T> fallbackValue);
    public static BindingValue`1<T> DataValidationError(Exception e);
    public static BindingValue`1<T> DataValidationError(Exception e, T fallbackValue);
    public static BindingValue`1<T> DataValidationError(Exception e, Optional`1<T> fallbackValue);
    [NullableContextAttribute("2")]
internal static BindingValue`1<T> FromUntypedStrict(object value);
    [ConditionalAttribute("DEBUG")]
private static void ValidateValue(T value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BindingValue`1<T> left, BindingValue`1<T> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BindingValue`1<T> left, BindingValue`1<T> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BindingValue`1<T> other);
}
[FlagsAttribute]
public enum Avalonia.Data.BindingValueType : Enum {
    public int value__;
    public static BindingValueType UnsetValue;
    public static BindingValueType DoNothing;
    public static BindingValueType Value;
    public static BindingValueType BindingError;
    public static BindingValueType DataValidationError;
    public static BindingValueType BindingErrorWithFallback;
    public static BindingValueType DataValidationErrorWithFallback;
    public static BindingValueType TypeMask;
    public static BindingValueType HasValue;
    public static BindingValueType HasError;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Data.Converters.BoolConverters : object {
    public static IMultiValueConverter And;
    public static IMultiValueConverter Or;
    public static IValueConverter Not;
    private static BoolConverters();
}
[RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
public class Avalonia.Data.Converters.DefaultValueConverter : object {
    [NullableAttribute("1")]
public static DefaultValueConverter Instance;
    private static DefaultValueConverter();
    [NullableContextAttribute("2")]
public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    [NullableContextAttribute("2")]
public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Avalonia.Data.Converters.FuncMultiValueConverter`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IEnumerable`1<TIn>, TOut> _convert;
    public FuncMultiValueConverter`2(Func`2<IEnumerable`1<TIn>, TOut> convert);
    [NullableContextAttribute("1")]
public sealed virtual object Convert(IList`1<object> values, Type targetType, object parameter, CultureInfo culture);
    [IteratorStateMachineAttribute("Avalonia.Data.Converters.FuncMultiValueConverter`2/<<Convert>g__OfTypeWithDefaultSupport|2_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TIn> <Convert>g__OfTypeWithDefaultSupport|2_0(IList`1<object> list);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.Converters.FuncValueConverter`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<TIn, TOut> _convert;
    public FuncValueConverter`2(Func`2<TIn, TOut> convert);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.Converters.FuncValueConverter`3 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<TIn, TParam, TOut> _convert;
    public FuncValueConverter`3(Func`3<TIn, TParam, TOut> convert);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[NullableContextAttribute("1")]
public interface Avalonia.Data.Converters.IMultiValueConverter {
    public abstract virtual object Convert(IList`1<object> values, Type targetType, object parameter, CultureInfo culture);
}
[NullableContextAttribute("2")]
public interface Avalonia.Data.Converters.IValueConverter {
    public abstract virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public abstract virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("BindingExpression and ReflectionBinding heavily use reflection. Consider using CompiledBindings instead.")]
internal class Avalonia.Data.Converters.MethodToCommandConverter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<object, bool> AlwaysEnabled;
    private static MethodInfo tryConvert;
    private static PropertyInfo currentCulture;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, bool> canExecute;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<object> execute;
    [NullableAttribute("2")]
private WeakPropertyChangedProxy weakPropertyChanged;
    [NullableAttribute("2")]
private PropertyChangedEventHandler propertyChangedEventHandler;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private String[] dependencyProperties;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    public MethodToCommandConverter(Delegate action);
    private static MethodToCommandConverter();
    private void OnPropertyChanged(object sender, PropertyChangedEventArgs args);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual bool CanExecute(object parameter);
    [NullableContextAttribute("2")]
public sealed virtual void Execute(object parameter);
    private static Action`1<object> CreateExecute(object target, MethodInfo method);
    private static Action`1<object> CreateExecute(object target, MethodInfo method, Type parameterType);
    private static Func`2<object, bool> CreateCanExecute(object target, MethodInfo method);
    [NullableContextAttribute("2")]
private static Expression ConvertTarget(object target, MethodInfo method);
    [CompilerGeneratedAttribute]
private void <OnPropertyChanged>b__9_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Data.Converters.ObjectConverters : object {
    public static IValueConverter IsNull;
    public static IValueConverter IsNotNull;
    public static IValueConverter Equal;
    public static IValueConverter NotEqual;
    private static ObjectConverters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Data.Converters.StringConverters : object {
    public static IValueConverter IsNullOrEmpty;
    public static IValueConverter IsNotNullOrEmpty;
    private static StringConverters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Converters.StringFormatMultiValueConverter : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IMultiValueConverter <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NullableAttribute("2")]
public IMultiValueConverter Inner { get; }
    public string Format { get; }
    public StringFormatMultiValueConverter(string format, IMultiValueConverter inner);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IMultiValueConverter get_Inner();
    [CompilerGeneratedAttribute]
public string get_Format();
    public sealed virtual object Convert(IList`1<object> values, Type targetType, object parameter, CultureInfo culture);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.Converters.StringFormatValueConverter : object {
    [CompilerGeneratedAttribute]
private IValueConverter <Inner>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public IValueConverter Inner { get; }
    [NullableAttribute("1")]
public string Format { get; }
    [NullableContextAttribute("1")]
public StringFormatValueConverter(string format, IValueConverter inner);
    [CompilerGeneratedAttribute]
public IValueConverter get_Inner();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Format();
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.BindingError : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingErrorType <ErrorType>k__BackingField;
    public Exception Exception { get; }
    public BindingErrorType ErrorType { get; }
    public BindingError(Exception exception, BindingErrorType errorType);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public BindingErrorType get_ErrorType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.BindingExpression : UntypedBindingExpressionBase {
    [NullableAttribute("1")]
private static List`1<ExpressionNode> s_emptyExpressionNodes;
    private WeakReference`1<object> _source;
    private BindingMode _mode;
    [NullableAttribute("1")]
private List`1<ExpressionNode> _nodes;
    private TargetTypeConverter _targetTypeConverter;
    private UncommonFields _uncommon;
    [NullableAttribute("1")]
public string Description { get; }
    public Type SourceType { get; }
    public IValueConverter Converter { get; }
    [NullableAttribute("1")]
public CultureInfo ConverterCulture { get; }
    public object ConverterParameter { get; }
    public object FallbackValue { get; }
    [NullableAttribute("1")]
public ExpressionNode LeafNode { get; }
    public string StringFormat { get; }
    public object TargetNullValue { get; }
    public UpdateSourceTrigger UpdateSourceTrigger { get; }
    public BindingExpression(object source, List`1<ExpressionNode> nodes, object fallbackValue, IValueConverter converter, CultureInfo converterCulture, object converterParameter, bool enableDataValidation, BindingMode mode, BindingPriority priority, string stringFormat, object targetNullValue, AvaloniaProperty targetProperty, TargetTypeConverter targetTypeConverter, UpdateSourceTrigger updateSourceTrigger);
    private static BindingExpression();
    [NullableContextAttribute("1")]
public virtual string get_Description();
    public Type get_SourceType();
    public IValueConverter get_Converter();
    [NullableContextAttribute("1")]
public CultureInfo get_ConverterCulture();
    public object get_ConverterParameter();
    public object get_FallbackValue();
    [NullableContextAttribute("1")]
public ExpressionNode get_LeafNode();
    public string get_StringFormat();
    public object get_TargetNullValue();
    public UpdateSourceTrigger get_UpdateSourceTrigger();
    public virtual void UpdateSource();
    public virtual void UpdateTarget();
    [RequiresUnreferencedCodeAttribute("ExpressionNode might require unreferenced code.")]
internal static BindingExpression Create(TIn source, Expression`1<Func`2<TIn, TOut>> expression, IValueConverter converter, CultureInfo converterCulture, object converterParameter, bool enableDataValidation, Optional`1<object> fallbackValue, BindingMode mode, BindingPriority priority, object targetNullValue, bool allowReflection);
    internal void OnNodeValueChanged(int nodeIndex, object value, Exception dataValidationError);
    [NullableContextAttribute("1")]
internal void OnNodeError(int nodeIndex, string error);
    [NullableContextAttribute("1")]
internal void OnDataValidationError(Exception error);
    internal virtual bool WriteValueToSource(object value);
    protected virtual bool ShouldLogError(AvaloniaObject& target);
    protected virtual void StartCore();
    protected virtual void StopCore();
    [NullableContextAttribute("1")]
private string CalculateErrorPoint(int nodeIndex);
    [NullableContextAttribute("1")]
private void Log(AvaloniaObject target, string error, string errorPoint, LogEventLevel level);
    private void ConvertAndPublishValue(object value, BindingError error);
    private void WriteTargetValueToSource();
    [NullableContextAttribute("1")]
private void OnTargetLostFocus(object sender, RoutedEventArgs e);
    [NullableContextAttribute("1")]
private void OnTargetPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
    private object ConvertFallback(object fallback, string fallbackName);
    private object ConvertFrom(TargetTypeConverter converter, object value, BindingError& error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.CastTypePropertyPathElement : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public CastTypePropertyPathElement(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
}
public class Avalonia.Data.Core.ChildTraversalPropertyPathElement : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.ClrPropertyInfo : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _getter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _setter;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    public string Name { get; }
    public Type PropertyType { get; }
    public bool CanSet { get; }
    public bool CanGet { get; }
    public ClrPropertyInfo(string name, Func`2<object, object> getter, Action`2<object, object> setter, Type propertyType);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_PropertyType();
    public sealed virtual object Get(object target);
    public sealed virtual void Set(object target, object value);
    public sealed virtual bool get_CanSet();
    public sealed virtual bool get_CanGet();
}
internal static class Avalonia.Data.Core.CommonPropertyNames : object {
    [NullableAttribute("1")]
public static string IndexerName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.EnsureTypePropertyPathElement : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public EnsureTypePropertyPathElement(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.ArrayIndexerNode : ExpressionNode {
    private Int32[] _indexes;
    [NullableAttribute("2")]
public Type ValueType { get; }
    public ArrayIndexerNode(Int32[] indexes);
    [NullableContextAttribute("2")]
public sealed virtual Type get_ValueType();
    public virtual void BuildString(StringBuilder builder);
    public sealed virtual bool WriteValueToSource(object value, IReadOnlyList`1<ExpressionNode> nodes);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.AvaloniaPropertyAccessorNode : ExpressionNode {
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    public AvaloniaProperty Property { get; }
    [NullableAttribute("2")]
public Type ValueType { get; }
    public AvaloniaPropertyAccessorNode(AvaloniaProperty property);
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    [NullableContextAttribute("2")]
public sealed virtual Type get_ValueType();
    public virtual void BuildString(StringBuilder builder);
    public sealed virtual bool WriteValueToSource(object value, IReadOnlyList`1<ExpressionNode> nodes);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object oldSource);
    public sealed virtual void OnEvent(object sender, WeakEvent ev, AvaloniaPropertyChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Data.Core.ExpressionNodes.CollectionNodeBase : ExpressionNode {
    private sealed virtual override void Avalonia.Utilities.IWeakEventSubscriber<System.Collections.Specialized.NotifyCollectionChangedEventArgs>.OnEvent(object sender, WeakEvent ev, NotifyCollectionChangedEventArgs e);
    private sealed virtual override void Avalonia.Utilities.IWeakEventSubscriber<System.ComponentModel.PropertyChangedEventArgs>.OnEvent(object sender, WeakEvent ev, PropertyChangedEventArgs e);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object source);
    protected abstract virtual bool ShouldUpdate(object sender, PropertyChangedEventArgs e);
    protected abstract virtual Nullable`1<int> TryGetFirstArgumentAsInt();
    [NullableContextAttribute("2")]
protected abstract virtual void UpdateValue(object source);
    private bool ShouldUpdate(object sender, NotifyCollectionChangedEventArgs e);
    [NullableContextAttribute("2")]
private void Subscribe(object source);
    [NullableContextAttribute("2")]
private void UpdateValueOrSetError(object source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.DataContextNode : DataContextNodeBase {
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object oldSource);
    private void OnPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
}
internal abstract class Avalonia.Data.Core.ExpressionNodes.DataContextNodeBase : SourceNode {
    [NullableContextAttribute("2")]
public virtual object SelectSource(object source, object target, object anchor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Avalonia.Data.Core.ExpressionNodes.ExpressionNode : object {
    private WeakReference`1<object> _source;
    private object _value;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingExpression <Owner>k__BackingField;
    public int Index { get; private set; }
    public BindingExpression Owner { get; private set; }
    public object Source { get; }
    public object Value { get; }
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [CompilerGeneratedAttribute]
public BindingExpression get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(BindingExpression value);
    public object get_Source();
    public object get_Value();
    [NullableContextAttribute("1")]
public virtual void BuildString(StringBuilder builder);
    [NullableContextAttribute("1")]
public virtual void BuildString(StringBuilder builder, IReadOnlyList`1<ExpressionNode> nodes);
    [NullableContextAttribute("1")]
public void SetOwner(BindingExpression owner, int index);
    public void SetSource(object source, Exception dataValidationError);
    protected void ClearValue();
    [NullableContextAttribute("1")]
protected void SetDataValidationError(Exception error);
    [NullableContextAttribute("1")]
protected void SetError(string message);
    [NullableContextAttribute("1")]
protected void SetError(Exception e);
    protected void SetValue(object valueOrNotification);
    protected void SetValue(object value, Exception dataValidationError);
    protected bool ValidateNonNullSource(object source);
    protected abstract virtual void OnSourceChanged(object source, Exception dataValidationError);
    [NullableContextAttribute("1")]
protected virtual void Unsubscribe(object oldSource);
}
internal class Avalonia.Data.Core.ExpressionNodes.FuncTransformNode : ExpressionNode {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _transform;
    public FuncTransformNode(Func`2<object, object> transform);
    [NullableContextAttribute("1")]
public virtual void BuildString(StringBuilder builder);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Data.Core.ExpressionNodes.IPropertyAccessorNode {
    public string PropertyName { get; }
    [NullableAttribute("2")]
public IPropertyAccessor Accessor { get; }
    public abstract virtual string get_PropertyName();
    [NullableContextAttribute("2")]
public abstract virtual IPropertyAccessor get_Accessor();
    public abstract virtual void EnableDataValidation();
}
[NullableContextAttribute("2")]
internal interface Avalonia.Data.Core.ExpressionNodes.ISettableNode {
    public Type ValueType { get; }
    public abstract virtual Type get_ValueType();
    [NullableContextAttribute("1")]
public abstract virtual bool WriteValueToSource(object value, IReadOnlyList`1<ExpressionNode> nodes);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.LogicalAncestorElementNode : SourceNode {
    private Type _ancestorType;
    private int _ancestorLevel;
    private IDisposable _subscription;
    public LogicalAncestorElementNode(Type ancestorType, int ancestorLevel);
    [NullableContextAttribute("1")]
public virtual void BuildString(StringBuilder builder);
    public virtual object SelectSource(object source, object target, object anchor);
    [NullableContextAttribute("1")]
public virtual bool ShouldLogErrors(object target);
    protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    [NullableContextAttribute("1")]
protected virtual void Unsubscribe(object oldSource);
    private void TrackedControlChanged(ILogical control);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.LogicalNotNode : ExpressionNode {
    public Type ValueType { get; }
    public virtual void BuildString(StringBuilder builder);
    public virtual void BuildString(StringBuilder builder, IReadOnlyList`1<ExpressionNode> nodes);
    public sealed virtual Type get_ValueType();
    public sealed virtual bool WriteValueToSource(object value, IReadOnlyList`1<ExpressionNode> nodes);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    [NullableContextAttribute("2")]
private static bool TryConvert(object value, Boolean& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.MethodCommandNode : ExpressionNode {
    private string _methodName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _execute;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<object, object, bool> _canExecute;
    private ISet`1<string> _dependsOnProperties;
    [NullableAttribute("2")]
private Command _command;
    public MethodCommandNode(string methodName, Action`2<object, object> execute, Func`3<object, object, bool> canExecute, ISet`1<string> dependsOnProperties);
    public virtual void BuildString(StringBuilder builder);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object oldSource);
    public sealed virtual void OnEvent(object sender, WeakEvent ev, PropertyChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.NamedElementNode : SourceNode {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<INameScope> _nameScope;
    private string _name;
    [NullableAttribute("2")]
private IDisposable _subscription;
    public NamedElementNode(INameScope nameScope, string name);
    public virtual void BuildString(StringBuilder builder);
    public virtual bool ShouldLogErrors(object target);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object oldSource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.ParentDataContextNode : DataContextNodeBase {
    private static AvaloniaObject s_unset;
    [NullableAttribute("2")]
private AvaloniaObject _parent;
    private static ParentDataContextNode();
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object oldSource);
    [NullableContextAttribute("2")]
private void SetParent(AvaloniaObject parent);
    private void Unsubscribe();
    private void OnPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
    private void OnParentPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.PropertyAccessorNode : ExpressionNode {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<object> _onValueChanged;
    private IPropertyAccessorPlugin _plugin;
    [NullableAttribute("2")]
private IPropertyAccessor _accessor;
    private bool _enableDataValidation;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [NullableAttribute("2")]
public IPropertyAccessor Accessor { get; }
    public string PropertyName { get; }
    [NullableAttribute("2")]
public Type ValueType { get; }
    public PropertyAccessorNode(string propertyName, IPropertyAccessorPlugin plugin);
    [NullableContextAttribute("2")]
public sealed virtual IPropertyAccessor get_Accessor();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PropertyName();
    [NullableContextAttribute("2")]
public sealed virtual Type get_ValueType();
    public virtual void BuildString(StringBuilder builder);
    public sealed virtual void EnableDataValidation();
    public sealed virtual bool WriteValueToSource(object value, IReadOnlyList`1<ExpressionNode> nodes);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object oldSource);
    [NullableContextAttribute("2")]
private void OnValueChanged(object newValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("ExpressionNode might require unreferenced code.")]
internal class Avalonia.Data.Core.ExpressionNodes.Reflection.DynamicPluginPropertyAccessorNode : ExpressionNode {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<object> _onValueChanged;
    private IPropertyAccessor _accessor;
    private bool _enableDataValidation;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public IPropertyAccessor Accessor { get; }
    [NullableAttribute("1")]
public string PropertyName { get; }
    public Type ValueType { get; }
    [NullableContextAttribute("1")]
public DynamicPluginPropertyAccessorNode(string propertyName);
    public sealed virtual IPropertyAccessor get_Accessor();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_PropertyName();
    public sealed virtual Type get_ValueType();
    [NullableContextAttribute("1")]
public virtual void BuildString(StringBuilder builder);
    public sealed virtual void EnableDataValidation();
    [NullableContextAttribute("1")]
public sealed virtual bool WriteValueToSource(object value, IReadOnlyList`1<ExpressionNode> nodes);
    protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    [NullableContextAttribute("1")]
protected virtual void Unsubscribe(object oldSource);
    private void OnValueChanged(object newValue);
    private IPropertyAccessorPlugin GetPlugin(object source);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("ExpressionNode might require unreferenced code.")]
internal class Avalonia.Data.Core.ExpressionNodes.Reflection.DynamicPluginStreamNode : ExpressionNode {
    private IDisposable _subscription;
    [NullableContextAttribute("1")]
public virtual void BuildString(StringBuilder builder);
    protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    [NullableContextAttribute("1")]
protected virtual void Unsubscribe(object oldSource);
    private static IStreamPlugin GetPlugin(WeakReference`1<object> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("ExpressionNode might require unreferenced code.")]
internal class Avalonia.Data.Core.ExpressionNodes.Reflection.ExpressionTreeIndexerNode : CollectionNodeBase {
    private ParameterExpression _parameter;
    private IndexExpression _expression;
    private Delegate _setDelegate;
    private Delegate _getDelegate;
    private Delegate _firstArgumentDelegate;
    [NullableAttribute("2")]
public Type ValueType { get; }
    public ExpressionTreeIndexerNode(IndexExpression expression);
    [NullableContextAttribute("2")]
public sealed virtual Type get_ValueType();
    public virtual void BuildString(StringBuilder builder);
    public sealed virtual bool WriteValueToSource(object value, IReadOnlyList`1<ExpressionNode> nodes);
    protected virtual bool ShouldUpdate(object sender, PropertyChangedEventArgs e);
    protected virtual Nullable`1<int> TryGetFirstArgumentAsInt();
    [NullableContextAttribute("2")]
protected virtual void UpdateValue(object source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("BindingExpression and ReflectionBinding heavily use reflection. Consider using CompiledBindings instead.")]
internal class Avalonia.Data.Core.ExpressionNodes.Reflection.ReflectionIndexerNode : CollectionNodeBase {
    private static BindingFlags InstanceFlags;
    [NullableAttribute("2")]
private MethodInfo _getter;
    [NullableAttribute("2")]
private MethodInfo _setter;
    [NullableAttribute("2")]
private Object[] _indexes;
    [CompilerGeneratedAttribute]
private IList <Arguments>k__BackingField;
    public IList Arguments { get; }
    [NullableAttribute("2")]
public Type ValueType { get; }
    public ReflectionIndexerNode(IList arguments);
    [CompilerGeneratedAttribute]
public IList get_Arguments();
    [NullableContextAttribute("2")]
public sealed virtual Type get_ValueType();
    public virtual void BuildString(StringBuilder builder);
    public sealed virtual bool WriteValueToSource(object value, IReadOnlyList`1<ExpressionNode> nodes);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual bool ShouldUpdate(object sender, PropertyChangedEventArgs e);
    protected virtual Nullable`1<int> TryGetFirstArgumentAsInt();
    [NullableContextAttribute("2")]
protected virtual void UpdateValue(object source);
    private static Object[] ConvertIndexes(ParameterInfo[] indexParameters, IList arguments);
    [NullableContextAttribute("2")]
private static bool GetIndexer(Type type, MethodInfo& getter, MethodInfo& setter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.Reflection.ReflectionTypeCastNode : ExpressionNode {
    private Type _targetType;
    public ReflectionTypeCastNode(Type targetType);
    public virtual void BuildString(StringBuilder builder);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
}
internal abstract class Avalonia.Data.Core.ExpressionNodes.SourceNode : ExpressionNode {
    [NullableContextAttribute("2")]
public virtual object SelectSource(object source, object target, object anchor);
    [NullableContextAttribute("1")]
public virtual bool ShouldLogErrors(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.StreamNode : ExpressionNode {
    private IStreamPlugin _plugin;
    [NullableAttribute("2")]
private IDisposable _subscription;
    public StreamNode(IStreamPlugin plugin);
    public virtual void BuildString(StringBuilder builder);
    private sealed virtual override void System.IObserver<System.Object>.OnCompleted();
    private sealed virtual override void System.IObserver<System.Object>.OnError(Exception error);
    [NullableContextAttribute("2")]
private sealed virtual override void System.IObserver<System.Object>.OnNext(object value);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object oldSource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.TemplatedParentNode : SourceNode {
    public virtual void BuildString(StringBuilder builder);
    [NullableContextAttribute("2")]
public virtual object SelectSource(object source, object target, object anchor);
    [NullableContextAttribute("2")]
protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    protected virtual void Unsubscribe(object oldSource);
    private void OnPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.ExpressionNodes.VisualAncestorElementNode : SourceNode {
    private Type _ancestorType;
    private int _ancestorLevel;
    private IDisposable _subscription;
    public VisualAncestorElementNode(Type ancestorType, int ancestorLevel);
    [NullableContextAttribute("1")]
public virtual void BuildString(StringBuilder builder);
    public virtual object SelectSource(object source, object target, object anchor);
    [NullableContextAttribute("1")]
public virtual bool ShouldLogErrors(object target);
    protected virtual void OnSourceChanged(object source, Exception dataValidationError);
    [NullableContextAttribute("1")]
protected virtual void Unsubscribe(object oldSource);
    private void TrackedControlChanged(Visual control);
}
public class Avalonia.Data.Core.ExpressionParseException : Exception {
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Column { get; }
    [NullableContextAttribute("1")]
public ExpressionParseException(int column, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_Column();
}
internal interface Avalonia.Data.Core.IBinding2 {
    [NullableContextAttribute("1")]
public abstract virtual BindingExpressionBase Instance(AvaloniaObject target, AvaloniaProperty targetProperty, object anchor);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Data.Core.IBindingExpressionSink {
    [NullableContextAttribute("2")]
public abstract virtual void OnChanged(UntypedBindingExpressionBase instance, bool hasValueChanged, bool hasErrorChanged, object value, BindingError error);
    public abstract virtual void OnCompleted(UntypedBindingExpressionBase instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.IndexerBindingExpression : UntypedBindingExpressionBase {
    private AvaloniaObject _source;
    private AvaloniaProperty _sourceProperty;
    private AvaloniaObject _target;
    [NullableAttribute("2")]
private AvaloniaProperty _targetProperty;
    private BindingMode _mode;
    public string Description { get; }
    public IndexerBindingExpression(AvaloniaObject source, AvaloniaProperty sourceProperty, AvaloniaObject target, AvaloniaProperty targetProperty, BindingMode mode);
    public virtual string get_Description();
    [NullableContextAttribute("2")]
internal virtual bool WriteValueToSource(object value);
    protected virtual void StartCore();
    protected virtual void StopCore();
    private void OnSourcePropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
    private void OnTargetPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Data.Core.IPropertyInfo {
    public string Name { get; }
    public bool CanSet { get; }
    public bool CanGet { get; }
    public Type PropertyType { get; }
    public abstract virtual string get_Name();
    public abstract virtual object Get(object target);
    public abstract virtual void Set(object target, object value);
    public abstract virtual bool get_CanSet();
    public abstract virtual bool get_CanGet();
    public abstract virtual Type get_PropertyType();
}
public interface Avalonia.Data.Core.IPropertyPathElement {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.MultiBindingExpression : UntypedBindingExpressionBase {
    [NullableAttribute("1")]
private static object s_uninitialized;
    [NullableAttribute("1")]
private IBinding[] _bindings;
    private IMultiValueConverter _converter;
    private CultureInfo _converterCulture;
    private object _converterParameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private UntypedBindingExpressionBase[] _expressions;
    private object _fallbackValue;
    private object _targetNullValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _values;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyCollection`1<object> _valuesView;
    [NullableAttribute("1")]
public string Description { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal UntypedBindingExpressionBase[] Expressions { get; }
    internal IMultiValueConverter Converter { get; }
    internal CultureInfo ConverterCulture { get; }
    internal object ConverterParameter { get; }
    internal object FallbackValue { get; }
    internal object TargetNullValue { get; }
    public MultiBindingExpression(BindingPriority priority, IList`1<IBinding> bindings, IMultiValueConverter converter, CultureInfo converterCulture, object converterParameter, object fallbackValue, object targetNullValue);
    private static MultiBindingExpression();
    [NullableContextAttribute("1")]
public virtual string get_Description();
    internal UntypedBindingExpressionBase[] get_Expressions();
    internal IMultiValueConverter get_Converter();
    internal CultureInfo get_ConverterCulture();
    internal object get_ConverterParameter();
    internal object get_FallbackValue();
    internal object get_TargetNullValue();
    protected virtual void StartCore();
    protected virtual void StopCore();
    private sealed virtual override void Avalonia.Data.Core.IBindingExpressionSink.OnChanged(UntypedBindingExpressionBase instance, bool hasValueChanged, bool hasErrorChanged, object value, BindingError error);
    [NullableContextAttribute("1")]
private sealed virtual override void Avalonia.Data.Core.IBindingExpressionSink.OnCompleted(UntypedBindingExpressionBase instance);
    private void PublishValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("ExpressionNode might require unreferenced code.")]
internal class Avalonia.Data.Core.Parsers.BindingExpressionVisitor`1 : ExpressionVisitor {
    private static PropertyInfo AvaloniaObjectIndexer;
    private static MethodInfo CreateDelegateMethod;
    private static string IndexerGetterName;
    private static string MultiDimensionalArrayGetterMethodName;
    private bool _enableDataValidation;
    private LambdaExpression _rootExpression;
    private List`1<ExpressionNode> _nodes;
    [NullableAttribute("2")]
private Expression _head;
    public BindingExpressionVisitor`1(LambdaExpression expression, bool enableDataValidation);
    private static BindingExpressionVisitor`1();
    public static List`1<ExpressionNode> BuildNodes(Expression`1<Func`2<TIn, TOut>> expression, bool enableDataValidation);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitIndex(IndexExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitConditional(ConditionalExpression node);
    protected virtual Expression VisitDynamic(DynamicExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected virtual Expression VisitGoto(GotoExpression node);
    protected virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual Expression VisitLabel(LabelExpression node);
    protected virtual Expression VisitListInit(ListInitExpression node);
    protected virtual Expression VisitLoop(LoopExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual Expression VisitTry(TryExpression node);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    private Expression Add(Expression instance, Expression expression, ExpressionNode node);
    private static T GetValue(Expression expr);
    private static PropertyInfo TryGetPropertyFromMethod(MethodInfo method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.Plugins.AvaloniaPropertyAccessorPlugin : object {
    public sealed virtual bool Match(object obj, string propertyName);
    public sealed virtual IPropertyAccessor Start(WeakReference`1<object> reference, string propertyName);
    private static AvaloniaProperty LookupProperty(AvaloniaObject o, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("PropertyAccessors might require unreferenced code.")]
public static class Avalonia.Data.Core.Plugins.BindingPlugins : object {
    internal static List`1<IPropertyAccessorPlugin> s_propertyAccessors;
    internal static List`1<IDataValidationPlugin> s_dataValidators;
    internal static List`1<IStreamPlugin> s_streamHandlers;
    public static IList`1<IPropertyAccessorPlugin> PropertyAccessors { get; }
    public static IList`1<IDataValidationPlugin> DataValidators { get; }
    public static IList`1<IStreamPlugin> StreamHandlers { get; }
    private static BindingPlugins();
    public static IList`1<IPropertyAccessorPlugin> get_PropertyAccessors();
    public static IList`1<IDataValidationPlugin> get_DataValidators();
    public static IList`1<IStreamPlugin> get_StreamHandlers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
public class Avalonia.Data.Core.Plugins.DataAnnotationsValidationPlugin : object {
    public sealed virtual bool Match(WeakReference`1<object> reference, string memberName);
    public sealed virtual IPropertyAccessor Start(WeakReference`1<object> reference, string name, IPropertyAccessor inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Avalonia.Data.Core.Plugins.DataValidationBase : PropertyAccessorBase {
    [NullableAttribute("1")]
private IPropertyAccessor _inner;
    public Type PropertyType { get; }
    public object Value { get; }
    [NullableContextAttribute("1")]
protected DataValidationBase(IPropertyAccessor inner);
    public virtual Type get_PropertyType();
    public virtual object get_Value();
    public virtual bool SetValue(object value, BindingPriority priority);
    private sealed virtual override void System.IObserver<System.Object>.OnCompleted();
    [NullableContextAttribute("1")]
private sealed virtual override void System.IObserver<System.Object>.OnError(Exception error);
    private sealed virtual override void System.IObserver<System.Object>.OnNext(object value);
    protected virtual void SubscribeCore();
    protected virtual void UnsubscribeCore();
    protected virtual void InnerValueChanged(object value);
}
public class Avalonia.Data.Core.Plugins.ExceptionValidationPlugin : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Match(WeakReference`1<object> reference, string memberName);
    [NullableContextAttribute("1")]
public sealed virtual IPropertyAccessor Start(WeakReference`1<object> reference, string name, IPropertyAccessor inner);
}
[NullableContextAttribute("1")]
public interface Avalonia.Data.Core.Plugins.IDataValidationPlugin {
    public abstract virtual bool Match(WeakReference`1<object> reference, string memberName);
    public abstract virtual IPropertyAccessor Start(WeakReference`1<object> reference, string propertyName, IPropertyAccessor inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.Plugins.IndeiValidationPlugin : object {
    private static WeakEvent`2<INotifyDataErrorInfo, DataErrorsChangedEventArgs> ErrorsChangedWeakEvent;
    private static IndeiValidationPlugin();
    public sealed virtual bool Match(WeakReference`1<object> reference, string memberName);
    public sealed virtual IPropertyAccessor Start(WeakReference`1<object> reference, string name, IPropertyAccessor accessor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("PropertyAccessors might require unreferenced code.")]
internal class Avalonia.Data.Core.Plugins.InpcPropertyAccessorPlugin : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<Type, string>, PropertyInfo> _propertyLookup;
    private static BindingFlags PropertyBindingFlags;
    public sealed virtual bool Match(object obj, string propertyName);
    public sealed virtual IPropertyAccessor Start(WeakReference`1<object> reference, string propertyName);
    private PropertyInfo GetFirstPropertyWithName(object instance, string propertyName);
    private PropertyInfo TryFindAndCacheProperty(Type type, string propertyName);
}
[NullableContextAttribute("2")]
public interface Avalonia.Data.Core.Plugins.IPropertyAccessor {
    public Type PropertyType { get; }
    public object Value { get; }
    public abstract virtual Type get_PropertyType();
    public abstract virtual object get_Value();
    public abstract virtual bool SetValue(object value, BindingPriority priority);
    public abstract virtual void Subscribe(Action`1<object> listener);
    public abstract virtual void Unsubscribe();
}
[NullableContextAttribute("1")]
public interface Avalonia.Data.Core.Plugins.IPropertyAccessorPlugin {
    public abstract virtual bool Match(object obj, string propertyName);
    public abstract virtual IPropertyAccessor Start(WeakReference`1<object> reference, string propertyName);
}
public interface Avalonia.Data.Core.Plugins.IStreamPlugin {
    public abstract virtual bool Match(WeakReference`1<object> reference);
    public abstract virtual IObservable`1<object> Start(WeakReference`1<object> reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.Plugins.MethodAccessorPlugin : object {
    private MethodInfo _method;
    private Type _delegateType;
    public MethodAccessorPlugin(MethodInfo method, Type delegateType);
    public sealed virtual bool Match(object obj, string propertyName);
    public sealed virtual IPropertyAccessor Start(WeakReference`1<object> reference, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL3050")]
[RequiresUnreferencedCodeAttribute("StreamPlugin might require unreferenced code.")]
internal class Avalonia.Data.Core.Plugins.ObservableStreamPlugin : object {
    [NullableAttribute("2")]
private static MethodInfo s_observableGeneric;
    [NullableAttribute("2")]
private static MethodInfo s_observableSelect;
    public virtual bool Match(WeakReference`1<object> reference);
    public virtual IObservable`1<object> Start(WeakReference`1<object> reference);
    [RequiresUnreferencedCodeAttribute("StreamPlugin might require unreferenced code.")]
private static MethodInfo GetBoxObservable(Type source);
    [RequiresUnreferencedCodeAttribute("StreamPlugin might require unreferenced code.")]
private static MethodInfo GetBoxObservable();
    private static IObservable`1<object> BoxObservable(IObservable`1<T> source);
}
internal class Avalonia.Data.Core.Plugins.ObservableStreamPlugin`1 : object {
    public sealed virtual bool Match(WeakReference`1<object> reference);
    public sealed virtual IObservable`1<object> Start(WeakReference`1<object> reference);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Avalonia.Data.Core.Plugins.PropertyAccessorBase : object {
    private Action`1<object> _listener;
    public Type PropertyType { get; }
    public object Value { get; }
    public abstract virtual Type get_PropertyType();
    public abstract virtual object get_Value();
    public sealed virtual void Dispose();
    public abstract virtual bool SetValue(object value, BindingPriority priority);
    public sealed virtual void Subscribe(Action`1<object> listener);
    public sealed virtual void Unsubscribe();
    protected void PublishValue(object value);
    protected abstract virtual void SubscribeCore();
    protected abstract virtual void UnsubscribeCore();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.Plugins.PropertyError : object {
    [NullableAttribute("1")]
private BindingNotification _error;
    public Type PropertyType { get; }
    public object Value { get; }
    [NullableContextAttribute("1")]
public PropertyError(BindingNotification error);
    public sealed virtual Type get_PropertyType();
    public sealed virtual object get_Value();
    public sealed virtual void Dispose();
    public sealed virtual bool SetValue(object value, BindingPriority priority);
    [NullableContextAttribute("1")]
public sealed virtual void Subscribe(Action`1<object> listener);
    public sealed virtual void Unsubscribe();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.Plugins.PropertyInfoAccessorPlugin : object {
    private IPropertyInfo _propertyInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<WeakReference`1<object>, IPropertyInfo, IPropertyAccessor> _accessorFactory;
    public PropertyInfoAccessorPlugin(IPropertyInfo propertyInfo, Func`3<WeakReference`1<object>, IPropertyInfo, IPropertyAccessor> accessorFactory);
    public sealed virtual bool Match(object obj, string propertyName);
    public sealed virtual IPropertyAccessor Start(WeakReference`1<object> reference, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresUnreferencedCodeAttribute("PropertyAccessors might require unreferenced code.")]
internal class Avalonia.Data.Core.Plugins.ReflectionMethodAccessorPlugin : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<Type, string>, MethodInfo> _methodLookup;
    public sealed virtual bool Match(object obj, string methodName);
    public sealed virtual IPropertyAccessor Start(WeakReference`1<object> reference, string methodName);
    private MethodInfo GetFirstMethodWithName(Type type, string methodName);
    private MethodInfo TryFindAndCacheMethod(Type type, string methodName);
}
[UnconditionalSuppressMessageAttribute("Trimming", "IL3050")]
[RequiresUnreferencedCodeAttribute("StreamPlugin might require unreferenced code.")]
internal class Avalonia.Data.Core.Plugins.TaskStreamPlugin : object {
    public virtual bool Match(WeakReference`1<object> reference);
    public virtual IObservable`1<object> Start(WeakReference`1<object> reference);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("StreamPlugin might require unreferenced code.")]
private static IObservable`1<object> HandleCompleted(Task task);
}
internal class Avalonia.Data.Core.Plugins.TaskStreamPlugin`1 : object {
    public sealed virtual bool Match(WeakReference`1<object> reference);
    public sealed virtual IObservable`1<object> Start(WeakReference`1<object> reference);
    [NullableContextAttribute("1")]
private static IObservable`1<object> HandleCompleted(Task`1<T> task);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.PropertyPath : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IPropertyPathElement> <Elements>k__BackingField;
    public IReadOnlyList`1<IPropertyPathElement> Elements { get; }
    public PropertyPath(IEnumerable`1<IPropertyPathElement> elements);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IPropertyPathElement> get_Elements();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.PropertyPathBuilder : object {
    private List`1<IPropertyPathElement> _elements;
    public PropertyPathBuilder Property(IPropertyInfo property);
    public PropertyPathBuilder ChildTraversal();
    public PropertyPathBuilder EnsureType(Type type);
    public PropertyPathBuilder Cast(Type type);
    public PropertyPath Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.PropertyPropertyPathElement : object {
    [CompilerGeneratedAttribute]
private IPropertyInfo <Property>k__BackingField;
    public IPropertyInfo Property { get; }
    public PropertyPropertyPathElement(IPropertyInfo property);
    [CompilerGeneratedAttribute]
public IPropertyInfo get_Property();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.Core.ReflectionClrPropertyInfo : ClrPropertyInfo {
    public ReflectionClrPropertyInfo(PropertyInfo info);
    private static Action`2<object, object> CreateSetter(PropertyInfo info);
    private static Func`2<object, object> CreateGetter(PropertyInfo info);
}
internal abstract class Avalonia.Data.Core.TargetTypeConverter : object {
    [NullableAttribute("2")]
private static TargetTypeConverter s_default;
    [NullableAttribute("2")]
private static TargetTypeConverter s_reflection;
    [NullableContextAttribute("1")]
public static TargetTypeConverter GetDefaultConverter();
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
public static TargetTypeConverter GetReflectionConverter();
    [NullableContextAttribute("1")]
public abstract virtual bool TryConvert(object value, Type type, CultureInfo culture, Object& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public abstract class Avalonia.Data.Core.UntypedBindingExpressionBase : BindingExpressionBase {
    [NullableAttribute("1")]
protected static object UnchangedValue;
    private bool _isDataValidationEnabled;
    private object _defaultValue;
    private BindingError _error;
    private ImmediateValueFrame _frame;
    private bool _isDefaultValueInitialized;
    private bool _isRunning;
    private bool _produceValue;
    private IBindingExpressionSink _sink;
    private WeakReference`1<AvaloniaObject> _target;
    private object _value;
    [CompilerGeneratedAttribute]
private BindingPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private AvaloniaProperty <TargetProperty>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [NullableAttribute("1")]
public string Description { get; }
    public BindingErrorType ErrorType { get; }
    public bool IsDataValidationEnabled { get; }
    public bool IsRunning { get; }
    public BindingPriority Priority { get; private set; }
    public AvaloniaProperty TargetProperty { get; private set; }
    [NullableAttribute("1")]
public Type TargetType { get; private set; }
    [NullableAttribute("1")]
private AvaloniaProperty Avalonia.PropertyStore.IValueEntry.Property { get; }
    public UntypedBindingExpressionBase(BindingPriority defaultPriority, AvaloniaProperty targetProperty, bool isDataValidationEnabled);
    private static UntypedBindingExpressionBase();
    [NullableContextAttribute("1")]
public abstract virtual string get_Description();
    public BindingErrorType get_ErrorType();
    public bool get_IsDataValidationEnabled();
    public bool get_IsRunning();
    [CompilerGeneratedAttribute]
public BindingPriority get_Priority();
    [CompilerGeneratedAttribute]
private void set_Priority(BindingPriority value);
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_TargetProperty();
    [CompilerGeneratedAttribute]
private void set_TargetProperty(AvaloniaProperty value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Type get_TargetType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [NullableContextAttribute("1")]
private sealed virtual override AvaloniaProperty Avalonia.PropertyStore.IValueEntry.get_Property();
    public virtual void Dispose();
    public object GetValue();
    public object GetValueOrDefault();
    public void Start();
    private sealed virtual override bool Avalonia.PropertyStore.IValueEntry.GetDataValidationState(BindingValueType& state, Exception& error);
    private sealed virtual override bool Avalonia.PropertyStore.IValueEntry.HasValue();
    private sealed virtual override object Avalonia.PropertyStore.IValueEntry.GetValue();
    private sealed virtual override void Avalonia.PropertyStore.IValueEntry.Unsubscribe();
    [NullableContextAttribute("1")]
internal virtual void Attach(ValueStore valueStore, ImmediateValueFrame frame, AvaloniaObject target, AvaloniaProperty targetProperty, BindingPriority priority);
    [NullableContextAttribute("1")]
internal void AttachAndStart(IBindingExpressionSink subscriber, AvaloniaObject target, AvaloniaProperty targetProperty, BindingPriority priority);
    internal IAvaloniaSubject`1<object> ToObservable(AvaloniaObject target);
    internal virtual bool WriteValueToSource(object value);
    [NullableContextAttribute("1")]
private void AttachCore(IBindingExpressionSink sink, ImmediateValueFrame frame, AvaloniaObject target, AvaloniaProperty targetProperty, BindingPriority priority);
    private protected object Convert(IValueConverter converter, CultureInfo converterCulture, object converterParameter, object value, Type targetType, BindingError& error);
    protected object ConvertBack(IValueConverter converter, CultureInfo converterCulture, object converterParameter, object value, Type targetType);
    [NullableContextAttribute("1")]
protected void Log(string error, LogEventLevel level);
    [NullableContextAttribute("1")]
protected void Log(AvaloniaObject target, string error, LogEventLevel level);
    private protected void PublishValue(object value, BindingError error);
    protected virtual bool ShouldLogError(AvaloniaObject& target);
    protected void Start(bool produceValue);
    protected abstract virtual void StartCore();
    protected void Stop();
    protected abstract virtual void StopCore();
    protected bool TryGetTarget(AvaloniaObject& target);
    private object GetCachedDefaultValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.Core.UntypedObservableBindingExpression : UntypedBindingExpressionBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IObservable`1<object> _observable;
    [NullableAttribute("2")]
private IDisposable _subscription;
    public string Description { get; }
    public UntypedObservableBindingExpression(IObservable`1<object> observable, BindingPriority priority);
    public virtual string get_Description();
    protected virtual void StartCore();
    protected virtual void StopCore();
    private sealed virtual override void System.IObserver<System.Object>.OnCompleted();
    private sealed virtual override void System.IObserver<System.Object>.OnError(Exception error);
    [NullableContextAttribute("2")]
private sealed virtual override void System.IObserver<System.Object>.OnNext(object value);
}
[PrivateApiAttribute]
public class Avalonia.Data.CultureInfoIetfLanguageTagConverter : TypeConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    [NullableContextAttribute("2")]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.DataValidationException : Exception {
    [CompilerGeneratedAttribute]
private object <ErrorData>k__BackingField;
    public object ErrorData { get; }
    public DataValidationException(object errorData);
    [CompilerGeneratedAttribute]
public object get_ErrorData();
}
public class Avalonia.Data.DoNothingType : object {
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Data.IBinding {
    [ObsoleteAttribute("This API may be removed in Avalonia 12. If you depend on this API, please open an issue with details of your use-case.")]
public abstract virtual InstancedBinding Initiate(AvaloniaObject target, AvaloniaProperty targetProperty, object anchor, bool enableDataValidation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Data.IndexerBinding : object {
    [CompilerGeneratedAttribute]
private AvaloniaObject <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingMode <Mode>k__BackingField;
    private AvaloniaObject Source { get; }
    public AvaloniaProperty Property { get; }
    private BindingMode Mode { get; }
    public IndexerBinding(AvaloniaObject source, AvaloniaProperty property, BindingMode mode);
    [CompilerGeneratedAttribute]
private AvaloniaObject get_Source();
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    [CompilerGeneratedAttribute]
private BindingMode get_Mode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This API may be removed in Avalonia 12. If you depend on this API, please open an issue with details of your use-case.")]
public sealed virtual InstancedBinding Initiate(AvaloniaObject target, AvaloniaProperty targetProperty, object anchor, bool enableDataValidation);
    private sealed virtual override BindingExpressionBase Avalonia.Data.Core.IBinding2.Instance(AvaloniaObject target, AvaloniaProperty targetProperty, object anchor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.IndexerDescriptor : object {
    [CompilerGeneratedAttribute]
private BindingMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private AvaloniaObject <Source>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IObservable`1<object> <SourceObservable>k__BackingField;
    public BindingMode Mode { get; public set; }
    public BindingPriority Priority { get; public set; }
    public AvaloniaProperty Property { get; public set; }
    public AvaloniaObject Source { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IObservable`1<object> SourceObservable { get; public set; }
    [NullableAttribute("1")]
public string Description { get; }
    [CompilerGeneratedAttribute]
public BindingMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(BindingMode value);
    [CompilerGeneratedAttribute]
public BindingPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(BindingPriority value);
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(AvaloniaProperty value);
    [CompilerGeneratedAttribute]
public AvaloniaObject get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(AvaloniaObject value);
    [CompilerGeneratedAttribute]
public IObservable`1<object> get_SourceObservable();
    [CompilerGeneratedAttribute]
public void set_SourceObservable(IObservable`1<object> value);
    [NullableContextAttribute("1")]
public sealed virtual string get_Description();
    [NullableContextAttribute("1")]
public static IndexerDescriptor op_LogicalNot(IndexerDescriptor binding);
    [NullableContextAttribute("1")]
public static IndexerDescriptor op_OnesComplement(IndexerDescriptor binding);
    [NullableContextAttribute("1")]
public IndexerDescriptor WithMode(BindingMode mode);
    [NullableContextAttribute("1")]
public IndexerDescriptor WithPriority(BindingPriority priority);
    [NullableContextAttribute("1")]
public sealed virtual IDisposable Subscribe(IObserver`1<object> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Data.InstancedBinding : object {
    [NullableAttribute("2")]
private AvaloniaObject _target;
    [NullableAttribute("2")]
private UntypedBindingExpressionBase _expression;
    [NullableAttribute("2")]
private IObservable`1<object> _observable;
    [CompilerGeneratedAttribute]
private BindingMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingPriority <Priority>k__BackingField;
    public BindingMode Mode { get; }
    public BindingPriority Priority { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IObservable`1<object> Source { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ObsoleteAttribute("Use Source property")]
[EditorBrowsableAttribute("1")]
public IObservable`1<object> Observable { get; }
    [NullableAttribute("2")]
internal UntypedBindingExpressionBase Expression { get; }
    internal InstancedBinding(IObservable`1<object> source, BindingMode mode, BindingPriority priority);
    internal InstancedBinding(UntypedBindingExpressionBase source, BindingMode mode, BindingPriority priority);
    internal InstancedBinding(AvaloniaObject target, UntypedBindingExpressionBase source, BindingMode mode, BindingPriority priority);
    [CompilerGeneratedAttribute]
public BindingMode get_Mode();
    [CompilerGeneratedAttribute]
public BindingPriority get_Priority();
    public IObservable`1<object> get_Source();
    public IObservable`1<object> get_Observable();
    [NullableContextAttribute("2")]
internal UntypedBindingExpressionBase get_Expression();
    public static InstancedBinding OneTime(object value, BindingPriority priority);
    public static InstancedBinding OneTime(IObservable`1<object> observable, BindingPriority priority);
    public static InstancedBinding OneWay(IObservable`1<object> observable, BindingPriority priority);
    public static InstancedBinding OneWayToSource(IObserver`1<object> observer, BindingPriority priority);
    public static InstancedBinding TwoWay(IObservable`1<object> observable, IObserver`1<object> observer, BindingPriority priority);
    public InstancedBinding WithPriority(BindingPriority priority);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Avalonia.Data.Optional`1 : ValueType {
    private T _value;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public bool HasValue { get; }
    public T Value { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Optional`1<T> Empty { get; }
    public Optional`1(T value);
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public T get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Optional`1<T> other);
    public virtual int GetHashCode();
    public Optional`1<object> ToObject();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
    [NullableContextAttribute("2")]
public TResult GetValueOrDefault();
    [NullableContextAttribute("2")]
public TResult GetValueOrDefault(TResult defaultValue);
    public static Optional`1<T> op_Implicit(T value);
    public static bool op_Inequality(Optional`1<T> x, Optional`1<T> y);
    public static bool op_Equality(Optional`1<T> x, Optional`1<T> y);
    public static Optional`1<T> get_Empty();
}
[ExtensionAttribute]
public static class Avalonia.Data.OptionalExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Optional`1<T> Cast(Optional`1<object> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Data.TemplateBinding : UntypedBindingExpressionBase {
    private bool _isSetterValue;
    private bool _hasPublishedValue;
    [CompilerGeneratedAttribute]
private IValueConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <ConverterCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ConverterParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    private IAvaloniaSubject`1<object> _observableAdapter;
    public IValueConverter Converter { get; public set; }
    [TypeConverterAttribute("Avalonia.Data.CultureInfoIetfLanguageTagConverter")]
public CultureInfo ConverterCulture { get; public set; }
    public object ConverterParameter { get; public set; }
    public BindingMode Mode { get; public set; }
    [InheritDataTypeFromAttribute("2")]
public AvaloniaProperty Property { get; public set; }
    [NullableAttribute("1")]
public string Description { get; }
    [NullableContextAttribute("1")]
public TemplateBinding(AvaloniaProperty property);
    [CompilerGeneratedAttribute]
public IValueConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(IValueConverter value);
    [CompilerGeneratedAttribute]
public CultureInfo get_ConverterCulture();
    [CompilerGeneratedAttribute]
public void set_ConverterCulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public object get_ConverterParameter();
    [CompilerGeneratedAttribute]
public void set_ConverterParameter(object value);
    public BindingMode get_Mode();
    public void set_Mode(BindingMode value);
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(AvaloniaProperty value);
    [NullableContextAttribute("1")]
public virtual string get_Description();
    [NullableContextAttribute("1")]
public IBinding ProvideValue();
    public sealed virtual InstancedBinding Initiate(AvaloniaObject target, AvaloniaProperty targetProperty, object anchor, bool enableDataValidation);
    [NullableContextAttribute("1")]
private sealed virtual override BindingExpressionBase Avalonia.Data.Core.IBinding2.Instance(AvaloniaObject target, AvaloniaProperty property, object anchor);
    internal virtual bool WriteValueToSource(object value);
    [NullableContextAttribute("1")]
private sealed virtual override void Avalonia.Styling.ISetterValue.Initialize(SetterBase setter);
    protected virtual void StartCore();
    protected virtual void StopCore();
    private object ConvertToTargetType(object value);
    [NullableContextAttribute("1")]
private TemplateBinding InstanceCore();
    private void PublishValue();
    private void OnTemplatedParentChanged();
    [NullableContextAttribute("1")]
private void OnTemplatedParentPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
    [NullableContextAttribute("1")]
private void OnTargetPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
    private bool TryGetTemplatedParent(AvaloniaObject& result);
    [NullableContextAttribute("1")]
public sealed virtual IDisposable Subscribe(IObserver`1<object> observer);
    private sealed virtual override void System.IObserver<System.Object>.OnCompleted();
    [NullableContextAttribute("1")]
private sealed virtual override void System.IObserver<System.Object>.OnError(Exception error);
    private sealed virtual override void System.IObserver<System.Object>.OnNext(object value);
}
public enum Avalonia.Data.UpdateSourceTrigger : Enum {
    public int value__;
    public static UpdateSourceTrigger Default;
    public static UpdateSourceTrigger PropertyChanged;
    public static UpdateSourceTrigger LostFocus;
    public static UpdateSourceTrigger Explicit;
}
internal static class Avalonia.DebugDisplayHelper : object {
    [NullableContextAttribute("1")]
public static void AppendOptionalValue(StringBuilder builder, string name, object value, bool includeContent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
[UnstableAttribute("Use StyledElementExtensions.GetValueStoreDiagnostic() instead")]
public class Avalonia.Diagnostics.AppliedStyle : object {
    private StyleInstance _instance;
    public bool HasActivator { get; }
    public bool IsActive { get; }
    public StyleBase Style { get; }
    internal AppliedStyle(StyleInstance instance);
    public bool get_HasActivator();
    public bool get_IsActive();
    public StyleBase get_Style();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Diagnostics.AvaloniaObjectExtensions : object {
    [ExtensionAttribute]
public static AvaloniaPropertyValue GetDiagnostic(AvaloniaObject o, AvaloniaProperty property);
    [ExtensionAttribute]
public static ValueStoreDiagnostic GetValueStoreDiagnostic(AvaloniaObject avaloniaObject);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Diagnostics.AvaloniaPropertyValue : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Diagnostic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOverriddenCurrentValue>k__BackingField;
    [NullableAttribute("1")]
public AvaloniaProperty Property { get; }
    public object Value { get; }
    public BindingPriority Priority { get; }
    public string Diagnostic { get; }
    public bool IsOverriddenCurrentValue { get; }
    internal AvaloniaPropertyValue(AvaloniaProperty property, object value, BindingPriority priority, string diagnostic, bool isOverriddenCurrentValue);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public BindingPriority get_Priority();
    [CompilerGeneratedAttribute]
public string get_Diagnostic();
    [CompilerGeneratedAttribute]
public bool get_IsOverriddenCurrentValue();
}
internal interface Avalonia.Diagnostics.IAvaloniaObjectDebug {
    public abstract virtual Delegate[] GetPropertyChangedSubscribers();
}
internal interface Avalonia.Diagnostics.INotifyCollectionChangedDebug {
    public abstract virtual Delegate[] GetCollectionChangedSubscribers();
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
[NotClientImplementableAttribute]
public interface Avalonia.Diagnostics.IValueFrameDiagnostic {
    [NullableAttribute("2")]
public object Source { get; }
    public FrameType Type { get; }
    public bool IsActive { get; }
    public BindingPriority Priority { get; }
    public IEnumerable`1<ValueEntryDiagnostic> Values { get; }
    [NullableContextAttribute("2")]
public abstract virtual object get_Source();
    public abstract virtual FrameType get_Type();
    public abstract virtual bool get_IsActive();
    public abstract virtual BindingPriority get_Priority();
    public abstract virtual IEnumerable`1<ValueEntryDiagnostic> get_Values();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Diagnostics.LocalValueFrameDiagnostic : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ValueEntryDiagnostic> <Values>k__BackingField;
    [NullableAttribute("2")]
public object Source { get; }
    public FrameType Type { get; }
    public bool IsActive { get; }
    public BindingPriority Priority { get; }
    public IEnumerable`1<ValueEntryDiagnostic> Values { get; }
    public LocalValueFrameDiagnostic(IEnumerable`1<ValueEntryDiagnostic> values);
    [NullableContextAttribute("2")]
public sealed virtual object get_Source();
    public sealed virtual FrameType get_Type();
    public sealed virtual bool get_IsActive();
    public sealed virtual BindingPriority get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ValueEntryDiagnostic> get_Values();
}
internal static class Avalonia.Diagnostics.ObsoletionMessages : object {
    [NullableAttribute("1")]
public static string MayBeRemovedInAvalonia12;
}
[ExtensionAttribute]
[PrivateApiAttribute]
public static class Avalonia.Diagnostics.StyledElementExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[ObsoleteAttribute("Use AvaloniaObjectExtensions.GetValueStoreDiagnostic instead", "True")]
public static StyleDiagnostics GetStyleDiagnostics(StyledElement styledElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
[UnstableAttribute("Use StyledElementExtensions.GetValueStoreDiagnostic() instead")]
public class Avalonia.Diagnostics.StyleDiagnostics : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AppliedStyle> <AppliedStyles>k__BackingField;
    public IReadOnlyList`1<AppliedStyle> AppliedStyles { get; }
    public StyleDiagnostics(IReadOnlyList`1<AppliedStyle> appliedStyles);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AppliedStyle> get_AppliedStyles();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Diagnostics.StyleValueFrameDiagnostic : object {
    private StyleInstance _styleInstance;
    [NullableAttribute("2")]
public object Source { get; }
    public FrameType Type { get; }
    public bool IsActive { get; }
    public BindingPriority Priority { get; }
    public IEnumerable`1<ValueEntryDiagnostic> Values { get; }
    internal StyleValueFrameDiagnostic(StyleInstance styleInstance);
    [NullableContextAttribute("2")]
public sealed virtual object get_Source();
    public sealed virtual FrameType get_Type();
    public sealed virtual bool get_IsActive();
    public sealed virtual BindingPriority get_Priority();
    [IteratorStateMachineAttribute("Avalonia.Diagnostics.StyleValueFrameDiagnostic/<get_Values>d__11")]
public sealed virtual IEnumerable`1<ValueEntryDiagnostic> get_Values();
    [UnstableAttribute("Compatibility with 11.x")]
public AppliedStyle AsAppliedStyle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Diagnostics.ValueEntryDiagnostic : object {
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public AvaloniaProperty Property { get; public set; }
    [NullableAttribute("2")]
public object Value { get; public set; }
    public ValueEntryDiagnostic(AvaloniaProperty Property, object Value);
    [CompilerGeneratedAttribute]
protected ValueEntryDiagnostic(ValueEntryDiagnostic original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Property(AvaloniaProperty value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(object value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ValueEntryDiagnostic left, ValueEntryDiagnostic right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ValueEntryDiagnostic left, ValueEntryDiagnostic right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ValueEntryDiagnostic other);
    [CompilerGeneratedAttribute]
public virtual ValueEntryDiagnostic <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(AvaloniaProperty& Property, Object& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Diagnostics.ValueFrameDiagnostic : object {
    private ValueFrame _valueFrame;
    [NullableAttribute("2")]
public object Source { get; }
    public FrameType Type { get; }
    public bool IsActive { get; }
    public BindingPriority Priority { get; }
    public IEnumerable`1<ValueEntryDiagnostic> Values { get; }
    internal ValueFrameDiagnostic(ValueFrame valueFrame);
    [NullableContextAttribute("2")]
public sealed virtual object get_Source();
    public sealed virtual FrameType get_Type();
    public sealed virtual bool get_IsActive();
    public sealed virtual BindingPriority get_Priority();
    [IteratorStateMachineAttribute("Avalonia.Diagnostics.ValueFrameDiagnostic/<get_Values>d__11")]
public sealed virtual IEnumerable`1<ValueEntryDiagnostic> get_Values();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Diagnostics.ValueStoreDiagnostic : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IValueFrameDiagnostic> <AppliedFrames>k__BackingField;
    public IReadOnlyList`1<IValueFrameDiagnostic> AppliedFrames { get; }
    internal ValueStoreDiagnostic(IReadOnlyList`1<IValueFrameDiagnostic> appliedFrames);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IValueFrameDiagnostic> get_AppliedFrames();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.DirectProperty`2 : DirectPropertyBase`1<TValue> {
    [CompilerGeneratedAttribute]
private Func`2<TOwner, TValue> <Getter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<TOwner, TValue> <Setter>k__BackingField;
    public Func`2<TOwner, TValue> Getter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<TOwner, TValue> Setter { get; }
    internal DirectProperty`2(string name, Func`2<TOwner, TValue> getter, Action`2<TOwner, TValue> setter, DirectPropertyMetadata`1<TValue> metadata);
    private DirectProperty`2(DirectPropertyBase`1<TValue> source, Func`2<TOwner, TValue> getter, Action`2<TOwner, TValue> setter, DirectPropertyMetadata`1<TValue> metadata);
    [CompilerGeneratedAttribute]
public Func`2<TOwner, TValue> get_Getter();
    [CompilerGeneratedAttribute]
public Action`2<TOwner, TValue> get_Setter();
    public DirectProperty`2<TNewOwner, TValue> AddOwner(Func`2<TNewOwner, TValue> getter, Action`2<TNewOwner, TValue> setter, TValue unsetValue, BindingMode defaultBindingMode, bool enableDataValidation);
    internal virtual TValue InvokeGetter(AvaloniaObject instance);
    internal virtual void InvokeSetter(AvaloniaObject instance, BindingValue`1<TValue> value);
    private sealed virtual override object Avalonia.IDirectPropertyAccessor.GetValue(AvaloniaObject instance);
    private sealed virtual override void Avalonia.IDirectPropertyAccessor.SetValue(AvaloniaObject instance, object value);
    private sealed virtual override object Avalonia.IDirectPropertyAccessor.GetUnsetValue(Type type);
    private sealed virtual override object Avalonia.IDirectPropertyAccessor.GetUnsetValue(AvaloniaObject owner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Avalonia.DirectPropertyBase`1 : AvaloniaProperty`1<TValue> {
    [CompilerGeneratedAttribute]
private Type <Owner>k__BackingField;
    public Type Owner { get; }
    private protected DirectPropertyBase`1(string name, Type ownerType, AvaloniaPropertyMetadata metadata);
    private protected DirectPropertyBase`1(DirectPropertyBase`1<TValue> source, Type ownerType, AvaloniaPropertyMetadata metadata);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Owner();
    internal abstract virtual TValue InvokeGetter(AvaloniaObject instance);
    internal abstract virtual void InvokeSetter(AvaloniaObject instance, BindingValue`1<TValue> value);
    public TValue GetUnsetValue(Type type);
    public TValue GetUnsetValue(AvaloniaObject owner);
    public DirectPropertyMetadata`1<TValue> GetMetadata(Type type);
    public DirectPropertyMetadata`1<TValue> GetMetadata(AvaloniaObject owner);
    private static DirectPropertyMetadata`1<TValue> CastMetadata(AvaloniaPropertyMetadata metadata);
    public void OverrideMetadata(DirectPropertyMetadata`1<TValue> metadata);
    public void OverrideMetadata(Type type, DirectPropertyMetadata`1<TValue> metadata);
    internal virtual EffectiveValue CreateEffectiveValue(AvaloniaObject o);
    internal virtual void RouteClearValue(AvaloniaObject o);
    internal virtual void RouteCoerceDefaultValue(AvaloniaObject o);
    internal virtual object RouteGetValue(AvaloniaObject o);
    internal virtual object RouteGetBaseValue(AvaloniaObject o);
    [NullableContextAttribute("2")]
internal virtual IDisposable RouteSetValue(AvaloniaObject o, object value, BindingPriority priority);
    internal virtual void RouteSetDirectValueUnchecked(AvaloniaObject o, object value);
    internal virtual void RouteSetCurrentValue(AvaloniaObject o, object value);
    internal virtual IDisposable RouteBind(AvaloniaObject o, IObservable`1<object> source, BindingPriority priority);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.DirectPropertyMetadata`1 : AvaloniaPropertyMetadata {
    [CompilerGeneratedAttribute]
private TValue <UnsetValue>k__BackingField;
    public TValue UnsetValue { get; private set; }
    [NullableAttribute("2")]
private object Avalonia.IDirectPropertyMetadata.UnsetValue { get; }
    public DirectPropertyMetadata`1(TValue unsetValue, BindingMode defaultBindingMode, Nullable`1<bool> enableDataValidation);
    [CompilerGeneratedAttribute]
public TValue get_UnsetValue();
    [CompilerGeneratedAttribute]
private void set_UnsetValue(TValue value);
    [NullableContextAttribute("2")]
private sealed virtual override object Avalonia.IDirectPropertyMetadata.get_UnsetValue();
    public virtual void Merge(AvaloniaPropertyMetadata baseMetadata, AvaloniaProperty property);
    public virtual AvaloniaPropertyMetadata GenerateTypeSafeMetadata();
}
[ExtensionAttribute]
internal static class Avalonia.EnumExtensions : object {
    [ExtensionAttribute]
public static bool HasAllFlags(T value, T flags);
    [ExtensionAttribute]
public static bool HasAnyFlag(T value, T flags);
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
public interface Avalonia.IAvaloniaDependencyResolver {
    public abstract virtual object GetService(Type t);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.IDataContextProvider {
    public object DataContext { get; public set; }
    public abstract virtual object get_DataContext();
    public abstract virtual void set_DataContext(object value);
}
[NullableContextAttribute("2")]
public interface Avalonia.IDescription {
    public string Description { get; }
    public abstract virtual string get_Description();
}
[NullableContextAttribute("1")]
internal interface Avalonia.IDirectPropertyAccessor {
    public bool IsReadOnly { get; }
    public Type Owner { get; }
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual Type get_Owner();
    public abstract virtual object GetValue(AvaloniaObject instance);
    public abstract virtual void SetValue(AvaloniaObject instance, object value);
    public abstract virtual object GetUnsetValue(Type type);
    public abstract virtual object GetUnsetValue(AvaloniaObject owner);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.IDirectPropertyMetadata {
    public object UnsetValue { get; }
    public Nullable`1<bool> EnableDataValidation { get; }
    public abstract virtual object get_UnsetValue();
    public abstract virtual Nullable`1<bool> get_EnableDataValidation();
}
[NullableContextAttribute("2")]
public interface Avalonia.INamed {
    public string Name { get; }
    public abstract virtual string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Input.AccessKeyHandler : object {
    public static RoutedEvent`1<RoutedEventArgs> AccessKeyPressedEvent;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<string, IInputElement>> _registered;
    [NullableAttribute("2")]
private IInputRoot _owner;
    private bool _showingAccessKeys;
    private bool _ignoreAltUp;
    private bool _altIsDown;
    [NullableAttribute("2")]
private IInputElement _restoreFocusElement;
    [NullableAttribute("2")]
private IMainMenu _mainMenu;
    [NullableAttribute("2")]
public IMainMenu MainMenu { get; public set; }
    private static AccessKeyHandler();
    [NullableContextAttribute("2")]
public sealed virtual IMainMenu get_MainMenu();
    [NullableContextAttribute("2")]
public sealed virtual void set_MainMenu(IMainMenu value);
    public sealed virtual void SetOwner(IInputRoot owner);
    public sealed virtual void Register(char accessKey, IInputElement element);
    public sealed virtual void Unregister(IInputElement element);
    protected virtual void OnPreviewKeyDown(object sender, KeyEventArgs e);
    protected virtual void OnKeyDown(object sender, KeyEventArgs e);
    protected virtual void OnPreviewKeyUp(object sender, KeyEventArgs e);
    protected virtual void OnPreviewPointerPressed(object sender, PointerEventArgs e);
    private void CloseMenu();
    private void MainMenuClosed(object sender, EventArgs e);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <OnKeyDown>b__15_2(IInputElement x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.Cursor : object {
    public static Cursor Default;
    private string _name;
    [CompilerGeneratedAttribute]
private ICursorImpl <PlatformImpl>k__BackingField;
    internal ICursorImpl PlatformImpl { get; }
    private Cursor(ICursorImpl platformImpl, string name);
    public Cursor(StandardCursorType cursorType);
    public Cursor(Bitmap cursor, PixelPoint hotSpot);
    private static Cursor();
    [CompilerGeneratedAttribute]
internal ICursorImpl get_PlatformImpl();
    public sealed virtual void Dispose();
    public static Cursor Parse(string s);
    private static ICursorFactory GetCursorFactory();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Input.DataFormats : object {
    public static string Text;
    public static string Files;
    [UnstableAttribute("Use DataFormats.Files, this format is supported only on desktop platforms. And it will be removed in 12.0.")]
[EditorBrowsableAttribute("1")]
public static string FileNames;
    private static DataFormats();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.DataObject : object {
    private Dictionary`2<string, object> _items;
    public sealed virtual bool Contains(string dataFormat);
    public sealed virtual object Get(string dataFormat);
    public sealed virtual IEnumerable`1<string> GetDataFormats();
    public void Set(string dataFormat, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Input.DataObjectExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IStorageItem> GetFiles(IDataObject dataObject);
    [ExtensionAttribute]
[ObsoleteAttribute("Use GetFiles, this method is supported only on desktop platforms.")]
[EditorBrowsableAttribute("1")]
public static IEnumerable`1<string> GetFileNames(IDataObject dataObject);
    [ExtensionAttribute]
public static string GetText(IDataObject dataObject);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Input.DragDrop : object {
    public static RoutedEvent`1<DragEventArgs> DragEnterEvent;
    public static RoutedEvent`1<DragEventArgs> DragLeaveEvent;
    public static RoutedEvent`1<DragEventArgs> DragOverEvent;
    public static RoutedEvent`1<DragEventArgs> DropEvent;
    public static AttachedProperty`1<bool> AllowDropProperty;
    private static DragDrop();
    public static bool GetAllowDrop(Interactive interactive);
    public static void SetAllowDrop(Interactive interactive, bool value);
    public static Task`1<DragDropEffects> DoDragDrop(PointerEventArgs triggerEvent, IDataObject data, DragDropEffects allowedEffects);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.DragDropDevice : object {
    public static DragDropDevice Instance;
    [NullableAttribute("2")]
private Interactive _lastTarget;
    private static DragDropDevice();
    private static Interactive GetTarget(IInputRoot root, Point local);
    private static DragDropEffects RaiseDragEvent(Interactive target, IInputRoot inputRoot, Point point, RoutedEvent`1<DragEventArgs> routedEvent, DragDropEffects operation, IDataObject data, KeyModifiers modifiers);
    private DragDropEffects DragEnter(IInputRoot inputRoot, Point point, IDataObject data, DragDropEffects effects, KeyModifiers modifiers);
    private DragDropEffects DragOver(IInputRoot inputRoot, Point point, IDataObject data, DragDropEffects effects, KeyModifiers modifiers);
    private void DragLeave(IInputRoot inputRoot, Point point, IDataObject data, DragDropEffects effects, KeyModifiers modifiers);
    private DragDropEffects Drop(IInputRoot inputRoot, Point point, IDataObject data, DragDropEffects effects, KeyModifiers modifiers);
    public sealed virtual void ProcessRawEvent(RawInputEventArgs e);
    private void ProcessRawEvent(RawDragEvent e);
}
[FlagsAttribute]
public enum Avalonia.Input.DragDropEffects : Enum {
    public int value__;
    public static DragDropEffects None;
    public static DragDropEffects Copy;
    public static DragDropEffects Move;
    public static DragDropEffects Link;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.DragEventArgs : RoutedEventArgs {
    private Interactive _target;
    private Point _targetLocation;
    [CompilerGeneratedAttribute]
private DragDropEffects <DragEffects>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataObject <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyModifiers <KeyModifiers>k__BackingField;
    public DragDropEffects DragEffects { get; public set; }
    public IDataObject Data { get; }
    public KeyModifiers KeyModifiers { get; }
    [UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using DragDrop.DoDragDrop or IHeadlessWindow.DragDrop.")]
public DragEventArgs(RoutedEvent`1<DragEventArgs> routedEvent, IDataObject data, Interactive target, Point targetLocation, KeyModifiers keyModifiers);
    [CompilerGeneratedAttribute]
public DragDropEffects get_DragEffects();
    [CompilerGeneratedAttribute]
public void set_DragEffects(DragDropEffects value);
    [CompilerGeneratedAttribute]
public IDataObject get_Data();
    [CompilerGeneratedAttribute]
public KeyModifiers get_KeyModifiers();
    public Point GetPosition(Visual relativeTo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.FocusManager : object {
    private static AttachedProperty`1<IInputElement> FocusedElementProperty;
    [NullableAttribute("2")]
private StyledElement _focusRoot;
    [NullableAttribute("2")]
private IInputElement Current { get; }
    private static FocusManager();
    [NullableContextAttribute("2")]
private IInputElement get_Current();
    [NullableContextAttribute("2")]
public sealed virtual IInputElement GetFocusedElement();
    [NullableContextAttribute("2")]
public bool Focus(IInputElement control, NavigationMethod method, KeyModifiers keyModifiers);
    public sealed virtual void ClearFocus();
    public void ClearFocusOnElementRemoved(IInputElement removedElement, Visual oldParent);
    public IInputElement GetFocusedElement(IFocusScope scope);
    public void SetFocusScope(IFocusScope scope);
    public void RemoveFocusRoot(IFocusScope scope);
    public static bool GetIsFocusScope(IInputElement e);
    [NullableContextAttribute("2")]
internal static FocusManager GetFocusManager(IInputElement element);
    internal bool TryMoveFocus(NavigationDirection direction);
    internal static bool CanFocus(IInputElement e);
    private static StyledElement GetFocusScope(IInputElement control);
    private static StyledElement GetFocusRoot(StyledElement scope);
    private static void OnPreviewPointerPressed(object sender, RoutedEventArgs e);
    private static bool IsVisible(IInputElement e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Input.GestureRecognizers.GestureRecognizer : StyledElement {
    [NullableAttribute("2")]
private PointerEventArgs _currentPointerEventArgs;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IInputElement <Target>k__BackingField;
    [NullableAttribute("2")]
protected internal IInputElement Target { get; internal set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected internal IInputElement get_Target();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Target(IInputElement value);
    protected abstract virtual void PointerPressed(PointerPressedEventArgs e);
    protected abstract virtual void PointerReleased(PointerReleasedEventArgs e);
    protected abstract virtual void PointerMoved(PointerEventArgs e);
    protected abstract virtual void PointerCaptureLost(IPointer pointer);
    internal void PointerPressedInternal(PointerPressedEventArgs e);
    internal void PointerReleasedInternal(PointerReleasedEventArgs e);
    internal void PointerMovedInternal(PointerEventArgs e);
    internal void PointerCaptureLostInternal(IPointer pointer);
    protected void Capture(IPointer pointer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.GestureRecognizers.GestureRecognizerCollection : object {
    private IInputElement _inputElement;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<GestureRecognizer> _recognizers;
    private static List`1<GestureRecognizer> s_Empty;
    public int Count { get; }
    public GestureRecognizerCollection(IInputElement inputElement);
    private static GestureRecognizerCollection();
    public void Add(GestureRecognizer recognizer);
    public sealed virtual IEnumerator`1<GestureRecognizer> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    internal bool HandlePointerPressed(PointerPressedEventArgs e);
    internal void HandleCaptureLost(IPointer pointer);
    internal bool HandlePointerReleased(PointerReleasedEventArgs e);
    internal bool HandlePointerMoved(PointerEventArgs e);
}
internal class Avalonia.Input.GestureRecognizers.LeastSquaresSolver : object {
    private static double PrecisionErrorTolerance;
    public static PolynomialFit Solve(int degree, ReadOnlySpan`1<double> x, ReadOnlySpan`1<double> y, ReadOnlySpan`1<double> w);
    private static double Multiply(Span`1<double> v1, Span`1<double> v2);
    private static double Norm(Span`1<double> v);
}
internal class Avalonia.Input.GestureRecognizers.PointAtTime : ValueType {
    [CompilerGeneratedAttribute]
private bool <Valid>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Time>k__BackingField;
    public bool Valid { get; public set; }
    public Vector Point { get; public set; }
    public TimeSpan Time { get; public set; }
    public PointAtTime(bool Valid, Vector Point, TimeSpan Time);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Valid();
    [CompilerGeneratedAttribute]
public void set_Valid(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector get_Point();
    [CompilerGeneratedAttribute]
public void set_Point(Vector value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TimeSpan get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(TimeSpan value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PointAtTime left, PointAtTime right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PointAtTime left, PointAtTime right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PointAtTime other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Boolean& Valid, Vector& Point, TimeSpan& Time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Input.GestureRecognizers.PolynomialFit : object {
    [CompilerGeneratedAttribute]
private Double[] <Coefficients>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Confidence>k__BackingField;
    public Double[] Coefficients { get; }
    public double Confidence { get; public set; }
    internal PolynomialFit(int degree);
    [CompilerGeneratedAttribute]
public Double[] get_Coefficients();
    [CompilerGeneratedAttribute]
public double get_Confidence();
    [CompilerGeneratedAttribute]
public void set_Confidence(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.GestureRecognizers.ScrollGestureRecognizer : GestureRecognizer {
    internal static double InertialScrollSpeedEnd;
    public static double InertialResistance;
    private bool _canHorizontallyScroll;
    private bool _canVerticallyScroll;
    private bool _isScrollInertiaEnabled;
    private static int s_defaultScrollStartDistance;
    private int _scrollStartDistance;
    private bool _scrolling;
    private Point _trackedRootPoint;
    [NullableAttribute("2")]
private IPointer _tracking;
    private int _gestureId;
    private Point _pointerPressedPoint;
    [NullableAttribute("2")]
private VelocityTracker _velocityTracker;
    [NullableAttribute("2")]
private Visual _rootTarget;
    private Vector _inertia;
    private Nullable`1<ulong> _lastMoveTimestamp;
    public static DirectProperty`2<ScrollGestureRecognizer, bool> CanHorizontallyScrollProperty;
    public static DirectProperty`2<ScrollGestureRecognizer, bool> CanVerticallyScrollProperty;
    public static DirectProperty`2<ScrollGestureRecognizer, bool> IsScrollInertiaEnabledProperty;
    public static DirectProperty`2<ScrollGestureRecognizer, int> ScrollStartDistanceProperty;
    public bool CanHorizontallyScroll { get; public set; }
    public bool CanVerticallyScroll { get; public set; }
    public bool IsScrollInertiaEnabled { get; public set; }
    public int ScrollStartDistance { get; public set; }
    private static ScrollGestureRecognizer();
    public bool get_CanHorizontallyScroll();
    public void set_CanHorizontallyScroll(bool value);
    public bool get_CanVerticallyScroll();
    public void set_CanVerticallyScroll(bool value);
    public bool get_IsScrollInertiaEnabled();
    public void set_IsScrollInertiaEnabled(bool value);
    public int get_ScrollStartDistance();
    public void set_ScrollStartDistance(int value);
    protected virtual void PointerPressed(PointerPressedEventArgs e);
    protected virtual void PointerMoved(PointerEventArgs e);
    protected virtual void PointerCaptureLost(IPointer pointer);
    private void EndGesture();
    protected virtual void PointerReleased(PointerReleasedEventArgs e);
}
[IsReadOnlyAttribute]
internal class Avalonia.Input.GestureRecognizers.Velocity : ValueType {
    [CompilerGeneratedAttribute]
private Vector <PixelsPerSecond>k__BackingField;
    public Vector PixelsPerSecond { get; public set; }
    public Velocity(Vector PixelsPerSecond);
    [CompilerGeneratedAttribute]
public Vector get_PixelsPerSecond();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PixelsPerSecond(Vector value);
    public Velocity ClampMagnitude(double minValue, double maxValue);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Velocity left, Velocity right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Velocity left, Velocity right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Velocity other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Vector& PixelsPerSecond);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Input.GestureRecognizers.VelocityEstimate : object {
    [CompilerGeneratedAttribute]
private Vector <PixelsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Confidence>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Vector PixelsPerSecond { get; public set; }
    public double Confidence { get; public set; }
    public TimeSpan Duration { get; public set; }
    public Vector Offset { get; public set; }
    public VelocityEstimate(Vector PixelsPerSecond, double Confidence, TimeSpan Duration, Vector Offset);
    [CompilerGeneratedAttribute]
protected VelocityEstimate(VelocityEstimate original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Vector get_PixelsPerSecond();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PixelsPerSecond(Vector value);
    [CompilerGeneratedAttribute]
public double get_Confidence();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Confidence(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public Vector get_Offset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Offset(Vector value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(VelocityEstimate left, VelocityEstimate right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(VelocityEstimate left, VelocityEstimate right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(VelocityEstimate other);
    [CompilerGeneratedAttribute]
public virtual VelocityEstimate <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Vector& PixelsPerSecond, Double& Confidence, TimeSpan& Duration, Vector& Offset);
}
internal class Avalonia.Input.GestureRecognizers.VelocityTracker : object {
    private static int AssumePointerMoveStoppedMilliseconds;
    private static int HistorySize;
    private static int HorizonMilliseconds;
    private static int MinSampleSize;
    private static double MinFlingVelocity;
    private static double MaxFlingVelocity;
    [NullableAttribute("1")]
private PointAtTime[] _samples;
    private int _index;
    public void AddPosition(TimeSpan time, Vector position);
    [NullableContextAttribute("2")]
protected virtual VelocityEstimate GetVelocityEstimate();
    internal Velocity GetVelocity();
    internal virtual Velocity GetFlingVelocity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Input.Gestures : object {
    private static Nullable`1<GestureState> s_gestureState;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static WeakReference`1<object> s_lastPress;
    private static Point s_lastPressPoint;
    [NullableAttribute("2")]
private static CancellationTokenSource s_holdCancellationToken;
    public static AttachedProperty`1<bool> IsHoldingEnabledProperty;
    public static AttachedProperty`1<bool> IsHoldWithMouseEnabledProperty;
    public static RoutedEvent`1<TappedEventArgs> TappedEvent;
    public static RoutedEvent`1<TappedEventArgs> DoubleTappedEvent;
    public static RoutedEvent`1<TappedEventArgs> RightTappedEvent;
    public static RoutedEvent`1<ScrollGestureEventArgs> ScrollGestureEvent;
    public static RoutedEvent`1<ScrollGestureInertiaStartingEventArgs> ScrollGestureInertiaStartingEvent;
    public static RoutedEvent`1<ScrollGestureEndedEventArgs> ScrollGestureEndedEvent;
    public static RoutedEvent`1<PointerDeltaEventArgs> PointerTouchPadGestureMagnifyEvent;
    public static RoutedEvent`1<PointerDeltaEventArgs> PointerTouchPadGestureRotateEvent;
    public static RoutedEvent`1<PointerDeltaEventArgs> PointerTouchPadGestureSwipeEvent;
    public static RoutedEvent`1<PinchEventArgs> PinchEvent;
    public static RoutedEvent`1<PinchEndedEventArgs> PinchEndedEvent;
    public static RoutedEvent`1<PullGestureEventArgs> PullGestureEvent;
    public static RoutedEvent`1<HoldingRoutedEventArgs> HoldingEvent;
    public static RoutedEvent`1<PullGestureEndedEventArgs> PullGestureEndedEvent;
    private static Gestures();
    public static bool GetIsHoldingEnabled(StyledElement element);
    public static void SetIsHoldingEnabled(StyledElement element, bool value);
    public static bool GetIsHoldWithMouseEnabled(StyledElement element);
    public static void SetIsHoldWithMouseEnabled(StyledElement element, bool value);
    public static void AddTappedHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void AddDoubleTappedHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void AddRightTappedHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void AddHoldingHandler(Interactive element, EventHandler`1<HoldingRoutedEventArgs> handler);
    public static void AddPinchHandler(Interactive element, EventHandler`1<PinchEventArgs> handler);
    public static void AddPinchEndedHandler(Interactive element, EventHandler`1<PinchEndedEventArgs> handler);
    public static void AddPullGestureHandler(Interactive element, EventHandler`1<PullGestureEventArgs> handler);
    public static void AddPullGestureEndedHandler(Interactive element, EventHandler`1<PullGestureEndedEventArgs> handler);
    public static void AddPointerTouchPadGestureMagnifyHandler(Interactive element, EventHandler`1<PointerDeltaEventArgs> handler);
    public static void AddPointerTouchPadGestureRotateHandler(Interactive element, EventHandler`1<PointerDeltaEventArgs> handler);
    public static void AddPointerTouchPadGestureSwipeHandler(Interactive element, EventHandler`1<PointerDeltaEventArgs> handler);
    public static void AddScrollGestureHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void AddScrollGestureEndedHandler(Interactive element, EventHandler`1<ScrollGestureEndedEventArgs> handler);
    public static void AddScrollGestureInertiaStartingHandler(Interactive element, EventHandler`1<ScrollGestureInertiaStartingEventArgs> handler);
    public static void RemoveTappedHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void RemoveDoubleTappedHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void RemoveRightTappedHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void RemoveHoldingHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void RemovePinchHandler(Interactive element, EventHandler`1<PinchEventArgs> handler);
    public static void RemovePinchEndedHandler(Interactive element, EventHandler`1<PinchEndedEventArgs> handler);
    public static void RemovePullGestureHandler(Interactive element, EventHandler`1<PullGestureEventArgs> handler);
    public static void RemovePullGestureEndedHandler(Interactive element, EventHandler`1<PullGestureEndedEventArgs> handler);
    public static void RemovePointerTouchPadGestureMagnifyHandler(Interactive element, EventHandler`1<PointerDeltaEventArgs> handler);
    public static void RemovePointerTouchPadGestureRotateHandler(Interactive element, EventHandler`1<PointerDeltaEventArgs> handler);
    public static void RemovePointerTouchPadGestureSwipeHandler(Interactive element, EventHandler`1<PointerDeltaEventArgs> handler);
    public static void RemoveScrollGestureHandler(Interactive element, EventHandler`1<ScrollGestureEventArgs> handler);
    public static void RemoveScrollGestureEndedHandler(Interactive element, EventHandler`1<ScrollGestureEndedEventArgs> handler);
    public static void RemoveScrollGestureInertiaStartingHandler(Interactive element, EventHandler`1<ScrollGestureInertiaStartingEventArgs> handler);
    private static void PointerPressed(RoutedEventArgs ev);
    private static void PointerReleased(RoutedEventArgs ev);
    private static void PointerMoved(RoutedEventArgs ev);
}
public class Avalonia.Input.GotFocusEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private NavigationMethod <NavigationMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyModifiers <KeyModifiers>k__BackingField;
    public NavigationMethod NavigationMethod { get; public set; }
    public KeyModifiers KeyModifiers { get; public set; }
    [CompilerGeneratedAttribute]
public NavigationMethod get_NavigationMethod();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NavigationMethod(NavigationMethod value);
    [CompilerGeneratedAttribute]
public KeyModifiers get_KeyModifiers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeyModifiers(KeyModifiers value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Input.HoldingRoutedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private HoldingState <HoldingState>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private PointerType <PointerType>k__BackingField;
    [CompilerGeneratedAttribute]
private PointerEventArgs <PointerEventArgs>k__BackingField;
    public HoldingState HoldingState { get; }
    public Point Position { get; }
    public PointerType PointerType { get; }
    internal PointerEventArgs PointerEventArgs { get; }
    public HoldingRoutedEventArgs(HoldingState holdingState, Point position, PointerType pointerType);
    [NullableContextAttribute("1")]
internal HoldingRoutedEventArgs(HoldingState holdingState, Point position, PointerType pointerType, PointerEventArgs pointerEventArgs);
    [CompilerGeneratedAttribute]
public HoldingState get_HoldingState();
    [CompilerGeneratedAttribute]
public Point get_Position();
    [CompilerGeneratedAttribute]
public PointerType get_PointerType();
    [CompilerGeneratedAttribute]
internal PointerEventArgs get_PointerEventArgs();
}
public enum Avalonia.Input.HoldingState : Enum {
    public int value__;
    public static HoldingState Started;
    public static HoldingState Completed;
    public static HoldingState Cancelled;
}
[NullableContextAttribute("1")]
internal interface Avalonia.Input.IAccessKeyHandler {
    [NullableAttribute("2")]
public IMainMenu MainMenu { get; public set; }
    [NullableContextAttribute("2")]
public abstract virtual IMainMenu get_MainMenu();
    [NullableContextAttribute("2")]
public abstract virtual void set_MainMenu(IMainMenu value);
    public abstract virtual void SetOwner(IInputRoot owner);
    public abstract virtual void Register(char accessKey, IInputElement element);
    public abstract virtual void Unregister(IInputElement element);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Input.IClickableControl {
    public bool IsEffectivelyEnabled { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Click(EventHandler`1<RoutedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Click(EventHandler`1<RoutedEventArgs> value);
    public abstract virtual void RaiseClick();
    public abstract virtual bool get_IsEffectivelyEnabled();
}
[NullableContextAttribute("2")]
public interface Avalonia.Input.ICloseable {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler value);
}
[NullableContextAttribute("2")]
public interface Avalonia.Input.ICommandSource {
    public ICommand Command { get; }
    public object CommandParameter { get; }
    public bool IsEffectivelyEnabled { get; }
    public abstract virtual ICommand get_Command();
    public abstract virtual object get_CommandParameter();
    [NullableContextAttribute("1")]
public abstract virtual void CanExecuteChanged(object sender, EventArgs e);
    public abstract virtual bool get_IsEffectivelyEnabled();
}
[NullableContextAttribute("1")]
public interface Avalonia.Input.ICustomKeyboardNavigation {
    public abstract virtual ValueTuple`2<bool, IInputElement> GetNext(IInputElement element, NavigationDirection direction);
}
[NullableContextAttribute("1")]
public interface Avalonia.Input.IDataObject {
    public abstract virtual IEnumerable`1<string> GetDataFormats();
    public abstract virtual bool Contains(string dataFormat);
    public abstract virtual object Get(string dataFormat);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Input.IFocusManager {
    public abstract virtual IInputElement GetFocusedElement();
    [UnstableAttribute("This API might be removed in 11.x minor updates. Please consider focusing another element instead of removing focus at all for better UX.")]
public abstract virtual void ClearFocus();
}
[NotClientImplementableAttribute]
public interface Avalonia.Input.IFocusScope {
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
[PrivateApiAttribute]
public interface Avalonia.Input.IInputDevice {
    public abstract virtual void ProcessRawEvent(RawInputEventArgs ev);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Input.IInputElement {
    public bool Focusable { get; }
    public bool IsEnabled { get; }
    [NullableAttribute("2")]
public Cursor Cursor { get; }
    public bool IsEffectivelyEnabled { get; }
    public bool IsEffectivelyVisible { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsFocused { get; }
    public bool IsHitTestVisible { get; }
    public bool IsPointerOver { get; }
    public List`1<KeyBinding> KeyBindings { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotFocus(EventHandler`1<GotFocusEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotFocus(EventHandler`1<GotFocusEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostFocus(EventHandler`1<RoutedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostFocus(EventHandler`1<RoutedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyDown(EventHandler`1<KeyEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyDown(EventHandler`1<KeyEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyUp(EventHandler`1<KeyEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyUp(EventHandler`1<KeyEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextInput(EventHandler`1<TextInputEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextInput(EventHandler`1<TextInputEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PointerEntered(EventHandler`1<PointerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PointerEntered(EventHandler`1<PointerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PointerExited(EventHandler`1<PointerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PointerExited(EventHandler`1<PointerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PointerPressed(EventHandler`1<PointerPressedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PointerPressed(EventHandler`1<PointerPressedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PointerMoved(EventHandler`1<PointerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PointerMoved(EventHandler`1<PointerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PointerReleased(EventHandler`1<PointerReleasedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PointerReleased(EventHandler`1<PointerReleasedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PointerWheelChanged(EventHandler`1<PointerWheelEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PointerWheelChanged(EventHandler`1<PointerWheelEventArgs> value);
    public abstract virtual bool get_Focusable();
    public abstract virtual bool get_IsEnabled();
    [NullableContextAttribute("2")]
public abstract virtual Cursor get_Cursor();
    public abstract virtual bool get_IsEffectivelyEnabled();
    public abstract virtual bool get_IsEffectivelyVisible();
    public abstract virtual bool get_IsKeyboardFocusWithin();
    public abstract virtual bool get_IsFocused();
    public abstract virtual bool get_IsHitTestVisible();
    public abstract virtual bool get_IsPointerOver();
    public abstract virtual bool Focus(NavigationMethod method, KeyModifiers keyModifiers);
    public abstract virtual List`1<KeyBinding> get_KeyBindings();
    public abstract virtual void AddHandler(RoutedEvent routedEvent, Delegate handler, RoutingStrategies routes, bool handledEventsToo);
    public abstract virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public abstract virtual void RaiseEvent(RoutedEventArgs e);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
[PrivateApiAttribute]
public interface Avalonia.Input.IInputManager {
    public IObservable`1<RawInputEventArgs> PreProcess { get; }
    public IObservable`1<RawInputEventArgs> Process { get; }
    public IObservable`1<RawInputEventArgs> PostProcess { get; }
    public abstract virtual IObservable`1<RawInputEventArgs> get_PreProcess();
    public abstract virtual IObservable`1<RawInputEventArgs> get_Process();
    public abstract virtual IObservable`1<RawInputEventArgs> get_PostProcess();
    public abstract virtual void ProcessInput(RawInputEventArgs e);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Input.IInputRoot {
    [NullableAttribute("1")]
public IKeyboardNavigationHandler KeyboardNavigationHandler { get; }
    public IFocusManager FocusManager { get; }
    public IPlatformSettings PlatformSettings { get; }
    public IInputElement PointerOverElement { get; public set; }
    public bool ShowAccessKeys { get; public set; }
    [NullableContextAttribute("1")]
public abstract virtual IKeyboardNavigationHandler get_KeyboardNavigationHandler();
    public abstract virtual IFocusManager get_FocusManager();
    public abstract virtual IPlatformSettings get_PlatformSettings();
    public abstract virtual IInputElement get_PointerOverElement();
    public abstract virtual void set_PointerOverElement(IInputElement value);
    public abstract virtual bool get_ShowAccessKeys();
    public abstract virtual void set_ShowAccessKeys(bool value);
}
[PrivateApiAttribute]
public interface Avalonia.Input.IKeyboardDevice {
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Input.IKeyboardNavigationHandler {
    [PrivateApiAttribute]
public abstract virtual void SetOwner(IInputRoot owner);
    public abstract virtual void Move(IInputElement element, NavigationDirection direction, KeyModifiers keyModifiers);
}
internal interface Avalonia.Input.IMainMenu {
    public bool IsOpen { get; }
    public abstract virtual bool get_IsOpen();
    public abstract virtual void Close();
    public abstract virtual void Open();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler`1<RoutedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler`1<RoutedEventArgs> value);
}
[PrivateApiAttribute]
public interface Avalonia.Input.IMouseDevice {
}
[NullableContextAttribute("2")]
public interface Avalonia.Input.INavigableContainer {
    public abstract virtual IInputElement GetControl(NavigationDirection direction, IInputElement from, bool wrap);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PseudoClassesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Input.InputElement : Interactive {
    public static StyledProperty`1<bool> FocusableProperty;
    public static StyledProperty`1<bool> IsEnabledProperty;
    public static DirectProperty`2<InputElement, bool> IsEffectivelyEnabledProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Cursor> CursorProperty;
    public static DirectProperty`2<InputElement, bool> IsKeyboardFocusWithinProperty;
    public static DirectProperty`2<InputElement, bool> IsFocusedProperty;
    public static StyledProperty`1<bool> IsHitTestVisibleProperty;
    public static DirectProperty`2<InputElement, bool> IsPointerOverProperty;
    public static StyledProperty`1<bool> IsTabStopProperty;
    public static RoutedEvent`1<GotFocusEventArgs> GotFocusEvent;
    public static RoutedEvent`1<RoutedEventArgs> LostFocusEvent;
    public static RoutedEvent`1<KeyEventArgs> KeyDownEvent;
    public static RoutedEvent`1<KeyEventArgs> KeyUpEvent;
    public static StyledProperty`1<int> TabIndexProperty;
    public static RoutedEvent`1<TextInputEventArgs> TextInputEvent;
    public static RoutedEvent`1<TextInputMethodClientRequestedEventArgs> TextInputMethodClientRequestedEvent;
    public static RoutedEvent`1<PointerEventArgs> PointerEnteredEvent;
    public static RoutedEvent`1<PointerEventArgs> PointerExitedEvent;
    public static RoutedEvent`1<PointerEventArgs> PointerMovedEvent;
    public static RoutedEvent`1<PointerPressedEventArgs> PointerPressedEvent;
    public static RoutedEvent`1<PointerReleasedEventArgs> PointerReleasedEvent;
    public static RoutedEvent`1<PointerCaptureLostEventArgs> PointerCaptureLostEvent;
    public static RoutedEvent`1<PointerWheelEventArgs> PointerWheelChangedEvent;
    public static RoutedEvent`1<TappedEventArgs> TappedEvent;
    public static RoutedEvent`1<HoldingRoutedEventArgs> HoldingEvent;
    public static RoutedEvent`1<TappedEventArgs> DoubleTappedEvent;
    private bool _isEffectivelyEnabled;
    private bool _isFocused;
    private bool _isKeyboardFocusWithin;
    private bool _isFocusVisible;
    private bool _isPointerOver;
    [NullableAttribute("2")]
private GestureRecognizerCollection _gestureRecognizers;
    [CompilerGeneratedAttribute]
private List`1<KeyBinding> <KeyBindings>k__BackingField;
    public bool Focusable { get; public set; }
    public bool IsEnabled { get; public set; }
    [NullableAttribute("2")]
public Cursor Cursor { get; public set; }
    public bool IsKeyboardFocusWithin { get; internal set; }
    public bool IsFocused { get; private set; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsPointerOver { get; internal set; }
    public bool IsTabStop { get; public set; }
    public bool IsEffectivelyEnabled { get; private set; }
    public int TabIndex { get; public set; }
    public List`1<KeyBinding> KeyBindings { get; }
    protected bool IsEnabledCore { get; }
    public GestureRecognizerCollection GestureRecognizers { get; }
    private static InputElement();
    public sealed virtual void add_GotFocus(EventHandler`1<GotFocusEventArgs> value);
    public sealed virtual void remove_GotFocus(EventHandler`1<GotFocusEventArgs> value);
    public sealed virtual void add_LostFocus(EventHandler`1<RoutedEventArgs> value);
    public sealed virtual void remove_LostFocus(EventHandler`1<RoutedEventArgs> value);
    public sealed virtual void add_KeyDown(EventHandler`1<KeyEventArgs> value);
    public sealed virtual void remove_KeyDown(EventHandler`1<KeyEventArgs> value);
    public sealed virtual void add_KeyUp(EventHandler`1<KeyEventArgs> value);
    public sealed virtual void remove_KeyUp(EventHandler`1<KeyEventArgs> value);
    public sealed virtual void add_TextInput(EventHandler`1<TextInputEventArgs> value);
    public sealed virtual void remove_TextInput(EventHandler`1<TextInputEventArgs> value);
    public void add_TextInputMethodClientRequested(EventHandler`1<TextInputMethodClientRequestedEventArgs> value);
    public void remove_TextInputMethodClientRequested(EventHandler`1<TextInputMethodClientRequestedEventArgs> value);
    public sealed virtual void add_PointerEntered(EventHandler`1<PointerEventArgs> value);
    public sealed virtual void remove_PointerEntered(EventHandler`1<PointerEventArgs> value);
    public sealed virtual void add_PointerExited(EventHandler`1<PointerEventArgs> value);
    public sealed virtual void remove_PointerExited(EventHandler`1<PointerEventArgs> value);
    public sealed virtual void add_PointerMoved(EventHandler`1<PointerEventArgs> value);
    public sealed virtual void remove_PointerMoved(EventHandler`1<PointerEventArgs> value);
    public sealed virtual void add_PointerPressed(EventHandler`1<PointerPressedEventArgs> value);
    public sealed virtual void remove_PointerPressed(EventHandler`1<PointerPressedEventArgs> value);
    public sealed virtual void add_PointerReleased(EventHandler`1<PointerReleasedEventArgs> value);
    public sealed virtual void remove_PointerReleased(EventHandler`1<PointerReleasedEventArgs> value);
    public void add_PointerCaptureLost(EventHandler`1<PointerCaptureLostEventArgs> value);
    public void remove_PointerCaptureLost(EventHandler`1<PointerCaptureLostEventArgs> value);
    public sealed virtual void add_PointerWheelChanged(EventHandler`1<PointerWheelEventArgs> value);
    public sealed virtual void remove_PointerWheelChanged(EventHandler`1<PointerWheelEventArgs> value);
    public void add_Tapped(EventHandler`1<TappedEventArgs> value);
    public void remove_Tapped(EventHandler`1<TappedEventArgs> value);
    public void add_Holding(EventHandler`1<HoldingRoutedEventArgs> value);
    public void remove_Holding(EventHandler`1<HoldingRoutedEventArgs> value);
    public void add_DoubleTapped(EventHandler`1<TappedEventArgs> value);
    public void remove_DoubleTapped(EventHandler`1<TappedEventArgs> value);
    public sealed virtual bool get_Focusable();
    public void set_Focusable(bool value);
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    [NullableContextAttribute("2")]
public sealed virtual Cursor get_Cursor();
    [NullableContextAttribute("2")]
public void set_Cursor(Cursor value);
    public sealed virtual bool get_IsKeyboardFocusWithin();
    internal void set_IsKeyboardFocusWithin(bool value);
    public sealed virtual bool get_IsFocused();
    private void set_IsFocused(bool value);
    public sealed virtual bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public sealed virtual bool get_IsPointerOver();
    internal void set_IsPointerOver(bool value);
    public bool get_IsTabStop();
    public void set_IsTabStop(bool value);
    public sealed virtual bool get_IsEffectivelyEnabled();
    private void set_IsEffectivelyEnabled(bool value);
    public int get_TabIndex();
    public void set_TabIndex(int value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<KeyBinding> get_KeyBindings();
    protected virtual bool get_IsEnabledCore();
    public GestureRecognizerCollection get_GestureRecognizers();
    public sealed virtual bool Focus(NavigationMethod method, KeyModifiers keyModifiers);
    protected virtual void OnDetachedFromVisualTreeCore(VisualTreeAttachmentEventArgs e);
    protected virtual void OnAttachedToVisualTreeCore(VisualTreeAttachmentEventArgs e);
    protected virtual void OnGotFocus(GotFocusEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnTextInput(TextInputEventArgs e);
    protected virtual void OnPointerEntered(PointerEventArgs e);
    protected virtual void OnPointerExited(PointerEventArgs e);
    protected virtual void OnPointerMoved(PointerEventArgs e);
    protected virtual void OnPointerPressed(PointerPressedEventArgs e);
    protected virtual void OnPointerReleased(PointerReleasedEventArgs e);
    private void OnGesturePointerReleased(PointerReleasedEventArgs e);
    private void OnGesturePointerCaptureLost(PointerCaptureLostEventArgs e);
    private void OnGesturePointerPressed(PointerPressedEventArgs e);
    private void OnGesturePointerMoved(PointerEventArgs e);
    protected virtual void OnPointerCaptureLost(PointerCaptureLostEventArgs e);
    protected virtual void OnPointerWheelChanged(PointerWheelEventArgs e);
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    protected void UpdateIsEffectivelyEnabled();
    private static void IsEnabledChanged(AvaloniaPropertyChangedEventArgs e);
    private void OnPointerEnteredCore(PointerEventArgs e);
    private void OnPointerExitedCore(PointerEventArgs e);
    [NullableContextAttribute("2")]
private void UpdateIsEffectivelyEnabled(InputElement parent);
    private void UpdatePseudoClasses(Nullable`1<bool> isFocused, Nullable`1<bool> isPointerOver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Input.InputExtensions : object {
    private static Func`2<Visual, bool> s_hitTestDelegate;
    private static Func`2<Visual, bool> s_hitTestEnabledOnlyDelegate;
    private static InputExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<IInputElement> GetInputElementsAt(IInputElement element, Point p, bool enabledElementsOnly);
    [ExtensionAttribute]
public static IEnumerable`1<IInputElement> GetInputElementsAt(IInputElement element, Point p);
    [ExtensionAttribute]
public static IInputElement InputHitTest(IInputElement element, Point p, bool enabledElementsOnly);
    [ExtensionAttribute]
public static IInputElement InputHitTest(IInputElement element, Point p);
    [ExtensionAttribute]
public static IInputElement InputHitTest(IInputElement element, Point p, Func`2<Visual, bool> filter, bool enabledElementsOnly);
    [ExtensionAttribute]
public static IInputElement InputHitTest(IInputElement element, Point p, Func`2<Visual, bool> filter);
    private static bool IsHitTestVisible(Visual visual);
    private static bool IsHitTestVisible_EnabledOnly(Visual visual);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Input.InputManager : object {
    private LightweightSubject`1<RawInputEventArgs> _preProcess;
    private LightweightSubject`1<RawInputEventArgs> _process;
    private LightweightSubject`1<RawInputEventArgs> _postProcess;
    [NullableAttribute("2")]
public static IInputManager Instance { get; }
    public IObservable`1<RawInputEventArgs> PreProcess { get; }
    public IObservable`1<RawInputEventArgs> Process { get; }
    public IObservable`1<RawInputEventArgs> PostProcess { get; }
    [NullableContextAttribute("2")]
public static IInputManager get_Instance();
    public sealed virtual IObservable`1<RawInputEventArgs> get_PreProcess();
    public sealed virtual IObservable`1<RawInputEventArgs> get_Process();
    public sealed virtual IObservable`1<RawInputEventArgs> get_PostProcess();
    public sealed virtual void ProcessInput(RawInputEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.InputMethod : object {
    public static AvaloniaProperty`1<bool> IsInputMethodEnabledProperty;
    public static RoutedEvent`1<TextInputMethodClientRequeryRequestedEventArgs> TextInputMethodClientRequeryRequestedEvent;
    private static InputMethod();
    public static void SetIsInputMethodEnabled(InputElement target, bool value);
    public static bool GetIsInputMethodEnabled(InputElement target);
    public static void AddTextInputMethodClientRequeryRequestedHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
    public static void RemoveTextInputMethodClientRequeryRequestedHandler(Interactive element, EventHandler`1<RoutedEventArgs> handler);
}
[PrivateApiAttribute]
public interface Avalonia.Input.IPenDevice {
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Input.IPointer {
    public int Id { get; }
    public IInputElement Captured { get; }
    public PointerType Type { get; }
    public bool IsPrimary { get; }
    public abstract virtual int get_Id();
    public abstract virtual void Capture(IInputElement control);
    public abstract virtual IInputElement get_Captured();
    public abstract virtual PointerType get_Type();
    public abstract virtual bool get_IsPrimary();
}
[PrivateApiAttribute]
public interface Avalonia.Input.IPointerDevice {
    [NullableContextAttribute("1")]
public abstract virtual IPointer TryGetPointer(RawPointerEventArgs ev);
}
public enum Avalonia.Input.Key : Enum {
    public int value__;
    public static Key None;
    public static Key Cancel;
    public static Key Back;
    public static Key Tab;
    public static Key LineFeed;
    public static Key Clear;
    public static Key Return;
    public static Key Enter;
    public static Key Pause;
    public static Key CapsLock;
    public static Key Capital;
    public static Key HangulMode;
    public static Key KanaMode;
    public static Key JunjaMode;
    public static Key FinalMode;
    public static Key KanjiMode;
    public static Key HanjaMode;
    public static Key Escape;
    public static Key ImeConvert;
    public static Key ImeNonConvert;
    public static Key ImeAccept;
    public static Key ImeModeChange;
    public static Key Space;
    public static Key PageUp;
    public static Key Prior;
    public static Key PageDown;
    public static Key Next;
    public static Key End;
    public static Key Home;
    public static Key Left;
    public static Key Up;
    public static Key Right;
    public static Key Down;
    public static Key Select;
    public static Key Print;
    public static Key Execute;
    public static Key Snapshot;
    public static Key PrintScreen;
    public static Key Insert;
    public static Key Delete;
    public static Key Help;
    public static Key D0;
    public static Key D1;
    public static Key D2;
    public static Key D3;
    public static Key D4;
    public static Key D5;
    public static Key D6;
    public static Key D7;
    public static Key D8;
    public static Key D9;
    public static Key A;
    public static Key B;
    public static Key C;
    public static Key D;
    public static Key E;
    public static Key F;
    public static Key G;
    public static Key H;
    public static Key I;
    public static Key J;
    public static Key K;
    public static Key L;
    public static Key M;
    public static Key N;
    public static Key O;
    public static Key P;
    public static Key Q;
    public static Key R;
    public static Key S;
    public static Key T;
    public static Key U;
    public static Key V;
    public static Key W;
    public static Key X;
    public static Key Y;
    public static Key Z;
    public static Key LWin;
    public static Key RWin;
    public static Key Apps;
    public static Key Sleep;
    public static Key NumPad0;
    public static Key NumPad1;
    public static Key NumPad2;
    public static Key NumPad3;
    public static Key NumPad4;
    public static Key NumPad5;
    public static Key NumPad6;
    public static Key NumPad7;
    public static Key NumPad8;
    public static Key NumPad9;
    public static Key Multiply;
    public static Key Add;
    public static Key Separator;
    public static Key Subtract;
    public static Key Decimal;
    public static Key Divide;
    public static Key F1;
    public static Key F2;
    public static Key F3;
    public static Key F4;
    public static Key F5;
    public static Key F6;
    public static Key F7;
    public static Key F8;
    public static Key F9;
    public static Key F10;
    public static Key F11;
    public static Key F12;
    public static Key F13;
    public static Key F14;
    public static Key F15;
    public static Key F16;
    public static Key F17;
    public static Key F18;
    public static Key F19;
    public static Key F20;
    public static Key F21;
    public static Key F22;
    public static Key F23;
    public static Key F24;
    public static Key NumLock;
    public static Key Scroll;
    public static Key LeftShift;
    public static Key RightShift;
    public static Key LeftCtrl;
    public static Key RightCtrl;
    public static Key LeftAlt;
    public static Key RightAlt;
    public static Key BrowserBack;
    public static Key BrowserForward;
    public static Key BrowserRefresh;
    public static Key BrowserStop;
    public static Key BrowserSearch;
    public static Key BrowserFavorites;
    public static Key BrowserHome;
    public static Key VolumeMute;
    public static Key VolumeDown;
    public static Key VolumeUp;
    public static Key MediaNextTrack;
    public static Key MediaPreviousTrack;
    public static Key MediaStop;
    public static Key MediaPlayPause;
    public static Key LaunchMail;
    public static Key SelectMedia;
    public static Key LaunchApplication1;
    public static Key LaunchApplication2;
    public static Key OemSemicolon;
    public static Key Oem1;
    public static Key OemPlus;
    public static Key OemComma;
    public static Key OemMinus;
    public static Key OemPeriod;
    public static Key OemQuestion;
    public static Key Oem2;
    public static Key OemTilde;
    public static Key Oem3;
    public static Key AbntC1;
    public static Key AbntC2;
    public static Key OemOpenBrackets;
    public static Key Oem4;
    public static Key OemPipe;
    public static Key Oem5;
    public static Key OemCloseBrackets;
    public static Key Oem6;
    public static Key OemQuotes;
    public static Key Oem7;
    public static Key Oem8;
    public static Key OemBackslash;
    public static Key Oem102;
    public static Key ImeProcessed;
    public static Key System;
    public static Key OemAttn;
    public static Key DbeAlphanumeric;
    public static Key OemFinish;
    public static Key DbeKatakana;
    public static Key DbeHiragana;
    public static Key OemCopy;
    public static Key DbeSbcsChar;
    public static Key OemAuto;
    public static Key DbeDbcsChar;
    public static Key OemEnlw;
    public static Key OemBackTab;
    public static Key DbeRoman;
    public static Key DbeNoRoman;
    public static Key Attn;
    public static Key CrSel;
    public static Key DbeEnterWordRegisterMode;
    public static Key ExSel;
    public static Key DbeEnterImeConfigureMode;
    public static Key EraseEof;
    public static Key DbeFlushString;
    public static Key Play;
    public static Key DbeCodeInput;
    public static Key DbeNoCodeInput;
    public static Key Zoom;
    public static Key NoName;
    public static Key DbeDetermineString;
    public static Key DbeEnterDialogConversionMode;
    public static Key Pa1;
    public static Key OemClear;
    public static Key DeadCharProcessed;
    public static Key FnLeftArrow;
    public static Key FnRightArrow;
    public static Key FnUpArrow;
    public static Key FnDownArrow;
    public static Key MediaHome;
    public static Key MediaChannelList;
    public static Key MediaChannelRaise;
    public static Key MediaChannelLower;
    public static Key MediaRecord;
    public static Key MediaRed;
    public static Key MediaGreen;
    public static Key MediaYellow;
    public static Key MediaBlue;
    public static Key MediaMenu;
    public static Key MediaMore;
    public static Key MediaOption;
    public static Key MediaInfo;
    public static Key MediaSearch;
    public static Key MediaSubtitle;
    public static Key MediaTvGuide;
    public static Key MediaPreviousChannel;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.KeyBinding : AvaloniaObject {
    public static StyledProperty`1<ICommand> CommandProperty;
    public static StyledProperty`1<object> CommandParameterProperty;
    public static StyledProperty`1<KeyGesture> GestureProperty;
    public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public KeyGesture Gesture { get; public set; }
    private static KeyBinding();
    public ICommand get_Command();
    public void set_Command(ICommand value);
    public object get_CommandParameter();
    public void set_CommandParameter(object value);
    public KeyGesture get_Gesture();
    public void set_Gesture(KeyGesture value);
    public void TryHandle(KeyEventArgs args);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.KeyboardDevice : object {
    private IInputElement _focusedElement;
    private IInputRoot _focusedRoot;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [NullableAttribute("1")]
private TextInputMethodManager _textInputManager;
    internal static KeyboardDevice Instance { get; }
    public IInputManager InputManager { get; }
    public IFocusManager FocusManager { get; }
    public IInputElement FocusedElement { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    internal static KeyboardDevice get_Instance();
    public IInputManager get_InputManager();
    public IFocusManager get_FocusManager();
    public IInputElement get_FocusedElement();
    private static void ClearFocusWithinAncestors(IInputElement element);
    [NullableContextAttribute("1")]
private void ClearFocusWithin(IInputElement element, bool clearRoot);
    private void SetIsFocusWithin(IInputElement oldElement, IInputElement newElement);
    [NullableContextAttribute("1")]
private void ClearChildrenFocusWithin(IInputElement element, bool clearRoot);
    public void SetFocusedElement(IInputElement element, NavigationMethod method, KeyModifiers keyModifiers);
    [NullableContextAttribute("1")]
protected void RaisePropertyChanged(string propertyName);
    [NullableContextAttribute("1")]
public sealed virtual void ProcessRawEvent(RawInputEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Input.KeyboardNavigation : object {
    public static AttachedProperty`1<int> TabIndexProperty;
    public static AttachedProperty`1<KeyboardNavigationMode> TabNavigationProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static AttachedProperty`1<IInputElement> TabOnceActiveElementProperty;
    public static AttachedProperty`1<bool> IsTabStopProperty;
    private static KeyboardNavigation();
    public static int GetTabIndex(IInputElement element);
    public static void SetTabIndex(IInputElement element, int value);
    public static KeyboardNavigationMode GetTabNavigation(InputElement element);
    public static void SetTabNavigation(InputElement element, KeyboardNavigationMode value);
    public static IInputElement GetTabOnceActiveElement(InputElement element);
    public static void SetTabOnceActiveElement(InputElement element, IInputElement value);
    public static void SetIsTabStop(InputElement element, bool value);
    public static bool GetIsTabStop(InputElement element);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[UnstableAttribute]
public class Avalonia.Input.KeyboardNavigationHandler : object {
    private IInputRoot _owner;
    [NullableContextAttribute("1")]
[PrivateApiAttribute]
public sealed virtual void SetOwner(IInputRoot owner);
    [NullableContextAttribute("1")]
public static IInputElement GetNext(IInputElement element, NavigationDirection direction);
    private static IInputElement GetNextPrivate(IInputElement element, IInputRoot owner, NavigationDirection direction, Nullable`1<KeyDeviceType> keyDeviceType);
    public sealed virtual void Move(IInputElement element, NavigationDirection direction, KeyModifiers keyModifiers);
    private bool MovePrivate(IInputElement element, NavigationDirection direction, KeyModifiers keyModifiers, Nullable`1<KeyDeviceType> deviceType);
    [NullableContextAttribute("1")]
private void OnKeyDown(object sender, KeyEventArgs e);
    [NullableContextAttribute("1")]
private static bool HandlePreCustomNavigation(ICustomKeyboardNavigation customHandler, IInputElement element, NavigationDirection direction, IInputElement& result);
    private static bool HandlePostCustomNavigation(IInputElement element, IInputElement newElement, NavigationDirection direction, IInputElement& result);
}
public enum Avalonia.Input.KeyboardNavigationMode : Enum {
    public int value__;
    public static KeyboardNavigationMode Continue;
    public static KeyboardNavigationMode Cycle;
    public static KeyboardNavigationMode Contained;
    public static KeyboardNavigationMode Once;
    public static KeyboardNavigationMode None;
    public static KeyboardNavigationMode Local;
}
public enum Avalonia.Input.KeyDeviceType : Enum {
    public int value__;
    public static KeyDeviceType Keyboard;
    public static KeyDeviceType Gamepad;
    public static KeyDeviceType Remote;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Input.KeyEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyModifiers <KeyModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private PhysicalKey <PhysicalKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeySymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyDeviceType <KeyDeviceType>k__BackingField;
    public Key Key { get; public set; }
    public KeyModifiers KeyModifiers { get; public set; }
    public PhysicalKey PhysicalKey { get; public set; }
    public string KeySymbol { get; public set; }
    public KeyDeviceType KeyDeviceType { get; public set; }
    [CompilerGeneratedAttribute]
public Key get_Key();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Key(Key value);
    [CompilerGeneratedAttribute]
public KeyModifiers get_KeyModifiers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeyModifiers(KeyModifiers value);
    [CompilerGeneratedAttribute]
public PhysicalKey get_PhysicalKey();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PhysicalKey(PhysicalKey value);
    [CompilerGeneratedAttribute]
public string get_KeySymbol();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeySymbol(string value);
    [CompilerGeneratedAttribute]
public KeyDeviceType get_KeyDeviceType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeyDeviceType(KeyDeviceType value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Input.KeyGesture : object {
    [NullableAttribute("1")]
private static Dictionary`2<string, Key> s_keySynonyms;
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyModifiers <KeyModifiers>k__BackingField;
    public Key Key { get; }
    public KeyModifiers KeyModifiers { get; }
    public KeyGesture(Key key, KeyModifiers modifiers);
    private static KeyGesture();
    public sealed virtual bool Equals(KeyGesture other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(KeyGesture left, KeyGesture right);
    public static bool op_Inequality(KeyGesture left, KeyGesture right);
    [CompilerGeneratedAttribute]
public Key get_Key();
    [CompilerGeneratedAttribute]
public KeyModifiers get_KeyModifiers();
    [NullableContextAttribute("1")]
public static KeyGesture Parse(string gesture);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public bool Matches(KeyEventArgs keyEvent);
    [NullableContextAttribute("1")]
private static Key ParseKey(string key);
    [NullableContextAttribute("0")]
private static KeyModifiers ParseModifier(ReadOnlySpan`1<char> modifier);
    private static Key ResolveNumPadOperationKey(Key key);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <ToString>g__Plus|15_0(StringBuilder s);
}
[FlagsAttribute]
public enum Avalonia.Input.KeyModifiers : Enum {
    public int value__;
    public static KeyModifiers None;
    public static KeyModifiers Alt;
    public static KeyModifiers Control;
    public static KeyModifiers Shift;
    public static KeyModifiers Meta;
}
[FlagsAttribute]
public enum Avalonia.Input.KeyStates : Enum {
    public int value__;
    public static KeyStates None;
    public static KeyStates Down;
    public static KeyStates Toggled;
}
internal static class Avalonia.Input.KeySymbolHelper : object {
    public static bool IsAllowedAsciiKeySymbol(char c);
}
public enum Avalonia.Input.MouseButton : Enum {
    public int value__;
    public static MouseButton None;
    public static MouseButton Left;
    public static MouseButton Right;
    public static MouseButton Middle;
    public static MouseButton XButton1;
    public static MouseButton XButton2;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.MouseDevice : object {
    private int _clickCount;
    private Rect _lastClickRect;
    private ulong _lastClickTime;
    private Pointer _pointer;
    private bool _disposed;
    private MouseButton _lastMouseDownButton;
    [NullableContextAttribute("2")]
public MouseDevice(Pointer pointer);
    public sealed virtual void ProcessRawEvent(RawInputEventArgs e);
    private static int ButtonCount(PointerPointProperties props);
    private void ProcessRawEvent(RawPointerEventArgs e);
    private void LeaveWindow();
    private static PointerPointProperties CreateProperties(RawPointerEventArgs args);
    private bool MouseDown(IMouseDevice device, ulong timestamp, IInputElement root, Point p, PointerPointProperties properties, KeyModifiers inputModifiers, IInputElement hitTest);
    private bool MouseMove(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties properties, KeyModifiers inputModifiers, Lazy`1<IReadOnlyList`1<RawPointerPoint>> intermediatePoints, IInputElement hitTest);
    private bool MouseUp(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties props, KeyModifiers inputModifiers, IInputElement hitTest);
    private bool MouseWheel(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties props, Vector delta, KeyModifiers inputModifiers, IInputElement hitTest);
    private bool GestureMagnify(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties props, Vector delta, KeyModifiers inputModifiers, IInputElement hitTest);
    private bool GestureRotate(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties props, Vector delta, KeyModifiers inputModifiers, IInputElement hitTest);
    private bool GestureSwipe(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties props, Vector delta, KeyModifiers inputModifiers, IInputElement hitTest);
    public sealed virtual void Dispose();
    public sealed virtual IPointer TryGetPointer(RawPointerEventArgs ev);
    internal void PlatformCaptureLost();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Input.Navigation.TabNavigation : object {
    public static IInputElement GetNextTab(IInputElement e, bool goDownOnly);
    [NullableContextAttribute("2")]
public static IInputElement GetNextTab(IInputElement e, IInputElement container, bool goDownOnly);
    public static IInputElement GetNextTabOutside(ICustomKeyboardNavigation e);
    [NullableContextAttribute("2")]
public static IInputElement GetPrevTab(IInputElement e, IInputElement container, bool goDownOnly);
    public static IInputElement GetPrevTabOutside(ICustomKeyboardNavigation e);
    [NullableContextAttribute("2")]
private static IInputElement FocusedElement(IInputElement e);
    private static IInputElement GetFirstChild(IInputElement e);
    private static IInputElement GetLastChild(IInputElement e);
    private static IInputElement GetFirstTabInGroup(IInputElement container);
    private static IInputElement GetLastInTree(IInputElement container);
    private static IInputElement GetLastTabInGroup(IInputElement container);
    private static IInputElement GetNextInTree(IInputElement e, IInputElement container);
    private static IInputElement GetNextSibling(IInputElement e);
    [NullableContextAttribute("2")]
private static IInputElement GetNextTabInGroup(IInputElement e, IInputElement container, KeyboardNavigationMode tabbingType);
    private static IInputElement GetNextTabWithSameIndex(IInputElement e, IInputElement container);
    private static IInputElement GetNextTabWithNextIndex(IInputElement e, IInputElement container, KeyboardNavigationMode tabbingType);
    [NullableContextAttribute("2")]
private static IInputElement GetPrevTabInGroup(IInputElement e, IInputElement container, KeyboardNavigationMode tabbingType);
    private static IInputElement GetPrevTabWithSameIndex(IInputElement e, IInputElement container);
    private static IInputElement GetPrevTabWithPrevIndex(IInputElement e, IInputElement container, KeyboardNavigationMode tabbingType);
    private static IInputElement GetPreviousInTree(IInputElement e, IInputElement container);
    private static IInputElement GetPreviousSibling(IInputElement e);
    private static IInputElement GetActiveElement(IInputElement e);
    private static IInputElement GetGroupParent(IInputElement e);
    private static IInputElement GetGroupParent(IInputElement element, bool includeCurrent);
    private static IInputElement GetParent(IInputElement e);
    private static KeyboardNavigationMode GetKeyNavigationMode(IInputElement e);
    private static bool IsFocusScope(IInputElement e);
    private static bool IsGroup(IInputElement e);
    private static bool IsTabStop(IInputElement e);
    private static bool IsTabStopOrGroup(IInputElement e);
    private static bool IsVisible(IInputElement e);
    private static bool IsVisibleAndEnabled(IInputElement e);
}
internal static class Avalonia.Input.Navigation.XYFocusAlgorithms : object {
    private static double InShadowThreshold;
    private static double InShadowThresholdForSecondaryAxis;
    private static double ConeAngle;
    private static double PrimaryAxisDistanceWeight;
    private static double SecondaryAxisDistanceWeight;
    private static double PercentInManifoldShadowWeight;
    private static double PercentInShadowWeight;
    public static double GetScoreProximity(NavigationDirection direction, Rect bounds, Rect candidateBounds, double maxDistance, bool considerSecondaryAxis);
    [NullableContextAttribute("1")]
public static double GetScoreProjection(NavigationDirection direction, Rect bounds, Rect candidateBounds, XYFocusManifolds manifolds, double maxDistance);
    [NullableContextAttribute("1")]
public static void UpdateManifolds(NavigationDirection direction, Rect bounds, Rect newFocusBounds, XYFocusManifolds manifolds);
    private static double CalculateScore(double percentInShadow, double primaryAxisDistance, double secondaryAxisDistance, double percentInManifoldShadow);
    public static bool ShouldCandidateBeConsideredForRanking(Rect bounds, Rect candidateBounds, double maxDistance, NavigationDirection direction, Rect exclusionRect, bool ignoreCone);
    private static double CalculatePrimaryAxisDistance(NavigationDirection direction, Rect bounds, Rect candidateBounds);
    private static double CalculateSecondaryAxisDistance(NavigationDirection direction, Rect bounds, Rect candidateBounds);
    private static double CalculatePercentInShadow(ValueTuple`2<double, double> referenceManifold, ValueTuple`2<double, double> potentialManifold);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Input.Navigation.XYFocusOptions : object {
    [CompilerGeneratedAttribute]
private InputElement <SearchRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <ExclusionRect>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Rect> <FocusHintRectangle>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Rect> <FocusedElementBounds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<XYFocusNavigationStrategy> <NavigationStrategyOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreClipping>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCone>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyDeviceType> <KeyDeviceType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConsiderEngagement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateManifold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateManifoldsFromFocusHintRect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreOcclusivity>k__BackingField;
    public InputElement SearchRoot { get; public set; }
    public Rect ExclusionRect { get; public set; }
    public Nullable`1<Rect> FocusHintRectangle { get; public set; }
    public Nullable`1<Rect> FocusedElementBounds { get; public set; }
    public Nullable`1<XYFocusNavigationStrategy> NavigationStrategyOverride { get; public set; }
    public bool IgnoreClipping { get; public set; }
    public bool IgnoreCone { get; public set; }
    public Nullable`1<KeyDeviceType> KeyDeviceType { get; public set; }
    public bool ConsiderEngagement { get; public set; }
    public bool UpdateManifold { get; public set; }
    public bool UpdateManifoldsFromFocusHintRect { get; public set; }
    public bool IgnoreOcclusivity { get; public set; }
    [CompilerGeneratedAttribute]
public InputElement get_SearchRoot();
    [CompilerGeneratedAttribute]
public void set_SearchRoot(InputElement value);
    [CompilerGeneratedAttribute]
public Rect get_ExclusionRect();
    [CompilerGeneratedAttribute]
public void set_ExclusionRect(Rect value);
    [CompilerGeneratedAttribute]
public Nullable`1<Rect> get_FocusHintRectangle();
    [CompilerGeneratedAttribute]
public void set_FocusHintRectangle(Nullable`1<Rect> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Rect> get_FocusedElementBounds();
    [CompilerGeneratedAttribute]
public void set_FocusedElementBounds(Nullable`1<Rect> value);
    [CompilerGeneratedAttribute]
public Nullable`1<XYFocusNavigationStrategy> get_NavigationStrategyOverride();
    [CompilerGeneratedAttribute]
public void set_NavigationStrategyOverride(Nullable`1<XYFocusNavigationStrategy> value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreClipping();
    [CompilerGeneratedAttribute]
public void set_IgnoreClipping(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCone();
    [CompilerGeneratedAttribute]
public void set_IgnoreCone(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<KeyDeviceType> get_KeyDeviceType();
    [CompilerGeneratedAttribute]
public void set_KeyDeviceType(Nullable`1<KeyDeviceType> value);
    [CompilerGeneratedAttribute]
public bool get_ConsiderEngagement();
    [CompilerGeneratedAttribute]
public void set_ConsiderEngagement(bool value);
    [CompilerGeneratedAttribute]
public bool get_UpdateManifold();
    [CompilerGeneratedAttribute]
public void set_UpdateManifold(bool value);
    [CompilerGeneratedAttribute]
public bool get_UpdateManifoldsFromFocusHintRect();
    [CompilerGeneratedAttribute]
public void set_UpdateManifoldsFromFocusHintRect(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreOcclusivity();
    [CompilerGeneratedAttribute]
public void set_IgnoreOcclusivity(bool value);
}
public enum Avalonia.Input.NavigationDirection : Enum {
    public int value__;
    public static NavigationDirection Next;
    public static NavigationDirection Previous;
    public static NavigationDirection First;
    public static NavigationDirection Last;
    public static NavigationDirection Left;
    public static NavigationDirection Right;
    public static NavigationDirection Up;
    public static NavigationDirection Down;
    public static NavigationDirection PageUp;
    public static NavigationDirection PageDown;
}
[ExtensionAttribute]
public static class Avalonia.Input.NavigationDirectionExtensions : object {
    [ExtensionAttribute]
public static bool IsTab(NavigationDirection direction);
    [ExtensionAttribute]
public static bool IsDirectional(NavigationDirection direction);
    [ExtensionAttribute]
public static Nullable`1<NavigationDirection> ToNavigationDirection(Key key, KeyModifiers modifiers);
}
public enum Avalonia.Input.NavigationMethod : Enum {
    public int value__;
    public static NavigationMethod Unspecified;
    public static NavigationMethod Tab;
    public static NavigationMethod Directional;
    public static NavigationMethod Pointer;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.PenDevice : object {
    private Dictionary`2<long, Pointer> _pointers;
    private bool _releasePointerOnPenUp;
    private int _clickCount;
    private Rect _lastClickRect;
    private ulong _lastClickTime;
    private MouseButton _lastMouseDownButton;
    private bool _disposed;
    public PenDevice(bool releasePointerOnPenUp);
    public sealed virtual void ProcessRawEvent(RawInputEventArgs e);
    private void ProcessRawEvent(RawPointerEventArgs e);
    private bool PenDown(Pointer pointer, ulong timestamp, IInputElement root, Point p, PointerPointProperties properties, KeyModifiers inputModifiers, IInputElement hitTest);
    private static bool PenMove(Pointer pointer, ulong timestamp, IInputRoot root, Point p, PointerPointProperties properties, KeyModifiers inputModifiers, IInputElement hitTest, Lazy`1<IReadOnlyList`1<RawPointerPoint>> intermediatePoints);
    private bool PenUp(Pointer pointer, ulong timestamp, IInputElement root, Point p, PointerPointProperties properties, KeyModifiers inputModifiers, IInputElement hitTest);
    public sealed virtual void Dispose();
    public sealed virtual IPointer TryGetPointer(RawPointerEventArgs ev);
}
public enum Avalonia.Input.PhysicalKey : Enum {
    public int value__;
    public static PhysicalKey None;
    public static PhysicalKey Backquote;
    public static PhysicalKey Backslash;
    public static PhysicalKey BracketLeft;
    public static PhysicalKey BracketRight;
    public static PhysicalKey Comma;
    public static PhysicalKey Digit0;
    public static PhysicalKey Digit1;
    public static PhysicalKey Digit2;
    public static PhysicalKey Digit3;
    public static PhysicalKey Digit4;
    public static PhysicalKey Digit5;
    public static PhysicalKey Digit6;
    public static PhysicalKey Digit7;
    public static PhysicalKey Digit8;
    public static PhysicalKey Digit9;
    public static PhysicalKey Equal;
    public static PhysicalKey IntlBackslash;
    public static PhysicalKey IntlRo;
    public static PhysicalKey IntlYen;
    public static PhysicalKey A;
    public static PhysicalKey B;
    public static PhysicalKey C;
    public static PhysicalKey D;
    public static PhysicalKey E;
    public static PhysicalKey F;
    public static PhysicalKey G;
    public static PhysicalKey H;
    public static PhysicalKey I;
    public static PhysicalKey J;
    public static PhysicalKey K;
    public static PhysicalKey L;
    public static PhysicalKey M;
    public static PhysicalKey N;
    public static PhysicalKey O;
    public static PhysicalKey P;
    public static PhysicalKey Q;
    public static PhysicalKey R;
    public static PhysicalKey S;
    public static PhysicalKey T;
    public static PhysicalKey U;
    public static PhysicalKey V;
    public static PhysicalKey W;
    public static PhysicalKey X;
    public static PhysicalKey Y;
    public static PhysicalKey Z;
    public static PhysicalKey Minus;
    public static PhysicalKey Period;
    public static PhysicalKey Quote;
    public static PhysicalKey Semicolon;
    public static PhysicalKey Slash;
    public static PhysicalKey AltLeft;
    public static PhysicalKey AltRight;
    public static PhysicalKey Backspace;
    public static PhysicalKey CapsLock;
    public static PhysicalKey ContextMenu;
    public static PhysicalKey ControlLeft;
    public static PhysicalKey ControlRight;
    public static PhysicalKey Enter;
    public static PhysicalKey MetaLeft;
    public static PhysicalKey MetaRight;
    public static PhysicalKey ShiftLeft;
    public static PhysicalKey ShiftRight;
    public static PhysicalKey Space;
    public static PhysicalKey Tab;
    public static PhysicalKey Convert;
    public static PhysicalKey KanaMode;
    public static PhysicalKey Lang1;
    public static PhysicalKey Lang2;
    public static PhysicalKey Lang3;
    public static PhysicalKey Lang4;
    public static PhysicalKey Lang5;
    public static PhysicalKey NonConvert;
    public static PhysicalKey Delete;
    public static PhysicalKey End;
    public static PhysicalKey Help;
    public static PhysicalKey Home;
    public static PhysicalKey Insert;
    public static PhysicalKey PageDown;
    public static PhysicalKey PageUp;
    public static PhysicalKey ArrowDown;
    public static PhysicalKey ArrowLeft;
    public static PhysicalKey ArrowRight;
    public static PhysicalKey ArrowUp;
    public static PhysicalKey NumLock;
    public static PhysicalKey NumPad0;
    public static PhysicalKey NumPad1;
    public static PhysicalKey NumPad2;
    public static PhysicalKey NumPad3;
    public static PhysicalKey NumPad4;
    public static PhysicalKey NumPad5;
    public static PhysicalKey NumPad6;
    public static PhysicalKey NumPad7;
    public static PhysicalKey NumPad8;
    public static PhysicalKey NumPad9;
    public static PhysicalKey NumPadAdd;
    public static PhysicalKey NumPadClear;
    public static PhysicalKey NumPadComma;
    public static PhysicalKey NumPadDecimal;
    public static PhysicalKey NumPadDivide;
    public static PhysicalKey NumPadEnter;
    public static PhysicalKey NumPadEqual;
    public static PhysicalKey NumPadMultiply;
    public static PhysicalKey NumPadParenLeft;
    public static PhysicalKey NumPadParenRight;
    public static PhysicalKey NumPadSubtract;
    public static PhysicalKey Escape;
    public static PhysicalKey F1;
    public static PhysicalKey F2;
    public static PhysicalKey F3;
    public static PhysicalKey F4;
    public static PhysicalKey F5;
    public static PhysicalKey F6;
    public static PhysicalKey F7;
    public static PhysicalKey F8;
    public static PhysicalKey F9;
    public static PhysicalKey F10;
    public static PhysicalKey F11;
    public static PhysicalKey F12;
    public static PhysicalKey F13;
    public static PhysicalKey F14;
    public static PhysicalKey F15;
    public static PhysicalKey F16;
    public static PhysicalKey F17;
    public static PhysicalKey F18;
    public static PhysicalKey F19;
    public static PhysicalKey F20;
    public static PhysicalKey F21;
    public static PhysicalKey F22;
    public static PhysicalKey F23;
    public static PhysicalKey F24;
    public static PhysicalKey PrintScreen;
    public static PhysicalKey ScrollLock;
    public static PhysicalKey Pause;
    public static PhysicalKey BrowserBack;
    public static PhysicalKey BrowserFavorites;
    public static PhysicalKey BrowserForward;
    public static PhysicalKey BrowserHome;
    public static PhysicalKey BrowserRefresh;
    public static PhysicalKey BrowserSearch;
    public static PhysicalKey BrowserStop;
    public static PhysicalKey Eject;
    public static PhysicalKey LaunchApp1;
    public static PhysicalKey LaunchApp2;
    public static PhysicalKey LaunchMail;
    public static PhysicalKey MediaPlayPause;
    public static PhysicalKey MediaSelect;
    public static PhysicalKey MediaStop;
    public static PhysicalKey MediaTrackNext;
    public static PhysicalKey MediaTrackPrevious;
    public static PhysicalKey Power;
    public static PhysicalKey Sleep;
    public static PhysicalKey AudioVolumeDown;
    public static PhysicalKey AudioVolumeMute;
    public static PhysicalKey AudioVolumeUp;
    public static PhysicalKey WakeUp;
    public static PhysicalKey Again;
    public static PhysicalKey Copy;
    public static PhysicalKey Cut;
    public static PhysicalKey Find;
    public static PhysicalKey Open;
    public static PhysicalKey Paste;
    public static PhysicalKey Props;
    public static PhysicalKey Select;
    public static PhysicalKey Undo;
}
[ExtensionAttribute]
public static class Avalonia.Input.PhysicalKeyExtensions : object {
    [ExtensionAttribute]
public static Key ToQwertyKey(PhysicalKey physicalKey);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string ToQwertyKeySymbol(PhysicalKey physicalKey, bool useShiftModifier);
}
public class Avalonia.Input.PinchEndedEventArgs : RoutedEventArgs {
}
public class Avalonia.Input.PinchEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private double <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <ScaleOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Angle>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AngleDelta>k__BackingField;
    public double Scale { get; }
    public Point ScaleOrigin { get; }
    public double Angle { get; }
    public double AngleDelta { get; }
    public PinchEventArgs(double scale, Point scaleOrigin);
    public PinchEventArgs(double scale, Point scaleOrigin, double angle, double angleDelta);
    [CompilerGeneratedAttribute]
public double get_Scale();
    [CompilerGeneratedAttribute]
public Point get_ScaleOrigin();
    [CompilerGeneratedAttribute]
public double get_Angle();
    [CompilerGeneratedAttribute]
public double get_AngleDelta();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.PinchGestureRecognizer : GestureRecognizer {
    private float _initialDistance;
    [NullableAttribute("2")]
private IPointer _firstContact;
    private Point _firstPoint;
    [NullableAttribute("2")]
private IPointer _secondContact;
    private Point _secondPoint;
    private Point _origin;
    private double _previousAngle;
    protected virtual void PointerCaptureLost(IPointer pointer);
    protected virtual void PointerMoved(PointerEventArgs e);
    protected virtual void PointerPressed(PointerPressedEventArgs e);
    protected virtual void PointerReleased(PointerReleasedEventArgs e);
    private bool RemoveContact(IPointer pointer);
    private static float GetDistance(Point a, Point b);
    private static double GetAngleDegreeFromPoints(Point a, Point b);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Input.Platform.IClipboard {
    public abstract virtual Task`1<string> GetTextAsync();
    public abstract virtual Task SetTextAsync(string text);
    public abstract virtual Task ClearAsync();
    public abstract virtual Task SetDataObjectAsync(IDataObject data);
    public abstract virtual Task`1<String[]> GetFormatsAsync();
    public abstract virtual Task`1<object> GetDataAsync(string format);
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Input.Platform.IPlatformDragSource {
    public abstract virtual Task`1<DragDropEffects> DoDragDrop(PointerEventArgs triggerEvent, IDataObject data, DragDropEffects allowedEffects);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.Platform.KeyGestureFormatInfo : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<Key, string> <platformKeyOverrides>P;
    [CompilerGeneratedAttribute]
private static KeyGestureFormatInfo <Invariant>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Meta>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Ctrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Shift>k__BackingField;
    private static Dictionary`2<Key, string> s_commonKeyOverrides;
    public static KeyGestureFormatInfo Invariant { get; }
    public string Meta { get; }
    public string Ctrl { get; }
    public string Alt { get; }
    public string Shift { get; }
    public KeyGestureFormatInfo(IReadOnlyDictionary`2<Key, string> platformKeyOverrides, string meta, string ctrl, string alt, string shift);
    private static KeyGestureFormatInfo();
    [CompilerGeneratedAttribute]
public static KeyGestureFormatInfo get_Invariant();
    [CompilerGeneratedAttribute]
public string get_Meta();
    [CompilerGeneratedAttribute]
public string get_Ctrl();
    [CompilerGeneratedAttribute]
public string get_Alt();
    [CompilerGeneratedAttribute]
public string get_Shift();
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    public static KeyGestureFormatInfo GetInstance(IFormatProvider formatProvider);
    public string FormatKey(Key key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.Platform.PlatformHotkeyConfiguration : object {
    [CompilerGeneratedAttribute]
private KeyModifiers <CommandModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyModifiers <WholeWordTextActionModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyModifiers <SelectionModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <Copy>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <Cut>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <Paste>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <Undo>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <Redo>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <SelectAll>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <MoveCursorToTheStartOfLine>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <MoveCursorToTheEndOfLine>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <MoveCursorToTheStartOfDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <MoveCursorToTheEndOfDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <MoveCursorToTheStartOfLineWithSelection>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <MoveCursorToTheEndOfLineWithSelection>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <MoveCursorToTheStartOfDocumentWithSelection>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <MoveCursorToTheEndOfDocumentWithSelection>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <OpenContextMenu>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <Back>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <PageUp>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <PageDown>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <PageRight>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyGesture> <PageLeft>k__BackingField;
    public KeyModifiers CommandModifiers { get; public set; }
    public KeyModifiers WholeWordTextActionModifiers { get; public set; }
    public KeyModifiers SelectionModifiers { get; public set; }
    public List`1<KeyGesture> Copy { get; public set; }
    public List`1<KeyGesture> Cut { get; public set; }
    public List`1<KeyGesture> Paste { get; public set; }
    public List`1<KeyGesture> Undo { get; public set; }
    public List`1<KeyGesture> Redo { get; public set; }
    public List`1<KeyGesture> SelectAll { get; public set; }
    public List`1<KeyGesture> MoveCursorToTheStartOfLine { get; public set; }
    public List`1<KeyGesture> MoveCursorToTheEndOfLine { get; public set; }
    public List`1<KeyGesture> MoveCursorToTheStartOfDocument { get; public set; }
    public List`1<KeyGesture> MoveCursorToTheEndOfDocument { get; public set; }
    public List`1<KeyGesture> MoveCursorToTheStartOfLineWithSelection { get; public set; }
    public List`1<KeyGesture> MoveCursorToTheEndOfLineWithSelection { get; public set; }
    public List`1<KeyGesture> MoveCursorToTheStartOfDocumentWithSelection { get; public set; }
    public List`1<KeyGesture> MoveCursorToTheEndOfDocumentWithSelection { get; public set; }
    public List`1<KeyGesture> OpenContextMenu { get; public set; }
    public List`1<KeyGesture> Back { get; public set; }
    public List`1<KeyGesture> PageUp { get; public set; }
    public List`1<KeyGesture> PageDown { get; public set; }
    public List`1<KeyGesture> PageRight { get; public set; }
    public List`1<KeyGesture> PageLeft { get; public set; }
    [PrivateApiAttribute]
public PlatformHotkeyConfiguration(KeyModifiers commandModifiers, KeyModifiers selectionModifiers, KeyModifiers wholeWordTextActionModifiers);
    [CompilerGeneratedAttribute]
public KeyModifiers get_CommandModifiers();
    [CompilerGeneratedAttribute]
public void set_CommandModifiers(KeyModifiers value);
    [CompilerGeneratedAttribute]
public KeyModifiers get_WholeWordTextActionModifiers();
    [CompilerGeneratedAttribute]
public void set_WholeWordTextActionModifiers(KeyModifiers value);
    [CompilerGeneratedAttribute]
public KeyModifiers get_SelectionModifiers();
    [CompilerGeneratedAttribute]
public void set_SelectionModifiers(KeyModifiers value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_Copy();
    [CompilerGeneratedAttribute]
public void set_Copy(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_Cut();
    [CompilerGeneratedAttribute]
public void set_Cut(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_Paste();
    [CompilerGeneratedAttribute]
public void set_Paste(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_Undo();
    [CompilerGeneratedAttribute]
public void set_Undo(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_Redo();
    [CompilerGeneratedAttribute]
public void set_Redo(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_SelectAll();
    [CompilerGeneratedAttribute]
public void set_SelectAll(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_MoveCursorToTheStartOfLine();
    [CompilerGeneratedAttribute]
public void set_MoveCursorToTheStartOfLine(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_MoveCursorToTheEndOfLine();
    [CompilerGeneratedAttribute]
public void set_MoveCursorToTheEndOfLine(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_MoveCursorToTheStartOfDocument();
    [CompilerGeneratedAttribute]
public void set_MoveCursorToTheStartOfDocument(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_MoveCursorToTheEndOfDocument();
    [CompilerGeneratedAttribute]
public void set_MoveCursorToTheEndOfDocument(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_MoveCursorToTheStartOfLineWithSelection();
    [CompilerGeneratedAttribute]
public void set_MoveCursorToTheStartOfLineWithSelection(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_MoveCursorToTheEndOfLineWithSelection();
    [CompilerGeneratedAttribute]
public void set_MoveCursorToTheEndOfLineWithSelection(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_MoveCursorToTheStartOfDocumentWithSelection();
    [CompilerGeneratedAttribute]
public void set_MoveCursorToTheStartOfDocumentWithSelection(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_MoveCursorToTheEndOfDocumentWithSelection();
    [CompilerGeneratedAttribute]
public void set_MoveCursorToTheEndOfDocumentWithSelection(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_OpenContextMenu();
    [CompilerGeneratedAttribute]
public void set_OpenContextMenu(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_Back();
    [CompilerGeneratedAttribute]
public void set_Back(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_PageUp();
    [CompilerGeneratedAttribute]
public void set_PageUp(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_PageDown();
    [CompilerGeneratedAttribute]
public void set_PageDown(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_PageRight();
    [CompilerGeneratedAttribute]
public void set_PageRight(List`1<KeyGesture> value);
    [CompilerGeneratedAttribute]
public List`1<KeyGesture> get_PageLeft();
    [CompilerGeneratedAttribute]
public void set_PageLeft(List`1<KeyGesture> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Input.Pointer : object {
    private static int s_NextFreePointerId;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IInputElement <Captured>k__BackingField;
    [CompilerGeneratedAttribute]
private PointerType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrimary>k__BackingField;
    [CompilerGeneratedAttribute]
private GestureRecognizer <CapturedGestureRecognizer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGestureRecognitionSkipped>k__BackingField;
    public int Id { get; }
    public IInputElement Captured { get; private set; }
    public PointerType Type { get; }
    public bool IsPrimary { get; }
    internal GestureRecognizer CapturedGestureRecognizer { get; private set; }
    public bool IsGestureRecognitionSkipped { get; public set; }
    public Pointer(int id, PointerType type, bool isPrimary);
    private static Pointer();
    public static int GetNextFreeId();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Id();
    private static IInputElement FindCommonParent(IInputElement control1, IInputElement control2);
    protected virtual void PlatformCapture(IInputElement element);
    public sealed virtual void Capture(IInputElement control);
    [NullableContextAttribute("1")]
private static IInputElement GetNextCapture(Visual parent);
    [NullableContextAttribute("1")]
private void OnCaptureDetached(object sender, VisualTreeAttachmentEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual IInputElement get_Captured();
    [CompilerGeneratedAttribute]
private void set_Captured(IInputElement value);
    [CompilerGeneratedAttribute]
public sealed virtual PointerType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPrimary();
    [CompilerGeneratedAttribute]
internal GestureRecognizer get_CapturedGestureRecognizer();
    [CompilerGeneratedAttribute]
private void set_CapturedGestureRecognizer(GestureRecognizer value);
    [CompilerGeneratedAttribute]
public bool get_IsGestureRecognitionSkipped();
    [CompilerGeneratedAttribute]
public void set_IsGestureRecognitionSkipped(bool value);
    public sealed virtual void Dispose();
    internal void CaptureGestureRecognizer(GestureRecognizer gestureRecognizer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.PointerCaptureLostEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private IPointer <Pointer>k__BackingField;
    public IPointer Pointer { get; }
    [UnstableAttribute("This constructor might be removed in 12.0. If you need to remove capture, use stable methods on the IPointer instance.,")]
public PointerCaptureLostEventArgs(object source, IPointer pointer);
    [CompilerGeneratedAttribute]
public IPointer get_Pointer();
}
public class Avalonia.Input.PointerDeltaEventArgs : PointerEventArgs {
    [CompilerGeneratedAttribute]
private Vector <Delta>k__BackingField;
    public Vector Delta { get; }
    [NullableContextAttribute("1")]
[UnstableAttribute("This constructor might be removed in 12.0.")]
public PointerDeltaEventArgs(RoutedEvent routedEvent, object source, IPointer pointer, Visual rootVisual, Point rootVisualPosition, ulong timestamp, PointerPointProperties properties, KeyModifiers modifiers, Vector delta);
    [CompilerGeneratedAttribute]
public Vector get_Delta();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Input.PointerEventArgs : RoutedEventArgs {
    private Visual _rootVisual;
    private Point _rootVisualPosition;
    private PointerPointProperties _properties;
    private Lazy`1<IReadOnlyList`1<RawPointerPoint>> _previousPoints;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IPointer <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyModifiers <KeyModifiers>k__BackingField;
    [NullableAttribute("1")]
public IPointer Pointer { get; }
    public ulong Timestamp { get; }
    internal bool IsGestureRecognitionSkipped { get; private set; }
    public KeyModifiers KeyModifiers { get; }
    protected PointerPointProperties Properties { get; }
    [NullableContextAttribute("1")]
[UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using IHeadlessWindow mouse methods.")]
public PointerEventArgs(RoutedEvent routedEvent, object source, IPointer pointer, Visual rootVisual, Point rootVisualPosition, ulong timestamp, PointerPointProperties properties, KeyModifiers modifiers);
    internal PointerEventArgs(RoutedEvent routedEvent, object source, IPointer pointer, Visual rootVisual, Point rootVisualPosition, ulong timestamp, PointerPointProperties properties, KeyModifiers modifiers, Lazy`1<IReadOnlyList`1<RawPointerPoint>> previousPoints);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IPointer get_Pointer();
    [CompilerGeneratedAttribute]
public ulong get_Timestamp();
    internal bool get_IsGestureRecognitionSkipped();
    private void set_IsGestureRecognitionSkipped(bool value);
    [CompilerGeneratedAttribute]
public KeyModifiers get_KeyModifiers();
    private Point GetPosition(Point pt, Visual relativeTo);
    public Point GetPosition(Visual relativeTo);
    public PointerPoint GetCurrentPoint(Visual relativeTo);
    [NullableContextAttribute("1")]
public IReadOnlyList`1<PointerPoint> GetIntermediatePoints(Visual relativeTo);
    public void PreventGestureRecognition();
    protected PointerPointProperties get_Properties();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Input.PointerOverPreProcessor : object {
    [NullableAttribute("2")]
private IPointerDevice _lastActivePointerDevice;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<IPointer, PixelPoint>> _currentPointer;
    private Nullable`1<PixelPoint> _lastKnownPosition;
    private IInputRoot _inputRoot;
    public Nullable`1<PixelPoint> LastPosition { get; }
    public PointerOverPreProcessor(IInputRoot inputRoot);
    public Nullable`1<PixelPoint> get_LastPosition();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(RawInputEventArgs value);
    public void SceneInvalidated(Rect dirtyRect);
    private void ClearPointerOver();
    private void ClearPointerOver(IPointer pointer, IInputRoot root, ulong timestamp, Nullable`1<Point> position, PointerPointProperties properties, KeyModifiers inputModifiers);
    private void ClearChildrenPointerOver(PointerEventArgs e, IInputElement element, bool clearRoot);
    private void SetPointerOver(IPointer pointer, IInputRoot root, IInputElement element, ulong timestamp, Point position, PointerPointProperties properties, KeyModifiers inputModifiers);
    private void SetPointerOverToElement(IPointer pointer, IInputRoot root, IInputElement element, ulong timestamp, Point position, PointerPointProperties properties, KeyModifiers inputModifiers);
    private static IInputElement GetVisualParent(IInputElement e);
    private static Point PointToClient(IInputRoot root, PixelPoint p);
}
public class Avalonia.Input.PointerPoint : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IPointer <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
private PointerPointProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Position>k__BackingField;
    [NullableAttribute("1")]
public IPointer Pointer { get; }
    public PointerPointProperties Properties { get; }
    public Point Position { get; }
    [NullableContextAttribute("1")]
public PointerPoint(IPointer pointer, Point position, PointerPointProperties properties);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IPointer get_Pointer();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PointerPointProperties get_Properties();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Point get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PointerPoint left, PointerPoint right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PointerPoint left, PointerPoint right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PointerPoint other);
}
public class Avalonia.Input.PointerPointProperties : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsLeftButtonPressed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMiddleButtonPressed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRightButtonPressed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsXButton1Pressed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsXButton2Pressed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBarrelButtonPressed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEraser>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInverted>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Twist>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Pressure>k__BackingField;
    [CompilerGeneratedAttribute]
private float <XTilt>k__BackingField;
    [CompilerGeneratedAttribute]
private float <YTilt>k__BackingField;
    [CompilerGeneratedAttribute]
private PointerUpdateKind <PointerUpdateKind>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointerPointProperties <None>k__BackingField;
    public bool IsLeftButtonPressed { get; }
    public bool IsMiddleButtonPressed { get; }
    public bool IsRightButtonPressed { get; }
    public bool IsXButton1Pressed { get; }
    public bool IsXButton2Pressed { get; }
    public bool IsBarrelButtonPressed { get; }
    public bool IsEraser { get; }
    public bool IsInverted { get; }
    public float Twist { get; }
    public float Pressure { get; }
    public float XTilt { get; }
    public float YTilt { get; }
    public PointerUpdateKind PointerUpdateKind { get; }
    public static PointerPointProperties None { get; }
    public PointerPointProperties(RawInputModifiers modifiers, PointerUpdateKind kind);
    public PointerPointProperties(RawInputModifiers modifiers, PointerUpdateKind kind, float twist, float pressure, float xTilt, float yTilt);
    internal PointerPointProperties(RawInputModifiers modifiers, PointerUpdateKind kind, RawPointerPoint rawPoint);
    internal PointerPointProperties(PointerPointProperties basedOn, RawPointerPoint rawPoint);
    private static PointerPointProperties();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsLeftButtonPressed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsMiddleButtonPressed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsRightButtonPressed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsXButton1Pressed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsXButton2Pressed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsBarrelButtonPressed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsEraser();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsInverted();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Twist();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Pressure();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_XTilt();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_YTilt();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PointerUpdateKind get_PointerUpdateKind();
    [CompilerGeneratedAttribute]
public static PointerPointProperties get_None();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PointerPointProperties left, PointerPointProperties right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PointerPointProperties left, PointerPointProperties right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PointerPointProperties other);
}
public class Avalonia.Input.PointerPressedEventArgs : PointerEventArgs {
    [CompilerGeneratedAttribute]
private int <ClickCount>k__BackingField;
    public int ClickCount { get; }
    [NullableContextAttribute("1")]
[UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using IHeadlessWindow mouse methods.")]
public PointerPressedEventArgs(object source, IPointer pointer, Visual rootVisual, Point rootVisualPosition, ulong timestamp, PointerPointProperties properties, KeyModifiers modifiers, int clickCount);
    [CompilerGeneratedAttribute]
public int get_ClickCount();
}
public class Avalonia.Input.PointerReleasedEventArgs : PointerEventArgs {
    [CompilerGeneratedAttribute]
private MouseButton <InitialPressMouseButton>k__BackingField;
    public MouseButton InitialPressMouseButton { get; }
    [NullableContextAttribute("1")]
[UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using IHeadlessWindow mouse methods.")]
public PointerReleasedEventArgs(object source, IPointer pointer, Visual rootVisual, Point rootVisualPosition, ulong timestamp, PointerPointProperties properties, KeyModifiers modifiers, MouseButton initialPressMouseButton);
    [CompilerGeneratedAttribute]
public MouseButton get_InitialPressMouseButton();
}
public enum Avalonia.Input.PointerType : Enum {
    public int value__;
    public static PointerType Mouse;
    public static PointerType Touch;
    public static PointerType Pen;
}
public enum Avalonia.Input.PointerUpdateKind : Enum {
    public int value__;
    public static PointerUpdateKind LeftButtonPressed;
    public static PointerUpdateKind MiddleButtonPressed;
    public static PointerUpdateKind RightButtonPressed;
    public static PointerUpdateKind XButton1Pressed;
    public static PointerUpdateKind XButton2Pressed;
    public static PointerUpdateKind LeftButtonReleased;
    public static PointerUpdateKind MiddleButtonReleased;
    public static PointerUpdateKind RightButtonReleased;
    public static PointerUpdateKind XButton1Released;
    public static PointerUpdateKind XButton2Released;
    public static PointerUpdateKind Other;
}
[ExtensionAttribute]
public static class Avalonia.Input.PointerUpdateKindExtensions : object {
    [ExtensionAttribute]
public static MouseButton GetMouseButton(PointerUpdateKind kind);
}
public class Avalonia.Input.PointerWheelEventArgs : PointerEventArgs {
    [CompilerGeneratedAttribute]
private Vector <Delta>k__BackingField;
    public Vector Delta { get; }
    [NullableContextAttribute("1")]
[UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using IHeadlessWindow.MouseWheel.")]
public PointerWheelEventArgs(object source, IPointer pointer, Visual rootVisual, Point rootVisualPosition, ulong timestamp, PointerPointProperties properties, KeyModifiers modifiers, Vector delta);
    [CompilerGeneratedAttribute]
public Vector get_Delta();
}
public enum Avalonia.Input.PullDirection : Enum {
    public int value__;
    public static PullDirection TopToBottom;
    public static PullDirection BottomToTop;
    public static PullDirection LeftToRight;
    public static PullDirection RightToLeft;
}
public class Avalonia.Input.PullGestureEndedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private PullDirection <PullDirection>k__BackingField;
    public int Id { get; }
    public PullDirection PullDirection { get; }
    public PullGestureEndedEventArgs(int id, PullDirection pullDirection);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public PullDirection get_PullDirection();
}
public class Avalonia.Input.PullGestureEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private PullDirection <PullDirection>k__BackingField;
    private static int _nextId;
    public int Id { get; }
    public Vector Delta { get; }
    public PullDirection PullDirection { get; }
    public PullGestureEventArgs(int id, Vector delta, PullDirection pullDirection);
    private static PullGestureEventArgs();
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public Vector get_Delta();
    [CompilerGeneratedAttribute]
public PullDirection get_PullDirection();
    internal static int GetNextFreeId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.PullGestureRecognizer : GestureRecognizer {
    internal static int MinPullDetectionSize;
    private Point _initialPosition;
    private int _gestureId;
    [NullableAttribute("2")]
private IPointer _tracking;
    private bool _pullInProgress;
    public static StyledProperty`1<PullDirection> PullDirectionProperty;
    public PullDirection PullDirection { get; public set; }
    public PullGestureRecognizer(PullDirection pullDirection);
    private static PullGestureRecognizer();
    public PullDirection get_PullDirection();
    public void set_PullDirection(PullDirection value);
    protected virtual void PointerCaptureLost(IPointer pointer);
    protected virtual void PointerMoved(PointerEventArgs e);
    protected virtual void PointerPressed(PointerPressedEventArgs e);
    protected virtual void PointerReleased(PointerReleasedEventArgs e);
    private void EndPull();
}
[PrivateApiAttribute]
public interface Avalonia.Input.Raw.IDragDropDevice {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawDragEvent : RawInputEventArgs {
    [CompilerGeneratedAttribute]
private Point <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataObject <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private DragDropEffects <Effects>k__BackingField;
    [CompilerGeneratedAttribute]
private RawDragEventType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyModifiers <KeyModifiers>k__BackingField;
    public Point Location { get; public set; }
    public IDataObject Data { get; }
    public DragDropEffects Effects { get; public set; }
    public RawDragEventType Type { get; }
    public KeyModifiers KeyModifiers { get; }
    public RawDragEvent(IDragDropDevice inputDevice, RawDragEventType type, IInputRoot root, Point location, IDataObject data, DragDropEffects effects, RawInputModifiers modifiers);
    [CompilerGeneratedAttribute]
public Point get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(Point value);
    [CompilerGeneratedAttribute]
public IDataObject get_Data();
    [CompilerGeneratedAttribute]
public DragDropEffects get_Effects();
    [CompilerGeneratedAttribute]
public void set_Effects(DragDropEffects value);
    [CompilerGeneratedAttribute]
public RawDragEventType get_Type();
    [CompilerGeneratedAttribute]
public KeyModifiers get_KeyModifiers();
}
public enum Avalonia.Input.Raw.RawDragEventType : Enum {
    public int value__;
    public static RawDragEventType DragEnter;
    public static RawDragEventType DragOver;
    public static RawDragEventType DragLeave;
    public static RawDragEventType Drop;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawInputEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInputDevice <Device>k__BackingField;
    [CompilerGeneratedAttribute]
private IInputRoot <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Timestamp>k__BackingField;
    public IInputDevice Device { get; }
    public IInputRoot Root { get; }
    public bool Handled { get; public set; }
    public ulong Timestamp { get; public set; }
    public RawInputEventArgs(IInputDevice device, ulong timestamp, IInputRoot root);
    [CompilerGeneratedAttribute]
public IInputDevice get_Device();
    [CompilerGeneratedAttribute]
public IInputRoot get_Root();
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
    [CompilerGeneratedAttribute]
public ulong get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(ulong value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawKeyEventArgs : RawInputEventArgs {
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private RawInputModifiers <Modifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private RawKeyEventType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PhysicalKey <PhysicalKey>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyDeviceType <KeyDeviceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeySymbol>k__BackingField;
    public Key Key { get; public set; }
    public RawInputModifiers Modifiers { get; public set; }
    public RawKeyEventType Type { get; public set; }
    public PhysicalKey PhysicalKey { get; public set; }
    public KeyDeviceType KeyDeviceType { get; public set; }
    public string KeySymbol { get; public set; }
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Use the overload that takes a physical key and key symbol instead.")]
public RawKeyEventArgs(IKeyboardDevice device, ulong timestamp, IInputRoot root, RawKeyEventType type, Key key, RawInputModifiers modifiers);
    [NullableContextAttribute("1")]
public RawKeyEventArgs(IInputDevice device, ulong timestamp, IInputRoot root, RawKeyEventType type, Key key, RawInputModifiers modifiers, PhysicalKey physicalKey, string keySymbol);
    [NullableContextAttribute("1")]
public RawKeyEventArgs(IInputDevice device, ulong timestamp, IInputRoot root, RawKeyEventType type, Key key, RawInputModifiers modifiers, PhysicalKey physicalKey, KeyDeviceType keyDeviceType, string keySymbol);
    [CompilerGeneratedAttribute]
public Key get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Key value);
    [CompilerGeneratedAttribute]
public RawInputModifiers get_Modifiers();
    [CompilerGeneratedAttribute]
public void set_Modifiers(RawInputModifiers value);
    [CompilerGeneratedAttribute]
public RawKeyEventType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RawKeyEventType value);
    [CompilerGeneratedAttribute]
public PhysicalKey get_PhysicalKey();
    [CompilerGeneratedAttribute]
public void set_PhysicalKey(PhysicalKey value);
    [CompilerGeneratedAttribute]
public KeyDeviceType get_KeyDeviceType();
    [CompilerGeneratedAttribute]
public void set_KeyDeviceType(KeyDeviceType value);
    [CompilerGeneratedAttribute]
public string get_KeySymbol();
    [CompilerGeneratedAttribute]
public void set_KeySymbol(string value);
}
public enum Avalonia.Input.Raw.RawKeyEventType : Enum {
    public int value__;
    public static RawKeyEventType KeyDown;
    public static RawKeyEventType KeyUp;
}
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawMouseWheelEventArgs : RawPointerEventArgs {
    [CompilerGeneratedAttribute]
private Vector <Delta>k__BackingField;
    public Vector Delta { get; private set; }
    [NullableContextAttribute("1")]
public RawMouseWheelEventArgs(IInputDevice device, ulong timestamp, IInputRoot root, Point position, Vector delta, RawInputModifiers inputModifiers);
    [CompilerGeneratedAttribute]
public Vector get_Delta();
    [CompilerGeneratedAttribute]
private void set_Delta(Vector value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawPointerEventArgs : RawInputEventArgs {
    private RawPointerPoint _point;
    [CompilerGeneratedAttribute]
private long <RawPointerId>k__BackingField;
    [CompilerGeneratedAttribute]
private RawPointerEventType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private RawInputModifiers <InputModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<IReadOnlyList`1<RawPointerPoint>> <IntermediatePoints>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<IInputElement, IInputElement> <InputHitTestResult>k__BackingField;
    public long RawPointerId { get; public set; }
    public RawPointerPoint Point { get; public set; }
    public Point Position { get; public set; }
    public RawPointerEventType Type { get; public set; }
    public RawInputModifiers InputModifiers { get; public set; }
    public Lazy`1<IReadOnlyList`1<RawPointerPoint>> IntermediatePoints { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ValueTuple`2<IInputElement, IInputElement> InputHitTestResult { get; internal set; }
    [NullableContextAttribute("1")]
public RawPointerEventArgs(IInputDevice device, ulong timestamp, IInputRoot root, RawPointerEventType type, Point position, RawInputModifiers inputModifiers);
    [NullableContextAttribute("1")]
public RawPointerEventArgs(IInputDevice device, ulong timestamp, IInputRoot root, RawPointerEventType type, RawPointerPoint point, RawInputModifiers inputModifiers);
    [CompilerGeneratedAttribute]
public long get_RawPointerId();
    [CompilerGeneratedAttribute]
public void set_RawPointerId(long value);
    public RawPointerPoint get_Point();
    public void set_Point(RawPointerPoint value);
    public Point get_Position();
    public void set_Position(Point value);
    [CompilerGeneratedAttribute]
public RawPointerEventType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RawPointerEventType value);
    [CompilerGeneratedAttribute]
public RawInputModifiers get_InputModifiers();
    [CompilerGeneratedAttribute]
public void set_InputModifiers(RawInputModifiers value);
    [CompilerGeneratedAttribute]
public Lazy`1<IReadOnlyList`1<RawPointerPoint>> get_IntermediatePoints();
    [CompilerGeneratedAttribute]
public void set_IntermediatePoints(Lazy`1<IReadOnlyList`1<RawPointerPoint>> value);
    [CompilerGeneratedAttribute]
internal ValueTuple`2<IInputElement, IInputElement> get_InputHitTestResult();
    [CompilerGeneratedAttribute]
internal void set_InputHitTestResult(ValueTuple`2<IInputElement, IInputElement> value);
}
public enum Avalonia.Input.Raw.RawPointerEventType : Enum {
    public int value__;
    public static RawPointerEventType LeaveWindow;
    public static RawPointerEventType LeftButtonDown;
    public static RawPointerEventType LeftButtonUp;
    public static RawPointerEventType RightButtonDown;
    public static RawPointerEventType RightButtonUp;
    public static RawPointerEventType MiddleButtonDown;
    public static RawPointerEventType MiddleButtonUp;
    public static RawPointerEventType XButton1Down;
    public static RawPointerEventType XButton1Up;
    public static RawPointerEventType XButton2Down;
    public static RawPointerEventType XButton2Up;
    public static RawPointerEventType Move;
    public static RawPointerEventType Wheel;
    public static RawPointerEventType NonClientLeftButtonDown;
    public static RawPointerEventType TouchBegin;
    public static RawPointerEventType TouchUpdate;
    public static RawPointerEventType TouchEnd;
    public static RawPointerEventType TouchCancel;
    public static RawPointerEventType Magnify;
    public static RawPointerEventType Rotate;
    public static RawPointerEventType Swipe;
}
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawPointerGestureEventArgs : RawPointerEventArgs {
    [CompilerGeneratedAttribute]
private Vector <Delta>k__BackingField;
    public Vector Delta { get; private set; }
    [NullableContextAttribute("1")]
public RawPointerGestureEventArgs(IInputDevice device, ulong timestamp, IInputRoot root, RawPointerEventType gestureType, Point position, Vector delta, RawInputModifiers inputModifiers);
    [CompilerGeneratedAttribute]
public Vector get_Delta();
    [CompilerGeneratedAttribute]
private void set_Delta(Vector value);
}
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawPointerPoint : ValueType {
    [CompilerGeneratedAttribute]
private Point <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Twist>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Pressure>k__BackingField;
    [CompilerGeneratedAttribute]
private float <XTilt>k__BackingField;
    [CompilerGeneratedAttribute]
private float <YTilt>k__BackingField;
    public Point Position { get; public set; }
    public float Twist { get; public set; }
    public float Pressure { get; public set; }
    public float XTilt { get; public set; }
    public float YTilt { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Point get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(Point value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Twist();
    [CompilerGeneratedAttribute]
public void set_Twist(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Pressure();
    [CompilerGeneratedAttribute]
public void set_Pressure(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_XTilt();
    [CompilerGeneratedAttribute]
public void set_XTilt(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_YTilt();
    [CompilerGeneratedAttribute]
public void set_YTilt(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RawPointerPoint left, RawPointerPoint right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RawPointerPoint left, RawPointerPoint right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RawPointerPoint other);
}
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawSizeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    public Size Size { get; private set; }
    public RawSizeEventArgs(Size size);
    public RawSizeEventArgs(double width, double height);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(Size value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawTextInputEventArgs : RawInputEventArgs {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public RawTextInputEventArgs(IKeyboardDevice device, ulong timestamp, IInputRoot root, string text);
    [CompilerGeneratedAttribute]
public string get_Text();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Input.Raw.RawTouchEventArgs : RawPointerEventArgs {
    public RawTouchEventArgs(IInputDevice device, ulong timestamp, IInputRoot root, RawPointerEventType type, Point position, RawInputModifiers inputModifiers, long rawPointerId);
    public RawTouchEventArgs(IInputDevice device, ulong timestamp, IInputRoot root, RawPointerEventType type, RawPointerPoint point, RawInputModifiers inputModifiers, long rawPointerId);
}
[ExtensionAttribute]
internal static class Avalonia.Input.RawInputHelpers : object {
    [ExtensionAttribute]
public static KeyModifiers ToKeyModifiers(RawInputModifiers modifiers);
    [ExtensionAttribute]
public static PointerUpdateKind ToUpdateKind(RawPointerEventType type);
}
[FlagsAttribute]
public enum Avalonia.Input.RawInputModifiers : Enum {
    public int value__;
    public static RawInputModifiers None;
    public static RawInputModifiers Alt;
    public static RawInputModifiers Control;
    public static RawInputModifiers Shift;
    public static RawInputModifiers Meta;
    public static RawInputModifiers LeftMouseButton;
    public static RawInputModifiers RightMouseButton;
    public static RawInputModifiers MiddleMouseButton;
    public static RawInputModifiers XButton1MouseButton;
    public static RawInputModifiers XButton2MouseButton;
    public static RawInputModifiers KeyboardMask;
    public static RawInputModifiers PenInverted;
    public static RawInputModifiers PenEraser;
    public static RawInputModifiers PenBarrelButton;
}
public class Avalonia.Input.ScrollGestureEndedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public int Id { get; }
    public ScrollGestureEndedEventArgs(int id);
    [CompilerGeneratedAttribute]
public int get_Id();
}
public class Avalonia.Input.ScrollGestureEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldEndScrollGesture>k__BackingField;
    private static int _nextId;
    public int Id { get; }
    public Vector Delta { get; }
    public bool ShouldEndScrollGesture { get; public set; }
    public ScrollGestureEventArgs(int id, Vector delta);
    private static ScrollGestureEventArgs();
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public Vector get_Delta();
    [CompilerGeneratedAttribute]
public bool get_ShouldEndScrollGesture();
    [CompilerGeneratedAttribute]
public void set_ShouldEndScrollGesture(bool value);
    public static int GetNextFreeId();
}
public class Avalonia.Input.ScrollGestureInertiaStartingEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <Inertia>k__BackingField;
    public int Id { get; }
    public Vector Inertia { get; }
    internal ScrollGestureInertiaStartingEventArgs(int id, Vector inertia);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public Vector get_Inertia();
}
public enum Avalonia.Input.StandardCursorType : Enum {
    public int value__;
    public static StandardCursorType Arrow;
    public static StandardCursorType Ibeam;
    public static StandardCursorType Wait;
    public static StandardCursorType Cross;
    public static StandardCursorType UpArrow;
    public static StandardCursorType SizeWestEast;
    public static StandardCursorType SizeNorthSouth;
    public static StandardCursorType SizeAll;
    public static StandardCursorType No;
    public static StandardCursorType Hand;
    public static StandardCursorType AppStarting;
    public static StandardCursorType Help;
    public static StandardCursorType TopSide;
    public static StandardCursorType BottomSide;
    public static StandardCursorType LeftSide;
    public static StandardCursorType RightSide;
    public static StandardCursorType TopLeftCorner;
    public static StandardCursorType TopRightCorner;
    public static StandardCursorType BottomLeftCorner;
    public static StandardCursorType BottomRightCorner;
    public static StandardCursorType DragMove;
    public static StandardCursorType DragCopy;
    public static StandardCursorType DragLink;
    public static StandardCursorType None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.TappedEventArgs : RoutedEventArgs {
    private PointerEventArgs lastPointerEventArgs;
    public IPointer Pointer { get; }
    public KeyModifiers KeyModifiers { get; }
    public ulong Timestamp { get; }
    public TappedEventArgs(RoutedEvent routedEvent, PointerEventArgs lastPointerEventArgs);
    public IPointer get_Pointer();
    public KeyModifiers get_KeyModifiers();
    public ulong get_Timestamp();
    [NullableContextAttribute("2")]
public Point GetPosition(Visual relativeTo);
}
public enum Avalonia.Input.TextInput.ContextMenuAction : Enum {
    public int value__;
    public static ContextMenuAction Copy;
    public static ContextMenuAction Cut;
    public static ContextMenuAction Paste;
    public static ContextMenuAction SelectAll;
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Input.TextInput.ITextInputMethodImpl {
    [NullableContextAttribute("2")]
public abstract virtual void SetClient(TextInputMethodClient client);
    public abstract virtual void SetCursorRect(Rect rect);
    public abstract virtual void SetOptions(TextInputOptions options);
    public abstract virtual void Reset();
}
[NotClientImplementableAttribute]
public interface Avalonia.Input.TextInput.ITextInputMethodRoot {
    [NullableAttribute("2")]
public ITextInputMethodImpl InputMethod { get; }
    [NullableContextAttribute("2")]
public abstract virtual ITextInputMethodImpl get_InputMethod();
}
public enum Avalonia.Input.TextInput.TextInputContentType : Enum {
    public int value__;
    public static TextInputContentType Normal;
    public static TextInputContentType Alpha;
    public static TextInputContentType Digits;
    public static TextInputContentType Pin;
    public static TextInputContentType Number;
    public static TextInputContentType Email;
    public static TextInputContentType Url;
    public static TextInputContentType Name;
    public static TextInputContentType Password;
    public static TextInputContentType Social;
    public static TextInputContentType Search;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Avalonia.Input.TextInput.TextInputMethodClient : object {
    [CompilerGeneratedAttribute]
private EventHandler TextViewVisualChanged;
    [CompilerGeneratedAttribute]
private EventHandler CursorRectangleChanged;
    [CompilerGeneratedAttribute]
private EventHandler SurroundingTextChanged;
    [CompilerGeneratedAttribute]
private EventHandler SelectionChanged;
    [CompilerGeneratedAttribute]
private EventHandler ResetRequested;
    [NullableAttribute("1")]
public Visual TextViewVisual { get; }
    public bool SupportsPreedit { get; }
    public bool SupportsSurroundingText { get; }
    [NullableAttribute("1")]
public string SurroundingText { get; }
    public Rect CursorRectangle { get; }
    public TextSelection Selection { get; public set; }
    [CompilerGeneratedAttribute]
public void add_TextViewVisualChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TextViewVisualChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_CursorRectangleChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CursorRectangleChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_SurroundingTextChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SurroundingTextChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ResetRequested(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ResetRequested(EventHandler value);
    [NullableContextAttribute("1")]
public abstract virtual Visual get_TextViewVisual();
    public abstract virtual bool get_SupportsPreedit();
    public abstract virtual bool get_SupportsSurroundingText();
    [NullableContextAttribute("1")]
public abstract virtual string get_SurroundingText();
    public abstract virtual Rect get_CursorRectangle();
    public abstract virtual TextSelection get_Selection();
    public abstract virtual void set_Selection(TextSelection value);
    public virtual void SetPreeditText(string preeditText);
    public virtual void ExecuteContextMenuAction(ContextMenuAction action);
    public virtual void SetPreeditText(string preeditText, Nullable`1<int> cursorPos);
    public virtual void ShowInputPanel();
    protected virtual void RaiseTextViewVisualChanged();
    protected virtual void RaiseCursorRectangleChanged();
    protected virtual void RaiseSurroundingTextChanged();
    protected virtual void RaiseSelectionChanged();
    protected virtual void RequestReset();
}
public class Avalonia.Input.TextInput.TextInputMethodClientRequeryRequestedEventArgs : RoutedEventArgs {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private TextInputMethodClient <Client>k__BackingField;
    public TextInputMethodClient Client { get; public set; }
    [CompilerGeneratedAttribute]
public TextInputMethodClient get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(TextInputMethodClient value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Input.TextInput.TextInputMethodManager : object {
    private ITextInputMethodImpl _im;
    private IInputElement _focusedElement;
    private Interactive _visualRoot;
    private TextInputMethodClient _client;
    [NullableAttribute("1")]
private TransformTrackingHelper _transformTracker;
    private TextInputMethodClient Client { get; private set; }
    private TextInputMethodClient get_Client();
    private void set_Client(TextInputMethodClient value);
    private void PopulateImWithInitialValues();
    [NullableContextAttribute("1")]
private void OnResetRequested(object sender, EventArgs args);
    [NullableContextAttribute("1")]
private void OnIsInputMethodEnabledChanged(AvaloniaPropertyChangedEventArgs`1<bool> obj);
    [NullableContextAttribute("1")]
private void OnTextViewVisualChanged(object sender, EventArgs e);
    private void UpdateCursorRect();
    [NullableContextAttribute("1")]
private void OnCursorRectangleChanged(object sender, EventArgs e);
    public void SetFocusedElement(IInputElement element);
    [NullableContextAttribute("1")]
private void TextInputMethodClientRequeryRequested(object sender, RoutedEventArgs e);
    private void TryFindAndApplyClient();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.TextInput.TextInputOptions : object {
    public static TextInputOptions Default;
    public static AttachedProperty`1<TextInputContentType> ContentTypeProperty;
    [CompilerGeneratedAttribute]
private TextInputContentType <ContentType>k__BackingField;
    public static AttachedProperty`1<TextInputReturnKeyType> ReturnKeyTypeProperty;
    [CompilerGeneratedAttribute]
private TextInputReturnKeyType <ReturnKeyType>k__BackingField;
    public static AttachedProperty`1<bool> MultilineProperty;
    [CompilerGeneratedAttribute]
private bool <Multiline>k__BackingField;
    public static AttachedProperty`1<bool> LowercaseProperty;
    [CompilerGeneratedAttribute]
private bool <Lowercase>k__BackingField;
    public static AttachedProperty`1<bool> UppercaseProperty;
    [CompilerGeneratedAttribute]
private bool <Uppercase>k__BackingField;
    public static AttachedProperty`1<bool> AutoCapitalizationProperty;
    [CompilerGeneratedAttribute]
private bool <AutoCapitalization>k__BackingField;
    public static AttachedProperty`1<bool> IsSensitiveProperty;
    [CompilerGeneratedAttribute]
private bool <IsSensitive>k__BackingField;
    public TextInputContentType ContentType { get; public set; }
    public TextInputReturnKeyType ReturnKeyType { get; public set; }
    public bool Multiline { get; public set; }
    public bool Lowercase { get; public set; }
    public bool Uppercase { get; public set; }
    public bool AutoCapitalization { get; public set; }
    public bool IsSensitive { get; public set; }
    private static TextInputOptions();
    public static TextInputOptions FromStyledElement(StyledElement avaloniaObject);
    public static void SetContentType(StyledElement avaloniaObject, TextInputContentType value);
    public static TextInputContentType GetContentType(StyledElement avaloniaObject);
    [CompilerGeneratedAttribute]
public TextInputContentType get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(TextInputContentType value);
    public static void SetReturnKeyType(StyledElement avaloniaObject, TextInputReturnKeyType value);
    public static TextInputReturnKeyType GetReturnKeyType(StyledElement avaloniaObject);
    [CompilerGeneratedAttribute]
public TextInputReturnKeyType get_ReturnKeyType();
    [CompilerGeneratedAttribute]
public void set_ReturnKeyType(TextInputReturnKeyType value);
    public static void SetMultiline(StyledElement avaloniaObject, bool value);
    public static bool GetMultiline(StyledElement avaloniaObject);
    [CompilerGeneratedAttribute]
public bool get_Multiline();
    [CompilerGeneratedAttribute]
public void set_Multiline(bool value);
    public static void SetLowercase(StyledElement avaloniaObject, bool value);
    public static bool GetLowercase(StyledElement avaloniaObject);
    [CompilerGeneratedAttribute]
public bool get_Lowercase();
    [CompilerGeneratedAttribute]
public void set_Lowercase(bool value);
    public static void SetUppercase(StyledElement avaloniaObject, bool value);
    public static bool GetUppercase(StyledElement avaloniaObject);
    [CompilerGeneratedAttribute]
public bool get_Uppercase();
    [CompilerGeneratedAttribute]
public void set_Uppercase(bool value);
    public static void SetAutoCapitalization(StyledElement avaloniaObject, bool value);
    public static bool GetAutoCapitalization(StyledElement avaloniaObject);
    [CompilerGeneratedAttribute]
public bool get_AutoCapitalization();
    [CompilerGeneratedAttribute]
public void set_AutoCapitalization(bool value);
    public static void SetIsSensitive(StyledElement avaloniaObject, bool value);
    public static bool GetIsSensitive(StyledElement avaloniaObject);
    [CompilerGeneratedAttribute]
public bool get_IsSensitive();
    [CompilerGeneratedAttribute]
public void set_IsSensitive(bool value);
}
public enum Avalonia.Input.TextInput.TextInputReturnKeyType : Enum {
    public int value__;
    public static TextInputReturnKeyType Default;
    public static TextInputReturnKeyType Return;
    public static TextInputReturnKeyType Done;
    public static TextInputReturnKeyType Go;
    public static TextInputReturnKeyType Send;
    public static TextInputReturnKeyType Search;
    public static TextInputReturnKeyType Next;
    public static TextInputReturnKeyType Previous;
}
public class Avalonia.Input.TextInput.TextSelection : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    public int Start { get; public set; }
    public int End { get; public set; }
    public TextSelection(int Start, int End);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public void set_End(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TextSelection left, TextSelection right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TextSelection left, TextSelection right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextSelection other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Int32& Start, Int32& End);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Input.TextInput.TransformTrackingHelper : object {
    [NullableAttribute("2")]
private Visual _visual;
    private bool _queuedForUpdate;
    private EventHandler`1<AvaloniaPropertyChangedEventArgs> _propertyChangedHandler;
    private List`1<Visual> _propertyChangedSubscriptions;
    [CompilerGeneratedAttribute]
private Nullable`1<Matrix> <Matrix>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action MatrixChanged;
    public Nullable`1<Matrix> Matrix { get; private set; }
    [NullableContextAttribute("2")]
public void SetVisual(Visual visual);
    [CompilerGeneratedAttribute]
public Nullable`1<Matrix> get_Matrix();
    [CompilerGeneratedAttribute]
private void set_Matrix(Nullable`1<Matrix> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_MatrixChanged(Action value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_MatrixChanged(Action value);
    public sealed virtual void Dispose();
    private void SubscribeToParents();
    private void UnsubscribeFromParents();
    private void UpdateMatrix();
    private void OnAttachedToVisualTree(object sender, VisualTreeAttachmentEventArgs visualTreeAttachmentEventArgs);
    private void EnqueueForUpdate();
    private void PropertyChangedHandler(object sender, AvaloniaPropertyChangedEventArgs e);
    private void OnDetachedFromVisualTree(object sender, VisualTreeAttachmentEventArgs visualTreeAttachmentEventArgs);
    public static IDisposable Track(Visual visual, Action`2<Visual, Nullable`1<Matrix>> cb);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Input.TextInputEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
}
[PrivateApiAttribute]
public class Avalonia.Input.TouchDevice : object {
    [NullableAttribute("1")]
private Dictionary`2<long, Pointer> _pointers;
    private bool _disposed;
    private int _clickCount;
    private Rect _lastClickRect;
    private ulong _lastClickTime;
    private static RawInputModifiers GetModifiers(RawInputModifiers modifiers, bool isLeftButtonDown);
    [NullableContextAttribute("1")]
public sealed virtual void ProcessRawEvent(RawInputEventArgs ev);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public sealed virtual IPointer TryGetPointer(RawPointerEventArgs ev);
    internal void PlatformCaptureLost();
}
public class Avalonia.Input.VectorEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private Vector <Vector>k__BackingField;
    public Vector Vector { get; public set; }
    [CompilerGeneratedAttribute]
public Vector get_Vector();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Vector(Vector value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Input.XYFocus : object {
    private XYFocusManifolds mManifolds;
    private PooledList`1<XYFocusParams> _pooledCandidates;
    private static XYFocus _instance;
    public static AttachedProperty`1<InputElement> DownProperty;
    public static AttachedProperty`1<InputElement> LeftProperty;
    public static AttachedProperty`1<InputElement> RightProperty;
    public static AttachedProperty`1<InputElement> UpProperty;
    public static AttachedProperty`1<XYFocusNavigationStrategy> DownNavigationStrategyProperty;
    public static AttachedProperty`1<XYFocusNavigationStrategy> UpNavigationStrategyProperty;
    public static AttachedProperty`1<XYFocusNavigationStrategy> LeftNavigationStrategyProperty;
    public static AttachedProperty`1<XYFocusNavigationStrategy> RightNavigationStrategyProperty;
    public static AttachedProperty`1<XYFocusNavigationModes> NavigationModesProperty;
    internal static AttachedProperty`1<bool> IsFocusEngagementEnabledProperty;
    internal static AttachedProperty`1<bool> IsFocusEngagedProperty;
    private static XYFocus();
    [NullableContextAttribute("2")]
private static InputElement GetDirectionOverride(InputElement element, InputElement searchRoot, NavigationDirection direction, bool ignoreFocusabililty);
    [NullableContextAttribute("2")]
private static InputElement TryXYFocusBubble(InputElement element, InputElement candidate, InputElement searchRoot, NavigationDirection direction);
    [NullableContextAttribute("2")]
private static InputElement GetDirectionOverrideRoot(InputElement element, InputElement searchRoot, NavigationDirection direction);
    private static XYFocusNavigationStrategy GetStrategy(InputElement element, NavigationDirection direction, Nullable`1<XYFocusNavigationStrategy> navigationStrategyOverride);
    private static AvaloniaProperty GetXYFocusPropertyIndex(InputElement element, NavigationDirection direction);
    private static AvaloniaProperty GetXYFocusNavigationStrategyPropertyIndex(InputElement element, NavigationDirection direction);
    private static void FindElements(PooledList`1<XYFocusParams> focusList, InputElement startRoot, InputElement currentElement, InputElement activeScroller, bool ignoreClipping, Nullable`1<KeyDeviceType> inputKeyDeviceType);
    private static bool IsValidFocusSubtree(InputElement candidate);
    private static bool IsValidCandidate(InputElement candidate, Nullable`1<KeyDeviceType> inputKeyDeviceType);
    private static bool IsCandidateParticipatingInScroll(InputElement candidate, InputElement activeScroller);
    private static bool IsCandidateChildOfAncestorScroller(InputElement candidate, InputElement activeScroller);
    private static bool IsOccluded(InputElement element, Rect elementBounds);
    private static Nullable`1<Rect> GetBoundsForRanking(InputElement element, bool ignoreClipping);
    internal XYFocusManifolds ResetManifolds();
    internal void SetManifoldsFromBounds(Rect bounds);
    internal void UpdateManifolds(NavigationDirection direction, Rect elementBounds, InputElement candidate, bool ignoreClipping);
    [NullableContextAttribute("2")]
internal static InputElement TryDirectionalFocus(NavigationDirection direction, IInputElement element, IInputElement owner, InputElement engagedControl, Nullable`1<KeyDeviceType> keyDeviceType);
    [NullableContextAttribute("2")]
internal InputElement GetNextFocusableElement(NavigationDirection direction, InputElement element, InputElement engagedControl, bool updateManifolds, XYFocusOptions xyFocusOptions);
    private InputElement ChooseBestFocusableElementFromList(PooledList`1<XYFocusParams> scoreList, NavigationDirection direction, Rect bounds, bool ignoreClipping, bool ignoreOcclusivity, bool isRightToLeft, bool updateManifolds);
    [NullableContextAttribute("2")]
private void GetAllValidFocusableChildren(PooledList`1<XYFocusParams> candidateList, InputElement startRoot, NavigationDirection direction, InputElement currentElement, InputElement engagedControl, InputElement searchScope, InputElement activeScroller, bool ignoreClipping, Nullable`1<KeyDeviceType> inputKeyDeviceType);
    private void RankElements(IList`1<XYFocusParams> candidateList, NavigationDirection direction, Rect bounds, double maxRootBoundsDistance, XYFocusNavigationStrategy mode, Nullable`1<Rect> exclusionRect, bool ignoreClipping, bool ignoreCone);
    private double GetMaxRootBoundsDistance(IList`1<XYFocusParams> list, Rect bounds, NavigationDirection direction, bool ignoreClipping);
    private InputElement GetActiveScrollerForScroll(NavigationDirection direction, InputElement focusedElement);
    public static void SetDown(InputElement obj, InputElement value);
    public static InputElement GetDown(InputElement obj);
    public static void SetLeft(InputElement obj, InputElement value);
    public static InputElement GetLeft(InputElement obj);
    public static void SetRight(InputElement obj, InputElement value);
    public static InputElement GetRight(InputElement obj);
    public static void SetUp(InputElement obj, InputElement value);
    public static InputElement GetUp(InputElement obj);
    public static void SetDownNavigationStrategy(InputElement obj, XYFocusNavigationStrategy value);
    public static XYFocusNavigationStrategy GetDownNavigationStrategy(InputElement obj);
    public static void SetUpNavigationStrategy(InputElement obj, XYFocusNavigationStrategy value);
    public static XYFocusNavigationStrategy GetUpNavigationStrategy(InputElement obj);
    public static void SetLeftNavigationStrategy(InputElement obj, XYFocusNavigationStrategy value);
    public static XYFocusNavigationStrategy GetLeftNavigationStrategy(InputElement obj);
    public static void SetRightNavigationStrategy(InputElement obj, XYFocusNavigationStrategy value);
    public static XYFocusNavigationStrategy GetRightNavigationStrategy(InputElement obj);
    public static void SetNavigationModes(InputElement obj, XYFocusNavigationModes value);
    public static XYFocusNavigationModes GetNavigationModes(InputElement obj);
    internal static void SetIsFocusEngagementEnabled(InputElement obj, bool value);
    internal static bool GetIsFocusEngagementEnabled(InputElement obj);
    private static bool IsFocusEngagedCoerce(AvaloniaObject sender, bool value);
    internal static void SetIsFocusEngaged(Visual obj, bool value);
    internal static bool GetIsFocusEngaged(Visual obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Input.XYFocusHelpers : object {
    [ExtensionAttribute]
internal static bool IsAllowedXYNavigationMode(InputElement visual, Nullable`1<KeyDeviceType> keyDeviceType);
    private static bool IsAllowedXYNavigationMode(XYFocusNavigationModes modes, Nullable`1<KeyDeviceType> keyDeviceType);
    [ExtensionAttribute]
internal static InputElement FindXYSearchRoot(InputElement visual, Nullable`1<KeyDeviceType> keyDeviceType);
}
[FlagsAttribute]
public enum Avalonia.Input.XYFocusNavigationModes : Enum {
    public int value__;
    public static XYFocusNavigationModes Disabled;
    public static XYFocusNavigationModes Keyboard;
    public static XYFocusNavigationModes Gamepad;
    public static XYFocusNavigationModes Remote;
    public static XYFocusNavigationModes Enabled;
}
public enum Avalonia.Input.XYFocusNavigationStrategy : Enum {
    public int value__;
    public static XYFocusNavigationStrategy Auto;
    public static XYFocusNavigationStrategy Projection;
    public static XYFocusNavigationStrategy NavigationDirectionDistance;
    public static XYFocusNavigationStrategy RectilinearDistance;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Input.XYFocusParams : object {
    [CompilerGeneratedAttribute]
private InputElement <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Score>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public InputElement Element { get; public set; }
    public Rect Bounds { get; public set; }
    public double Score { get; public set; }
    public XYFocusParams(InputElement Element, Rect Bounds);
    [CompilerGeneratedAttribute]
protected XYFocusParams(XYFocusParams original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public InputElement get_Element();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Element(InputElement value);
    [CompilerGeneratedAttribute]
public Rect get_Bounds();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Bounds(Rect value);
    [CompilerGeneratedAttribute]
public double get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(double value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(XYFocusParams left, XYFocusParams right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(XYFocusParams left, XYFocusParams right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(XYFocusParams other);
    [CompilerGeneratedAttribute]
public virtual XYFocusParams <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(InputElement& Element, Rect& Bounds);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Interactivity.CancelRoutedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private bool <Cancel>k__BackingField;
    public bool Cancel { get; public set; }
    public CancelRoutedEventArgs(RoutedEvent routedEvent);
    public CancelRoutedEventArgs(RoutedEvent routedEvent, object source);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Interactivity.EventRoute : object {
    private RoutedEvent _event;
    [NullableAttribute("2")]
private PooledList`1<RouteItem> _route;
    public bool HasHandlers { get; }
    public EventRoute(RoutedEvent e);
    public bool get_HasHandlers();
    public void Add(Interactive target, Delegate handler, RoutingStrategies routes, bool handledEventsToo, Action`3<Delegate, object, RoutedEventArgs> adapter);
    public void AddClassHandler(Interactive target);
    public void RaiseEvent(Interactive source, RoutedEventArgs e);
    public sealed virtual void Dispose();
    private void RaiseEventImpl(RoutedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Interactivity.Interactive : Layoutable {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<RoutedEvent, List`1<EventSubscription>> _eventHandlers;
    [NullableAttribute("2")]
internal Interactive InteractiveParent { get; }
    [NullableContextAttribute("2")]
internal virtual Interactive get_InteractiveParent();
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler, RoutingStrategies routes, bool handledEventsToo);
    public void AddHandler(RoutedEvent`1<TEventArgs> routedEvent, EventHandler`1<TEventArgs> handler, RoutingStrategies routes, bool handledEventsToo);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public void RemoveHandler(RoutedEvent`1<TEventArgs> routedEvent, EventHandler`1<TEventArgs> handler);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    protected EventRoute BuildEventRoute(RoutedEvent e);
    private void AddEventSubscription(RoutedEvent routedEvent, EventSubscription subscription);
    private void AddToEventRoute(RoutedEvent routedEvent, EventRoute route);
    [CompilerGeneratedAttribute]
internal static void <AddHandler>g__InvokeAdapter|4_0(Delegate baseHandler, object sender, RoutedEventArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Interactivity.InteractiveExtensions : object {
    [ExtensionAttribute]
public static IDisposable AddDisposableHandler(Interactive o, RoutedEvent`1<TEventArgs> routedEvent, EventHandler`1<TEventArgs> handler, RoutingStrategies routes, bool handledEventsToo);
    [ExtensionAttribute]
public static Interactive GetInteractiveParent(Interactive o);
    [ExtensionAttribute]
public static IObservable`1<TEventArgs> GetObservable(Interactive o, RoutedEvent`1<TEventArgs> routedEvent, RoutingStrategies routes, bool handledEventsToo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Interactivity.RoutedEvent : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LightweightSubject`1<ValueTuple`2<object, RoutedEventArgs>> _raised;
    private LightweightSubject`1<RoutedEventArgs> _routeFinished;
    [CompilerGeneratedAttribute]
private Type <EventArgsType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OwnerType>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutingStrategies <RoutingStrategies>k__BackingField;
    public Type EventArgsType { get; }
    public string Name { get; }
    public Type OwnerType { get; }
    public RoutingStrategies RoutingStrategies { get; }
    public bool HasRaisedSubscriptions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IObservable`1<ValueTuple`2<object, RoutedEventArgs>> Raised { get; }
    public IObservable`1<RoutedEventArgs> RouteFinished { get; }
    public RoutedEvent(string name, RoutingStrategies routingStrategies, Type eventArgsType, Type ownerType);
    [CompilerGeneratedAttribute]
public Type get_EventArgsType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Type get_OwnerType();
    [CompilerGeneratedAttribute]
public RoutingStrategies get_RoutingStrategies();
    public bool get_HasRaisedSubscriptions();
    public IObservable`1<ValueTuple`2<object, RoutedEventArgs>> get_Raised();
    public IObservable`1<RoutedEventArgs> get_RouteFinished();
    public static RoutedEvent`1<TEventArgs> Register(string name, RoutingStrategies routingStrategy);
    public static RoutedEvent`1<TEventArgs> Register(string name, RoutingStrategies routingStrategy, Type ownerType);
    public IDisposable AddClassHandler(Type targetType, EventHandler`1<RoutedEventArgs> handler, RoutingStrategies routes, bool handledEventsToo);
    internal void InvokeRaised(object sender, RoutedEventArgs e);
    internal void InvokeRouteFinished(RoutedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Interactivity.RoutedEvent`1 : RoutedEvent {
    public RoutedEvent`1(string name, RoutingStrategies routingStrategies, Type ownerType);
    public IDisposable AddClassHandler(Action`2<TTarget, TEventArgs> handler, RoutingStrategies routes, bool handledEventsToo);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Interactivity.RoutedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutedEvent <RoutedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutingStrategies <Route>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    public bool Handled { get; public set; }
    public RoutedEvent RoutedEvent { get; public set; }
    public RoutingStrategies Route { get; public set; }
    public object Source { get; public set; }
    public RoutedEventArgs(RoutedEvent routedEvent);
    public RoutedEventArgs(RoutedEvent routedEvent, object source);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
    [CompilerGeneratedAttribute]
public RoutedEvent get_RoutedEvent();
    [CompilerGeneratedAttribute]
public void set_RoutedEvent(RoutedEvent value);
    [CompilerGeneratedAttribute]
public RoutingStrategies get_Route();
    [CompilerGeneratedAttribute]
public void set_Route(RoutingStrategies value);
    [CompilerGeneratedAttribute]
public object get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Interactivity.RoutedEventRegistry : object {
    private Dictionary`2<Type, List`1<RoutedEvent>> _registeredRoutedEvents;
    [CompilerGeneratedAttribute]
private static RoutedEventRegistry <Instance>k__BackingField;
    public static RoutedEventRegistry Instance { get; }
    private static RoutedEventRegistry();
    [CompilerGeneratedAttribute]
public static RoutedEventRegistry get_Instance();
    public void Register(Type type, RoutedEvent event);
    [IteratorStateMachineAttribute("Avalonia.Interactivity.RoutedEventRegistry/<GetAllRegistered>d__5")]
public IEnumerable`1<RoutedEvent> GetAllRegistered();
    public IReadOnlyList`1<RoutedEvent> GetRegistered(Type type);
    public IReadOnlyList`1<RoutedEvent> GetRegistered();
}
[FlagsAttribute]
public enum Avalonia.Interactivity.RoutingStrategies : Enum {
    public int value__;
    public static RoutingStrategies Direct;
    public static RoutingStrategies Tunnel;
    public static RoutingStrategies Bubble;
}
[NullableContextAttribute("1")]
internal interface Avalonia.IStyledPropertyAccessor {
    public abstract virtual object GetDefaultValue(Type type);
    public abstract virtual object GetDefaultValue(AvaloniaObject owner);
    [NullableContextAttribute("2")]
public abstract virtual bool ValidateValue(object value);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.IStyledPropertyMetadata {
    public object DefaultValue { get; }
    public abstract virtual object get_DefaultValue();
}
public class Avalonia.Layout.EffectiveViewportChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Rect <EffectiveViewport>k__BackingField;
    public Rect EffectiveViewport { get; }
    public EffectiveViewportChangedEventArgs(Rect effectiveViewport);
    [CompilerGeneratedAttribute]
public Rect get_EffectiveViewport();
}
public enum Avalonia.Layout.HorizontalAlignment : Enum {
    public int value__;
    public static HorizontalAlignment Stretch;
    public static HorizontalAlignment Left;
    public static HorizontalAlignment Center;
    public static HorizontalAlignment Right;
}
public interface Avalonia.Layout.IEmbeddedLayoutRoot {
    public Size AllocatedSize { get; }
    public abstract virtual Size get_AllocatedSize();
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
public interface Avalonia.Layout.ILayoutManager {
    [CompilerGeneratedAttribute]
public abstract virtual void add_LayoutUpdated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LayoutUpdated(EventHandler value);
    public abstract virtual void InvalidateMeasure(Layoutable control);
    public abstract virtual void InvalidateArrange(Layoutable control);
    public abstract virtual void ExecuteLayoutPass();
    public abstract virtual void ExecuteInitialLayoutPass();
    public abstract virtual void RegisterEffectiveViewportListener(Layoutable control);
    public abstract virtual void UnregisterEffectiveViewportListener(Layoutable control);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Layout.ILayoutRoot {
    public Size ClientSize { get; }
    public double LayoutScaling { get; }
    internal ILayoutManager LayoutManager { get; }
    public abstract virtual Size get_ClientSize();
    public abstract virtual double get_LayoutScaling();
    internal abstract virtual ILayoutManager get_LayoutManager();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Layout.Layoutable : Visual {
    public static DirectProperty`2<Layoutable, Size> DesiredSizeProperty;
    public static StyledProperty`1<double> WidthProperty;
    public static StyledProperty`1<double> HeightProperty;
    public static StyledProperty`1<double> MinWidthProperty;
    public static StyledProperty`1<double> MaxWidthProperty;
    public static StyledProperty`1<double> MinHeightProperty;
    public static StyledProperty`1<double> MaxHeightProperty;
    public static StyledProperty`1<Thickness> MarginProperty;
    public static StyledProperty`1<HorizontalAlignment> HorizontalAlignmentProperty;
    public static StyledProperty`1<VerticalAlignment> VerticalAlignmentProperty;
    public static StyledProperty`1<bool> UseLayoutRoundingProperty;
    private bool _measuring;
    private Nullable`1<Size> _previousMeasure;
    private Nullable`1<Rect> _previousArrange;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<EffectiveViewportChangedEventArgs> _effectiveViewportChanged;
    [NullableAttribute("2")]
private EventHandler _layoutUpdated;
    [CompilerGeneratedAttribute]
private Size <DesiredSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMeasureValid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArrangeValid>k__BackingField;
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double MinWidth { get; public set; }
    public double MaxWidth { get; public set; }
    public double MinHeight { get; public set; }
    public double MaxHeight { get; public set; }
    public Thickness Margin { get; public set; }
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    public VerticalAlignment VerticalAlignment { get; public set; }
    public Size DesiredSize { get; private set; }
    public bool IsMeasureValid { get; private set; }
    public bool IsArrangeValid { get; private set; }
    public bool UseLayoutRounding { get; public set; }
    internal Nullable`1<Size> PreviousMeasure { get; }
    internal Nullable`1<Rect> PreviousArrange { get; }
    private static Layoutable();
    private static bool ValidateDimension(double value);
    private static bool ValidateMinimumDimension(double value);
    private static bool ValidateMaximumDimension(double value);
    public void add_EffectiveViewportChanged(EventHandler`1<EffectiveViewportChangedEventArgs> value);
    public void remove_EffectiveViewportChanged(EventHandler`1<EffectiveViewportChangedEventArgs> value);
    [NullableContextAttribute("2")]
public void add_LayoutUpdated(EventHandler value);
    [NullableContextAttribute("2")]
public void remove_LayoutUpdated(EventHandler value);
    public void UpdateLayout();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_MinWidth();
    public void set_MinWidth(double value);
    public double get_MaxWidth();
    public void set_MaxWidth(double value);
    public double get_MinHeight();
    public void set_MinHeight(double value);
    public double get_MaxHeight();
    public void set_MaxHeight(double value);
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    public HorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(HorizontalAlignment value);
    public VerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(VerticalAlignment value);
    [CompilerGeneratedAttribute]
public Size get_DesiredSize();
    [CompilerGeneratedAttribute]
private void set_DesiredSize(Size value);
    [CompilerGeneratedAttribute]
public bool get_IsMeasureValid();
    [CompilerGeneratedAttribute]
private void set_IsMeasureValid(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsArrangeValid();
    [CompilerGeneratedAttribute]
private void set_IsArrangeValid(bool value);
    public bool get_UseLayoutRounding();
    public void set_UseLayoutRounding(bool value);
    internal Nullable`1<Size> get_PreviousMeasure();
    internal Nullable`1<Rect> get_PreviousArrange();
    public virtual void ApplyTemplate();
    public void Measure(Size availableSize);
    public void Arrange(Rect rect);
    public void InvalidateMeasure();
    public void InvalidateArrange();
    internal void ChildDesiredSizeChanged(Layoutable control);
    internal void RaiseEffectiveViewportChanged(EffectiveViewportChangedEventArgs e);
    protected static void AffectsMeasure(AvaloniaProperty[] properties);
    protected static void AffectsArrange(AvaloniaProperty[] properties);
    protected virtual Size MeasureCore(Size availableSize);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual void ArrangeCore(Rect finalRect);
    protected virtual Size ArrangeOverride(Size finalSize);
    internal sealed virtual void InvalidateStyles(bool recurse);
    protected virtual void OnAttachedToVisualTreeCore(VisualTreeAttachmentEventArgs e);
    protected virtual void OnDetachedFromVisualTreeCore(VisualTreeAttachmentEventArgs e);
    protected virtual void OnMeasureInvalidated();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    [NullableContextAttribute("2")]
protected sealed virtual void OnVisualParentChanged(Visual oldParent, Visual newParent);
    private protected virtual void OnControlThemeChanged();
    internal virtual void OnTemplatedParentControlThemeChanged();
    private void AncestorBecameVisible(ILayoutManager layoutManager);
    private void LayoutManagedLayoutUpdated(object sender, EventArgs e);
    private static bool IsInvalidRect(Rect rect);
    private static bool IsInvalidSize(Size size);
    private static Size NonNegative(Size size);
}
[ExtensionAttribute]
public static class Avalonia.Layout.LayoutExtensions : object {
    [ExtensionAttribute]
public static Rect Align(Rect rect, Rect constraint, HorizontalAlignment horizontalAlignment, VerticalAlignment verticalAlignment);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class Avalonia.Layout.LayoutHelper : object {
    [CompilerGeneratedAttribute]
private static double <LayoutEpsilon>k__BackingField;
    public static double LayoutEpsilon { get; }
    private static LayoutHelper();
    [CompilerGeneratedAttribute]
public static double get_LayoutEpsilon();
    [NullableContextAttribute("1")]
public static Size ApplyLayoutConstraints(Layoutable control, Size constraints);
    public static Size MeasureChild(Layoutable control, Size availableSize, Thickness padding, Thickness borderThickness);
    public static Size MeasureChild(Layoutable control, Size availableSize, Thickness padding);
    public static Size ArrangeChild(Layoutable child, Size availableSize, Thickness padding, Thickness borderThickness);
    public static Size ArrangeChild(Layoutable child, Size availableSize, Thickness padding);
    private static Size ArrangeChildInternal(Layoutable child, Size availableSize, Thickness padding);
    private static bool IsParentLayoutRounded(Layoutable child, Double& scale);
    [NullableContextAttribute("1")]
public static void InvalidateSelfAndChildrenMeasure(Layoutable control);
    [NullableContextAttribute("1")]
public static double GetLayoutScale(Layoutable control);
    public static Size RoundLayoutSizeUp(Size size, double dpiScaleX, double dpiScaleY);
    public static Thickness RoundLayoutThickness(Thickness thickness, double dpiScaleX, double dpiScaleY);
    public static double RoundLayoutValue(double value, double dpiScale);
    public static double RoundLayoutValueUp(double value, double dpiScale);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <InvalidateSelfAndChildrenMeasure>g__InnerInvalidateMeasure|10_0(Visual target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Layout.LayoutInformation : object {
    public static Nullable`1<Size> GetPreviousMeasureConstraint(Layoutable control);
    public static Nullable`1<Rect> GetPreviousArrangeBounds(Layoutable control);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Layout.LayoutManager : object {
    private static int MaxPasses;
    private Layoutable _owner;
    private LayoutQueue`1<Layoutable> _toMeasure;
    private LayoutQueue`1<Layoutable> _toArrange;
    private List`1<Layoutable> _toArrangeAfterMeasure;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<EffectiveViewportChangedListener> _effectiveViewportChangedListeners;
    private bool _disposed;
    private bool _queued;
    private bool _running;
    private int _totalPassCount;
    private Action _invokeOnRender;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler LayoutUpdated;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action`1<LayoutPassTiming> <LayoutPassTimed>k__BackingField;
    [NullableAttribute("2")]
internal Action`1<LayoutPassTiming> LayoutPassTimed { get; internal set; }
    public LayoutManager(ILayoutRoot owner);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void add_LayoutUpdated(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void remove_LayoutUpdated(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Action`1<LayoutPassTiming> get_LayoutPassTimed();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_LayoutPassTimed(Action`1<LayoutPassTiming> value);
    public virtual void InvalidateMeasure(Layoutable control);
    public virtual void InvalidateArrange(Layoutable control);
    internal void ExecuteQueuedLayoutPass();
    public virtual void ExecuteLayoutPass();
    public virtual void ExecuteInitialLayoutPass();
    public sealed virtual void Dispose();
    private sealed virtual override void Avalonia.Layout.ILayoutManager.RegisterEffectiveViewportListener(Layoutable control);
    private sealed virtual override void Avalonia.Layout.ILayoutManager.UnregisterEffectiveViewportListener(Layoutable control);
    private void InnerLayoutPass();
    private void ExecuteMeasurePass();
    private void ExecuteArrangePass();
    private bool Measure(Layoutable control);
    private ArrangeResult Arrange(Layoutable control);
    private void QueueLayoutPass();
    private bool RaiseEffectiveViewportChanged();
    private Rect CalculateEffectiveViewport(Visual control);
    private void CalculateEffectiveViewport(Visual target, Visual control, Rect& viewport);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Layout.LayoutQueue`1 : object {
    private Func`2<T, bool> _shouldEnqueue;
    private Queue`1<T> _inner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<T, Info<T>> _loopQueueInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<T, Info<T>>> _notFinalizedBuffer;
    private int _maxEnqueueCountPerLoop;
    public int Count { get; }
    public LayoutQueue`1(Func`2<T, bool> shouldEnqueue);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T Dequeue();
    public void Enqueue(T item);
    public void BeginLoop(int maxEnqueueCountPerLoop);
    public void EndLoop();
    public sealed virtual void Dispose();
}
public enum Avalonia.Layout.Orientation : Enum {
    public int value__;
    public static Orientation Horizontal;
    public static Orientation Vertical;
}
public enum Avalonia.Layout.VerticalAlignment : Enum {
    public int value__;
    public static VerticalAlignment Stretch;
    public static VerticalAlignment Top;
    public static VerticalAlignment Center;
    public static VerticalAlignment Bottom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[PrivateApiAttribute]
public static class Avalonia.LocatorExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T GetService(IAvaloniaDependencyResolver resolver);
    [ExtensionAttribute]
public static object GetRequiredService(IAvaloniaDependencyResolver resolver, Type t);
    [ExtensionAttribute]
public static T GetRequiredService(IAvaloniaDependencyResolver resolver);
}
[NullableContextAttribute("1")]
public interface Avalonia.Logging.ILogSink {
    public abstract virtual bool IsEnabled(LogEventLevel level, string area);
    public abstract virtual void Log(LogEventLevel level, string area, object source, string messageTemplate);
    public abstract virtual void Log(LogEventLevel level, string area, object source, string messageTemplate, Object[] propertyValues);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Logging.LogArea : object {
    public static string Property;
    public static string Binding;
    public static string Animations;
    public static string Visual;
    public static string Layout;
    public static string Control;
    public static string Platform;
    public static string Win32Platform;
    public static string X11Platform;
    public static string AndroidPlatform;
    public static string IOSPlatform;
    public static string LinuxFramebufferPlatform;
    public static string FreeDesktopPlatform;
    public static string macOSPlatform;
    public static string BrowserPlatform;
    public static string VncPlatform;
}
public enum Avalonia.Logging.LogEventLevel : Enum {
    public int value__;
    public static LogEventLevel Verbose;
    public static LogEventLevel Debug;
    public static LogEventLevel Information;
    public static LogEventLevel Warning;
    public static LogEventLevel Error;
    public static LogEventLevel Fatal;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class Avalonia.Logging.Logger : object {
    [CompilerGeneratedAttribute]
private static ILogSink <Sink>k__BackingField;
    public static ILogSink Sink { get; public set; }
    [CompilerGeneratedAttribute]
public static ILogSink get_Sink();
    [CompilerGeneratedAttribute]
public static void set_Sink(ILogSink value);
    [NullableContextAttribute("1")]
public static bool IsEnabled(LogEventLevel level, string area);
    [NullableContextAttribute("1")]
public static Nullable`1<ParametrizedLogger> TryGet(LogEventLevel level, string area);
    [NullableContextAttribute("1")]
public static bool TryGet(LogEventLevel level, string area, ParametrizedLogger& outLogger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Avalonia.Logging.ParametrizedLogger : ValueType {
    private ILogSink _sink;
    private LogEventLevel _level;
    private string _area;
    public bool IsValid { get; }
    public ParametrizedLogger(ILogSink sink, LogEventLevel level, string area);
    public bool get_IsValid();
    public void Log(object source, string messageTemplate);
    public void Log(object source, string messageTemplate, T0 propertyValue0);
    public void Log(object source, string messageTemplate, T0 propertyValue0, T1 propertyValue1);
    public void Log(object source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2);
    public void Log(object source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2, T3 propertyValue3);
    public void Log(object source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2, T3 propertyValue3, T4 propertyValue4);
    public void Log(object source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2, T3 propertyValue3, T4 propertyValue4, T5 propertyValue5);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ParametrizedLogger left, ParametrizedLogger right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ParametrizedLogger left, ParametrizedLogger right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParametrizedLogger other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Logging.TraceLogSink : object {
    private LogEventLevel _level;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<string> _areas;
    public TraceLogSink(LogEventLevel minimumLevel, IList`1<string> areas);
    public sealed virtual bool IsEnabled(LogEventLevel level, string area);
    public sealed virtual void Log(LogEventLevel level, string area, object source, string messageTemplate);
    public sealed virtual void Log(LogEventLevel level, string area, object source, string messageTemplate, Object[] propertyValues);
    [NullableContextAttribute("2")]
private static string Format(string area, string template, object source, Object[] values);
    private static string Format(string area, string template, object source, Object[] v);
    private static void FormatSource(object source, StringBuilder result);
}
public enum Avalonia.LogicalTree.ChildIndexChangedAction : Enum {
    public int value__;
    public static ChildIndexChangedAction ChildIndexChanged;
    public static ChildIndexChangedAction ChildIndexesReset;
    public static ChildIndexChangedAction TotalCountChanged;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.LogicalTree.ChildIndexChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ChildIndexChangedAction <Action>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILogical <Child>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChildIndexChangedEventArgs <ChildIndexesReset>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChildIndexChangedEventArgs <TotalCountChanged>k__BackingField;
    public ChildIndexChangedAction Action { get; }
    [NullableAttribute("2")]
public ILogical Child { get; }
    public int Index { get; }
    public static ChildIndexChangedEventArgs ChildIndexesReset { get; }
    public static ChildIndexChangedEventArgs TotalCountChanged { get; }
    public ChildIndexChangedEventArgs(ILogical child, int index);
    private ChildIndexChangedEventArgs(ChildIndexChangedAction action);
    private static ChildIndexChangedEventArgs();
    [CompilerGeneratedAttribute]
public ChildIndexChangedAction get_Action();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ILogical get_Child();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public static ChildIndexChangedEventArgs get_ChildIndexesReset();
    [CompilerGeneratedAttribute]
public static ChildIndexChangedEventArgs get_TotalCountChanged();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.LogicalTree.ControlLocator : object {
    public static IObservable`1<ILogical> Track(ILogical relativeTo, int ancestorLevel, Type ancestorType);
}
[NullableContextAttribute("1")]
public interface Avalonia.LogicalTree.IChildIndexProvider {
    public abstract virtual int GetChildIndex(ILogical child);
    public abstract virtual bool TryGetTotalCount(Int32& count);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChildIndexChanged(EventHandler`1<ChildIndexChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChildIndexChanged(EventHandler`1<ChildIndexChangedEventArgs> value);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.LogicalTree.ILogical {
    public bool IsAttachedToLogicalTree { get; }
    [NullableAttribute("2")]
public ILogical LogicalParent { get; }
    public IAvaloniaReadOnlyList`1<ILogical> LogicalChildren { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_AttachedToLogicalTree(EventHandler`1<LogicalTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AttachedToLogicalTree(EventHandler`1<LogicalTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DetachedFromLogicalTree(EventHandler`1<LogicalTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DetachedFromLogicalTree(EventHandler`1<LogicalTreeAttachmentEventArgs> value);
    public abstract virtual bool get_IsAttachedToLogicalTree();
    [NullableContextAttribute("2")]
public abstract virtual ILogical get_LogicalParent();
    public abstract virtual IAvaloniaReadOnlyList`1<ILogical> get_LogicalChildren();
    public abstract virtual void NotifyAttachedToLogicalTree(LogicalTreeAttachmentEventArgs e);
    public abstract virtual void NotifyDetachedFromLogicalTree(LogicalTreeAttachmentEventArgs e);
    public abstract virtual void NotifyResourcesChanged(ResourcesChangedEventArgs e);
}
[NotClientImplementableAttribute]
public interface Avalonia.LogicalTree.ILogicalRoot {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.LogicalTree.LogicalExtensions : object {
    [IteratorStateMachineAttribute("Avalonia.LogicalTree.LogicalExtensions/<GetLogicalAncestors>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<ILogical> GetLogicalAncestors(ILogical logical);
    [IteratorStateMachineAttribute("Avalonia.LogicalTree.LogicalExtensions/<GetSelfAndLogicalAncestors>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<ILogical> GetSelfAndLogicalAncestors(ILogical logical);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FindLogicalAncestorOfType(ILogical logical, bool includeSelf);
    [ExtensionAttribute]
public static IEnumerable`1<ILogical> GetLogicalChildren(ILogical logical);
    [IteratorStateMachineAttribute("Avalonia.LogicalTree.LogicalExtensions/<GetLogicalDescendants>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<ILogical> GetLogicalDescendants(ILogical logical);
    [IteratorStateMachineAttribute("Avalonia.LogicalTree.LogicalExtensions/<GetSelfAndLogicalDescendants>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<ILogical> GetSelfAndLogicalDescendants(ILogical logical);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FindLogicalDescendantOfType(ILogical logical, bool includeSelf);
    [ExtensionAttribute]
public static ILogical GetLogicalParent(ILogical logical);
    [ExtensionAttribute]
public static T GetLogicalParent(ILogical logical);
    [IteratorStateMachineAttribute("Avalonia.LogicalTree.LogicalExtensions/<GetLogicalSiblings>d__9")]
[ExtensionAttribute]
public static IEnumerable`1<ILogical> GetLogicalSiblings(ILogical logical);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLogicalAncestorOf(ILogical logical, ILogical target);
    private static T FindDescendantOfTypeCore(ILogical logical);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ILogicalRoot <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogical <Source>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILogical <Parent>k__BackingField;
    public ILogicalRoot Root { get; }
    public ILogical Source { get; }
    [NullableAttribute("2")]
public ILogical Parent { get; }
    public LogicalTreeAttachmentEventArgs(ILogicalRoot root, ILogical source, ILogical parent);
    [CompilerGeneratedAttribute]
public ILogicalRoot get_Root();
    [CompilerGeneratedAttribute]
public ILogical get_Source();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ILogical get_Parent();
}
[IsReadOnlyAttribute]
public class Avalonia.Matrix : ValueType {
    private double _m11;
    private double _m12;
    private double _m13;
    private double _m21;
    private double _m22;
    private double _m23;
    private double _m31;
    private double _m32;
    private double _m33;
    [CompilerGeneratedAttribute]
private static Matrix <Identity>k__BackingField;
    public static Matrix Identity { get; }
    public bool IsIdentity { get; }
    public bool HasInverse { get; }
    public double M11 { get; }
    public double M12 { get; }
    public double M13 { get; }
    public double M21 { get; }
    public double M22 { get; }
    public double M23 { get; }
    public double M31 { get; }
    public double M32 { get; }
    public double M33 { get; }
    public Matrix(double scaleX, double skewY, double skewX, double scaleY, double offsetX, double offsetY);
    public Matrix(double scaleX, double skewY, double perspX, double skewX, double scaleY, double perspY, double offsetX, double offsetY, double perspZ);
    private static Matrix();
    [CompilerGeneratedAttribute]
public static Matrix get_Identity();
    public bool get_IsIdentity();
    public bool get_HasInverse();
    public double get_M11();
    public double get_M12();
    public double get_M13();
    public double get_M21();
    public double get_M22();
    public double get_M23();
    public double get_M31();
    public double get_M32();
    public double get_M33();
    public static Matrix op_Multiply(Matrix value1, Matrix value2);
    public static Matrix op_UnaryNegation(Matrix value);
    public static bool op_Equality(Matrix value1, Matrix value2);
    public static bool op_Inequality(Matrix value1, Matrix value2);
    public static Matrix CreateRotation(double radians);
    public static Matrix CreateSkew(double xAngle, double yAngle);
    public static Matrix CreateScale(double xScale, double yScale);
    public static Matrix CreateScale(Vector scales);
    public static Matrix CreateTranslation(Vector position);
    public static Matrix CreateTranslation(double xPosition, double yPosition);
    public static double ToRadians(double angle);
    public Matrix Append(Matrix value);
    public Matrix Prepend(Matrix value);
    public double GetDeterminant();
    public Point Transform(Point p);
    public sealed virtual bool Equals(Matrix other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool ContainsPerspective();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public bool TryInvert(Matrix& inverted);
    public Matrix Invert();
    [NullableContextAttribute("1")]
public static Matrix Parse(string s);
    public static bool TryDecomposeTransform(Matrix matrix, Decomposed& decomposed);
}
public enum Avalonia.Media.AcrylicBackgroundSource : Enum {
    public int value__;
    public static AcrylicBackgroundSource None;
    public static AcrylicBackgroundSource Digger;
}
public enum Avalonia.Media.AlignmentX : Enum {
    public int value__;
    public static AlignmentX Left;
    public static AlignmentX Center;
    public static AlignmentX Right;
}
public enum Avalonia.Media.AlignmentY : Enum {
    public int value__;
    public static AlignmentY Top;
    public static AlignmentY Center;
    public static AlignmentY Bottom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.ArcSegment : PathSegment {
    public static StyledProperty`1<bool> IsLargeArcProperty;
    public static StyledProperty`1<Point> PointProperty;
    public static StyledProperty`1<double> RotationAngleProperty;
    public static StyledProperty`1<Size> SizeProperty;
    public static StyledProperty`1<SweepDirection> SweepDirectionProperty;
    public bool IsLargeArc { get; public set; }
    public Point Point { get; public set; }
    public double RotationAngle { get; public set; }
    public Size Size { get; public set; }
    public SweepDirection SweepDirection { get; public set; }
    private static ArcSegment();
    public bool get_IsLargeArc();
    public void set_IsLargeArc(bool value);
    public Point get_Point();
    public void set_Point(Point value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public Size get_Size();
    public void set_Size(Size value);
    public SweepDirection get_SweepDirection();
    public void set_SweepDirection(SweepDirection value);
    internal virtual void ApplyTo(StreamGeometryContext ctx);
    public virtual string ToString();
}
public enum Avalonia.Media.BackgroundSizing : Enum {
    public int value__;
    public static BackgroundSizing InnerBorderEdge;
    public static BackgroundSizing OuterBorderEdge;
    public static BackgroundSizing CenterBorder;
}
public enum Avalonia.Media.BaselineAlignment : Enum {
    public int value__;
    public static BaselineAlignment Top;
    public static BaselineAlignment Center;
    public static BaselineAlignment Bottom;
    public static BaselineAlignment Baseline;
    public static BaselineAlignment TextTop;
    public static BaselineAlignment TextBottom;
    public static BaselineAlignment Subscript;
    public static BaselineAlignment Superscript;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.BezierSegment : PathSegment {
    public static StyledProperty`1<Point> Point1Property;
    public static StyledProperty`1<Point> Point2Property;
    public static StyledProperty`1<Point> Point3Property;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public Point Point3 { get; public set; }
    private static BezierSegment();
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    public Point get_Point3();
    public void set_Point3(Point value);
    internal virtual void ApplyTo(StreamGeometryContext ctx);
    public virtual string ToString();
}
public class Avalonia.Media.BlurEffect : Effect {
    [NullableAttribute("1")]
public static StyledProperty`1<double> RadiusProperty;
    public double Radius { get; public set; }
    private static BlurEffect();
    public sealed virtual double get_Radius();
    public void set_Radius(double value);
    [NullableContextAttribute("1")]
public sealed virtual IImmutableEffect ToImmutable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.BoxShadow : ValueType {
    [CompilerGeneratedAttribute]
private double <OffsetX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetY>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Blur>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Spread>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInset>k__BackingField;
    private static Char[] s_Separator;
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double Blur { get; public set; }
    public double Spread { get; public set; }
    public Color Color { get; public set; }
    public bool IsInset { get; public set; }
    private static BoxShadow();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_OffsetX();
    [CompilerGeneratedAttribute]
public void set_OffsetX(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_OffsetY();
    [CompilerGeneratedAttribute]
public void set_OffsetY(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Blur();
    [CompilerGeneratedAttribute]
public void set_Blur(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Spread();
    [CompilerGeneratedAttribute]
public void set_Spread(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Color value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsInset();
    [CompilerGeneratedAttribute]
public void set_IsInset(bool value);
    public bool Equals(BoxShadow& other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal void ToString(StringBuilder sb);
    public static BoxShadow Parse(string s);
    public Rect TransformBounds(Rect& rect);
    public static bool op_Equality(BoxShadow left, BoxShadow right);
    public static bool op_Inequality(BoxShadow left, BoxShadow right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Media.BoxShadows : ValueType {
    private BoxShadow _first;
    [NullableAttribute("2")]
private BoxShadow[] _list;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    private static Char[] s_Separators;
    public int Count { get; }
    public BoxShadow Item { get; }
    public bool HasInsetShadows { get; }
    public BoxShadows(BoxShadow shadow);
    public BoxShadows(BoxShadow first, BoxShadow[] rest);
    private static BoxShadows();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Count();
    public BoxShadow get_Item(int c);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public BoxShadowsEnumerator GetEnumerator();
    public static BoxShadows Parse(string s);
    public Rect TransformBounds(Rect& rect);
    public bool get_HasInsetShadows();
    public bool Equals(BoxShadows other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(BoxShadows left, BoxShadows right);
    public static bool op_Inequality(BoxShadows left, BoxShadows right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeConverterAttribute("Avalonia.Media.BrushConverter")]
public abstract class Avalonia.Media.Brush : Animatable {
    public static StyledProperty`1<double> OpacityProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<ITransform> TransformProperty;
    public static StyledProperty`1<RelativePoint> TransformOriginProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private CompositorResourceHolder`1<ServerCompositionSimpleBrush> _resource;
    public double Opacity { get; public set; }
    [NullableAttribute("2")]
public ITransform Transform { get; public set; }
    public RelativePoint TransformOrigin { get; public set; }
    internal Func`2<Compositor, ServerCompositionSimpleBrush> Factory { get; }
    private static Brush();
    public sealed virtual double get_Opacity();
    public void set_Opacity(double value);
    [NullableContextAttribute("2")]
public sealed virtual ITransform get_Transform();
    [NullableContextAttribute("2")]
public void set_Transform(ITransform value);
    public sealed virtual RelativePoint get_TransformOrigin();
    public void set_TransformOrigin(RelativePoint value);
    public static IBrush Parse(string s);
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    private protected void RegisterForSerialization();
    private protected bool IsOnCompositor(Compositor c);
    private sealed virtual override IBrush Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource<Avalonia.Media.IBrush>.GetForCompositor(Compositor c);
    internal abstract virtual Func`2<Compositor, ServerCompositionSimpleBrush> get_Factory();
    private sealed virtual override void Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource.AddRefOnCompositor(Compositor c);
    private protected virtual void OnReferencedFromCompositor(Compositor c);
    private sealed virtual override void Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource.ReleaseOnCompositor(Compositor c);
    protected virtual void OnUnreferencedFromCompositor(Compositor c);
    private sealed virtual override SimpleServerObject Avalonia.Rendering.Composition.ICompositorSerializable.TryGetServer(Compositor c);
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
    private sealed virtual override void Avalonia.Rendering.Composition.ICompositorSerializable.SerializeChanges(Compositor c, BatchStreamWriter writer);
}
public class Avalonia.Media.BrushConverter : TypeConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    [NullableContextAttribute("2")]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Media.Brushes : object {
    public static IImmutableSolidColorBrush AliceBlue { get; }
    public static IImmutableSolidColorBrush AntiqueWhite { get; }
    public static IImmutableSolidColorBrush Aqua { get; }
    public static IImmutableSolidColorBrush Aquamarine { get; }
    public static IImmutableSolidColorBrush Azure { get; }
    public static IImmutableSolidColorBrush Beige { get; }
    public static IImmutableSolidColorBrush Bisque { get; }
    public static IImmutableSolidColorBrush Black { get; }
    public static IImmutableSolidColorBrush BlanchedAlmond { get; }
    public static IImmutableSolidColorBrush Blue { get; }
    public static IImmutableSolidColorBrush BlueViolet { get; }
    public static IImmutableSolidColorBrush Brown { get; }
    public static IImmutableSolidColorBrush BurlyWood { get; }
    public static IImmutableSolidColorBrush CadetBlue { get; }
    public static IImmutableSolidColorBrush Chartreuse { get; }
    public static IImmutableSolidColorBrush Chocolate { get; }
    public static IImmutableSolidColorBrush Coral { get; }
    public static IImmutableSolidColorBrush CornflowerBlue { get; }
    public static IImmutableSolidColorBrush Cornsilk { get; }
    public static IImmutableSolidColorBrush Crimson { get; }
    public static IImmutableSolidColorBrush Cyan { get; }
    public static IImmutableSolidColorBrush DarkBlue { get; }
    public static IImmutableSolidColorBrush DarkCyan { get; }
    public static IImmutableSolidColorBrush DarkGoldenrod { get; }
    public static IImmutableSolidColorBrush DarkGray { get; }
    public static IImmutableSolidColorBrush DarkGreen { get; }
    public static IImmutableSolidColorBrush DarkKhaki { get; }
    public static IImmutableSolidColorBrush DarkMagenta { get; }
    public static IImmutableSolidColorBrush DarkOliveGreen { get; }
    public static IImmutableSolidColorBrush DarkOrange { get; }
    public static IImmutableSolidColorBrush DarkOrchid { get; }
    public static IImmutableSolidColorBrush DarkRed { get; }
    public static IImmutableSolidColorBrush DarkSalmon { get; }
    public static IImmutableSolidColorBrush DarkSeaGreen { get; }
    public static IImmutableSolidColorBrush DarkSlateBlue { get; }
    public static IImmutableSolidColorBrush DarkSlateGray { get; }
    public static IImmutableSolidColorBrush DarkTurquoise { get; }
    public static IImmutableSolidColorBrush DarkViolet { get; }
    public static IImmutableSolidColorBrush DeepPink { get; }
    public static IImmutableSolidColorBrush DeepSkyBlue { get; }
    public static IImmutableSolidColorBrush DimGray { get; }
    public static IImmutableSolidColorBrush DodgerBlue { get; }
    public static IImmutableSolidColorBrush Firebrick { get; }
    public static IImmutableSolidColorBrush FloralWhite { get; }
    public static IImmutableSolidColorBrush ForestGreen { get; }
    public static IImmutableSolidColorBrush Fuchsia { get; }
    public static IImmutableSolidColorBrush Gainsboro { get; }
    public static IImmutableSolidColorBrush GhostWhite { get; }
    public static IImmutableSolidColorBrush Gold { get; }
    public static IImmutableSolidColorBrush Goldenrod { get; }
    public static IImmutableSolidColorBrush Gray { get; }
    public static IImmutableSolidColorBrush Green { get; }
    public static IImmutableSolidColorBrush GreenYellow { get; }
    public static IImmutableSolidColorBrush Honeydew { get; }
    public static IImmutableSolidColorBrush HotPink { get; }
    public static IImmutableSolidColorBrush IndianRed { get; }
    public static IImmutableSolidColorBrush Indigo { get; }
    public static IImmutableSolidColorBrush Ivory { get; }
    public static IImmutableSolidColorBrush Khaki { get; }
    public static IImmutableSolidColorBrush Lavender { get; }
    public static IImmutableSolidColorBrush LavenderBlush { get; }
    public static IImmutableSolidColorBrush LawnGreen { get; }
    public static IImmutableSolidColorBrush LemonChiffon { get; }
    public static IImmutableSolidColorBrush LightBlue { get; }
    public static IImmutableSolidColorBrush LightCoral { get; }
    public static IImmutableSolidColorBrush LightCyan { get; }
    public static IImmutableSolidColorBrush LightGoldenrodYellow { get; }
    public static IImmutableSolidColorBrush LightGray { get; }
    public static IImmutableSolidColorBrush LightGreen { get; }
    public static IImmutableSolidColorBrush LightPink { get; }
    public static IImmutableSolidColorBrush LightSalmon { get; }
    public static IImmutableSolidColorBrush LightSeaGreen { get; }
    public static IImmutableSolidColorBrush LightSkyBlue { get; }
    public static IImmutableSolidColorBrush LightSlateGray { get; }
    public static IImmutableSolidColorBrush LightSteelBlue { get; }
    public static IImmutableSolidColorBrush LightYellow { get; }
    public static IImmutableSolidColorBrush Lime { get; }
    public static IImmutableSolidColorBrush LimeGreen { get; }
    public static IImmutableSolidColorBrush Linen { get; }
    public static IImmutableSolidColorBrush Magenta { get; }
    public static IImmutableSolidColorBrush Maroon { get; }
    public static IImmutableSolidColorBrush MediumAquamarine { get; }
    public static IImmutableSolidColorBrush MediumBlue { get; }
    public static IImmutableSolidColorBrush MediumOrchid { get; }
    public static IImmutableSolidColorBrush MediumPurple { get; }
    public static IImmutableSolidColorBrush MediumSeaGreen { get; }
    public static IImmutableSolidColorBrush MediumSlateBlue { get; }
    public static IImmutableSolidColorBrush MediumSpringGreen { get; }
    public static IImmutableSolidColorBrush MediumTurquoise { get; }
    public static IImmutableSolidColorBrush MediumVioletRed { get; }
    public static IImmutableSolidColorBrush MidnightBlue { get; }
    public static IImmutableSolidColorBrush MintCream { get; }
    public static IImmutableSolidColorBrush MistyRose { get; }
    public static IImmutableSolidColorBrush Moccasin { get; }
    public static IImmutableSolidColorBrush NavajoWhite { get; }
    public static IImmutableSolidColorBrush Navy { get; }
    public static IImmutableSolidColorBrush OldLace { get; }
    public static IImmutableSolidColorBrush Olive { get; }
    public static IImmutableSolidColorBrush OliveDrab { get; }
    public static IImmutableSolidColorBrush Orange { get; }
    public static IImmutableSolidColorBrush OrangeRed { get; }
    public static IImmutableSolidColorBrush Orchid { get; }
    public static IImmutableSolidColorBrush PaleGoldenrod { get; }
    public static IImmutableSolidColorBrush PaleGreen { get; }
    public static IImmutableSolidColorBrush PaleTurquoise { get; }
    public static IImmutableSolidColorBrush PaleVioletRed { get; }
    public static IImmutableSolidColorBrush PapayaWhip { get; }
    public static IImmutableSolidColorBrush PeachPuff { get; }
    public static IImmutableSolidColorBrush Peru { get; }
    public static IImmutableSolidColorBrush Pink { get; }
    public static IImmutableSolidColorBrush Plum { get; }
    public static IImmutableSolidColorBrush PowderBlue { get; }
    public static IImmutableSolidColorBrush Purple { get; }
    public static IImmutableSolidColorBrush Red { get; }
    public static IImmutableSolidColorBrush RosyBrown { get; }
    public static IImmutableSolidColorBrush RoyalBlue { get; }
    public static IImmutableSolidColorBrush SaddleBrown { get; }
    public static IImmutableSolidColorBrush Salmon { get; }
    public static IImmutableSolidColorBrush SandyBrown { get; }
    public static IImmutableSolidColorBrush SeaGreen { get; }
    public static IImmutableSolidColorBrush SeaShell { get; }
    public static IImmutableSolidColorBrush Sienna { get; }
    public static IImmutableSolidColorBrush Silver { get; }
    public static IImmutableSolidColorBrush SkyBlue { get; }
    public static IImmutableSolidColorBrush SlateBlue { get; }
    public static IImmutableSolidColorBrush SlateGray { get; }
    public static IImmutableSolidColorBrush Snow { get; }
    public static IImmutableSolidColorBrush SpringGreen { get; }
    public static IImmutableSolidColorBrush SteelBlue { get; }
    public static IImmutableSolidColorBrush Tan { get; }
    public static IImmutableSolidColorBrush Teal { get; }
    public static IImmutableSolidColorBrush Thistle { get; }
    public static IImmutableSolidColorBrush Tomato { get; }
    public static IImmutableSolidColorBrush Transparent { get; }
    public static IImmutableSolidColorBrush Turquoise { get; }
    public static IImmutableSolidColorBrush Violet { get; }
    public static IImmutableSolidColorBrush Wheat { get; }
    public static IImmutableSolidColorBrush White { get; }
    public static IImmutableSolidColorBrush WhiteSmoke { get; }
    public static IImmutableSolidColorBrush Yellow { get; }
    public static IImmutableSolidColorBrush YellowGreen { get; }
    public static IImmutableSolidColorBrush get_AliceBlue();
    public static IImmutableSolidColorBrush get_AntiqueWhite();
    public static IImmutableSolidColorBrush get_Aqua();
    public static IImmutableSolidColorBrush get_Aquamarine();
    public static IImmutableSolidColorBrush get_Azure();
    public static IImmutableSolidColorBrush get_Beige();
    public static IImmutableSolidColorBrush get_Bisque();
    public static IImmutableSolidColorBrush get_Black();
    public static IImmutableSolidColorBrush get_BlanchedAlmond();
    public static IImmutableSolidColorBrush get_Blue();
    public static IImmutableSolidColorBrush get_BlueViolet();
    public static IImmutableSolidColorBrush get_Brown();
    public static IImmutableSolidColorBrush get_BurlyWood();
    public static IImmutableSolidColorBrush get_CadetBlue();
    public static IImmutableSolidColorBrush get_Chartreuse();
    public static IImmutableSolidColorBrush get_Chocolate();
    public static IImmutableSolidColorBrush get_Coral();
    public static IImmutableSolidColorBrush get_CornflowerBlue();
    public static IImmutableSolidColorBrush get_Cornsilk();
    public static IImmutableSolidColorBrush get_Crimson();
    public static IImmutableSolidColorBrush get_Cyan();
    public static IImmutableSolidColorBrush get_DarkBlue();
    public static IImmutableSolidColorBrush get_DarkCyan();
    public static IImmutableSolidColorBrush get_DarkGoldenrod();
    public static IImmutableSolidColorBrush get_DarkGray();
    public static IImmutableSolidColorBrush get_DarkGreen();
    public static IImmutableSolidColorBrush get_DarkKhaki();
    public static IImmutableSolidColorBrush get_DarkMagenta();
    public static IImmutableSolidColorBrush get_DarkOliveGreen();
    public static IImmutableSolidColorBrush get_DarkOrange();
    public static IImmutableSolidColorBrush get_DarkOrchid();
    public static IImmutableSolidColorBrush get_DarkRed();
    public static IImmutableSolidColorBrush get_DarkSalmon();
    public static IImmutableSolidColorBrush get_DarkSeaGreen();
    public static IImmutableSolidColorBrush get_DarkSlateBlue();
    public static IImmutableSolidColorBrush get_DarkSlateGray();
    public static IImmutableSolidColorBrush get_DarkTurquoise();
    public static IImmutableSolidColorBrush get_DarkViolet();
    public static IImmutableSolidColorBrush get_DeepPink();
    public static IImmutableSolidColorBrush get_DeepSkyBlue();
    public static IImmutableSolidColorBrush get_DimGray();
    public static IImmutableSolidColorBrush get_DodgerBlue();
    public static IImmutableSolidColorBrush get_Firebrick();
    public static IImmutableSolidColorBrush get_FloralWhite();
    public static IImmutableSolidColorBrush get_ForestGreen();
    public static IImmutableSolidColorBrush get_Fuchsia();
    public static IImmutableSolidColorBrush get_Gainsboro();
    public static IImmutableSolidColorBrush get_GhostWhite();
    public static IImmutableSolidColorBrush get_Gold();
    public static IImmutableSolidColorBrush get_Goldenrod();
    public static IImmutableSolidColorBrush get_Gray();
    public static IImmutableSolidColorBrush get_Green();
    public static IImmutableSolidColorBrush get_GreenYellow();
    public static IImmutableSolidColorBrush get_Honeydew();
    public static IImmutableSolidColorBrush get_HotPink();
    public static IImmutableSolidColorBrush get_IndianRed();
    public static IImmutableSolidColorBrush get_Indigo();
    public static IImmutableSolidColorBrush get_Ivory();
    public static IImmutableSolidColorBrush get_Khaki();
    public static IImmutableSolidColorBrush get_Lavender();
    public static IImmutableSolidColorBrush get_LavenderBlush();
    public static IImmutableSolidColorBrush get_LawnGreen();
    public static IImmutableSolidColorBrush get_LemonChiffon();
    public static IImmutableSolidColorBrush get_LightBlue();
    public static IImmutableSolidColorBrush get_LightCoral();
    public static IImmutableSolidColorBrush get_LightCyan();
    public static IImmutableSolidColorBrush get_LightGoldenrodYellow();
    public static IImmutableSolidColorBrush get_LightGray();
    public static IImmutableSolidColorBrush get_LightGreen();
    public static IImmutableSolidColorBrush get_LightPink();
    public static IImmutableSolidColorBrush get_LightSalmon();
    public static IImmutableSolidColorBrush get_LightSeaGreen();
    public static IImmutableSolidColorBrush get_LightSkyBlue();
    public static IImmutableSolidColorBrush get_LightSlateGray();
    public static IImmutableSolidColorBrush get_LightSteelBlue();
    public static IImmutableSolidColorBrush get_LightYellow();
    public static IImmutableSolidColorBrush get_Lime();
    public static IImmutableSolidColorBrush get_LimeGreen();
    public static IImmutableSolidColorBrush get_Linen();
    public static IImmutableSolidColorBrush get_Magenta();
    public static IImmutableSolidColorBrush get_Maroon();
    public static IImmutableSolidColorBrush get_MediumAquamarine();
    public static IImmutableSolidColorBrush get_MediumBlue();
    public static IImmutableSolidColorBrush get_MediumOrchid();
    public static IImmutableSolidColorBrush get_MediumPurple();
    public static IImmutableSolidColorBrush get_MediumSeaGreen();
    public static IImmutableSolidColorBrush get_MediumSlateBlue();
    public static IImmutableSolidColorBrush get_MediumSpringGreen();
    public static IImmutableSolidColorBrush get_MediumTurquoise();
    public static IImmutableSolidColorBrush get_MediumVioletRed();
    public static IImmutableSolidColorBrush get_MidnightBlue();
    public static IImmutableSolidColorBrush get_MintCream();
    public static IImmutableSolidColorBrush get_MistyRose();
    public static IImmutableSolidColorBrush get_Moccasin();
    public static IImmutableSolidColorBrush get_NavajoWhite();
    public static IImmutableSolidColorBrush get_Navy();
    public static IImmutableSolidColorBrush get_OldLace();
    public static IImmutableSolidColorBrush get_Olive();
    public static IImmutableSolidColorBrush get_OliveDrab();
    public static IImmutableSolidColorBrush get_Orange();
    public static IImmutableSolidColorBrush get_OrangeRed();
    public static IImmutableSolidColorBrush get_Orchid();
    public static IImmutableSolidColorBrush get_PaleGoldenrod();
    public static IImmutableSolidColorBrush get_PaleGreen();
    public static IImmutableSolidColorBrush get_PaleTurquoise();
    public static IImmutableSolidColorBrush get_PaleVioletRed();
    public static IImmutableSolidColorBrush get_PapayaWhip();
    public static IImmutableSolidColorBrush get_PeachPuff();
    public static IImmutableSolidColorBrush get_Peru();
    public static IImmutableSolidColorBrush get_Pink();
    public static IImmutableSolidColorBrush get_Plum();
    public static IImmutableSolidColorBrush get_PowderBlue();
    public static IImmutableSolidColorBrush get_Purple();
    public static IImmutableSolidColorBrush get_Red();
    public static IImmutableSolidColorBrush get_RosyBrown();
    public static IImmutableSolidColorBrush get_RoyalBlue();
    public static IImmutableSolidColorBrush get_SaddleBrown();
    public static IImmutableSolidColorBrush get_Salmon();
    public static IImmutableSolidColorBrush get_SandyBrown();
    public static IImmutableSolidColorBrush get_SeaGreen();
    public static IImmutableSolidColorBrush get_SeaShell();
    public static IImmutableSolidColorBrush get_Sienna();
    public static IImmutableSolidColorBrush get_Silver();
    public static IImmutableSolidColorBrush get_SkyBlue();
    public static IImmutableSolidColorBrush get_SlateBlue();
    public static IImmutableSolidColorBrush get_SlateGray();
    public static IImmutableSolidColorBrush get_Snow();
    public static IImmutableSolidColorBrush get_SpringGreen();
    public static IImmutableSolidColorBrush get_SteelBlue();
    public static IImmutableSolidColorBrush get_Tan();
    public static IImmutableSolidColorBrush get_Teal();
    public static IImmutableSolidColorBrush get_Thistle();
    public static IImmutableSolidColorBrush get_Tomato();
    public static IImmutableSolidColorBrush get_Transparent();
    public static IImmutableSolidColorBrush get_Turquoise();
    public static IImmutableSolidColorBrush get_Violet();
    public static IImmutableSolidColorBrush get_Wheat();
    public static IImmutableSolidColorBrush get_White();
    public static IImmutableSolidColorBrush get_WhiteSmoke();
    public static IImmutableSolidColorBrush get_Yellow();
    public static IImmutableSolidColorBrush get_YellowGreen();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Media.BrushExtensions : object {
    [ExtensionAttribute]
public static IImmutableBrush ToImmutable(IBrush brush);
    [ExtensionAttribute]
public static ImmutableDashStyle ToImmutable(IDashStyle style);
    [ExtensionAttribute]
public static ImmutablePen ToImmutable(IPen pen);
}
public enum Avalonia.Media.BrushMappingMode : Enum {
    public int value__;
    public static BrushMappingMode Absolute;
    public static BrushMappingMode RelativeToBoundingBox;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("CharacterHit({FirstCharacterIndex}, {TrailingLength})")]
public class Avalonia.Media.CharacterHit : ValueType {
    [CompilerGeneratedAttribute]
private int <FirstCharacterIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TrailingLength>k__BackingField;
    public int FirstCharacterIndex { get; }
    public int TrailingLength { get; }
    [DebuggerStepThroughAttribute]
public CharacterHit(int firstCharacterIndex, int trailingLength);
    [CompilerGeneratedAttribute]
public int get_FirstCharacterIndex();
    [CompilerGeneratedAttribute]
public int get_TrailingLength();
    public sealed virtual bool Equals(CharacterHit other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CharacterHit left, CharacterHit right);
    public static bool op_Inequality(CharacterHit left, CharacterHit right);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.Color : ValueType {
    private static double byteToDouble;
    [CompilerGeneratedAttribute]
private byte <A>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <R>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <G>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <B>k__BackingField;
    public byte A { get; }
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }
    public Color(byte a, byte r, byte g, byte b);
    [CompilerGeneratedAttribute]
public byte get_A();
    [CompilerGeneratedAttribute]
public byte get_R();
    [CompilerGeneratedAttribute]
public byte get_G();
    [CompilerGeneratedAttribute]
public byte get_B();
    public static Color FromArgb(byte a, byte r, byte g, byte b);
    public static Color FromRgb(byte r, byte g, byte b);
    public static Color FromUInt32(UInt32 value);
    [NullableContextAttribute("1")]
public static Color Parse(string s);
    public static Color Parse(ReadOnlySpan`1<char> s);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Color& color);
    public static bool TryParse(ReadOnlySpan`1<char> s, Color& color);
    private static bool TryParseHexFormat(ReadOnlySpan`1<char> s, Color& color);
    [NullableContextAttribute("2")]
private static bool TryParseCssFormat(string s, Color& color);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal void ToString(StringBuilder builder);
    public UInt32 ToUInt32();
    [ObsoleteAttribute("Use Color.ToUInt32() instead.")]
[EditorBrowsableAttribute("1")]
public UInt32 ToUint32();
    public HslColor ToHsl();
    public HsvColor ToHsv();
    public sealed virtual bool Equals(Color other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static HslColor ToHsl(byte red, byte green, byte blue, byte alpha);
    internal static HslColor ToHsl(double r, double g, double b, double a);
    public static HsvColor ToHsv(byte red, byte green, byte blue, byte alpha);
    internal static HsvColor ToHsv(double r, double g, double b, double a);
    public static bool op_Equality(Color left, Color right);
    public static bool op_Inequality(Color left, Color right);
    [CompilerGeneratedAttribute]
internal static bool <TryParseHexFormat>g__TryParseCore|21_0(ReadOnlySpan`1<char> input, Color& color);
    [CompilerGeneratedAttribute]
internal static bool <TryParseCssFormat>g__InternalTryParseByte|22_0(ReadOnlySpan`1<char> inString, Byte& outByte);
    [CompilerGeneratedAttribute]
internal static bool <TryParseCssFormat>g__InternalTryParseDouble|22_1(ReadOnlySpan`1<char> inString, Double& outDouble);
}
public class Avalonia.Media.Colors : object {
    public static Color AliceBlue { get; }
    public static Color AntiqueWhite { get; }
    public static Color Aqua { get; }
    public static Color Aquamarine { get; }
    public static Color Azure { get; }
    public static Color Beige { get; }
    public static Color Bisque { get; }
    public static Color Black { get; }
    public static Color BlanchedAlmond { get; }
    public static Color Blue { get; }
    public static Color BlueViolet { get; }
    public static Color Brown { get; }
    public static Color BurlyWood { get; }
    public static Color CadetBlue { get; }
    public static Color Chartreuse { get; }
    public static Color Chocolate { get; }
    public static Color Coral { get; }
    public static Color CornflowerBlue { get; }
    public static Color Cornsilk { get; }
    public static Color Crimson { get; }
    public static Color Cyan { get; }
    public static Color DarkBlue { get; }
    public static Color DarkCyan { get; }
    public static Color DarkGoldenrod { get; }
    public static Color DarkGray { get; }
    public static Color DarkGreen { get; }
    public static Color DarkKhaki { get; }
    public static Color DarkMagenta { get; }
    public static Color DarkOliveGreen { get; }
    public static Color DarkOrange { get; }
    public static Color DarkOrchid { get; }
    public static Color DarkRed { get; }
    public static Color DarkSalmon { get; }
    public static Color DarkSeaGreen { get; }
    public static Color DarkSlateBlue { get; }
    public static Color DarkSlateGray { get; }
    public static Color DarkTurquoise { get; }
    public static Color DarkViolet { get; }
    public static Color DeepPink { get; }
    public static Color DeepSkyBlue { get; }
    public static Color DimGray { get; }
    public static Color DodgerBlue { get; }
    public static Color Firebrick { get; }
    public static Color FloralWhite { get; }
    public static Color ForestGreen { get; }
    public static Color Fuchsia { get; }
    public static Color Gainsboro { get; }
    public static Color GhostWhite { get; }
    public static Color Gold { get; }
    public static Color Goldenrod { get; }
    public static Color Gray { get; }
    public static Color Green { get; }
    public static Color GreenYellow { get; }
    public static Color Honeydew { get; }
    public static Color HotPink { get; }
    public static Color IndianRed { get; }
    public static Color Indigo { get; }
    public static Color Ivory { get; }
    public static Color Khaki { get; }
    public static Color Lavender { get; }
    public static Color LavenderBlush { get; }
    public static Color LawnGreen { get; }
    public static Color LemonChiffon { get; }
    public static Color LightBlue { get; }
    public static Color LightCoral { get; }
    public static Color LightCyan { get; }
    public static Color LightGoldenrodYellow { get; }
    public static Color LightGray { get; }
    public static Color LightGreen { get; }
    public static Color LightPink { get; }
    public static Color LightSalmon { get; }
    public static Color LightSeaGreen { get; }
    public static Color LightSkyBlue { get; }
    public static Color LightSlateGray { get; }
    public static Color LightSteelBlue { get; }
    public static Color LightYellow { get; }
    public static Color Lime { get; }
    public static Color LimeGreen { get; }
    public static Color Linen { get; }
    public static Color Magenta { get; }
    public static Color Maroon { get; }
    public static Color MediumAquamarine { get; }
    public static Color MediumBlue { get; }
    public static Color MediumOrchid { get; }
    public static Color MediumPurple { get; }
    public static Color MediumSeaGreen { get; }
    public static Color MediumSlateBlue { get; }
    public static Color MediumSpringGreen { get; }
    public static Color MediumTurquoise { get; }
    public static Color MediumVioletRed { get; }
    public static Color MidnightBlue { get; }
    public static Color MintCream { get; }
    public static Color MistyRose { get; }
    public static Color Moccasin { get; }
    public static Color NavajoWhite { get; }
    public static Color Navy { get; }
    public static Color OldLace { get; }
    public static Color Olive { get; }
    public static Color OliveDrab { get; }
    public static Color Orange { get; }
    public static Color OrangeRed { get; }
    public static Color Orchid { get; }
    public static Color PaleGoldenrod { get; }
    public static Color PaleGreen { get; }
    public static Color PaleTurquoise { get; }
    public static Color PaleVioletRed { get; }
    public static Color PapayaWhip { get; }
    public static Color PeachPuff { get; }
    public static Color Peru { get; }
    public static Color Pink { get; }
    public static Color Plum { get; }
    public static Color PowderBlue { get; }
    public static Color Purple { get; }
    public static Color Red { get; }
    public static Color RosyBrown { get; }
    public static Color RoyalBlue { get; }
    public static Color SaddleBrown { get; }
    public static Color Salmon { get; }
    public static Color SandyBrown { get; }
    public static Color SeaGreen { get; }
    public static Color SeaShell { get; }
    public static Color Sienna { get; }
    public static Color Silver { get; }
    public static Color SkyBlue { get; }
    public static Color SlateBlue { get; }
    public static Color SlateGray { get; }
    public static Color Snow { get; }
    public static Color SpringGreen { get; }
    public static Color SteelBlue { get; }
    public static Color Tan { get; }
    public static Color Teal { get; }
    public static Color Thistle { get; }
    public static Color Tomato { get; }
    public static Color Transparent { get; }
    public static Color Turquoise { get; }
    public static Color Violet { get; }
    public static Color Wheat { get; }
    public static Color White { get; }
    public static Color WhiteSmoke { get; }
    public static Color Yellow { get; }
    public static Color YellowGreen { get; }
    public static Color get_AliceBlue();
    public static Color get_AntiqueWhite();
    public static Color get_Aqua();
    public static Color get_Aquamarine();
    public static Color get_Azure();
    public static Color get_Beige();
    public static Color get_Bisque();
    public static Color get_Black();
    public static Color get_BlanchedAlmond();
    public static Color get_Blue();
    public static Color get_BlueViolet();
    public static Color get_Brown();
    public static Color get_BurlyWood();
    public static Color get_CadetBlue();
    public static Color get_Chartreuse();
    public static Color get_Chocolate();
    public static Color get_Coral();
    public static Color get_CornflowerBlue();
    public static Color get_Cornsilk();
    public static Color get_Crimson();
    public static Color get_Cyan();
    public static Color get_DarkBlue();
    public static Color get_DarkCyan();
    public static Color get_DarkGoldenrod();
    public static Color get_DarkGray();
    public static Color get_DarkGreen();
    public static Color get_DarkKhaki();
    public static Color get_DarkMagenta();
    public static Color get_DarkOliveGreen();
    public static Color get_DarkOrange();
    public static Color get_DarkOrchid();
    public static Color get_DarkRed();
    public static Color get_DarkSalmon();
    public static Color get_DarkSeaGreen();
    public static Color get_DarkSlateBlue();
    public static Color get_DarkSlateGray();
    public static Color get_DarkTurquoise();
    public static Color get_DarkViolet();
    public static Color get_DeepPink();
    public static Color get_DeepSkyBlue();
    public static Color get_DimGray();
    public static Color get_DodgerBlue();
    public static Color get_Firebrick();
    public static Color get_FloralWhite();
    public static Color get_ForestGreen();
    public static Color get_Fuchsia();
    public static Color get_Gainsboro();
    public static Color get_GhostWhite();
    public static Color get_Gold();
    public static Color get_Goldenrod();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_GreenYellow();
    public static Color get_Honeydew();
    public static Color get_HotPink();
    public static Color get_IndianRed();
    public static Color get_Indigo();
    public static Color get_Ivory();
    public static Color get_Khaki();
    public static Color get_Lavender();
    public static Color get_LavenderBlush();
    public static Color get_LawnGreen();
    public static Color get_LemonChiffon();
    public static Color get_LightBlue();
    public static Color get_LightCoral();
    public static Color get_LightCyan();
    public static Color get_LightGoldenrodYellow();
    public static Color get_LightGray();
    public static Color get_LightGreen();
    public static Color get_LightPink();
    public static Color get_LightSalmon();
    public static Color get_LightSeaGreen();
    public static Color get_LightSkyBlue();
    public static Color get_LightSlateGray();
    public static Color get_LightSteelBlue();
    public static Color get_LightYellow();
    public static Color get_Lime();
    public static Color get_LimeGreen();
    public static Color get_Linen();
    public static Color get_Magenta();
    public static Color get_Maroon();
    public static Color get_MediumAquamarine();
    public static Color get_MediumBlue();
    public static Color get_MediumOrchid();
    public static Color get_MediumPurple();
    public static Color get_MediumSeaGreen();
    public static Color get_MediumSlateBlue();
    public static Color get_MediumSpringGreen();
    public static Color get_MediumTurquoise();
    public static Color get_MediumVioletRed();
    public static Color get_MidnightBlue();
    public static Color get_MintCream();
    public static Color get_MistyRose();
    public static Color get_Moccasin();
    public static Color get_NavajoWhite();
    public static Color get_Navy();
    public static Color get_OldLace();
    public static Color get_Olive();
    public static Color get_OliveDrab();
    public static Color get_Orange();
    public static Color get_OrangeRed();
    public static Color get_Orchid();
    public static Color get_PaleGoldenrod();
    public static Color get_PaleGreen();
    public static Color get_PaleTurquoise();
    public static Color get_PaleVioletRed();
    public static Color get_PapayaWhip();
    public static Color get_PeachPuff();
    public static Color get_Peru();
    public static Color get_Pink();
    public static Color get_Plum();
    public static Color get_PowderBlue();
    public static Color get_Purple();
    public static Color get_Red();
    public static Color get_RosyBrown();
    public static Color get_RoyalBlue();
    public static Color get_SaddleBrown();
    public static Color get_Salmon();
    public static Color get_SandyBrown();
    public static Color get_SeaGreen();
    public static Color get_SeaShell();
    public static Color get_Sienna();
    public static Color get_Silver();
    public static Color get_SkyBlue();
    public static Color get_SlateBlue();
    public static Color get_SlateGray();
    public static Color get_Snow();
    public static Color get_SpringGreen();
    public static Color get_SteelBlue();
    public static Color get_Tan();
    public static Color get_Teal();
    public static Color get_Thistle();
    public static Color get_Tomato();
    public static Color get_Transparent();
    public static Color get_Turquoise();
    public static Color get_Violet();
    public static Color get_Wheat();
    public static Color get_White();
    public static Color get_WhiteSmoke();
    public static Color get_Yellow();
    public static Color get_YellowGreen();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.CombinedGeometry : Geometry {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Geometry> Geometry1Property;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Geometry> Geometry2Property;
    [NullableAttribute("1")]
public static StyledProperty`1<GeometryCombineMode> GeometryCombineModeProperty;
    public Geometry Geometry1 { get; public set; }
    public Geometry Geometry2 { get; public set; }
    public GeometryCombineMode GeometryCombineMode { get; public set; }
    [NullableContextAttribute("1")]
public CombinedGeometry(Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode combineMode, Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode combineMode, Geometry geometry1, Geometry geometry2, Transform transform);
    private static CombinedGeometry();
    public Geometry get_Geometry1();
    public void set_Geometry1(Geometry value);
    public Geometry get_Geometry2();
    public void set_Geometry2(Geometry value);
    public GeometryCombineMode get_GeometryCombineMode();
    public void set_GeometryCombineMode(GeometryCombineMode value);
    [NullableContextAttribute("1")]
public virtual Geometry Clone();
    private protected sealed virtual IGeometryImpl CreateDefiningGeometry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.CompositeFontFamilyKey : FontFamilyKey {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FontFamilyKey> <Keys>k__BackingField;
    public IReadOnlyList`1<FontFamilyKey> Keys { get; }
    public CompositeFontFamilyKey(Uri source, FontFamilyKey[] keys);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FontFamilyKey> get_Keys();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.ConicGradientBrush : GradientBrush {
    public static StyledProperty`1<RelativePoint> CenterProperty;
    public static StyledProperty`1<double> AngleProperty;
    public RelativePoint Center { get; public set; }
    public double Angle { get; public set; }
    internal Func`2<Compositor, ServerCompositionSimpleBrush> Factory { get; }
    private static ConicGradientBrush();
    public sealed virtual RelativePoint get_Center();
    public void set_Center(RelativePoint value);
    public sealed virtual double get_Angle();
    public void set_Angle(double value);
    public virtual IImmutableBrush ToImmutable();
    internal virtual Func`2<Compositor, ServerCompositionSimpleBrush> get_Factory();
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.DashStyle : Animatable {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<AvaloniaList`1<double>> DashesProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<double> OffsetProperty;
    private static ImmutableDashStyle s_dash;
    private static ImmutableDashStyle s_dot;
    private static ImmutableDashStyle s_dashDot;
    private static ImmutableDashStyle s_dashDotDot;
    [CompilerGeneratedAttribute]
private EventHandler Invalidated;
    [NullableAttribute("1")]
public static IDashStyle Dash { get; }
    [NullableAttribute("1")]
public static IDashStyle Dot { get; }
    [NullableAttribute("1")]
public static IDashStyle DashDot { get; }
    [NullableAttribute("1")]
public static IDashStyle DashDotDot { get; }
    public AvaloniaList`1<double> Dashes { get; public set; }
    public double Offset { get; public set; }
    private IReadOnlyList`1<double> Avalonia.Media.IDashStyle.Dashes { get; }
    public DashStyle(IEnumerable`1<double> dashes, double offset);
    private static DashStyle();
    [NullableContextAttribute("1")]
public static IDashStyle get_Dash();
    [NullableContextAttribute("1")]
public static IDashStyle get_Dot();
    [NullableContextAttribute("1")]
public static IDashStyle get_DashDot();
    [NullableContextAttribute("1")]
public static IDashStyle get_DashDotDot();
    public AvaloniaList`1<double> get_Dashes();
    public void set_Dashes(AvaloniaList`1<double> value);
    public sealed virtual double get_Offset();
    public void set_Offset(double value);
    private sealed virtual override IReadOnlyList`1<double> Avalonia.Media.IDashStyle.get_Dashes();
    [CompilerGeneratedAttribute]
internal void add_Invalidated(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Invalidated(EventHandler value);
    [NullableContextAttribute("1")]
public ImmutableDashStyle ToImmutable();
    [NullableContextAttribute("1")]
protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    [NullableContextAttribute("1")]
private void DashesChanged(object sender, NotifyCollectionChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.Drawing : AvaloniaObject {
    public void Draw(DrawingContext context);
    internal abstract virtual void DrawCore(DrawingContext context);
    public abstract virtual Rect GetBounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.DrawingBrush : TileBrush {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Drawing> DrawingProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private InlineDictionary`2<Compositor, CompositionRenderData> _renderDataDictionary;
    [NullableAttribute("2")]
public Drawing Drawing { get; public set; }
    internal Func`2<Compositor, ServerCompositionSimpleBrush> Factory { get; }
    public DrawingBrush(Drawing visual);
    private static DrawingBrush();
    [NullableContextAttribute("2")]
public Drawing get_Drawing();
    [NullableContextAttribute("2")]
public void set_Drawing(Drawing value);
    [NullableContextAttribute("2")]
private sealed virtual override ISceneBrushContent Avalonia.Media.ISceneBrush.CreateContent();
    internal virtual Func`2<Compositor, ServerCompositionSimpleBrush> get_Factory();
    private protected virtual void OnReferencedFromCompositor(Compositor c);
    protected virtual void OnUnreferencedFromCompositor(Compositor c);
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
    private CompositionRenderData CreateServerContent(Compositor c);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Media.DrawingCollection : AvaloniaList`1<Drawing> {
    public DrawingCollection(IEnumerable`1<Drawing> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.DrawingContext : object {
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<Stack`1<RestoreState>> <StateStackPool>k__BackingField;
    [NullableAttribute("2")]
private Stack`1<RestoreState> _states;
    private static ThreadSafeObjectPool`1<Stack`1<RestoreState>> StateStackPool { get; }
    private static DrawingContext();
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<Stack`1<RestoreState>> get_StateStackPool();
    public sealed virtual void Dispose();
    protected abstract virtual void DisposeCore();
    public virtual void DrawImage(IImage source, Rect rect);
    public virtual void DrawImage(IImage source, Rect sourceRect, Rect destRect);
    internal abstract virtual void DrawBitmap(IRef`1<IBitmapImpl> source, double opacity, Rect sourceRect, Rect destRect);
    public void DrawLine(IPen pen, Point p1, Point p2);
    protected abstract virtual void DrawLineCore(IPen pen, Point p1, Point p2);
    [NullableContextAttribute("2")]
public void DrawGeometry(IBrush brush, IPen pen, Geometry geometry);
    [NullableContextAttribute("2")]
public void DrawGeometry(IBrush brush, IPen pen, IGeometryImpl geometry);
    [NullableContextAttribute("2")]
protected abstract virtual void DrawGeometryCore(IBrush brush, IPen pen, IGeometryImpl geometry);
    [NullableContextAttribute("2")]
public void DrawRectangle(IBrush brush, IPen pen, Rect rect, double radiusX, double radiusY, BoxShadows boxShadows);
    [NullableContextAttribute("2")]
public void DrawRectangle(IBrush brush, IPen pen, RoundedRect rrect, BoxShadows boxShadows);
    [NullableContextAttribute("2")]
protected abstract virtual void DrawRectangleCore(IBrush brush, IPen pen, RoundedRect rrect, BoxShadows boxShadows);
    public void DrawRectangle(IPen pen, Rect rect, float cornerRadius);
    public void FillRectangle(IBrush brush, Rect rect, float cornerRadius);
    [NullableContextAttribute("2")]
public void DrawEllipse(IBrush brush, IPen pen, Point center, double radiusX, double radiusY);
    [NullableContextAttribute("2")]
public void DrawEllipse(IBrush brush, IPen pen, Rect rect);
    [NullableContextAttribute("2")]
protected abstract virtual void DrawEllipseCore(IBrush brush, IPen pen, Rect rect);
    public abstract virtual void Custom(ICustomDrawOperation custom);
    public virtual void DrawText(FormattedText text, Point origin);
    public abstract virtual void DrawGlyphRun(IBrush foreground, GlyphRun glyphRun);
    public PushedState PushClip(RoundedRect clip);
    protected abstract virtual void PushClipCore(RoundedRect rect);
    public PushedState PushClip(Rect clip);
    protected abstract virtual void PushClipCore(Rect rect);
    public PushedState PushGeometryClip(Geometry clip);
    protected abstract virtual void PushGeometryClipCore(Geometry clip);
    public PushedState PushOpacity(double opacity);
    protected abstract virtual void PushOpacityCore(double opacity);
    public PushedState PushOpacityMask(IBrush mask, Rect bounds);
    protected abstract virtual void PushOpacityMaskCore(IBrush mask, Rect bounds);
    public PushedState PushTransform(Matrix matrix);
    public PushedState PushRenderOptions(RenderOptions renderOptions);
    protected abstract virtual void PushRenderOptionsCore(RenderOptions renderOptions);
    [ObsoleteAttribute("Use PushTransform")]
[EditorBrowsableAttribute("1")]
public PushedState PushPreTransform(Matrix matrix);
    [ObsoleteAttribute("Use PushTransform")]
[EditorBrowsableAttribute("1")]
public PushedState PushPostTransform(Matrix matrix);
    [ObsoleteAttribute("Use PushTransform")]
[EditorBrowsableAttribute("1")]
public PushedState PushTransformContainer();
    protected abstract virtual void PushTransformCore(Matrix matrix);
    protected abstract virtual void PopClipCore();
    protected abstract virtual void PopGeometryClipCore();
    protected abstract virtual void PopOpacityCore();
    protected abstract virtual void PopOpacityMaskCore();
    protected abstract virtual void PopTransformCore();
    protected abstract virtual void PopRenderOptionsCore();
    [NullableContextAttribute("2")]
private static bool PenIsVisible(IPen pen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.DrawingGroup : Drawing {
    public static StyledProperty`1<double> OpacityProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Transform> TransformProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Geometry> ClipGeometryProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IBrush> OpacityMaskProperty;
    public static DirectProperty`2<DrawingGroup, DrawingCollection> ChildrenProperty;
    private DrawingCollection _children;
    [CompilerGeneratedAttribute]
private Nullable`1<RenderOptions> <RenderOptions>k__BackingField;
    public double Opacity { get; public set; }
    [NullableAttribute("2")]
public Transform Transform { get; public set; }
    [NullableAttribute("2")]
public Geometry ClipGeometry { get; public set; }
    [NullableAttribute("2")]
public IBrush OpacityMask { get; public set; }
    internal Nullable`1<RenderOptions> RenderOptions { get; internal set; }
    [ContentAttribute]
public DrawingCollection Children { get; public set; }
    private static DrawingGroup();
    public double get_Opacity();
    public void set_Opacity(double value);
    [NullableContextAttribute("2")]
public Transform get_Transform();
    [NullableContextAttribute("2")]
public void set_Transform(Transform value);
    [NullableContextAttribute("2")]
public Geometry get_ClipGeometry();
    [NullableContextAttribute("2")]
public void set_ClipGeometry(Geometry value);
    [NullableContextAttribute("2")]
public IBrush get_OpacityMask();
    [NullableContextAttribute("2")]
public void set_OpacityMask(IBrush value);
    [CompilerGeneratedAttribute]
internal Nullable`1<RenderOptions> get_RenderOptions();
    [CompilerGeneratedAttribute]
internal void set_RenderOptions(Nullable`1<RenderOptions> value);
    public DrawingCollection get_Children();
    public void set_Children(DrawingCollection value);
    public DrawingContext Open();
    internal virtual void DrawCore(DrawingContext context);
    public virtual Rect GetBounds();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.DrawingImage : AvaloniaObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Drawing> DrawingProperty;
    [CompilerGeneratedAttribute]
private EventHandler Invalidated;
    [ContentAttribute]
public Drawing Drawing { get; public set; }
    public Size Size { get; }
    [NullableContextAttribute("1")]
public DrawingImage(Drawing drawing);
    private static DrawingImage();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Invalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Invalidated(EventHandler value);
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    public sealed virtual Size get_Size();
    [NullableContextAttribute("1")]
private sealed virtual override void Avalonia.Media.IImage.Draw(DrawingContext context, Rect sourceRect, Rect destRect);
    [NullableContextAttribute("1")]
protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    [NullableContextAttribute("1")]
protected void RaiseInvalidated(EventArgs e);
}
public class Avalonia.Media.DropShadowDirectionEffect : DropShadowEffectBase {
    [NullableAttribute("1")]
public static StyledProperty`1<double> ShadowDepthProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<double> DirectionProperty;
    public double ShadowDepth { get; public set; }
    public double Direction { get; public set; }
    public double OffsetX { get; }
    public double OffsetY { get; }
    private static DropShadowDirectionEffect();
    public sealed virtual double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public sealed virtual double get_Direction();
    public void set_Direction(double value);
    public sealed virtual double get_OffsetX();
    public sealed virtual double get_OffsetY();
    [NullableContextAttribute("1")]
public sealed virtual IImmutableEffect ToImmutable();
}
public class Avalonia.Media.DropShadowEffect : DropShadowEffectBase {
    [NullableAttribute("1")]
public static StyledProperty`1<double> OffsetXProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<double> OffsetYProperty;
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    private static DropShadowEffect();
    public sealed virtual double get_OffsetX();
    public void set_OffsetX(double value);
    public sealed virtual double get_OffsetY();
    public void set_OffsetY(double value);
    [NullableContextAttribute("1")]
public sealed virtual IImmutableEffect ToImmutable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.DropShadowEffectBase : Effect {
    public static StyledProperty`1<double> BlurRadiusProperty;
    public static StyledProperty`1<Color> ColorProperty;
    public static StyledProperty`1<double> OpacityProperty;
    public double BlurRadius { get; public set; }
    public Color Color { get; public set; }
    public double Opacity { get; public set; }
    private static DropShadowEffectBase();
    public sealed virtual double get_BlurRadius();
    public void set_BlurRadius(double value);
    public sealed virtual Color get_Color();
    public void set_Color(Color value);
    public sealed virtual double get_Opacity();
    public void set_Opacity(double value);
}
public enum Avalonia.Media.EdgeMode : Enum {
    public byte value__;
    public static EdgeMode Unspecified;
    public static EdgeMode Antialias;
    public static EdgeMode Aliased;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Effect : Animatable {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Invalidated;
    private static Effect();
    protected static void AffectsRender(AvaloniaProperty[] properties);
    protected void RaiseInvalidated(EventArgs e);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_Invalidated(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_Invalidated(EventHandler value);
    private static Exception ParseError(string s);
    public static IEffect Parse(string s);
}
public class Avalonia.Media.EffectConverter : TypeConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    [NullableContextAttribute("2")]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Media.EffectExtensions : object {
    private static double AdjustPaddingRadius(double radius);
    [ExtensionAttribute]
internal static Thickness GetEffectOutputPadding(IEffect effect);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IImmutableEffect ToImmutable(IEffect effect);
    [ExtensionAttribute]
internal static bool EffectEquals(IImmutableEffect immutable, IEffect right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.EllipseGeometry : Geometry {
    public static StyledProperty`1<Rect> RectProperty;
    public static StyledProperty`1<double> RadiusXProperty;
    public static StyledProperty`1<double> RadiusYProperty;
    public static StyledProperty`1<Point> CenterProperty;
    public Rect Rect { get; public set; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Point Center { get; public set; }
    private static EllipseGeometry();
    public EllipseGeometry(Rect rect);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Point get_Center();
    public void set_Center(Point value);
    public virtual Geometry Clone();
    [NullableContextAttribute("2")]
private protected sealed virtual IGeometryImpl CreateDefiningGeometry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.ExperimentalAcrylicMaterial : AvaloniaObject {
    private Color _effectiveTintColor;
    private Color _effectiveLuminosityColor;
    public static StyledProperty`1<Color> TintColorProperty;
    public static StyledProperty`1<AcrylicBackgroundSource> BackgroundSourceProperty;
    public static StyledProperty`1<double> TintOpacityProperty;
    public static StyledProperty`1<double> MaterialOpacityProperty;
    public static StyledProperty`1<double> PlatformTransparencyCompensationLevelProperty;
    public static StyledProperty`1<Color> FallbackColorProperty;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Invalidated;
    public AcrylicBackgroundSource BackgroundSource { get; public set; }
    public Color TintColor { get; public set; }
    public double TintOpacity { get; public set; }
    public Color FallbackColor { get; public set; }
    public double MaterialOpacity { get; public set; }
    public double PlatformTransparencyCompensationLevel { get; public set; }
    private Color Avalonia.Media.IExperimentalAcrylicMaterial.MaterialColor { get; }
    private Color Avalonia.Media.IExperimentalAcrylicMaterial.TintColor { get; }
    private static ExperimentalAcrylicMaterial();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_Invalidated(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_Invalidated(EventHandler value);
    public sealed virtual AcrylicBackgroundSource get_BackgroundSource();
    public void set_BackgroundSource(AcrylicBackgroundSource value);
    public Color get_TintColor();
    public void set_TintColor(Color value);
    public sealed virtual double get_TintOpacity();
    public void set_TintOpacity(double value);
    public sealed virtual Color get_FallbackColor();
    public void set_FallbackColor(Color value);
    public double get_MaterialOpacity();
    public void set_MaterialOpacity(double value);
    public double get_PlatformTransparencyCompensationLevel();
    public void set_PlatformTransparencyCompensationLevel(double value);
    private sealed virtual override Color Avalonia.Media.IExperimentalAcrylicMaterial.get_MaterialColor();
    private sealed virtual override Color Avalonia.Media.IExperimentalAcrylicMaterial.get_TintColor();
    private static Color GetEffectiveTintColor(Color tintColor, double tintOpacity);
    private static double GetTintOpacityModifier(Color tintColor);
    private Color GetEffectiveLuminosityColor();
    private static byte Trim(double value);
    private static float RGBMax(Color color);
    private static float RGBMin(Color color);
    private Color GetLuminosityColor(Nullable`1<double> luminosityOpacity);
    protected static void AffectsRender(AvaloniaProperty[] properties);
    protected void RaiseInvalidated(EventArgs e);
    public sealed virtual IExperimentalAcrylicMaterial ToImmutable();
}
public enum Avalonia.Media.FillRule : Enum {
    public int value__;
    public static FillRule EvenOdd;
    public static FillRule NonZero;
}
public enum Avalonia.Media.FlowDirection : Enum {
    public int value__;
    public static FlowDirection LeftToRight;
    public static FlowDirection RightToLeft;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.FontFallback : object {
    [CompilerGeneratedAttribute]
private FontFamily <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private UnicodeRange <UnicodeRange>k__BackingField;
    public FontFamily FontFamily { get; public set; }
    public UnicodeRange UnicodeRange { get; public set; }
    [CompilerGeneratedAttribute]
public FontFamily get_FontFamily();
    [CompilerGeneratedAttribute]
public void set_FontFamily(FontFamily value);
    [CompilerGeneratedAttribute]
public UnicodeRange get_UnicodeRange();
    [CompilerGeneratedAttribute]
public void set_UnicodeRange(UnicodeRange value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.FontFamily : object {
    public static string DefaultFontFamilyName;
    [CompilerGeneratedAttribute]
private static FontFamily <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private FamilyNameCollection <FamilyNames>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FontFamilyKey <Key>k__BackingField;
    public static FontFamily Default { get; }
    public string Name { get; }
    public FamilyNameCollection FamilyNames { get; }
    [NullableAttribute("2")]
public FontFamilyKey Key { get; }
    private static FontFamily();
    public FontFamily(string name);
    public FontFamily(Uri baseUri, string name);
    [CompilerGeneratedAttribute]
public static FontFamily get_Default();
    public string get_Name();
    [CompilerGeneratedAttribute]
public FamilyNameCollection get_FamilyNames();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FontFamilyKey get_Key();
    public static FontFamily op_Implicit(string s);
    [NullableContextAttribute("0")]
private static FrugalStructList`1<FontSourceIdentifier> GetFontSourceIdentifier(string name);
    public static FontFamily Parse(string s);
    public static FontFamily Parse(string s, Uri baseUri);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Inequality(FontFamily a, FontFamily b);
    [NullableContextAttribute("2")]
public static bool op_Equality(FontFamily a, FontFamily b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.FontFeature : object {
    private static int DefaultValue;
    private static int InfinityEnd;
    private static Regex s_featureRegex;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Tag { get; public set; }
    public int Value { get; public set; }
    public int Start { get; public set; }
    public int End { get; public set; }
    [CompilerGeneratedAttribute]
protected FontFeature(FontFeature original);
    private static FontFeature();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Tag(string value);
    [CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(int value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_End(int value);
    public static FontFeature Parse(string s);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(FontFeature left, FontFeature right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(FontFeature left, FontFeature right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(FontFeature other);
    [CompilerGeneratedAttribute]
public virtual FontFeature <Clone>$();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Media.FontFeatureCollection : AvaloniaList`1<FontFeature> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.FontManager : object {
    internal static Uri SystemFontsKey;
    public static string FontCollectionScheme;
    public static string SystemFontScheme;
    public static string CompositeFontScheme;
    private ConcurrentDictionary`2<Uri, IFontCollection> _fontCollections;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<FontFallback> _fontFallbacks;
    [CompilerGeneratedAttribute]
private FontFamily <DefaultFontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private IFontManagerImpl <PlatformImpl>k__BackingField;
    public static FontManager Current { get; }
    public FontFamily DefaultFontFamily { get; }
    public IFontCollection SystemFonts { get; }
    internal IFontManagerImpl PlatformImpl { get; }
    public FontManager(IFontManagerImpl platformImpl);
    private static FontManager();
    public static FontManager get_Current();
    [CompilerGeneratedAttribute]
public FontFamily get_DefaultFontFamily();
    public IFontCollection get_SystemFonts();
    [CompilerGeneratedAttribute]
internal IFontManagerImpl get_PlatformImpl();
    [NullableContextAttribute("2")]
public bool TryGetGlyphTypeface(Typeface typeface, IGlyphTypeface& glyphTypeface);
    private bool TryGetGlyphTypefaceByKeyAndName(Typeface typeface, FontFamilyKey key, string familyName, IGlyphTypeface& glyphTypeface);
    public void AddFontCollection(IFontCollection fontCollection);
    public void RemoveFontCollection(Uri key);
    [NullableContextAttribute("2")]
public bool TryMatchCharacter(int codepoint, FontStyle fontStyle, FontWeight fontWeight, FontStretch fontStretch, FontFamily fontFamily, CultureInfo culture, Typeface& typeface);
    private bool TryGetFontCollection(Uri source, IFontCollection& fontCollection);
    private string GetDefaultFontFamilyName(FontManagerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.FontManagerOptions : object {
    [CompilerGeneratedAttribute]
private string <DefaultFamilyName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<FontFallback> <FontFallbacks>k__BackingField;
    public string DefaultFamilyName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<FontFallback> FontFallbacks { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultFamilyName();
    [CompilerGeneratedAttribute]
public void set_DefaultFamilyName(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FontFallback> get_FontFallbacks();
    [CompilerGeneratedAttribute]
public void set_FontFallbacks(IReadOnlyList`1<FontFallback> value);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.FontMetrics : ValueType {
    [CompilerGeneratedAttribute]
private short <DesignEmHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixedPitch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ascent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Descent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineGap>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnderlinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UnderlineThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrikethroughPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrikethroughThickness>k__BackingField;
    public short DesignEmHeight { get; public set; }
    public bool IsFixedPitch { get; public set; }
    public int Ascent { get; public set; }
    public int Descent { get; public set; }
    public int LineGap { get; public set; }
    public int LineSpacing { get; }
    public int UnderlinePosition { get; public set; }
    public int UnderlineThickness { get; public set; }
    public int StrikethroughPosition { get; public set; }
    public int StrikethroughThickness { get; public set; }
    [CompilerGeneratedAttribute]
public short get_DesignEmHeight();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DesignEmHeight(short value);
    [CompilerGeneratedAttribute]
public bool get_IsFixedPitch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsFixedPitch(bool value);
    [CompilerGeneratedAttribute]
public int get_Ascent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Ascent(int value);
    [CompilerGeneratedAttribute]
public int get_Descent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Descent(int value);
    [CompilerGeneratedAttribute]
public int get_LineGap();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineGap(int value);
    public int get_LineSpacing();
    [CompilerGeneratedAttribute]
public int get_UnderlinePosition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnderlinePosition(int value);
    [CompilerGeneratedAttribute]
public int get_UnderlineThickness();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnderlineThickness(int value);
    [CompilerGeneratedAttribute]
public int get_StrikethroughPosition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StrikethroughPosition(int value);
    [CompilerGeneratedAttribute]
public int get_StrikethroughThickness();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StrikethroughThickness(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FontMetrics left, FontMetrics right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FontMetrics left, FontMetrics right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FontMetrics other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Media.Fonts.EmbeddedFontCollection : FontCollectionBase {
    private List`1<FontFamily> _fontFamilies;
    private Uri _key;
    private Uri _source;
    [NullableAttribute("2")]
private IFontManagerImpl _fontManager;
    public Uri Key { get; }
    public FontFamily Item { get; }
    public int Count { get; }
    public EmbeddedFontCollection(Uri key, Uri source);
    public virtual Uri get_Key();
    public virtual FontFamily get_Item(int index);
    public virtual int get_Count();
    public virtual void Initialize(IFontManagerImpl fontManager);
    public virtual bool TryGetGlyphTypeface(string familyName, FontStyle style, FontWeight weight, FontStretch stretch, IGlyphTypeface& glyphTypeface);
    public virtual IEnumerator`1<FontFamily> GetEnumerator();
    private void AddGlyphTypeface(IGlyphTypeface glyphTypeface);
    [CompilerGeneratedAttribute]
private void <AddGlyphTypeface>g__AddGlyphTypefaceByFamilyName|14_0(string familyName, IGlyphTypeface glyphTypeface);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Media.Fonts.FamilyNameCollection : object {
    private String[] _names;
    [CompilerGeneratedAttribute]
private string <PrimaryFamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFallbacks>k__BackingField;
    public string PrimaryFamilyName { get; }
    public bool HasFallbacks { get; }
    public int Count { get; }
    public string Item { get; }
    public FamilyNameCollection(string familyNames);
    [NullableContextAttribute("0")]
internal FamilyNameCollection(FrugalStructList`1<FontSourceIdentifier> fontSources);
    private static String[] SplitNames(string names);
    [CompilerGeneratedAttribute]
public string get_PrimaryFamilyName();
    [CompilerGeneratedAttribute]
public bool get_HasFallbacks();
    public ImmutableReadOnlyListStructEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Inequality(FamilyNameCollection a, FamilyNameCollection b);
    [NullableContextAttribute("2")]
public static bool op_Equality(FamilyNameCollection a, FamilyNameCollection b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual int get_Count();
    public sealed virtual string get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class Avalonia.Media.Fonts.FontCollectionBase : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ConcurrentDictionary`2<string, ConcurrentDictionary`2<FontCollectionKey, IGlyphTypeface>> _glyphTypefaceCache;
    public Uri Key { get; }
    public int Count { get; }
    public FontFamily Item { get; }
    public abstract virtual Uri get_Key();
    public abstract virtual int get_Count();
    public abstract virtual FontFamily get_Item(int index);
    public abstract virtual bool TryGetGlyphTypeface(string familyName, FontStyle style, FontWeight weight, FontStretch stretch, IGlyphTypeface& glyphTypeface);
    [NullableContextAttribute("2")]
public sealed virtual bool TryMatchCharacter(int codepoint, FontStyle style, FontWeight weight, FontStretch stretch, string familyName, CultureInfo culture, Typeface& match);
    public abstract virtual void Initialize(IFontManagerImpl fontManager);
    public abstract virtual IEnumerator`1<FontFamily> GetEnumerator();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
internal static bool TryGetNearestMatch(ConcurrentDictionary`2<FontCollectionKey, IGlyphTypeface> glyphTypefaces, FontCollectionKey key, IGlyphTypeface& glyphTypeface);
    [NullableContextAttribute("2")]
internal static bool TryFindStretchFallback(ConcurrentDictionary`2<FontCollectionKey, IGlyphTypeface> glyphTypefaces, FontCollectionKey key, IGlyphTypeface& glyphTypeface);
    [NullableContextAttribute("2")]
internal static bool TryFindWeightFallback(ConcurrentDictionary`2<FontCollectionKey, IGlyphTypeface> glyphTypefaces, FontCollectionKey key, IGlyphTypeface& glyphTypeface);
    internal static Typeface GetImplicitTypeface(Typeface typeface, String& normalizedFamilyName);
    internal static bool TryGetWeight(String& familyName, FontWeight& weight);
    internal static bool TryGetStyle(String& familyName, FontStyle& style);
    internal static bool TryGetStretch(String& familyName, FontStretch& stretch);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.Fonts.FontCollectionKey : ValueType {
    [CompilerGeneratedAttribute]
private FontStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private FontWeight <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStretch <Stretch>k__BackingField;
    public FontStyle Style { get; public set; }
    public FontWeight Weight { get; public set; }
    public FontStretch Stretch { get; public set; }
    public FontCollectionKey(FontStyle Style, FontWeight Weight, FontStretch Stretch);
    [CompilerGeneratedAttribute]
public FontStyle get_Style();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Style(FontStyle value);
    [CompilerGeneratedAttribute]
public FontWeight get_Weight();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Weight(FontWeight value);
    [CompilerGeneratedAttribute]
public FontStretch get_Stretch();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Stretch(FontStretch value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FontCollectionKey left, FontCollectionKey right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FontCollectionKey left, FontCollectionKey right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FontCollectionKey other);
    [CompilerGeneratedAttribute]
public void Deconstruct(FontStyle& Style, FontWeight& Weight, FontStretch& Stretch);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.Fonts.FontFamilyKey : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Uri <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    [NullableAttribute("1")]
public Uri Source { get; }
    public Uri BaseUri { get; }
    [NullableContextAttribute("1")]
public FontFamilyKey(Uri source, Uri baseUri);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Uri get_Source();
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    public virtual int GetHashCode();
    public static bool op_Inequality(FontFamilyKey a, FontFamilyKey b);
    public static bool op_Equality(FontFamilyKey a, FontFamilyKey b);
    public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Media.Fonts.FontFamilyLoader : object {
    public static IEnumerable`1<Uri> LoadFontAssets(Uri source);
    private static IEnumerable`1<Uri> GetFontAssetsBySource(Uri source);
    private static IEnumerable`1<Uri> GetFontAssetsByExpression(Uri source);
    private static ValueTuple`2<string, string> GetFileName(Uri source, Uri& location);
    private static string CreateFilePattern(Uri source, Uri location, string fileNameWithoutExtension);
    private static bool IsContainsFile(Uri x, string filePattern, string fileExtension);
    private static bool IsFontTtfOrOtf(Uri uri);
    private static ValueTuple`2<string, string> GetFileNameAndExtension(string path, char directorySeparator);
    [NullableContextAttribute("0")]
private static bool IsPathRooted(ReadOnlySpan`1<char> path, char directorySeparator);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<char> GetFileExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path, char directorySeparator, int extensionLength);
    private static string GetSubString(string path, char separator);
}
[NullableContextAttribute("1")]
public interface Avalonia.Media.Fonts.IFontCollection {
    public Uri Key { get; }
    public abstract virtual Uri get_Key();
    public abstract virtual void Initialize(IFontManagerImpl fontManager);
    public abstract virtual bool TryGetGlyphTypeface(string familyName, FontStyle style, FontWeight weight, FontStretch stretch, IGlyphTypeface& glyphTypeface);
    [NullableContextAttribute("2")]
public abstract virtual bool TryMatchCharacter(int codepoint, FontStyle fontStyle, FontWeight fontWeight, FontStretch fontStretch, string familyName, CultureInfo culture, Typeface& typeface);
}
[IsReadOnlyAttribute]
internal class Avalonia.Media.Fonts.OpenTypeTag : ValueType {
    public static OpenTypeTag None;
    public static OpenTypeTag Max;
    public static OpenTypeTag MaxSigned;
    private UInt32 _value;
    public OpenTypeTag(UInt32 value);
    public OpenTypeTag(char c1, char c2, char c3, char c4);
    private OpenTypeTag(byte c1, byte c2, byte c3, byte c4);
    private static OpenTypeTag();
    [NullableContextAttribute("1")]
public static OpenTypeTag Parse(string tag);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static UInt32 op_Implicit(OpenTypeTag tag);
    public static OpenTypeTag op_Implicit(UInt32 tag);
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(OpenTypeTag left, OpenTypeTag right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(OpenTypeTag left, OpenTypeTag right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OpenTypeTag other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Avalonia.Media.Fonts.SystemFontCollection : FontCollectionBase {
    private FontManager _fontManager;
    private List`1<string> _familyNames;
    public Uri Key { get; }
    public FontFamily Item { get; }
    public int Count { get; }
    public SystemFontCollection(FontManager fontManager);
    public virtual Uri get_Key();
    public virtual FontFamily get_Item(int index);
    public virtual int get_Count();
    [IteratorStateMachineAttribute("Avalonia.Media.Fonts.SystemFontCollection/<GetEnumerator>d__9")]
public virtual IEnumerator`1<FontFamily> GetEnumerator();
    public virtual bool TryGetGlyphTypeface(string familyName, FontStyle style, FontWeight weight, FontStretch stretch, IGlyphTypeface& glyphTypeface);
    private bool TryCreateSyntheticGlyphTypeface(IGlyphTypeface glyphTypeface, FontStyle style, FontWeight weight, IGlyphTypeface& syntheticGlyphTypeface);
    public virtual void Initialize(IFontManagerImpl fontManager);
    public void AddCustomFontSource(Uri source);
    private void LoadGlyphTypefaces(IFontManagerImpl fontManager, Uri source);
    [CompilerGeneratedAttribute]
private void <LoadGlyphTypefaces>g__AddGlyphTypefaceByFamilyName|14_0(string familyName, IGlyphTypeface glyphTypeface);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Start: {StartOfStream}, Position: {BaseStream.Position}")]
internal class Avalonia.Media.Fonts.Tables.BigEndianBinaryReader : object {
    private Byte[] _buffer;
    private bool _leaveOpen;
    [CompilerGeneratedAttribute]
private long <StartOfStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <BaseStream>k__BackingField;
    private long StartOfStream { get; }
    public Stream BaseStream { get; }
    public BigEndianBinaryReader(Stream stream, bool leaveOpen);
    [CompilerGeneratedAttribute]
private long get_StartOfStream();
    [CompilerGeneratedAttribute]
public Stream get_BaseStream();
    public void Seek(long offset, SeekOrigin origin);
    public byte ReadByte();
    public sbyte ReadSByte();
    public float ReadF2dot14();
    public short ReadInt16();
    [NullableContextAttribute("0")]
public TEnum ReadInt16();
    public short ReadFWORD();
    public Int16[] ReadFWORDArray(int length);
    public ushort ReadUFWORD();
    public float ReadFixed();
    public int ReadInt32();
    public long ReadInt64();
    public ushort ReadUInt16();
    public ushort ReadOffset16();
    [NullableContextAttribute("0")]
public TEnum ReadUInt16();
    public UInt16[] ReadUInt16Array(int length);
    [NullableContextAttribute("0")]
public void ReadUInt16Array(Span`1<ushort> buffer);
    public UInt32[] ReadUInt32Array(int length);
    public Byte[] ReadUInt8Array(int length);
    public Int16[] ReadInt16Array(int length);
    [NullableContextAttribute("0")]
public void ReadInt16Array(Span`1<short> buffer);
    public byte ReadUInt8();
    public int ReadUInt24();
    public UInt32 ReadUInt32();
    public UInt32 ReadOffset32();
    public Byte[] ReadBytes(int count);
    public string ReadString(int bytesToRead, Encoding encoding);
    public string ReadTag();
    public int ReadOffset(int size);
    private void ReadInternal(Byte[] data, int size);
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
private static bool TryConvert(T input, TEnum& value);
}
[ExtensionAttribute]
internal static class Avalonia.Media.Fonts.Tables.EncodingIDExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Encoding AsEncoding(EncodingIDs id);
}
internal enum Avalonia.Media.Fonts.Tables.EncodingIDs : Enum {
    public ushort value__;
    public static EncodingIDs Unicode1;
    public static EncodingIDs Unicode11;
    public static EncodingIDs ISO10646;
    public static EncodingIDs Unicode2;
    public static EncodingIDs Unicode2Plus;
    public static EncodingIDs UnicodeVariationSequences;
    public static EncodingIDs UnicodeFull;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.Fonts.Tables.FeatureListTable : object {
    private static OpenTypeTag GSubTag;
    private static OpenTypeTag GPosTag;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OpenTypeTag> <Features>k__BackingField;
    public IReadOnlyList`1<OpenTypeTag> Features { get; }
    private FeatureListTable(IReadOnlyList`1<OpenTypeTag> features);
    private static FeatureListTable();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OpenTypeTag> get_Features();
    public static FeatureListTable LoadGSub(IGlyphTypeface glyphTypeface);
    public static FeatureListTable LoadGPos(IGlyphTypeface glyphTypeface);
    private static FeatureListTable Load(BigEndianBinaryReader reader);
    private static FeatureListTable Load(BigEndianBinaryReader reader, long offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.Fonts.Tables.HorizontalHeadTable : object {
    internal static string TableName;
    internal static OpenTypeTag Tag;
    [CompilerGeneratedAttribute]
private ushort <AdvanceWidthMax>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Ascender>k__BackingField;
    [CompilerGeneratedAttribute]
private short <CaretOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private short <CaretSlopeRise>k__BackingField;
    [CompilerGeneratedAttribute]
private short <CaretSlopeRun>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Descender>k__BackingField;
    [CompilerGeneratedAttribute]
private short <LineGap>k__BackingField;
    [CompilerGeneratedAttribute]
private short <MinLeftSideBearing>k__BackingField;
    [CompilerGeneratedAttribute]
private short <MinRightSideBearing>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfHMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private short <XMaxExtent>k__BackingField;
    public ushort AdvanceWidthMax { get; }
    public short Ascender { get; }
    public short CaretOffset { get; }
    public short CaretSlopeRise { get; }
    public short CaretSlopeRun { get; }
    public short Descender { get; }
    public short LineGap { get; }
    public short MinLeftSideBearing { get; }
    public short MinRightSideBearing { get; }
    public ushort NumberOfHMetrics { get; }
    public short XMaxExtent { get; }
    public HorizontalHeadTable(short ascender, short descender, short lineGap, ushort advanceWidthMax, short minLeftSideBearing, short minRightSideBearing, short xMaxExtent, short caretSlopeRise, short caretSlopeRun, short caretOffset, ushort numberOfHMetrics);
    private static HorizontalHeadTable();
    [CompilerGeneratedAttribute]
public ushort get_AdvanceWidthMax();
    [CompilerGeneratedAttribute]
public short get_Ascender();
    [CompilerGeneratedAttribute]
public short get_CaretOffset();
    [CompilerGeneratedAttribute]
public short get_CaretSlopeRise();
    [CompilerGeneratedAttribute]
public short get_CaretSlopeRun();
    [CompilerGeneratedAttribute]
public short get_Descender();
    [CompilerGeneratedAttribute]
public short get_LineGap();
    [CompilerGeneratedAttribute]
public short get_MinLeftSideBearing();
    [CompilerGeneratedAttribute]
public short get_MinRightSideBearing();
    [CompilerGeneratedAttribute]
public ushort get_NumberOfHMetrics();
    [CompilerGeneratedAttribute]
public short get_XMaxExtent();
    public static HorizontalHeadTable Load(IGlyphTypeface glyphTypeface);
    public static HorizontalHeadTable Load(BigEndianBinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.Fonts.Tables.InvalidFontTableException : Exception {
    [CompilerGeneratedAttribute]
private string <Table>k__BackingField;
    public string Table { get; }
    public InvalidFontTableException(string message, string table);
    [CompilerGeneratedAttribute]
public string get_Table();
}
internal enum Avalonia.Media.Fonts.Tables.KnownNameIds : Enum {
    public ushort value__;
    public static KnownNameIds CopyrightNotice;
    public static KnownNameIds FontFamilyName;
    public static KnownNameIds FontSubfamilyName;
    public static KnownNameIds UniqueFontID;
    public static KnownNameIds FullFontName;
    public static KnownNameIds Version;
    public static KnownNameIds PostscriptName;
    public static KnownNameIds Trademark;
    public static KnownNameIds Manufacturer;
    public static KnownNameIds Designer;
    public static KnownNameIds Description;
    public static KnownNameIds VendorUrl;
    public static KnownNameIds DesignerUrl;
    public static KnownNameIds LicenseDescription;
    public static KnownNameIds LicenseInfoUrl;
    public static KnownNameIds TypographicFamilyName;
    public static KnownNameIds TypographicSubfamilyName;
    public static KnownNameIds SampleText;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.Fonts.Tables.MissingFontTableException : Exception {
    [CompilerGeneratedAttribute]
private string <Table>k__BackingField;
    public string Table { get; }
    public MissingFontTableException(string message, string table);
    [CompilerGeneratedAttribute]
public string get_Table();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.Fonts.Tables.Name.NameRecord : object {
    private string value;
    [CompilerGeneratedAttribute]
private PlatformIDs <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LanguageID>k__BackingField;
    [CompilerGeneratedAttribute]
private KnownNameIds <NameID>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private StringLoader <StringReader>k__BackingField;
    public PlatformIDs Platform { get; }
    public ushort LanguageID { get; }
    public KnownNameIds NameID { get; }
    [NullableAttribute("2")]
internal StringLoader StringReader { get; private set; }
    public string Value { get; }
    public NameRecord(PlatformIDs platform, ushort languageId, KnownNameIds nameId, string value);
    [CompilerGeneratedAttribute]
public PlatformIDs get_Platform();
    [CompilerGeneratedAttribute]
public ushort get_LanguageID();
    [CompilerGeneratedAttribute]
public KnownNameIds get_NameID();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal StringLoader get_StringReader();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_StringReader(StringLoader value);
    public string get_Value();
    public static NameRecord Read(BigEndianBinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.Fonts.Tables.Name.NameTable : object {
    internal static string TableName;
    internal static OpenTypeTag Tag;
    private NameRecord[] _names;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ushort> <Languages>k__BackingField;
    public IReadOnlyList`1<ushort> Languages { get; }
    internal NameTable(NameRecord[] names, IReadOnlyList`1<ushort> languages);
    private static NameTable();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ushort> get_Languages();
    public string Id(ushort culture);
    public string FontName(ushort culture);
    public string FontFamilyName(ushort culture);
    public string FontSubFamilyName(ushort culture);
    public string GetNameById(ushort culture, KnownNameIds nameId);
    public string GetNameById(ushort culture, ushort nameId);
    public static NameTable Load(IGlyphTypeface glyphTypeface);
    public static NameTable Load(BigEndianBinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.Fonts.Tables.OS2Table : object {
    internal static string TableName;
    internal static OpenTypeTag Tag;
    private ushort styleType;
    private Byte[] panose;
    private short capHeight;
    private short familyClass;
    private short heightX;
    private string tag;
    private ushort codePageRange1;
    private ushort codePageRange2;
    private UInt32 unicodeRange1;
    private UInt32 unicodeRange2;
    private UInt32 unicodeRange3;
    private UInt32 unicodeRange4;
    private ushort breakChar;
    private ushort defaultChar;
    private ushort firstCharIndex;
    private ushort lastCharIndex;
    private ushort lowerOpticalPointSize;
    private ushort maxContext;
    private ushort upperOpticalPointSize;
    private ushort weightClass;
    private ushort widthClass;
    private short averageCharWidth;
    [CompilerGeneratedAttribute]
private FontStyleSelection <FontStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private short <TypoAscender>k__BackingField;
    [CompilerGeneratedAttribute]
private short <TypoDescender>k__BackingField;
    [CompilerGeneratedAttribute]
private short <TypoLineGap>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <WinAscent>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <WinDescent>k__BackingField;
    [CompilerGeneratedAttribute]
private short <StrikeoutPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private short <StrikeoutSize>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SubscriptXOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SubscriptXSize>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SubscriptYOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SubscriptYSize>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SuperscriptXOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SuperscriptXSize>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SuperscriptYOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private short <SuperscriptYSize>k__BackingField;
    public FontStyleSelection FontStyle { get; }
    public short TypoAscender { get; }
    public short TypoDescender { get; }
    public short TypoLineGap { get; }
    public ushort WinAscent { get; }
    public ushort WinDescent { get; }
    public short StrikeoutPosition { get; }
    public short StrikeoutSize { get; }
    public short SubscriptXOffset { get; }
    public short SubscriptXSize { get; }
    public short SubscriptYOffset { get; }
    public short SubscriptYSize { get; }
    public short SuperscriptXOffset { get; }
    public short SuperscriptXSize { get; }
    public short SuperscriptYOffset { get; }
    public short SuperscriptYSize { get; }
    public OS2Table(short averageCharWidth, ushort weightClass, ushort widthClass, ushort styleType, short subscriptXSize, short subscriptYSize, short subscriptXOffset, short subscriptYOffset, short superscriptXSize, short superscriptYSize, short superscriptXOffset, short superscriptYOffset, short strikeoutSize, short strikeoutPosition, short familyClass, Byte[] panose, UInt32 unicodeRange1, UInt32 unicodeRange2, UInt32 unicodeRange3, UInt32 unicodeRange4, string tag, FontStyleSelection fontStyle, ushort firstCharIndex, ushort lastCharIndex, short typoAscender, short typoDescender, short typoLineGap, ushort winAscent, ushort winDescent);
    public OS2Table(OS2Table version0Table, ushort codePageRange1, ushort codePageRange2, short heightX, short capHeight, ushort defaultChar, ushort breakChar, ushort maxContext);
    public OS2Table(OS2Table versionLessThan5Table, ushort lowerOpticalPointSize, ushort upperOpticalPointSize);
    private static OS2Table();
    [CompilerGeneratedAttribute]
public FontStyleSelection get_FontStyle();
    [CompilerGeneratedAttribute]
public short get_TypoAscender();
    [CompilerGeneratedAttribute]
public short get_TypoDescender();
    [CompilerGeneratedAttribute]
public short get_TypoLineGap();
    [CompilerGeneratedAttribute]
public ushort get_WinAscent();
    [CompilerGeneratedAttribute]
public ushort get_WinDescent();
    [CompilerGeneratedAttribute]
public short get_StrikeoutPosition();
    [CompilerGeneratedAttribute]
public short get_StrikeoutSize();
    [CompilerGeneratedAttribute]
public short get_SubscriptXOffset();
    [CompilerGeneratedAttribute]
public short get_SubscriptXSize();
    [CompilerGeneratedAttribute]
public short get_SubscriptYOffset();
    [CompilerGeneratedAttribute]
public short get_SubscriptYSize();
    [CompilerGeneratedAttribute]
public short get_SuperscriptXOffset();
    [CompilerGeneratedAttribute]
public short get_SuperscriptXSize();
    [CompilerGeneratedAttribute]
public short get_SuperscriptYOffset();
    [CompilerGeneratedAttribute]
public short get_SuperscriptYSize();
    public static OS2Table Load(IGlyphTypeface glyphTypeface);
    public static OS2Table Load(BigEndianBinaryReader reader);
}
internal enum Avalonia.Media.Fonts.Tables.PlatformIDs : Enum {
    public ushort value__;
    public static PlatformIDs Unicode;
    public static PlatformIDs Macintosh;
    public static PlatformIDs ISO;
    public static PlatformIDs Windows;
    public static PlatformIDs Custom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Offset: {Offset}, Length: {Length}, Value: {Value}")]
internal class Avalonia.Media.Fonts.Tables.StringLoader : object {
    [CompilerGeneratedAttribute]
private ushort <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public ushort Length { get; }
    public ushort Offset { get; }
    public string Value { get; private set; }
    public Encoding Encoding { get; }
    public StringLoader(ushort length, ushort offset, Encoding encoding);
    [CompilerGeneratedAttribute]
public ushort get_Length();
    [CompilerGeneratedAttribute]
public ushort get_Offset();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    public static StringLoader Create(BigEndianBinaryReader reader);
    public static StringLoader Create(BigEndianBinaryReader reader, Encoding encoding);
    public void LoadValue(BigEndianBinaryReader reader);
}
[FlagsAttribute]
public enum Avalonia.Media.FontSimulations : Enum {
    public byte value__;
    public static FontSimulations None;
    public static FontSimulations Bold;
    public static FontSimulations Oblique;
}
[IsReadOnlyAttribute]
internal class Avalonia.Media.FontSourceIdentifier : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Uri <Source>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; public set; }
    [NullableAttribute("2")]
public Uri Source { get; public set; }
    [NullableContextAttribute("1")]
public FontSourceIdentifier(string name, Uri source);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Uri get_Source();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(Uri value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FontSourceIdentifier left, FontSourceIdentifier right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FontSourceIdentifier left, FontSourceIdentifier right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FontSourceIdentifier other);
}
public enum Avalonia.Media.FontStretch : Enum {
    public int value__;
    public static FontStretch Normal;
    public static FontStretch UltraCondensed;
    public static FontStretch ExtraCondensed;
    public static FontStretch Condensed;
    public static FontStretch SemiCondensed;
    public static FontStretch SemiExpanded;
    public static FontStretch Expanded;
    public static FontStretch ExtraExpanded;
    public static FontStretch UltraExpanded;
}
public enum Avalonia.Media.FontStyle : Enum {
    public int value__;
    public static FontStyle Normal;
    public static FontStyle Italic;
    public static FontStyle Oblique;
}
public enum Avalonia.Media.FontWeight : Enum {
    public int value__;
    public static FontWeight Thin;
    public static FontWeight ExtraLight;
    public static FontWeight UltraLight;
    public static FontWeight Light;
    public static FontWeight SemiLight;
    public static FontWeight Normal;
    public static FontWeight Regular;
    public static FontWeight Medium;
    public static FontWeight DemiBold;
    public static FontWeight SemiBold;
    public static FontWeight Bold;
    public static FontWeight ExtraBold;
    public static FontWeight UltraBold;
    public static FontWeight Black;
    public static FontWeight Heavy;
    public static FontWeight Solid;
    public static FontWeight ExtraBlack;
    public static FontWeight UltraBlack;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.FormattedText : object {
    public static double DefaultRealToIdeal;
    public static double DefaultIdealToReal;
    public static int IdealInfiniteWidth;
    public static double RealInfiniteWidth;
    public static double GreatestMultiplierOfEm;
    private static double MaxFontEmSize;
    private string _text;
    private SpanVector _formatRuns;
    private SpanPosition _latestPosition;
    private GenericTextParagraphProperties _defaultParaProps;
    private double _maxTextWidth;
    [NullableAttribute("2")]
private Double[] _maxTextWidths;
    private double _maxTextHeight;
    private int _maxLineCount;
    private TextTrimming _trimming;
    [NullableAttribute("2")]
private TextSourceImplementation _textSourceImpl;
    [NullableAttribute("2")]
private CachedMetrics _metrics;
    public FlowDirection FlowDirection { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public double LineHeight { get; public set; }
    public double MaxTextWidth { get; public set; }
    public double MaxTextHeight { get; public set; }
    public int MaxLineCount { get; public set; }
    public TextTrimming Trimming { get; public set; }
    private CachedMetrics Metrics { get; }
    private CachedMetrics BlackBoxMetrics { get; }
    public double Height { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, IBrush foreground);
    private static void ValidateFontSize(double emSize);
    private static void ValidateFlowDirection(FlowDirection flowDirection, string parameterName);
    private int ValidateRange(int startIndex, int count);
    private void InvalidateMetrics();
    public void SetForegroundBrush(IBrush foregroundBrush);
    [NullableContextAttribute("2")]
public void SetForegroundBrush(IBrush foregroundBrush, int startIndex, int count);
    [NullableContextAttribute("2")]
public void SetFontFeatures(FontFeatureCollection fontFeatures);
    [NullableContextAttribute("2")]
public void SetFontFeatures(FontFeatureCollection fontFeatures, int startIndex, int count);
    public void SetFontFamily(string fontFamily);
    public void SetFontFamily(string fontFamily, int startIndex, int count);
    public void SetFontFamily(FontFamily fontFamily);
    public void SetFontFamily(FontFamily fontFamily, int startIndex, int count);
    public void SetFontSize(double emSize);
    public void SetFontSize(double emSize, int startIndex, int count);
    public void SetCulture(CultureInfo culture);
    public void SetCulture(CultureInfo culture, int startIndex, int count);
    public void SetFontWeight(FontWeight weight);
    public void SetFontWeight(FontWeight weight, int startIndex, int count);
    public void SetFontStyle(FontStyle style);
    public void SetFontStyle(FontStyle style, int startIndex, int count);
    public void SetFontTypeface(Typeface typeface);
    public void SetFontTypeface(Typeface typeface, int startIndex, int count);
    public void SetTextDecorations(TextDecorationCollection textDecorations);
    public void SetTextDecorations(TextDecorationCollection textDecorations, int startIndex, int count);
    private LineEnumerator GetEnumerator();
    private void AdvanceLineOrigin(Point& lineOrigin, TextLine currentLine);
    public void set_FlowDirection(FlowDirection value);
    public FlowDirection get_FlowDirection();
    public void set_TextAlignment(TextAlignment value);
    public TextAlignment get_TextAlignment();
    public void set_LineHeight(double value);
    public double get_LineHeight();
    public void set_MaxTextWidth(double value);
    public double get_MaxTextWidth();
    public void SetMaxTextWidths(Double[] maxTextWidths);
    public Double[] GetMaxTextWidths();
    public void set_MaxTextHeight(double value);
    public double get_MaxTextHeight();
    public void set_MaxLineCount(int value);
    public int get_MaxLineCount();
    public void set_Trimming(TextTrimming value);
    public TextTrimming get_Trimming();
    private CachedMetrics get_Metrics();
    private CachedMetrics get_BlackBoxMetrics();
    public double get_Height();
    public double get_Extent();
    public double get_Baseline();
    public double get_OverhangAfter();
    public double get_OverhangLeading();
    public double get_OverhangTrailing();
    public double get_Width();
    public double get_WidthIncludingTrailingWhitespace();
    [NullableContextAttribute("2")]
public Geometry BuildGeometry(Point origin);
    [NullableContextAttribute("2")]
public Geometry BuildHighlightGeometry(Point origin);
    [NullableContextAttribute("2")]
public Geometry BuildHighlightGeometry(Point origin, int startIndex, int count);
    internal void Draw(DrawingContext drawingContext, Point origin);
    [NullableContextAttribute("2")]
private void CombineGeometryRecursive(Drawing drawing, Transform& transform, GeometryGroup& accumulatedGeometry);
    private CachedMetrics DrawAndCalculateMetrics(DrawingContext drawingContext, Point drawingOffset, bool getBlackBoxMetrics);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeConverterAttribute("Avalonia.Media.GeometryTypeConverter")]
public abstract class Avalonia.Media.Geometry : AvaloniaObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Transform> TransformProperty;
    private bool _isDirty;
    private bool _canInvaldate;
    private IGeometryImpl _platformImpl;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public Rect Bounds { get; }
    internal IGeometryImpl PlatformImpl { get; }
    public Transform Transform { get; public set; }
    public double ContourLength { get; }
    private static Geometry();
    private protected Geometry(IGeometryImpl platformImpl);
    [CompilerGeneratedAttribute]
public void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(EventHandler value);
    public Rect get_Bounds();
    internal IGeometryImpl get_PlatformImpl();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    [NullableContextAttribute("1")]
public static Geometry Parse(string s);
    [NullableContextAttribute("1")]
public abstract virtual Geometry Clone();
    [NullableContextAttribute("1")]
public Rect GetRenderBounds(IPen pen);
    public bool FillContains(Point point);
    [NullableContextAttribute("1")]
public bool StrokeContains(IPen pen, Point point);
    [NullableContextAttribute("1")]
public Geometry GetWidenedGeometry(IPen pen);
    [NullableContextAttribute("1")]
protected static void AffectsGeometry(AvaloniaProperty[] properties);
    private protected abstract virtual IGeometryImpl CreateDefiningGeometry();
    protected void InvalidateGeometry();
    [NullableContextAttribute("1")]
private void TransformChanged(AvaloniaPropertyChangedEventArgs e);
    [NullableContextAttribute("1")]
private void TransformChanged(object sender, EventArgs e);
    [NullableContextAttribute("1")]
private static void AffectsGeometryInvalidate(AvaloniaPropertyChangedEventArgs e);
    public double get_ContourLength();
    [NullableContextAttribute("1")]
public static Geometry Combine(Geometry geometry1, RectangleGeometry geometry2, GeometryCombineMode combineMode, Transform transform);
    public bool TryGetPointAtDistance(double distance, Point& point);
    public bool TryGetPointAndTangentAtDistance(double distance, Point& point, Point& tangent);
    public bool TryGetSegment(double startDistance, double stopDistance, bool startOnBeginFigure, Geometry& segmentGeometry);
}
internal class Avalonia.Media.GeometryBuilder : object {
    private static double PiOver2;
    private static double Epsilon;
    [NullableContextAttribute("1")]
public static void DrawRoundedCornersRectangle(StreamGeometryContext context, RoundedRectKeypoints& keypoints);
    [NullableContextAttribute("1")]
public static void DrawRoundedCornersRectangle(StreamGeometryContext context, Rect rect, double radiusX, double radiusY);
    public static RoundedRectKeypoints CalculateRoundedCornersRectangleWinUI(Rect outerBounds, Thickness borderThickness, CornerRadius cornerRadius, BackgroundSizing sizing);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Media.GeometryCollection : AvaloniaList`1<Geometry> {
    [CompilerGeneratedAttribute]
private GeometryGroup <Parent>k__BackingField;
    public GeometryGroup Parent { get; public set; }
    [NullableContextAttribute("1")]
public GeometryCollection(IEnumerable`1<Geometry> items);
    [CompilerGeneratedAttribute]
public GeometryGroup get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(GeometryGroup value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__0_0(Geometry x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__0_1(Geometry x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__1_0(Geometry x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__1_1(Geometry x);
}
public enum Avalonia.Media.GeometryCombineMode : Enum {
    public int value__;
    public static GeometryCombineMode Union;
    public static GeometryCombineMode Intersect;
    public static GeometryCombineMode Xor;
    public static GeometryCombineMode Exclude;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.GeometryDrawing : Drawing {
    [NullableAttribute("1")]
private static IPen s_boundsPen;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Geometry> GeometryProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IBrush> BrushProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IPen> PenProperty;
    [ContentAttribute]
public Geometry Geometry { get; public set; }
    public IBrush Brush { get; public set; }
    public IPen Pen { get; public set; }
    private static GeometryDrawing();
    public Geometry get_Geometry();
    public void set_Geometry(Geometry value);
    public IBrush get_Brush();
    public void set_Brush(IBrush value);
    public IPen get_Pen();
    public void set_Pen(IPen value);
    [NullableContextAttribute("1")]
internal virtual void DrawCore(DrawingContext context);
    public virtual Rect GetBounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.GeometryGroup : Geometry {
    public static DirectProperty`2<GeometryGroup, GeometryCollection> ChildrenProperty;
    public static StyledProperty`1<FillRule> FillRuleProperty;
    private GeometryCollection _children;
    [ContentAttribute]
public GeometryCollection Children { get; public set; }
    public FillRule FillRule { get; public set; }
    private static GeometryGroup();
    public GeometryCollection get_Children();
    public void set_Children(GeometryCollection value);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public virtual Geometry Clone();
    protected void OnChildrenChanged(GeometryCollection oldChildren, GeometryCollection newChildren);
    [NullableContextAttribute("2")]
private protected sealed virtual IGeometryImpl CreateDefiningGeometry();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    internal void Invalidate();
}
public class Avalonia.Media.GeometryTypeConverter : TypeConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    [NullableContextAttribute("2")]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.GlyphMetrics : ValueType {
    [CompilerGeneratedAttribute]
private int <XBearing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <YBearing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public int XBearing { get; public set; }
    public int YBearing { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    [CompilerGeneratedAttribute]
public int get_XBearing();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_XBearing(int value);
    [CompilerGeneratedAttribute]
public int get_YBearing();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_YBearing(int value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Height(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GlyphMetrics left, GlyphMetrics right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GlyphMetrics left, GlyphMetrics right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(GlyphMetrics other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.GlyphRun : object {
    private static IPlatformRenderInterface s_renderInterface;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IRef`1<IGlyphRunImpl> _platformImpl;
    private double _fontRenderingEmSize;
    private int _biDiLevel;
    private Nullable`1<GlyphRunMetrics> _glyphRunMetrics;
    [NullableAttribute("0")]
private ReadOnlyMemory`1<char> _characters;
    private IReadOnlyList`1<GlyphInfo> _glyphInfos;
    private Nullable`1<Point> _baselineOrigin;
    private bool _hasOneCharPerCluster;
    [CompilerGeneratedAttribute]
private IGlyphTypeface <GlyphTypeface>k__BackingField;
    public IGlyphTypeface GlyphTypeface { get; }
    public double FontRenderingEmSize { get; public set; }
    public Rect Bounds { get; }
    public Rect InkBounds { get; }
    public GlyphRunMetrics Metrics { get; }
    public Point BaselineOrigin { get; public set; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<char> Characters { get; public set; }
    public IReadOnlyList`1<GlyphInfo> GlyphInfos { get; public set; }
    public int BiDiLevel { get; public set; }
    internal double Scale { get; }
    public bool IsLeftToRight { get; }
    internal IRef`1<IGlyphRunImpl> PlatformImpl { get; }
    private static GlyphRun();
    public GlyphRun(IGlyphTypeface glyphTypeface, double fontRenderingEmSize, ReadOnlyMemory`1<char> characters, IReadOnlyList`1<ushort> glyphIndices, Nullable`1<Point> baselineOrigin, int biDiLevel);
    public GlyphRun(IGlyphTypeface glyphTypeface, double fontRenderingEmSize, ReadOnlyMemory`1<char> characters, IReadOnlyList`1<GlyphInfo> glyphInfos, Nullable`1<Point> baselineOrigin, int biDiLevel);
    internal GlyphRun(IRef`1<IGlyphRunImpl> platformImpl);
    private static IReadOnlyList`1<GlyphInfo> CreateGlyphInfos(IReadOnlyList`1<ushort> glyphIndices, double fontRenderingEmSize, IGlyphTypeface glyphTypeface);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<ushort> ListToSpan(IReadOnlyList`1<ushort> list);
    [CompilerGeneratedAttribute]
public IGlyphTypeface get_GlyphTypeface();
    public double get_FontRenderingEmSize();
    public void set_FontRenderingEmSize(double value);
    public Rect get_Bounds();
    public Rect get_InkBounds();
    public GlyphRunMetrics get_Metrics();
    public Point get_BaselineOrigin();
    public void set_BaselineOrigin(Point value);
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<char> get_Characters();
    [NullableContextAttribute("0")]
public void set_Characters(ReadOnlyMemory`1<char> value);
    public IReadOnlyList`1<GlyphInfo> get_GlyphInfos();
    public void set_GlyphInfos(IReadOnlyList`1<GlyphInfo> value);
    public int get_BiDiLevel();
    public void set_BiDiLevel(int value);
    internal double get_Scale();
    public bool get_IsLeftToRight();
    internal IRef`1<IGlyphRunImpl> get_PlatformImpl();
    public Geometry BuildGeometry();
    public double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public CharacterHit GetCharacterHitFromDistance(double distance, Boolean& isInside);
    public CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public int FindGlyphIndex(int characterIndex);
    public CharacterHit FindNearestCharacterHit(int index, Double& width);
    private GlyphRunMetrics CreateGlyphRunMetrics();
    private int GetTrailingWhitespaceLength(bool isReversed, Int32& newLineLength, Int32& glyphCount);
    private int GetTrailingWhitespaceLengthRightToLeft(Int32& newLineLength, Int32& glyphCount);
    private void Set(T& field, T value);
    private IRef`1<IGlyphRunImpl> CreateGlyphRunImpl();
    public sealed virtual void Dispose();
    public IReadOnlyList`1<float> GetIntersections(float lowerLimit, float upperLimit);
    [NullableContextAttribute("2")]
public IImmutableGlyphRunReference TryCreateImmutableGlyphRunReference();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.GlyphRunDrawing : Drawing {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IBrush> ForegroundProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<GlyphRun> GlyphRunProperty;
    public IBrush Foreground { get; public set; }
    public GlyphRun GlyphRun { get; public set; }
    private static GlyphRunDrawing();
    public IBrush get_Foreground();
    public void set_Foreground(IBrush value);
    public GlyphRun get_GlyphRun();
    public void set_GlyphRun(GlyphRun value);
    [NullableContextAttribute("1")]
internal virtual void DrawCore(DrawingContext context);
    public virtual Rect GetBounds();
}
[IsReadOnlyAttribute]
public class Avalonia.Media.GlyphRunMetrics : ValueType {
    [CompilerGeneratedAttribute]
private double <Baseline>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private double <WidthIncludingTrailingWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TrailingWhitespaceLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewLineLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastCluster>k__BackingField;
    public double Baseline { get; public set; }
    public double Width { get; public set; }
    public double WidthIncludingTrailingWhitespace { get; public set; }
    public double Height { get; public set; }
    public int TrailingWhitespaceLength { get; public set; }
    public int NewLineLength { get; public set; }
    public int FirstCluster { get; public set; }
    public int LastCluster { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Baseline();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Baseline(double value);
    [CompilerGeneratedAttribute]
public double get_Width();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Width(double value);
    [CompilerGeneratedAttribute]
public double get_WidthIncludingTrailingWhitespace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WidthIncludingTrailingWhitespace(double value);
    [CompilerGeneratedAttribute]
public double get_Height();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Height(double value);
    [CompilerGeneratedAttribute]
public int get_TrailingWhitespaceLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TrailingWhitespaceLength(int value);
    [CompilerGeneratedAttribute]
public int get_NewLineLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewLineLength(int value);
    [CompilerGeneratedAttribute]
public int get_FirstCluster();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FirstCluster(int value);
    [CompilerGeneratedAttribute]
public int get_LastCluster();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LastCluster(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GlyphRunMetrics left, GlyphRunMetrics right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GlyphRunMetrics left, GlyphRunMetrics right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(GlyphRunMetrics other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.GradientBrush : Brush {
    public static StyledProperty`1<GradientSpreadMethod> SpreadMethodProperty;
    public static StyledProperty`1<GradientStops> GradientStopsProperty;
    [NullableAttribute("2")]
private IDisposable _gradientStopsSubscription;
    public GradientSpreadMethod SpreadMethod { get; public set; }
    [ContentAttribute]
public GradientStops GradientStops { get; public set; }
    private IReadOnlyList`1<IGradientStop> Avalonia.Media.IGradientBrush.GradientStops { get; }
    private static GradientBrush();
    public sealed virtual GradientSpreadMethod get_SpreadMethod();
    public void set_SpreadMethod(GradientSpreadMethod value);
    public GradientStops get_GradientStops();
    public void set_GradientStops(GradientStops value);
    private sealed virtual override IReadOnlyList`1<IGradientStop> Avalonia.Media.IGradientBrush.get_GradientStops();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    private void GradientStopsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void GradientStopChanged(Tuple`2<object, PropertyChangedEventArgs> e);
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
    public abstract virtual IImmutableBrush ToImmutable();
}
public enum Avalonia.Media.GradientSpreadMethod : Enum {
    public int value__;
    public static GradientSpreadMethod Pad;
    public static GradientSpreadMethod Reflect;
    public static GradientSpreadMethod Repeat;
}
public class Avalonia.Media.GradientStop : AvaloniaObject {
    [NullableAttribute("1")]
public static StyledProperty`1<double> OffsetProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<Color> ColorProperty;
    public double Offset { get; public set; }
    public Color Color { get; public set; }
    public GradientStop(Color color, double offset);
    private static GradientStop();
    public sealed virtual double get_Offset();
    public void set_Offset(double value);
    public sealed virtual Color get_Color();
    public void set_Color(Color value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Media.GradientStops : AvaloniaList`1<GradientStop> {
    public IReadOnlyList`1<ImmutableGradientStop> ToImmutable();
}
[IsReadOnlyAttribute]
public class Avalonia.Media.HslColor : ValueType {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <H>k__BackingField;
    [CompilerGeneratedAttribute]
private double <S>k__BackingField;
    [CompilerGeneratedAttribute]
private double <L>k__BackingField;
    public double A { get; }
    public double H { get; }
    public double S { get; }
    public double L { get; }
    public HslColor(double alpha, double hue, double saturation, double lightness);
    internal HslColor(double alpha, double hue, double saturation, double lightness, bool clampValues);
    public HslColor(Color color);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
public double get_H();
    [CompilerGeneratedAttribute]
public double get_S();
    [CompilerGeneratedAttribute]
public double get_L();
    public sealed virtual bool Equals(HslColor other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Color ToRgb();
    public HsvColor ToHsv();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static HslColor Parse(string s);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, HslColor& hslColor);
    public static HslColor FromAhsl(double a, double h, double s, double l);
    public static HslColor FromHsl(double h, double s, double l);
    public static Color ToRgb(double hue, double saturation, double lightness, double alpha);
    public static HsvColor ToHsv(double hue, double saturation, double lightness, double alpha);
    public static bool op_Equality(HslColor left, HslColor right);
    public static bool op_Inequality(HslColor left, HslColor right);
    public static Color op_Explicit(HslColor hslColor);
    [CompilerGeneratedAttribute]
internal static bool <TryParse>g__TryInternalParse|22_0(ReadOnlySpan`1<char> inString, Double& outDouble);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.HsvColor : ValueType {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <H>k__BackingField;
    [CompilerGeneratedAttribute]
private double <S>k__BackingField;
    [CompilerGeneratedAttribute]
private double <V>k__BackingField;
    public double A { get; }
    public double H { get; }
    public double S { get; }
    public double V { get; }
    public HsvColor(double alpha, double hue, double saturation, double value);
    internal HsvColor(double alpha, double hue, double saturation, double value, bool clampValues);
    public HsvColor(Color color);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
public double get_H();
    [CompilerGeneratedAttribute]
public double get_S();
    [CompilerGeneratedAttribute]
public double get_V();
    public sealed virtual bool Equals(HsvColor other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Color ToRgb();
    public HslColor ToHsl();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static HsvColor Parse(string s);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, HsvColor& hsvColor);
    public static HsvColor FromAhsv(double a, double h, double s, double v);
    public static HsvColor FromHsv(double h, double s, double v);
    public static Color ToRgb(double hue, double saturation, double value, double alpha);
    public static HslColor ToHsl(double hue, double saturation, double value, double alpha);
    public static bool op_Equality(HsvColor left, HsvColor right);
    public static bool op_Inequality(HsvColor left, HsvColor right);
    public static Color op_Explicit(HsvColor hsvColor);
    [CompilerGeneratedAttribute]
internal static bool <TryParse>g__TryInternalParse|22_0(ReadOnlySpan`1<char> inString, Double& outDouble);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Media.IAffectsRender {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Invalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Invalidated(EventHandler value);
}
public interface Avalonia.Media.IBlurEffect {
    public double Radius { get; }
    public abstract virtual double get_Radius();
}
[NullableContextAttribute("2")]
[TypeConverterAttribute("Avalonia.Media.BrushConverter")]
[NotClientImplementableAttribute]
public interface Avalonia.Media.IBrush {
    public double Opacity { get; }
    public ITransform Transform { get; }
    public RelativePoint TransformOrigin { get; }
    public abstract virtual double get_Opacity();
    public abstract virtual ITransform get_Transform();
    public abstract virtual RelativePoint get_TransformOrigin();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.IConicGradientBrush {
    public RelativePoint Center { get; }
    public double Angle { get; }
    public abstract virtual RelativePoint get_Center();
    public abstract virtual double get_Angle();
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Media.IDashStyle {
    public IReadOnlyList`1<double> Dashes { get; }
    public double Offset { get; }
    public abstract virtual IReadOnlyList`1<double> get_Dashes();
    public abstract virtual double get_Offset();
}
internal interface Avalonia.Media.IDirectionDropShadowEffect {
    public double Direction { get; }
    public double ShadowDepth { get; }
    public abstract virtual double get_Direction();
    public abstract virtual double get_ShadowDepth();
}
public interface Avalonia.Media.IDropShadowEffect {
    public double OffsetX { get; }
    public double OffsetY { get; }
    public double BlurRadius { get; }
    public Color Color { get; }
    public double Opacity { get; }
    public abstract virtual double get_OffsetX();
    public abstract virtual double get_OffsetY();
    public abstract virtual double get_BlurRadius();
    public abstract virtual Color get_Color();
    public abstract virtual double get_Opacity();
}
[TypeConverterAttribute("Avalonia.Media.EffectConverter")]
[NotClientImplementableAttribute]
public interface Avalonia.Media.IEffect {
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.IExperimentalAcrylicMaterial {
    public AcrylicBackgroundSource BackgroundSource { get; }
    public Color TintColor { get; }
    public double TintOpacity { get; }
    public Color MaterialColor { get; }
    public Color FallbackColor { get; }
    public abstract virtual AcrylicBackgroundSource get_BackgroundSource();
    public abstract virtual Color get_TintColor();
    public abstract virtual double get_TintOpacity();
    public abstract virtual Color get_MaterialColor();
    public abstract virtual Color get_FallbackColor();
}
[UnstableAttribute]
public interface Avalonia.Media.IGlyphTypeface {
    [NullableAttribute("1")]
public string FamilyName { get; }
    public FontWeight Weight { get; }
    public FontStyle Style { get; }
    public FontStretch Stretch { get; }
    public int GlyphCount { get; }
    public FontMetrics Metrics { get; }
    public FontSimulations FontSimulations { get; }
    [NullableContextAttribute("1")]
public abstract virtual string get_FamilyName();
    public abstract virtual FontWeight get_Weight();
    public abstract virtual FontStyle get_Style();
    public abstract virtual FontStretch get_Stretch();
    public abstract virtual int get_GlyphCount();
    public abstract virtual FontMetrics get_Metrics();
    public abstract virtual FontSimulations get_FontSimulations();
    public abstract virtual bool TryGetGlyphMetrics(ushort glyph, GlyphMetrics& metrics);
    public abstract virtual ushort GetGlyph(UInt32 codepoint);
    public abstract virtual bool TryGetGlyph(UInt32 codepoint, UInt16& glyph);
    public abstract virtual UInt16[] GetGlyphs(ReadOnlySpan`1<UInt32> codepoints);
    public abstract virtual int GetGlyphAdvance(ushort glyph);
    public abstract virtual Int32[] GetGlyphAdvances(ReadOnlySpan`1<ushort> glyphs);
    [NullableContextAttribute("1")]
public abstract virtual bool TryGetTable(UInt32 tag, Byte[]& table);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Media.IGlyphTypeface2 {
    public string TypographicFamilyName { get; }
    public IReadOnlyDictionary`2<ushort, string> FamilyNames { get; }
    public IReadOnlyList`1<OpenTypeTag> SupportedFeatures { get; }
    [NullableContextAttribute("2")]
public abstract virtual bool TryGetStream(Stream& stream);
    public abstract virtual string get_TypographicFamilyName();
    public abstract virtual IReadOnlyDictionary`2<ushort, string> get_FamilyNames();
    public abstract virtual IReadOnlyList`1<OpenTypeTag> get_SupportedFeatures();
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Media.IGradientBrush {
    public IReadOnlyList`1<IGradientStop> GradientStops { get; }
    public GradientSpreadMethod SpreadMethod { get; }
    public abstract virtual IReadOnlyList`1<IGradientStop> get_GradientStops();
    public abstract virtual GradientSpreadMethod get_SpreadMethod();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.IGradientStop {
    public Color Color { get; }
    public double Offset { get; }
    public abstract virtual Color get_Color();
    public abstract virtual double get_Offset();
}
[NullableContextAttribute("1")]
public interface Avalonia.Media.IImage {
    public Size Size { get; }
    public abstract virtual Size get_Size();
    public abstract virtual void Draw(DrawingContext context, Rect sourceRect, Rect destRect);
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.IImageBrush {
    [NullableAttribute("2")]
public IImageBrushSource Source { get; }
    [NullableContextAttribute("2")]
public abstract virtual IImageBrushSource get_Source();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.IImageBrushSource {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IRef`1<IBitmapImpl> Bitmap { get; }
    internal abstract virtual IRef`1<IBitmapImpl> get_Bitmap();
}
public interface Avalonia.Media.IImmutableBrush {
}
public interface Avalonia.Media.IImmutableEffect {
}
public interface Avalonia.Media.IImmutableGlyphRunReference {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IRef`1<IGlyphRunImpl> GlyphRun { get; }
    internal abstract virtual IRef`1<IGlyphRunImpl> get_GlyphRun();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.IImmutableSolidColorBrush {
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.ILinearGradientBrush {
    public RelativePoint StartPoint { get; }
    public RelativePoint EndPoint { get; }
    public abstract virtual RelativePoint get_StartPoint();
    public abstract virtual RelativePoint get_EndPoint();
}
public class Avalonia.Media.ImageBrush : TileBrush {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IImageBrushSource> SourceProperty;
    [NullableAttribute("2")]
public IImageBrushSource Source { get; public set; }
    [NullableAttribute("1")]
internal Func`2<Compositor, ServerCompositionSimpleBrush> Factory { get; }
    [NullableContextAttribute("2")]
public ImageBrush(IImageBrushSource source);
    private static ImageBrush();
    [NullableContextAttribute("2")]
public sealed virtual IImageBrushSource get_Source();
    [NullableContextAttribute("2")]
public void set_Source(IImageBrushSource value);
    [NullableContextAttribute("1")]
public sealed virtual IImmutableBrush ToImmutable();
    [NullableContextAttribute("1")]
internal virtual Func`2<Compositor, ServerCompositionSimpleBrush> get_Factory();
    [NullableContextAttribute("1")]
private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.ImageDrawing : Drawing {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IImage> ImageSourceProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<Rect> RectProperty;
    public IImage ImageSource { get; public set; }
    public Rect Rect { get; public set; }
    private static ImageDrawing();
    public IImage get_ImageSource();
    public void set_ImageSource(IImage value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    [NullableContextAttribute("1")]
internal virtual void DrawCore(DrawingContext context);
    public virtual Rect GetBounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Imaging.Bitmap : object {
    private bool _isTranscoded;
    [CompilerGeneratedAttribute]
private IRef`1<IBitmapImpl> <PlatformImpl>k__BackingField;
    public Vector Dpi { get; }
    public Size Size { get; }
    public PixelSize PixelSize { get; }
    internal IRef`1<IBitmapImpl> PlatformImpl { get; }
    private IRef`1<IBitmapImpl> Avalonia.Media.Imaging.IBitmap.PlatformImpl { get; }
    public Nullable`1<PixelFormat> Format { get; }
    public Nullable`1<AlphaFormat> AlphaFormat { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IRef`1<IBitmapImpl> Avalonia.Media.IImageBrushSource.Bitmap { get; }
    public Bitmap(string fileName);
    public Bitmap(Stream stream);
    internal Bitmap(IRef`1<IBitmapImpl> impl);
    protected Bitmap(IBitmapImpl impl);
    public Bitmap(PixelFormat format, AlphaFormat alphaFormat, IntPtr data, PixelSize size, Vector dpi, int stride);
    public static Bitmap DecodeToWidth(Stream stream, int width, BitmapInterpolationMode interpolationMode);
    public static Bitmap DecodeToHeight(Stream stream, int height, BitmapInterpolationMode interpolationMode);
    public Bitmap CreateScaledBitmap(PixelSize destinationSize, BitmapInterpolationMode interpolationMode);
    public virtual void Dispose();
    public sealed virtual Vector get_Dpi();
    public sealed virtual Size get_Size();
    public sealed virtual PixelSize get_PixelSize();
    [CompilerGeneratedAttribute]
internal IRef`1<IBitmapImpl> get_PlatformImpl();
    private sealed virtual override IRef`1<IBitmapImpl> Avalonia.Media.Imaging.IBitmap.get_PlatformImpl();
    public sealed virtual void Save(string fileName, Nullable`1<int> quality);
    public sealed virtual void Save(Stream stream, Nullable`1<int> quality);
    public virtual Nullable`1<PixelFormat> get_Format();
    public virtual Nullable`1<AlphaFormat> get_AlphaFormat();
    private protected void CopyPixelsCore(PixelRect sourceRect, IntPtr buffer, int bufferSize, int stride, ILockedFramebuffer fb);
    public virtual void CopyPixels(PixelRect sourceRect, IntPtr buffer, int bufferSize, int stride);
    public void CopyPixels(ILockedFramebuffer buffer, AlphaFormat alphaFormat);
    private sealed virtual override void Avalonia.Media.IImage.Draw(DrawingContext context, Rect sourceRect, Rect destRect);
    private static IPlatformRenderInterface GetFactory();
    private sealed virtual override IRef`1<IBitmapImpl> Avalonia.Media.IImageBrushSource.get_Bitmap();
}
public enum Avalonia.Media.Imaging.BitmapBlendingMode : Enum {
    public byte value__;
    public static BitmapBlendingMode Unspecified;
    public static BitmapBlendingMode SourceOver;
    public static BitmapBlendingMode Source;
    public static BitmapBlendingMode Destination;
    public static BitmapBlendingMode DestinationOver;
    public static BitmapBlendingMode SourceIn;
    public static BitmapBlendingMode DestinationIn;
    public static BitmapBlendingMode SourceOut;
    public static BitmapBlendingMode DestinationOut;
    public static BitmapBlendingMode SourceAtop;
    public static BitmapBlendingMode DestinationAtop;
    public static BitmapBlendingMode Xor;
    public static BitmapBlendingMode Plus;
}
public enum Avalonia.Media.Imaging.BitmapInterpolationMode : Enum {
    public byte value__;
    public static BitmapInterpolationMode Unspecified;
    public static BitmapInterpolationMode None;
    public static BitmapInterpolationMode LowQuality;
    public static BitmapInterpolationMode MediumQuality;
    public static BitmapInterpolationMode HighQuality;
}
internal class Avalonia.Media.Imaging.BitmapMemory : object {
    private int _memorySize;
    [CompilerGeneratedAttribute]
private IntPtr <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelSize <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private AlphaFormat <AlphaFormat>k__BackingField;
    public IntPtr Address { get; private set; }
    public PixelSize Size { get; }
    public int RowBytes { get; }
    public PixelFormat Format { get; }
    public AlphaFormat AlphaFormat { get; }
    public BitmapMemory(PixelFormat format, AlphaFormat alphaFormat, PixelSize size);
    private void ReleaseUnmanagedResources();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public IntPtr get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(IntPtr value);
    [CompilerGeneratedAttribute]
public PixelSize get_Size();
    [CompilerGeneratedAttribute]
public int get_RowBytes();
    [CompilerGeneratedAttribute]
public PixelFormat get_Format();
    [CompilerGeneratedAttribute]
public AlphaFormat get_AlphaFormat();
    public void CopyToRgba(AlphaFormat alphaFormat, IntPtr buffer, int stride);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.Imaging.CroppedBitmap : AvaloniaObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IImage> SourceProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<PixelRect> SourceRectProperty;
    [CompilerGeneratedAttribute]
private EventHandler Invalidated;
    public IImage Source { get; public set; }
    public PixelRect SourceRect { get; public set; }
    public Size Size { get; }
    private static CroppedBitmap();
    [NullableContextAttribute("1")]
public CroppedBitmap(IImage source, PixelRect sourceRect);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Invalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Invalidated(EventHandler value);
    public IImage get_Source();
    public void set_Source(IImage value);
    public PixelRect get_SourceRect();
    public void set_SourceRect(PixelRect value);
    [NullableContextAttribute("1")]
private void SourceChanged(AvaloniaPropertyChangedEventArgs e);
    [NullableContextAttribute("1")]
private void SourceRectChanged(AvaloniaPropertyChangedEventArgs e);
    public virtual void Dispose();
    public sealed virtual Size get_Size();
    [NullableContextAttribute("1")]
public sealed virtual void Draw(DrawingContext context, Rect sourceRect, Rect destRect);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
internal interface Avalonia.Media.Imaging.IBitmap {
    public Vector Dpi { get; }
    public PixelSize PixelSize { get; }
    public IRef`1<IBitmapImpl> PlatformImpl { get; }
    public abstract virtual Vector get_Dpi();
    public abstract virtual PixelSize get_PixelSize();
    public abstract virtual IRef`1<IBitmapImpl> get_PlatformImpl();
    public abstract virtual void Save(string fileName, Nullable`1<int> quality);
    public abstract virtual void Save(Stream stream, Nullable`1<int> quality);
}
internal interface Avalonia.Media.Imaging.IPixelFormatReader {
    public abstract virtual Rgba8888Pixel ReadNext();
    public abstract virtual void Reset(IntPtr address);
}
internal interface Avalonia.Media.Imaging.IPixelFormatWriter {
    public abstract virtual void WriteNext(Rgba8888Pixel pixel);
    public abstract virtual void Reset(IntPtr address);
}
internal static class Avalonia.Media.Imaging.PixelFormatReader : object {
    private static Rgba8888Pixel s_white;
    private static Rgba8888Pixel s_black;
    private static PixelFormatReader();
    public static bool SupportsFormat(PixelFormat format);
    private static void Read(Span`1<Rgba8888Pixel> pixels, IntPtr source, PixelSize size, int stride);
    public static void Read(Span`1<Rgba8888Pixel> pixels, IntPtr source, PixelSize size, int stride, PixelFormat format);
}
internal static class Avalonia.Media.Imaging.PixelFormatTranscoder : object {
    public static void Transcode(IntPtr source, PixelSize srcSize, int sourceStride, PixelFormat srcFormat, AlphaFormat srcAlphaFormat, IntPtr dest, int destStride, PixelFormat destFormat, AlphaFormat destAlphaFormat);
}
internal static class Avalonia.Media.Imaging.PixelFormatWriter : object {
    private static void Write(ReadOnlySpan`1<Rgba8888Pixel> pixels, IntPtr dest, PixelSize size, int stride, AlphaFormat alphaFormat, AlphaFormat srcAlphaFormat);
    private static Rgba8888Pixel GetConvertedPixel(Rgba8888Pixel pixel, AlphaFormat sourceAlpha, AlphaFormat destAlpha);
    private static Rgba8888Pixel ConvertToPremultiplied(Rgba8888Pixel pixel);
    private static Rgba8888Pixel ConvertFromPremultiplied(Rgba8888Pixel pixel);
    public static void Write(ReadOnlySpan`1<Rgba8888Pixel> pixels, IntPtr dest, PixelSize size, int stride, PixelFormat format, AlphaFormat alphaFormat, AlphaFormat srcAlphaFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Imaging.RenderTargetBitmap : Bitmap {
    [CompilerGeneratedAttribute]
private IRef`1<IRenderTargetBitmapImpl> <PlatformImpl>k__BackingField;
    internal IRef`1<IRenderTargetBitmapImpl> PlatformImpl { get; }
    public RenderTargetBitmap(PixelSize pixelSize);
    public RenderTargetBitmap(PixelSize pixelSize, Vector dpi);
    private RenderTargetBitmap(IRef`1<IRenderTargetBitmapImpl> impl);
    [CompilerGeneratedAttribute]
internal IRef`1<IRenderTargetBitmapImpl> get_PlatformImpl();
    public void Render(Visual visual);
    private static IRenderTargetBitmapImpl CreateImpl(PixelSize size, Vector dpi);
    public DrawingContext CreateDrawingContext();
    public DrawingContext CreateDrawingContext(bool clear);
    public virtual void Dispose();
}
internal class Avalonia.Media.Imaging.Rgba64Pixel : ValueType {
    public ushort R;
    public ushort G;
    public ushort B;
    public ushort A;
    public Rgba64Pixel(ushort r, ushort g, ushort b, ushort a);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Rgba64Pixel left, Rgba64Pixel right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Rgba64Pixel left, Rgba64Pixel right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Rgba64Pixel other);
}
internal class Avalonia.Media.Imaging.Rgba8888Pixel : ValueType {
    public byte R;
    public byte G;
    public byte B;
    public byte A;
    public Rgba8888Pixel(byte r, byte g, byte b, byte a);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Rgba8888Pixel left, Rgba8888Pixel right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Rgba8888Pixel left, Rgba8888Pixel right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Rgba8888Pixel other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Imaging.WriteableBitmap : Bitmap {
    [NullableAttribute("2")]
private BitmapMemory _pixelFormatMemory;
    public Nullable`1<PixelFormat> Format { get; }
    public WriteableBitmap(PixelSize size, Vector dpi, Nullable`1<PixelFormat> format, Nullable`1<AlphaFormat> alphaFormat);
    private WriteableBitmap(ValueTuple`2<IBitmapImpl, BitmapMemory> bitmapWithMem);
    private WriteableBitmap(IBitmapImpl impl, BitmapMemory pixelFormatMemory);
    public WriteableBitmap(PixelFormat format, AlphaFormat alphaFormat, IntPtr data, PixelSize size, Vector dpi, int stride);
    public virtual Nullable`1<PixelFormat> get_Format();
    public ILockedFramebuffer Lock();
    public virtual void CopyPixels(PixelRect sourceRect, IntPtr buffer, int bufferSize, int stride);
    public static WriteableBitmap Decode(Stream stream);
    public static WriteableBitmap DecodeToWidth(Stream stream, int width, BitmapInterpolationMode interpolationMode);
    public static WriteableBitmap DecodeToHeight(Stream stream, int height, BitmapInterpolationMode interpolationMode);
    private static ValueTuple`2<IBitmapImpl, BitmapMemory> CreatePlatformImpl(PixelSize size, Vector& dpi, Nullable`1<PixelFormat> format, Nullable`1<AlphaFormat> alphaFormat);
    private static IPlatformRenderInterface GetFactory();
    [CompilerGeneratedAttribute]
private void <Lock>b__7_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.ImmediateDrawingContext : object {
    private bool _ownsImpl;
    private int _currentLevel;
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<Stack`1<PushedState>> <StateStackPool>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<Stack`1<TransformContainer>> <TransformStackPool>k__BackingField;
    [NullableAttribute("2")]
private Stack`1<PushedState> _states;
    [NullableAttribute("2")]
private Stack`1<TransformContainer> _transformContainers;
    [CompilerGeneratedAttribute]
private IDrawingContextImpl <PlatformImpl>k__BackingField;
    private Matrix _currentTransform;
    private Matrix _currentContainerTransform;
    private static ThreadSafeObjectPool`1<Stack`1<PushedState>> StateStackPool { get; }
    private static ThreadSafeObjectPool`1<Stack`1<TransformContainer>> TransformStackPool { get; }
    public IDrawingContextImpl PlatformImpl { get; }
    public Matrix CurrentTransform { get; private set; }
    internal ImmediateDrawingContext(IDrawingContextImpl impl, bool ownsImpl);
    internal ImmediateDrawingContext(IDrawingContextImpl impl, Matrix transform, bool ownsImpl);
    private static ImmediateDrawingContext();
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<Stack`1<PushedState>> get_StateStackPool();
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<Stack`1<TransformContainer>> get_TransformStackPool();
    [CompilerGeneratedAttribute]
public IDrawingContextImpl get_PlatformImpl();
    public Matrix get_CurrentTransform();
    private void set_CurrentTransform(Matrix value);
    public void DrawBitmap(Bitmap source, Rect rect);
    public void DrawBitmap(Bitmap source, Rect sourceRect, Rect destRect);
    public void DrawLine(ImmutablePen pen, Point p1, Point p2);
    [NullableContextAttribute("2")]
public void DrawRectangle(IImmutableBrush brush, ImmutablePen pen, Rect rect, double radiusX, double radiusY, BoxShadows boxShadows);
    public void DrawRectangle(ImmutablePen pen, Rect rect, float cornerRadius);
    [NullableContextAttribute("2")]
public void DrawEllipse(IImmutableBrush brush, ImmutablePen pen, Point center, double radiusX, double radiusY);
    public void DrawGlyphRun(IImmutableBrush foreground, IImmutableGlyphRunReference glyphRun);
    public void FillRectangle(IImmutableBrush brush, Rect rect, float cornerRadius);
    public PushedState PushClip(RoundedRect clip);
    public PushedState PushClip(Rect clip);
    public PushedState PushOpacity(double opacity, Rect bounds);
    public PushedState PushOpacityMask(IImmutableBrush mask, Rect bounds);
    public PushedState PushPostTransform(Matrix matrix);
    public PushedState PushPreTransform(Matrix matrix);
    public PushedState PushSetTransform(Matrix matrix);
    public PushedState PushTransformContainer();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
private static bool PenIsVisible(IPen pen);
    public sealed virtual object TryGetFeature(Type type);
}
public class Avalonia.Media.Immutable.ImmutableConicGradientBrush : ImmutableGradientBrush {
    [CompilerGeneratedAttribute]
private RelativePoint <Center>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Angle>k__BackingField;
    public RelativePoint Center { get; }
    public double Angle { get; }
    [NullableContextAttribute("1")]
public ImmutableConicGradientBrush(IReadOnlyList`1<ImmutableGradientStop> gradientStops, double opacity, ImmutableTransform transform, Nullable`1<RelativePoint> transformOrigin, GradientSpreadMethod spreadMethod, Nullable`1<RelativePoint> center, double angle);
    [NullableContextAttribute("1")]
public ImmutableConicGradientBrush(ConicGradientBrush source);
    [CompilerGeneratedAttribute]
public sealed virtual RelativePoint get_Center();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Angle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Immutable.ImmutableDashStyle : object {
    private Double[] _dashes;
    [CompilerGeneratedAttribute]
private double <Offset>k__BackingField;
    public IReadOnlyList`1<double> Dashes { get; }
    public double Offset { get; }
    [NullableContextAttribute("2")]
public ImmutableDashStyle(IEnumerable`1<double> dashes, double offset);
    public sealed virtual IReadOnlyList`1<double> get_Dashes();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Offset();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IDashStyle other);
    public virtual int GetHashCode();
    private static bool SequenceEqual(Double[] left, IReadOnlyList`1<double> right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.Immutable.ImmutableGradientBrush : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IGradientStop> <GradientStops>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Opacity>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITransform <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativePoint <TransformOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private GradientSpreadMethod <SpreadMethod>k__BackingField;
    public IReadOnlyList`1<IGradientStop> GradientStops { get; }
    public double Opacity { get; }
    [NullableAttribute("2")]
public ITransform Transform { get; }
    public RelativePoint TransformOrigin { get; }
    public GradientSpreadMethod SpreadMethod { get; }
    protected ImmutableGradientBrush(IReadOnlyList`1<ImmutableGradientStop> gradientStops, double opacity, ImmutableTransform transform, Nullable`1<RelativePoint> transformOrigin, GradientSpreadMethod spreadMethod);
    protected ImmutableGradientBrush(GradientBrush source);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IGradientStop> get_GradientStops();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Opacity();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ITransform get_Transform();
    [CompilerGeneratedAttribute]
public sealed virtual RelativePoint get_TransformOrigin();
    [CompilerGeneratedAttribute]
public sealed virtual GradientSpreadMethod get_SpreadMethod();
}
public class Avalonia.Media.Immutable.ImmutableGradientStop : object {
    [CompilerGeneratedAttribute]
private double <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    public double Offset { get; }
    public Color Color { get; }
    public ImmutableGradientStop(double offset, Color color);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Offset();
    [CompilerGeneratedAttribute]
public sealed virtual Color get_Color();
}
internal class Avalonia.Media.Immutable.ImmutableImageBrush : ImmutableTileBrush {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IImageBrushSource <Source>k__BackingField;
    [NullableAttribute("2")]
public IImageBrushSource Source { get; }
    [NullableContextAttribute("2")]
public ImmutableImageBrush(Bitmap source, AlignmentX alignmentX, AlignmentY alignmentY, Nullable`1<RelativeRect> destinationRect, double opacity, ImmutableTransform transform, RelativePoint transformOrigin, Nullable`1<RelativeRect> sourceRect, Stretch stretch, TileMode tileMode);
    [NullableContextAttribute("1")]
public ImmutableImageBrush(IImageBrush source);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IImageBrushSource get_Source();
}
public class Avalonia.Media.Immutable.ImmutableLinearGradientBrush : ImmutableGradientBrush {
    [CompilerGeneratedAttribute]
private RelativePoint <StartPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativePoint <EndPoint>k__BackingField;
    public RelativePoint StartPoint { get; }
    public RelativePoint EndPoint { get; }
    [NullableContextAttribute("1")]
public ImmutableLinearGradientBrush(IReadOnlyList`1<ImmutableGradientStop> gradientStops, double opacity, ImmutableTransform transform, Nullable`1<RelativePoint> transformOrigin, GradientSpreadMethod spreadMethod, Nullable`1<RelativePoint> startPoint, Nullable`1<RelativePoint> endPoint);
    [NullableContextAttribute("1")]
public ImmutableLinearGradientBrush(LinearGradientBrush source);
    [CompilerGeneratedAttribute]
public sealed virtual RelativePoint get_StartPoint();
    [CompilerGeneratedAttribute]
public sealed virtual RelativePoint get_EndPoint();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.Immutable.ImmutablePen : object {
    [CompilerGeneratedAttribute]
private IBrush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Thickness>k__BackingField;
    [CompilerGeneratedAttribute]
private IDashStyle <DashStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private PenLineCap <LineCap>k__BackingField;
    [CompilerGeneratedAttribute]
private PenLineJoin <LineJoin>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MiterLimit>k__BackingField;
    public IBrush Brush { get; }
    public double Thickness { get; }
    public IDashStyle DashStyle { get; }
    public PenLineCap LineCap { get; }
    public PenLineJoin LineJoin { get; }
    public double MiterLimit { get; }
    public ImmutablePen(UInt32 color, double thickness, ImmutableDashStyle dashStyle, PenLineCap lineCap, PenLineJoin lineJoin, double miterLimit);
    public ImmutablePen(IImmutableBrush brush, double thickness, ImmutableDashStyle dashStyle, PenLineCap lineCap, PenLineJoin lineJoin, double miterLimit);
    [CompilerGeneratedAttribute]
public sealed virtual IBrush get_Brush();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Thickness();
    [CompilerGeneratedAttribute]
public sealed virtual IDashStyle get_DashStyle();
    [CompilerGeneratedAttribute]
public sealed virtual PenLineCap get_LineCap();
    [CompilerGeneratedAttribute]
public sealed virtual PenLineJoin get_LineJoin();
    [CompilerGeneratedAttribute]
public sealed virtual double get_MiterLimit();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IPen other);
    public virtual int GetHashCode();
}
public class Avalonia.Media.Immutable.ImmutableRadialGradientBrush : ImmutableGradientBrush {
    [CompilerGeneratedAttribute]
private RelativePoint <Center>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativePoint <GradientOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativeScalar <RadiusX>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativeScalar <RadiusY>k__BackingField;
    public RelativePoint Center { get; }
    public RelativePoint GradientOrigin { get; }
    public RelativeScalar RadiusX { get; }
    public RelativeScalar RadiusY { get; }
    [ObsoleteAttribute("Use RadiusX/RadiusY")]
public double Radius { get; }
    [NullableContextAttribute("1")]
public ImmutableRadialGradientBrush(IReadOnlyList`1<ImmutableGradientStop> gradientStops, double opacity, ImmutableTransform transform, Nullable`1<RelativePoint> transformOrigin, GradientSpreadMethod spreadMethod, Nullable`1<RelativePoint> center, Nullable`1<RelativePoint> gradientOrigin, double radius);
    [NullableContextAttribute("1")]
public ImmutableRadialGradientBrush(IReadOnlyList`1<ImmutableGradientStop> gradientStops, double opacity, ImmutableTransform transform, Nullable`1<RelativePoint> transformOrigin, GradientSpreadMethod spreadMethod, Nullable`1<RelativePoint> center, Nullable`1<RelativePoint> gradientOrigin, Nullable`1<RelativeScalar> radiusX, Nullable`1<RelativeScalar> radiusY);
    [NullableContextAttribute("1")]
public ImmutableRadialGradientBrush(RadialGradientBrush source);
    [CompilerGeneratedAttribute]
public sealed virtual RelativePoint get_Center();
    [CompilerGeneratedAttribute]
public sealed virtual RelativePoint get_GradientOrigin();
    [CompilerGeneratedAttribute]
public sealed virtual RelativeScalar get_RadiusX();
    [CompilerGeneratedAttribute]
public sealed virtual RelativeScalar get_RadiusY();
    public sealed virtual double get_Radius();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.Immutable.ImmutableSolidColorBrush : object {
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Opacity>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransform <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativePoint <TransformOrigin>k__BackingField;
    public Color Color { get; }
    public double Opacity { get; }
    public ITransform Transform { get; }
    public RelativePoint TransformOrigin { get; }
    public ImmutableSolidColorBrush(Color color, double opacity, ImmutableTransform transform);
    public ImmutableSolidColorBrush(UInt32 color);
    [NullableContextAttribute("1")]
public ImmutableSolidColorBrush(ISolidColorBrush source);
    [CompilerGeneratedAttribute]
public sealed virtual Color get_Color();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Opacity();
    [CompilerGeneratedAttribute]
public sealed virtual ITransform get_Transform();
    [CompilerGeneratedAttribute]
public sealed virtual RelativePoint get_TransformOrigin();
    public sealed virtual bool Equals(ImmutableSolidColorBrush other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static bool op_Equality(ImmutableSolidColorBrush left, ImmutableSolidColorBrush right);
    [NullableContextAttribute("1")]
public static bool op_Inequality(ImmutableSolidColorBrush left, ImmutableSolidColorBrush right);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Immutable.ImmutableTextDecoration : object {
    [CompilerGeneratedAttribute]
private TextDecorationLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutablePen <Pen>k__BackingField;
    [CompilerGeneratedAttribute]
private TextDecorationUnit <PenThicknessUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private double <PenOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private TextDecorationUnit <PenOffsetUnit>k__BackingField;
    public TextDecorationLocation Location { get; }
    public ImmutablePen Pen { get; }
    public TextDecorationUnit PenThicknessUnit { get; }
    public double PenOffset { get; }
    public TextDecorationUnit PenOffsetUnit { get; }
    public ImmutableTextDecoration(TextDecorationLocation location, ImmutablePen pen, TextDecorationUnit penThicknessUnit, double penOffset, TextDecorationUnit penOffsetUnit);
    [CompilerGeneratedAttribute]
public TextDecorationLocation get_Location();
    [CompilerGeneratedAttribute]
public ImmutablePen get_Pen();
    [CompilerGeneratedAttribute]
public TextDecorationUnit get_PenThicknessUnit();
    [CompilerGeneratedAttribute]
public double get_PenOffset();
    [CompilerGeneratedAttribute]
public TextDecorationUnit get_PenOffsetUnit();
}
public abstract class Avalonia.Media.Immutable.ImmutableTileBrush : object {
    [CompilerGeneratedAttribute]
private AlignmentX <AlignmentX>k__BackingField;
    [CompilerGeneratedAttribute]
private AlignmentY <AlignmentY>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativeRect <DestinationRect>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Opacity>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITransform <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativePoint <TransformOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private RelativeRect <SourceRect>k__BackingField;
    [CompilerGeneratedAttribute]
private Stretch <Stretch>k__BackingField;
    [CompilerGeneratedAttribute]
private TileMode <TileMode>k__BackingField;
    public AlignmentX AlignmentX { get; }
    public AlignmentY AlignmentY { get; }
    public RelativeRect DestinationRect { get; }
    public double Opacity { get; }
    [NullableAttribute("2")]
public ITransform Transform { get; }
    public RelativePoint TransformOrigin { get; }
    public RelativeRect SourceRect { get; }
    public Stretch Stretch { get; }
    public TileMode TileMode { get; }
    [NullableContextAttribute("2")]
private protected ImmutableTileBrush(AlignmentX alignmentX, AlignmentY alignmentY, RelativeRect destinationRect, double opacity, ImmutableTransform transform, RelativePoint transformOrigin, RelativeRect sourceRect, Stretch stretch, TileMode tileMode);
    [NullableContextAttribute("1")]
protected ImmutableTileBrush(ITileBrush source);
    [CompilerGeneratedAttribute]
public sealed virtual AlignmentX get_AlignmentX();
    [CompilerGeneratedAttribute]
public sealed virtual AlignmentY get_AlignmentY();
    [CompilerGeneratedAttribute]
public sealed virtual RelativeRect get_DestinationRect();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Opacity();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ITransform get_Transform();
    [CompilerGeneratedAttribute]
public sealed virtual RelativePoint get_TransformOrigin();
    [CompilerGeneratedAttribute]
public sealed virtual RelativeRect get_SourceRect();
    [CompilerGeneratedAttribute]
public sealed virtual Stretch get_Stretch();
    [CompilerGeneratedAttribute]
public sealed virtual TileMode get_TileMode();
}
public class Avalonia.Media.Immutable.ImmutableTransform : object {
    [CompilerGeneratedAttribute]
private Matrix <Value>k__BackingField;
    public Matrix Value { get; }
    public ImmutableTransform(Matrix matrix);
    [CompilerGeneratedAttribute]
public sealed virtual Matrix get_Value();
}
public class Avalonia.Media.ImmutableBlurEffect : object {
    [CompilerGeneratedAttribute]
private double <Radius>k__BackingField;
    public double Radius { get; }
    private static ImmutableBlurEffect();
    public ImmutableBlurEffect(double radius);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Radius();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IEffect other);
}
public class Avalonia.Media.ImmutableDropShadowDirectionEffect : object {
    [CompilerGeneratedAttribute]
private double <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ShadowDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BlurRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Opacity>k__BackingField;
    public double OffsetX { get; }
    public double OffsetY { get; }
    public double Direction { get; }
    public double ShadowDepth { get; }
    public double BlurRadius { get; }
    public Color Color { get; }
    public double Opacity { get; }
    private static ImmutableDropShadowDirectionEffect();
    public ImmutableDropShadowDirectionEffect(double direction, double shadowDepth, double blurRadius, Color color, double opacity);
    public sealed virtual double get_OffsetX();
    public sealed virtual double get_OffsetY();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Direction();
    [CompilerGeneratedAttribute]
public sealed virtual double get_ShadowDepth();
    [CompilerGeneratedAttribute]
public sealed virtual double get_BlurRadius();
    [CompilerGeneratedAttribute]
public sealed virtual Color get_Color();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Opacity();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IEffect other);
}
public class Avalonia.Media.ImmutableDropShadowEffect : object {
    [CompilerGeneratedAttribute]
private double <OffsetX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetY>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BlurRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Opacity>k__BackingField;
    public double OffsetX { get; }
    public double OffsetY { get; }
    public double BlurRadius { get; }
    public Color Color { get; }
    public double Opacity { get; }
    private static ImmutableDropShadowEffect();
    public ImmutableDropShadowEffect(double offsetX, double offsetY, double blurRadius, Color color, double opacity);
    [CompilerGeneratedAttribute]
public sealed virtual double get_OffsetX();
    [CompilerGeneratedAttribute]
public sealed virtual double get_OffsetY();
    [CompilerGeneratedAttribute]
public sealed virtual double get_BlurRadius();
    [CompilerGeneratedAttribute]
public sealed virtual Color get_Color();
    [CompilerGeneratedAttribute]
public sealed virtual double get_Opacity();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IEffect other);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.ImmutableExperimentalAcrylicMaterial : ValueType {
    [CompilerGeneratedAttribute]
private AcrylicBackgroundSource <BackgroundSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <TintColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <MaterialColor>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TintOpacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <FallbackColor>k__BackingField;
    public AcrylicBackgroundSource BackgroundSource { get; }
    public Color TintColor { get; }
    public Color MaterialColor { get; }
    public double TintOpacity { get; }
    public Color FallbackColor { get; }
    [NullableContextAttribute("1")]
public ImmutableExperimentalAcrylicMaterial(IExperimentalAcrylicMaterial brush);
    [CompilerGeneratedAttribute]
public sealed virtual AcrylicBackgroundSource get_BackgroundSource();
    [CompilerGeneratedAttribute]
public sealed virtual Color get_TintColor();
    [CompilerGeneratedAttribute]
public sealed virtual Color get_MaterialColor();
    [CompilerGeneratedAttribute]
public sealed virtual double get_TintOpacity();
    [CompilerGeneratedAttribute]
public sealed virtual Color get_FallbackColor();
    public sealed virtual bool Equals(ImmutableExperimentalAcrylicMaterial other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public Color GetEffectiveTintColor();
    public virtual int GetHashCode();
    public static bool op_Equality(ImmutableExperimentalAcrylicMaterial left, ImmutableExperimentalAcrylicMaterial right);
    public static bool op_Inequality(ImmutableExperimentalAcrylicMaterial left, ImmutableExperimentalAcrylicMaterial right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Media.ImmutableGeometry : Geometry {
    public ImmutableGeometry(IGeometryImpl platformImpl);
    [NullableContextAttribute("1")]
public virtual Geometry Clone();
    private protected virtual IGeometryImpl CreateDefiningGeometry();
}
internal class Avalonia.Media.ImmutableGlyphRunReference : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IRef`1<IGlyphRunImpl> <GlyphRun>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IRef`1<IGlyphRunImpl> GlyphRun { get; private set; }
    public ImmutableGlyphRunReference(IRef`1<IGlyphRunImpl> glyphRun);
    [CompilerGeneratedAttribute]
public sealed virtual IRef`1<IGlyphRunImpl> get_GlyphRun();
    [CompilerGeneratedAttribute]
private void set_GlyphRun(IRef`1<IGlyphRunImpl> value);
    public sealed virtual void Dispose();
}
internal class Avalonia.Media.ImmutableSceneBrush : ImmutableTileBrush {
    [NullableContextAttribute("1")]
public ImmutableSceneBrush(ITileBrush source);
}
[NotClientImplementableAttribute]
internal interface Avalonia.Media.IMutableBrush {
    [NullableContextAttribute("1")]
internal abstract virtual IImmutableBrush ToImmutable();
}
public interface Avalonia.Media.IMutableEffect {
    [NullableContextAttribute("1")]
internal abstract virtual IImmutableEffect ToImmutable();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.IMutableExperimentalAcrylicMaterial {
    [NullableContextAttribute("1")]
public abstract virtual IExperimentalAcrylicMaterial ToImmutable();
}
[NullableContextAttribute("1")]
public interface Avalonia.Media.IMutableTransform {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler value);
}
[NullableContextAttribute("2")]
[NotClientImplementableAttribute]
public interface Avalonia.Media.IPen {
    public IBrush Brush { get; }
    public IDashStyle DashStyle { get; }
    public PenLineCap LineCap { get; }
    public PenLineJoin LineJoin { get; }
    public double MiterLimit { get; }
    public double Thickness { get; }
    public abstract virtual IBrush get_Brush();
    public abstract virtual IDashStyle get_DashStyle();
    public abstract virtual PenLineCap get_LineCap();
    public abstract virtual PenLineJoin get_LineJoin();
    public abstract virtual double get_MiterLimit();
    public abstract virtual double get_Thickness();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.IRadialGradientBrush {
    public RelativePoint Center { get; }
    public RelativePoint GradientOrigin { get; }
    [ObsoleteAttribute("Use RadiusX/RadiusY")]
public double Radius { get; }
    public RelativeScalar RadiusX { get; }
    public RelativeScalar RadiusY { get; }
    public abstract virtual RelativePoint get_Center();
    public abstract virtual RelativePoint get_GradientOrigin();
    public abstract virtual double get_Radius();
    public abstract virtual RelativeScalar get_RadiusX();
    public abstract virtual RelativeScalar get_RadiusY();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.ISceneBrush {
    [NullableContextAttribute("2")]
public abstract virtual ISceneBrushContent CreateContent();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.ISceneBrushContent {
    [NullableAttribute("1")]
public ITileBrush Brush { get; }
    public Rect Rect { get; }
    internal bool UseScalableRasterization { get; }
    [NullableContextAttribute("1")]
public abstract virtual ITileBrush get_Brush();
    public abstract virtual Rect get_Rect();
    [NullableContextAttribute("1")]
public abstract virtual void Render(IDrawingContextImpl context, Nullable`1<Matrix> transform);
    internal abstract virtual bool get_UseScalableRasterization();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.ISolidColorBrush {
    public Color Color { get; }
    public abstract virtual Color get_Color();
}
[NotClientImplementableAttribute]
public interface Avalonia.Media.ITileBrush {
    public AlignmentX AlignmentX { get; }
    public AlignmentY AlignmentY { get; }
    public RelativeRect DestinationRect { get; }
    public RelativeRect SourceRect { get; }
    public Stretch Stretch { get; }
    public TileMode TileMode { get; }
    public abstract virtual AlignmentX get_AlignmentX();
    public abstract virtual AlignmentY get_AlignmentY();
    public abstract virtual RelativeRect get_DestinationRect();
    public abstract virtual RelativeRect get_SourceRect();
    public abstract virtual Stretch get_Stretch();
    public abstract virtual TileMode get_TileMode();
}
[TypeConverterAttribute("Avalonia.Media.TransformConverter")]
[NotClientImplementableAttribute]
public interface Avalonia.Media.ITransform {
    public Matrix Value { get; }
    public abstract virtual Matrix get_Value();
}
internal enum Avalonia.Media.KnownColor : Enum {
    public UInt32 value__;
    public static KnownColor None;
    public static KnownColor AliceBlue;
    public static KnownColor AntiqueWhite;
    public static KnownColor Aqua;
    public static KnownColor Aquamarine;
    public static KnownColor Azure;
    public static KnownColor Beige;
    public static KnownColor Bisque;
    public static KnownColor Black;
    public static KnownColor BlanchedAlmond;
    public static KnownColor Blue;
    public static KnownColor BlueViolet;
    public static KnownColor Brown;
    public static KnownColor BurlyWood;
    public static KnownColor CadetBlue;
    public static KnownColor Chartreuse;
    public static KnownColor Chocolate;
    public static KnownColor Coral;
    public static KnownColor CornflowerBlue;
    public static KnownColor Cornsilk;
    public static KnownColor Crimson;
    public static KnownColor Cyan;
    public static KnownColor DarkBlue;
    public static KnownColor DarkCyan;
    public static KnownColor DarkGoldenrod;
    public static KnownColor DarkGray;
    public static KnownColor DarkGreen;
    public static KnownColor DarkKhaki;
    public static KnownColor DarkMagenta;
    public static KnownColor DarkOliveGreen;
    public static KnownColor DarkOrange;
    public static KnownColor DarkOrchid;
    public static KnownColor DarkRed;
    public static KnownColor DarkSalmon;
    public static KnownColor DarkSeaGreen;
    public static KnownColor DarkSlateBlue;
    public static KnownColor DarkSlateGray;
    public static KnownColor DarkTurquoise;
    public static KnownColor DarkViolet;
    public static KnownColor DeepPink;
    public static KnownColor DeepSkyBlue;
    public static KnownColor DimGray;
    public static KnownColor DodgerBlue;
    public static KnownColor Firebrick;
    public static KnownColor FloralWhite;
    public static KnownColor ForestGreen;
    public static KnownColor Fuchsia;
    public static KnownColor Gainsboro;
    public static KnownColor GhostWhite;
    public static KnownColor Gold;
    public static KnownColor Goldenrod;
    public static KnownColor Gray;
    public static KnownColor Green;
    public static KnownColor GreenYellow;
    public static KnownColor Honeydew;
    public static KnownColor HotPink;
    public static KnownColor IndianRed;
    public static KnownColor Indigo;
    public static KnownColor Ivory;
    public static KnownColor Khaki;
    public static KnownColor Lavender;
    public static KnownColor LavenderBlush;
    public static KnownColor LawnGreen;
    public static KnownColor LemonChiffon;
    public static KnownColor LightBlue;
    public static KnownColor LightCoral;
    public static KnownColor LightCyan;
    public static KnownColor LightGoldenrodYellow;
    public static KnownColor LightGreen;
    public static KnownColor LightGray;
    public static KnownColor LightPink;
    public static KnownColor LightSalmon;
    public static KnownColor LightSeaGreen;
    public static KnownColor LightSkyBlue;
    public static KnownColor LightSlateGray;
    public static KnownColor LightSteelBlue;
    public static KnownColor LightYellow;
    public static KnownColor Lime;
    public static KnownColor LimeGreen;
    public static KnownColor Linen;
    public static KnownColor Magenta;
    public static KnownColor Maroon;
    public static KnownColor MediumAquamarine;
    public static KnownColor MediumBlue;
    public static KnownColor MediumOrchid;
    public static KnownColor MediumPurple;
    public static KnownColor MediumSeaGreen;
    public static KnownColor MediumSlateBlue;
    public static KnownColor MediumSpringGreen;
    public static KnownColor MediumTurquoise;
    public static KnownColor MediumVioletRed;
    public static KnownColor MidnightBlue;
    public static KnownColor MintCream;
    public static KnownColor MistyRose;
    public static KnownColor Moccasin;
    public static KnownColor NavajoWhite;
    public static KnownColor Navy;
    public static KnownColor OldLace;
    public static KnownColor Olive;
    public static KnownColor OliveDrab;
    public static KnownColor Orange;
    public static KnownColor OrangeRed;
    public static KnownColor Orchid;
    public static KnownColor PaleGoldenrod;
    public static KnownColor PaleGreen;
    public static KnownColor PaleTurquoise;
    public static KnownColor PaleVioletRed;
    public static KnownColor PapayaWhip;
    public static KnownColor PeachPuff;
    public static KnownColor Peru;
    public static KnownColor Pink;
    public static KnownColor Plum;
    public static KnownColor PowderBlue;
    public static KnownColor Purple;
    public static KnownColor Red;
    public static KnownColor RosyBrown;
    public static KnownColor RoyalBlue;
    public static KnownColor SaddleBrown;
    public static KnownColor Salmon;
    public static KnownColor SandyBrown;
    public static KnownColor SeaGreen;
    public static KnownColor SeaShell;
    public static KnownColor Sienna;
    public static KnownColor Silver;
    public static KnownColor SkyBlue;
    public static KnownColor SlateBlue;
    public static KnownColor SlateGray;
    public static KnownColor Snow;
    public static KnownColor SpringGreen;
    public static KnownColor SteelBlue;
    public static KnownColor Tan;
    public static KnownColor Teal;
    public static KnownColor Thistle;
    public static KnownColor Tomato;
    public static KnownColor Transparent;
    public static KnownColor Turquoise;
    public static KnownColor Violet;
    public static KnownColor Wheat;
    public static KnownColor White;
    public static KnownColor WhiteSmoke;
    public static KnownColor Yellow;
    public static KnownColor YellowGreen;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Media.KnownColors : object {
    private static IReadOnlyDictionary`2<string, KnownColor> _knownColorNames;
    private static IReadOnlyDictionary`2<UInt32, string> _knownColors;
    private static Dictionary`2<KnownColor, IImmutableSolidColorBrush> _knownBrushes;
    private static KnownColors();
    [GenerateEnumValueDictionaryAttribute]
private static Dictionary`2<string, KnownColor> GetKnownColors();
    public static ISolidColorBrush GetKnownBrush(string s);
    public static KnownColor GetKnownColor(string s);
    [NullableContextAttribute("2")]
public static string GetKnownColorName(UInt32 rgb);
    [NullableContextAttribute("2")]
internal static bool TryGetKnownColorName(UInt32 rgb, String& name);
    [ExtensionAttribute]
public static Color ToColor(KnownColor color);
    [ExtensionAttribute]
public static IImmutableSolidColorBrush ToBrush(KnownColor color);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.LinearGradientBrush : GradientBrush {
    public static StyledProperty`1<RelativePoint> StartPointProperty;
    public static StyledProperty`1<RelativePoint> EndPointProperty;
    public RelativePoint StartPoint { get; public set; }
    public RelativePoint EndPoint { get; public set; }
    internal Func`2<Compositor, ServerCompositionSimpleBrush> Factory { get; }
    private static LinearGradientBrush();
    public sealed virtual RelativePoint get_StartPoint();
    public void set_StartPoint(RelativePoint value);
    public sealed virtual RelativePoint get_EndPoint();
    public void set_EndPoint(RelativePoint value);
    public virtual IImmutableBrush ToImmutable();
    internal virtual Func`2<Compositor, ServerCompositionSimpleBrush> get_Factory();
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.LineGeometry : Geometry {
    public static StyledProperty`1<Point> StartPointProperty;
    public static StyledProperty`1<Point> EndPointProperty;
    public Point StartPoint { get; public set; }
    public Point EndPoint { get; public set; }
    private static LineGeometry();
    public LineGeometry(Point startPoint, Point endPoint);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    public virtual Geometry Clone();
    [NullableContextAttribute("2")]
private protected sealed virtual IGeometryImpl CreateDefiningGeometry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.LineSegment : PathSegment {
    public static StyledProperty`1<Point> PointProperty;
    public Point Point { get; public set; }
    private static LineSegment();
    public Point get_Point();
    public void set_Point(Point value);
    internal virtual void ApplyTo(StreamGeometryContext ctx);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Avalonia.Media.MaterialExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IExperimentalAcrylicMaterial ToImmutable(IExperimentalAcrylicMaterial material);
}
public class Avalonia.Media.MatrixTransform : Transform {
    [NullableAttribute("1")]
public static StyledProperty`1<Matrix> MatrixProperty;
    public Matrix Matrix { get; public set; }
    public Matrix Value { get; }
    public MatrixTransform(Matrix matrix);
    private static MatrixTransform();
    public Matrix get_Matrix();
    public void set_Matrix(Matrix value);
    public virtual Matrix get_Value();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(Matrix _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.MediaContext : object {
    private MediaContextClock _clock;
    private Stopwatch _time;
    private bool _scheduleCommitOnLastCompositionBatchCompletion;
    [NullableAttribute("2")]
private DispatcherOperation _nextRenderOp;
    [NullableAttribute("2")]
private DispatcherOperation _inputMarkerOp;
    private TimeSpan _inputMarkerAddedAt;
    private bool _isRendering;
    private bool _animationsAreWaitingForComposition;
    private double MaxSecondsWithoutInput;
    private Action _render;
    private Action _inputMarkerHandler;
    private HashSet`1<Compositor> _requestedCommits;
    private Dictionary`2<Compositor, CompositionBatch> _pendingCompositionBatches;
    private Dispatcher _dispatcher;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Action> _invokeOnRenderCallbacks;
    private Stack`1<List`1<Action>> _invokeOnRenderCallbackListPool;
    private DispatcherTimer _animationsTimer;
    private Dictionary`2<object, TopLevelInfo> _topLevels;
    public IGlobalClock Clock { get; }
    public static MediaContext Instance { get; }
    private MediaContext(Dispatcher dispatcher, TimeSpan inputStarvationTimeout);
    public IGlobalClock get_Clock();
    public void RequestAnimationFrame(Action`1<TimeSpan> action);
    private CompositionBatch CommitCompositor(Compositor compositor);
    private void CompositionBatchFinished(Compositor compositor, CompositionBatch batch);
    private void ScheduleRenderForAnimationsIfNeeded();
    private bool CommitCompositorsWithThrottling();
    private void SyncCommit(Compositor compositor, bool waitFullRender, bool catchExceptions);
    public void ImmediateRenderRequested(CompositionTarget target, bool catchExceptions);
    public void SyncDisposeCompositionTarget(CompositionTarget compositionTarget);
    private sealed virtual override void Avalonia.Rendering.Composition.ICompositorScheduler.CommitRequested(Compositor compositor);
    public static MediaContext get_Instance();
    private void ScheduleRender(bool now);
    private void InputMarkerHandler();
    private void Render();
    private void RenderCore();
    public bool IsTopLevelActive(object key);
    public void AddTopLevel(object key, ILayoutManager layoutManager, IRenderer renderer);
    public void RemoveTopLevel(object key);
    private void FireInvokeOnRenderCallbacks();
    public void BeginInvokeOnRender(Action callback);
    [CompilerGeneratedAttribute]
private void <.ctor>b__31_0(object _, EventArgs _);
}
[ExtensionAttribute]
public static class Avalonia.Media.MediaExtensions : object {
    [ExtensionAttribute]
public static Vector CalculateScaling(Stretch stretch, Size destinationSize, Size sourceSize, StretchDirection stretchDirection);
    [ExtensionAttribute]
public static Size CalculateSize(Stretch stretch, Size destinationSize, Size sourceSize, StretchDirection stretchDirection);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.PathFigure : AvaloniaObject {
    [NullableAttribute("1")]
public static StyledProperty`1<bool> IsClosedProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<bool> IsFilledProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<PathFigure, PathSegments> SegmentsProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<Point> StartPointProperty;
    [CompilerGeneratedAttribute]
private EventHandler SegmentsInvalidated;
    private PathSegments _segments;
    private IDisposable _segmentsDisposable;
    private IDisposable _segmentsPropertiesDisposable;
    public bool IsClosed { get; public set; }
    public bool IsFilled { get; public set; }
    [ContentAttribute]
public PathSegments Segments { get; public set; }
    public Point StartPoint { get; public set; }
    private static PathFigure();
    [CompilerGeneratedAttribute]
internal void add_SegmentsInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_SegmentsInvalidated(EventHandler value);
    private void OnSegmentsChanged();
    private void InvalidateSegments();
    public bool get_IsClosed();
    public void set_IsClosed(bool value);
    public bool get_IsFilled();
    public void set_IsFilled(bool value);
    public PathSegments get_Segments();
    public void set_Segments(PathSegments value);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal void ApplyTo(StreamGeometryContext ctx);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnSegmentsChanged>b__12_0(PathSegment _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnSegmentsChanged>b__12_1(PathSegment _);
    [CompilerGeneratedAttribute]
private void <OnSegmentsChanged>b__12_2(Tuple`2<object, PropertyChangedEventArgs> _);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Media.PathFigures : AvaloniaList`1<PathFigure> {
    public static PathFigures Parse(string pathData);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.PathGeometry : StreamGeometry {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<PathGeometry, PathFigures> FiguresProperty;
    [NullableAttribute("1")]
public static StyledProperty`1<FillRule> FillRuleProperty;
    private PathFigures _figures;
    private IDisposable _figuresObserver;
    private IDisposable _figuresPropertiesObserver;
    [ContentAttribute]
public PathFigures Figures { get; public set; }
    public FillRule FillRule { get; public set; }
    private static PathGeometry();
    [NullableContextAttribute("1")]
public static PathGeometry Parse(string pathData);
    public PathFigures get_Figures();
    public void set_Figures(PathFigures value);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    private protected sealed virtual IGeometryImpl CreateDefiningGeometry();
    private void OnFiguresChanged(PathFigures figures);
    [NullableContextAttribute("1")]
private void InvalidateGeometryFromSegments(object _, EventArgs __);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnFiguresChanged>b__15_0(PathFigure s);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnFiguresChanged>b__15_1(PathFigure s);
    [CompilerGeneratedAttribute]
private void <OnFiguresChanged>b__15_2(Tuple`2<object, PropertyChangedEventArgs> _);
}
public class Avalonia.Media.PathMarkupParser : object {
    [NullableAttribute("1")]
private static Dictionary`2<char, Command> s_commands;
    [NullableAttribute("2")]
private IGeometryContext _geometryContext;
    private Point _currentPoint;
    private Nullable`1<Point> _beginFigurePoint;
    private Nullable`1<Point> _previousControlPoint;
    private bool _isOpen;
    private bool _isDisposed;
    [NullableContextAttribute("1")]
public PathMarkupParser(IGeometryContext geometryContext);
    private static PathMarkupParser();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    private static Point MirrorControlPoint(Point controlPoint, Point center);
    [NullableContextAttribute("1")]
public void Parse(string pathData);
    private void CreateFigure();
    private void SetFillRule(ReadOnlySpan`1& span);
    private void CloseFigure();
    private void AddMove(ReadOnlySpan`1& span, bool relative);
    private void AddLine(ReadOnlySpan`1& span, bool relative);
    private void AddHorizontalLine(ReadOnlySpan`1& span, bool relative);
    private void AddVerticalLine(ReadOnlySpan`1& span, bool relative);
    private void AddCubicBezierCurve(ReadOnlySpan`1& span, bool relative);
    private void AddQuadraticBezierCurve(ReadOnlySpan`1& span, bool relative);
    private void AddSmoothCubicBezierCurve(ReadOnlySpan`1& span, bool relative);
    private void AddSmoothQuadraticBezierCurve(ReadOnlySpan`1& span, bool relative);
    private void AddArc(ReadOnlySpan`1& span, bool relative);
    private static bool PeekArgument(ReadOnlySpan`1<char> span);
    private static bool ReadArgument(ReadOnlySpan`1& remaining, ReadOnlySpan`1& argument);
    private static ReadOnlySpan`1<char> ReadSeparator(ReadOnlySpan`1<char> span);
    private static ReadOnlySpan`1<char> SkipWhitespace(ReadOnlySpan`1<char> span);
    private static bool ReadBool(ReadOnlySpan`1& span);
    private static double ReadDouble(ReadOnlySpan`1& span);
    private static Size ReadSize(ReadOnlySpan`1& span);
    private static Point ReadPoint(ReadOnlySpan`1& span);
    private static Point ReadRelativePoint(ReadOnlySpan`1& span, Point origin);
    private static bool ReadCommand(ReadOnlySpan`1& span, Command& command, Boolean& relative);
    [MemberNotNullAttribute("_geometryContext")]
private void ThrowIfDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.PathSegment : AvaloniaObject {
    public static StyledProperty`1<bool> IsStrokedProperty;
    public bool IsStroked { get; public set; }
    private static PathSegment();
    internal abstract virtual void ApplyTo(StreamGeometryContext ctx);
    public bool get_IsStroked();
    public void set_IsStroked(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Media.PathSegments : AvaloniaList`1<PathSegment> {
    public PathSegments(IEnumerable`1<PathSegment> collection);
    public PathSegments(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Pen : AvaloniaObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IBrush> BrushProperty;
    public static StyledProperty`1<double> ThicknessProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IDashStyle> DashStyleProperty;
    public static StyledProperty`1<PenLineCap> LineCapProperty;
    public static StyledProperty`1<PenLineJoin> LineJoinProperty;
    public static StyledProperty`1<double> MiterLimitProperty;
    [NullableAttribute("2")]
private DashStyle _subscribedToDashes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TargetWeakEventSubscriber`2<Pen, EventArgs> _weakSubscriber;
    private static WeakEvent`2<DashStyle, EventArgs> InvalidatedWeakEvent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private CompositorResourceHolder`1<ServerCompositionSimplePen> _resource;
    [NullableAttribute("2")]
public IBrush Brush { get; public set; }
    public double Thickness { get; public set; }
    [NullableAttribute("2")]
public IDashStyle DashStyle { get; public set; }
    public PenLineCap LineCap { get; public set; }
    public PenLineJoin LineJoin { get; public set; }
    public double MiterLimit { get; public set; }
    [NullableContextAttribute("2")]
public Pen(UInt32 color, double thickness, IDashStyle dashStyle, PenLineCap lineCap, PenLineJoin lineJoin, double miterLimit);
    [NullableContextAttribute("2")]
public Pen(IBrush brush, double thickness, IDashStyle dashStyle, PenLineCap lineCap, PenLineJoin lineJoin, double miterLimit);
    private static Pen();
    [NullableContextAttribute("2")]
public sealed virtual IBrush get_Brush();
    [NullableContextAttribute("2")]
public void set_Brush(IBrush value);
    public sealed virtual double get_Thickness();
    public void set_Thickness(double value);
    [NullableContextAttribute("2")]
public sealed virtual IDashStyle get_DashStyle();
    [NullableContextAttribute("2")]
public void set_DashStyle(IDashStyle value);
    public sealed virtual PenLineCap get_LineCap();
    public void set_LineCap(PenLineCap value);
    public sealed virtual PenLineJoin get_LineJoin();
    public void set_LineJoin(PenLineJoin value);
    public sealed virtual double get_MiterLimit();
    public void set_MiterLimit(double value);
    public ImmutablePen ToImmutable();
    [NullableContextAttribute("2")]
internal static bool TryModifyOrCreate(IPen& pen, IBrush brush, double thickness, IList`1<double> strokeDashArray, double strokeDaskOffset, PenLineCap lineCap, PenLineJoin lineJoin, double miterLimit);
    private void RegisterForSerialization();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    private void UpdateDashStyleSubscription();
    private sealed virtual override IPen Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource<Avalonia.Media.IPen>.GetForCompositor(Compositor c);
    private sealed virtual override void Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource.AddRefOnCompositor(Compositor c);
    private sealed virtual override void Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource.ReleaseOnCompositor(Compositor c);
    private sealed virtual override SimpleServerObject Avalonia.Rendering.Composition.ICompositorSerializable.TryGetServer(Compositor c);
    private sealed virtual override void Avalonia.Rendering.Composition.ICompositorSerializable.SerializeChanges(Compositor c, BatchStreamWriter writer);
}
public enum Avalonia.Media.PenLineCap : Enum {
    public int value__;
    public static PenLineCap Flat;
    public static PenLineCap Round;
    public static PenLineCap Square;
}
public enum Avalonia.Media.PenLineJoin : Enum {
    public int value__;
    public static PenLineJoin Bevel;
    public static PenLineJoin Miter;
    public static PenLineJoin Round;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.PlatformDrawingContext : DrawingContext {
    private IDrawingContextImpl _impl;
    private bool _ownsImpl;
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<Stack`1<Matrix>> <TransformStackPool>k__BackingField;
    [NullableAttribute("2")]
private Stack`1<Matrix> _transforms;
    private static ThreadSafeObjectPool`1<Stack`1<Matrix>> TransformStackPool { get; }
    public PlatformDrawingContext(IDrawingContextImpl impl, bool ownsImpl);
    private static PlatformDrawingContext();
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<Stack`1<Matrix>> get_TransformStackPool();
    protected virtual void DrawLineCore(IPen pen, Point p1, Point p2);
    [NullableContextAttribute("2")]
protected virtual void DrawGeometryCore(IBrush brush, IPen pen, IGeometryImpl geometry);
    [NullableContextAttribute("2")]
protected virtual void DrawRectangleCore(IBrush brush, IPen pen, RoundedRect rrect, BoxShadows boxShadows);
    [NullableContextAttribute("2")]
protected virtual void DrawEllipseCore(IBrush brush, IPen pen, Rect rect);
    internal virtual void DrawBitmap(IRef`1<IBitmapImpl> source, double opacity, Rect sourceRect, Rect destRect);
    public virtual void Custom(ICustomDrawOperation custom);
    public virtual void DrawGlyphRun(IBrush foreground, GlyphRun glyphRun);
    protected virtual void PushClipCore(RoundedRect rect);
    protected virtual void PushClipCore(Rect rect);
    protected virtual void PushGeometryClipCore(Geometry clip);
    protected virtual void PushOpacityCore(double opacity);
    protected virtual void PushOpacityMaskCore(IBrush mask, Rect bounds);
    protected virtual void PushTransformCore(Matrix matrix);
    protected virtual void PushRenderOptionsCore(RenderOptions renderOptions);
    protected virtual void PopClipCore();
    protected virtual void PopGeometryClipCore();
    protected virtual void PopOpacityCore();
    protected virtual void PopOpacityMaskCore();
    protected virtual void PopTransformCore();
    protected virtual void PopRenderOptionsCore();
    protected virtual void DisposeCore();
    public void DrawRectangle(IExperimentalAcrylicMaterial material, RoundedRect rect);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.PlatformGeometry : Geometry {
    private IGeometryImpl _geometryImpl;
    public PlatformGeometry(IGeometryImpl geometryImpl);
    public virtual Geometry Clone();
    [NullableContextAttribute("2")]
private protected virtual IGeometryImpl CreateDefiningGeometry();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.PolyBezierSegment : PathSegment {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<PolyBezierSegment, Points> PointsProperty;
    private Points _points;
    [ContentAttribute]
public Points Points { get; public set; }
    [NullableContextAttribute("1")]
public PolyBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    private static PolyBezierSegment();
    public Points get_Points();
    public void set_Points(Points value);
    [NullableContextAttribute("1")]
internal virtual void ApplyTo(StreamGeometryContext ctx);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.PolylineGeometry : Geometry {
    public static DirectProperty`2<PolylineGeometry, IList`1<Point>> PointsProperty;
    public static StyledProperty`1<bool> IsFilledProperty;
    private IList`1<Point> _points;
    [NullableAttribute("2")]
private IDisposable _pointsObserver;
    [ContentAttribute]
public IList`1<Point> Points { get; public set; }
    public bool IsFilled { get; public set; }
    private static PolylineGeometry();
    public PolylineGeometry(IEnumerable`1<Point> points, bool isFilled);
    public IList`1<Point> get_Points();
    public void set_Points(IList`1<Point> value);
    public bool get_IsFilled();
    public void set_IsFilled(bool value);
    public virtual Geometry Clone();
    [NullableContextAttribute("2")]
private protected sealed virtual IGeometryImpl CreateDefiningGeometry();
    [NullableContextAttribute("2")]
private void OnPointsChanged(IList`1<Point> newValue);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnPointsChanged>b__15_0(NotifyCollectionChangedEventArgs _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.PolyLineSegment : PathSegment {
    public static StyledProperty`1<IList`1<Point>> PointsProperty;
    public IList`1<Point> Points { get; public set; }
    public PolyLineSegment(IEnumerable`1<Point> points);
    private static PolyLineSegment();
    public IList`1<Point> get_Points();
    public void set_Points(IList`1<Point> value);
    internal virtual void ApplyTo(StreamGeometryContext ctx);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Media.PreciseEllipticArcHelper : object {
    public static void ArcTo(StreamGeometryContext streamGeometryContextImpl, Point currentPoint, Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.QuadraticBezierSegment : PathSegment {
    public static StyledProperty`1<Point> Point1Property;
    public static StyledProperty`1<Point> Point2Property;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    private static QuadraticBezierSegment();
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    internal virtual void ApplyTo(StreamGeometryContext ctx);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.RadialGradientBrush : GradientBrush {
    public static StyledProperty`1<RelativePoint> CenterProperty;
    public static StyledProperty`1<RelativePoint> GradientOriginProperty;
    [ObsoleteAttribute("Use RadiusX/RadiusY, note that those properties use _relative_ values, so Radius=0.55 would become RadiusX=55% RadiusY=55%. Radius property is always relative even if the rest of the brush uses absolute values.")]
public static StyledProperty`1<double> RadiusProperty;
    public static StyledProperty`1<RelativeScalar> RadiusXProperty;
    public static StyledProperty`1<RelativeScalar> RadiusYProperty;
    public RelativePoint Center { get; public set; }
    public RelativePoint GradientOrigin { get; public set; }
    [DependsOnAttribute("Radius")]
public RelativeScalar RadiusX { get; public set; }
    [DependsOnAttribute("Radius")]
public RelativeScalar RadiusY { get; public set; }
    [ObsoleteAttribute("Use RadiusX/RadiusY, note that those properties use _relative_ values, so Radius=0.55 would become RadiusX=55% RadiusY=55%. Radius property is always relative even if the rest of the brush uses absolute values.")]
public double Radius { get; public set; }
    internal Func`2<Compositor, ServerCompositionSimpleBrush> Factory { get; }
    private static RadialGradientBrush();
    public sealed virtual RelativePoint get_Center();
    public void set_Center(RelativePoint value);
    public sealed virtual RelativePoint get_GradientOrigin();
    public void set_GradientOrigin(RelativePoint value);
    public sealed virtual RelativeScalar get_RadiusX();
    public void set_RadiusX(RelativeScalar value);
    public sealed virtual RelativeScalar get_RadiusY();
    public void set_RadiusY(RelativeScalar value);
    public sealed virtual double get_Radius();
    public void set_Radius(double value);
    public virtual IImmutableBrush ToImmutable();
    internal virtual Func`2<Compositor, ServerCompositionSimpleBrush> get_Factory();
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.RectangleGeometry : Geometry {
    public static StyledProperty`1<double> RadiusXProperty;
    public static StyledProperty`1<double> RadiusYProperty;
    public static StyledProperty`1<Rect> RectProperty;
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Rect Rect { get; public set; }
    private static RectangleGeometry();
    public RectangleGeometry(Rect rect);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    public virtual Geometry Clone();
    [NullableContextAttribute("2")]
private protected sealed virtual IGeometryImpl CreateDefiningGeometry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Avalonia.Media.RenderOptions : ValueType {
    [CompilerGeneratedAttribute]
private BitmapInterpolationMode <BitmapInterpolationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private EdgeMode <EdgeMode>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRenderingMode <TextRenderingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BitmapBlendingMode <BitmapBlendingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RequiresFullOpacityHandling>k__BackingField;
    public BitmapInterpolationMode BitmapInterpolationMode { get; public set; }
    public EdgeMode EdgeMode { get; public set; }
    public TextRenderingMode TextRenderingMode { get; public set; }
    public BitmapBlendingMode BitmapBlendingMode { get; public set; }
    public Nullable`1<bool> RequiresFullOpacityHandling { get; public set; }
    [CompilerGeneratedAttribute]
public BitmapInterpolationMode get_BitmapInterpolationMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BitmapInterpolationMode(BitmapInterpolationMode value);
    [CompilerGeneratedAttribute]
public EdgeMode get_EdgeMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EdgeMode(EdgeMode value);
    [CompilerGeneratedAttribute]
public TextRenderingMode get_TextRenderingMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TextRenderingMode(TextRenderingMode value);
    [CompilerGeneratedAttribute]
public BitmapBlendingMode get_BitmapBlendingMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BitmapBlendingMode(BitmapBlendingMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_RequiresFullOpacityHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RequiresFullOpacityHandling(Nullable`1<bool> value);
    public static BitmapInterpolationMode GetBitmapInterpolationMode(Visual visual);
    public static void SetBitmapInterpolationMode(Visual visual, BitmapInterpolationMode value);
    public static BitmapBlendingMode GetBitmapBlendingMode(Visual visual);
    public static void SetBitmapBlendingMode(Visual visual, BitmapBlendingMode value);
    public static EdgeMode GetEdgeMode(Visual visual);
    public static void SetEdgeMode(Visual visual, EdgeMode value);
    public static TextRenderingMode GetTextRenderingMode(Visual visual);
    public static void SetTextRenderingMode(Visual visual, TextRenderingMode value);
    public static Nullable`1<bool> GetRequiresFullOpacityHandling(Visual visual);
    public static void SetRequiresFullOpacityHandling(Visual visual, Nullable`1<bool> value);
    public RenderOptions MergeWith(RenderOptions other);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RenderOptions left, RenderOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RenderOptions left, RenderOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RenderOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Rotate3DTransform : Transform {
    private bool _isInitializing;
    public static StyledProperty`1<double> AngleXProperty;
    public static StyledProperty`1<double> AngleYProperty;
    public static StyledProperty`1<double> AngleZProperty;
    public static StyledProperty`1<double> CenterXProperty;
    public static StyledProperty`1<double> CenterYProperty;
    public static StyledProperty`1<double> CenterZProperty;
    public static StyledProperty`1<double> DepthProperty;
    public double AngleX { get; public set; }
    public double AngleY { get; public set; }
    public double AngleZ { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public double Depth { get; public set; }
    public Matrix Value { get; }
    public Rotate3DTransform(double angleX, double angleY, double angleZ, double centerX, double centerY, double centerZ, double depth);
    private static Rotate3DTransform();
    public double get_AngleX();
    public void set_AngleX(double value);
    public double get_AngleY();
    public void set_AngleY(double value);
    public double get_AngleZ();
    public void set_AngleZ(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    public double get_Depth();
    public void set_Depth(double value);
    public virtual Matrix get_Value();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.RotateTransform : Transform {
    public static StyledProperty`1<double> AngleProperty;
    public static StyledProperty`1<double> CenterXProperty;
    public static StyledProperty`1<double> CenterYProperty;
    public double Angle { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    public RotateTransform(double angle);
    public RotateTransform(double angle, double centerX, double centerY);
    private static RotateTransform();
    public double get_Angle();
    public void set_Angle(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public virtual Matrix get_Value();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(double _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.ScaleTransform : Transform {
    public static StyledProperty`1<double> ScaleXProperty;
    public static StyledProperty`1<double> ScaleYProperty;
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public Matrix Value { get; }
    public ScaleTransform(double scaleX, double scaleY);
    private static ScaleTransform();
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public virtual Matrix get_Value();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.SkewTransform : Transform {
    public static StyledProperty`1<double> AngleXProperty;
    public static StyledProperty`1<double> AngleYProperty;
    public double AngleX { get; public set; }
    public double AngleY { get; public set; }
    public Matrix Value { get; }
    public SkewTransform(double angleX, double angleY);
    private static SkewTransform();
    public double get_AngleX();
    public void set_AngleX(double value);
    public double get_AngleY();
    public void set_AngleY(double value);
    public virtual Matrix get_Value();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.SolidColorBrush : Brush {
    public static StyledProperty`1<Color> ColorProperty;
    public Color Color { get; public set; }
    internal Func`2<Compositor, ServerCompositionSimpleBrush> Factory { get; }
    public SolidColorBrush(Color color, double opacity);
    public SolidColorBrush(UInt32 color);
    private static SolidColorBrush();
    public sealed virtual Color get_Color();
    public void set_Color(Color value);
    public static SolidColorBrush Parse(string s);
    public virtual string ToString();
    public sealed virtual IImmutableBrush ToImmutable();
    internal virtual Func`2<Compositor, ServerCompositionSimpleBrush> get_Factory();
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.StreamGeometry : Geometry {
    [NullableAttribute("2")]
private IStreamGeometryImpl _impl;
    private StreamGeometry(IStreamGeometryImpl impl);
    public static StreamGeometry Parse(string s);
    public virtual Geometry Clone();
    public StreamGeometryContext Open();
    [NullableContextAttribute("2")]
private protected virtual IGeometryImpl CreateDefiningGeometry();
}
public class Avalonia.Media.StreamGeometryContext : object {
    [NullableAttribute("1")]
private IStreamGeometryContextImpl _impl;
    private Point _currentPoint;
    [NullableContextAttribute("1")]
public StreamGeometryContext(IStreamGeometryContextImpl impl);
    public sealed virtual void SetFillRule(FillRule fillRule);
    public sealed virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection);
    public void PreciseArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection);
    public sealed virtual void BeginFigure(Point startPoint, bool isFilled);
    public sealed virtual void CubicBezierTo(Point controlPoint1, Point controlPoint2, Point endPoint);
    public sealed virtual void QuadraticBezierTo(Point controlPoint, Point endPoint);
    public sealed virtual void LineTo(Point endPoint);
    public sealed virtual void EndFigure(bool isClosed);
    public sealed virtual void Dispose();
    public sealed virtual void LineTo(Point point, bool isStroked);
    public sealed virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked);
    public sealed virtual void CubicBezierTo(Point controlPoint1, Point controlPoint2, Point endPoint, bool isStroked);
    public sealed virtual void QuadraticBezierTo(Point controlPoint, Point endPoint, bool isStroked);
}
public enum Avalonia.Media.Stretch : Enum {
    public int value__;
    public static Stretch None;
    public static Stretch Fill;
    public static Stretch Uniform;
    public static Stretch UniformToFill;
}
public enum Avalonia.Media.StretchDirection : Enum {
    public int value__;
    public static StretchDirection UpOnly;
    public static StretchDirection DownOnly;
    public static StretchDirection Both;
}
public enum Avalonia.Media.SweepDirection : Enum {
    public int value__;
    public static SweepDirection CounterClockwise;
    public static SweepDirection Clockwise;
}
public enum Avalonia.Media.TextAlignment : Enum {
    public int value__;
    public static TextAlignment Left;
    public static TextAlignment Center;
    public static TextAlignment Right;
    public static TextAlignment Start;
    public static TextAlignment End;
    public static TextAlignment DetectFromContent;
    public static TextAlignment Justify;
}
[IsReadOnlyAttribute]
public class Avalonia.Media.TextCollapsingCreateInfo : ValueType {
    public double Width;
    [NullableAttribute("1")]
public TextRunProperties TextRunProperties;
    public FlowDirection FlowDirection;
    [NullableContextAttribute("1")]
public TextCollapsingCreateInfo(double width, TextRunProperties textRunProperties, FlowDirection flowDirection);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TextCollapsingCreateInfo left, TextCollapsingCreateInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TextCollapsingCreateInfo left, TextCollapsingCreateInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextCollapsingCreateInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextDecoration : AvaloniaObject {
    public static StyledProperty`1<TextDecorationLocation> LocationProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IBrush> StrokeProperty;
    public static StyledProperty`1<TextDecorationUnit> StrokeThicknessUnitProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<AvaloniaList`1<double>> StrokeDashArrayProperty;
    public static StyledProperty`1<double> StrokeDashOffsetProperty;
    public static StyledProperty`1<double> StrokeThicknessProperty;
    public static StyledProperty`1<PenLineCap> StrokeLineCapProperty;
    public static StyledProperty`1<double> StrokeOffsetProperty;
    public static StyledProperty`1<TextDecorationUnit> StrokeOffsetUnitProperty;
    public TextDecorationLocation Location { get; public set; }
    [NullableAttribute("2")]
public IBrush Stroke { get; public set; }
    public TextDecorationUnit StrokeThicknessUnit { get; public set; }
    [NullableAttribute("2")]
public AvaloniaList`1<double> StrokeDashArray { get; public set; }
    public double StrokeDashOffset { get; public set; }
    public double StrokeThickness { get; public set; }
    public PenLineCap StrokeLineCap { get; public set; }
    public double StrokeOffset { get; public set; }
    public TextDecorationUnit StrokeOffsetUnit { get; public set; }
    private static TextDecoration();
    public TextDecorationLocation get_Location();
    public void set_Location(TextDecorationLocation value);
    [NullableContextAttribute("2")]
public IBrush get_Stroke();
    [NullableContextAttribute("2")]
public void set_Stroke(IBrush value);
    public TextDecorationUnit get_StrokeThicknessUnit();
    public void set_StrokeThicknessUnit(TextDecorationUnit value);
    [NullableContextAttribute("2")]
public AvaloniaList`1<double> get_StrokeDashArray();
    [NullableContextAttribute("2")]
public void set_StrokeDashArray(AvaloniaList`1<double> value);
    public double get_StrokeDashOffset();
    public void set_StrokeDashOffset(double value);
    public double get_StrokeThickness();
    public void set_StrokeThickness(double value);
    public PenLineCap get_StrokeLineCap();
    public void set_StrokeLineCap(PenLineCap value);
    public double get_StrokeOffset();
    public void set_StrokeOffset(double value);
    public TextDecorationUnit get_StrokeOffsetUnit();
    public void set_StrokeOffsetUnit(TextDecorationUnit value);
    internal void Draw(DrawingContext drawingContext, GlyphRun glyphRun, TextMetrics textMetrics, IBrush defaultBrush);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Media.TextDecorationCollection : AvaloniaList`1<TextDecoration> {
    public TextDecorationCollection(IEnumerable`1<TextDecoration> textDecorations);
    public static TextDecorationCollection Parse(string s);
    private static TextDecorationLocation GetTextDecorationLocation(string s);
}
public enum Avalonia.Media.TextDecorationLocation : Enum {
    public int value__;
    public static TextDecorationLocation Underline;
    public static TextDecorationLocation Overline;
    public static TextDecorationLocation Strikethrough;
    public static TextDecorationLocation Baseline;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Media.TextDecorations : object {
    [CompilerGeneratedAttribute]
private static TextDecorationCollection <Underline>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextDecorationCollection <Strikethrough>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextDecorationCollection <Overline>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextDecorationCollection <Baseline>k__BackingField;
    public static TextDecorationCollection Underline { get; }
    public static TextDecorationCollection Strikethrough { get; }
    public static TextDecorationCollection Overline { get; }
    public static TextDecorationCollection Baseline { get; }
    private static TextDecorations();
    [CompilerGeneratedAttribute]
public static TextDecorationCollection get_Underline();
    [CompilerGeneratedAttribute]
public static TextDecorationCollection get_Strikethrough();
    [CompilerGeneratedAttribute]
public static TextDecorationCollection get_Overline();
    [CompilerGeneratedAttribute]
public static TextDecorationCollection get_Baseline();
}
public enum Avalonia.Media.TextDecorationUnit : Enum {
    public int value__;
    public static TextDecorationUnit FontRecommended;
    public static TextDecorationUnit FontRenderingEmSize;
    public static TextDecorationUnit Pixel;
}
internal class Avalonia.Media.TextFormatting.BidiReorderer : object {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static BidiReorderer t_instance;
    private ArrayBuilder`1<OrderedBidiRun> _runs;
    private ArrayBuilder`1<BidiRange> _ranges;
    [NullableAttribute("1")]
public static BidiReorderer Instance { get; }
    [NullableContextAttribute("1")]
public static BidiReorderer get_Instance();
    [NullableContextAttribute("1")]
public IndexedTextRun[] BidiReorder(Span`1<TextRun> textRuns, FlowDirection flowDirection, int firstTextSourceIndex);
    [NullableContextAttribute("1")]
private static sbyte GetRunBidiLevel(TextRun run, FlowDirection flowDirection, Nullable`1<sbyte> previousLevel);
    private int LinearReorder();
    private int MergeRangeWithPrevious(int index);
}
public abstract class Avalonia.Media.TextFormatting.DrawableTextRun : TextRun {
    public Size Size { get; }
    public double Baseline { get; }
    public abstract virtual Size get_Size();
    public abstract virtual double get_Baseline();
    [NullableContextAttribute("1")]
public abstract virtual void Draw(DrawingContext drawingContext, Point origin);
}
[IsReadOnlyAttribute]
internal class Avalonia.Media.TextFormatting.FormattedTextSource : ValueType {
    [NullableAttribute("1")]
private string _text;
    [NullableAttribute("1")]
private TextRunProperties _defaultProperties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<ValueSpan`1<TextRunProperties>> _textModifier;
    [NullableContextAttribute("1")]
public FormattedTextSource(string text, TextRunProperties defaultProperties, IReadOnlyList`1<ValueSpan`1<TextRunProperties>> textModifier);
    [NullableContextAttribute("2")]
public sealed virtual TextRun GetTextRun(int textSourceIndex);
    internal static ValueSpan`1<TextRunProperties> CreateTextStyleRun(ReadOnlySpan`1<char> text, int firstTextSourceIndex, TextRunProperties defaultProperties, IReadOnlyList`1<ValueSpan`1<TextRunProperties>> textModifier);
    private static int CoerceLength(ReadOnlySpan`1<char> text, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Media.TextFormatting.FormattingBufferHelper : object {
    private static long MaxKeptBufferSizeInBytes;
    [NullableContextAttribute("2")]
public static void ClearThenResetIfTooLarge(ArrayBuilder`1& arrayBuilder);
    public static void ClearThenResetIfTooLarge(List`1<T> list);
    public static void ClearThenResetIfTooLarge(Stack`1<T> stack);
    public static void ClearThenResetIfTooLarge(Dictionary`2& dictionary);
    [NullableContextAttribute("2")]
private static bool IsBufferTooLarge(UInt32 capacity);
    private static UInt32 RoundUpToPowerOf2(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.TextFormatting.FormattingObjectPool : object {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static FormattingObjectPool t_instance;
    [CompilerGeneratedAttribute]
private ListPool`1<TextRun> <TextRunLists>k__BackingField;
    [CompilerGeneratedAttribute]
private ListPool`1<UnshapedTextRun> <UnshapedTextRunLists>k__BackingField;
    [CompilerGeneratedAttribute]
private ListPool`1<TextLine> <TextLines>k__BackingField;
    public static FormattingObjectPool Instance { get; }
    public ListPool`1<TextRun> TextRunLists { get; }
    public ListPool`1<UnshapedTextRun> UnshapedTextRunLists { get; }
    public ListPool`1<TextLine> TextLines { get; }
    public static FormattingObjectPool get_Instance();
    [CompilerGeneratedAttribute]
public ListPool`1<TextRun> get_TextRunLists();
    [CompilerGeneratedAttribute]
public ListPool`1<UnshapedTextRun> get_UnshapedTextRunLists();
    [CompilerGeneratedAttribute]
public ListPool`1<TextLine> get_TextLines();
    [ConditionalAttribute("DEBUG")]
public void VerifyAllReturned();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.GenericTextParagraphProperties : TextParagraphProperties {
    private FlowDirection _flowDirection;
    private TextAlignment _textAlignment;
    private TextWrapping _textWrap;
    private double _lineHeight;
    [CompilerGeneratedAttribute]
private bool <FirstLineInParagraph>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysCollapsible>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRunProperties <DefaultTextRunProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LetterSpacing>k__BackingField;
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public bool AlwaysCollapsible { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextWrapping TextWrapping { get; }
    public double Indent { get; }
    public double LetterSpacing { get; }
    public GenericTextParagraphProperties(TextRunProperties defaultTextRunProperties, TextAlignment textAlignment, TextWrapping textWrap, double lineHeight, double letterSpacing);
    public GenericTextParagraphProperties(FlowDirection flowDirection, TextAlignment textAlignment, bool firstLineInParagraph, bool alwaysCollapsible, TextRunProperties defaultTextRunProperties, TextWrapping textWrap, double lineHeight, double indent, double letterSpacing);
    public GenericTextParagraphProperties(TextParagraphProperties textParagraphProperties);
    public virtual FlowDirection get_FlowDirection();
    public virtual TextAlignment get_TextAlignment();
    public virtual double get_LineHeight();
    [CompilerGeneratedAttribute]
public virtual bool get_FirstLineInParagraph();
    [CompilerGeneratedAttribute]
public virtual bool get_AlwaysCollapsible();
    [CompilerGeneratedAttribute]
public virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextWrapping get_TextWrapping();
    [CompilerGeneratedAttribute]
public virtual double get_Indent();
    [CompilerGeneratedAttribute]
public virtual double get_LetterSpacing();
    internal void SetFlowDirection(FlowDirection flowDirection);
    internal void SetTextAlignment(TextAlignment textAlignment);
    internal void SetLineHeight(double lineHeight);
    internal void SetTextWrapping(TextWrapping textWrap);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.GenericTextRunProperties : TextRunProperties {
    private static double DefaultFontRenderingEmSize;
    [CompilerGeneratedAttribute]
private Typeface <Typeface>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FontRenderingEmSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TextDecorationCollection <TextDecorations>k__BackingField;
    [CompilerGeneratedAttribute]
private IBrush <ForegroundBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private IBrush <BackgroundBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private FontFeatureCollection <FontFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private BaselineAlignment <BaselineAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public IBrush ForegroundBrush { get; }
    public IBrush BackgroundBrush { get; }
    public FontFeatureCollection FontFeatures { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public CultureInfo CultureInfo { get; }
    public GenericTextRunProperties(Typeface typeface, double fontRenderingEmSize, TextDecorationCollection textDecorations, IBrush foregroundBrush, IBrush backgroundBrush, BaselineAlignment baselineAlignment, CultureInfo cultureInfo);
    public GenericTextRunProperties(Typeface typeface, FontFeatureCollection fontFeatures, double fontRenderingEmSize, TextDecorationCollection textDecorations, IBrush foregroundBrush, IBrush backgroundBrush, BaselineAlignment baselineAlignment, CultureInfo cultureInfo);
    [CompilerGeneratedAttribute]
public virtual Typeface get_Typeface();
    [CompilerGeneratedAttribute]
public virtual double get_FontRenderingEmSize();
    [CompilerGeneratedAttribute]
public virtual TextDecorationCollection get_TextDecorations();
    [CompilerGeneratedAttribute]
public virtual IBrush get_ForegroundBrush();
    [CompilerGeneratedAttribute]
public virtual IBrush get_BackgroundBrush();
    [CompilerGeneratedAttribute]
public virtual FontFeatureCollection get_FontFeatures();
    [CompilerGeneratedAttribute]
public virtual BaselineAlignment get_BaselineAlignment();
    [CompilerGeneratedAttribute]
public virtual CultureInfo get_CultureInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.GlyphInfo : ValueType {
    [CompilerGeneratedAttribute]
private static Comparer`1<GlyphInfo> <ClusterAscendingComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static Comparer`1<GlyphInfo> <ClusterDescendingComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GlyphIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GlyphCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private double <GlyphAdvance>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <GlyphOffset>k__BackingField;
    internal static Comparer`1<GlyphInfo> ClusterAscendingComparer { get; }
    internal static Comparer`1<GlyphInfo> ClusterDescendingComparer { get; }
    public ushort GlyphIndex { get; }
    public int GlyphCluster { get; }
    public double GlyphAdvance { get; }
    public Vector GlyphOffset { get; }
    public GlyphInfo(ushort GlyphIndex, int GlyphCluster, double GlyphAdvance, Vector GlyphOffset);
    private static GlyphInfo();
    [CompilerGeneratedAttribute]
internal static Comparer`1<GlyphInfo> get_ClusterAscendingComparer();
    [CompilerGeneratedAttribute]
internal static Comparer`1<GlyphInfo> get_ClusterDescendingComparer();
    [CompilerGeneratedAttribute]
public ushort get_GlyphIndex();
    [CompilerGeneratedAttribute]
public int get_GlyphCluster();
    [CompilerGeneratedAttribute]
public double get_GlyphAdvance();
    [CompilerGeneratedAttribute]
public Vector get_GlyphOffset();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GlyphInfo left, GlyphInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GlyphInfo left, GlyphInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(GlyphInfo other);
    [CompilerGeneratedAttribute]
public void Deconstruct(UInt16& GlyphIndex, Int32& GlyphCluster, Double& GlyphAdvance, Vector& GlyphOffset);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Media.TextFormatting.IndexedTextRun : object {
    [CompilerGeneratedAttribute]
private int <TextSourceCharacterIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RunIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NextRunIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRun <TextRun>k__BackingField;
    public int TextSourceCharacterIndex { get; public set; }
    public int RunIndex { get; public set; }
    public int NextRunIndex { get; public set; }
    public TextRun TextRun { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TextSourceCharacterIndex();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TextSourceCharacterIndex(int value);
    [CompilerGeneratedAttribute]
public int get_RunIndex();
    [CompilerGeneratedAttribute]
public void set_RunIndex(int value);
    [CompilerGeneratedAttribute]
public int get_NextRunIndex();
    [CompilerGeneratedAttribute]
public void set_NextRunIndex(int value);
    [CompilerGeneratedAttribute]
public TextRun get_TextRun();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TextRun(TextRun value);
}
internal class Avalonia.Media.TextFormatting.InterWordJustification : JustificationProperties {
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    public double Width { get; }
    public InterWordJustification(double width);
    [CompilerGeneratedAttribute]
public virtual double get_Width();
    [NullableContextAttribute("1")]
public virtual void Justify(TextLine textLine);
}
[NullableContextAttribute("2")]
public interface Avalonia.Media.TextFormatting.ITextSource {
    public abstract virtual TextRun GetTextRun(int textSourceIndex);
}
public abstract class Avalonia.Media.TextFormatting.JustificationProperties : object {
    public double Width { get; }
    public abstract virtual double get_Width();
    [NullableContextAttribute("1")]
public abstract virtual void Justify(TextLine textLine);
}
public enum Avalonia.Media.TextFormatting.LogicalDirection : Enum {
    public int value__;
    public static LogicalDirection Backward;
    public static LogicalDirection Forward;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.TextFormatting.OrderedBidiRun : ValueType {
    [CompilerGeneratedAttribute]
private int <RunIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRun <Run>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NextRunIndex>k__BackingField;
    public int RunIndex { get; }
    public sbyte Level { get; }
    public TextRun Run { get; }
    public int NextRunIndex { get; public set; }
    public OrderedBidiRun(int runIndex, TextRun run, sbyte level);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RunIndex();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_Level();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextRun get_Run();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NextRunIndex();
    [CompilerGeneratedAttribute]
public void set_NextRunIndex(int value);
}
[DefaultMemberAttribute("Item")]
public class Avalonia.Media.TextFormatting.ShapedBuffer : object {
    [NullableAttribute("2")]
private GlyphInfo[] _rentedBuffer;
    private ArraySlice`1<GlyphInfo> _glyphInfos;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IGlyphTypeface <GlyphTypeface>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FontRenderingEmSize>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <BidiLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Text>k__BackingField;
    public int Length { get; }
    [NullableAttribute("1")]
public IGlyphTypeface GlyphTypeface { get; }
    public double FontRenderingEmSize { get; }
    public sbyte BidiLevel { get; }
    public bool IsLeftToRight { get; }
    public ReadOnlyMemory`1<char> Text { get; }
    public GlyphInfo Item { get; public set; }
    private int System.Collections.Generic.IReadOnlyCollection<Avalonia.Media.TextFormatting.GlyphInfo>.Count { get; }
    public ShapedBuffer(ReadOnlyMemory`1<char> text, int bufferLength, IGlyphTypeface glyphTypeface, double fontRenderingEmSize, sbyte bidiLevel);
    internal ShapedBuffer(ReadOnlyMemory`1<char> text, ArraySlice`1<GlyphInfo> glyphInfos, IGlyphTypeface glyphTypeface, double fontRenderingEmSize, sbyte bidiLevel);
    public int get_Length();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IGlyphTypeface get_GlyphTypeface();
    [CompilerGeneratedAttribute]
public double get_FontRenderingEmSize();
    [CompilerGeneratedAttribute]
public sbyte get_BidiLevel();
    public bool get_IsLeftToRight();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_Text();
    public void Reverse();
    public sealed virtual void Dispose();
    public sealed virtual GlyphInfo get_Item(int index);
    public void set_Item(int index, GlyphInfo value);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerator`1<GlyphInfo> GetEnumerator();
    private int FindGlyphIndex(int characterIndex);
    internal SplitResult`1<ShapedBuffer> Split(int length);
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<Avalonia.Media.TextFormatting.GlyphInfo>.get_Count();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.ShapedTextRun : DrawableTextRun {
    [NullableAttribute("2")]
private GlyphRun _glyphRun;
    [CompilerGeneratedAttribute]
private bool <IsReversed>k__BackingField;
    [CompilerGeneratedAttribute]
private ShapedBuffer <ShapedBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRunProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private TextMetrics <TextMetrics>k__BackingField;
    public bool IsReversed { get; private set; }
    public sbyte BidiLevel { get; }
    public ShapedBuffer ShapedBuffer { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<char> Text { get; }
    public TextRunProperties Properties { get; }
    public int Length { get; }
    public TextMetrics TextMetrics { get; }
    public double Baseline { get; }
    public Size Size { get; }
    public GlyphRun GlyphRun { get; }
    public ShapedTextRun(ShapedBuffer shapedBuffer, TextRunProperties properties);
    [CompilerGeneratedAttribute]
public bool get_IsReversed();
    [CompilerGeneratedAttribute]
private void set_IsReversed(bool value);
    public sbyte get_BidiLevel();
    [CompilerGeneratedAttribute]
public ShapedBuffer get_ShapedBuffer();
    [NullableContextAttribute("0")]
public virtual ReadOnlyMemory`1<char> get_Text();
    [CompilerGeneratedAttribute]
public virtual TextRunProperties get_Properties();
    public virtual int get_Length();
    [CompilerGeneratedAttribute]
public TextMetrics get_TextMetrics();
    public virtual double get_Baseline();
    public virtual Size get_Size();
    public GlyphRun get_GlyphRun();
    public virtual void Draw(DrawingContext drawingContext, Point origin);
    internal void Reverse();
    public bool TryMeasureCharacters(double availableWidth, Int32& length);
    internal bool TryMeasureCharactersBackwards(double availableWidth, Int32& length, Double& width);
    internal SplitResult`1<ShapedTextRun> Split(int length);
    internal GlyphRun CreateGlyphRun();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.SplitResult`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <First>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private T <Second>k__BackingField;
    public T First { get; }
    [NullableAttribute("2")]
public T Second { get; }
    public SplitResult`1(T first, T second);
    [CompilerGeneratedAttribute]
public T get_First();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public T get_Second();
    public void Deconstruct(T& first, T& second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.TextBounds : object {
    [CompilerGeneratedAttribute]
private Rect <Rectangle>k__BackingField;
    [CompilerGeneratedAttribute]
private FlowDirection <FlowDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TextRunBounds> <TextRunBounds>k__BackingField;
    public Rect Rectangle { get; internal set; }
    public FlowDirection FlowDirection { get; }
    public IList`1<TextRunBounds> TextRunBounds { get; }
    [DebuggerStepThroughAttribute]
internal TextBounds(Rect bounds, FlowDirection flowDirection, IList`1<TextRunBounds> runBounds);
    [CompilerGeneratedAttribute]
public Rect get_Rectangle();
    [CompilerGeneratedAttribute]
internal void set_Rectangle(Rect value);
    [CompilerGeneratedAttribute]
public FlowDirection get_FlowDirection();
    [CompilerGeneratedAttribute]
public IList`1<TextRunBounds> get_TextRunBounds();
}
public class Avalonia.Media.TextFormatting.TextCharacters : TextRun {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Text>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TextRunProperties <Properties>k__BackingField;
    public int Length { get; }
    public ReadOnlyMemory`1<char> Text { get; }
    [NullableAttribute("1")]
public TextRunProperties Properties { get; }
    [NullableContextAttribute("1")]
public TextCharacters(string text, TextRunProperties textRunProperties);
    public TextCharacters(ReadOnlyMemory`1<char> text, TextRunProperties textRunProperties);
    public virtual int get_Length();
    [CompilerGeneratedAttribute]
public virtual ReadOnlyMemory`1<char> get_Text();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual TextRunProperties get_Properties();
    [NullableContextAttribute("1")]
internal void GetShapeableCharacters(ReadOnlyMemory`1<char> text, sbyte biDiLevel, FontManager fontManager, TextRunProperties& previousProperties, RentedList`1<TextRun> results);
    [NullableContextAttribute("1")]
private static UnshapedTextRun CreateShapeableRun(ReadOnlyMemory`1<char> text, TextRunProperties defaultProperties, sbyte biDiLevel, FontManager fontManager, TextRunProperties& previousProperties);
    internal static bool TryGetShapeableLength(ReadOnlySpan`1<char> text, IGlyphTypeface glyphTypeface, IGlyphTypeface defaultGlyphTypeface, Int32& length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.TextFormatting.TextCollapsingProperties : object {
    public double Width { get; }
    public TextRun Symbol { get; }
    public FlowDirection FlowDirection { get; }
    public abstract virtual double get_Width();
    public abstract virtual TextRun get_Symbol();
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual TextRun[] Collapse(TextLine textLine);
    public static TextRun[] CreateCollapsedRuns(TextLine textLine, int collapsedLength, FlowDirection flowDirection, TextRun shapedSymbol);
}
internal static class Avalonia.Media.TextFormatting.TextEllipsisHelper : object {
    [NullableContextAttribute("1")]
public static TextRun[] Collapse(TextLine textLine, TextCollapsingProperties properties, bool isWordEllipsis);
}
public class Avalonia.Media.TextFormatting.TextEndOfLine : TextRun {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public TextEndOfLine(int textSourceLength);
    [CompilerGeneratedAttribute]
public virtual int get_Length();
}
public class Avalonia.Media.TextFormatting.TextEndOfParagraph : TextEndOfLine {
    public TextEndOfParagraph(int textSourceLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.TextFormatting.TextFormatter : object {
    public static TextFormatter Current { get; }
    public static TextFormatter get_Current();
    public abstract virtual TextLine FormatLine(ITextSource textSource, int firstTextSourceIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak);
    public static ShapedTextRun CreateSymbol(TextRun textRun, FlowDirection flowDirection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.TextFormatting.TextFormatterImpl : TextFormatter {
    private static Char[] s_empty;
    private static string s_defaultText;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static BidiData t_bidiData;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static BidiAlgorithm t_bidiAlgorithm;
    private static TextFormatterImpl();
    public virtual TextLine FormatLine(ITextSource textSource, int firstTextSourceIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak);
    internal static SplitResult`1<RentedList`1<TextRun>> SplitTextRuns(IReadOnlyList`1<TextRun> textRuns, int length, FormattingObjectPool objectPool);
    private static RentedList`1<TextRun> ShapeTextRuns(IReadOnlyList`1<TextRun> textRuns, TextParagraphProperties paragraphProperties, FormattingObjectPool objectPool, FontManager fontManager, FlowDirection& resolvedFlowDirection);
    [NullableContextAttribute("0")]
private static bool TryJoinContiguousMemories(ReadOnlyMemory`1<char> x, ReadOnlyMemory`1<char> y, ReadOnlyMemory`1& joinedMemory);
    private static bool CanShapeTogether(TextRunProperties x, TextRunProperties y);
    private static void ShapeTogether(IReadOnlyList`1<UnshapedTextRun> textRuns, ReadOnlyMemory`1<char> text, TextShaperOptions options, TextShaper textShaper, RentedList`1<TextRun> results);
    private static void CoalesceLevels(IReadOnlyList`1<TextRun> textCharacters, ReadOnlySpan`1<sbyte> levels, FontManager fontManager, RentedList`1<TextRun> processedRuns);
    private static RentedList`1<TextRun> FetchTextRuns(ITextSource textSource, int firstTextSourceIndex, FormattingObjectPool objectPool, TextEndOfLine& endOfLine, Int32& textSourceLength);
    private static bool TryGetLineBreak(TextRun textRun, LineBreak& lineBreak);
    private static int MeasureLength(IReadOnlyList`1<TextRun> textRuns, double paragraphWidth);
    public static TextLineImpl CreateEmptyTextLine(int firstTextSourceIndex, double paragraphWidth, TextParagraphProperties paragraphProperties);
    private static TextLineImpl PerformTextWrapping(List`1<TextRun> textRuns, bool canReuseTextRunList, int firstTextSourceIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, FlowDirection resolvedFlowDirection, TextLineBreak currentLineBreak, FormattingObjectPool objectPool);
    [CompilerGeneratedAttribute]
internal static bool <TryJoinContiguousMemories>g__TryGetContiguousStart|7_0(int xStart, int xLength, int yStart, int yLength, Int32& joinedStart);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.TextLayout : object {
    private ITextSource _textSource;
    private TextParagraphProperties _paragraphProperties;
    private TextTrimming _textTrimming;
    private TextLine[] _textLines;
    private CachedMetrics _metrics;
    private int _textSourceLength;
    [CompilerGeneratedAttribute]
private double <MaxWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLines>k__BackingField;
    public double LineHeight { get; }
    public double MaxWidth { get; }
    public double MaxHeight { get; }
    public int MaxLines { get; }
    public double LetterSpacing { get; }
    public IReadOnlyList`1<TextLine> TextLines { get; }
    public double Height { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    [NullableContextAttribute("2")]
public TextLayout(string text, Typeface typeface, double fontSize, IBrush foreground, TextAlignment textAlignment, TextWrapping textWrapping, TextTrimming textTrimming, TextDecorationCollection textDecorations, FlowDirection flowDirection, double maxWidth, double maxHeight, double lineHeight, double letterSpacing, int maxLines, IReadOnlyList`1<ValueSpan`1<TextRunProperties>> textStyleOverrides);
    [NullableContextAttribute("2")]
public TextLayout(string text, Typeface typeface, FontFeatureCollection fontFeatures, double fontSize, IBrush foreground, TextAlignment textAlignment, TextWrapping textWrapping, TextTrimming textTrimming, TextDecorationCollection textDecorations, FlowDirection flowDirection, double maxWidth, double maxHeight, double lineHeight, double letterSpacing, int maxLines, IReadOnlyList`1<ValueSpan`1<TextRunProperties>> textStyleOverrides);
    public TextLayout(ITextSource textSource, TextParagraphProperties paragraphProperties, TextTrimming textTrimming, double maxWidth, double maxHeight, int maxLines);
    public double get_LineHeight();
    [CompilerGeneratedAttribute]
public double get_MaxWidth();
    [CompilerGeneratedAttribute]
public double get_MaxHeight();
    [CompilerGeneratedAttribute]
public int get_MaxLines();
    public double get_LetterSpacing();
    public IReadOnlyList`1<TextLine> get_TextLines();
    public double get_Height();
    public double get_Extent();
    public double get_Baseline();
    public double get_OverhangAfter();
    public double get_OverhangLeading();
    public double get_OverhangTrailing();
    public double get_Width();
    public double get_WidthIncludingTrailingWhitespace();
    public void Draw(DrawingContext context, Point origin);
    public Rect HitTestTextPosition(int textPosition);
    public IEnumerable`1<Rect> HitTestTextRange(int start, int length);
    public TextHitTestResult HitTestPoint(Point& point);
    public int GetLineIndexFromCharacterIndex(int charIndex, bool trailingEdge);
    private TextHitTestResult GetHitTestResult(TextLine textLine, CharacterHit characterHit, Point point);
    [NullableContextAttribute("2")]
internal static TextParagraphProperties CreateTextParagraphProperties(Typeface typeface, double fontSize, IBrush foreground, TextAlignment textAlignment, TextWrapping textWrapping, TextDecorationCollection textDecorations, FlowDirection flowDirection, double lineHeight, double letterSpacing, FontFeatureCollection features);
    private TextLine[] CreateTextLines();
    private void UpdateMetrics(TextLine currentLine, Double& lineStartOfLongestLine, Point& origin, Boolean& first, Double& accBlackBoxLeft, Double& accBlackBoxTop, Double& accBlackBoxRight, Double& accBlackBoxBottom);
    [NullableContextAttribute("2")]
private TextCollapsingProperties GetCollapsingProperties(double width);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.TextLeadingPrefixCharacterEllipsis : TextCollapsingProperties {
    private int _prefixLength;
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRun <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private FlowDirection <FlowDirection>k__BackingField;
    public double Width { get; }
    public TextRun Symbol { get; }
    public FlowDirection FlowDirection { get; }
    public TextLeadingPrefixCharacterEllipsis(string ellipsis, int prefixLength, double width, TextRunProperties textRunProperties, FlowDirection flowDirection);
    [CompilerGeneratedAttribute]
public virtual double get_Width();
    [CompilerGeneratedAttribute]
public virtual TextRun get_Symbol();
    [CompilerGeneratedAttribute]
public virtual FlowDirection get_FlowDirection();
    public virtual TextRun[] Collapse(TextLine textLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.TextFormatting.TextLine : object {
    public IReadOnlyList`1<TextRun> TextRuns { get; }
    public int FirstTextSourceIndex { get; }
    public int Length { get; }
    [NullableAttribute("2")]
public TextLineBreak TextLineBreak { get; }
    public double Baseline { get; }
    public double Extent { get; }
    public bool HasCollapsed { get; }
    public bool HasOverflowed { get; }
    public double Height { get; }
    public int NewLineLength { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double Start { get; }
    public int TrailingWhitespaceLength { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public abstract virtual IReadOnlyList`1<TextRun> get_TextRuns();
    public abstract virtual int get_FirstTextSourceIndex();
    public abstract virtual int get_Length();
    [NullableContextAttribute("2")]
public abstract virtual TextLineBreak get_TextLineBreak();
    public abstract virtual double get_Baseline();
    public abstract virtual double get_Extent();
    public abstract virtual bool get_HasCollapsed();
    public abstract virtual bool get_HasOverflowed();
    public abstract virtual double get_Height();
    public abstract virtual int get_NewLineLength();
    public abstract virtual double get_OverhangAfter();
    public abstract virtual double get_OverhangLeading();
    public abstract virtual double get_OverhangTrailing();
    public abstract virtual double get_Start();
    public abstract virtual int get_TrailingWhitespaceLength();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual void Draw(DrawingContext drawingContext, Point lineOrigin);
    public abstract virtual TextLine Collapse(TextCollapsingProperties[] collapsingPropertiesList);
    public abstract virtual void Justify(JustificationProperties justificationProperties);
    public abstract virtual CharacterHit GetCharacterHitFromDistance(double distance);
    public abstract virtual double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetBackspaceCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual IReadOnlyList`1<TextBounds> GetTextBounds(int firstTextSourceCharacterIndex, int textLength);
    public abstract virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.TextLineBreak : object {
    [CompilerGeneratedAttribute]
private TextEndOfLine <TextEndOfLine>k__BackingField;
    [CompilerGeneratedAttribute]
private FlowDirection <FlowDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSplit>k__BackingField;
    public TextEndOfLine TextEndOfLine { get; }
    public FlowDirection FlowDirection { get; }
    public bool IsSplit { get; }
    public TextLineBreak(TextEndOfLine textEndOfLine, FlowDirection flowDirection, bool isSplit);
    [CompilerGeneratedAttribute]
public TextEndOfLine get_TextEndOfLine();
    [CompilerGeneratedAttribute]
public FlowDirection get_FlowDirection();
    [CompilerGeneratedAttribute]
public bool get_IsSplit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.TextFormatting.TextLineImpl : TextLine {
    [CompilerGeneratedAttribute]
private static Comparer`1<TextBounds> <TextBoundsComparer>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyList`1<IndexedTextRun> _indexedTextRuns;
    private TextRun[] _textRuns;
    private double _paragraphWidth;
    private TextParagraphProperties _paragraphProperties;
    private TextLineMetrics _textLineMetrics;
    [NullableAttribute("2")]
private TextLineBreak _textLineBreak;
    private FlowDirection _resolvedFlowDirection;
    [CompilerGeneratedAttribute]
private int <FirstTextSourceIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCollapsed>k__BackingField;
    internal static Comparer`1<TextBounds> TextBoundsComparer { get; }
    public IReadOnlyList`1<TextRun> TextRuns { get; }
    public int FirstTextSourceIndex { get; }
    public int Length { get; }
    [NullableAttribute("2")]
public TextLineBreak TextLineBreak { get; }
    public bool HasCollapsed { get; }
    public bool HasOverflowed { get; }
    public double Baseline { get; }
    public double Extent { get; }
    public double Height { get; }
    public int NewLineLength { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public int TrailingWhitespaceLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public TextLineImpl(TextRun[] textRuns, int firstTextSourceIndex, int length, double paragraphWidth, TextParagraphProperties paragraphProperties, FlowDirection resolvedFlowDirection, TextLineBreak lineBreak, bool hasCollapsed);
    private static TextLineImpl();
    [CompilerGeneratedAttribute]
internal static Comparer`1<TextBounds> get_TextBoundsComparer();
    public virtual IReadOnlyList`1<TextRun> get_TextRuns();
    [CompilerGeneratedAttribute]
public virtual int get_FirstTextSourceIndex();
    [CompilerGeneratedAttribute]
public virtual int get_Length();
    [NullableContextAttribute("2")]
public virtual TextLineBreak get_TextLineBreak();
    [CompilerGeneratedAttribute]
public virtual bool get_HasCollapsed();
    public virtual bool get_HasOverflowed();
    public virtual double get_Baseline();
    public virtual double get_Extent();
    public virtual double get_Height();
    public virtual int get_NewLineLength();
    public virtual double get_OverhangAfter();
    public virtual double get_OverhangLeading();
    public virtual double get_OverhangTrailing();
    public virtual int get_TrailingWhitespaceLength();
    public virtual double get_Start();
    public virtual double get_Width();
    public virtual double get_WidthIncludingTrailingWhitespace();
    public virtual void Draw(DrawingContext drawingContext, Point lineOrigin);
    private double GetBaselineOffset(DrawableTextRun textRun);
    public virtual TextLine Collapse(TextCollapsingProperties[] collapsingPropertiesList);
    public virtual void Justify(JustificationProperties justificationProperties);
    public virtual CharacterHit GetCharacterHitFromDistance(double distance);
    private static CharacterHit GetRunCharacterHit(TextRun run, int currentPosition, double distance);
    public virtual double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetBackspaceCaretCharacterHit(CharacterHit characterHit);
    public virtual IReadOnlyList`1<TextBounds> GetTextBounds(int firstTextSourceIndex, int textLength);
    private CharacterHit GetPreviousCharacterHit(CharacterHit characterHit, bool useGraphemeBoundaries);
    private TextBounds GetTextRunBoundsRightToLeft(int firstRunIndex, int lastRunIndex, double endX, int firstTextSourceIndex, int currentPosition, int remainingLength, Int32& coveredLength, Int32& newPosition);
    private TextBounds GetTextBoundsLeftToRight(int firstRunIndex, int lastRunIndex, double startX, int firstTextSourceIndex, int currentPosition, int remainingLength, Int32& coveredLength, Int32& newPosition);
    private TextRunBounds GetRunBoundsLeftToRight(ShapedTextRun currentRun, double startX, int firstTextSourceIndex, int remainingLength, int currentPosition, Int32& offset);
    private TextRunBounds GetRunBoundsRightToLeft(ShapedTextRun currentRun, double endX, int firstTextSourceIndex, int remainingLength, int currentPosition, Int32& offset);
    public virtual void Dispose();
    public void FinalizeLine();
    [NullableContextAttribute("2")]
private TextRun GetRunAtCharacterIndex(int codepointIndex, LogicalDirection direction, Int32& textPosition);
    private TextLineMetrics CreateLineMetrics();
    private double GetParagraphOffsetX(double width, double widthIncludingTrailingWhitespace);
    [CompilerGeneratedAttribute]
internal static FlowDirection <GetDistanceFromCharacterHit>g__GetDirection|54_0(TextRun textRun, FlowDirection currentDirection);
    [CompilerGeneratedAttribute]
private IndexedTextRun <GetDistanceFromCharacterHit>g__FindIndexedRun|54_1(<>c__DisplayClass54_0& );
    [CompilerGeneratedAttribute]
private double <GetDistanceFromCharacterHit>g__GetPreceedingDistance|54_2(int firstIndex, <>c__DisplayClass54_0& );
    [CompilerGeneratedAttribute]
internal static FlowDirection <GetTextBounds>g__GetDirection|58_0(TextRun textRun, FlowDirection currentDirection);
    [CompilerGeneratedAttribute]
private IndexedTextRun <GetTextBounds>g__FindIndexedRun|58_1(<>c__DisplayClass58_0& );
    [CompilerGeneratedAttribute]
private double <GetTextBounds>g__GetPreceedingDistance|58_2(int firstIndex, <>c__DisplayClass58_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetTextBounds>g__TryMergeWithLastBounds|58_3(TextBounds currentBounds, TextBounds lastBounds);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.TextLineMetrics : ValueType {
    [CompilerGeneratedAttribute]
private bool <HasOverflowed>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewlineLength>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TextBaseline>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TrailingWhitespaceLength>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private double <WidthIncludingTrailingWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Extent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OverhangAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OverhangLeading>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OverhangTrailing>k__BackingField;
    public bool HasOverflowed { get; public set; }
    public double Height { get; public set; }
    public int NewlineLength { get; public set; }
    public double Start { get; public set; }
    public double TextBaseline { get; public set; }
    public int TrailingWhitespaceLength { get; public set; }
    public double Width { get; public set; }
    public double WidthIncludingTrailingWhitespace { get; public set; }
    public double Extent { get; public set; }
    public double OverhangAfter { get; public set; }
    public double OverhangLeading { get; public set; }
    public double OverhangTrailing { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HasOverflowed();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasOverflowed(bool value);
    [CompilerGeneratedAttribute]
public double get_Height();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Height(double value);
    [CompilerGeneratedAttribute]
public int get_NewlineLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewlineLength(int value);
    [CompilerGeneratedAttribute]
public double get_Start();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Start(double value);
    [CompilerGeneratedAttribute]
public double get_TextBaseline();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TextBaseline(double value);
    [CompilerGeneratedAttribute]
public int get_TrailingWhitespaceLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TrailingWhitespaceLength(int value);
    [CompilerGeneratedAttribute]
public double get_Width();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Width(double value);
    [CompilerGeneratedAttribute]
public double get_WidthIncludingTrailingWhitespace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WidthIncludingTrailingWhitespace(double value);
    [CompilerGeneratedAttribute]
public double get_Extent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Extent(double value);
    [CompilerGeneratedAttribute]
public double get_OverhangAfter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OverhangAfter(double value);
    [CompilerGeneratedAttribute]
public double get_OverhangLeading();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OverhangLeading(double value);
    [CompilerGeneratedAttribute]
public double get_OverhangTrailing();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OverhangTrailing(double value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TextLineMetrics left, TextLineMetrics right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TextLineMetrics left, TextLineMetrics right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextLineMetrics other);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.TextMetrics : ValueType {
    [CompilerGeneratedAttribute]
private double <FontRenderingEmSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Ascent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Descent>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LineGap>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LineHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UnderlineThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UnderlinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StrikethroughThickness>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StrikethroughPosition>k__BackingField;
    public double FontRenderingEmSize { get; }
    public double Ascent { get; }
    public double Descent { get; }
    public double LineGap { get; }
    public double LineHeight { get; }
    public double UnderlineThickness { get; }
    public double UnderlinePosition { get; }
    public double StrikethroughThickness { get; }
    public double StrikethroughPosition { get; }
    [NullableContextAttribute("1")]
public TextMetrics(IGlyphTypeface glyphTypeface, double fontRenderingEmSize);
    [CompilerGeneratedAttribute]
public double get_FontRenderingEmSize();
    [CompilerGeneratedAttribute]
public double get_Ascent();
    [CompilerGeneratedAttribute]
public double get_Descent();
    [CompilerGeneratedAttribute]
public double get_LineGap();
    [CompilerGeneratedAttribute]
public double get_LineHeight();
    [CompilerGeneratedAttribute]
public double get_UnderlineThickness();
    [CompilerGeneratedAttribute]
public double get_UnderlinePosition();
    [CompilerGeneratedAttribute]
public double get_StrikethroughThickness();
    [CompilerGeneratedAttribute]
public double get_StrikethroughPosition();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TextMetrics left, TextMetrics right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TextMetrics left, TextMetrics right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextMetrics other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.TextFormatting.TextParagraphProperties : object {
    [CompilerGeneratedAttribute]
private double <LineSpacing>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LetterSpacing>k__BackingField;
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    internal double LineSpacing { get; internal set; }
    public bool FirstLineInParagraph { get; }
    public bool AlwaysCollapsible { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    [NullableAttribute("2")]
public TextDecorationCollection TextDecorations { get; }
    public TextWrapping TextWrapping { get; }
    public double Indent { get; }
    public double ParagraphIndent { get; }
    public double DefaultIncrementalTab { get; }
    public double LetterSpacing { get; }
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual TextAlignment get_TextAlignment();
    public abstract virtual double get_LineHeight();
    [CompilerGeneratedAttribute]
internal double get_LineSpacing();
    [CompilerGeneratedAttribute]
internal void set_LineSpacing(double value);
    public abstract virtual bool get_FirstLineInParagraph();
    public virtual bool get_AlwaysCollapsible();
    public abstract virtual TextRunProperties get_DefaultTextRunProperties();
    [NullableContextAttribute("2")]
public virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual TextWrapping get_TextWrapping();
    public abstract virtual double get_Indent();
    public virtual double get_ParagraphIndent();
    public virtual double get_DefaultIncrementalTab();
    [CompilerGeneratedAttribute]
public virtual double get_LetterSpacing();
}
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.TextRange : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Start { get; }
    public int Length { get; }
    public int End { get; }
    public TextRange(int start, int length);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    public int get_End();
    public TextRange Take(int length);
    public TextRange Skip(int length);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TextRange left, TextRange right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TextRange left, TextRange right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextRange other);
}
[DebuggerTypeProxyAttribute("Avalonia.Media.TextFormatting.TextRun/TextRunDebuggerProxy")]
public abstract class Avalonia.Media.TextFormatting.TextRun : object {
    public static int DefaultTextSourceLength;
    public int Length { get; }
    public ReadOnlyMemory`1<char> Text { get; }
    [NullableAttribute("2")]
public TextRunProperties Properties { get; }
    public virtual int get_Length();
    public virtual ReadOnlyMemory`1<char> get_Text();
    [NullableContextAttribute("2")]
public virtual TextRunProperties get_Properties();
}
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.TextRunBounds : ValueType {
    [CompilerGeneratedAttribute]
private int <TextSourceCharacterIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <Rectangle>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TextRun <TextRun>k__BackingField;
    public int TextSourceCharacterIndex { get; }
    public int Length { get; }
    public Rect Rectangle { get; }
    [NullableAttribute("1")]
public TextRun TextRun { get; }
    [NullableContextAttribute("1")]
internal TextRunBounds(Rect bounds, int firstCharacterIndex, int length, TextRun textRun);
    [CompilerGeneratedAttribute]
public int get_TextSourceCharacterIndex();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public Rect get_Rectangle();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TextRun get_TextRun();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TextRunBounds left, TextRunBounds right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TextRunBounds left, TextRunBounds right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextRunBounds other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.TextFormatting.TextRunProperties : object {
    private IGlyphTypeface _cachedGlyphTypeFace;
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public IBrush ForegroundBrush { get; }
    public IBrush BackgroundBrush { get; }
    public CultureInfo CultureInfo { get; }
    public FontFeatureCollection FontFeatures { get; }
    public BaselineAlignment BaselineAlignment { get; }
    [NullableAttribute("1")]
internal IGlyphTypeface CachedGlyphTypeface { get; }
    public abstract virtual Typeface get_Typeface();
    public abstract virtual double get_FontRenderingEmSize();
    public abstract virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual IBrush get_ForegroundBrush();
    public abstract virtual IBrush get_BackgroundBrush();
    public abstract virtual CultureInfo get_CultureInfo();
    public virtual FontFeatureCollection get_FontFeatures();
    public virtual BaselineAlignment get_BaselineAlignment();
    [NullableContextAttribute("1")]
internal IGlyphTypeface get_CachedGlyphTypeface();
    public sealed virtual bool Equals(TextRunProperties other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static bool op_Equality(TextRunProperties left, TextRunProperties right);
    [NullableContextAttribute("1")]
public static bool op_Inequality(TextRunProperties left, TextRunProperties right);
    [NullableContextAttribute("1")]
internal TextRunProperties WithTypeface(Typeface typeface);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.TextShaper : object {
    private ITextShaperImpl _platformImpl;
    public static TextShaper Current { get; }
    public TextShaper(ITextShaperImpl platformImpl);
    public static TextShaper get_Current();
    [NullableContextAttribute("0")]
public ShapedBuffer ShapeText(ReadOnlyMemory`1<char> text, TextShaperOptions options);
    public ShapedBuffer ShapeText(string text, TextShaperOptions options);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.TextShaperOptions : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IGlyphTypeface <Typeface>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FontRenderingEmSize>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <BidiLevel>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IncrementalTabWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LetterSpacing>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<FontFeature> <FontFeatures>k__BackingField;
    [NullableAttribute("1")]
public IGlyphTypeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public sbyte BidiLevel { get; }
    [NullableAttribute("2")]
public CultureInfo Culture { get; }
    public double IncrementalTabWidth { get; }
    public double LetterSpacing { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<FontFeature> FontFeatures { get; }
    [NullableContextAttribute("1")]
public TextShaperOptions(IGlyphTypeface typeface, double fontRenderingEmSize, sbyte bidiLevel, CultureInfo culture, double incrementalTabWidth, double letterSpacing);
    [NullableContextAttribute("1")]
public TextShaperOptions(IGlyphTypeface typeface, IReadOnlyList`1<FontFeature> fontFeatures, double fontRenderingEmSize, sbyte bidiLevel, CultureInfo culture, double incrementalTabWidth, double letterSpacing);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IGlyphTypeface get_Typeface();
    [CompilerGeneratedAttribute]
public double get_FontRenderingEmSize();
    [CompilerGeneratedAttribute]
public sbyte get_BidiLevel();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public double get_IncrementalTabWidth();
    [CompilerGeneratedAttribute]
public double get_LetterSpacing();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FontFeature> get_FontFeatures();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TextShaperOptions left, TextShaperOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TextShaperOptions left, TextShaperOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextShaperOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.TextTrailingCharacterEllipsis : TextCollapsingProperties {
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRun <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private FlowDirection <FlowDirection>k__BackingField;
    public double Width { get; }
    public TextRun Symbol { get; }
    public FlowDirection FlowDirection { get; }
    public TextTrailingCharacterEllipsis(string ellipsis, double width, TextRunProperties textRunProperties, FlowDirection flowDirection);
    [CompilerGeneratedAttribute]
public virtual double get_Width();
    [CompilerGeneratedAttribute]
public virtual TextRun get_Symbol();
    [CompilerGeneratedAttribute]
public virtual FlowDirection get_FlowDirection();
    public virtual TextRun[] Collapse(TextLine textLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextFormatting.TextTrailingWordEllipsis : TextCollapsingProperties {
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRun <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private FlowDirection <FlowDirection>k__BackingField;
    public double Width { get; }
    public TextRun Symbol { get; }
    public FlowDirection FlowDirection { get; }
    public TextTrailingWordEllipsis(string ellipsis, double width, TextRunProperties textRunProperties, FlowDirection flowDirection);
    [CompilerGeneratedAttribute]
public virtual double get_Width();
    [CompilerGeneratedAttribute]
public virtual TextRun get_Symbol();
    [CompilerGeneratedAttribute]
public virtual FlowDirection get_FlowDirection();
    public virtual TextRun[] Collapse(TextLine textLine);
}
internal class Avalonia.Media.TextFormatting.Unicode.BidiAlgorithm : object {
    private bool _hasCleanState;
    private ArraySlice`1<BidiClass> _originalClasses;
    private ArraySlice`1<BidiPairedBracketType> _pairedBracketTypes;
    private ArraySlice`1<int> _pairedBracketValues;
    private bool _hasBrackets;
    private bool _hasEmbeddings;
    private bool _hasIsolates;
    [NullableAttribute("1")]
private BidiDictionary`2<int, int> _isolatePairs;
    private ArraySlice`1<BidiClass> _workingClasses;
    private ArrayBuilder`1<BidiClass> _workingClassesBuffer;
    private ArraySlice`1<sbyte> _resolvedLevels;
    private ArrayBuilder`1<sbyte> _resolvedLevelsBuffer;
    private sbyte _paragraphEmbeddingLevel;
    [NullableAttribute("1")]
private Stack`1<Status> _statusStack;
    private ArrayBuilder`1<int> _x9Map;
    [NullableAttribute("1")]
private List`1<LevelRun> _levelRuns;
    private ArrayBuilder`1<int> _isolatedRunMapping;
    [NullableAttribute("1")]
private Stack`1<int> _pendingIsolateOpenings;
    private int _runLevel;
    private BidiClass _runDirection;
    private int _runLength;
    private MappedArraySlice`1<BidiClass> _runResolvedClasses;
    private MappedArraySlice`1<BidiClass> _runOriginalClasses;
    private MappedArraySlice`1<sbyte> _runLevels;
    private MappedArraySlice`1<BidiPairedBracketType> _runBiDiPairedBracketTypes;
    private MappedArraySlice`1<int> _runPairedBracketValues;
    private static int MaxPairedBracketDepth;
    [NullableAttribute("1")]
private List`1<int> _pendingOpeningBrackets;
    [NullableAttribute("1")]
private List`1<BracketPair> _pairedBrackets;
    public ArraySlice`1<sbyte> ResolvedLevels { get; }
    public int ResolvedParagraphEmbeddingLevel { get; }
    public ArraySlice`1<sbyte> get_ResolvedLevels();
    public int get_ResolvedParagraphEmbeddingLevel();
    [NullableContextAttribute("1")]
public void Process(BidiData data);
    public void Process(ArraySlice`1<BidiClass> types, ArraySlice`1<BidiPairedBracketType> pairedBracketTypes, ArraySlice`1<int> pairedBracketValues, sbyte paragraphEmbeddingLevel, Nullable`1<bool> hasBrackets, Nullable`1<bool> hasEmbeddings, Nullable`1<bool> hasIsolates, Nullable`1<ArraySlice`1<sbyte>> outLevels);
    public sbyte ResolveEmbeddingLevel(ArraySlice`1<BidiClass> data);
    private static bool IsIsolateStart(BidiClass type);
    private void FindIsolatePairs();
    private void ResolveExplicitEmbeddingLevels();
    private void BuildX9RemovalMap();
    private int MapX9(int index);
    private void AddLevelRun(int start, int length, int level);
    private void FindLevelRuns();
    private int FindRunForIndex(int index);
    private void ProcessIsolatedRunSequences();
    private void ProcessIsolatedRunSequence(BidiClass sos, BidiClass eos, int runLevel);
    [NullableContextAttribute("1")]
private List`1<BracketPair> LocatePairedBrackets();
    private BidiClass InspectPairedBracket(BracketPair& bracketPair);
    private BidiClass InspectBeforePairedBracket(BracketPair& bracketPair, BidiClass sos);
    private void SetPairedBracketDirection(BracketPair& pairedBracket, BidiClass direction);
    private void ResetWhitespaceLevels();
    private void AssignLevelsToCodePointsRemovedByX9();
    private static bool IsWhitespace(BidiClass biDiClass);
    private static BidiClass DirectionFromLevel(int level);
    private static bool IsRemovedByX9(BidiClass biDiClass);
    private static bool IsNeutralClass(BidiClass direction);
    private static BidiClass GetStrongClassN0(BidiClass direction);
    public void Reset();
}
public enum Avalonia.Media.TextFormatting.Unicode.BidiClass : Enum {
    public int value__;
    public static BidiClass LeftToRight;
    public static BidiClass ArabicLetter;
    public static BidiClass ArabicNumber;
    public static BidiClass ParagraphSeparator;
    public static BidiClass BoundaryNeutral;
    public static BidiClass CommonSeparator;
    public static BidiClass EuropeanNumber;
    public static BidiClass EuropeanSeparator;
    public static BidiClass EuropeanTerminator;
    public static BidiClass FirstStrongIsolate;
    public static BidiClass LeftToRightEmbedding;
    public static BidiClass LeftToRightIsolate;
    public static BidiClass LeftToRightOverride;
    public static BidiClass NonspacingMark;
    public static BidiClass OtherNeutral;
    public static BidiClass PopDirectionalFormat;
    public static BidiClass PopDirectionalIsolate;
    public static BidiClass RightToLeft;
    public static BidiClass RightToLeftEmbedding;
    public static BidiClass RightToLeftIsolate;
    public static BidiClass RightToLeftOverride;
    public static BidiClass SegmentSeparator;
    public static BidiClass WhiteSpace;
}
internal class Avalonia.Media.TextFormatting.Unicode.BidiData : object {
    private bool _hasCleanState;
    private ArrayBuilder`1<BidiClass> _classes;
    private ArrayBuilder`1<BidiPairedBracketType> _pairedBracketTypes;
    private ArrayBuilder`1<int> _pairedBracketValues;
    private ArrayBuilder`1<BidiClass> _savedClasses;
    private ArrayBuilder`1<BidiPairedBracketType> _savedPairedBracketTypes;
    private ArrayBuilder`1<sbyte> _tempLevelBuffer;
    [CompilerGeneratedAttribute]
private sbyte <ParagraphEmbeddingLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasEmbeddings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasIsolates>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private ArraySlice`1<BidiClass> <Classes>k__BackingField;
    [CompilerGeneratedAttribute]
private ArraySlice`1<BidiPairedBracketType> <PairedBracketTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ArraySlice`1<int> <PairedBracketValues>k__BackingField;
    public sbyte ParagraphEmbeddingLevel { get; public set; }
    public bool HasBrackets { get; private set; }
    public bool HasEmbeddings { get; private set; }
    public bool HasIsolates { get; private set; }
    public int Length { get; private set; }
    public ArraySlice`1<BidiClass> Classes { get; private set; }
    public ArraySlice`1<BidiPairedBracketType> PairedBracketTypes { get; private set; }
    public ArraySlice`1<int> PairedBracketValues { get; private set; }
    [CompilerGeneratedAttribute]
public sbyte get_ParagraphEmbeddingLevel();
    [CompilerGeneratedAttribute]
public void set_ParagraphEmbeddingLevel(sbyte value);
    [CompilerGeneratedAttribute]
public bool get_HasBrackets();
    [CompilerGeneratedAttribute]
private void set_HasBrackets(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasEmbeddings();
    [CompilerGeneratedAttribute]
private void set_HasEmbeddings(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasIsolates();
    [CompilerGeneratedAttribute]
private void set_HasIsolates(bool value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
public ArraySlice`1<BidiClass> get_Classes();
    [CompilerGeneratedAttribute]
private void set_Classes(ArraySlice`1<BidiClass> value);
    [CompilerGeneratedAttribute]
public ArraySlice`1<BidiPairedBracketType> get_PairedBracketTypes();
    [CompilerGeneratedAttribute]
private void set_PairedBracketTypes(ArraySlice`1<BidiPairedBracketType> value);
    [CompilerGeneratedAttribute]
public ArraySlice`1<int> get_PairedBracketValues();
    [CompilerGeneratedAttribute]
private void set_PairedBracketValues(ArraySlice`1<int> value);
    public void Append(ReadOnlySpan`1<char> text);
    public void SaveTypes();
    public void RestoreTypes();
    public ArraySlice`1<sbyte> GetTempLevelBuffer(int length);
    public void Reset();
}
public enum Avalonia.Media.TextFormatting.Unicode.BidiPairedBracketType : Enum {
    public int value__;
    public static BidiPairedBracketType None;
    public static BidiPairedBracketType Close;
    public static BidiPairedBracketType Open;
}
internal static class Avalonia.Media.TextFormatting.Unicode.BidiTrie : object {
    public static UnicodeTrie Trie { get; }
    private static ReadOnlySpan`1<UInt32> Data { get; }
    public static UnicodeTrie get_Trie();
    private static ReadOnlySpan`1<UInt32> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Media.TextFormatting.Unicode.BinaryReaderExtensions : object {
    [ExtensionAttribute]
public static int ReadInt32BE(BinaryReader reader);
    [ExtensionAttribute]
public static UInt32 ReadUInt32BE(BinaryReader reader);
    [ExtensionAttribute]
public static void WriteBE(BinaryWriter writer, int value);
    [ExtensionAttribute]
public static void WriteBE(BinaryWriter writer, UInt32 value);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.Unicode.Codepoint : ValueType {
    private UInt32 _value;
    public static Codepoint ReplacementCodepoint { get; }
    public UInt32 Value { get; }
    public GeneralCategory GeneralCategory { get; }
    public Script Script { get; }
    public BidiClass BiDiClass { get; }
    public BidiPairedBracketType PairedBracketType { get; }
    public LineBreakClass LineBreakClass { get; }
    public GraphemeBreakClass GraphemeBreakClass { get; }
    public bool IsBreakChar { get; }
    public bool IsWhiteSpace { get; }
    public Codepoint(UInt32 value);
    public static Codepoint get_ReplacementCodepoint();
    public UInt32 get_Value();
    public GeneralCategory get_GeneralCategory();
    public Script get_Script();
    public BidiClass get_BiDiClass();
    public BidiPairedBracketType get_PairedBracketType();
    public LineBreakClass get_LineBreakClass();
    public GraphemeBreakClass get_GraphemeBreakClass();
    public bool get_IsBreakChar();
    public bool get_IsWhiteSpace();
    internal static Codepoint GetCanonicalType(Codepoint codePoint);
    public bool TryGetPairedBracket(Codepoint& codepoint);
    public static int op_Implicit(Codepoint codepoint);
    public static UInt32 op_Implicit(Codepoint codepoint);
    public static Codepoint ReadAt(ReadOnlySpan`1<char> text, int index, Int32& count);
    private static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsInRangeInclusive(Codepoint cp, UInt32 lowerBound, UInt32 upperBound);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Codepoint left, Codepoint right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Codepoint left, Codepoint right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Codepoint other);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class Avalonia.Media.TextFormatting.Unicode.CodepointEnumerator : ValueType {
    private ReadOnlySpan`1<char> _text;
    private int _offset;
    public CodepointEnumerator(ReadOnlySpan`1<char> text);
    public bool MoveNext(Codepoint& codepoint);
}
public enum Avalonia.Media.TextFormatting.Unicode.GeneralCategory : Enum {
    public int value__;
    public static GeneralCategory Other;
    public static GeneralCategory Control;
    public static GeneralCategory Format;
    public static GeneralCategory Unassigned;
    public static GeneralCategory PrivateUse;
    public static GeneralCategory Surrogate;
    public static GeneralCategory Letter;
    public static GeneralCategory CasedLetter;
    public static GeneralCategory LowercaseLetter;
    public static GeneralCategory ModifierLetter;
    public static GeneralCategory OtherLetter;
    public static GeneralCategory TitlecaseLetter;
    public static GeneralCategory UppercaseLetter;
    public static GeneralCategory Mark;
    public static GeneralCategory SpacingMark;
    public static GeneralCategory EnclosingMark;
    public static GeneralCategory NonspacingMark;
    public static GeneralCategory Number;
    public static GeneralCategory DecimalNumber;
    public static GeneralCategory LetterNumber;
    public static GeneralCategory OtherNumber;
    public static GeneralCategory Punctuation;
    public static GeneralCategory ConnectorPunctuation;
    public static GeneralCategory DashPunctuation;
    public static GeneralCategory ClosePunctuation;
    public static GeneralCategory FinalPunctuation;
    public static GeneralCategory InitialPunctuation;
    public static GeneralCategory OtherPunctuation;
    public static GeneralCategory OpenPunctuation;
    public static GeneralCategory Symbol;
    public static GeneralCategory CurrencySymbol;
    public static GeneralCategory ModifierSymbol;
    public static GeneralCategory MathSymbol;
    public static GeneralCategory OtherSymbol;
    public static GeneralCategory Separator;
    public static GeneralCategory LineSeparator;
    public static GeneralCategory ParagraphSeparator;
    public static GeneralCategory SpaceSeparator;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
public class Avalonia.Media.TextFormatting.Unicode.Grapheme : ValueType {
    [CompilerGeneratedAttribute]
private Codepoint <FirstCodepoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Codepoint FirstCodepoint { get; }
    public int Offset { get; }
    public int Length { get; }
    public Grapheme(Codepoint firstCodepoint, int offset, int length);
    [CompilerGeneratedAttribute]
public Codepoint get_FirstCodepoint();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public int get_Length();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Media.TextFormatting.Unicode.GraphemeBreak : object {
    public static Byte[] Data { get; }
    public static Byte[] get_Data();
}
public enum Avalonia.Media.TextFormatting.Unicode.GraphemeBreakClass : Enum {
    public int value__;
    public static GraphemeBreakClass Other;
    public static GraphemeBreakClass Control;
    public static GraphemeBreakClass CR;
    public static GraphemeBreakClass EBase;
    public static GraphemeBreakClass EBaseGAZ;
    public static GraphemeBreakClass EModifier;
    public static GraphemeBreakClass Extend;
    public static GraphemeBreakClass GlueAfterZwj;
    public static GraphemeBreakClass L;
    public static GraphemeBreakClass LF;
    public static GraphemeBreakClass LV;
    public static GraphemeBreakClass LVT;
    public static GraphemeBreakClass Prepend;
    public static GraphemeBreakClass RegionalIndicator;
    public static GraphemeBreakClass SpacingMark;
    public static GraphemeBreakClass T;
    public static GraphemeBreakClass V;
    public static GraphemeBreakClass ZWJ;
    public static GraphemeBreakClass ExtendedPictographic;
}
internal static class Avalonia.Media.TextFormatting.Unicode.GraphemeBreakTrie : object {
    public static UnicodeTrie Trie { get; }
    private static ReadOnlySpan`1<UInt32> Data { get; }
    public static UnicodeTrie get_Trie();
    private static ReadOnlySpan`1<UInt32> get_Data();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class Avalonia.Media.TextFormatting.Unicode.GraphemeEnumerator : ValueType {
    private ReadOnlySpan`1<char> _text;
    private int _currentCodeUnitOffset;
    private int _codeUnitLengthOfCurrentCodepoint;
    private Codepoint _currentCodepoint;
    private GraphemeBreakClass _currentType;
    public GraphemeEnumerator(ReadOnlySpan`1<char> text);
    public bool MoveNext(Grapheme& grapheme);
    private void ReadNextCodepoint();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{PositionMeasure}/{PositionWrap} @ {Required}")]
public class Avalonia.Media.TextFormatting.Unicode.LineBreak : ValueType {
    [CompilerGeneratedAttribute]
private int <PositionMeasure>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PositionWrap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public int PositionMeasure { get; }
    public int PositionWrap { get; }
    public bool Required { get; }
    public LineBreak(int positionMeasure, int positionWrap, bool required);
    [CompilerGeneratedAttribute]
public int get_PositionMeasure();
    [CompilerGeneratedAttribute]
public int get_PositionWrap();
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(LineBreak left, LineBreak right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(LineBreak left, LineBreak right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LineBreak other);
}
public enum Avalonia.Media.TextFormatting.Unicode.LineBreakClass : Enum {
    public int value__;
    public static LineBreakClass OpenPunctuation;
    public static LineBreakClass ClosePunctuation;
    public static LineBreakClass CloseParenthesis;
    public static LineBreakClass Quotation;
    public static LineBreakClass Glue;
    public static LineBreakClass Nonstarter;
    public static LineBreakClass Exclamation;
    public static LineBreakClass BreakSymbols;
    public static LineBreakClass InfixNumeric;
    public static LineBreakClass PrefixNumeric;
    public static LineBreakClass PostfixNumeric;
    public static LineBreakClass Numeric;
    public static LineBreakClass Alphabetic;
    public static LineBreakClass HebrewLetter;
    public static LineBreakClass Ideographic;
    public static LineBreakClass Inseparable;
    public static LineBreakClass Hyphen;
    public static LineBreakClass BreakAfter;
    public static LineBreakClass BreakBefore;
    public static LineBreakClass BreakBoth;
    public static LineBreakClass ZWSpace;
    public static LineBreakClass CombiningMark;
    public static LineBreakClass WordJoiner;
    public static LineBreakClass H2;
    public static LineBreakClass H3;
    public static LineBreakClass JL;
    public static LineBreakClass JV;
    public static LineBreakClass JT;
    public static LineBreakClass RegionalIndicator;
    public static LineBreakClass EBase;
    public static LineBreakClass EModifier;
    public static LineBreakClass ZWJ;
    public static LineBreakClass ContingentBreak;
    public static LineBreakClass Unknown;
    public static LineBreakClass Ambiguous;
    public static LineBreakClass MandatoryBreak;
    public static LineBreakClass ConditionalJapaneseStarter;
    public static LineBreakClass CarriageReturn;
    public static LineBreakClass LineFeed;
    public static LineBreakClass NextLine;
    public static LineBreakClass ComplexContext;
    public static LineBreakClass Surrogate;
    public static LineBreakClass Space;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class Avalonia.Media.TextFormatting.Unicode.LineBreakEnumerator : ValueType {
    private ReadOnlySpan`1<char> _text;
    private int _position;
    private int _lastPosition;
    private LineBreakClass _currentClass;
    private LineBreakClass _nextClass;
    private bool _first;
    private int _alphaNumericCount;
    private bool _lb8a;
    private bool _lb21a;
    private bool _lb22ex;
    private bool _lb24ex;
    private bool _lb25ex;
    private bool _lb30;
    private int _lb30a;
    private bool _lb31;
    public LineBreakEnumerator(ReadOnlySpan`1<char> text);
    public bool MoveNext(LineBreak& lineBreak);
    private static LineBreakClass MapClass(Codepoint cp);
    private static LineBreakClass MapFirst(LineBreakClass c);
    private static bool IsAlphaNumeric(LineBreakClass cls);
    private static bool IsPrefixPostfixNumericOrSpace(LineBreakClass cls);
    private static bool IsPrefixPostfixNumeric(LineBreakClass cls);
    private static bool IsClosePunctuationOrParenthesis(LineBreakClass cls);
    private static bool IsClosePunctuationOrInfixNumericOrBreakSymbols(LineBreakClass cls);
    private static bool IsSpaceOrWordJoinerOrAlphabetic(LineBreakClass cls);
    private static bool IsMandatoryBreakOrLineFeedOrCarriageReturn(LineBreakClass cls);
    private LineBreakClass PeekNextCharClass();
    private LineBreakClass NextCharClass();
    private Nullable`1<bool> GetSimpleBreak();
    private bool GetPairTableBreak(LineBreakClass lastClass);
    private int FindPriorNonWhitespace(int from);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Media.TextFormatting.Unicode.LineBreakPairTable : object {
    public static byte DIBRK;
    public static byte INBRK;
    public static byte CIBRK;
    public static byte CPBRK;
    public static byte PRBRK;
    [CompilerGeneratedAttribute]
private static Byte[][] <Table>k__BackingField;
    public static Byte[][] Table { get; }
    private static LineBreakPairTable();
    [CompilerGeneratedAttribute]
public static Byte[][] get_Table();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Media.TextFormatting.Unicode.PropertyValueAliasHelper : object {
    private static Dictionary`2<Script, string> s_scriptToTag;
    private static Dictionary`2<string, Script> s_tagToScript;
    private static Dictionary`2<string, GeneralCategory> s_tagToGeneralCategory;
    private static Dictionary`2<string, LineBreakClass> s_tagToLineBreakClass;
    private static Dictionary`2<string, BidiPairedBracketType> s_tagToBidiPairedBracketType;
    private static Dictionary`2<string, BidiClass> s_tagToBidiClass;
    private static PropertyValueAliasHelper();
    public static string GetTag(Script script);
    public static Script GetScript(string tag);
    public static GeneralCategory GetGeneralCategory(string tag);
    public static LineBreakClass GetLineBreakClass(string tag);
    public static BidiPairedBracketType GetBidiPairedBracketType(string tag);
    public static BidiClass GetBidiClass(string tag);
}
public enum Avalonia.Media.TextFormatting.Unicode.Script : Enum {
    public int value__;
    public static Script Unknown;
    public static Script Common;
    public static Script Inherited;
    public static Script Adlam;
    public static Script CaucasianAlbanian;
    public static Script Ahom;
    public static Script Arabic;
    public static Script ImperialAramaic;
    public static Script Armenian;
    public static Script Avestan;
    public static Script Balinese;
    public static Script Bamum;
    public static Script BassaVah;
    public static Script Batak;
    public static Script Bengali;
    public static Script Bhaiksuki;
    public static Script Bopomofo;
    public static Script Brahmi;
    public static Script Braille;
    public static Script Buginese;
    public static Script Buhid;
    public static Script Chakma;
    public static Script CanadianAboriginal;
    public static Script Carian;
    public static Script Cham;
    public static Script Cherokee;
    public static Script Chorasmian;
    public static Script Coptic;
    public static Script CyproMinoan;
    public static Script Cypriot;
    public static Script Cyrillic;
    public static Script Devanagari;
    public static Script DivesAkuru;
    public static Script Dogra;
    public static Script Deseret;
    public static Script Duployan;
    public static Script EgyptianHieroglyphs;
    public static Script Elbasan;
    public static Script Elymaic;
    public static Script Ethiopic;
    public static Script Georgian;
    public static Script Glagolitic;
    public static Script GunjalaGondi;
    public static Script MasaramGondi;
    public static Script Gothic;
    public static Script Grantha;
    public static Script Greek;
    public static Script Gujarati;
    public static Script Gurmukhi;
    public static Script Hangul;
    public static Script Han;
    public static Script Hanunoo;
    public static Script Hatran;
    public static Script Hebrew;
    public static Script Hiragana;
    public static Script AnatolianHieroglyphs;
    public static Script PahawhHmong;
    public static Script NyiakengPuachueHmong;
    public static Script KatakanaOrHiragana;
    public static Script OldHungarian;
    public static Script OldItalic;
    public static Script Javanese;
    public static Script KayahLi;
    public static Script Katakana;
    public static Script Kawi;
    public static Script Kharoshthi;
    public static Script Khmer;
    public static Script Khojki;
    public static Script KhitanSmallScript;
    public static Script Kannada;
    public static Script Kaithi;
    public static Script TaiTham;
    public static Script Lao;
    public static Script Latin;
    public static Script Lepcha;
    public static Script Limbu;
    public static Script LinearA;
    public static Script LinearB;
    public static Script Lisu;
    public static Script Lycian;
    public static Script Lydian;
    public static Script Mahajani;
    public static Script Makasar;
    public static Script Mandaic;
    public static Script Manichaean;
    public static Script Marchen;
    public static Script Medefaidrin;
    public static Script MendeKikakui;
    public static Script MeroiticCursive;
    public static Script MeroiticHieroglyphs;
    public static Script Malayalam;
    public static Script Modi;
    public static Script Mongolian;
    public static Script Mro;
    public static Script MeeteiMayek;
    public static Script Multani;
    public static Script Myanmar;
    public static Script NagMundari;
    public static Script Nandinagari;
    public static Script OldNorthArabian;
    public static Script Nabataean;
    public static Script Newa;
    public static Script Nko;
    public static Script Nushu;
    public static Script Ogham;
    public static Script OlChiki;
    public static Script OldTurkic;
    public static Script Oriya;
    public static Script Osage;
    public static Script Osmanya;
    public static Script OldUyghur;
    public static Script Palmyrene;
    public static Script PauCinHau;
    public static Script OldPermic;
    public static Script PhagsPa;
    public static Script InscriptionalPahlavi;
    public static Script PsalterPahlavi;
    public static Script Phoenician;
    public static Script Miao;
    public static Script InscriptionalParthian;
    public static Script Rejang;
    public static Script HanifiRohingya;
    public static Script Runic;
    public static Script Samaritan;
    public static Script OldSouthArabian;
    public static Script Saurashtra;
    public static Script SignWriting;
    public static Script Shavian;
    public static Script Sharada;
    public static Script Siddham;
    public static Script Khudawadi;
    public static Script Sinhala;
    public static Script Sogdian;
    public static Script OldSogdian;
    public static Script SoraSompeng;
    public static Script Soyombo;
    public static Script Sundanese;
    public static Script SylotiNagri;
    public static Script Syriac;
    public static Script Tagbanwa;
    public static Script Takri;
    public static Script TaiLe;
    public static Script NewTaiLue;
    public static Script Tamil;
    public static Script Tangut;
    public static Script TaiViet;
    public static Script Telugu;
    public static Script Tifinagh;
    public static Script Tagalog;
    public static Script Thaana;
    public static Script Thai;
    public static Script Tibetan;
    public static Script Tirhuta;
    public static Script Tangsa;
    public static Script Toto;
    public static Script Ugaritic;
    public static Script Vai;
    public static Script Vithkuqi;
    public static Script WarangCiti;
    public static Script Wancho;
    public static Script OldPersian;
    public static Script Cuneiform;
    public static Script Yezidi;
    public static Script Yi;
    public static Script ZanabazarSquare;
}
internal static class Avalonia.Media.TextFormatting.Unicode.UnicodeData : object {
    internal static int CATEGORY_BITS;
    internal static int SCRIPT_BITS;
    internal static int LINEBREAK_BITS;
    internal static int BIDIPAIREDBRACKED_BITS;
    internal static int BIDIPAIREDBRACKEDTYPE_BITS;
    internal static int BIDICLASS_BITS;
    internal static int SCRIPT_SHIFT;
    internal static int LINEBREAK_SHIFT;
    internal static int BIDIPAIREDBRACKEDTYPE_SHIFT;
    internal static int BIDICLASS_SHIFT;
    internal static int CATEGORY_MASK;
    internal static int SCRIPT_MASK;
    internal static int LINEBREAK_MASK;
    internal static int BIDIPAIREDBRACKED_MASK;
    internal static int BIDIPAIREDBRACKEDTYPE_MASK;
    internal static int BIDICLASS_MASK;
    public static GeneralCategory GetGeneralCategory(UInt32 codepoint);
    public static Script GetScript(UInt32 codepoint);
    public static BidiClass GetBiDiClass(UInt32 codepoint);
    public static BidiPairedBracketType GetBiDiPairedBracketType(UInt32 codepoint);
    public static Codepoint GetBiDiPairedBracket(UInt32 codepoint);
    public static LineBreakClass GetLineBreakClass(UInt32 codepoint);
    public static GraphemeBreakClass GetGraphemeClusterBreak(UInt32 codepoint);
}
internal static class Avalonia.Media.TextFormatting.Unicode.UnicodeDataTrie : object {
    public static UnicodeTrie Trie { get; }
    private static ReadOnlySpan`1<UInt32> Data { get; }
    public static UnicodeTrie get_Trie();
    private static ReadOnlySpan`1<UInt32> get_Data();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class Avalonia.Media.TextFormatting.Unicode.UnicodeTrie : ValueType {
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<UInt32> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HighStart>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ErrorValue>k__BackingField;
    public ReadOnlySpan`1<UInt32> Data { get; }
    public int HighStart { get; }
    public UInt32 ErrorValue { get; }
    public UnicodeTrie(ReadOnlySpan`1<UInt32> data, int highStart, UInt32 errorValue);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<UInt32> get_Data();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_HighStart();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ErrorValue();
    public UInt32 Get(UInt32 codePoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.TextFormatting.Unicode.UnicodeTrieBuilder : object {
    internal static int SHIFT_1;
    internal static int SHIFT_2;
    private static int SHIFT_1_2;
    internal static int OMITTED_BMP_INDEX_1_LENGTH;
    private static int CP_PER_INDEX_1_ENTRY;
    private static int INDEX_2_BLOCK_LENGTH;
    internal static int INDEX_2_MASK;
    private static int DATA_BLOCK_LENGTH;
    internal static int DATA_MASK;
    internal static int INDEX_SHIFT;
    internal static int DATA_GRANULARITY;
    private static int INDEX_2_OFFSET;
    internal static int LSCP_INDEX_2_OFFSET;
    private static int LSCP_INDEX_2_LENGTH;
    private static int INDEX_2_BMP_LENGTH;
    private static int UTF8_2B_INDEX_2_OFFSET;
    private static int UTF8_2B_INDEX_2_LENGTH;
    internal static int INDEX_1_OFFSET;
    private static int MAX_INDEX_1_LENGTH;
    private static int BAD_UTF8_DATA_OFFSET;
    private static int DATA_START_OFFSET;
    private static int DATA_NULL_OFFSET;
    private static int NEW_DATA_START_OFFSET;
    private static int DATA_0800_OFFSET;
    private static int INITIAL_DATA_LENGTH;
    private static int MEDIUM_DATA_LENGTH;
    private static int MAX_DATA_LENGTH_RUNTIME;
    private static int INDEX_1_LENGTH;
    private static int MAX_DATA_LENGTH_BUILDTIME;
    private static int INDEX_GAP_OFFSET;
    private static int INDEX_GAP_LENGTH;
    private static int MAX_INDEX_2_LENGTH;
    private static int INDEX_2_NULL_OFFSET;
    private static int INDEX_2_START_OFFSET;
    private static int MAX_INDEX_LENGTH;
    private UInt32 _initialValue;
    private UInt32 _errorValue;
    private Int32[] _index1;
    private Int32[] _index2;
    private int _highStart;
    private UInt32[] _data;
    private int _dataCapacity;
    private int _firstFreeBlock;
    private bool _isCompacted;
    private Int32[] _map;
    private int _dataNullOffset;
    private int _dataLength;
    private int _index2NullOffset;
    private int _index2Length;
    public UnicodeTrieBuilder(UInt32 initialValue, UInt32 errorValue);
    public UnicodeTrieBuilder Set(int codePoint, UInt32 value);
    public UnicodeTrieBuilder SetRange(int start, int end, UInt32 value, bool overwrite);
    public UInt32 Get(int c, bool fromLSCP);
    public UnicodeTrie Freeze();
    private bool IsInNullBlock(int c, bool forLSCP);
    private int AllocIndex2Block();
    private int GetIndex2Block(int c, bool forLSCP);
    private bool IsWritableBlock(int block);
    private int AllocDataBlock(int copyBlock);
    private void ReleaseDataBlock(int block);
    private void SetIndex2Entry(int i2, int block);
    private int GetDataBlock(int c, bool forLSCP);
    private void FillBlock(int block, int start, int limit, UInt32 value, UInt32 initialValue, bool overwrite);
    private void WriteBlock(int block, UInt32 value);
    private int FindHighStart(UInt32 highValue);
    private int FindSameDataBlock(int dataLength, int otherBlock, int blockLength);
    private int FindSameIndex2Block(int index2Length, int otherBlock);
    private void CompactData();
    private void CompactIndex2();
    private void Compact();
    private static bool EqualSequence(IReadOnlyList`1<UInt32> a, int s, int t, int length);
    private static bool EqualSequence(IReadOnlyList`1<int> a, int s, int t, int length);
}
internal class Avalonia.Media.TextFormatting.Unicode.Utf16Utils : object {
    [NullableContextAttribute("1")]
public static int CharacterOffsetToStringOffset(string s, int off, bool throwOnOutOfRange);
}
public class Avalonia.Media.TextFormatting.UnshapedTextRun : TextRun {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Text>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TextRunProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <BidiLevel>k__BackingField;
    public int Length { get; }
    public ReadOnlyMemory`1<char> Text { get; }
    [NullableAttribute("1")]
public TextRunProperties Properties { get; }
    public sbyte BidiLevel { get; }
    public UnshapedTextRun(ReadOnlyMemory`1<char> text, TextRunProperties properties, sbyte biDiLevel);
    public virtual int get_Length();
    [CompilerGeneratedAttribute]
public virtual ReadOnlyMemory`1<char> get_Text();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual TextRunProperties get_Properties();
    [CompilerGeneratedAttribute]
public sbyte get_BidiLevel();
}
internal class Avalonia.Media.TextFormatting.WrappingTextLineBreak : TextLineBreak {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<TextRun> _remainingRuns;
    [NullableContextAttribute("1")]
public WrappingTextLineBreak(TextEndOfLine textEndOfLine, FlowDirection flowDirection, List`1<TextRun> remainingRuns);
    public List`1<TextRun> AcquireRemainingRuns();
}
[IsReadOnlyAttribute]
public class Avalonia.Media.TextHitTestResult : ValueType {
    [CompilerGeneratedAttribute]
private CharacterHit <CharacterHit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInside>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TextPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTrailing>k__BackingField;
    public CharacterHit CharacterHit { get; }
    public bool IsInside { get; }
    public int TextPosition { get; }
    public bool IsTrailing { get; }
    public TextHitTestResult(CharacterHit characterHit, int textPosition, bool isInside, bool isTrailing);
    [CompilerGeneratedAttribute]
public CharacterHit get_CharacterHit();
    [CompilerGeneratedAttribute]
public bool get_IsInside();
    [CompilerGeneratedAttribute]
public int get_TextPosition();
    [CompilerGeneratedAttribute]
public bool get_IsTrailing();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TextHitTestResult left, TextHitTestResult right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TextHitTestResult left, TextHitTestResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextHitTestResult other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextLeadingPrefixTrimming : TextTrimming {
    private string _ellipsis;
    private int _prefixLength;
    public TextLeadingPrefixTrimming(string ellipsis, int prefixLength);
    public virtual TextCollapsingProperties CreateCollapsingProperties(TextCollapsingCreateInfo createInfo);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Media.TextNoneTrimming : TextTrimming {
    public virtual TextCollapsingProperties CreateCollapsingProperties(TextCollapsingCreateInfo createInfo);
    public virtual string ToString();
}
public enum Avalonia.Media.TextRenderingMode : Enum {
    public byte value__;
    public static TextRenderingMode Unspecified;
    public static TextRenderingMode SubpixelAntialias;
    public static TextRenderingMode Antialias;
    public static TextRenderingMode Alias;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TextTrailingTrimming : TextTrimming {
    private string _ellipsis;
    private bool _isWordBased;
    public TextTrailingTrimming(string ellipsis, bool isWordBased);
    public virtual TextCollapsingProperties CreateCollapsingProperties(TextCollapsingCreateInfo createInfo);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.TextTrimming : object {
    internal static string DefaultEllipsisChar;
    [CompilerGeneratedAttribute]
private static TextTrimming <None>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextTrimming <CharacterEllipsis>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextTrimming <WordEllipsis>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextTrimming <PrefixCharacterEllipsis>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextTrimming <LeadingCharacterEllipsis>k__BackingField;
    public static TextTrimming None { get; }
    public static TextTrimming CharacterEllipsis { get; }
    public static TextTrimming WordEllipsis { get; }
    public static TextTrimming PrefixCharacterEllipsis { get; }
    public static TextTrimming LeadingCharacterEllipsis { get; }
    private static TextTrimming();
    [CompilerGeneratedAttribute]
public static TextTrimming get_None();
    [CompilerGeneratedAttribute]
public static TextTrimming get_CharacterEllipsis();
    [CompilerGeneratedAttribute]
public static TextTrimming get_WordEllipsis();
    [CompilerGeneratedAttribute]
public static TextTrimming get_PrefixCharacterEllipsis();
    [CompilerGeneratedAttribute]
public static TextTrimming get_LeadingCharacterEllipsis();
    public abstract virtual TextCollapsingProperties CreateCollapsingProperties(TextCollapsingCreateInfo createInfo);
    public static TextTrimming Parse(string s);
    [CompilerGeneratedAttribute]
internal static bool <Parse>g__Matches|17_0(string name, <>c__DisplayClass17_0& );
}
public enum Avalonia.Media.TextWrapping : Enum {
    public int value__;
    public static TextWrapping NoWrap;
    public static TextWrapping Wrap;
    public static TextWrapping WrapWithOverflow;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.TileBrush : Brush {
    public static StyledProperty`1<AlignmentX> AlignmentXProperty;
    public static StyledProperty`1<AlignmentY> AlignmentYProperty;
    public static StyledProperty`1<RelativeRect> DestinationRectProperty;
    public static StyledProperty`1<RelativeRect> SourceRectProperty;
    public static StyledProperty`1<Stretch> StretchProperty;
    public static StyledProperty`1<TileMode> TileModeProperty;
    public AlignmentX AlignmentX { get; public set; }
    public AlignmentY AlignmentY { get; public set; }
    public RelativeRect DestinationRect { get; public set; }
    public RelativeRect SourceRect { get; public set; }
    public Stretch Stretch { get; public set; }
    public TileMode TileMode { get; public set; }
    private static TileBrush();
    public sealed virtual AlignmentX get_AlignmentX();
    public void set_AlignmentX(AlignmentX value);
    public sealed virtual AlignmentY get_AlignmentY();
    public void set_AlignmentY(AlignmentY value);
    public sealed virtual RelativeRect get_DestinationRect();
    public void set_DestinationRect(RelativeRect value);
    public sealed virtual RelativeRect get_SourceRect();
    public void set_SourceRect(RelativeRect value);
    public sealed virtual Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public sealed virtual TileMode get_TileMode();
    public void set_TileMode(TileMode value);
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
}
public enum Avalonia.Media.TileMode : Enum {
    public int value__;
    public static TileMode None;
    public static TileMode FlipX;
    public static TileMode FlipY;
    public static TileMode FlipXY;
    public static TileMode Tile;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Media.Transform : Animatable {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Changed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private CompositorResourceHolder`1<ServerCompositionSimpleTransform> _resource;
    public Matrix Value { get; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_Changed(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(EventHandler value);
    public abstract virtual Matrix get_Value();
    public static Transform Parse(string s);
    protected void RaiseChanged();
    public ImmutableTransform ToImmutable();
    public virtual string ToString();
    private sealed virtual override ITransform Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource<Avalonia.Media.ITransform>.GetForCompositor(Compositor c);
    private sealed virtual override SimpleServerObject Avalonia.Rendering.Composition.ICompositorSerializable.TryGetServer(Compositor c);
    private sealed virtual override void Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource.AddRefOnCompositor(Compositor c);
    private sealed virtual override void Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource.ReleaseOnCompositor(Compositor c);
    private sealed virtual override void Avalonia.Rendering.Composition.ICompositorSerializable.SerializeChanges(Compositor c, BatchStreamWriter writer);
}
internal static class Avalonia.Media.Transformation.InterpolationUtilities : object {
    public static double InterpolateScalars(double from, double to, double progress);
    public static Vector InterpolateVectors(Vector from, Vector to, double progress);
    public static Matrix ComposeTransform(Decomposed decomposed);
    public static Decomposed InterpolateDecomposedTransforms(Decomposed& from, Decomposed& to, double progress);
}
public class Avalonia.Media.Transformation.TransformOperation : ValueType {
    public OperationType Type;
    public Matrix Matrix;
    public DataLayout Data;
    public bool IsIdentity { get; }
    public static TransformOperation Identity { get; }
    public bool get_IsIdentity();
    public void Bake();
    public static TransformOperation get_Identity();
    public static bool TryInterpolate(Nullable`1<TransformOperation> from, Nullable`1<TransformOperation> to, double progress, TransformOperation& result);
    private static bool IsOperationIdentity(Nullable`1& operation);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TransformOperation left, TransformOperation right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TransformOperation left, TransformOperation right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TransformOperation other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.Transformation.TransformOperations : object {
    [CompilerGeneratedAttribute]
private static TransformOperations <Identity>k__BackingField;
    private List`1<TransformOperation> _operations;
    [CompilerGeneratedAttribute]
private bool <IsIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix <Value>k__BackingField;
    public static TransformOperations Identity { get; }
    public bool IsIdentity { get; }
    public IReadOnlyList`1<TransformOperation> Operations { get; }
    public Matrix Value { get; }
    private TransformOperations(List`1<TransformOperation> operations);
    private static TransformOperations();
    [CompilerGeneratedAttribute]
public static TransformOperations get_Identity();
    [CompilerGeneratedAttribute]
public bool get_IsIdentity();
    public IReadOnlyList`1<TransformOperation> get_Operations();
    [CompilerGeneratedAttribute]
public sealed virtual Matrix get_Value();
    public static TransformOperations Parse(string s);
    public static Builder CreateBuilder(int capacity);
    public static TransformOperations Interpolate(TransformOperations from, TransformOperations to, double progress);
    private Matrix ApplyTransforms(int startOffset);
    private bool CheckIsIdentity();
    private static bool TryInterpolate(TransformOperations from, TransformOperations to, double progress, TransformOperations& result);
    private static bool ComputeDecomposedTransform(TransformOperations operations, int startOffset, Decomposed& decomposed);
    private static int ComputeMatchingPrefixLength(TransformOperations from, TransformOperations to);
}
internal static class Avalonia.Media.Transformation.TransformParser : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] s_functionMapping;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] s_unitMapping;
    private static TransformParser();
    [NullableContextAttribute("1")]
public static TransformOperations Parse(string s);
    private static void ParseFunction(ReadOnlySpan`1& functionPart, TransformFunction function, Builder& builder);
    private static void VerifyZeroOrUnit(TransformFunction function, UnitValue& value, Unit unit);
    private static void VerifyZeroOrAngle(TransformFunction function, UnitValue& value);
    private static bool IsAngleUnit(Unit unit);
    private static void ThrowFormatInvalidValue(TransformFunction function, UnitValue& value);
    private static void ThrowFormatInvalidValueCount(TransformFunction function, int count);
    private static Unit ParseUnit(ReadOnlySpan`1& part);
    private static TransformFunction ParseTransformFunction(ReadOnlySpan`1& part);
    private static double ToRadians(UnitValue& value);
    [CompilerGeneratedAttribute]
internal static void <Parse>g__ThrowInvalidFormat|2_0(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static UnitValue <ParseFunction>g__ParseValue|3_0(ReadOnlySpan`1<char> part);
    [CompilerGeneratedAttribute]
internal static int <ParseFunction>g__ParseValuePair|3_1(ReadOnlySpan`1& part, UnitValue& leftValue, UnitValue& rightValue);
    [CompilerGeneratedAttribute]
internal static int <ParseFunction>g__ParseCommaDelimitedValues|3_2(ReadOnlySpan`1<char> part, Span`1& outValues);
}
public class Avalonia.Media.TransformConverter : TypeConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    [NullableContextAttribute("2")]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[ExtensionAttribute]
public static class Avalonia.Media.TransformExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableTransform ToImmutable(ITransform transform);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TransformGroup : Transform {
    public static StyledProperty`1<Transforms> ChildrenProperty;
    [NullableAttribute("2")]
private IDisposable _childrenNotificationSubscription;
    private EventHandler _childTransformChangedHandler;
    private Nullable`1<Matrix> _lastMatrix;
    [ContentAttribute]
public Transforms Children { get; public set; }
    public Matrix Value { get; }
    private static TransformGroup();
    public Transforms get_Children();
    public void set_Children(Transforms value);
    public virtual Matrix get_Value();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(object _, EventArgs _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnPropertyChanged>b__10_0(Transform tr);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnPropertyChanged>b__10_1(Transform tr);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.Media.Transforms : AvaloniaList`1<Transform> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.TranslateTransform : Transform {
    public static StyledProperty`1<double> XProperty;
    public static StyledProperty`1<double> YProperty;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Matrix Value { get; }
    public TranslateTransform(double x, double y);
    private static TranslateTransform();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual Matrix get_Value();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Name = {FontFamily.Name}, Weight = {Weight}, Style = {Style}")]
public class Avalonia.Media.Typeface : ValueType {
    [CompilerGeneratedAttribute]
private static Typeface <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private FontFamily <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private FontWeight <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStretch <Stretch>k__BackingField;
    public static Typeface Default { get; }
    public FontFamily FontFamily { get; }
    public FontStyle Style { get; }
    public FontWeight Weight { get; }
    public FontStretch Stretch { get; }
    public IGlyphTypeface GlyphTypeface { get; }
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch);
    public Typeface(string fontFamilyName, FontStyle style, FontWeight weight, FontStretch stretch);
    private static Typeface();
    [CompilerGeneratedAttribute]
public static Typeface get_Default();
    [CompilerGeneratedAttribute]
public FontFamily get_FontFamily();
    [CompilerGeneratedAttribute]
public FontStyle get_Style();
    [CompilerGeneratedAttribute]
public FontWeight get_Weight();
    [CompilerGeneratedAttribute]
public FontStretch get_Stretch();
    public IGlyphTypeface get_GlyphTypeface();
    public static bool op_Inequality(Typeface a, Typeface b);
    public static bool op_Equality(Typeface a, Typeface b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Typeface other);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class Avalonia.Media.UnicodeRange : ValueType {
    public static UnicodeRange Default;
    private UnicodeRangeSegment _single;
    [NullableAttribute("2")]
private IReadOnlyList`1<UnicodeRangeSegment> _segments;
    internal UnicodeRangeSegment Single { get; }
    [NullableAttribute("2")]
internal IReadOnlyList`1<UnicodeRangeSegment> Segments { get; }
    public UnicodeRange(int start, int end);
    public UnicodeRange(UnicodeRangeSegment single);
    [NullableContextAttribute("1")]
public UnicodeRange(IReadOnlyList`1<UnicodeRangeSegment> segments);
    private static UnicodeRange();
    internal UnicodeRangeSegment get_Single();
    [NullableContextAttribute("2")]
internal IReadOnlyList`1<UnicodeRangeSegment> get_Segments();
    public bool IsInRange(int value);
    [NullableContextAttribute("1")]
public static UnicodeRange Parse(string s);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UnicodeRange left, UnicodeRange right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UnicodeRange left, UnicodeRange right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnicodeRange other);
}
[IsReadOnlyAttribute]
public class Avalonia.Media.UnicodeRangeSegment : ValueType {
    [NullableAttribute("1")]
private static Regex s_regex;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    public int Start { get; }
    public int End { get; }
    public UnicodeRangeSegment(int start, int end);
    private static UnicodeRangeSegment();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_End();
    public bool IsInRange(int value);
    [NullableContextAttribute("1")]
public static UnicodeRangeSegment Parse(string s);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UnicodeRangeSegment left, UnicodeRangeSegment right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UnicodeRangeSegment left, UnicodeRangeSegment right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnicodeRangeSegment other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Media.VisualBrush : TileBrush {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Visual> VisualProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private InlineDictionary`2<Compositor, RenderDataItem> _renderDataDictionary;
    [NullableAttribute("2")]
public Visual Visual { get; public set; }
    internal Func`2<Compositor, ServerCompositionSimpleBrush> Factory { get; }
    public VisualBrush(Visual visual);
    private static VisualBrush();
    [NullableContextAttribute("2")]
public Visual get_Visual();
    [NullableContextAttribute("2")]
public void set_Visual(Visual value);
    [NullableContextAttribute("2")]
private sealed virtual override ISceneBrushContent Avalonia.Media.ISceneBrush.CreateContent();
    internal virtual Func`2<Compositor, ServerCompositionSimpleBrush> get_Factory();
    protected virtual void OnUnreferencedFromCompositor(Compositor c);
    private protected virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
    private void InvalidateContent();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    private RenderDataItem CreateServerContent(Compositor c);
}
[AttributeUsageAttribute("132")]
public class Avalonia.Metadata.AmbientAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Avalonia.Metadata.AvaloniaListAttribute : Attribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Separators>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSplitOptions <SplitOptions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Separators { get; public set; }
    public StringSplitOptions SplitOptions { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Separators();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Separators(String[] value);
    [CompilerGeneratedAttribute]
public StringSplitOptions get_SplitOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SplitOptions(StringSplitOptions value);
}
[AttributeUsageAttribute("128")]
public class Avalonia.Metadata.ContentAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class Avalonia.Metadata.DataTypeAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class Avalonia.Metadata.DependsOnAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public DependsOnAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
public interface Avalonia.Metadata.IAddChild {
    public abstract virtual void AddChild(object child);
}
[NullableContextAttribute("1")]
public interface Avalonia.Metadata.IAddChild`1 {
    public abstract virtual void AddChild(T child);
}
[AttributeUsageAttribute("2176")]
public class Avalonia.Metadata.InheritDataTypeFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private InheritDataTypeFromScopeKind <ScopeKind>k__BackingField;
    public InheritDataTypeFromScopeKind ScopeKind { get; }
    public InheritDataTypeFromAttribute(InheritDataTypeFromScopeKind scopeKind);
    [CompilerGeneratedAttribute]
public InheritDataTypeFromScopeKind get_ScopeKind();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
public class Avalonia.Metadata.InheritDataTypeFromItemsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AncestorItemsProperty>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <AncestorType>k__BackingField;
    public string AncestorItemsProperty { get; }
    [NullableAttribute("2")]
public Type AncestorType { get; public set; }
    public InheritDataTypeFromItemsAttribute(string ancestorItemsProperty);
    [CompilerGeneratedAttribute]
public string get_AncestorItemsProperty();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_AncestorType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_AncestorType(Type value);
}
public enum Avalonia.Metadata.InheritDataTypeFromScopeKind : Enum {
    public int value__;
    public static InheritDataTypeFromScopeKind Style;
    public static InheritDataTypeFromScopeKind ControlTemplate;
}
[AttributeUsageAttribute("128")]
public class Avalonia.Metadata.MarkupExtensionDefaultOptionAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
public class Avalonia.Metadata.MarkupExtensionOptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public object Value { get; }
    public int Priority { get; public set; }
    public MarkupExtensionOptionAttribute(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
}
[AttributeUsageAttribute("1024")]
public class Avalonia.Metadata.NotClientImplementableAttribute : Attribute {
}
[AttributeUsageAttribute("1516")]
public class Avalonia.Metadata.PrivateApiAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
public class Avalonia.Metadata.TemplateContentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <TemplateResultType>k__BackingField;
    public Type TemplateResultType { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_TemplateResultType();
    [CompilerGeneratedAttribute]
public void set_TemplateResultType(Type value);
}
[AttributeUsageAttribute("4")]
public class Avalonia.Metadata.TrimSurroundingWhitespaceAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class Avalonia.Metadata.UnstableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public UnstableAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
[AttributeUsageAttribute("4")]
public class Avalonia.Metadata.UsableDuringInitializationAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Avalonia.Metadata.WhitespaceSignificantCollectionAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class Avalonia.Metadata.XmlnsDefinitionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <XmlNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrNamespace>k__BackingField;
    public string XmlNamespace { get; }
    public string ClrNamespace { get; }
    public XmlnsDefinitionAttribute(string xmlNamespace, string clrNamespace);
    [CompilerGeneratedAttribute]
public string get_XmlNamespace();
    [CompilerGeneratedAttribute]
public string get_ClrNamespace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class Avalonia.Metadata.XmlnsPrefixAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <XmlNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public string XmlNamespace { get; }
    public string Prefix { get; }
    public XmlnsPrefixAttribute(string xmlNamespace, string prefix);
    [CompilerGeneratedAttribute]
public string get_XmlNamespace();
    [CompilerGeneratedAttribute]
public string get_Prefix();
}
[IsReadOnlyAttribute]
public class Avalonia.PixelPoint : ValueType {
    public static PixelPoint Origin;
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    public int X { get; }
    public int Y { get; }
    public PixelPoint(int x, int y);
    private static PixelPoint();
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public int get_Y();
    public static bool op_Equality(PixelPoint left, PixelPoint right);
    public static bool op_Inequality(PixelPoint left, PixelPoint right);
    public static PixelVector op_Implicit(PixelPoint p);
    public static PixelPoint op_Addition(PixelPoint a, PixelPoint b);
    public static PixelPoint op_Addition(PixelPoint a, PixelVector b);
    public static PixelPoint op_Subtraction(PixelPoint a, PixelPoint b);
    public static PixelPoint op_Subtraction(PixelPoint a, PixelVector b);
    [NullableContextAttribute("1")]
public static PixelPoint Parse(string s);
    public sealed virtual bool Equals(PixelPoint other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public PixelPoint WithX(int x);
    public PixelPoint WithY(int y);
    public Point ToPoint(double scale);
    public Point ToPoint(Vector scale);
    public Point ToPointWithDpi(double dpi);
    public Point ToPointWithDpi(Vector dpi);
    public static PixelPoint FromPoint(Point point, double scale);
    public static PixelPoint FromPoint(Point point, Vector scale);
    public static PixelPoint FromPointWithDpi(Point point, double dpi);
    public static PixelPoint FromPointWithDpi(Point point, Vector dpi);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Avalonia.PixelRect : ValueType {
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public int X { get; }
    public int Y { get; }
    public int Width { get; }
    public int Height { get; }
    public PixelPoint Position { get; }
    public PixelSize Size { get; }
    public int Right { get; }
    public int Bottom { get; }
    public PixelPoint TopLeft { get; }
    public PixelPoint TopRight { get; }
    public PixelPoint BottomLeft { get; }
    public PixelPoint BottomRight { get; }
    public PixelPoint Center { get; }
    public PixelRect(int x, int y, int width, int height);
    public PixelRect(PixelSize size);
    public PixelRect(PixelPoint position, PixelSize size);
    public PixelRect(PixelPoint topLeft, PixelPoint bottomRight);
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public int get_Y();
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    public PixelPoint get_Position();
    public PixelSize get_Size();
    public int get_Right();
    public int get_Bottom();
    public PixelPoint get_TopLeft();
    public PixelPoint get_TopRight();
    public PixelPoint get_BottomLeft();
    public PixelPoint get_BottomRight();
    public PixelPoint get_Center();
    public static bool op_Equality(PixelRect left, PixelRect right);
    public static bool op_Inequality(PixelRect left, PixelRect right);
    public bool Contains(PixelPoint p);
    public bool ContainsExclusive(PixelPoint p);
    public bool Contains(PixelRect r);
    public PixelRect CenterRect(PixelRect rect);
    public sealed virtual bool Equals(PixelRect other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public PixelRect Intersect(PixelRect rect);
    public bool Intersects(PixelRect rect);
    public PixelRect Translate(PixelVector offset);
    public PixelRect Union(PixelRect rect);
    public PixelRect WithX(int x);
    public PixelRect WithY(int y);
    public PixelRect WithWidth(int width);
    public PixelRect WithHeight(int height);
    public Rect ToRect(double scale);
    public Rect ToRect(Vector scale);
    public Rect ToRectWithDpi(double dpi);
    public Rect ToRectWithDpi(Vector dpi);
    public static PixelRect FromRect(Rect rect, double scale);
    public static PixelRect FromRect(Rect rect, Vector scale);
    public static PixelRect FromRectWithDpi(Rect rect, double dpi);
    public static PixelRect FromRectWithDpi(Rect rect, Vector dpi);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static PixelRect Parse(string s);
    private static PixelPoint FromPointCeiling(Point point, Vector scale);
}
[IsReadOnlyAttribute]
public class Avalonia.PixelSize : ValueType {
    public static PixelSize Empty;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public double AspectRatio { get; }
    public int Width { get; }
    public int Height { get; }
    public PixelSize(int width, int height);
    private static PixelSize();
    public double get_AspectRatio();
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    public static bool op_Equality(PixelSize left, PixelSize right);
    public static bool op_Inequality(PixelSize left, PixelSize right);
    [NullableContextAttribute("1")]
public static PixelSize Parse(string s);
    [NullableContextAttribute("2")]
public static bool TryParse(string source, PixelSize& result);
    public sealed virtual bool Equals(PixelSize other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public PixelSize WithWidth(int width);
    public PixelSize WithHeight(int height);
    public Size ToSize(double scale);
    public Size ToSize(Vector scale);
    public Size ToSizeWithDpi(double dpi);
    public Size ToSizeWithDpi(Vector dpi);
    public static PixelSize FromSize(Size size, double scale);
    internal static PixelSize FromSizeRounded(Size size, double scale);
    public static PixelSize FromSize(Size size, Vector scale);
    public static PixelSize FromSizeWithDpi(Size size, double dpi);
    public static PixelSize FromSizeWithDpi(Size size, Vector dpi);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Avalonia.PixelVector : ValueType {
    private int _x;
    private int _y;
    public int X { get; }
    public int Y { get; }
    public double Length { get; }
    public PixelVector(int x, int y);
    public int get_X();
    public int get_Y();
    public static PixelPoint op_Explicit(PixelVector a);
    public static int op_Multiply(PixelVector a, PixelVector b);
    public static PixelVector op_Multiply(PixelVector vector, int scale);
    public static PixelVector op_Division(PixelVector vector, int scale);
    public double get_Length();
    public static PixelVector op_UnaryNegation(PixelVector a);
    public static PixelVector op_Addition(PixelVector a, PixelVector b);
    public static PixelVector op_Subtraction(PixelVector a, PixelVector b);
    public bool Equals(PixelVector other);
    public bool NearlyEquals(PixelVector other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PixelVector left, PixelVector right);
    public static bool op_Inequality(PixelVector left, PixelVector right);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public PixelVector WithX(int x);
    public PixelVector WithY(int y);
}
public enum Avalonia.Platform.AlphaFormat : Enum {
    public int value__;
    public static AlphaFormat Premul;
    public static AlphaFormat Unpremul;
    public static AlphaFormat Opaque;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Platform.AssetLoader : object {
    private static IAssetLoader GetAssetLoader();
    public static void SetDefaultAssembly(Assembly assembly);
    public static bool Exists(Uri uri, Uri baseUri);
    public static Stream Open(Uri uri, Uri baseUri);
    public static ValueTuple`2<Stream, Assembly> OpenAndGetAssembly(Uri uri, Uri baseUri);
    [NullableContextAttribute("2")]
public static Assembly GetAssembly(Uri uri, Uri baseUri);
    public static IEnumerable`1<Uri> GetAssets(Uri uri, Uri baseUri);
    public static void InvalidateAssemblyCache(string name);
    public static void InvalidateAssemblyCache();
    internal static void RegisterResUriParsers();
}
public enum Avalonia.Platform.ColorContrastPreference : Enum {
    public int value__;
    public static ColorContrastPreference NoPreference;
    public static ColorContrastPreference High;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Platform.DefaultPlatformSettings : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<PlatformColorValues> ColorValuesChanged;
    public TimeSpan HoldWaitDuration { get; }
    public PlatformHotkeyConfiguration HotkeyConfiguration { get; }
    public virtual Size GetTapSize(PointerType type);
    public virtual Size GetDoubleTapSize(PointerType type);
    public virtual TimeSpan GetDoubleTapTime(PointerType type);
    public virtual TimeSpan get_HoldWaitDuration();
    public sealed virtual PlatformHotkeyConfiguration get_HotkeyConfiguration();
    public virtual PlatformColorValues GetColorValues();
    [CompilerGeneratedAttribute]
public virtual void add_ColorValuesChanged(EventHandler`1<PlatformColorValues> value);
    [CompilerGeneratedAttribute]
public virtual void remove_ColorValuesChanged(EventHandler`1<PlatformColorValues> value);
    protected void OnColorValuesChanged(PlatformColorValues colorValues);
}
[ExtensionAttribute]
public static class Avalonia.Platform.DrawingContextImplExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T GetFeature(IDrawingContextImpl context);
}
public enum Avalonia.Platform.FormFactorType : Enum {
    public int value__;
    public static FormFactorType Unknown;
    public static FormFactorType Desktop;
    public static FormFactorType Mobile;
    public static FormFactorType TV;
}
[NullableContextAttribute("1")]
[UnstableAttribute("IAssetLoader interface and AvaloniaLocator usage is considered unstable. Please use AssetLoader static class instead.")]
public interface Avalonia.Platform.IAssetLoader {
    public abstract virtual void SetDefaultAssembly(Assembly assembly);
    public abstract virtual bool Exists(Uri uri, Uri baseUri);
    public abstract virtual Stream Open(Uri uri, Uri baseUri);
    public abstract virtual ValueTuple`2<Stream, Assembly> OpenAndGetAssembly(Uri uri, Uri baseUri);
    [NullableContextAttribute("2")]
public abstract virtual Assembly GetAssembly(Uri uri, Uri baseUri);
    public abstract virtual IEnumerable`1<Uri> GetAssets(Uri uri, Uri baseUri);
    public abstract virtual void InvalidateAssemblyCache(string name);
    public abstract virtual void InvalidateAssemblyCache();
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
public interface Avalonia.Platform.IBitmapImpl {
    public Vector Dpi { get; }
    public PixelSize PixelSize { get; }
    public int Version { get; }
    public abstract virtual Vector get_Dpi();
    public abstract virtual PixelSize get_PixelSize();
    public abstract virtual int get_Version();
    public abstract virtual void Save(string fileName, Nullable`1<int> quality);
    public abstract virtual void Save(Stream stream, Nullable`1<int> quality);
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
public interface Avalonia.Platform.ICursorFactory {
    public abstract virtual ICursorImpl GetCursor(StandardCursorType cursorType);
    public abstract virtual ICursorImpl CreateCursor(IBitmapImpl cursor, PixelPoint hotSpot);
}
[UnstableAttribute]
public interface Avalonia.Platform.ICursorImpl {
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.IDrawingContextImpl {
    public Matrix Transform { get; public set; }
    public abstract virtual Matrix get_Transform();
    public abstract virtual void set_Transform(Matrix value);
    public abstract virtual void Clear(Color color);
    public abstract virtual void DrawBitmap(IBitmapImpl source, double opacity, Rect sourceRect, Rect destRect);
    public abstract virtual void DrawBitmap(IBitmapImpl source, IBrush opacityMask, Rect opacityMaskRect, Rect destRect);
    [NullableContextAttribute("2")]
public abstract virtual void DrawLine(IPen pen, Point p1, Point p2);
    [NullableContextAttribute("2")]
public abstract virtual void DrawGeometry(IBrush brush, IPen pen, IGeometryImpl geometry);
    [NullableContextAttribute("2")]
public abstract virtual void DrawRectangle(IBrush brush, IPen pen, RoundedRect rect, BoxShadows boxShadows);
    [NullableContextAttribute("2")]
public abstract virtual void DrawRegion(IBrush brush, IPen pen, IPlatformRenderInterfaceRegion region);
    [NullableContextAttribute("2")]
public abstract virtual void DrawEllipse(IBrush brush, IPen pen, Rect rect);
    public abstract virtual void DrawGlyphRun(IBrush foreground, IGlyphRunImpl glyphRun);
    public abstract virtual IDrawingContextLayerImpl CreateLayer(PixelSize size);
    public abstract virtual void PushClip(Rect clip);
    public abstract virtual void PushClip(RoundedRect clip);
    public abstract virtual void PushClip(IPlatformRenderInterfaceRegion region);
    public abstract virtual void PopClip();
    public abstract virtual void PushLayer(Rect bounds);
    public abstract virtual void PopLayer();
    public abstract virtual void PushOpacity(double opacity, Nullable`1<Rect> bounds);
    public abstract virtual void PopOpacity();
    public abstract virtual void PushOpacityMask(IBrush mask, Rect bounds);
    public abstract virtual void PopOpacityMask();
    public abstract virtual void PushGeometryClip(IGeometryImpl clip);
    public abstract virtual void PopGeometryClip();
    public abstract virtual void PushRenderOptions(RenderOptions renderOptions);
    public abstract virtual void PopRenderOptions();
    public abstract virtual object GetFeature(Type t);
}
[NullableContextAttribute("1")]
public interface Avalonia.Platform.IDrawingContextImplWithEffects {
    public abstract virtual void PushEffect(IEffect effect);
    public abstract virtual void PopEffect();
}
public interface Avalonia.Platform.IDrawingContextLayerImpl {
    public bool CanBlit { get; }
    [NullableContextAttribute("1")]
public abstract virtual void Blit(IDrawingContextImpl context);
    public abstract virtual bool get_CanBlit();
}
public interface Avalonia.Platform.IDrawingContextLayerWithRenderContextAffinityImpl {
    public bool HasRenderContextAffinity { get; }
    public abstract virtual bool get_HasRenderContextAffinity();
    [NullableContextAttribute("1")]
public abstract virtual IBitmapImpl CreateNonAffinedSnapshot();
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
public interface Avalonia.Platform.IDrawingContextWithAcrylicLikeSupport {
    public abstract virtual void DrawRectangle(IExperimentalAcrylicMaterial material, RoundedRect rect);
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.IExternalObjectsRenderInterfaceContextFeature {
    public IReadOnlyList`1<string> SupportedImageHandleTypes { get; }
    public IReadOnlyList`1<string> SupportedSemaphoreTypes { get; }
    [NullableAttribute("2")]
public Byte[] DeviceUuid { get; }
    [NullableAttribute("2")]
public Byte[] DeviceLuid { get; }
    public abstract virtual IReadOnlyList`1<string> get_SupportedImageHandleTypes();
    public abstract virtual IReadOnlyList`1<string> get_SupportedSemaphoreTypes();
    public abstract virtual IPlatformRenderInterfaceImportedImage ImportImage(IPlatformHandle handle, PlatformGraphicsExternalImageProperties properties);
    public abstract virtual IPlatformRenderInterfaceImportedImage ImportImage(ICompositionImportableSharedGpuContextImage image);
    public abstract virtual IPlatformRenderInterfaceImportedSemaphore ImportSemaphore(IPlatformHandle handle);
    public abstract virtual CompositionGpuImportedImageSynchronizationCapabilities GetSynchronizationCapabilities(string imageHandleType);
    [NullableContextAttribute("2")]
public abstract virtual Byte[] get_DeviceUuid();
    [NullableContextAttribute("2")]
public abstract virtual Byte[] get_DeviceLuid();
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.IFontManagerImpl {
    public abstract virtual string GetDefaultFontFamilyName();
    public abstract virtual String[] GetInstalledFontFamilyNames(bool checkForUpdates);
    [NullableContextAttribute("2")]
public abstract virtual bool TryMatchCharacter(int codepoint, FontStyle fontStyle, FontWeight fontWeight, FontStretch fontStretch, CultureInfo culture, Typeface& typeface);
    public abstract virtual bool TryCreateGlyphTypeface(string familyName, FontStyle style, FontWeight weight, FontStretch stretch, IGlyphTypeface& glyphTypeface);
    public abstract virtual bool TryCreateGlyphTypeface(Stream stream, FontSimulations fontSimulations, IGlyphTypeface& glyphTypeface);
}
public interface Avalonia.Platform.IGeometryContext {
    public abstract virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection);
    public abstract virtual void BeginFigure(Point startPoint, bool isFilled);
    public abstract virtual void CubicBezierTo(Point controlPoint1, Point controlPoint2, Point endPoint);
    public abstract virtual void QuadraticBezierTo(Point controlPoint, Point endPoint);
    public abstract virtual void LineTo(Point endPoint);
    public abstract virtual void EndFigure(bool isClosed);
    public abstract virtual void SetFillRule(FillRule fillRule);
}
public interface Avalonia.Platform.IGeometryContext2 {
    public abstract virtual void LineTo(Point point, bool isStroked);
    public abstract virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked);
    public abstract virtual void CubicBezierTo(Point controlPoint1, Point controlPoint2, Point endPoint, bool isStroked);
    public abstract virtual void QuadraticBezierTo(Point controlPoint, Point endPoint, bool isStroked);
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.IGeometryImpl {
    public Rect Bounds { get; }
    public double ContourLength { get; }
    public abstract virtual Rect get_Bounds();
    public abstract virtual double get_ContourLength();
    [NullableContextAttribute("2")]
public abstract virtual Rect GetRenderBounds(IPen pen);
    public abstract virtual IGeometryImpl GetWidenedGeometry(IPen pen);
    public abstract virtual bool FillContains(Point point);
    public abstract virtual IGeometryImpl Intersect(IGeometryImpl geometry);
    [NullableContextAttribute("2")]
public abstract virtual bool StrokeContains(IPen pen, Point point);
    public abstract virtual ITransformedGeometryImpl WithTransform(Matrix transform);
    public abstract virtual bool TryGetPointAtDistance(double distance, Point& point);
    public abstract virtual bool TryGetPointAndTangentAtDistance(double distance, Point& point, Point& tangent);
    [NullableContextAttribute("2")]
public abstract virtual bool TryGetSegment(double startDistance, double stopDistance, bool startOnBeginFigure, IGeometryImpl& segmentGeometry);
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.IGlyphRunImpl {
    public IGlyphTypeface GlyphTypeface { get; }
    public double FontRenderingEmSize { get; }
    public Point BaselineOrigin { get; }
    public Rect Bounds { get; }
    public abstract virtual IGlyphTypeface get_GlyphTypeface();
    public abstract virtual double get_FontRenderingEmSize();
    public abstract virtual Point get_BaselineOrigin();
    public abstract virtual Rect get_Bounds();
    public abstract virtual IReadOnlyList`1<float> GetIntersections(float lowerLimit, float upperLimit);
}
public interface Avalonia.Platform.ILockedFramebuffer {
    public IntPtr Address { get; }
    public PixelSize Size { get; }
    public int RowBytes { get; }
    public Vector Dpi { get; }
    public PixelFormat Format { get; }
    public abstract virtual IntPtr get_Address();
    public abstract virtual PixelSize get_Size();
    public abstract virtual int get_RowBytes();
    public abstract virtual Vector get_Dpi();
    public abstract virtual PixelFormat get_Format();
}
[UnstableAttribute]
public interface Avalonia.Platform.IMacOSTopLevelPlatformHandle {
    public IntPtr NSView { get; }
    public IntPtr NSWindow { get; }
    public abstract virtual IntPtr get_NSView();
    public abstract virtual IntPtr GetNSViewRetained();
    public abstract virtual IntPtr get_NSWindow();
    public abstract virtual IntPtr GetNSWindowRetained();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Internal.AssemblyDescriptor : object {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, IAssetDescriptor> <Resources>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, IAssetDescriptor> <AvaloniaResources>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Assembly Assembly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, IAssetDescriptor> Resources { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, IAssetDescriptor> AvaloniaResources { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public AssemblyDescriptor(Assembly assembly);
    [CompilerGeneratedAttribute]
public sealed virtual Assembly get_Assembly();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, IAssetDescriptor> get_Resources();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, IAssetDescriptor> get_AvaloniaResources();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    private static string GetPathRooted(AvaloniaResourcesIndexEntry r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Internal.AssemblyDescriptorResolver : object {
    private Dictionary`2<string, IAssemblyDescriptor> _assemblyNameCache;
    public sealed virtual IAssemblyDescriptor GetAssembly(string name);
    public sealed virtual void InvalidateAssemblyCache(string name);
    public sealed virtual void InvalidateAssemblyCache();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Internal.AssemblyResourceDescriptor : object {
    private Assembly _asm;
    private string _name;
    public Assembly Assembly { get; }
    public AssemblyResourceDescriptor(Assembly asm, string name);
    public sealed virtual Stream GetStream();
    public sealed virtual Assembly get_Assembly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Internal.AvaloniaResourceDescriptor : object {
    private int _offset;
    private int _length;
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    public Assembly Assembly { get; }
    public AvaloniaResourceDescriptor(Assembly asm, int offset, int length);
    [CompilerGeneratedAttribute]
public sealed virtual Assembly get_Assembly();
    public sealed virtual Stream GetStream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Platform.Internal.Constants : object {
    public static string AvaloniaResourceName { get; }
    public static string get_AvaloniaResourceName();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Platform.Internal.IAssemblyDescriptor {
    public Assembly Assembly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, IAssetDescriptor> Resources { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, IAssetDescriptor> AvaloniaResources { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public abstract virtual Assembly get_Assembly();
    public abstract virtual Dictionary`2<string, IAssetDescriptor> get_Resources();
    public abstract virtual Dictionary`2<string, IAssetDescriptor> get_AvaloniaResources();
    [NullableContextAttribute("2")]
public abstract virtual string get_Name();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Platform.Internal.IAssemblyDescriptorResolver {
    public abstract virtual IAssemblyDescriptor GetAssembly(string name);
    public abstract virtual void InvalidateAssemblyCache(string name);
    public abstract virtual void InvalidateAssemblyCache();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Platform.Internal.IAssetDescriptor {
    public Assembly Assembly { get; }
    public abstract virtual Stream GetStream();
    public abstract virtual Assembly get_Assembly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Internal.SlicedStream : Stream {
    private Stream _baseStream;
    private int _from;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SlicedStream(Stream baseStream, int from, int length);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
}
internal class Avalonia.Platform.Internal.UnmanagedBlob : object {
    private IntPtr _address;
    [NullableAttribute("1")]
private object _lock;
    [CompilerGeneratedAttribute]
private static bool <SuppressFinalizerWarning>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private Nullable`1<bool> _useMmap;
    public static bool SuppressFinalizerWarning { get; public set; }
    public IntPtr Address { get; }
    public int Size { get; private set; }
    public bool IsDisposed { get; private set; }
    private bool UseMmap { get; }
    public UnmanagedBlob(int size);
    [CompilerGeneratedAttribute]
public static bool get_SuppressFinalizerWarning();
    [CompilerGeneratedAttribute]
public static void set_SuppressFinalizerWarning(bool value);
    private void DoDispose();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public IntPtr get_Address();
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(int value);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    private static IntPtr mmap(IntPtr addr, IntPtr length, int prot, int flags, int fd, IntPtr offset);
    private static int munmap(IntPtr addr, IntPtr length);
    private static long sysconf(int name);
    private bool get_UseMmap();
    private IntPtr Alloc(int size);
    private void Free(IntPtr ptr, int len);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Interop.Utf8Buffer : SafeHandle {
    private GCHandle _gcHandle;
    private Byte[] _data;
    public int ByteLen { get; }
    public bool IsInvalid { get; }
    public Utf8Buffer(string s);
    public int get_ByteLen();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    public static string StringFromPtr(IntPtr s);
    [NullableContextAttribute("1")]
public static IntPtr op_Implicit(Utf8Buffer b);
    [NullableContextAttribute("0")]
public static Byte* op_Implicit(Utf8Buffer b);
}
[NullableContextAttribute("1")]
public interface Avalonia.Platform.IOptionalFeatureProvider {
    public abstract virtual object TryGetFeature(Type featureType);
}
[NullableContextAttribute("1")]
public interface Avalonia.Platform.IPlatformBehaviorInhibition {
    public abstract virtual Task SetInhibitAppSleep(bool inhibitAppSleep, string reason);
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.IPlatformGraphics {
    public bool UsesSharedContext { get; }
    public abstract virtual bool get_UsesSharedContext();
    public abstract virtual IPlatformGraphicsContext CreateContext();
    public abstract virtual IPlatformGraphicsContext GetSharedContext();
}
[UnstableAttribute]
public interface Avalonia.Platform.IPlatformGraphicsContext {
    public bool IsLost { get; }
    public abstract virtual bool get_IsLost();
    [NullableContextAttribute("1")]
public abstract virtual IDisposable EnsureCurrent();
}
[UnstableAttribute]
public interface Avalonia.Platform.IPlatformGraphicsReadyStateFeature {
    public bool IsReady { get; }
    public bool UsesContexts { get; }
    public abstract virtual bool get_IsReady();
    public abstract virtual bool get_UsesContexts();
}
[UnstableAttribute]
public interface Avalonia.Platform.IPlatformGraphicsWithFeatures {
}
[NullableContextAttribute("2")]
public interface Avalonia.Platform.IPlatformHandle {
    public IntPtr Handle { get; }
    public string HandleDescriptor { get; }
    public abstract virtual IntPtr get_Handle();
    public abstract virtual string get_HandleDescriptor();
}
[NullableContextAttribute("1")]
[UnstableAttribute]
[PrivateApiAttribute]
public interface Avalonia.Platform.IPlatformRenderInterface {
    public bool SupportsIndividualRoundRects { get; }
    public AlphaFormat DefaultAlphaFormat { get; }
    public PixelFormat DefaultPixelFormat { get; }
    public bool SupportsRegions { get; }
    public abstract virtual IGeometryImpl CreateEllipseGeometry(Rect rect);
    public abstract virtual IGeometryImpl CreateLineGeometry(Point p1, Point p2);
    public abstract virtual IGeometryImpl CreateRectangleGeometry(Rect rect);
    public abstract virtual IStreamGeometryImpl CreateStreamGeometry();
    public abstract virtual IGeometryImpl CreateGeometryGroup(FillRule fillRule, IReadOnlyList`1<IGeometryImpl> children);
    public abstract virtual IGeometryImpl CreateCombinedGeometry(GeometryCombineMode combineMode, IGeometryImpl g1, IGeometryImpl g2);
    public abstract virtual IGeometryImpl BuildGlyphRunGeometry(GlyphRun glyphRun);
    public abstract virtual IRenderTargetBitmapImpl CreateRenderTargetBitmap(PixelSize size, Vector dpi);
    public abstract virtual IWriteableBitmapImpl CreateWriteableBitmap(PixelSize size, Vector dpi, PixelFormat format, AlphaFormat alphaFormat);
    public abstract virtual IBitmapImpl LoadBitmap(string fileName);
    public abstract virtual IBitmapImpl LoadBitmap(Stream stream);
    public abstract virtual IWriteableBitmapImpl LoadWriteableBitmapToWidth(Stream stream, int width, BitmapInterpolationMode interpolationMode);
    public abstract virtual IWriteableBitmapImpl LoadWriteableBitmapToHeight(Stream stream, int height, BitmapInterpolationMode interpolationMode);
    public abstract virtual IWriteableBitmapImpl LoadWriteableBitmap(string fileName);
    public abstract virtual IWriteableBitmapImpl LoadWriteableBitmap(Stream stream);
    public abstract virtual IBitmapImpl LoadBitmapToWidth(Stream stream, int width, BitmapInterpolationMode interpolationMode);
    public abstract virtual IBitmapImpl LoadBitmapToHeight(Stream stream, int height, BitmapInterpolationMode interpolationMode);
    public abstract virtual IBitmapImpl ResizeBitmap(IBitmapImpl bitmapImpl, PixelSize destinationSize, BitmapInterpolationMode interpolationMode);
    public abstract virtual IBitmapImpl LoadBitmap(PixelFormat format, AlphaFormat alphaFormat, IntPtr data, PixelSize size, Vector dpi, int stride);
    public abstract virtual IGlyphRunImpl CreateGlyphRun(IGlyphTypeface glyphTypeface, double fontRenderingEmSize, IReadOnlyList`1<GlyphInfo> glyphInfos, Point baselineOrigin);
    public abstract virtual IPlatformRenderInterfaceContext CreateBackendContext(IPlatformGraphicsContext graphicsApiContext);
    public abstract virtual bool get_SupportsIndividualRoundRects();
    public abstract virtual AlphaFormat get_DefaultAlphaFormat();
    public abstract virtual PixelFormat get_DefaultPixelFormat();
    public abstract virtual bool IsSupportedBitmapPixelFormat(PixelFormat format);
    public abstract virtual bool get_SupportsRegions();
    public abstract virtual IPlatformRenderInterfaceRegion CreateRegion();
}
[NullableContextAttribute("1")]
[UnstableAttribute]
[PrivateApiAttribute]
public interface Avalonia.Platform.IPlatformRenderInterfaceContext {
    public bool IsLost { get; }
    public IReadOnlyDictionary`2<Type, object> PublicFeatures { get; }
    public abstract virtual IRenderTarget CreateRenderTarget(IEnumerable`1<object> surfaces);
    public abstract virtual IDrawingContextLayerImpl CreateOffscreenRenderTarget(PixelSize pixelSize, double scaling);
    public abstract virtual bool get_IsLost();
    public abstract virtual IReadOnlyDictionary`2<Type, object> get_PublicFeatures();
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.IPlatformRenderInterfaceImportedImage {
    public abstract virtual IBitmapImpl SnapshotWithKeyedMutex(UInt32 acquireIndex, UInt32 releaseIndex);
    public abstract virtual IBitmapImpl SnapshotWithSemaphores(IPlatformRenderInterfaceImportedSemaphore waitForSemaphore, IPlatformRenderInterfaceImportedSemaphore signalSemaphore);
    public abstract virtual IBitmapImpl SnapshotWithAutomaticSync();
}
[UnstableAttribute]
public interface Avalonia.Platform.IPlatformRenderInterfaceImportedObject {
}
[UnstableAttribute]
public interface Avalonia.Platform.IPlatformRenderInterfaceImportedSemaphore {
}
[NullableContextAttribute("1")]
[UnstableAttribute]
[PrivateApiAttribute]
public interface Avalonia.Platform.IPlatformRenderInterfaceRegion {
    public bool IsEmpty { get; }
    public LtrbPixelRect Bounds { get; }
    public IList`1<LtrbPixelRect> Rects { get; }
    public abstract virtual void AddRect(LtrbPixelRect rect);
    public abstract virtual void Reset();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual LtrbPixelRect get_Bounds();
    public abstract virtual IList`1<LtrbPixelRect> get_Rects();
    public abstract virtual bool Intersects(LtrbRect rect);
    public abstract virtual bool Contains(Point pt);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Platform.IPlatformSettings {
    public TimeSpan HoldWaitDuration { get; }
    public PlatformHotkeyConfiguration HotkeyConfiguration { get; }
    public abstract virtual Size GetTapSize(PointerType type);
    public abstract virtual Size GetDoubleTapSize(PointerType type);
    public abstract virtual TimeSpan GetDoubleTapTime(PointerType type);
    public abstract virtual TimeSpan get_HoldWaitDuration();
    public abstract virtual PlatformHotkeyConfiguration get_HotkeyConfiguration();
    public abstract virtual PlatformColorValues GetColorValues();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ColorValuesChanged(EventHandler`1<PlatformColorValues> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ColorValuesChanged(EventHandler`1<PlatformColorValues> value);
}
[NullableContextAttribute("2")]
[PrivateApiAttribute]
public interface Avalonia.Platform.IPlatformThreadingInterface {
    public bool CurrentThreadIsLoopThread { get; }
    [NullableContextAttribute("1")]
public abstract virtual IDisposable StartTimer(DispatcherPriority priority, TimeSpan interval, Action tick);
    public abstract virtual void Signal(DispatcherPriority priority);
    public abstract virtual bool get_CurrentThreadIsLoopThread();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Signaled(Action`1<Nullable`1<DispatcherPriority>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Signaled(Action`1<Nullable`1<DispatcherPriority>> value);
}
[NullableContextAttribute("1")]
public interface Avalonia.Platform.IReadableBitmapImpl {
    public Nullable`1<PixelFormat> Format { get; }
    public abstract virtual Nullable`1<PixelFormat> get_Format();
    public abstract virtual ILockedFramebuffer Lock();
}
[UnstableAttribute]
public interface Avalonia.Platform.IReadableBitmapWithAlphaImpl {
    public Nullable`1<AlphaFormat> AlphaFormat { get; }
    public abstract virtual Nullable`1<AlphaFormat> get_AlphaFormat();
}
[PrivateApiAttribute]
public interface Avalonia.Platform.IRenderTarget {
    public bool IsCorrupted { get; }
    [NullableContextAttribute("1")]
public abstract virtual IDrawingContextImpl CreateDrawingContext(bool useScaledDrawing);
    public abstract virtual bool get_IsCorrupted();
}
[UnstableAttribute]
public interface Avalonia.Platform.IRenderTargetBitmapImpl {
}
[PrivateApiAttribute]
public interface Avalonia.Platform.IRenderTargetWithProperties {
    public RenderTargetProperties Properties { get; }
    public abstract virtual RenderTargetProperties get_Properties();
    [NullableContextAttribute("1")]
public abstract virtual IDrawingContextImpl CreateDrawingContext(bool useScaledDrawing, RenderTargetDrawingContextProperties& properties);
}
[PrivateApiAttribute]
public interface Avalonia.Platform.IRuntimePlatform {
    public abstract virtual RuntimePlatformInfo GetRuntimeInfo();
}
[NullableContextAttribute("1")]
public interface Avalonia.Platform.IScopedResource`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[UnstableAttribute]
public interface Avalonia.Platform.IStreamGeometryContextImpl {
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.IStreamGeometryImpl {
    public abstract virtual IStreamGeometryImpl Clone();
    public abstract virtual IStreamGeometryContextImpl Open();
}
[UnstableAttribute]
public interface Avalonia.Platform.ISystemNavigationManagerImpl {
    [CompilerGeneratedAttribute]
public abstract virtual void add_BackRequested(EventHandler`1<RoutedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BackRequested(EventHandler`1<RoutedEventArgs> value);
}
[UnstableAttribute]
public interface Avalonia.Platform.ITextShaperImpl {
    public abstract virtual ShapedBuffer ShapeText(ReadOnlyMemory`1<char> text, TextShaperOptions options);
}
[NullableContextAttribute("1")]
[UnstableAttribute]
public interface Avalonia.Platform.ITransformedGeometryImpl {
    public IGeometryImpl SourceGeometry { get; }
    public Matrix Transform { get; }
    public abstract virtual IGeometryImpl get_SourceGeometry();
    public abstract virtual Matrix get_Transform();
}
[UnstableAttribute]
public interface Avalonia.Platform.IWriteableBitmapImpl {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Platform.KnownPlatformGraphicsExternalImageHandleTypes : object {
    public static string D3D11TextureGlobalSharedHandle;
    public static string D3D11TextureNtHandle;
    public static string VulkanOpaquePosixFileDescriptor;
    public static string VulkanOpaqueNtHandle;
    public static string VulkanOpaqueKmtHandle;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Platform.KnownPlatformGraphicsExternalSemaphoreHandleTypes : object {
    public static string VulkanOpaquePosixFileDescriptor;
    public static string VulkanOpaqueNtHandle;
    public static string VulkanOpaqueKmtHandle;
    public static string Direct3D12FenceNtHandle;
}
public class Avalonia.Platform.LockedFramebuffer : object {
    [NullableAttribute("2")]
private Action _onDispose;
    [CompilerGeneratedAttribute]
private IntPtr <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelSize <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <Dpi>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelFormat <Format>k__BackingField;
    public IntPtr Address { get; }
    public PixelSize Size { get; }
    public int RowBytes { get; }
    public Vector Dpi { get; }
    public PixelFormat Format { get; }
    [NullableContextAttribute("2")]
public LockedFramebuffer(IntPtr address, PixelSize size, int rowBytes, Vector dpi, PixelFormat format, Action onDispose);
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_Address();
    [CompilerGeneratedAttribute]
public sealed virtual PixelSize get_Size();
    [CompilerGeneratedAttribute]
public sealed virtual int get_RowBytes();
    [CompilerGeneratedAttribute]
public sealed virtual Vector get_Dpi();
    [CompilerGeneratedAttribute]
public sealed virtual PixelFormat get_Format();
    public sealed virtual void Dispose();
}
[PrivateApiAttribute]
public class Avalonia.Platform.LtrbPixelRect : ValueType {
    public int Left;
    public int Top;
    public int Right;
    public int Bottom;
    internal bool IsEmpty { get; }
    internal LtrbPixelRect(int x, int y, int right, int bottom);
    internal LtrbPixelRect(PixelSize size);
    internal bool get_IsEmpty();
    internal PixelRect ToPixelRect();
    internal LtrbPixelRect Union(LtrbPixelRect rect);
    internal Rect ToRectWithNoScaling();
    internal bool Contains(int x, int y);
    internal static LtrbPixelRect FromRectWithNoScaling(LtrbRect rect);
    public static bool op_Equality(LtrbPixelRect left, LtrbPixelRect right);
    public static bool op_Inequality(LtrbPixelRect left, LtrbPixelRect right);
    public bool Equals(LtrbPixelRect other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal Rect ToRectUnscaled();
    internal static LtrbPixelRect FromRectUnscaled(LtrbRect rect);
}
[PrivateApiAttribute]
public class Avalonia.Platform.LtrbRect : ValueType {
    public double Left;
    public double Top;
    public double Right;
    public double Bottom;
    internal bool IsZeroSize { get; }
    internal Point TopLeft { get; }
    internal Point TopRight { get; }
    internal Point BottomLeft { get; }
    internal Point BottomRight { get; }
    internal LtrbRect(double x, double y, double right, double bottom);
    internal LtrbRect(Rect rc);
    internal bool get_IsZeroSize();
    internal LtrbRect Intersect(LtrbRect rect);
    internal bool Intersects(LtrbRect rect);
    internal Rect ToRect();
    internal LtrbRect Inflate(Thickness thickness);
    public static bool op_Equality(LtrbRect left, LtrbRect right);
    public static bool op_Inequality(LtrbRect left, LtrbRect right);
    public bool Equals(LtrbRect other);
    public bool Equals(LtrbRect& other);
    internal Point get_TopLeft();
    internal Point get_TopRight();
    internal Point get_BottomLeft();
    internal Point get_BottomRight();
    internal LtrbRect TransformToAABB(Matrix matrix);
    private LtrbRect FullUnionCore(LtrbRect rect);
    internal static Nullable`1<LtrbRect> FullUnion(Nullable`1<LtrbRect> left, Nullable`1<LtrbRect> right);
    internal static Nullable`1<LtrbRect> FullUnion(Nullable`1<LtrbRect> left, Nullable`1<Rect> right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Platform.OptionalFeatureProviderExtensions : object {
    [ExtensionAttribute]
public static T TryGetFeature(IOptionalFeatureProvider provider);
    [ExtensionAttribute]
public static bool TryGetFeature(IOptionalFeatureProvider provider, T& rv);
}
public class Avalonia.Platform.PixelFormat : ValueType {
    internal PixelFormatEnum FormatEnum;
    public int BitsPerPixel { get; }
    internal bool HasAlpha { get; }
    public static PixelFormat Rgb565 { get; }
    public static PixelFormat Rgba8888 { get; }
    public static PixelFormat Rgb32 { get; }
    public static PixelFormat Bgra8888 { get; }
    internal PixelFormat(PixelFormatEnum format);
    public int get_BitsPerPixel();
    internal bool get_HasAlpha();
    public static PixelFormat get_Rgb565();
    public static PixelFormat get_Rgba8888();
    public static PixelFormat get_Rgb32();
    public static PixelFormat get_Bgra8888();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PixelFormat left, PixelFormat right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PixelFormat left, PixelFormat right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PixelFormat other);
}
internal enum Avalonia.Platform.PixelFormatEnum : Enum {
    public int value__;
    public static PixelFormatEnum Rgb565;
    public static PixelFormatEnum Rgba8888;
    public static PixelFormatEnum Bgra8888;
    public static PixelFormatEnum BlackWhite;
    public static PixelFormatEnum Gray2;
    public static PixelFormatEnum Gray4;
    public static PixelFormatEnum Gray8;
    public static PixelFormatEnum Gray16;
    public static PixelFormatEnum Gray32Float;
    public static PixelFormatEnum Rgba64;
    public static PixelFormatEnum Rgb24;
    public static PixelFormatEnum Rgb32;
    public static PixelFormatEnum Bgr24;
    public static PixelFormatEnum Bgr32;
    public static PixelFormatEnum Bgr555;
    public static PixelFormatEnum Bgr565;
}
public static class Avalonia.Platform.PixelFormats : object {
    [CompilerGeneratedAttribute]
private static PixelFormat <Rgb565>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Rgba8888>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Rgba64>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Bgra8888>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <BlackWhite>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Gray2>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Gray4>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Gray8>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Gray16>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Gray32Float>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Rgb24>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Rgb32>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Bgr24>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Bgr32>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Bgr555>k__BackingField;
    [CompilerGeneratedAttribute]
private static PixelFormat <Bgr565>k__BackingField;
    public static PixelFormat Rgb565 { get; }
    public static PixelFormat Rgba8888 { get; }
    public static PixelFormat Rgba64 { get; }
    public static PixelFormat Bgra8888 { get; }
    public static PixelFormat BlackWhite { get; }
    public static PixelFormat Gray2 { get; }
    public static PixelFormat Gray4 { get; }
    public static PixelFormat Gray8 { get; }
    public static PixelFormat Gray16 { get; }
    public static PixelFormat Gray32Float { get; }
    public static PixelFormat Rgb24 { get; }
    public static PixelFormat Rgb32 { get; }
    public static PixelFormat Bgr24 { get; }
    public static PixelFormat Bgr32 { get; }
    public static PixelFormat Bgr555 { get; }
    public static PixelFormat Bgr565 { get; }
    private static PixelFormats();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Rgb565();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Rgba8888();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Rgba64();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Bgra8888();
    [CompilerGeneratedAttribute]
public static PixelFormat get_BlackWhite();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Gray2();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Gray4();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Gray8();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Gray16();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Gray32Float();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Rgb24();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Rgb32();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Bgr24();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Bgr32();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Bgr555();
    [CompilerGeneratedAttribute]
public static PixelFormat get_Bgr565();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Platform.PlatformColorValues : object {
    private Color _accentColor2;
    private Color _accentColor3;
    [CompilerGeneratedAttribute]
private PlatformThemeVariant <ThemeVariant>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorContrastPreference <ContrastPreference>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <AccentColor1>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    private static Color DefaultAccent { get; }
    public PlatformThemeVariant ThemeVariant { get; public set; }
    public ColorContrastPreference ContrastPreference { get; public set; }
    public Color AccentColor1 { get; public set; }
    public Color AccentColor2 { get; public set; }
    public Color AccentColor3 { get; public set; }
    [CompilerGeneratedAttribute]
protected PlatformColorValues(PlatformColorValues original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    private static Color get_DefaultAccent();
    [CompilerGeneratedAttribute]
public PlatformThemeVariant get_ThemeVariant();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ThemeVariant(PlatformThemeVariant value);
    [CompilerGeneratedAttribute]
public ColorContrastPreference get_ContrastPreference();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ContrastPreference(ColorContrastPreference value);
    [CompilerGeneratedAttribute]
public Color get_AccentColor1();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AccentColor1(Color value);
    public Color get_AccentColor2();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AccentColor2(Color value);
    public Color get_AccentColor3();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AccentColor3(Color value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PlatformColorValues left, PlatformColorValues right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PlatformColorValues left, PlatformColorValues right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PlatformColorValues other);
    [CompilerGeneratedAttribute]
public virtual PlatformColorValues <Clone>$();
}
public class Avalonia.Platform.PlatformGraphicsContextLostException : Exception {
}
public enum Avalonia.Platform.PlatformGraphicsExternalImageFormat : Enum {
    public int value__;
    public static PlatformGraphicsExternalImageFormat R8G8B8A8UNorm;
    public static PlatformGraphicsExternalImageFormat B8G8R8A8UNorm;
}
public class Avalonia.Platform.PlatformGraphicsExternalImageProperties : ValueType {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private PlatformGraphicsExternalImageFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MemorySize>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MemoryOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TopLeftOrigin>k__BackingField;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public PlatformGraphicsExternalImageFormat Format { get; public set; }
    public ulong MemorySize { get; public set; }
    public ulong MemoryOffset { get; public set; }
    public bool TopLeftOrigin { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PlatformGraphicsExternalImageFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(PlatformGraphicsExternalImageFormat value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MemorySize();
    [CompilerGeneratedAttribute]
public void set_MemorySize(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_MemoryOffset();
    [CompilerGeneratedAttribute]
public void set_MemoryOffset(ulong value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_TopLeftOrigin();
    [CompilerGeneratedAttribute]
public void set_TopLeftOrigin(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PlatformGraphicsExternalImageProperties left, PlatformGraphicsExternalImageProperties right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PlatformGraphicsExternalImageProperties left, PlatformGraphicsExternalImageProperties right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PlatformGraphicsExternalImageProperties other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Platform.PlatformHandle : object {
    [CompilerGeneratedAttribute]
private IntPtr <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HandleDescriptor>k__BackingField;
    public IntPtr Handle { get; }
    public string HandleDescriptor { get; }
    public PlatformHandle(IntPtr handle, string descriptor);
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_Handle();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HandleDescriptor();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(PlatformHandle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PlatformHandle left, PlatformHandle right);
    public static bool op_Inequality(PlatformHandle left, PlatformHandle right);
}
public enum Avalonia.Platform.PlatformThemeVariant : Enum {
    public int value__;
    public static PlatformThemeVariant Light;
    public static PlatformThemeVariant Dark;
}
[PrivateApiAttribute]
public class Avalonia.Platform.RenderTargetDrawingContextProperties : ValueType {
    [CompilerGeneratedAttribute]
private bool <PreviousFrameIsRetained>k__BackingField;
    public bool PreviousFrameIsRetained { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_PreviousFrameIsRetained();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreviousFrameIsRetained(bool value);
}
[ExtensionAttribute]
internal static class Avalonia.Platform.RenderTargetExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IDrawingContextImpl CreateDrawingContextWithProperties(IRenderTarget renderTarget, bool useScaledDrawing, RenderTargetDrawingContextProperties& properties);
}
[PrivateApiAttribute]
public class Avalonia.Platform.RenderTargetProperties : ValueType {
    [CompilerGeneratedAttribute]
private bool <RetainsPreviousFrameContents>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuitableForDirectRendering>k__BackingField;
    public bool RetainsPreviousFrameContents { get; public set; }
    public bool IsSuitableForDirectRendering { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_RetainsPreviousFrameContents();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RetainsPreviousFrameContents(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsSuitableForDirectRendering();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsSuitableForDirectRendering(bool value);
}
internal class Avalonia.Platform.RetainedFramebuffer : object {
    [CompilerGeneratedAttribute]
private PixelSize <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelFormat <Format>k__BackingField;
    [NullableAttribute("2")]
private UnmanagedBlob _blob;
    public PixelSize Size { get; }
    public int RowBytes { get; }
    public PixelFormat Format { get; }
    public IntPtr Address { get; }
    public RetainedFramebuffer(PixelSize size, PixelFormat format);
    public RetainedFramebuffer(PixelSize size, PixelFormat format, int rowBytes);
    [CompilerGeneratedAttribute]
public PixelSize get_Size();
    [CompilerGeneratedAttribute]
public int get_RowBytes();
    [CompilerGeneratedAttribute]
public PixelFormat get_Format();
    public IntPtr get_Address();
    private static PixelFormat ValidateKnownFormat(PixelFormat format);
    [NullableContextAttribute("1")]
public ILockedFramebuffer Lock(Vector dpi, Action`1<RetainedFramebuffer> blit);
    public sealed virtual void Dispose();
}
[PrivateApiAttribute]
public class Avalonia.Platform.RuntimePlatformInfo : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsDesktop>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMobile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTV>k__BackingField;
    public FormFactorType FormFactor { get; }
    public bool IsDesktop { get; public set; }
    public bool IsMobile { get; public set; }
    public bool IsTV { get; public set; }
    public FormFactorType get_FormFactor();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsDesktop();
    [CompilerGeneratedAttribute]
public void set_IsDesktop(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsMobile();
    [CompilerGeneratedAttribute]
public void set_IsMobile(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsTV();
    [CompilerGeneratedAttribute]
public void set_IsTV(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimePlatformInfo left, RuntimePlatformInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RuntimePlatformInfo left, RuntimePlatformInfo right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimePlatformInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Platform.ScopedResource`1 : object {
    private int _disposed;
    private T _value;
    [NullableAttribute("2")]
private Action _dispose;
    public T Value { get; }
    private ScopedResource`1(T value, Action dispose);
    public static IScopedResource`1<T> Create(T value, Action dispose);
    public sealed virtual void Dispose();
    public sealed virtual T get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnstableAttribute("StandardAssetLoader is considered unstable. Please use AssetLoader static class instead.")]
public class Avalonia.Platform.StandardAssetLoader : object {
    private IAssemblyDescriptorResolver _assemblyDescriptorResolver;
    [NullableAttribute("2")]
private AssemblyDescriptor _defaultResmAssembly;
    internal StandardAssetLoader(IAssemblyDescriptorResolver resolver, Assembly assembly);
    [NullableContextAttribute("2")]
public StandardAssetLoader(Assembly assembly);
    public sealed virtual void SetDefaultAssembly(Assembly assembly);
    public sealed virtual bool Exists(Uri uri, Uri baseUri);
    public sealed virtual Stream Open(Uri uri, Uri baseUri);
    public sealed virtual ValueTuple`2<Stream, Assembly> OpenAndGetAssembly(Uri uri, Uri baseUri);
    [NullableContextAttribute("2")]
public sealed virtual Assembly GetAssembly(Uri uri, Uri baseUri);
    public sealed virtual IEnumerable`1<Uri> GetAssets(Uri uri, Uri baseUri);
    public sealed virtual void InvalidateAssemblyCache(string name);
    public sealed virtual void InvalidateAssemblyCache();
    public static void RegisterResUriParsers();
    [NullableContextAttribute("2")]
private bool TryGetAsset(Uri uri, Uri baseUri, IAssetDescriptor& assetDescriptor);
    private bool TryGetResAsmAndPath(Uri uri, IAssemblyDescriptor& assembly, String& path);
    [NullableContextAttribute("2")]
private bool TryGetAssembly(Uri uri, IAssemblyDescriptor& assembly);
    private bool TryLoadAssembly(string assemblyName, IAssemblyDescriptor& assembly);
}
[PrivateApiAttribute]
public class Avalonia.Platform.StandardRuntimePlatform : object {
    public virtual RuntimePlatformInfo GetRuntimeInfo();
}
internal static class Avalonia.Platform.StandardRuntimePlatformServices : object {
    [NullableContextAttribute("2")]
public static void Register(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Storage.FallbackStorageProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1[] _factories;
    private List`1<IStorageProvider> _providers;
    private int _nextProviderFactory;
    public bool CanOpen { get; }
    public bool CanSave { get; }
    public bool CanPickFolder { get; }
    public FallbackStorageProvider(Func`1[] factories);
    [AsyncIteratorStateMachineAttribute("Avalonia.Platform.Storage.FallbackStorageProvider/<GetProviders>d__4")]
private IAsyncEnumerable`1<IStorageProvider> GetProviders();
    [AsyncStateMachineAttribute("Avalonia.Platform.Storage.FallbackStorageProvider/<GetFor>d__5")]
private Task`1<IStorageProvider> GetFor(Func`2<IStorageProvider, bool> filter);
    public sealed virtual bool get_CanOpen();
    public sealed virtual bool get_CanSave();
    public sealed virtual bool get_CanPickFolder();
    [AsyncStateMachineAttribute("Avalonia.Platform.Storage.FallbackStorageProvider/<OpenFilePickerAsync>d__12")]
public sealed virtual Task`1<IReadOnlyList`1<IStorageFile>> OpenFilePickerAsync(FilePickerOpenOptions options);
    [AsyncStateMachineAttribute("Avalonia.Platform.Storage.FallbackStorageProvider/<SaveFilePickerAsync>d__13")]
public sealed virtual Task`1<IStorageFile> SaveFilePickerAsync(FilePickerSaveOptions options);
    [AsyncStateMachineAttribute("Avalonia.Platform.Storage.FallbackStorageProvider/<OpenFolderPickerAsync>d__14")]
public sealed virtual Task`1<IReadOnlyList`1<IStorageFolder>> OpenFolderPickerAsync(FolderPickerOpenOptions options);
    [AsyncStateMachineAttribute("Avalonia.Platform.Storage.FallbackStorageProvider/<FirstNotNull>d__15`2")]
private Task`1<TResult> FirstNotNull(TArg arg, Func`3<IStorageProvider, TArg, Task`1<TResult>> cb);
    public sealed virtual Task`1<IStorageBookmarkFile> OpenFileBookmarkAsync(string bookmark);
    public sealed virtual Task`1<IStorageBookmarkFolder> OpenFolderBookmarkAsync(string bookmark);
    public sealed virtual Task`1<IStorageFile> TryGetFileFromPathAsync(Uri filePath);
    public sealed virtual Task`1<IStorageFolder> TryGetFolderFromPathAsync(Uri folderPath);
    public sealed virtual Task`1<IStorageFolder> TryGetWellKnownFolderAsync(WellKnownFolder wellKnownFolder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Storage.FileIO.BclLauncher : object {
    public virtual Task`1<bool> LaunchUriAsync(Uri uri);
    public virtual Task`1<bool> LaunchFileAsync(IStorageItem storageItem);
    protected virtual bool CanOpenFileOrDirectory(string localPath);
    private static bool Exec(string urlOrFile);
    private static void ShellExec(string cmd, bool waitForExit);
}
internal class Avalonia.Platform.Storage.FileIO.BclStorageFile : BclStorageItem {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private FileInfo <fileInfo>P;
    [NullableContextAttribute("1")]
public BclStorageFile(FileInfo fileInfo);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<Stream> OpenReadAsync();
    [NullableContextAttribute("1")]
public sealed virtual Task`1<Stream> OpenWriteAsync();
}
internal class Avalonia.Platform.Storage.FileIO.BclStorageFolder : BclStorageItem {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private DirectoryInfo <directoryInfo>P;
    [NullableContextAttribute("1")]
public BclStorageFolder(DirectoryInfo directoryInfo);
    [NullableContextAttribute("1")]
public sealed virtual IAsyncEnumerable`1<IStorageItem> GetItemsAsync();
    [NullableContextAttribute("1")]
public sealed virtual Task`1<IStorageFile> CreateFileAsync(string name);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<IStorageFolder> CreateFolderAsync(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Platform.Storage.FileIO.BclStorageItem : object {
    [CompilerGeneratedAttribute]
private FileSystemInfo <FileSystemInfo>k__BackingField;
    public FileSystemInfo FileSystemInfo { get; }
    public string Name { get; }
    public bool CanBookmark { get; }
    public Uri Path { get; }
    protected BclStorageItem(FileSystemInfo fileSystemInfo);
    [CompilerGeneratedAttribute]
public sealed virtual FileSystemInfo get_FileSystemInfo();
    public sealed virtual string get_Name();
    public sealed virtual bool get_CanBookmark();
    public sealed virtual Uri get_Path();
    public sealed virtual Task`1<StorageItemProperties> GetBasicPropertiesAsync();
    public sealed virtual Task`1<IStorageFolder> GetParentAsync();
    public sealed virtual Task DeleteAsync();
    public sealed virtual Task`1<IStorageItem> MoveAsync(IStorageFolder destination);
    public sealed virtual Task`1<string> SaveBookmarkAsync();
    public sealed virtual Task ReleaseBookmarkAsync();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
protected IStorageItem WrapFileSystemInfo(FileSystemInfo fileSystemInfo);
    internal static void DeleteCore(FileSystemInfo fileSystemInfo);
    internal static Uri GetPathCore(FileSystemInfo fileSystemInfo);
    internal static StorageItemProperties GetBasicPropertiesAsyncCore(FileSystemInfo fileSystemInfo);
    internal static DirectoryInfo GetParentCore(FileSystemInfo fileSystemInfo);
    internal static FileSystemInfo MoveCore(FileSystemInfo fileSystemInfo, IStorageFolder destination);
    internal static FileStream OpenReadCore(FileInfo fileInfo);
    internal static FileStream OpenWriteCore(FileInfo fileInfo);
    internal static IEnumerable`1<FileSystemInfo> GetItemsCore(DirectoryInfo directoryInfo);
    internal static FileInfo CreateFileCore(DirectoryInfo directoryInfo, string name);
    internal static DirectoryInfo CreateFolderCore(DirectoryInfo directoryInfo, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Platform.Storage.FileIO.BclStorageProvider : object {
    private static Guid s_folderDownloads;
    public bool CanOpen { get; }
    public bool CanSave { get; }
    public bool CanPickFolder { get; }
    private static BclStorageProvider();
    public abstract virtual bool get_CanOpen();
    public abstract virtual Task`1<IReadOnlyList`1<IStorageFile>> OpenFilePickerAsync(FilePickerOpenOptions options);
    public abstract virtual bool get_CanSave();
    public abstract virtual Task`1<IStorageFile> SaveFilePickerAsync(FilePickerSaveOptions options);
    public abstract virtual bool get_CanPickFolder();
    public abstract virtual Task`1<IReadOnlyList`1<IStorageFolder>> OpenFolderPickerAsync(FolderPickerOpenOptions options);
    public virtual Task`1<IStorageBookmarkFile> OpenFileBookmarkAsync(string bookmark);
    public virtual Task`1<IStorageBookmarkFolder> OpenFolderBookmarkAsync(string bookmark);
    public virtual Task`1<IStorageFile> TryGetFileFromPathAsync(Uri filePath);
    public virtual Task`1<IStorageFolder> TryGetFolderFromPathAsync(Uri folderPath);
    public virtual Task`1<IStorageFolder> TryGetWellKnownFolderAsync(WellKnownFolder wellKnownFolder);
    [NullableContextAttribute("2")]
internal static DirectoryInfo TryGetWellKnownFolderCore(WellKnownFolder wellKnownFolder);
    [NullableContextAttribute("2")]
protected static string GetDownloadsWellKnownFolder();
    private IStorageBookmarkItem OpenBookmark(string bookmark);
    private static IntPtr SHGetKnownFolderPath(Guid id, int flags, IntPtr token);
    [CompilerGeneratedAttribute]
internal static string <TryGetWellKnownFolderCore>g__GetFromSpecialFolder|14_0(SpecialFolder folder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Storage.FileIO.SecurityScopedStream : Stream {
    [CompilerGeneratedAttribute]
private FileStream <_stream>P;
    [CompilerGeneratedAttribute]
private IDisposable <_securityScope>P;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SecurityScopedStream(FileStream _stream, IDisposable _securityScope);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Avalonia.Platform.Storage.FileIO.SecurityScopedStream/<DisposeAsync>d__35")]
public virtual ValueTask DisposeAsync();
}
internal static class Avalonia.Platform.Storage.FileIO.StorageBookmarkHelper : object {
    private static int HeaderLength;
    private static ReadOnlySpan`1<byte> AvaHeaderPrefix { get; }
    private static ReadOnlySpan`1<byte> FakeBclBookmarkPlatform { get; }
    private static ReadOnlySpan`1<byte> get_AvaHeaderPrefix();
    private static ReadOnlySpan`1<byte> get_FakeBclBookmarkPlatform();
    [NullableContextAttribute("2")]
public static string EncodeBookmark(ReadOnlySpan`1<byte> platform, string nativeBookmark);
    public static string EncodeBookmark(ReadOnlySpan`1<byte> platform, ReadOnlySpan`1<byte> nativeBookmarkBytes);
    [NullableContextAttribute("2")]
public static DecodeResult TryDecodeBookmark(ReadOnlySpan`1<byte> platform, string base64bookmark, Byte[]& nativeBookmark);
    [NullableContextAttribute("1")]
public static string EncodeBclBookmark(string localPath);
    [NullableContextAttribute("1")]
public static bool TryDecodeBclBookmark(string nativeBookmark, String& localPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Platform.Storage.FileIO.StorageProviderHelpers : object {
    public static BclStorageItem TryCreateBclStorageItem(string path);
    [NullableContextAttribute("2")]
public static string TryGetPathFromFileUri(Uri uri);
    public static Uri UriFromFilePath(string path, bool isDirectory);
    public static Uri TryGetUriFromFilePath(string path, bool isDirectory);
    [NullableContextAttribute("2")]
public static string NameWithExtension(string path, string defaultExtension, FilePickerFileType filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Platform.Storage.FilePickerFileType : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Patterns>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <MimeTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AppleUniformTypeIdentifiers>k__BackingField;
    public string Name { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<string> Patterns { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<string> MimeTypes { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<string> AppleUniformTypeIdentifiers { get; public set; }
    [NullableContextAttribute("2")]
public FilePickerFileType(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Patterns();
    [CompilerGeneratedAttribute]
public void set_Patterns(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_MimeTypes();
    [CompilerGeneratedAttribute]
public void set_MimeTypes(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AppleUniformTypeIdentifiers();
    [CompilerGeneratedAttribute]
public void set_AppleUniformTypeIdentifiers(IReadOnlyList`1<string> value);
    internal IReadOnlyList`1<string> TryGetExtensions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Platform.Storage.FilePickerFileTypes : object {
    [CompilerGeneratedAttribute]
private static FilePickerFileType <All>k__BackingField;
    [CompilerGeneratedAttribute]
private static FilePickerFileType <TextPlain>k__BackingField;
    [CompilerGeneratedAttribute]
private static FilePickerFileType <ImageAll>k__BackingField;
    [CompilerGeneratedAttribute]
private static FilePickerFileType <ImageJpg>k__BackingField;
    [CompilerGeneratedAttribute]
private static FilePickerFileType <ImagePng>k__BackingField;
    [CompilerGeneratedAttribute]
private static FilePickerFileType <ImageWebp>k__BackingField;
    [CompilerGeneratedAttribute]
private static FilePickerFileType <Pdf>k__BackingField;
    public static FilePickerFileType All { get; }
    public static FilePickerFileType TextPlain { get; }
    public static FilePickerFileType ImageAll { get; }
    public static FilePickerFileType ImageJpg { get; }
    public static FilePickerFileType ImagePng { get; }
    public static FilePickerFileType ImageWebp { get; }
    public static FilePickerFileType Pdf { get; }
    private static FilePickerFileTypes();
    [CompilerGeneratedAttribute]
public static FilePickerFileType get_All();
    [CompilerGeneratedAttribute]
public static FilePickerFileType get_TextPlain();
    [CompilerGeneratedAttribute]
public static FilePickerFileType get_ImageAll();
    [CompilerGeneratedAttribute]
public static FilePickerFileType get_ImageJpg();
    [CompilerGeneratedAttribute]
public static FilePickerFileType get_ImagePng();
    [CompilerGeneratedAttribute]
public static FilePickerFileType get_ImageWebp();
    [CompilerGeneratedAttribute]
public static FilePickerFileType get_Pdf();
}
public class Avalonia.Platform.Storage.FilePickerOpenOptions : PickerOptions {
    [CompilerGeneratedAttribute]
private bool <AllowMultiple>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<FilePickerFileType> <FileTypeFilter>k__BackingField;
    public bool AllowMultiple { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<FilePickerFileType> FileTypeFilter { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowMultiple();
    [CompilerGeneratedAttribute]
public void set_AllowMultiple(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FilePickerFileType> get_FileTypeFilter();
    [CompilerGeneratedAttribute]
public void set_FileTypeFilter(IReadOnlyList`1<FilePickerFileType> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Platform.Storage.FilePickerSaveOptions : PickerOptions {
    [CompilerGeneratedAttribute]
private string <DefaultExtension>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<FilePickerFileType> <FileTypeChoices>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShowOverwritePrompt>k__BackingField;
    public string DefaultExtension { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<FilePickerFileType> FileTypeChoices { get; public set; }
    public Nullable`1<bool> ShowOverwritePrompt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultExtension();
    [CompilerGeneratedAttribute]
public void set_DefaultExtension(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FilePickerFileType> get_FileTypeChoices();
    [CompilerGeneratedAttribute]
public void set_FileTypeChoices(IReadOnlyList`1<FilePickerFileType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ShowOverwritePrompt();
    [CompilerGeneratedAttribute]
public void set_ShowOverwritePrompt(Nullable`1<bool> value);
}
public class Avalonia.Platform.Storage.FolderPickerOpenOptions : PickerOptions {
    [CompilerGeneratedAttribute]
private bool <AllowMultiple>k__BackingField;
    public bool AllowMultiple { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowMultiple();
    [CompilerGeneratedAttribute]
public void set_AllowMultiple(bool value);
}
[NullableContextAttribute("1")]
public interface Avalonia.Platform.Storage.ILauncher {
    public abstract virtual Task`1<bool> LaunchUriAsync(Uri uri);
    public abstract virtual Task`1<bool> LaunchFileAsync(IStorageItem storageItem);
}
[NotClientImplementableAttribute]
public interface Avalonia.Platform.Storage.IStorageBookmarkFile {
}
[NotClientImplementableAttribute]
public interface Avalonia.Platform.Storage.IStorageBookmarkFolder {
}
[NotClientImplementableAttribute]
public interface Avalonia.Platform.Storage.IStorageBookmarkItem {
    [NullableContextAttribute("1")]
public abstract virtual Task ReleaseBookmarkAsync();
}
[NotClientImplementableAttribute]
public interface Avalonia.Platform.Storage.IStorageFile {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Stream> OpenReadAsync();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Stream> OpenWriteAsync();
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Platform.Storage.IStorageFolder {
    public abstract virtual IAsyncEnumerable`1<IStorageItem> GetItemsAsync();
    public abstract virtual Task`1<IStorageFile> CreateFileAsync(string name);
    public abstract virtual Task`1<IStorageFolder> CreateFolderAsync(string name);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Platform.Storage.IStorageItem {
    public string Name { get; }
    public Uri Path { get; }
    public bool CanBookmark { get; }
    public abstract virtual string get_Name();
    public abstract virtual Uri get_Path();
    public abstract virtual Task`1<StorageItemProperties> GetBasicPropertiesAsync();
    public abstract virtual bool get_CanBookmark();
    public abstract virtual Task`1<string> SaveBookmarkAsync();
    public abstract virtual Task`1<IStorageFolder> GetParentAsync();
    public abstract virtual Task DeleteAsync();
    public abstract virtual Task`1<IStorageItem> MoveAsync(IStorageFolder destination);
}
internal interface Avalonia.Platform.Storage.IStorageItemWithFileSystemInfo {
    [NullableAttribute("1")]
public FileSystemInfo FileSystemInfo { get; }
    [NullableContextAttribute("1")]
public abstract virtual FileSystemInfo get_FileSystemInfo();
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Platform.Storage.IStorageProvider {
    public bool CanOpen { get; }
    public bool CanSave { get; }
    public bool CanPickFolder { get; }
    public abstract virtual bool get_CanOpen();
    public abstract virtual Task`1<IReadOnlyList`1<IStorageFile>> OpenFilePickerAsync(FilePickerOpenOptions options);
    public abstract virtual bool get_CanSave();
    public abstract virtual Task`1<IStorageFile> SaveFilePickerAsync(FilePickerSaveOptions options);
    public abstract virtual bool get_CanPickFolder();
    public abstract virtual Task`1<IReadOnlyList`1<IStorageFolder>> OpenFolderPickerAsync(FolderPickerOpenOptions options);
    public abstract virtual Task`1<IStorageBookmarkFile> OpenFileBookmarkAsync(string bookmark);
    public abstract virtual Task`1<IStorageBookmarkFolder> OpenFolderBookmarkAsync(string bookmark);
    public abstract virtual Task`1<IStorageFile> TryGetFileFromPathAsync(Uri filePath);
    public abstract virtual Task`1<IStorageFolder> TryGetFolderFromPathAsync(Uri folderPath);
    public abstract virtual Task`1<IStorageFolder> TryGetWellKnownFolderAsync(WellKnownFolder wellKnownFolder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Platform.Storage.LauncherExtensions : object {
    [ExtensionAttribute]
public static Task`1<bool> LaunchFileInfoAsync(ILauncher launcher, FileInfo fileInfo);
    [ExtensionAttribute]
public static Task`1<bool> LaunchDirectoryInfoAsync(ILauncher launcher, DirectoryInfo directoryInfo);
}
internal class Avalonia.Platform.Storage.NoopLauncher : object {
    [NullableContextAttribute("1")]
public sealed virtual Task`1<bool> LaunchUriAsync(Uri uri);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<bool> LaunchFileAsync(IStorageItem storageItem);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Platform.Storage.NoopStorageProvider : BclStorageProvider {
    public bool CanOpen { get; }
    public bool CanSave { get; }
    public bool CanPickFolder { get; }
    public virtual bool get_CanOpen();
    public virtual Task`1<IReadOnlyList`1<IStorageFile>> OpenFilePickerAsync(FilePickerOpenOptions options);
    public virtual bool get_CanSave();
    public virtual Task`1<IStorageFile> SaveFilePickerAsync(FilePickerSaveOptions options);
    public virtual bool get_CanPickFolder();
    public virtual Task`1<IReadOnlyList`1<IStorageFolder>> OpenFolderPickerAsync(FolderPickerOpenOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Platform.Storage.PickerOptions : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageFolder <SuggestedStartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuggestedFileName>k__BackingField;
    public string Title { get; public set; }
    public IStorageFolder SuggestedStartLocation { get; public set; }
    public string SuggestedFileName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public IStorageFolder get_SuggestedStartLocation();
    [CompilerGeneratedAttribute]
public void set_SuggestedStartLocation(IStorageFolder value);
    [CompilerGeneratedAttribute]
public string get_SuggestedFileName();
    [CompilerGeneratedAttribute]
public void set_SuggestedFileName(string value);
}
public class Avalonia.Platform.Storage.StorageItemProperties : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DateCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DateModified>k__BackingField;
    public Nullable`1<ulong> Size { get; }
    public Nullable`1<DateTimeOffset> DateCreated { get; }
    public Nullable`1<DateTimeOffset> DateModified { get; }
    public StorageItemProperties(Nullable`1<ulong> size, Nullable`1<DateTimeOffset> dateCreated, Nullable`1<DateTimeOffset> dateModified);
    [CompilerGeneratedAttribute]
public Nullable`1<ulong> get_Size();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DateCreated();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DateModified();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Platform.Storage.StorageProviderExtensions : object {
    [ExtensionAttribute]
public static Task`1<IStorageFile> TryGetFileFromPathAsync(IStorageProvider provider, string filePath);
    [ExtensionAttribute]
public static Task`1<IStorageFolder> TryGetFolderFromPathAsync(IStorageProvider provider, string folderPath);
    [ExtensionAttribute]
public static string TryGetLocalPath(IStorageItem item);
}
public enum Avalonia.Platform.Storage.WellKnownFolder : Enum {
    public int value__;
    public static WellKnownFolder Desktop;
    public static WellKnownFolder Documents;
    public static WellKnownFolder Downloads;
    public static WellKnownFolder Music;
    public static WellKnownFolder Pictures;
    public static WellKnownFolder Videos;
}
[IsReadOnlyAttribute]
public class Avalonia.Point : ValueType {
    private double _x;
    private double _y;
    public double X { get; }
    public double Y { get; }
    public Point(double x, double y);
    public double get_X();
    public double get_Y();
    public static Vector op_Implicit(Point p);
    public static Point op_UnaryNegation(Point a);
    public static bool op_Equality(Point left, Point right);
    public static bool op_Inequality(Point left, Point right);
    public static Point op_Addition(Point a, Point b);
    public static Point op_Addition(Point a, Vector b);
    public static Point op_Subtraction(Point a, Point b);
    public static Point op_Subtraction(Point a, Vector b);
    public static Point op_Multiply(Point p, double k);
    public static Point op_Multiply(double k, Point p);
    public static Point op_Division(Point p, double k);
    public static Point op_Multiply(Point point, Matrix matrix);
    public static double Distance(Point value1, Point value2);
    [NullableContextAttribute("1")]
public static Point Parse(string s);
    public sealed virtual bool Equals(Point other);
    public bool NearlyEquals(Point other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Point Transform(Matrix transform);
    internal Point Transform(Matrix4x4 matrix);
    public Point WithX(double x);
    public Point WithY(double y);
    public void Deconstruct(Double& x, Double& y);
}
public class Avalonia.Points : AvaloniaList`1<Point> {
    [NullableContextAttribute("1")]
public Points(IEnumerable`1<Point> points);
}
internal static class Avalonia.PropertyStore.AvaloniaPropertyDictionaryPool`1 : object {
    private static int MaxPoolSize;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Stack`1<AvaloniaPropertyDictionary`1<TValue>> _pool;
    private static AvaloniaPropertyDictionaryPool`1();
    public static AvaloniaPropertyDictionary`1<TValue> Get();
    public static void Release(AvaloniaPropertyDictionary`1<TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.PropertyStore.BindingEntryBase`2 : object {
    [NullableAttribute("2")]
private IDisposable _subscription;
    private bool _hasValue;
    [NullableAttribute("2")]
private TValue _value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private UncommonFields<TValue, TSource> _uncommon;
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueFrame <Frame>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    public bool IsSubscribed { get; }
    public AvaloniaProperty Property { get; }
    private AvaloniaProperty Avalonia.PropertyStore.IValueEntry.Property { get; }
    protected ValueFrame Frame { get; }
    protected object Source { get; }
    protected BindingEntryBase`2(AvaloniaObject target, ValueFrame frame, AvaloniaProperty property, IObservable`1<BindingValue`1<TSource>> source);
    protected BindingEntryBase`2(AvaloniaObject target, ValueFrame frame, AvaloniaProperty property, IObservable`1<TSource> source);
    private BindingEntryBase`2(AvaloniaObject target, ValueFrame frame, AvaloniaProperty property, object source);
    public bool get_IsSubscribed();
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    private sealed virtual override AvaloniaProperty Avalonia.PropertyStore.IValueEntry.get_Property();
    [CompilerGeneratedAttribute]
protected ValueFrame get_Frame();
    [CompilerGeneratedAttribute]
protected object get_Source();
    public sealed virtual void Dispose();
    public sealed virtual bool HasValue();
    public sealed virtual TValue GetValue();
    [NullableContextAttribute("2")]
public sealed virtual bool GetDataValidationState(BindingValueType& state, Exception& error);
    public void Start();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(TSource value);
    public sealed virtual void OnNext(BindingValue`1<TSource> value);
    public virtual void Unsubscribe();
    [NullableContextAttribute("2")]
private sealed virtual override object Avalonia.PropertyStore.IValueEntry.GetValue();
    protected abstract virtual BindingValue`1<TValue> ConvertAndValidate(TSource value);
    protected abstract virtual BindingValue`1<TValue> ConvertAndValidate(BindingValue`1<TSource> value);
    protected abstract virtual TValue GetDefaultValue(AvaloniaObject owner);
    protected virtual void Start(bool produceValue);
    private void SetValue(BindingValue`1<TValue> value);
    private void BindingCompleted();
    private TValue GetCachedDefaultValue();
    [CompilerGeneratedAttribute]
internal static void <SetValue>g__Execute|35_0(BindingEntryBase`2<TValue, TSource> instance, BindingValue`1<TValue> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.PropertyStore.BindingEntryBaseNonGenericHelper : object {
    public static IDisposable Creating;
    public static IDisposable CreatingQuiet;
    private static BindingEntryBaseNonGenericHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.PropertyStore.DirectBindingObserver`1 : object {
    private ValueStore _owner;
    private bool _hasDataValidation;
    [NullableAttribute("2")]
private IDisposable _subscription;
    [CompilerGeneratedAttribute]
private DirectPropertyBase`1<T> <Property>k__BackingField;
    public DirectPropertyBase`1<T> Property { get; }
    public DirectBindingObserver`1(ValueStore owner, DirectPropertyBase`1<T> property);
    [CompilerGeneratedAttribute]
public DirectPropertyBase`1<T> get_Property();
    public void Start(IObservable`1<T> source);
    public void Start(IObservable`1<BindingValue`1<T>> source);
    public sealed virtual void Dispose();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
    public sealed virtual void OnNext(BindingValue`1<T> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
internal class Avalonia.PropertyStore.DirectUntypedBindingObserver`1 : object {
    private ValueStore _owner;
    private bool _hasDataValidation;
    [NullableAttribute("2")]
private IDisposable _subscription;
    [CompilerGeneratedAttribute]
private DirectPropertyBase`1<T> <Property>k__BackingField;
    public DirectPropertyBase`1<T> Property { get; }
    public DirectUntypedBindingObserver`1(ValueStore owner, DirectPropertyBase`1<T> property);
    [CompilerGeneratedAttribute]
public DirectPropertyBase`1<T> get_Property();
    public void Start(IObservable`1<object> source);
    public sealed virtual void Dispose();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    [NullableContextAttribute("2")]
public sealed virtual void OnNext(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.PropertyStore.EffectiveValue : object {
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingPriority <BasePriority>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IValueEntry <ValueEntry>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IValueEntry <BaseValueEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCoercion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOverridenCurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCoercedDefaultValue>k__BackingField;
    public AvaloniaProperty Property { get; protected set; }
    [NullableAttribute("2")]
public object Value { get; }
    public BindingPriority Priority { get; protected set; }
    public BindingPriority BasePriority { get; protected set; }
    [NullableAttribute("2")]
public IValueEntry ValueEntry { get; private set; }
    [NullableAttribute("2")]
public IValueEntry BaseValueEntry { get; private set; }
    public bool HasCoercion { get; protected set; }
    public bool IsOverridenCurrentValue { get; public set; }
    public bool IsCoercedDefaultValue { get; public set; }
    protected EffectiveValue(AvaloniaProperty property);
    [CompilerGeneratedAttribute]
public AvaloniaProperty get_Property();
    [CompilerGeneratedAttribute]
protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Property(AvaloniaProperty value);
    [NullableContextAttribute("2")]
public object get_Value();
    [CompilerGeneratedAttribute]
public BindingPriority get_Priority();
    [CompilerGeneratedAttribute]
protected void set_Priority(BindingPriority value);
    [CompilerGeneratedAttribute]
public BindingPriority get_BasePriority();
    [CompilerGeneratedAttribute]
protected void set_BasePriority(BindingPriority value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IValueEntry get_ValueEntry();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ValueEntry(IValueEntry value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IValueEntry get_BaseValueEntry();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_BaseValueEntry(IValueEntry value);
    [CompilerGeneratedAttribute]
public bool get_HasCoercion();
    [CompilerGeneratedAttribute]
protected void set_HasCoercion(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOverridenCurrentValue();
    [CompilerGeneratedAttribute]
public void set_IsOverridenCurrentValue(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCoercedDefaultValue();
    [CompilerGeneratedAttribute]
public void set_IsCoercedDefaultValue(bool value);
    public void BeginReevaluation(bool clearLocalValue);
    public void EndReevaluation(ValueStore owner, AvaloniaProperty property);
    public bool CanRemove();
    public void UnsubscribeIfNecessary();
    public abstract virtual void SetAndRaise(ValueStore owner, IValueEntry value, BindingPriority priority);
    public abstract virtual void SetLocalValueAndRaise(ValueStore owner, AvaloniaProperty property, object value);
    public abstract virtual void RaiseInheritedValueChanged(AvaloniaObject owner, AvaloniaProperty property, EffectiveValue oldValue, EffectiveValue newValue);
    public abstract virtual void RemoveAnimationAndRaise(ValueStore owner, AvaloniaProperty property);
    public abstract virtual void CoerceValue(ValueStore owner, AvaloniaProperty property);
    public abstract virtual void DisposeAndRaiseUnset(ValueStore owner, AvaloniaProperty property);
    protected abstract virtual void CoerceDefaultValueAndRaise(ValueStore owner, AvaloniaProperty property);
    [NullableContextAttribute("2")]
protected abstract virtual object GetBoxedValue();
    [NullableContextAttribute("2")]
protected void UpdateValueEntry(IValueEntry entry, BindingPriority priority);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.PropertyStore.EffectiveValue`1 : EffectiveValue {
    private StyledPropertyMetadata`1<T> _metadata;
    [NullableAttribute("2")]
private T _baseValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private UncommonFields<T> _uncommon;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; private set; }
    public EffectiveValue`1(AvaloniaObject owner, StyledProperty`1<T> property, EffectiveValue`1<T> inherited);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public virtual void SetAndRaise(ValueStore owner, IValueEntry value, BindingPriority priority);
    public virtual void SetLocalValueAndRaise(ValueStore owner, AvaloniaProperty property, object value);
    public void SetLocalValueAndRaise(ValueStore owner, StyledProperty`1<T> property, T value);
    public void SetCurrentValueAndRaise(ValueStore owner, StyledProperty`1<T> property, T value);
    public void SetCoercedDefaultValueAndRaise(ValueStore owner, StyledProperty`1<T> property, T value);
    public bool TryGetBaseValue(T& value);
    public virtual void RaiseInheritedValueChanged(AvaloniaObject owner, AvaloniaProperty property, EffectiveValue oldValue, EffectiveValue newValue);
    public virtual void RemoveAnimationAndRaise(ValueStore owner, AvaloniaProperty property);
    public virtual void CoerceValue(ValueStore owner, AvaloniaProperty property);
    public virtual void DisposeAndRaiseUnset(ValueStore owner, AvaloniaProperty property);
    protected virtual void CoerceDefaultValueAndRaise(ValueStore owner, AvaloniaProperty property);
    [NullableContextAttribute("2")]
protected virtual object GetBoxedValue();
    private static T GetValue(IValueEntry entry);
    private void SetAndRaiseCore(ValueStore owner, StyledProperty`1<T> property, T value, BindingPriority priority, bool isOverriddenCurrentValue, bool isCoercedDefaultValue);
    private void SetAndRaiseCore(ValueStore owner, StyledProperty`1<T> property, T value, BindingPriority priority, T baseValue, BindingPriority basePriority);
    private void NotifyValueChanged(ValueStore owner, StyledProperty`1<T> property, T oldValue);
    private void NotifyBaseValueChanged(ValueStore owner, StyledProperty`1<T> property);
}
internal enum Avalonia.PropertyStore.FramePriority : Enum {
    public sbyte value__;
    public static FramePriority Animation;
    public static FramePriority AnimationTemplatedParentTheme;
    public static FramePriority AnimationTheme;
    public static FramePriority StyleTrigger;
    public static FramePriority StyleTriggerTemplatedParentTheme;
    public static FramePriority StyleTriggerTheme;
    public static FramePriority Template;
    public static FramePriority TemplateTemplatedParentTheme;
    public static FramePriority TemplateTheme;
    public static FramePriority Style;
    public static FramePriority StyleTemplatedParentTheme;
    public static FramePriority StyleTheme;
}
[ExtensionAttribute]
internal static class Avalonia.PropertyStore.FramePriorityExtensions : object {
    [ExtensionAttribute]
public static FramePriority ToFramePriority(BindingPriority priority, FrameType type);
    [ExtensionAttribute]
public static BindingPriority ToBindingPriority(FramePriority priority);
    [ExtensionAttribute]
public static bool IsType(FramePriority priority, FrameType type);
}
internal enum Avalonia.PropertyStore.FrameType : Enum {
    public int value__;
    public static FrameType Style;
    public static FrameType TemplatedParentTheme;
    public static FrameType Theme;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.PropertyStore.ImmediateValueEntry`1 : object {
    private ImmediateValueFrame _owner;
    private T _value;
    [CompilerGeneratedAttribute]
private StyledProperty`1<T> <Property>k__BackingField;
    public StyledProperty`1<T> Property { get; }
    private AvaloniaProperty Avalonia.PropertyStore.IValueEntry.Property { get; }
    public ImmediateValueEntry`1(ImmediateValueFrame owner, StyledProperty`1<T> property, T value);
    [CompilerGeneratedAttribute]
public StyledProperty`1<T> get_Property();
    private sealed virtual override AvaloniaProperty Avalonia.PropertyStore.IValueEntry.get_Property();
    public sealed virtual void Unsubscribe();
    public sealed virtual void Dispose();
    private sealed virtual override bool Avalonia.PropertyStore.IValueEntry.HasValue();
    [NullableContextAttribute("2")]
private sealed virtual override object Avalonia.PropertyStore.IValueEntry.GetValue();
    private sealed virtual override T Avalonia.PropertyStore.IValueEntry<T>.GetValue();
    [NullableContextAttribute("2")]
private sealed virtual override bool Avalonia.PropertyStore.IValueEntry.GetDataValidationState(BindingValueType& state, Exception& error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.PropertyStore.ImmediateValueFrame : ValueFrame {
    public ImmediateValueFrame(BindingPriority priority);
    public IValueEntry AddBinding(UntypedBindingExpressionBase source);
    public TypedBindingEntry`1<T> AddBinding(StyledProperty`1<T> property, IObservable`1<BindingValue`1<T>> source);
    public TypedBindingEntry`1<T> AddBinding(StyledProperty`1<T> property, IObservable`1<T> source);
    public SourceUntypedBindingEntry`1<T> AddBinding(StyledProperty`1<T> property, IObservable`1<object> source);
    public ImmediateValueEntry`1<T> AddValue(StyledProperty`1<T> property, T value);
    public void OnEntryDisposed(IValueEntry value);
    protected virtual bool GetIsActive(Boolean& hasChanged);
}
[NullableContextAttribute("1")]
internal interface Avalonia.PropertyStore.IValueEntry {
    public AvaloniaProperty Property { get; }
    public abstract virtual AvaloniaProperty get_Property();
    public abstract virtual bool HasValue();
    [NullableContextAttribute("2")]
public abstract virtual object GetValue();
    [NullableContextAttribute("2")]
public abstract virtual bool GetDataValidationState(BindingValueType& state, Exception& error);
    public abstract virtual void Unsubscribe();
}
internal interface Avalonia.PropertyStore.IValueEntry`1 {
    [NullableContextAttribute("1")]
public abstract virtual T GetValue();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.PropertyStore.LocalValueBindingObserver`1 : LocalValueBindingObserverBase`1<T> {
    [NullableContextAttribute("1")]
public LocalValueBindingObserver`1(ValueStore owner, StyledProperty`1<T> property);
    public void Start(IObservable`1<object> source);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
public sealed virtual void OnNext(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.PropertyStore.LocalValueBindingObserverBase`1 : object {
    private ValueStore _owner;
    private bool _hasDataValidation;
    [NullableAttribute("2")]
protected IDisposable _subscription;
    [NullableAttribute("2")]
private T _defaultValue;
    private bool _isDefaultValueInitialized;
    [CompilerGeneratedAttribute]
private StyledProperty`1<T> <Property>k__BackingField;
    public StyledProperty`1<T> Property { get; }
    protected LocalValueBindingObserverBase`1(ValueStore owner, StyledProperty`1<T> property);
    [CompilerGeneratedAttribute]
public StyledProperty`1<T> get_Property();
    public void Start(IObservable`1<T> source);
    public void Start(IObservable`1<BindingValue`1<T>> source);
    public sealed virtual void Dispose();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
    public sealed virtual void OnNext(BindingValue`1<T> value);
    private T GetCachedDefaultValue();
    [CompilerGeneratedAttribute]
internal static void <OnNext>g__Execute|14_0(LocalValueBindingObserverBase`1<T> instance, T value);
    [CompilerGeneratedAttribute]
internal static void <OnNext>g__Execute|15_0(LocalValueBindingObserverBase`1<T> instance, BindingValue`1<T> value);
}
internal class Avalonia.PropertyStore.PropertyNotifying : ValueType {
    [NullableAttribute("2")]
private AvaloniaObject _owner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<AvaloniaObject, bool> _notifying;
    [NullableContextAttribute("1")]
private PropertyNotifying(AvaloniaObject owner, Action`2<AvaloniaObject, bool> notifying);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public static PropertyNotifying Start(AvaloniaObject owner, AvaloniaProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.PropertyStore.SourceUntypedBindingEntry`1 : BindingEntryBase`2<TTarget, object> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<TTarget, bool> _validate;
    public StyledProperty`1<TTarget> Property { get; }
    public SourceUntypedBindingEntry`1(AvaloniaObject target, ValueFrame frame, StyledProperty`1<TTarget> property, IObservable`1<object> source);
    public StyledProperty`1<TTarget> get_Property();
    [NullableContextAttribute("2")]
protected virtual BindingValue`1<TTarget> ConvertAndValidate(object value);
    protected virtual BindingValue`1<TTarget> ConvertAndValidate(BindingValue`1<object> value);
    protected virtual TTarget GetDefaultValue(AvaloniaObject owner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.PropertyStore.TypedBindingEntry`1 : BindingEntryBase`2<T, T> {
    public StyledProperty`1<T> Property { get; }
    public TypedBindingEntry`1(AvaloniaObject target, ValueFrame frame, StyledProperty`1<T> property, IObservable`1<T> source);
    public TypedBindingEntry`1(AvaloniaObject target, ValueFrame frame, StyledProperty`1<T> property, IObservable`1<BindingValue`1<T>> source);
    public StyledProperty`1<T> get_Property();
    protected virtual BindingValue`1<T> ConvertAndValidate(T value);
    protected virtual BindingValue`1<T> ConvertAndValidate(BindingValue`1<T> value);
    protected virtual T GetDefaultValue(AvaloniaObject owner);
}
internal static class Avalonia.PropertyStore.UntypedValueUtils : object {
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
public static BindingValue`1<T> ConvertAndValidate(object value, Type targetType, Func`2<T, bool> validate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.PropertyStore.ValueFrame : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IValueEntry> _entries;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AvaloniaPropertyDictionary`1<IValueEntry> _index;
    [NullableAttribute("2")]
private ValueStore _owner;
    private bool _isShared;
    [CompilerGeneratedAttribute]
private BindingPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private FramePriority <FramePriority>k__BackingField;
    public int EntryCount { get; }
    [NullableAttribute("2")]
public ValueStore Owner { get; }
    public BindingPriority Priority { get; }
    public FramePriority FramePriority { get; }
    protected ValueFrame(BindingPriority priority, FrameType type);
    public int get_EntryCount();
    public bool IsActive();
    [NullableContextAttribute("2")]
public ValueStore get_Owner();
    [CompilerGeneratedAttribute]
public BindingPriority get_Priority();
    [CompilerGeneratedAttribute]
public FramePriority get_FramePriority();
    public bool Contains(AvaloniaProperty property);
    public IValueEntry GetEntry(int index);
    [NullableContextAttribute("2")]
public void SetOwner(ValueStore owner);
    public bool TryGetEntryIfActive(AvaloniaProperty property, IValueEntry& entry, Boolean& activeChanged);
    public void OnBindingCompleted(IValueEntry binding);
    public virtual void Dispose();
    protected abstract virtual bool GetIsActive(Boolean& hasChanged);
    protected void MakeShared();
    protected void Add(IValueEntry value);
    protected void Remove(AvaloniaProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.PropertyStore.ValueStore : object {
    private List`1<ValueFrame> _frames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<int, IDisposable> _localValueBindings;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AvaloniaPropertyDictionary`1<EffectiveValue> _effectiveValues;
    private int _inheritedValueCount;
    private int _isEvaluating;
    private int _frameGeneration;
    private int _styling;
    [CompilerGeneratedAttribute]
private AvaloniaObject <Owner>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ValueStore <InheritanceAncestor>k__BackingField;
    public AvaloniaObject Owner { get; }
    [NullableAttribute("2")]
public ValueStore InheritanceAncestor { get; private set; }
    public bool IsEvaluating { get; }
    public IReadOnlyList`1<ValueFrame> Frames { get; }
    public ValueStore(AvaloniaObject owner);
    [CompilerGeneratedAttribute]
public AvaloniaObject get_Owner();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ValueStore get_InheritanceAncestor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_InheritanceAncestor(ValueStore value);
    public bool get_IsEvaluating();
    public IReadOnlyList`1<ValueFrame> get_Frames();
    public void BeginStyling();
    public void EndStyling();
    public void AddFrame(ValueFrame style);
    public BindingExpressionBase AddBinding(AvaloniaProperty property, UntypedBindingExpressionBase source);
    public IDisposable AddBinding(StyledProperty`1<T> property, IObservable`1<BindingValue`1<T>> source, BindingPriority priority);
    public IDisposable AddBinding(StyledProperty`1<T> property, IObservable`1<T> source, BindingPriority priority);
    public IDisposable AddBinding(StyledProperty`1<T> property, IObservable`1<object> source, BindingPriority priority);
    public IDisposable AddBinding(DirectPropertyBase`1<T> property, IObservable`1<BindingValue`1<T>> source);
    public IDisposable AddBinding(DirectPropertyBase`1<T> property, IObservable`1<T> source);
    public IDisposable AddBinding(DirectPropertyBase`1<T> property, IObservable`1<object> source);
    public void ClearValue(AvaloniaProperty property);
    public IDisposable SetValue(StyledProperty`1<T> property, T value, BindingPriority priority);
    public void SetCurrentValue(StyledProperty`1<T> property, T value);
    public void SetLocalValue(AvaloniaProperty property, object value);
    public void SetLocalValue(StyledProperty`1<T> property, T value);
    public object GetValue(AvaloniaProperty property);
    public T GetValue(StyledProperty`1<T> property);
    public BindingExpressionBase GetExpression(AvaloniaProperty property);
    private static EffectiveValue`1<T> CastEffectiveValue(EffectiveValue value);
    public bool IsAnimating(AvaloniaProperty property);
    public bool IsSet(AvaloniaProperty property);
    public void CoerceValue(AvaloniaProperty property);
    public void CoerceDefaultValue(StyledProperty`1<T> property);
    public Optional`1<T> GetBaseValue(StyledProperty`1<T> property);
    public bool TryGetInheritedValue(AvaloniaProperty property, EffectiveValue& result);
    public EffectiveValue`1<T> CreateEffectiveValue(StyledProperty`1<T> property);
    [NullableContextAttribute("2")]
public void SetInheritanceParent(AvaloniaObject newParent);
    public void OnBindingValueChanged(IValueEntry entry, BindingPriority priority);
    public void OnFrameActivationChanged(ValueFrame frame);
    [NullableContextAttribute("2")]
public void OnInheritanceAncestorChanged(ValueStore ancestor);
    public void OnInheritedEffectiveValueChanged(StyledProperty`1<T> property, T oldValue, EffectiveValue`1<T> value);
    public void OnInheritedEffectiveValueDisposed(StyledProperty`1<T> property, T oldValue, T newValue);
    public void OnLocalValueBindingCompleted(AvaloniaProperty property, IDisposable observer);
    public void OnAncestorInheritedValueChanged(StyledProperty`1<T> property, T oldValue, T newValue);
    public void OnValueEntryRemoved(ValueFrame frame, AvaloniaProperty property);
    public bool RemoveFrame(ValueFrame frame);
    public void RemoveFrames(FrameType type);
    public void RemoveFrames(IReadOnlyList`1<IStyle> styles);
    public AvaloniaPropertyValue GetDiagnostic(AvaloniaProperty property);
    [NullableContextAttribute("2")]
private sealed virtual override void Avalonia.Data.Core.IBindingExpressionSink.OnChanged(UntypedBindingExpressionBase instance, bool hasValueChanged, bool hasErrorChanged, object value, BindingError error);
    private sealed virtual override void Avalonia.Data.Core.IBindingExpressionSink.OnCompleted(UntypedBindingExpressionBase instance);
    public ValueStoreDiagnostic GetStoreDiagnostic();
    private int InsertFrame(ValueFrame frame);
    private ImmediateValueFrame GetOrCreateImmediateValueFrame(AvaloniaProperty property, BindingPriority priority, Int32& frameIndex);
    private void AddEffectiveValue(AvaloniaProperty property, EffectiveValue effectiveValue);
    private void AddEffectiveValueAndRaise(AvaloniaProperty property, IValueEntry entry, BindingPriority priority);
    private void RemoveEffectiveValue(AvaloniaProperty property, int index);
    private bool RemoveEffectiveValue(AvaloniaProperty property);
    [NullableContextAttribute("2")]
private void InheritedValueChanged(AvaloniaProperty property, EffectiveValue oldValue, EffectiveValue newValue);
    [NullableContextAttribute("2")]
private void ReevaluateEffectiveValue(AvaloniaProperty property, EffectiveValue current, IValueEntry changedValueEntry, bool ignoreLocalValue);
    [NullableContextAttribute("2")]
private void ReevaluateEffectiveValues(IValueEntry changedValueEntry);
    [NullableContextAttribute("2")]
private static bool HasHigherPriority(IValueEntry entry, BindingPriority entryPriority, EffectiveValue current, IValueEntry changedValueEntry);
    private bool TryGetEffectiveValue(AvaloniaProperty property, EffectiveValue& value);
    private EffectiveValue GetEffectiveValue(AvaloniaProperty property);
    private object GetDefaultValue(AvaloniaProperty property);
    private void DisposeExistingLocalValueBinding(AvaloniaProperty property);
    private int BinarySearchFrame(FramePriority priority);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private bool <GetExpression>g__TryGetLocalValue|36_0(BindingExpressionBase& result, <>c__DisplayClass36_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Reactive.AnonymousObserver`1 : object {
    private Action`1<T> _onNext;
    private Action`1<Exception> _onError;
    private Action _onCompleted;
    public AnonymousObserver`1(TaskCompletionSource`1<T> tcs);
    public AnonymousObserver`1(Action`1<T> onNext, Action`1<Exception> onError, Action onCompleted);
    public AnonymousObserver`1(Action`1<T> onNext);
    public AnonymousObserver`1(Action`1<T> onNext, Action`1<Exception> onError);
    public AnonymousObserver`1(Action`1<T> onNext, Action onCompleted);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Reactive.AnonymousObserverNonGenericHelper : object {
    public static Action`1<Exception> ThrowsOnError;
    public static Action NoOpCompleted;
    private static AnonymousObserverNonGenericHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Reactive.AvaloniaPropertyBindingObservable`2 : LightweightObservableBase`1<BindingValue`1<TResult>> {
    private WeakReference`1<AvaloniaObject> _target;
    private AvaloniaProperty _property;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<TSource, TResult> _converter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BindingValue`1<TResult> _value;
    public string Description { get; }
    public AvaloniaPropertyBindingObservable`2(AvaloniaObject target, AvaloniaProperty property, Func`2<TSource, TResult> converter);
    public sealed virtual string get_Description();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
    protected virtual void Subscribed(IObserver`1<BindingValue`1<TResult>> observer, bool first);
    private void PropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
    private void PropertyChanged_WithConversion(object sender, AvaloniaPropertyChangedEventArgs e);
    private void PublishValue(TResult newValue);
    [NullableContextAttribute("2")]
private void PublishUntypedValue(object newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Reactive.AvaloniaPropertyChangedObservable : LightweightObservableBase`1<AvaloniaPropertyChangedEventArgs> {
    private WeakReference`1<AvaloniaObject> _target;
    private AvaloniaProperty _property;
    public string Description { get; }
    public AvaloniaPropertyChangedObservable(AvaloniaObject target, AvaloniaProperty property);
    public sealed virtual string get_Description();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
    private void PropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Reactive.AvaloniaPropertyObservable`2 : LightweightObservableBase`1<TResult> {
    private WeakReference`1<AvaloniaObject> _target;
    private AvaloniaProperty _property;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<TSource, TResult> _converter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Optional`1<TResult> _value;
    public string Description { get; }
    public AvaloniaPropertyObservable`2(AvaloniaObject target, AvaloniaProperty property, Func`2<TSource, TResult> converter);
    public sealed virtual string get_Description();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
    protected virtual void Subscribed(IObserver`1<TResult> observer, bool first);
    private void PropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e);
    private void PropertyChanged_WithConversion(object sender, AvaloniaPropertyChangedEventArgs e);
    private void PublishNewValue(TResult newValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Reactive.CombinedSubject`1 : object {
    private IObserver`1<T> _observer;
    private IObservable`1<T> _observable;
    public CombinedSubject`1(IObserver`1<T> observer, IObservable`1<T> observable);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Reactive.CompositeDisposable : object {
    private object _gate;
    private bool _disposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IDisposable> _disposables;
    private int _count;
    private static int ShrinkThreshold;
    private static CompositeEnumerator EmptyEnumerator;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsDisposed { get; }
    public CompositeDisposable(int capacity);
    public CompositeDisposable(IDisposable[] disposables);
    public CompositeDisposable(IList`1<IDisposable> disposables);
    private static CompositeDisposable();
    private static List`1<IDisposable> ToList(IEnumerable`1<IDisposable> disposables);
    public sealed virtual int get_Count();
    public sealed virtual void Add(IDisposable item);
    public sealed virtual bool Remove(IDisposable item);
    public sealed virtual void Dispose();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IDisposable item);
    public sealed virtual void CopyTo(IDisposable[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<IDisposable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool get_IsDisposed();
}
internal static class Avalonia.Reactive.Disposable : object {
    [NullableAttribute("1")]
public static IDisposable Empty { get; }
    [NullableContextAttribute("1")]
public static IDisposable get_Empty();
    [NullableContextAttribute("1")]
public static IDisposable Create(Action dispose);
    [NullableContextAttribute("1")]
public static IDisposable Create(TState state, Action`1<TState> dispose);
}
[ExtensionAttribute]
internal static class Avalonia.Reactive.DisposableMixin : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T DisposeWith(T item, CompositeDisposable compositeDisposable);
}
[NullableContextAttribute("2")]
internal interface Avalonia.Reactive.IAvaloniaSubject`1 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Reactive.LightweightObservableBase`1 : object {
    [NullableAttribute("2")]
private Exception _error;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IObserver`1<T>> _observers;
    public bool HasObservers { get; }
    public bool get_HasObservers();
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
    private void Remove(IObserver`1<T> observer);
    protected abstract virtual void Initialize();
    protected abstract virtual void Deinitialize();
    protected void PublishNext(T value);
    protected void PublishCompleted();
    protected void PublishError(Exception error);
    protected virtual void Subscribed(IObserver`1<T> observer, bool first);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Reactive.LightweightSubject`1 : LightweightObservableBase`1<T> {
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(T value);
    protected virtual void Initialize();
    protected virtual void Deinitialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Reactive.Observable : object {
    public static IObservable`1<TSource> Create(Func`2<IObserver`1<TSource>, IDisposable> subscribe);
    [ExtensionAttribute]
public static IDisposable Subscribe(IObservable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static IObservable`1<TResult> Select(IObservable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static IObservable`1<TSource> StartWith(IObservable`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static IObservable`1<TSource> Where(IObservable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IObservable`1<TSource> Switch(IObservable`1<IObservable`1<TSource>> sources);
    [ExtensionAttribute]
public static IObservable`1<TResult> CombineLatest(IObservable`1<TFirst> first, IObservable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static IObservable`1<TInput[]> CombineLatest(IEnumerable`1<IObservable`1<TInput>> inputs);
    [ExtensionAttribute]
public static IObservable`1<T> Skip(IObservable`1<T> source, int skipCount);
    [ExtensionAttribute]
public static IObservable`1<T> Take(IObservable`1<T> source, int takeCount);
    public static IObservable`1<EventArgs> FromEventPattern(Action`1<EventHandler> addHandler, Action`1<EventHandler> removeHandler);
    public static IObservable`1<T> FromEventPattern(Action`1<EventHandler`1<T>> addHandler, Action`1<EventHandler`1<T>> removeHandler);
    public static IObservable`1<T> Return(T value);
    public static IObservable`1<T> Empty();
    public static IObservable`1<T> SingleValue(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Reactive.Operators.CombineLatest`2 : object {
    private IEnumerable`1<IObservable`1<TSource>> _sources;
    private Func`2<TSource[], TResult> _resultSelector;
    public CombineLatest`2(IEnumerable`1<IObservable`1<TSource>> sources, Func`2<TSource[], TResult> resultSelector);
    public sealed virtual IDisposable Subscribe(IObserver`1<TResult> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Reactive.Operators.CombineLatest`3 : object {
    private IObservable`1<TFirst> _first;
    private IObservable`1<TSecond> _second;
    private Func`3<TFirst, TSecond, TResult> _resultSelector;
    public CombineLatest`3(IObservable`1<TFirst> first, IObservable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    public sealed virtual IDisposable Subscribe(IObserver`1<TResult> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Avalonia.Reactive.Operators.IdentitySink`1 : Sink`2<T, T> {
    protected IdentitySink`1(IObserver`1<T> observer);
    public virtual void OnNext(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Reactive.Operators.Sink`1 : object {
    [NullableAttribute("2")]
private IDisposable _upstream;
    private IObserver`1<TTarget> _observer;
    protected Sink`1(IObserver`1<TTarget> observer);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void ForwardOnNext(TTarget value);
    public void ForwardOnCompleted();
    public void ForwardOnError(Exception error);
    protected void SetUpstream(IDisposable upstream);
    protected void DisposeUpstream();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Avalonia.Reactive.Operators.Sink`2 : Sink`1<TTarget> {
    protected Sink`2(IObserver`1<TTarget> observer);
    public virtual void Run(IObservable`1<TSource> source);
    public abstract virtual void OnNext(TSource value);
    public virtual void OnError(Exception error);
    public virtual void OnCompleted();
    public IObserver`1<TTarget> GetForwarder();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Reactive.Operators.Switch`1 : object {
    private IObservable`1<IObservable`1<TSource>> _sources;
    public Switch`1(IObservable`1<IObservable`1<TSource>> sources);
    public sealed virtual IDisposable Subscribe(IObserver`1<TSource> observer);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Reactive.SerialDisposableValue : object {
    private IDisposable _current;
    private bool _disposed;
    public IDisposable Disposable { get; public set; }
    public IDisposable get_Disposable();
    public void set_Disposable(IDisposable value);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Reactive.SingleSubscriberObservableBase`1 : object {
    [NullableAttribute("2")]
private Exception _error;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IObserver`1<T> _observer;
    private bool _completed;
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
    public virtual void Dispose();
    protected abstract virtual void Unsubscribed();
    protected void PublishNext(T value);
    protected void PublishCompleted();
    protected void PublishError(Exception error);
    protected abstract virtual void Subscribed();
}
[IsReadOnlyAttribute]
public class Avalonia.Rect : ValueType {
    private double _x;
    private double _y;
    private double _width;
    private double _height;
    public double X { get; }
    public double Y { get; }
    public double Width { get; }
    public double Height { get; }
    public Point Position { get; }
    public Size Size { get; }
    public double Right { get; }
    public double Bottom { get; }
    public double Left { get; }
    public double Top { get; }
    public Point TopLeft { get; }
    public Point TopRight { get; }
    public Point BottomLeft { get; }
    public Point BottomRight { get; }
    public Point Center { get; }
    public Rect(double x, double y, double width, double height);
    public Rect(Size size);
    public Rect(Point position, Size size);
    public Rect(Point topLeft, Point bottomRight);
    public double get_X();
    public double get_Y();
    public double get_Width();
    public double get_Height();
    public Point get_Position();
    public Size get_Size();
    public double get_Right();
    public double get_Bottom();
    public double get_Left();
    public double get_Top();
    public Point get_TopLeft();
    public Point get_TopRight();
    public Point get_BottomLeft();
    public Point get_BottomRight();
    public Point get_Center();
    public static bool op_Equality(Rect left, Rect right);
    public static bool op_Inequality(Rect left, Rect right);
    public static Rect op_Multiply(Rect rect, Vector scale);
    public static Rect op_Multiply(Rect rect, double scale);
    public static Rect op_Division(Rect rect, Vector scale);
    public bool Contains(Point p);
    public bool ContainsExclusive(Point p);
    public bool Contains(Rect r);
    public Rect CenterRect(Rect rect);
    public Rect Inflate(double thickness);
    public Rect Inflate(Thickness thickness);
    public Rect Deflate(double thickness);
    public Rect Deflate(Thickness thickness);
    public sealed virtual bool Equals(Rect other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Rect Intersect(Rect rect);
    public bool Intersects(Rect rect);
    public Rect TransformToAABB(Matrix matrix);
    internal Rect TransformToAABB(Matrix4x4 matrix);
    public Rect Translate(Vector offset);
    public Rect Normalize();
    public Rect Union(Rect rect);
    internal static Nullable`1<Rect> Union(Nullable`1<Rect> left, Nullable`1<Rect> right);
    public Rect WithX(double x);
    public Rect WithY(double y);
    public Rect WithWidth(double width);
    public Rect WithHeight(double height);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static Rect Parse(string s);
    internal bool IsEmpty();
}
[IsReadOnlyAttribute]
public class Avalonia.RelativePoint : ValueType {
    public static RelativePoint TopLeft;
    public static RelativePoint Center;
    public static RelativePoint BottomRight;
    private Point _point;
    private RelativeUnit _unit;
    public Point Point { get; }
    public RelativeUnit Unit { get; }
    public RelativePoint(double x, double y, RelativeUnit unit);
    public RelativePoint(Point point, RelativeUnit unit);
    private static RelativePoint();
    public Point get_Point();
    public RelativeUnit get_Unit();
    public static bool op_Equality(RelativePoint left, RelativePoint right);
    public static bool op_Inequality(RelativePoint left, RelativePoint right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RelativePoint p);
    public virtual int GetHashCode();
    public Point ToPixels(Size size);
    public Point ToPixels(Rect rect);
    [NullableContextAttribute("1")]
public static RelativePoint Parse(string s);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Avalonia.RelativeRect : ValueType {
    [NullableAttribute("1")]
private static Char[] PercentChar;
    public static RelativeRect Fill;
    [CompilerGeneratedAttribute]
private RelativeUnit <Unit>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <Rect>k__BackingField;
    public RelativeUnit Unit { get; }
    public Rect Rect { get; }
    public RelativeRect(double x, double y, double width, double height, RelativeUnit unit);
    public RelativeRect(Rect rect, RelativeUnit unit);
    public RelativeRect(Size size, RelativeUnit unit);
    public RelativeRect(Point position, Size size, RelativeUnit unit);
    public RelativeRect(Point topLeft, Point bottomRight, RelativeUnit unit);
    private static RelativeRect();
    [CompilerGeneratedAttribute]
public RelativeUnit get_Unit();
    [CompilerGeneratedAttribute]
public Rect get_Rect();
    public static bool op_Equality(RelativeRect left, RelativeRect right);
    public static bool op_Inequality(RelativeRect left, RelativeRect right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RelativeRect p);
    public virtual int GetHashCode();
    public Rect ToPixels(Size size);
    public Rect ToPixels(Rect boundingBox);
    [NullableContextAttribute("1")]
public static RelativeRect Parse(string s);
}
public class Avalonia.RelativeScalar : ValueType {
    private double _scalar;
    private RelativeUnit _unit;
    [CompilerGeneratedAttribute]
private static RelativeScalar <Beginning>k__BackingField;
    [CompilerGeneratedAttribute]
private static RelativeScalar <Middle>k__BackingField;
    [CompilerGeneratedAttribute]
private static RelativeScalar <End>k__BackingField;
    public double Scalar { get; }
    public RelativeUnit Unit { get; }
    public static RelativeScalar Beginning { get; }
    public static RelativeScalar Middle { get; }
    public static RelativeScalar End { get; }
    public RelativeScalar(double scalar, RelativeUnit unit);
    private static RelativeScalar();
    public double get_Scalar();
    public RelativeUnit get_Unit();
    [CompilerGeneratedAttribute]
public static RelativeScalar get_Beginning();
    [CompilerGeneratedAttribute]
public static RelativeScalar get_Middle();
    [CompilerGeneratedAttribute]
public static RelativeScalar get_End();
    public sealed virtual bool Equals(RelativeScalar other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RelativeScalar left, RelativeScalar right);
    public static bool op_Inequality(RelativeScalar left, RelativeScalar right);
    public double ToValue(double size);
    [NullableContextAttribute("1")]
public static RelativeScalar Parse(string s);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum Avalonia.RelativeUnit : Enum {
    public int value__;
    public static RelativeUnit Relative;
    public static RelativeUnit Absolute;
}
public enum Avalonia.Rendering.Composition.Animations.AnimationDelayBehavior : Enum {
    public int value__;
    public static AnimationDelayBehavior SetInitialValueAfterDelay;
    public static AnimationDelayBehavior SetInitialValueBeforeDelay;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.Composition.Animations.AnimationInstanceBase : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<ServerObject, CompositionProperty>> _trackedObjects;
    [CompilerGeneratedAttribute]
private PropertySetSnapshot <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerObject <TargetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private CompositionProperty <Property>k__BackingField;
    private bool _invalidated;
    protected PropertySetSnapshot Parameters { get; }
    public ServerObject TargetObject { get; }
    protected CompositionProperty Property { get; private set; }
    public AnimationInstanceBase(ServerObject target, PropertySetSnapshot parameters);
    [CompilerGeneratedAttribute]
protected PropertySetSnapshot get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual ServerObject get_TargetObject();
    [CompilerGeneratedAttribute]
protected CompositionProperty get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(CompositionProperty value);
    protected void Initialize(CompositionProperty property, HashSet`1<ValueTuple`2<string, string>> trackedObjects);
    public abstract virtual void Initialize(TimeSpan startedAt, ExpressionVariant startingValue, CompositionProperty property);
    protected abstract virtual ExpressionVariant EvaluateCore(TimeSpan now, ExpressionVariant currentValue);
    public sealed virtual ExpressionVariant Evaluate(TimeSpan now, ExpressionVariant currentValue);
    public virtual void Activate();
    public virtual void Deactivate();
    public sealed virtual void Invalidate();
    public sealed virtual void OnTick();
}
public enum Avalonia.Rendering.Composition.Animations.AnimationIterationBehavior : Enum {
    public int value__;
    public static AnimationIterationBehavior Count;
    public static AnimationIterationBehavior Forever;
}
public enum Avalonia.Rendering.Composition.Animations.AnimationStopBehavior : Enum {
    public int value__;
    public static AnimationStopBehavior LeaveCurrentValue;
    public static AnimationStopBehavior SetToInitialValue;
    public static AnimationStopBehavior SetToFinalValue;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.BooleanInterpolator : object {
    [CompilerGeneratedAttribute]
private static BooleanInterpolator <Instance>k__BackingField;
    public static BooleanInterpolator Instance { get; }
    private static BooleanInterpolator();
    public sealed virtual bool Interpolate(bool from, bool to, float progress);
    [CompilerGeneratedAttribute]
public static BooleanInterpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.ColorInterpolator : object {
    [CompilerGeneratedAttribute]
private static ColorInterpolator <Instance>k__BackingField;
    public static ColorInterpolator Instance { get; }
    private static ColorInterpolator();
    private static byte Lerp(float a, float b, float p);
    public static Color LerpRGB(Color to, Color from, float progress);
    public sealed virtual Color Interpolate(Color from, Color to, float progress);
    [CompilerGeneratedAttribute]
public static ColorInterpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Rendering.Composition.Animations.CompositionAnimation : CompositionObject {
    private CompositionPropertySet _propertySet;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [NullableAttribute("2")]
public string Target { get; public set; }
    internal CompositionAnimation(Compositor compositor);
    public void ClearAllParameters();
    public void ClearParameter(string key);
    private void SetVariant(string key, ExpressionVariant value);
    public void SetColorParameter(string key, Color value);
    public void SetMatrix3x2Parameter(string key, Matrix3x2 value);
    public void SetMatrix4x4Parameter(string key, Matrix4x4 value);
    public void SetQuaternionParameter(string key, Quaternion value);
    public void SetReferenceParameter(string key, CompositionObject compositionObject);
    public void SetScalarParameter(string key, float value);
    public void SetVector2Parameter(string key, Vector2 value);
    public void SetVector3Parameter(string key, Vector3 value);
    public void SetVector4Parameter(string key, Vector4 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Target();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Target(string value);
    internal abstract virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    internal PropertySetSnapshot CreateSnapshot();
    private sealed virtual override void Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase.InternalOnly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.Animations.CompositionAnimationGroup : CompositionObject {
    [CompilerGeneratedAttribute]
private List`1<CompositionAnimation> <Animations>k__BackingField;
    internal List`1<CompositionAnimation> Animations { get; }
    public CompositionAnimationGroup(Compositor compositor);
    [CompilerGeneratedAttribute]
internal List`1<CompositionAnimation> get_Animations();
    private sealed virtual override void Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase.InternalOnly();
    public void Add(CompositionAnimation value);
    public void Remove(CompositionAnimation value);
    public void RemoveAll();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.DoubleInterpolator : object {
    [CompilerGeneratedAttribute]
private static DoubleInterpolator <Instance>k__BackingField;
    public static DoubleInterpolator Instance { get; }
    private static DoubleInterpolator();
    public sealed virtual double Interpolate(double from, double to, float progress);
    [CompilerGeneratedAttribute]
public static DoubleInterpolator get_Instance();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.Animations.ExpressionAnimation : CompositionAnimation {
    private string _expression;
    private Expression _parsedExpression;
    public string Expression { get; public set; }
    [NullableAttribute("1")]
private Expression ParsedExpression { get; }
    [NullableContextAttribute("1")]
internal ExpressionAnimation(Compositor compositor);
    public string get_Expression();
    public void set_Expression(string value);
    [NullableContextAttribute("1")]
private Expression get_ParsedExpression();
    [NullableContextAttribute("1")]
internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
}
internal class Avalonia.Rendering.Composition.Animations.ExpressionAnimationInstance : AnimationInstanceBase {
    [NullableAttribute("1")]
private Expression _expression;
    private ExpressionVariant _startingValue;
    private Nullable`1<ExpressionVariant> _finalValue;
    [NullableContextAttribute("1")]
public ExpressionAnimationInstance(Expression expression, ServerObject target, Nullable`1<ExpressionVariant> finalValue, PropertySetSnapshot parameters);
    protected virtual ExpressionVariant EvaluateCore(TimeSpan now, ExpressionVariant currentValue);
    [NullableContextAttribute("1")]
public virtual void Initialize(TimeSpan startedAt, ExpressionVariant startingValue, CompositionProperty property);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Animations.IAnimationInstance {
    public ServerObject TargetObject { get; }
    public abstract virtual ServerObject get_TargetObject();
    public abstract virtual ExpressionVariant Evaluate(TimeSpan now, ExpressionVariant currentValue);
    public abstract virtual void Initialize(TimeSpan startedAt, ExpressionVariant startingValue, CompositionProperty property);
    public abstract virtual void Activate();
    public abstract virtual void Deactivate();
    public abstract virtual void Invalidate();
}
public interface Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase {
    internal abstract virtual void InternalOnly();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Animations.IInterpolator`1 {
    public abstract virtual T Interpolate(T from, T to, float progress);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Animations.IKeyFrames {
    public abstract virtual void InsertExpressionKeyFrame(float normalizedProgressKey, string value, IEasing easingFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Rendering.Composition.Animations.ImplicitAnimationCollection : CompositionObject {
    private Dictionary`2<string, ICompositionAnimationBase> _inner;
    private IDictionary`2<string, ICompositionAnimationBase> _innerface;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.IsReadOnly { get; }
    public ICompositionAnimationBase Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>.Keys { get; }
    private ICollection`1<ICompositionAnimationBase> System.Collections.Generic.IDictionary<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>.Values { get; }
    public UInt32 Size { get; }
    internal ImplicitAnimationCollection(Compositor compositor);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, ICompositionAnimationBase>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.Add(KeyValuePair`2<string, ICompositionAnimationBase> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.Contains(KeyValuePair`2<string, ICompositionAnimationBase> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.Remove(KeyValuePair`2<string, ICompositionAnimationBase> item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.get_IsReadOnly();
    public sealed virtual void Add(string key, ICompositionAnimationBase value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, ICompositionAnimationBase& value);
    public sealed virtual ICompositionAnimationBase get_Item(string key);
    public sealed virtual void set_Item(string key, ICompositionAnimationBase value);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>.get_Keys();
    private sealed virtual override ICollection`1<ICompositionAnimationBase> System.Collections.Generic.IDictionary<System.String,Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>.get_Values();
    public UInt32 get_Size();
    public IReadOnlyDictionary`2<string, ICompositionAnimationBase> GetView();
    public bool HasKey(string key);
    public void Insert(string key, ICompositionAnimationBase animation);
    public ICompositionAnimationBase Lookup(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.KeyFrame`1 : ValueType {
    public float NormalizedProgressKey;
    public T Value;
    public Expression Expression;
    public IEasing EasingFunction;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Rendering.Composition.Animations.KeyFrameAnimation : CompositionAnimation {
    private TimeSpan _duration;
    [CompilerGeneratedAttribute]
private AnimationDelayBehavior <DelayBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DelayTime>k__BackingField;
    [CompilerGeneratedAttribute]
private PlaybackDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private AnimationIterationBehavior <IterationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IterationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private AnimationStopBehavior <StopBehavior>k__BackingField;
    public AnimationDelayBehavior DelayBehavior { get; public set; }
    public TimeSpan DelayTime { get; public set; }
    public PlaybackDirection Direction { get; public set; }
    public TimeSpan Duration { get; public set; }
    public AnimationIterationBehavior IterationBehavior { get; public set; }
    public int IterationCount { get; public set; }
    public AnimationStopBehavior StopBehavior { get; public set; }
    private protected IKeyFrames KeyFrames { get; }
    internal KeyFrameAnimation(Compositor compositor);
    [CompilerGeneratedAttribute]
public AnimationDelayBehavior get_DelayBehavior();
    [CompilerGeneratedAttribute]
public void set_DelayBehavior(AnimationDelayBehavior value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DelayTime();
    [CompilerGeneratedAttribute]
public void set_DelayTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public PlaybackDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(PlaybackDirection value);
    public TimeSpan get_Duration();
    public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public AnimationIterationBehavior get_IterationBehavior();
    [CompilerGeneratedAttribute]
public void set_IterationBehavior(AnimationIterationBehavior value);
    [CompilerGeneratedAttribute]
public int get_IterationCount();
    [CompilerGeneratedAttribute]
public void set_IterationCount(int value);
    [CompilerGeneratedAttribute]
public AnimationStopBehavior get_StopBehavior();
    [CompilerGeneratedAttribute]
public void set_StopBehavior(AnimationStopBehavior value);
    private protected abstract virtual IKeyFrames get_KeyFrames();
    public void InsertExpressionKeyFrame(float normalizedProgressKey, string value, Easing easingFunction);
}
internal class Avalonia.Rendering.Composition.Animations.KeyFrameAnimationInstance`1 : AnimationInstanceBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IInterpolator`1<T> _interpolator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ServerKeyFrame`1[] _keyFrames;
    private Nullable`1<ExpressionVariant> _finalValue;
    private AnimationDelayBehavior _delayBehavior;
    private TimeSpan _delayTime;
    private PlaybackDirection _direction;
    private TimeSpan _duration;
    private AnimationIterationBehavior _iterationBehavior;
    private int _iterationCount;
    private AnimationStopBehavior _stopBehavior;
    private TimeSpan _startedAt;
    private T _startingValue;
    private TimeSpan _totalDuration;
    private bool _finished;
    [NullableContextAttribute("1")]
public KeyFrameAnimationInstance`1(IInterpolator`1<T> interpolator, ServerKeyFrame`1[] keyFrames, PropertySetSnapshot snapshot, Nullable`1<ExpressionVariant> finalValue, ServerObject target, AnimationDelayBehavior delayBehavior, TimeSpan delayTime, PlaybackDirection direction, TimeSpan duration, AnimationIterationBehavior iterationBehavior, int iterationCount, AnimationStopBehavior stopBehavior);
    protected virtual ExpressionVariant EvaluateCore(TimeSpan now, ExpressionVariant currentValue);
    private ExpressionVariant EvaluateImpl(TimeSpan elapsed, ExpressionVariant currentValue, ExpressionEvaluationContext& ctx);
    private static T GetKeyFrame(ExpressionEvaluationContext& ctx, ServerKeyFrame`1<T> f);
    [NullableContextAttribute("1")]
public virtual void Initialize(TimeSpan startedAt, ExpressionVariant startingValue, CompositionProperty property);
    public virtual void Activate();
    public virtual void Deactivate();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Rendering.Composition.Animations.KeyFrames`1 : List`1<KeyFrame`1<T>> {
    private void Validate(float key);
    public sealed virtual void InsertExpressionKeyFrame(float normalizedProgressKey, string value, IEasing easingFunction);
    public void Insert(float normalizedProgressKey, T value, IEasing easingFunction);
    public ServerKeyFrame`1[] Snapshot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.PropertySetSnapshot : object {
    private Dictionary`2<string, Value> _dic;
    public PropertySetSnapshot(Dictionary`2<string, Value> dic);
    public sealed virtual ExpressionVariant GetParameter(string name);
    public sealed virtual IExpressionObject GetObjectParameter(string name);
    public sealed virtual ExpressionVariant GetProperty(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.QuaternionInterpolator : object {
    [CompilerGeneratedAttribute]
private static QuaternionInterpolator <Instance>k__BackingField;
    public static QuaternionInterpolator Instance { get; }
    private static QuaternionInterpolator();
    public sealed virtual Quaternion Interpolate(Quaternion from, Quaternion to, float progress);
    [CompilerGeneratedAttribute]
public static QuaternionInterpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.ScalarInterpolator : object {
    [CompilerGeneratedAttribute]
private static ScalarInterpolator <Instance>k__BackingField;
    public static ScalarInterpolator Instance { get; }
    private static ScalarInterpolator();
    public sealed virtual float Interpolate(float from, float to, float progress);
    [CompilerGeneratedAttribute]
public static ScalarInterpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.ServerKeyFrame`1 : ValueType {
    public T Value;
    [NullableAttribute("2")]
public Expression Expression;
    public IEasing EasingFunction;
    public float Key;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.Vector2Interpolator : object {
    [CompilerGeneratedAttribute]
private static Vector2Interpolator <Instance>k__BackingField;
    public static Vector2Interpolator Instance { get; }
    private static Vector2Interpolator();
    public sealed virtual Vector2 Interpolate(Vector2 from, Vector2 to, float progress);
    [CompilerGeneratedAttribute]
public static Vector2Interpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.Vector3DInterpolator : object {
    [CompilerGeneratedAttribute]
private static Vector3DInterpolator <Instance>k__BackingField;
    public static Vector3DInterpolator Instance { get; }
    private static Vector3DInterpolator();
    public sealed virtual Vector3D Interpolate(Vector3D from, Vector3D to, float progress);
    [CompilerGeneratedAttribute]
public static Vector3DInterpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.Vector3Interpolator : object {
    [CompilerGeneratedAttribute]
private static Vector3Interpolator <Instance>k__BackingField;
    public static Vector3Interpolator Instance { get; }
    private static Vector3Interpolator();
    public sealed virtual Vector3 Interpolate(Vector3 from, Vector3 to, float progress);
    [CompilerGeneratedAttribute]
public static Vector3Interpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.Vector4Interpolator : object {
    [CompilerGeneratedAttribute]
private static Vector4Interpolator <Instance>k__BackingField;
    public static Vector4Interpolator Instance { get; }
    private static Vector4Interpolator();
    public sealed virtual Vector4 Interpolate(Vector4 from, Vector4 to, float progress);
    [CompilerGeneratedAttribute]
public static Vector4Interpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Animations.VectorInterpolator : object {
    [CompilerGeneratedAttribute]
private static VectorInterpolator <Instance>k__BackingField;
    public static VectorInterpolator Instance { get; }
    private static VectorInterpolator();
    public sealed virtual Vector Interpolate(Vector from, Vector to, float progress);
    [CompilerGeneratedAttribute]
public static VectorInterpolator get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.BooleanKeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<bool> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public BooleanKeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, bool value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.ColorKeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<Color> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public ColorKeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, Color value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, Color value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.CompositingRenderer : object {
    private IRenderRoot _root;
    private Compositor _compositor;
    private RenderDataDrawingContext _recorder;
    private HashSet`1<Visual> _dirty;
    private HashSet`1<Visual> _recalculateChildren;
    private Action _update;
    private bool _queuedUpdate;
    private bool _queuedSceneInvalidation;
    private bool _updating;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private CompositionTarget <CompositionTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private RendererDiagnostics <Diagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<SceneInvalidatedEventArgs> SceneInvalidated;
    internal CompositionTarget CompositionTarget { get; }
    public RendererDiagnostics Diagnostics { get; }
    public Compositor Compositor { get; }
    public bool IsDisposed { get; }
    public CompositingRenderer(IRenderRoot root, Compositor compositor, Func`1<IEnumerable`1<object>> surfaces);
    [CompilerGeneratedAttribute]
internal CompositionTarget get_CompositionTarget();
    [CompilerGeneratedAttribute]
public sealed virtual RendererDiagnostics get_Diagnostics();
    public sealed virtual Compositor get_Compositor();
    private void OnDiagnosticsPropertyChanged(object sender, PropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SceneInvalidated(EventHandler`1<SceneInvalidatedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SceneInvalidated(EventHandler`1<SceneInvalidatedEventArgs> value);
    private void QueueUpdate();
    public sealed virtual void AddDirty(Visual visual);
    [IteratorStateMachineAttribute("Avalonia.Rendering.Composition.CompositingRenderer/<HitTest>d__25")]
public sealed virtual IEnumerable`1<Visual> HitTest(Point p, Visual root, Func`2<Visual, bool> filter);
    public sealed virtual Visual HitTestFirst(Point p, Visual root, Func`2<Visual, bool> filter);
    public sealed virtual void RecalculateChildren(Visual visual);
    private void UpdateCore();
    public void TriggerSceneInvalidatedForUnitTests(Rect rect);
    private void Update();
    public sealed virtual void Resized(Size size);
    public sealed virtual void Paint(Rect rect);
    public void Paint(Rect rect, bool catchExceptions);
    public sealed virtual void Start();
    public sealed virtual void Stop();
    public sealed virtual ValueTask`1<object> TryGetRenderInterfaceFeature(Type featureType);
    public bool get_IsDisposed();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <UpdateCore>b__28_0(Task _);
    [CompilerGeneratedAttribute]
private void <UpdateCore>b__28_1();
}
public enum Avalonia.Rendering.Composition.CompositionBlendMode : Enum {
    public int value__;
    public static CompositionBlendMode Clear;
    public static CompositionBlendMode Src;
    public static CompositionBlendMode Dst;
    public static CompositionBlendMode SrcOver;
    public static CompositionBlendMode DstOver;
    public static CompositionBlendMode SrcIn;
    public static CompositionBlendMode DstIn;
    public static CompositionBlendMode SrcOut;
    public static CompositionBlendMode DstOut;
    public static CompositionBlendMode SrcATop;
    public static CompositionBlendMode DstATop;
    public static CompositionBlendMode Xor;
    public static CompositionBlendMode Plus;
    public static CompositionBlendMode Modulate;
    public static CompositionBlendMode Screen;
    public static CompositionBlendMode Overlay;
    public static CompositionBlendMode Darken;
    public static CompositionBlendMode Lighten;
    public static CompositionBlendMode ColorDodge;
    public static CompositionBlendMode ColorBurn;
    public static CompositionBlendMode HardLight;
    public static CompositionBlendMode SoftLight;
    public static CompositionBlendMode Difference;
    public static CompositionBlendMode Exclusion;
    public static CompositionBlendMode Multiply;
    public static CompositionBlendMode Hue;
    public static CompositionBlendMode Saturation;
    public static CompositionBlendMode Color;
    public static CompositionBlendMode Luminosity;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.CompositionContainerVisual : CompositionVisual {
    [CompilerGeneratedAttribute]
private CompositionVisualCollection <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCompositionContainerVisual <Server>k__BackingField;
    public CompositionVisualCollection Children { get; private set; }
    internal ServerCompositionContainerVisual Server { get; }
    internal CompositionContainerVisual(Compositor compositor, ServerCompositionContainerVisual server);
    [CompilerGeneratedAttribute]
public CompositionVisualCollection get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(CompositionVisualCollection value);
    private protected virtual void OnRootChangedCore();
    [CompilerGeneratedAttribute]
internal ServerCompositionContainerVisual get_Server();
    private void InitializeDefaults();
    private void InitializeDefaultsExtra();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.CompositionCustomVisual : CompositionContainerVisual {
    private static ThreadSafeObjectPool`1<List`1<object>> s_messageListPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<object> _messages;
    internal CompositionCustomVisual(Compositor compositor, CompositionCustomVisualHandler handler);
    private static CompositionCustomVisual();
    public void SendHandlerMessage(object message);
    private void OnCompositionUpdate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Rendering.Composition.CompositionCustomVisualHandler : object {
    [NullableAttribute("2")]
private ServerCompositionCustomVisual _host;
    private bool _inRender;
    private Rect _currentTransformedClip;
    protected Vector EffectiveSize { get; }
    protected TimeSpan CompositionNow { get; }
    public virtual void OnMessage(object message);
    public virtual void OnAnimationFrameUpdate();
    internal void Render(ImmediateDrawingContext drawingContext, Rect currentTransformedClip);
    public abstract virtual void OnRender(ImmediateDrawingContext drawingContext);
    private void VerifyAccess();
    private void VerifyInRender();
    protected Vector get_EffectiveSize();
    protected TimeSpan get_CompositionNow();
    public virtual Rect GetRenderBounds();
    internal void Attach(ServerCompositionCustomVisual visual);
    protected void Invalidate();
    protected void Invalidate(Rect rc);
    protected void RegisterForNextAnimationFrameUpdate();
    protected bool RenderClipContains(Point pt);
    protected bool RenderClipIntersectes(Rect rc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.CompositionDrawingSurface : CompositionSurface {
    internal ServerCompositionDrawingSurface Server { get; }
    internal CompositionDrawingSurface(Compositor compositor);
    internal ServerCompositionDrawingSurface get_Server();
    public Task UpdateWithKeyedMutexAsync(ICompositionImportedGpuImage image, UInt32 acquireIndex, UInt32 releaseIndex);
    public Task UpdateWithSemaphoresAsync(ICompositionImportedGpuImage image, ICompositionImportedGpuSemaphore waitForSemaphore, ICompositionImportedGpuSemaphore signalSemaphore);
    public Task UpdateAsync(ICompositionImportedGpuImage image);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.CompositionDrawListVisual : CompositionContainerVisual {
    [CompilerGeneratedAttribute]
private Visual <Visual>k__BackingField;
    private bool _drawListChanged;
    [NullableAttribute("2")]
private CompositionRenderData _drawList;
    public Visual Visual { get; }
    [NullableAttribute("2")]
public CompositionRenderData DrawList { get; public set; }
    internal CompositionDrawListVisual(Compositor compositor, ServerCompositionDrawListVisual server, Visual visual);
    [CompilerGeneratedAttribute]
public Visual get_Visual();
    [NullableContextAttribute("2")]
public CompositionRenderData get_DrawList();
    [NullableContextAttribute("2")]
public void set_DrawList(CompositionRenderData value);
    private protected virtual void SerializeChangesCore(BatchStreamWriter writer);
    internal virtual bool HitTest(Point pt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.CompositionExperimentalAcrylicVisual : CompositionDrawListVisual {
    private CompositionExperimentalAcrylicVisualChangedFields _changedFieldsOfCompositionExperimentalAcrylicVisual;
    private ImmutableExperimentalAcrylicMaterial _material;
    private CornerRadius _cornerRadius;
    public ImmutableExperimentalAcrylicMaterial Material { get; public set; }
    public CornerRadius CornerRadius { get; public set; }
    internal CompositionExperimentalAcrylicVisual(Compositor compositor, Visual visual);
    public ImmutableExperimentalAcrylicMaterial get_Material();
    public void set_Material(ImmutableExperimentalAcrylicMaterial value);
    public CornerRadius get_CornerRadius();
    public void set_CornerRadius(CornerRadius value);
    private void InitializeDefaults();
    private protected virtual void SerializeChangesCore(BatchStreamWriter writer);
}
public enum Avalonia.Rendering.Composition.CompositionGetValueStatus : Enum {
    public int value__;
    public static CompositionGetValueStatus Succeeded;
    public static CompositionGetValueStatus TypeMismatch;
    public static CompositionGetValueStatus NotFound;
}
[FlagsAttribute]
public enum Avalonia.Rendering.Composition.CompositionGpuImportedImageSynchronizationCapabilities : Enum {
    public int value__;
    public static CompositionGpuImportedImageSynchronizationCapabilities Semaphores;
    public static CompositionGpuImportedImageSynchronizationCapabilities KeyedMutex;
    public static CompositionGpuImportedImageSynchronizationCapabilities Automatic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.Composition.CompositionGpuImportedObjectBase : object {
    [CompilerGeneratedAttribute]
private Compositor <Compositor>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlatformRenderInterfaceContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IExternalObjectsRenderInterfaceContextFeature <Feature>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <ImportCompleted>k__BackingField;
    protected Compositor Compositor { get; }
    public IPlatformRenderInterfaceContext Context { get; }
    public IExternalObjectsRenderInterfaceContextFeature Feature { get; }
    public Task ImportCompleted { get; }
    public Task ImportCompeted { get; }
    public bool IsLost { get; }
    public CompositionGpuImportedObjectBase(Compositor compositor, IPlatformRenderInterfaceContext context, IExternalObjectsRenderInterfaceContextFeature feature);
    [CompilerGeneratedAttribute]
protected Compositor get_Compositor();
    [CompilerGeneratedAttribute]
public IPlatformRenderInterfaceContext get_Context();
    [CompilerGeneratedAttribute]
public IExternalObjectsRenderInterfaceContextFeature get_Feature();
    protected abstract virtual void Import();
    public abstract virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual Task get_ImportCompleted();
    public sealed virtual Task get_ImportCompeted();
    public sealed virtual bool get_IsLost();
    public sealed virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
private void <DisposeAsync>b__19_0();
}
public enum Avalonia.Rendering.Composition.CompositionGradientExtendMode : Enum {
    public int value__;
    public static CompositionGradientExtendMode Clamp;
    public static CompositionGradientExtendMode Wrap;
    public static CompositionGradientExtendMode Mirror;
}
internal class Avalonia.Rendering.Composition.CompositionImportedGpuImage : CompositionGpuImportedObjectBase {
    [NullableAttribute("1")]
private Func`1<IPlatformRenderInterfaceImportedImage> _importer;
    [NullableAttribute("2")]
private IPlatformRenderInterfaceImportedImage _image;
    [NullableAttribute("1")]
public IPlatformRenderInterfaceImportedImage Image { get; }
    public bool IsUsable { get; }
    [NullableContextAttribute("1")]
public CompositionImportedGpuImage(Compositor compositor, IPlatformRenderInterfaceContext context, IExternalObjectsRenderInterfaceContextFeature feature, Func`1<IPlatformRenderInterfaceImportedImage> importer);
    protected virtual void Import();
    [NullableContextAttribute("1")]
public IPlatformRenderInterfaceImportedImage get_Image();
    public bool get_IsUsable();
    public virtual void Dispose();
}
internal class Avalonia.Rendering.Composition.CompositionImportedGpuSemaphore : CompositionGpuImportedObjectBase {
    [NullableAttribute("1")]
private IPlatformHandle _handle;
    [NullableAttribute("2")]
private IPlatformRenderInterfaceImportedSemaphore _semaphore;
    [NullableAttribute("1")]
public IPlatformRenderInterfaceImportedSemaphore Semaphore { get; }
    public bool IsUsable { get; }
    [NullableContextAttribute("1")]
public CompositionImportedGpuSemaphore(IPlatformHandle handle, Compositor compositor, IPlatformRenderInterfaceContext context, IExternalObjectsRenderInterfaceContextFeature feature);
    [NullableContextAttribute("1")]
public IPlatformRenderInterfaceImportedSemaphore get_Semaphore();
    public bool get_IsUsable();
    protected virtual void Import();
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.CompositionInterop : object {
    private Compositor _compositor;
    private IPlatformRenderInterfaceContext _context;
    private IExternalObjectsRenderInterfaceContextFeature _externalObjects;
    [CompilerGeneratedAttribute]
private bool <IsLost>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <DeviceLuid>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <DeviceUuid>k__BackingField;
    public IReadOnlyList`1<string> SupportedImageHandleTypes { get; }
    public IReadOnlyList`1<string> SupportedSemaphoreTypes { get; }
    public bool IsLost { get; }
    [NullableAttribute("2")]
public Byte[] DeviceLuid { get; public set; }
    [NullableAttribute("2")]
public Byte[] DeviceUuid { get; public set; }
    public CompositionInterop(Compositor compositor, IExternalObjectsRenderInterfaceContextFeature externalObjects);
    public sealed virtual IReadOnlyList`1<string> get_SupportedImageHandleTypes();
    public sealed virtual IReadOnlyList`1<string> get_SupportedSemaphoreTypes();
    public sealed virtual CompositionGpuImportedImageSynchronizationCapabilities GetSynchronizationCapabilities(string imageHandleType);
    public sealed virtual ICompositionImportedGpuImage ImportImage(IPlatformHandle handle, PlatformGraphicsExternalImageProperties properties);
    public sealed virtual ICompositionImportedGpuImage ImportImage(ICompositionImportableSharedGpuContextImage image);
    public sealed virtual ICompositionImportedGpuSemaphore ImportSemaphore(IPlatformHandle handle);
    public sealed virtual ICompositionImportedGpuImage ImportSemaphore(ICompositionImportableSharedGpuContextSemaphore image);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLost();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Byte[] get_DeviceLuid();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_DeviceLuid(Byte[] value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Byte[] get_DeviceUuid();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_DeviceUuid(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Rendering.Composition.CompositionObject : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ImplicitAnimationCollection <ImplicitAnimations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected InlineDictionary`2<CompositionProperty, IAnimationInstance> PendingAnimations;
    [CompilerGeneratedAttribute]
private Compositor <Compositor>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SimpleServerObject <Server>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private bool _registeredForSerialization;
    [NullableAttribute("2")]
public ImplicitAnimationCollection ImplicitAnimations { get; public set; }
    public Compositor Compositor { get; }
    [NullableAttribute("2")]
internal SimpleServerObject Server { get; }
    public bool IsDisposed { get; private set; }
    internal CompositionObject(Compositor compositor, SimpleServerObject server);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ImplicitAnimationCollection get_ImplicitAnimations();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ImplicitAnimations(ImplicitAnimationCollection value);
    [CompilerGeneratedAttribute]
public Compositor get_Compositor();
    private sealed virtual override SimpleServerObject Avalonia.Rendering.Composition.ICompositorSerializable.TryGetServer(Compositor c);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SimpleServerObject get_Server();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    private static SimpleServerObject ThrowInvalidOperation();
    protected internal void Dispose();
    public void StartAnimation(string propertyName, CompositionAnimation animation);
    internal virtual void StartAnimation(string propertyName, CompositionAnimation animation, Nullable`1<ExpressionVariant> finalValue);
    public void StartAnimationGroup(ICompositionAnimationBase grp);
    private bool StartAnimationGroupPart(CompositionAnimation animation, string target, ExpressionVariant finalValue);
    internal bool StartAnimationGroup(ICompositionAnimationBase grp, string target, ExpressionVariant finalValue);
    protected void RegisterForSerialization();
    private sealed virtual override void Avalonia.Rendering.Composition.ICompositorSerializable.SerializeChanges(Compositor c, BatchStreamWriter writer);
    private protected virtual void SerializeChangesCore(BatchStreamWriter writer);
}
public class Avalonia.Rendering.Composition.CompositionOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseRegionDirtyRectClipping>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseSaveLayerRootClip>k__BackingField;
    public Nullable`1<bool> UseRegionDirtyRectClipping { get; public set; }
    public Nullable`1<bool> UseSaveLayerRootClip { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseRegionDirtyRectClipping();
    [CompilerGeneratedAttribute]
public void set_UseRegionDirtyRectClipping(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseSaveLayerRootClip();
    [CompilerGeneratedAttribute]
public void set_UseSaveLayerRootClip(Nullable`1<bool> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.CompositionPropertySet : CompositionObject {
    private Dictionary`2<string, ExpressionVariant> _variants;
    private Dictionary`2<string, CompositionObject> _objects;
    internal CompositionPropertySet(Compositor compositor);
    internal void Set(string key, ExpressionVariant value);
    internal void Set(string key, CompositionObject obj);
    public void InsertColor(string propertyName, Color value);
    public void InsertMatrix3x2(string propertyName, Matrix3x2 value);
    public void InsertMatrix4x4(string propertyName, Matrix4x4 value);
    public void InsertQuaternion(string propertyName, Quaternion value);
    public void InsertScalar(string propertyName, float value);
    public void InsertVector2(string propertyName, Vector2 value);
    public void InsertVector3(string propertyName, Vector3 value);
    public void InsertVector4(string propertyName, Vector4 value);
    [NullableContextAttribute("0")]
private CompositionGetValueStatus TryGetVariant(string key, T& value);
    public CompositionGetValueStatus TryGetColor(string propertyName, Color& value);
    public CompositionGetValueStatus TryGetMatrix3x2(string propertyName, Matrix3x2& value);
    public CompositionGetValueStatus TryGetMatrix4x4(string propertyName, Matrix4x4& value);
    public CompositionGetValueStatus TryGetQuaternion(string propertyName, Quaternion& value);
    public CompositionGetValueStatus TryGetScalar(string propertyName, Single& value);
    public CompositionGetValueStatus TryGetVector2(string propertyName, Vector2& value);
    public CompositionGetValueStatus TryGetVector3(string propertyName, Vector3& value);
    public CompositionGetValueStatus TryGetVector4(string propertyName, Vector4& value);
    public void InsertBoolean(string propertyName, bool value);
    public CompositionGetValueStatus TryGetBoolean(string propertyName, Boolean& value);
    internal void ClearAll();
    internal void Clear(string key);
    internal PropertySetSnapshot Snapshot();
    private PropertySetSnapshot SnapshotCore(int allowedNestingLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.CompositionSolidColorVisual : CompositionContainerVisual {
    private CompositionSolidColorVisualChangedFields _changedFieldsOfCompositionSolidColorVisual;
    [CompilerGeneratedAttribute]
private ServerCompositionSolidColorVisual <Server>k__BackingField;
    private Color _color;
    internal ServerCompositionSolidColorVisual Server { get; }
    public Color Color { get; public set; }
    internal CompositionSolidColorVisual(Compositor compositor, ServerCompositionSolidColorVisual server);
    [CompilerGeneratedAttribute]
internal ServerCompositionSolidColorVisual get_Server();
    public Color get_Color();
    public void set_Color(Color value);
    private void InitializeDefaults();
    private protected virtual void SerializeChangesCore(BatchStreamWriter writer);
    internal virtual void StartAnimation(string propertyName, CompositionAnimation animation, Nullable`1<ExpressionVariant> finalValue);
}
public enum Avalonia.Rendering.Composition.CompositionStretch : Enum {
    public int value__;
    public static CompositionStretch None;
    public static CompositionStretch Fill;
}
public class Avalonia.Rendering.Composition.CompositionSurface : CompositionObject {
    [NullableContextAttribute("1")]
internal CompositionSurface(Compositor compositor, ServerObject server);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.CompositionSurfaceVisual : CompositionContainerVisual {
    private CompositionSurfaceVisualChangedFields _changedFieldsOfCompositionSurfaceVisual;
    [CompilerGeneratedAttribute]
private ServerCompositionSurfaceVisual <Server>k__BackingField;
    [NullableAttribute("2")]
private CompositionSurface _surface;
    internal ServerCompositionSurfaceVisual Server { get; }
    [NullableAttribute("2")]
public CompositionSurface Surface { get; public set; }
    internal CompositionSurfaceVisual(Compositor compositor, ServerCompositionSurfaceVisual server);
    [CompilerGeneratedAttribute]
internal ServerCompositionSurfaceVisual get_Server();
    [NullableContextAttribute("2")]
public CompositionSurface get_Surface();
    [NullableContextAttribute("2")]
public void set_Surface(CompositionSurface value);
    private void InitializeDefaults();
    private protected virtual void SerializeChangesCore(BatchStreamWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.CompositionTarget : CompositionObject {
    private CompositionTargetChangedFields _changedFieldsOfCompositionTarget;
    [CompilerGeneratedAttribute]
private ServerCompositionTarget <Server>k__BackingField;
    [NullableAttribute("2")]
private CompositionVisual _root;
    private bool _isEnabled;
    private RendererDebugOverlays _debugOverlays;
    private LayoutPassTiming _lastLayoutPassTiming;
    private double _scaling;
    private PixelSize _pixelSize;
    internal ServerCompositionTarget Server { get; }
    [NullableAttribute("2")]
public CompositionVisual Root { get; public set; }
    public bool IsEnabled { get; public set; }
    public RendererDebugOverlays DebugOverlays { get; public set; }
    internal LayoutPassTiming LastLayoutPassTiming { get; internal set; }
    public double Scaling { get; public set; }
    public PixelSize PixelSize { get; public set; }
    internal CompositionTarget(Compositor compositor, ServerCompositionTarget server);
    [NullableContextAttribute("2")]
public PooledList`1<CompositionVisual> TryHitTest(Point point, CompositionVisual root, Func`2<CompositionVisual, bool> filter);
    public Nullable`1<Point> TryTransformToVisual(CompositionVisual visual, Point point);
    private static bool TryGetInvertedTransform(CompositionVisual visual, Matrix& matrix);
    private static bool TryTransformTo(CompositionVisual visual, Point globalPoint, Point& v);
    private void HitTestCore(CompositionVisual visual, Point globalPoint, PooledList`1<CompositionVisual> result, Func`2<CompositionVisual, bool> filter);
    public void RequestRedraw();
    [CompilerGeneratedAttribute]
internal ServerCompositionTarget get_Server();
    [NullableContextAttribute("2")]
public CompositionVisual get_Root();
    [NullableContextAttribute("2")]
public void set_Root(CompositionVisual value);
    private void OnRootChanged();
    private void OnRootChanging();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public RendererDebugOverlays get_DebugOverlays();
    public void set_DebugOverlays(RendererDebugOverlays value);
    internal LayoutPassTiming get_LastLayoutPassTiming();
    internal void set_LastLayoutPassTiming(LayoutPassTiming value);
    public double get_Scaling();
    public void set_Scaling(double value);
    public PixelSize get_PixelSize();
    public void set_PixelSize(PixelSize value);
    private void InitializeDefaults();
    private protected virtual void SerializeChangesCore(BatchStreamWriter writer);
}
[FlagsAttribute]
public enum Avalonia.Rendering.Composition.CompositionTileMode : Enum {
    public int value__;
    public static CompositionTileMode None;
    public static CompositionTileMode TileX;
    public static CompositionTileMode TileY;
    public static CompositionTileMode FlipX;
    public static CompositionTileMode FlipY;
    public static CompositionTileMode Tile;
    public static CompositionTileMode Flip;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Avalonia.Rendering.Composition.CompositionVisual : CompositionObject {
    private IBrush _opacityMask;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    private CompositionVisualChangedFields _changedFieldsOfCompositionVisual;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ServerCompositionVisual <Server>k__BackingField;
    private CompositionTarget _root;
    private CompositionVisual _parent;
    private bool _visible;
    private float _opacity;
    private IGeometryImpl _clip;
    private bool _clipToBounds;
    private Vector3D _offset;
    private Vector _size;
    private Vector _anchorPoint;
    private Vector3D _centerPoint;
    private float _rotationAngle;
    private Quaternion _orientation;
    private Vector3D _scale;
    private Matrix _transformMatrix;
    private CompositionVisual _adornedVisual;
    private bool _adornerIsClipped;
    private IImmutableBrush _opacityMaskBrush;
    private IImmutableEffect _effect;
    private RenderOptions _renderOptions;
    public IBrush OpacityMask { get; public set; }
    internal object Tag { get; internal set; }
    [NullableAttribute("1")]
internal ServerCompositionVisual Server { get; }
    internal CompositionTarget Root { get; internal set; }
    internal CompositionVisual Parent { get; internal set; }
    public bool Visible { get; public set; }
    public float Opacity { get; public set; }
    internal IGeometryImpl Clip { get; internal set; }
    public bool ClipToBounds { get; public set; }
    public Vector3D Offset { get; public set; }
    public Vector Size { get; public set; }
    public Vector AnchorPoint { get; public set; }
    public Vector3D CenterPoint { get; public set; }
    public float RotationAngle { get; public set; }
    public Quaternion Orientation { get; public set; }
    public Vector3D Scale { get; public set; }
    internal Matrix TransformMatrix { get; internal set; }
    internal CompositionVisual AdornedVisual { get; internal set; }
    internal bool AdornerIsClipped { get; internal set; }
    internal IImmutableBrush OpacityMaskBrush { get; internal set; }
    internal IImmutableEffect Effect { get; internal set; }
    public RenderOptions RenderOptions { get; public set; }
    [NullableContextAttribute("1")]
internal CompositionVisual(Compositor compositor, ServerCompositionVisual server);
    private protected virtual void OnRootChangedCore();
    public IBrush get_OpacityMask();
    public void set_OpacityMask(IBrush value);
    internal Nullable`1<Matrix> TryGetServerGlobalTransform();
    [CompilerGeneratedAttribute]
internal object get_Tag();
    [CompilerGeneratedAttribute]
internal void set_Tag(object value);
    internal virtual bool HitTest(Point point);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal ServerCompositionVisual get_Server();
    internal CompositionTarget get_Root();
    internal void set_Root(CompositionTarget value);
    private void OnRootChanged();
    internal CompositionVisual get_Parent();
    internal void set_Parent(CompositionVisual value);
    private void OnParentChanged();
    public bool get_Visible();
    public void set_Visible(bool value);
    public float get_Opacity();
    public void set_Opacity(float value);
    internal IGeometryImpl get_Clip();
    internal void set_Clip(IGeometryImpl value);
    public bool get_ClipToBounds();
    public void set_ClipToBounds(bool value);
    public Vector3D get_Offset();
    public void set_Offset(Vector3D value);
    public Vector get_Size();
    public void set_Size(Vector value);
    public Vector get_AnchorPoint();
    public void set_AnchorPoint(Vector value);
    public Vector3D get_CenterPoint();
    public void set_CenterPoint(Vector3D value);
    public float get_RotationAngle();
    public void set_RotationAngle(float value);
    public Quaternion get_Orientation();
    public void set_Orientation(Quaternion value);
    public Vector3D get_Scale();
    public void set_Scale(Vector3D value);
    internal Matrix get_TransformMatrix();
    internal void set_TransformMatrix(Matrix value);
    internal CompositionVisual get_AdornedVisual();
    internal void set_AdornedVisual(CompositionVisual value);
    internal bool get_AdornerIsClipped();
    internal void set_AdornerIsClipped(bool value);
    internal IImmutableBrush get_OpacityMaskBrush();
    internal void set_OpacityMaskBrush(IImmutableBrush value);
    internal IImmutableEffect get_Effect();
    internal void set_Effect(IImmutableEffect value);
    public RenderOptions get_RenderOptions();
    public void set_RenderOptions(RenderOptions value);
    private void InitializeDefaults();
    [NullableContextAttribute("1")]
private protected virtual void SerializeChangesCore(BatchStreamWriter writer);
    [NullableContextAttribute("1")]
internal virtual void StartAnimation(string propertyName, CompositionAnimation animation, Nullable`1<ExpressionVariant> finalValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Rendering.Composition.CompositionVisualCollection : CompositionObject {
    private CompositionVisual _owner;
    private ServerListProxyHelper`2<CompositionVisual, ServerCompositionVisual> _list;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public CompositionVisual Item { get; public set; }
    internal CompositionVisualCollection(CompositionVisual parent, ServerCompositionVisualCollection server);
    public void InsertAbove(CompositionVisual newChild, CompositionVisual sibling);
    public void InsertBelow(CompositionVisual newChild, CompositionVisual sibling);
    public void InsertAtTop(CompositionVisual newChild);
    public void InsertAtBottom(CompositionVisual newChild);
    public void RemoveAll();
    private void InitializeDefaults();
    private sealed virtual override void Avalonia.Rendering.Composition.Transport.ServerListProxyHelper<Avalonia.Rendering.Composition.CompositionVisual,Avalonia.Rendering.Composition.Server.ServerCompositionVisual>.IRegisterForSerialization.RegisterForSerialization();
    public Enumerator<CompositionVisual> GetEnumerator();
    private sealed virtual override IEnumerator`1<CompositionVisual> System.Collections.Generic.IEnumerable<Avalonia.Rendering.Composition.CompositionVisual>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(CompositionVisual item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(CompositionVisual item);
    public sealed virtual void CopyTo(CompositionVisual[] array, int arrayIndex);
    public sealed virtual bool Remove(CompositionVisual item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(CompositionVisual item);
    public sealed virtual void Insert(int index, CompositionVisual item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual CompositionVisual get_Item(int index);
    public sealed virtual void set_Item(int index, CompositionVisual value);
    private void OnBeforeAdded(CompositionVisual item);
    private void OnAdded(CompositionVisual item);
    private void OnRemoved(CompositionVisual item);
    private void OnBeforeClear();
    private void OnBeforeReplace(CompositionVisual oldItem, CompositionVisual newItem);
    private void OnReplace(CompositionVisual oldItem, CompositionVisual newItem);
    private protected virtual void SerializeChangesCore(BatchStreamWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.Compositor : object {
    [CompilerGeneratedAttribute]
private IRenderLoop <Loop>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseUiThreadForSynchronousCommits>k__BackingField;
    private ServerCompositor _server;
    [NullableAttribute("2")]
private CompositionBatch _nextCommit;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BatchStreamObjectPool`1<object> _batchObjectPool;
    private BatchStreamMemoryPool _batchMemoryPool;
    private Queue`1<ICompositorSerializable> _objectSerializationQueue;
    private HashSet`1<ICompositorSerializable> _objectSerializationHashSet;
    private Queue`1<Action> _invokeBeforeCommitWrite;
    private Queue`1<Action> _invokeBeforeCommitRead;
    private HashSet`1<IDisposable> _disposeOnNextBatch;
    [NullableAttribute("2")]
private CompositionBatch _pendingBatch;
    private object _pendingBatchLock;
    private List`1<Action> _pendingServerCompositorJobs;
    private List`1<Action> _pendingServerCompositorPostTargetJobs;
    [NullableAttribute("2")]
private DiagnosticTextRenderer _diagnosticTextRenderer;
    private Action _triggerCommitRequested;
    [CompilerGeneratedAttribute]
private IEasing <DefaultEasing>k__BackingField;
    [CompilerGeneratedAttribute]
private Dispatcher <Dispatcher>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action AfterCommit;
    internal IRenderLoop Loop { get; }
    internal bool UseUiThreadForSynchronousCommits { get; }
    internal ServerCompositor Server { get; }
    internal IEasing DefaultEasing { get; }
    internal Dispatcher Dispatcher { get; }
    [NullableAttribute("2")]
private DiagnosticTextRenderer DiagnosticTextRenderer { get; }
    [NullableContextAttribute("2")]
[PrivateApiAttribute]
public Compositor(IPlatformGraphics gpu, bool useUiThreadForSynchronousCommits);
    internal Compositor(IRenderLoop loop, IPlatformGraphics gpu, bool useUiThreadForSynchronousCommits);
    internal Compositor(IRenderLoop loop, IPlatformGraphics gpu, bool useUiThreadForSynchronousCommits, ICompositorScheduler scheduler, bool reclaimBuffersImmediately, Dispatcher dispatcher, CompositionOptions options);
    [CompilerGeneratedAttribute]
internal IRenderLoop get_Loop();
    [CompilerGeneratedAttribute]
internal bool get_UseUiThreadForSynchronousCommits();
    internal ServerCompositor get_Server();
    [CompilerGeneratedAttribute]
internal IEasing get_DefaultEasing();
    [CompilerGeneratedAttribute]
internal Dispatcher get_Dispatcher();
    [NullableContextAttribute("2")]
private DiagnosticTextRenderer get_DiagnosticTextRenderer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void add_AfterCommit(Action value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void remove_AfterCommit(Action value);
    public Task RequestCommitAsync();
    public CompositionBatch RequestCompositionBatchCommitAsync();
    internal CompositionBatch Commit();
    private CompositionBatch CommitCore();
    internal void RegisterForSerialization(ICompositorSerializable compositionObject);
    internal void DisposeOnNextBatch(SimpleServerObject obj);
    public void RequestCompositionUpdate(Action action);
    internal void PostServerJob(Action job, bool postTarget);
    internal Task InvokeServerJobAsync(Action job, bool postTarget);
    internal Task`1<T> InvokeServerJobAsync(Func`1<T> job, bool postTarget);
    internal ValueTask`1<IReadOnlyDictionary`2<Type, object>> GetRenderInterfacePublicFeatures();
    [AsyncStateMachineAttribute("Avalonia.Rendering.Composition.Compositor/<TryGetRenderInterfaceFeature>d__48")]
public ValueTask`1<object> TryGetRenderInterfaceFeature(Type featureType);
    [AsyncStateMachineAttribute("Avalonia.Rendering.Composition.Compositor/<CreateCompositionVisualSnapshot>d__49")]
public Task`1<Bitmap> CreateCompositionVisualSnapshot(CompositionVisual visual, double scaling);
    [AsyncStateMachineAttribute("Avalonia.Rendering.Composition.Compositor/<TryGetCompositionGpuInterop>d__50")]
public ValueTask`1<ICompositionGpuInterop> TryGetCompositionGpuInterop();
    internal bool UnitTestIsRegisteredForSerialization(ICompositorSerializable serializable);
    [NullableContextAttribute("2")]
public static Compositor TryGetDefaultCompositor();
    internal CompositionTarget CreateCompositionTarget(Func`1<IEnumerable`1<object>> surfaces);
    public CompositionContainerVisual CreateContainerVisual();
    public ExpressionAnimation CreateExpressionAnimation();
    public ExpressionAnimation CreateExpressionAnimation(string expression);
    public ImplicitAnimationCollection CreateImplicitAnimationCollection();
    public CompositionAnimationGroup CreateAnimationGroup();
    public CompositionSolidColorVisual CreateSolidColorVisual();
    public CompositionCustomVisual CreateCustomVisual(CompositionCustomVisualHandler handler);
    public CompositionSurfaceVisual CreateSurfaceVisual();
    public CompositionDrawingSurface CreateDrawingSurface();
    public ScalarKeyFrameAnimation CreateScalarKeyFrameAnimation();
    public DoubleKeyFrameAnimation CreateDoubleKeyFrameAnimation();
    public BooleanKeyFrameAnimation CreateBooleanKeyFrameAnimation();
    public ColorKeyFrameAnimation CreateColorKeyFrameAnimation();
    public VectorKeyFrameAnimation CreateVectorKeyFrameAnimation();
    public Vector2KeyFrameAnimation CreateVector2KeyFrameAnimation();
    public Vector3KeyFrameAnimation CreateVector3KeyFrameAnimation();
    public Vector3DKeyFrameAnimation CreateVector3DKeyFrameAnimation();
    public Vector4KeyFrameAnimation CreateVector4KeyFrameAnimation();
    public QuaternionKeyFrameAnimation CreateQuaternionKeyFrameAnimation();
    [CompilerGeneratedAttribute]
private void <RequestCompositionBatchCommitAsync>b__38_0(Task _);
    [CompilerGeneratedAttribute]
internal static void <CommitCore>g__SerializeServerJobs|40_0(BatchStreamWriter writer, List`1<Action> list, object startMarker, object endMarker);
    [CompilerGeneratedAttribute]
private void <CommitCore>b__40_1(Task t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.DoubleKeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<double> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public DoubleKeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, double value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.CompositionRenderData : object {
    private Compositor _compositor;
    [CompilerGeneratedAttribute]
private ServerCompositionRenderData <Server>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledInlineList`1<ICompositionRenderResource> _resources;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledInlineList`1<IRenderDataItem> _items;
    private bool _itemsSent;
    public ServerCompositionRenderData Server { get; }
    public CompositionRenderData(Compositor compositor);
    [CompilerGeneratedAttribute]
public ServerCompositionRenderData get_Server();
    public void AddResource(ICompositionRenderResource resource);
    public void Add(IRenderDataItem item);
    public sealed virtual void Dispose();
    public sealed virtual SimpleServerObject TryGetServer(Compositor c);
    public sealed virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
    public bool HitTest(Point pt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.CompositionRenderDataSceneBrushContent : object {
    [CompilerGeneratedAttribute]
private ServerCompositionRenderData <RenderData>k__BackingField;
    private Nullable`1<Rect> _rect;
    [CompilerGeneratedAttribute]
private ITileBrush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseScalableRasterization>k__BackingField;
    public ServerCompositionRenderData RenderData { get; }
    public ITileBrush Brush { get; }
    public Rect Rect { get; }
    public double Opacity { get; }
    [NullableAttribute("2")]
public ITransform Transform { get; }
    public RelativePoint TransformOrigin { get; }
    public bool UseScalableRasterization { get; }
    public CompositionRenderDataSceneBrushContent(ITileBrush brush, Properties properties);
    [CompilerGeneratedAttribute]
public ServerCompositionRenderData get_RenderData();
    [CompilerGeneratedAttribute]
public sealed virtual ITileBrush get_Brush();
    public sealed virtual Rect get_Rect();
    public sealed virtual double get_Opacity();
    [NullableContextAttribute("2")]
public sealed virtual ITransform get_Transform();
    public sealed virtual RelativePoint get_TransformOrigin();
    public sealed virtual void Dispose();
    public sealed virtual void Render(IDrawingContextImpl context, Nullable`1<Matrix> transform);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseScalableRasterization();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.CompositorRefCountableResource`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RefCount>k__BackingField;
    public T Value { get; private set; }
    public int RefCount { get; private set; }
    public CompositorRefCountableResource`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    [CompilerGeneratedAttribute]
public int get_RefCount();
    [CompilerGeneratedAttribute]
private void set_RefCount(int value);
    private static void ThrowInvalidOperation();
    public void AddRef();
    public bool Release(Compositor c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.CompositorResourceHolder`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private InlineDictionary`2<Compositor, CompositorRefCountableResource`1<T>> _dictionary;
    public bool IsAttached { get; }
    public bool get_IsAttached();
    public bool CreateOrAddRef(Compositor compositor, ICompositorSerializable owner, T& resource, Func`2<Compositor, T> factory);
    public T TryGetForCompositor(Compositor compositor);
    public T GetForCompositor(Compositor compositor);
    [DoesNotReturnAttribute]
private static void ThrowDoesNotExist();
    public bool Release(Compositor compositor);
    public void ProcessPropertyChangeNotification(AvaloniaPropertyChangedEventArgs change);
    public void TransitiveReleaseAll(ICompositionRenderResource oldResource);
    public void TransitiveAddRefAll(ICompositionRenderResource newResource);
    public void RegisterForInvalidationOnAllCompositors(ICompositorSerializable serializable);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource {
    public abstract virtual void AddRefOnCompositor(Compositor c);
    public abstract virtual void ReleaseOnCompositor(Compositor c);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Drawing.ICompositionRenderResource`1 {
    public abstract virtual T GetForCompositor(Compositor c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.ImmediateRenderDataSceneBrushContent : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IRenderDataItem> _items;
    private ThreadSafeObjectPool`1<List`1<IRenderDataItem>> _pool;
    [CompilerGeneratedAttribute]
private ITileBrush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <Rect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseScalableRasterization>k__BackingField;
    public ITileBrush Brush { get; }
    public Rect Rect { get; }
    public double Opacity { get; }
    [NullableAttribute("2")]
public ITransform Transform { get; }
    public RelativePoint TransformOrigin { get; }
    public bool UseScalableRasterization { get; }
    public ImmediateRenderDataSceneBrushContent(ITileBrush brush, List`1<IRenderDataItem> items, Nullable`1<Rect> rect, bool useScalableRasterization, ThreadSafeObjectPool`1<List`1<IRenderDataItem>> pool);
    [CompilerGeneratedAttribute]
public sealed virtual ITileBrush get_Brush();
    [CompilerGeneratedAttribute]
public sealed virtual Rect get_Rect();
    public sealed virtual double get_Opacity();
    [NullableContextAttribute("2")]
public sealed virtual ITransform get_Transform();
    public sealed virtual RelativePoint get_TransformOrigin();
    public sealed virtual void Dispose();
    private void Render(IDrawingContextImpl context);
    public sealed virtual void Render(IDrawingContextImpl context, Nullable`1<Matrix> transform);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseScalableRasterization();
}
internal interface Avalonia.Rendering.Composition.Drawing.Nodes.IRenderDataItem {
    public Nullable`1<Rect> Bounds { get; }
    public abstract virtual void Invoke(RenderDataNodeRenderContext& context);
    public abstract virtual Nullable`1<Rect> get_Bounds();
    public abstract virtual bool HitTest(Point p);
}
internal interface Avalonia.Rendering.Composition.Drawing.Nodes.IRenderDataItemWithServerResources {
    [NullableContextAttribute("1")]
public abstract virtual void Collect(IRenderDataServerResourcesCollector collector);
}
[NullableContextAttribute("2")]
internal interface Avalonia.Rendering.Composition.Drawing.Nodes.IRenderDataServerResourcesCollector {
    public abstract virtual void AddRenderDataServerResource(object obj);
}
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataBitmapNode : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IRef`1<IBitmapImpl> <Bitmap>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Opacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <SourceRect>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <DestRect>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IRef`1<IBitmapImpl> Bitmap { get; public set; }
    public double Opacity { get; public set; }
    public Rect SourceRect { get; public set; }
    public Rect DestRect { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [CompilerGeneratedAttribute]
public IRef`1<IBitmapImpl> get_Bitmap();
    [CompilerGeneratedAttribute]
public void set_Bitmap(IRef`1<IBitmapImpl> value);
    [CompilerGeneratedAttribute]
public double get_Opacity();
    [CompilerGeneratedAttribute]
public void set_Opacity(double value);
    [CompilerGeneratedAttribute]
public Rect get_SourceRect();
    [CompilerGeneratedAttribute]
public void set_SourceRect(Rect value);
    [CompilerGeneratedAttribute]
public Rect get_DestRect();
    [CompilerGeneratedAttribute]
public void set_DestRect(Rect value);
    public sealed virtual bool HitTest(Point p);
    public sealed virtual void Invoke(RenderDataNodeRenderContext& context);
    public sealed virtual Nullable`1<Rect> get_Bounds();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataBrushAndPenNode : object {
    [CompilerGeneratedAttribute]
private IBrush <ServerBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private IPen <ServerPen>k__BackingField;
    [CompilerGeneratedAttribute]
private IPen <ClientPen>k__BackingField;
    public IBrush ServerBrush { get; public set; }
    public IPen ServerPen { get; public set; }
    public IPen ClientPen { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [CompilerGeneratedAttribute]
public IBrush get_ServerBrush();
    [CompilerGeneratedAttribute]
public void set_ServerBrush(IBrush value);
    [CompilerGeneratedAttribute]
public IPen get_ServerPen();
    [CompilerGeneratedAttribute]
public void set_ServerPen(IPen value);
    [CompilerGeneratedAttribute]
public IPen get_ClientPen();
    [CompilerGeneratedAttribute]
public void set_ClientPen(IPen value);
    [NullableContextAttribute("1")]
public sealed virtual void Collect(IRenderDataServerResourcesCollector collector);
    public abstract virtual void Invoke(RenderDataNodeRenderContext& context);
    public abstract virtual Nullable`1<Rect> get_Bounds();
    public abstract virtual bool HitTest(Point p);
}
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataClipNode : RenderDataPushNode {
    [CompilerGeneratedAttribute]
private RoundedRect <Rect>k__BackingField;
    public RoundedRect Rect { get; public set; }
    [CompilerGeneratedAttribute]
public RoundedRect get_Rect();
    [CompilerGeneratedAttribute]
public void set_Rect(RoundedRect value);
    public virtual void Push(RenderDataNodeRenderContext& context);
    public virtual void Pop(RenderDataNodeRenderContext& context);
    public virtual bool HitTest(Point p);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataCustomNode : object {
    [CompilerGeneratedAttribute]
private ICustomDrawOperation <Operation>k__BackingField;
    public ICustomDrawOperation Operation { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [CompilerGeneratedAttribute]
public ICustomDrawOperation get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(ICustomDrawOperation value);
    public sealed virtual bool HitTest(Point p);
    public sealed virtual void Invoke(RenderDataNodeRenderContext& context);
    public sealed virtual Nullable`1<Rect> get_Bounds();
    public sealed virtual void Dispose();
}
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataEllipseNode : RenderDataBrushAndPenNode {
    [CompilerGeneratedAttribute]
private Rect <Rect>k__BackingField;
    public Rect Rect { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [CompilerGeneratedAttribute]
public Rect get_Rect();
    [CompilerGeneratedAttribute]
public void set_Rect(Rect value);
    private bool Contains(double dx, double dy, double radiusX, double radiusY);
    public virtual bool HitTest(Point p);
    public virtual void Invoke(RenderDataNodeRenderContext& context);
    public virtual Nullable`1<Rect> get_Bounds();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataGeometryClipNode : RenderDataPushNode {
    [CompilerGeneratedAttribute]
private IGeometryImpl <Geometry>k__BackingField;
    public IGeometryImpl Geometry { get; public set; }
    [CompilerGeneratedAttribute]
public IGeometryImpl get_Geometry();
    [CompilerGeneratedAttribute]
public void set_Geometry(IGeometryImpl value);
    public bool Contains(Point p);
    public virtual void Push(RenderDataNodeRenderContext& context);
    public virtual void Pop(RenderDataNodeRenderContext& context);
    public virtual bool HitTest(Point p);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataGeometryNode : RenderDataBrushAndPenNode {
    [CompilerGeneratedAttribute]
private IGeometryImpl <Geometry>k__BackingField;
    public IGeometryImpl Geometry { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [CompilerGeneratedAttribute]
public IGeometryImpl get_Geometry();
    [CompilerGeneratedAttribute]
public void set_Geometry(IGeometryImpl value);
    public virtual bool HitTest(Point p);
    public virtual void Invoke(RenderDataNodeRenderContext& context);
    public virtual Nullable`1<Rect> get_Bounds();
}
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataGlyphRunNode : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IBrush <ServerBrush>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IRef`1<IGlyphRunImpl> <GlyphRun>k__BackingField;
    [NullableAttribute("2")]
public IBrush ServerBrush { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IRef`1<IGlyphRunImpl> GlyphRun { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IBrush get_ServerBrush();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ServerBrush(IBrush value);
    [CompilerGeneratedAttribute]
public IRef`1<IGlyphRunImpl> get_GlyphRun();
    [CompilerGeneratedAttribute]
public void set_GlyphRun(IRef`1<IGlyphRunImpl> value);
    public sealed virtual bool HitTest(Point p);
    public sealed virtual void Invoke(RenderDataNodeRenderContext& context);
    public sealed virtual Nullable`1<Rect> get_Bounds();
    [NullableContextAttribute("1")]
public sealed virtual void Collect(IRenderDataServerResourcesCollector collector);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataLineNode : object {
    [CompilerGeneratedAttribute]
private IPen <ServerPen>k__BackingField;
    [CompilerGeneratedAttribute]
private IPen <ClientPen>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <P1>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <P2>k__BackingField;
    public IPen ServerPen { get; public set; }
    public IPen ClientPen { get; public set; }
    public Point P1 { get; public set; }
    public Point P2 { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [CompilerGeneratedAttribute]
public IPen get_ServerPen();
    [CompilerGeneratedAttribute]
public void set_ServerPen(IPen value);
    [CompilerGeneratedAttribute]
public IPen get_ClientPen();
    [CompilerGeneratedAttribute]
public void set_ClientPen(IPen value);
    [CompilerGeneratedAttribute]
public Point get_P1();
    [CompilerGeneratedAttribute]
public void set_P1(Point value);
    [CompilerGeneratedAttribute]
public Point get_P2();
    [CompilerGeneratedAttribute]
public void set_P2(Point value);
    public sealed virtual bool HitTest(Point p);
    public sealed virtual void Invoke(RenderDataNodeRenderContext& context);
    public sealed virtual Nullable`1<Rect> get_Bounds();
    [NullableContextAttribute("1")]
public sealed virtual void Collect(IRenderDataServerResourcesCollector collector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataNodeRenderContext : ValueType {
    [NullableAttribute("2")]
private Stack`1<Matrix> _stack;
    private static ThreadSafeObjectPool`1<Stack`1<Matrix>> s_matrixStackPool;
    [CompilerGeneratedAttribute]
private IDrawingContextImpl <Context>k__BackingField;
    public IDrawingContextImpl Context { get; }
    public Stack`1<Matrix> MatrixStack { get; }
    public RenderDataNodeRenderContext(IDrawingContextImpl context);
    private static RenderDataNodeRenderContext();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IDrawingContextImpl get_Context();
    public Stack`1<Matrix> get_MatrixStack();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataOpacityMaskNode : RenderDataPushNode {
    [CompilerGeneratedAttribute]
private IBrush <ServerBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <BoundsRect>k__BackingField;
    public IBrush ServerBrush { get; public set; }
    public Rect BoundsRect { get; public set; }
    [CompilerGeneratedAttribute]
public IBrush get_ServerBrush();
    [CompilerGeneratedAttribute]
public void set_ServerBrush(IBrush value);
    [CompilerGeneratedAttribute]
public Rect get_BoundsRect();
    [CompilerGeneratedAttribute]
public void set_BoundsRect(Rect value);
    [NullableContextAttribute("1")]
public sealed virtual void Collect(IRenderDataServerResourcesCollector collector);
    public virtual void Push(RenderDataNodeRenderContext& context);
    public virtual void Pop(RenderDataNodeRenderContext& context);
}
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataOpacityNode : RenderDataPushNode {
    [CompilerGeneratedAttribute]
private double <Opacity>k__BackingField;
    public double Opacity { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Opacity();
    [CompilerGeneratedAttribute]
public void set_Opacity(double value);
    public virtual void Push(RenderDataNodeRenderContext& context);
    public virtual void Pop(RenderDataNodeRenderContext& context);
}
internal enum Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataPopNodeType : Enum {
    public int value__;
    public static RenderDataPopNodeType Transform;
    public static RenderDataPopNodeType Clip;
    public static RenderDataPopNodeType GeometryClip;
    public static RenderDataPopNodeType Opacity;
    public static RenderDataPopNodeType OpacityMask;
}
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataPushMatrixNode : RenderDataPushNode {
    [CompilerGeneratedAttribute]
private Matrix <Matrix>k__BackingField;
    public Matrix Matrix { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [CompilerGeneratedAttribute]
public Matrix get_Matrix();
    [CompilerGeneratedAttribute]
public void set_Matrix(Matrix value);
    public virtual void Push(RenderDataNodeRenderContext& context);
    public virtual void Pop(RenderDataNodeRenderContext& context);
    public virtual bool HitTest(Point p);
    public virtual Nullable`1<Rect> get_Bounds();
}
internal abstract class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataPushNode : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public PooledInlineList`1<IRenderDataItem> Children;
    public Nullable`1<Rect> Bounds { get; }
    public abstract virtual void Push(RenderDataNodeRenderContext& context);
    public abstract virtual void Pop(RenderDataNodeRenderContext& context);
    public sealed virtual void Invoke(RenderDataNodeRenderContext& context);
    public virtual Nullable`1<Rect> get_Bounds();
    public virtual bool HitTest(Point p);
    public sealed virtual void Dispose();
}
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataRectangleNode : RenderDataBrushAndPenNode {
    [CompilerGeneratedAttribute]
private RoundedRect <Rect>k__BackingField;
    [CompilerGeneratedAttribute]
private BoxShadows <BoxShadows>k__BackingField;
    public RoundedRect Rect { get; public set; }
    public BoxShadows BoxShadows { get; public set; }
    public Nullable`1<Rect> Bounds { get; }
    [CompilerGeneratedAttribute]
public RoundedRect get_Rect();
    [CompilerGeneratedAttribute]
public void set_Rect(RoundedRect value);
    [CompilerGeneratedAttribute]
public BoxShadows get_BoxShadows();
    [CompilerGeneratedAttribute]
public void set_BoxShadows(BoxShadows value);
    public virtual bool HitTest(Point p);
    public virtual void Invoke(RenderDataNodeRenderContext& context);
    public virtual Nullable`1<Rect> get_Bounds();
}
internal class Avalonia.Rendering.Composition.Drawing.Nodes.RenderDataRenderOptionsNode : RenderDataPushNode {
    [CompilerGeneratedAttribute]
private RenderOptions <RenderOptions>k__BackingField;
    public RenderOptions RenderOptions { get; public set; }
    [CompilerGeneratedAttribute]
public RenderOptions get_RenderOptions();
    [CompilerGeneratedAttribute]
public void set_RenderOptions(RenderOptions value);
    public virtual void Push(RenderDataNodeRenderContext& context);
    public virtual void Pop(RenderDataNodeRenderContext& context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.RenderDataDrawingContext : DrawingContext {
    private Compositor _compositor;
    private CompositionRenderData _renderData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<object> _resourcesHashSet;
    [NullableAttribute("1")]
private static ThreadSafeObjectPool`1<HashSet`1<object>> s_hashSetPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IRenderDataItem> _currentItemList;
    [NullableAttribute("1")]
private static ThreadSafeObjectPool`1<List`1<IRenderDataItem>> s_listPool;
    private Stack`1<ParentStackItem> _parentNodeStack;
    [NullableAttribute("1")]
private static ThreadSafeObjectPool`1<Stack`1<ParentStackItem>> s_parentStackPool;
    [NullableAttribute("1")]
private CompositionRenderData RenderData { get; }
    public RenderDataDrawingContext(Compositor compositor);
    private static RenderDataDrawingContext();
    [NullableContextAttribute("1")]
private CompositionRenderData get_RenderData();
    [NullableContextAttribute("1")]
private void Add(IRenderDataItem item);
    private void Push(RenderDataPushNode node);
    [NullableContextAttribute("0")]
private void Pop();
    private void AddResource(object resource);
    protected virtual void DrawLineCore(IPen pen, Point p1, Point p2);
    protected virtual void DrawGeometryCore(IBrush brush, IPen pen, IGeometryImpl geometry);
    protected virtual void DrawRectangleCore(IBrush brush, IPen pen, RoundedRect rrect, BoxShadows boxShadows);
    protected virtual void DrawEllipseCore(IBrush brush, IPen pen, Rect rect);
    [NullableContextAttribute("1")]
public virtual void Custom(ICustomDrawOperation custom);
    public virtual void DrawGlyphRun(IBrush foreground, GlyphRun glyphRun);
    protected virtual void PushClipCore(RoundedRect rect);
    protected virtual void PushClipCore(Rect rect);
    protected virtual void PushGeometryClipCore(Geometry clip);
    protected virtual void PushOpacityCore(double opacity);
    protected virtual void PushOpacityMaskCore(IBrush mask, Rect bounds);
    protected virtual void PushTransformCore(Matrix matrix);
    protected virtual void PushRenderOptionsCore(RenderOptions renderOptions);
    protected virtual void PopClipCore();
    protected virtual void PopGeometryClipCore();
    protected virtual void PopOpacityCore();
    protected virtual void PopOpacityMaskCore();
    protected virtual void PopTransformCore();
    protected virtual void PopRenderOptionsCore();
    internal virtual void DrawBitmap(IRef`1<IBitmapImpl> source, double opacity, Rect sourceRect, Rect destRect);
    private void FlushStack();
    public CompositionRenderData GetRenderResults();
    [NullableContextAttribute("1")]
public ImmediateRenderDataSceneBrushContent GetImmediateSceneBrushContent(ITileBrush brush, Nullable`1<Rect> rect, bool useScalableRasterization);
    public void Reset();
    protected virtual void DisposeCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Drawing.ServerCompositionRenderData : SimpleServerRenderResource {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledInlineList`1<IRenderDataItem> _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledInlineList`1<IServerRenderResource> _referencedResources;
    private Nullable`1<LtrbRect> _bounds;
    private bool _boundsValid;
    private static ThreadSafeObjectPool`1<Collector> s_resourceHashSetPool;
    public Nullable`1<LtrbRect> Bounds { get; }
    public ServerCompositionRenderData(ServerCompositor compositor);
    private static ServerCompositionRenderData();
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    private static void CollectResources(PooledInlineList`1<IRenderDataItem> items, IRenderDataServerResourcesCollector collector);
    public Nullable`1<LtrbRect> get_Bounds();
    private Nullable`1<LtrbRect> CalculateRenderBounds();
    public static Nullable`1<Rect> ApplyRenderBoundsRounding(Nullable`1<Rect> rect);
    public static Nullable`1<LtrbRect> ApplyRenderBoundsRounding(Nullable`1<LtrbRect> rect);
    public virtual void DependencyQueuedInvalidate(IServerRenderResource sender);
    public void Render(IDrawingContextImpl context);
    private void Reset();
    public virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Rendering.Composition.Drawing.ServerResourceHelperExtensions : object {
    [ExtensionAttribute]
public static IBrush GetServer(IBrush brush, Compositor compositor);
    [ExtensionAttribute]
public static IPen GetServer(IPen pen, Compositor compositor);
    [NullableContextAttribute("1")]
[DoesNotReturnAttribute]
private static void ThrowNotCompatible(object o);
    [ExtensionAttribute]
public static ITransform GetServer(ITransform transform, Compositor compositor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Rendering.Composition.ElementComposition : object {
    public static CompositionVisual GetElementVisual(Visual visual);
    public static void SetElementChildVisual(Visual visual, CompositionVisual compositionVisual);
    public static CompositionVisual GetElementChildVisual(Visual visual);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.BinaryExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionType <Type>k__BackingField;
    public Expression Left { get; }
    public Expression Right { get; }
    public ExpressionType Type { get; }
    public BinaryExpression(Expression left, Expression right, ExpressionType type);
    [CompilerGeneratedAttribute]
public Expression get_Left();
    [CompilerGeneratedAttribute]
public Expression get_Right();
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_Type();
    public virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    public virtual void CollectReferences(HashSet`1<ValueTuple`2<string, string>> references);
    protected virtual string Print();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.BuiltInExpressionFfi : object {
    private DelegateExpressionFfi _registry;
    [CompilerGeneratedAttribute]
private static BuiltInExpressionFfi <Instance>k__BackingField;
    public static BuiltInExpressionFfi Instance { get; }
    private static BuiltInExpressionFfi();
    private static float Lerp(float a, float b, float p);
    private static double Lerp(double a, double b, double p);
    private static Matrix3x2 Inverse(Matrix3x2 m);
    private static Matrix4x4 Inverse(Matrix4x4 m);
    private static float SmoothStep(float edge0, float edge1, float x);
    private static double SmoothStep(double edge0, double edge1, double x);
    private static Vector2 SmoothStep(Vector2 edge0, Vector2 edge1, Vector2 x);
    private static Vector SmoothStep(Vector edge0, Vector edge1, Vector x);
    private static Vector3 SmoothStep(Vector3 edge0, Vector3 edge1, Vector3 x);
    private static Vector3D SmoothStep(Vector3D edge0, Vector3D edge1, Vector3D x);
    private static Vector4 SmoothStep(Vector4 edge0, Vector4 edge1, Vector4 x);
    public sealed virtual bool Call(string name, IReadOnlyList`1<ExpressionVariant> arguments, ExpressionVariant& result);
    [CompilerGeneratedAttribute]
public static BuiltInExpressionFfi get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.ConditionalExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <TruePart>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <FalsePart>k__BackingField;
    public Expression Condition { get; }
    public Expression TruePart { get; }
    public Expression FalsePart { get; }
    public ExpressionType Type { get; }
    public ConditionalExpression(Expression condition, Expression truePart, Expression falsePart);
    [CompilerGeneratedAttribute]
public Expression get_Condition();
    [CompilerGeneratedAttribute]
public Expression get_TruePart();
    [CompilerGeneratedAttribute]
public Expression get_FalsePart();
    public virtual ExpressionType get_Type();
    public virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    public virtual void CollectReferences(HashSet`1<ValueTuple`2<string, string>> references);
    protected virtual string Print();
}
internal class Avalonia.Rendering.Composition.Expressions.ConstantExpression : Expression {
    [CompilerGeneratedAttribute]
private float <Constant>k__BackingField;
    public float Constant { get; }
    public ExpressionType Type { get; }
    public ConstantExpression(float constant);
    [CompilerGeneratedAttribute]
public float get_Constant();
    public virtual ExpressionType get_Type();
    public virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    [NullableContextAttribute("1")]
protected virtual string Print();
}
internal class Avalonia.Rendering.Composition.Expressions.DelegateExpressionFfi : object {
    [NullableAttribute("1")]
private Dictionary`2<string, Dictionary`2<int, List`1<FfiRecord>>> _registry;
    [NullableAttribute("1")]
private static Dictionary`2<Type, VariantType> TypeMap;
    private static DelegateExpressionFfi();
    [NullableContextAttribute("1")]
public sealed virtual bool Call(string name, IReadOnlyList`1<ExpressionVariant> arguments, ExpressionVariant& result);
    [NullableContextAttribute("1")]
private bool CallWithCast(List`1<FfiRecord> countGroup, IReadOnlyList`1<ExpressionVariant> arguments, ExpressionVariant& result, bool anyCast);
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
private void Add(string name, Func`2<IReadOnlyList`1<ExpressionVariant>, ExpressionVariant> cb, Type[] types);
    public void Add(string name, Func`2<T1, ExpressionVariant> cb);
    public void Add(string name, Func`3<T1, T2, ExpressionVariant> cb);
    public void Add(string name, Func`4<T1, T2, T3, ExpressionVariant> cb);
    public void Add(string name, Func`5<T1, T2, T3, T4, ExpressionVariant> cb);
    public void Add(string name, Func`6<T1, T2, T3, T4, T5, ExpressionVariant> cb);
    public void Add(string name, Func`7<T1, T2, T3, T4, T5, T6, ExpressionVariant> cb);
    public void Add(string name, Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, ExpressionVariant> cb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.Composition.Expressions.Expression : object {
    public ExpressionType Type { get; }
    public abstract virtual ExpressionType get_Type();
    public static Expression Parse(string expression);
    public abstract virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    public virtual void CollectReferences(HashSet`1<ValueTuple`2<string, string>> references);
    protected abstract virtual string Print();
    public virtual string ToString();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL3050")]
internal static string OperatorName(ExpressionType t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.ExpressionEvaluationContext : ValueType {
    [CompilerGeneratedAttribute]
private ExpressionVariant <StartingValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionVariant <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionVariant <FinalValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionObject <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionParameterCollection <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionForeignFunctionInterface <ForeignFunctionInterface>k__BackingField;
    public ExpressionVariant StartingValue { get; public set; }
    public ExpressionVariant CurrentValue { get; public set; }
    public ExpressionVariant FinalValue { get; public set; }
    public IExpressionObject Target { get; public set; }
    public IExpressionParameterCollection Parameters { get; public set; }
    public IExpressionForeignFunctionInterface ForeignFunctionInterface { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ExpressionVariant get_StartingValue();
    [CompilerGeneratedAttribute]
public void set_StartingValue(ExpressionVariant value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ExpressionVariant get_CurrentValue();
    [CompilerGeneratedAttribute]
public void set_CurrentValue(ExpressionVariant value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ExpressionVariant get_FinalValue();
    [CompilerGeneratedAttribute]
public void set_FinalValue(ExpressionVariant value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IExpressionObject get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(IExpressionObject value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IExpressionParameterCollection get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IExpressionParameterCollection value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IExpressionForeignFunctionInterface get_ForeignFunctionInterface();
    [CompilerGeneratedAttribute]
public void set_ForeignFunctionInterface(IExpressionForeignFunctionInterface value);
}
internal enum Avalonia.Rendering.Composition.Expressions.ExpressionKeyword : Enum {
    public int value__;
    public static ExpressionKeyword StartingValue;
    public static ExpressionKeyword CurrentValue;
    public static ExpressionKeyword FinalValue;
    public static ExpressionKeyword Target;
    public static ExpressionKeyword Pi;
    public static ExpressionKeyword True;
    public static ExpressionKeyword False;
}
internal class Avalonia.Rendering.Composition.Expressions.ExpressionParseException : Exception {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; }
    [NullableContextAttribute("1")]
public ExpressionParseException(string message, int position);
    [CompilerGeneratedAttribute]
public int get_Position();
}
internal class Avalonia.Rendering.Composition.Expressions.ExpressionParser : object {
    private static ReadOnlySpan`1<char> Dot { get; }
    public static Expression Parse(ReadOnlySpan`1<char> s);
    private static ReadOnlySpan`1<char> get_Dot();
    [NullableContextAttribute("1")]
private static bool TryParseAtomic(TokenParser& parser, Expression& expr);
    private static bool TryParseOperator(TokenParser& parser, ExpressionType& op);
    [NullableContextAttribute("1")]
private static Expression ParseTillTerminator(TokenParser& parser, string terminatorChars, bool throwOnTerminator, bool throwOnEnd, Nullable`1& token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.ExpressionTrackedObjects : object {
    private List`1<IExpressionObject> _list;
    private HashSet`1<IExpressionObject> _hashSet;
    public void Add(IExpressionObject obj, string member);
    public void Clear();
    private sealed virtual override IEnumerator`1<IExpressionObject> System.Collections.Generic.IEnumerable<Avalonia.Rendering.Composition.Expressions.IExpressionObject>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<IExpressionObject> GetEnumerator();
}
internal enum Avalonia.Rendering.Composition.Expressions.ExpressionType : Enum {
    public int value__;
    [PrettyPrintStringAttribute("+")]
public static ExpressionType Add;
    [PrettyPrintStringAttribute("-")]
public static ExpressionType Subtract;
    [PrettyPrintStringAttribute("/")]
public static ExpressionType Divide;
    [PrettyPrintStringAttribute("*")]
public static ExpressionType Multiply;
    [PrettyPrintStringAttribute(">")]
public static ExpressionType MoreThan;
    [PrettyPrintStringAttribute("<")]
public static ExpressionType LessThan;
    [PrettyPrintStringAttribute(">=")]
public static ExpressionType MoreThanOrEqual;
    [PrettyPrintStringAttribute("<=")]
public static ExpressionType LessThanOrEqual;
    [PrettyPrintStringAttribute("&&")]
public static ExpressionType LogicalAnd;
    [PrettyPrintStringAttribute("||")]
public static ExpressionType LogicalOr;
    [PrettyPrintStringAttribute("%")]
public static ExpressionType Remainder;
    [PrettyPrintStringAttribute("==")]
public static ExpressionType Equals;
    [PrettyPrintStringAttribute("!=")]
public static ExpressionType NotEquals;
    [PrettyPrintStringAttribute("!")]
public static ExpressionType Not;
    [PrettyPrintStringAttribute("-")]
public static ExpressionType UnaryMinus;
    public static ExpressionType MemberAccess;
    public static ExpressionType Parameter;
    public static ExpressionType FunctionCall;
    public static ExpressionType Keyword;
    public static ExpressionType Constant;
    public static ExpressionType ConditionalExpression;
}
internal class Avalonia.Rendering.Composition.Expressions.ExpressionVariant : ValueType {
    public VariantType Type;
    public bool Boolean;
    public float Scalar;
    public double Double;
    public Vector2 Vector2;
    public Vector3 Vector3;
    public Vector4 Vector4;
    public Vector Vector;
    public Vector3D Vector3D;
    public Matrix AvaloniaMatrix;
    public Matrix3x2 Matrix3x2;
    public Matrix4x4 Matrix4x4;
    public Quaternion Quaternion;
    public Color Color;
    [NullableContextAttribute("1")]
public ExpressionVariant GetProperty(string property);
    public static ExpressionVariant op_Implicit(bool value);
    public static ExpressionVariant op_Implicit(float scalar);
    public static ExpressionVariant op_Implicit(double d);
    public static ExpressionVariant op_Implicit(Vector2 value);
    public static ExpressionVariant op_Implicit(Vector value);
    public static ExpressionVariant op_Implicit(Vector3 value);
    public static ExpressionVariant op_Implicit(Vector3D value);
    public static ExpressionVariant op_Implicit(Vector4 value);
    public static ExpressionVariant op_Implicit(Matrix3x2 value);
    public static ExpressionVariant op_Implicit(Matrix value);
    public static ExpressionVariant op_Implicit(Matrix4x4 value);
    public static ExpressionVariant op_Implicit(Quaternion value);
    public static ExpressionVariant op_Implicit(Color value);
    public static ExpressionVariant op_Addition(ExpressionVariant left, ExpressionVariant right);
    public static ExpressionVariant op_Subtraction(ExpressionVariant left, ExpressionVariant right);
    public static ExpressionVariant op_UnaryNegation(ExpressionVariant left);
    public static ExpressionVariant op_Multiply(ExpressionVariant left, ExpressionVariant right);
    public static ExpressionVariant op_Division(ExpressionVariant left, ExpressionVariant right);
    public ExpressionVariant EqualsTo(ExpressionVariant right);
    public ExpressionVariant NotEqualsTo(ExpressionVariant right);
    public static ExpressionVariant op_LogicalNot(ExpressionVariant v);
    public static ExpressionVariant op_Modulus(ExpressionVariant left, ExpressionVariant right);
    public static ExpressionVariant op_LessThan(ExpressionVariant left, ExpressionVariant right);
    public static ExpressionVariant op_GreaterThan(ExpressionVariant left, ExpressionVariant right);
    public ExpressionVariant And(ExpressionVariant right);
    public ExpressionVariant Or(ExpressionVariant right);
    public bool TryCast(T& res);
    public static ExpressionVariant Create(T v);
    public T CastOrDefault();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.FunctionCallExpression : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <Parameters>k__BackingField;
    public string Name { get; }
    public List`1<Expression> Parameters { get; }
    public ExpressionType Type { get; }
    public FunctionCallExpression(string name, List`1<Expression> parameters);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_Parameters();
    public virtual ExpressionType get_Type();
    public virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    public virtual void CollectReferences(HashSet`1<ValueTuple`2<string, string>> references);
    protected virtual string Print();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Expressions.IExpressionForeignFunctionInterface {
    public abstract virtual bool Call(string name, IReadOnlyList`1<ExpressionVariant> arguments, ExpressionVariant& result);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Expressions.IExpressionObject {
    public abstract virtual ExpressionVariant GetProperty(string name);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Expressions.IExpressionParameterCollection {
    public abstract virtual ExpressionVariant GetParameter(string name);
    public abstract virtual IExpressionObject GetObjectParameter(string name);
}
internal class Avalonia.Rendering.Composition.Expressions.KeywordExpression : Expression {
    [CompilerGeneratedAttribute]
private ExpressionKeyword <Keyword>k__BackingField;
    public ExpressionType Type { get; }
    public ExpressionKeyword Keyword { get; }
    public KeywordExpression(ExpressionKeyword keyword);
    public virtual ExpressionType get_Type();
    [CompilerGeneratedAttribute]
public ExpressionKeyword get_Keyword();
    public virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    [NullableContextAttribute("1")]
protected virtual string Print();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.MemberAccessExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Member>k__BackingField;
    public ExpressionType Type { get; }
    public Expression Target { get; }
    public string Member { get; }
    public MemberAccessExpression(Expression target, string member);
    public virtual ExpressionType get_Type();
    [CompilerGeneratedAttribute]
public Expression get_Target();
    [CompilerGeneratedAttribute]
public string get_Member();
    public virtual void CollectReferences(HashSet`1<ValueTuple`2<string, string>> references);
    public virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    protected virtual string Print();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.ParameterExpression : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public ExpressionType Type { get; }
    public ParameterExpression(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual ExpressionType get_Type();
    public virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    protected virtual string Print();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
internal class Avalonia.Rendering.Composition.Expressions.PrettyPrintStringAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public PrettyPrintStringAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class Avalonia.Rendering.Composition.Expressions.TokenParser : ValueType {
    private ReadOnlySpan`1<char> _s;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; private set; }
    public int Length { get; }
    public TokenParser(ReadOnlySpan`1<char> s);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public void SkipWhitespace();
    public bool NextIsWhitespace();
    private static bool IsAlphaNumeric(char ch);
    public bool TryConsume(char c);
    [NullableContextAttribute("1")]
public bool TryConsume(string s);
    public bool TryConsumeAny(ReadOnlySpan`1<char> chars, Char& token);
    [NullableContextAttribute("1")]
public bool TryParseKeyword(string keyword);
    [NullableContextAttribute("1")]
public bool TryParseKeywordLowerCase(string keywordInLowerCase);
    public void Advance(int c);
    public int get_Length();
    public bool TryParseIdentifier(ReadOnlySpan`1<char> extraValidChars, ReadOnlySpan`1& res);
    public bool TryParseIdentifier(ReadOnlySpan`1& res);
    public bool TryParseCall(ReadOnlySpan`1& res);
    public bool TryParseFloat(Single& res);
    public bool TryParseDouble(Double& res);
    public bool IsEofWithWhitespace();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Expressions.UnaryExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionType <Type>k__BackingField;
    public Expression Parameter { get; }
    public ExpressionType Type { get; }
    public UnaryExpression(Expression parameter, ExpressionType type);
    [CompilerGeneratedAttribute]
public Expression get_Parameter();
    [CompilerGeneratedAttribute]
public virtual ExpressionType get_Type();
    public virtual ExpressionVariant Evaluate(ExpressionEvaluationContext& context);
    public virtual void CollectReferences(HashSet`1<ValueTuple`2<string, string>> references);
    protected virtual string Print();
}
internal enum Avalonia.Rendering.Composition.Expressions.VariantType : Enum {
    public int value__;
    public static VariantType Invalid;
    public static VariantType Boolean;
    public static VariantType Scalar;
    public static VariantType Double;
    public static VariantType Vector2;
    public static VariantType Vector3;
    public static VariantType Vector4;
    public static VariantType Vector;
    public static VariantType Vector3D;
    public static VariantType AvaloniaMatrix;
    public static VariantType Matrix3x2;
    public static VariantType Matrix4x4;
    public static VariantType Quaternion;
    public static VariantType Color;
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Rendering.Composition.ICompositionGpuImportedObject {
    public Task ImportCompleted { get; }
    [ObsoleteAttribute("Please use ICompositionGpuImportedObject.ImportCompleted instead")]
[EditorBrowsableAttribute("1")]
public Task ImportCompeted { get; }
    public bool IsLost { get; }
    public abstract virtual Task get_ImportCompleted();
    public abstract virtual Task get_ImportCompeted();
    public abstract virtual bool get_IsLost();
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Rendering.Composition.ICompositionGpuInterop {
    public IReadOnlyList`1<string> SupportedImageHandleTypes { get; }
    public IReadOnlyList`1<string> SupportedSemaphoreTypes { get; }
    public bool IsLost { get; }
    [NullableAttribute("2")]
public Byte[] DeviceLuid { get; public set; }
    [NullableAttribute("2")]
public Byte[] DeviceUuid { get; public set; }
    public abstract virtual IReadOnlyList`1<string> get_SupportedImageHandleTypes();
    public abstract virtual IReadOnlyList`1<string> get_SupportedSemaphoreTypes();
    public abstract virtual CompositionGpuImportedImageSynchronizationCapabilities GetSynchronizationCapabilities(string imageHandleType);
    public abstract virtual ICompositionImportedGpuImage ImportImage(IPlatformHandle handle, PlatformGraphicsExternalImageProperties properties);
    public abstract virtual ICompositionImportedGpuImage ImportImage(ICompositionImportableSharedGpuContextImage image);
    public abstract virtual ICompositionImportedGpuSemaphore ImportSemaphore(IPlatformHandle handle);
    public abstract virtual ICompositionImportedGpuImage ImportSemaphore(ICompositionImportableSharedGpuContextSemaphore image);
    public abstract virtual bool get_IsLost();
    [NullableContextAttribute("2")]
public abstract virtual Byte[] get_DeviceLuid();
    [NullableContextAttribute("2")]
public abstract virtual void set_DeviceLuid(Byte[] value);
    [NullableContextAttribute("2")]
public abstract virtual Byte[] get_DeviceUuid();
    [NullableContextAttribute("2")]
public abstract virtual void set_DeviceUuid(Byte[] value);
}
[NotClientImplementableAttribute]
public interface Avalonia.Rendering.Composition.ICompositionImportableSharedGpuContextImage {
}
[NotClientImplementableAttribute]
public interface Avalonia.Rendering.Composition.ICompositionImportableSharedGpuContextObject {
}
[NotClientImplementableAttribute]
public interface Avalonia.Rendering.Composition.ICompositionImportableSharedGpuContextSemaphore {
}
[NotClientImplementableAttribute]
public interface Avalonia.Rendering.Composition.ICompositionImportedGpuImage {
}
[NotClientImplementableAttribute]
public interface Avalonia.Rendering.Composition.ICompositionImportedGpuSemaphore {
}
internal interface Avalonia.Rendering.Composition.ICompositionTargetDebugEvents {
    public int RenderedVisuals { get; }
    public abstract virtual int get_RenderedVisuals();
    public abstract virtual void IncrementRenderedVisuals();
    public abstract virtual void RectInvalidated(Rect rc);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.ICompositorScheduler {
    public abstract virtual void CommitRequested(Compositor compositor);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.ICompositorSerializable {
    public abstract virtual SimpleServerObject TryGetServer(Compositor c);
    public abstract virtual void SerializeChanges(Compositor c, BatchStreamWriter writer);
}
internal static class Avalonia.Rendering.Composition.MatrixUtils : object {
    public static Matrix ComputeTransform(Vector size, Vector anchorPoint, Vector3D centerPoint, Matrix transformMatrix, Vector3D scale, float rotationAngle, Quaternion orientation, Vector3D offset);
    public static Matrix4x4 ToMatrix4x4(Matrix matrix);
    public static Matrix ToMatrix(Matrix4x4 matrix44);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.QuaternionKeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<Quaternion> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public QuaternionKeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, Quaternion value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, Quaternion value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.ScalarKeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<float> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public ScalarKeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, float value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, float value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.CompositionProperty : object {
    private static int s_nextId;
    private static object _lock;
    private static Dictionary`2<Type, List`1<CompositionProperty>> s_dynamicRegistry;
    [NullableAttribute("2")]
private static ReadOnlyRegistry modreq(System.Runtime.CompilerServices.IsVolatile) s_ReadOnlyRegistry;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Owner>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<SimpleServerObject, ExpressionVariant> <GetVariant>k__BackingField;
    public int Id { get; }
    public string Name { get; }
    public Type Owner { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<SimpleServerObject, ExpressionVariant> GetVariant { get; }
    public CompositionProperty(int id, string name, Type owner, Func`2<SimpleServerObject, ExpressionVariant> getVariant);
    private static CompositionProperty();
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Type get_Owner();
    [CompilerGeneratedAttribute]
public Func`2<SimpleServerObject, ExpressionVariant> get_GetVariant();
    public static CompositionProperty`1<TField> Register(string name, Func`2<SimpleServerObject, TField> getField, Action`2<SimpleServerObject, TField> setField, Func`2<SimpleServerObject, ExpressionVariant> getVariant);
    private static void PopulatePropertiesForType(Type type, List`1<CompositionProperty> l);
    private static ReadOnlyRegistry Build();
    public static IReadOnlyDictionary`2<string, CompositionProperty> TryGetPropertiesForType(Type t);
    public static CompositionProperty Find(Type owner, string name);
    private static ReadOnlyRegistry GetRegistry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.CompositionProperty`1 : CompositionProperty {
    [CompilerGeneratedAttribute]
private Func`2<SimpleServerObject, T> <GetField>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<SimpleServerObject, T> <SetField>k__BackingField;
    public Func`2<SimpleServerObject, T> GetField { get; }
    public Action`2<SimpleServerObject, T> SetField { get; }
    public CompositionProperty`1(int id, string name, Type owner, Func`2<SimpleServerObject, T> getField, Action`2<SimpleServerObject, T> setField, Func`2<SimpleServerObject, ExpressionVariant> getVariant);
    [CompilerGeneratedAttribute]
public Func`2<SimpleServerObject, T> get_GetField();
    [CompilerGeneratedAttribute]
public Action`2<SimpleServerObject, T> get_SetField();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.CompositionTargetOverlays : object {
    private FpsCounter _fpsCounter;
    private FrameTimeGraph _renderTimeGraph;
    private FrameTimeGraph _updateTimeGraph;
    private FrameTimeGraph _layoutTimeGraph;
    private Nullable`1<Rect> _oldFpsCounterRect;
    private long _updateStarted;
    [NullableAttribute("1")]
private ServerCompositionTarget _target;
    private DiagnosticTextRenderer _diagnosticTextRenderer;
    [CompilerGeneratedAttribute]
private RendererDebugOverlays <DebugOverlays>k__BackingField;
    private RendererDebugOverlays DebugOverlays { get; private set; }
    private FpsCounter FpsCounter { get; }
    private FrameTimeGraph LayoutTimeGraph { get; }
    private FrameTimeGraph RenderTimeGraph { get; }
    private FrameTimeGraph UpdateTimeGraph { get; }
    public bool RequireLayer { get; }
    private bool CaptureTiming { get; }
    [NullableContextAttribute("1")]
public CompositionTargetOverlays(ServerCompositionTarget target, DiagnosticTextRenderer diagnosticTextRenderer);
    [CompilerGeneratedAttribute]
private RendererDebugOverlays get_DebugOverlays();
    [CompilerGeneratedAttribute]
private void set_DebugOverlays(RendererDebugOverlays value);
    private FpsCounter get_FpsCounter();
    private FrameTimeGraph get_LayoutTimeGraph();
    private FrameTimeGraph get_RenderTimeGraph();
    private FrameTimeGraph get_UpdateTimeGraph();
    public bool get_RequireLayer();
    [NullableContextAttribute("1")]
private FrameTimeGraph CreateTimeGraph(string title);
    public void OnChanged(RendererDebugOverlays debugOverlays);
    private bool get_CaptureTiming();
    [NullableContextAttribute("1")]
public void Draw(IDrawingContextImpl targetContext, bool hasLayer);
    public void MarkUpdateCallStart();
    public void MarkUpdateCallEnd();
    [NullableContextAttribute("1")]
private void DrawOverlays(ImmediateDrawingContext targetContext, bool hasLayer, Size logicalSize);
    public void OnLastLayoutPassTimingChanged(LayoutPassTiming lastLayoutPassTiming);
    [CompilerGeneratedAttribute]
internal static void <DrawOverlays>g__DrawTimeGraph|30_0(FrameTimeGraph graph, <>c__DisplayClass30_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.CompositorDrawingContextProxy : object {
    private IDrawingContextImpl _impl;
    [CompilerGeneratedAttribute]
private Nullable`1<Matrix> <PostTransform>k__BackingField;
    private Matrix _transform;
    private PooledList`1<PendingCommand> _commands;
    private bool _autoFlush;
    public Nullable`1<Matrix> PostTransform { get; public set; }
    public Matrix Transform { get; public set; }
    public bool AutoFlush { get; public set; }
    public CompositorDrawingContextProxy(IDrawingContextImpl impl);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public Nullable`1<Matrix> get_PostTransform();
    [CompilerGeneratedAttribute]
public void set_PostTransform(Nullable`1<Matrix> value);
    public sealed virtual Matrix get_Transform();
    public sealed virtual void set_Transform(Matrix value);
    private void SetImplTransform(Matrix m);
    public sealed virtual void Clear(Color color);
    public sealed virtual void DrawBitmap(IBitmapImpl source, double opacity, Rect sourceRect, Rect destRect);
    public sealed virtual void DrawBitmap(IBitmapImpl source, IBrush opacityMask, Rect opacityMaskRect, Rect destRect);
    [NullableContextAttribute("2")]
public sealed virtual void DrawLine(IPen pen, Point p1, Point p2);
    [NullableContextAttribute("2")]
public sealed virtual void DrawGeometry(IBrush brush, IPen pen, IGeometryImpl geometry);
    [NullableContextAttribute("2")]
public sealed virtual void DrawRectangle(IBrush brush, IPen pen, RoundedRect rect, BoxShadows boxShadows);
    [NullableContextAttribute("2")]
public sealed virtual void DrawRegion(IBrush brush, IPen pen, IPlatformRenderInterfaceRegion region);
    [NullableContextAttribute("2")]
public sealed virtual void DrawEllipse(IBrush brush, IPen pen, Rect rect);
    public sealed virtual void DrawGlyphRun(IBrush foreground, IGlyphRunImpl glyphRun);
    public sealed virtual IDrawingContextLayerImpl CreateLayer(PixelSize size);
    public sealed virtual void PushClip(Rect clip);
    public sealed virtual void PushClip(RoundedRect clip);
    public sealed virtual void PushClip(IPlatformRenderInterfaceRegion region);
    public sealed virtual void PopClip();
    public sealed virtual void PushLayer(Rect bounds);
    public sealed virtual void PopLayer();
    public sealed virtual void PushOpacity(double opacity, Nullable`1<Rect> bounds);
    public sealed virtual void PopOpacity();
    public sealed virtual void PushOpacityMask(IBrush mask, Rect bounds);
    public sealed virtual void PopOpacityMask();
    public sealed virtual void PushGeometryClip(IGeometryImpl clip);
    public sealed virtual void PopGeometryClip();
    public sealed virtual void PushRenderOptions(RenderOptions renderOptions);
    public sealed virtual void PopRenderOptions();
    public sealed virtual object GetFeature(Type t);
    public sealed virtual void DrawRectangle(IExperimentalAcrylicMaterial material, RoundedRect rect);
    public sealed virtual void PushEffect(IEffect effect);
    public sealed virtual void PopEffect();
    public bool get_AutoFlush();
    public void set_AutoFlush(bool value);
    public void SetTransform(Matrix m);
    private bool TryDiscard(PendingCommandType type);
    private void AddCommand(PendingCommand command);
    private void ExecCommand(PendingCommand& cmd);
    public void Flush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.DiagnosticTextRenderer : object {
    private static char FirstChar;
    private static char LastChar;
    private GlyphRun[] _runs;
    public DiagnosticTextRenderer(IGlyphTypeface typeface, double fontRenderingEmSize);
    public double GetMaxHeight();
    [NullableContextAttribute("0")]
public Size MeasureAsciiText(ReadOnlySpan`1<char> text);
    public void DrawAsciiText(ImmediateDrawingContext context, ReadOnlySpan`1<char> text, IImmutableBrush foreground);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.DirtyRectTracker : object {
    private LtrbPixelRect _rect;
    private Rect _doubleRect;
    private LtrbRect _normalRect;
    private LtrbPixelRect[] _rectsForApi;
    private Random _random;
    public bool IsEmpty { get; }
    public LtrbPixelRect CombinedRect { get; }
    public IList`1<LtrbPixelRect> Rects { get; }
    public sealed virtual void AddRect(LtrbPixelRect rect);
    public sealed virtual IDisposable BeginDraw(IDrawingContextImpl ctx);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool Intersects(LtrbRect rect);
    public sealed virtual bool Contains(Point pt);
    public sealed virtual void Reset();
    public sealed virtual void Visualize(IDrawingContextImpl context);
    public sealed virtual LtrbPixelRect get_CombinedRect();
    public sealed virtual IList`1<LtrbPixelRect> get_Rects();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.FpsCounter : object {
    private Stopwatch _stopwatch;
    private DiagnosticTextRenderer _textRenderer;
    private int _framesThisSecond;
    private int _totalFrames;
    private int _fps;
    private TimeSpan _lastFpsUpdate;
    public FpsCounter(DiagnosticTextRenderer textRenderer);
    public void FpsTick();
    public Nullable`1<Rect> RenderFps(ImmediateDrawingContext context, string aux, bool hasLayer, Nullable`1<Rect> oldRect);
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.FrameTimeGraph : object {
    private static double HeaderPadding;
    private IPlatformRenderInterface _renderInterface;
    private ImmutableSolidColorBrush _borderBrush;
    private ImmutablePen _graphPen;
    private Double[] _frameValues;
    private Size _size;
    private Size _headerSize;
    private Size _graphSize;
    private double _defaultMaxY;
    private string _title;
    private DiagnosticTextRenderer _textRenderer;
    private int _startFrameIndex;
    private int _frameCount;
    public Size Size { get; }
    public FrameTimeGraph(int maxFrames, Size size, double defaultMaxY, string title, DiagnosticTextRenderer textRenderer);
    public Size get_Size();
    public void AddFrameValue(double value);
    public void Reset();
    public void Render(ImmediateDrawingContext context);
    private void DrawLabelledValue(ImmediateDrawingContext context, string label, double value, double left);
    private IStreamGeometryImpl BuildGraphGeometry(double maxY);
    [NullableContextAttribute("0")]
private ValueTuple`3<double, double, double> GetYValues();
    private double GetFrameValue(int frameOffset);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Server.IDirtyRectTracker {
    public bool IsEmpty { get; }
    public LtrbPixelRect CombinedRect { get; }
    public IList`1<LtrbPixelRect> Rects { get; }
    public abstract virtual void AddRect(LtrbPixelRect rect);
    public abstract virtual IDisposable BeginDraw(IDrawingContextImpl ctx);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool Intersects(LtrbRect rect);
    public abstract virtual bool Contains(Point pt);
    public abstract virtual void Reset();
    public abstract virtual void Visualize(IDrawingContextImpl context);
    public abstract virtual LtrbPixelRect get_CombinedRect();
    public abstract virtual IList`1<LtrbPixelRect> get_Rects();
}
internal interface Avalonia.Rendering.Composition.Server.IServerClockItem {
    public abstract virtual void OnTick();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Server.IServerRenderResource {
    public abstract virtual void AddObserver(IServerRenderResourceObserver observer);
    public abstract virtual void RemoveObserver(IServerRenderResourceObserver observer);
    public abstract virtual void QueuedInvalidate();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Rendering.Composition.Server.IServerRenderResourceObserver {
    public abstract virtual void DependencyQueuedInvalidate(IServerRenderResource sender);
}
internal class Avalonia.Rendering.Composition.Server.ReadbackIndices : object {
    [NullableAttribute("1")]
private object _lock;
    [CompilerGeneratedAttribute]
private int <ReadIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WriteIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WrittenIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ReadRevision>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LastWrittenRevision>k__BackingField;
    public int ReadIndex { get; private set; }
    public int WriteIndex { get; private set; }
    public int WrittenIndex { get; private set; }
    public ulong ReadRevision { get; private set; }
    public ulong LastWrittenRevision { get; private set; }
    [CompilerGeneratedAttribute]
public int get_ReadIndex();
    [CompilerGeneratedAttribute]
private void set_ReadIndex(int value);
    [CompilerGeneratedAttribute]
public int get_WriteIndex();
    [CompilerGeneratedAttribute]
private void set_WriteIndex(int value);
    [CompilerGeneratedAttribute]
public int get_WrittenIndex();
    [CompilerGeneratedAttribute]
private void set_WrittenIndex(int value);
    [CompilerGeneratedAttribute]
public ulong get_ReadRevision();
    [CompilerGeneratedAttribute]
private void set_ReadRevision(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_LastWrittenRevision();
    [CompilerGeneratedAttribute]
private void set_LastWrittenRevision(ulong value);
    public void NextRead();
    public void CompleteWrite(ulong writtenRevision);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.RegionDirtyRectTracker : object {
    private IPlatformRenderInterfaceRegion _region;
    private Random _random;
    public bool IsEmpty { get; }
    public LtrbPixelRect CombinedRect { get; }
    public IList`1<LtrbPixelRect> Rects { get; }
    public RegionDirtyRectTracker(IPlatformRenderInterface platformRender);
    public sealed virtual void AddRect(LtrbPixelRect rect);
    public sealed virtual IDisposable BeginDraw(IDrawingContextImpl ctx);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool Intersects(LtrbRect rect);
    public sealed virtual bool Contains(Point pt);
    public sealed virtual void Reset();
    public sealed virtual void Visualize(IDrawingContextImpl context);
    public sealed virtual LtrbPixelRect get_CombinedRect();
    public sealed virtual IList`1<LtrbPixelRect> get_Rects();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionContainerVisual : ServerCompositionVisual {
    [CompilerGeneratedAttribute]
private ServerCompositionVisualCollection <Children>k__BackingField;
    private Nullable`1<LtrbRect> _transformedContentBounds;
    [NullableAttribute("2")]
private IImmutableEffect _oldEffect;
    public ServerCompositionVisualCollection Children { get; private set; }
    internal ServerCompositionContainerVisual(ServerCompositor compositor);
    [CompilerGeneratedAttribute]
public ServerCompositionVisualCollection get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(ServerCompositionVisualCollection value);
    protected virtual void RenderCore(ServerVisualRenderContext context, LtrbRect currentTransformedClip);
    public virtual UpdateResult Update(ServerCompositionTarget root, Matrix parentCombinedTransform);
    private void AddEffectPaddedDirtyRect(IImmutableEffect effect, LtrbRect transformedBounds);
    private void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionCustomVisual : ServerCompositionContainerVisual {
    private CompositionCustomVisualHandler _handler;
    private bool _wantsNextAnimationFrameAfterTick;
    public LtrbRect OwnContentBounds { get; }
    internal ServerCompositionCustomVisual(ServerCompositor compositor, CompositionCustomVisualHandler handler);
    public void DispatchMessages(List`1<object> messages);
    public sealed virtual void OnTick();
    public virtual LtrbRect get_OwnContentBounds();
    protected virtual void OnAttachedToRoot(ServerCompositionTarget target);
    protected virtual void OnDetachedFromRoot(ServerCompositionTarget target);
    internal void HandlerInvalidate();
    internal void HandlerInvalidate(Rect rc);
    internal void HandlerRegisterForNextAnimationFrameUpdate();
    protected virtual void RenderCore(ServerVisualRenderContext ctx, LtrbRect currentTransformedClip);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionDrawingSurface : ServerCompositionSurface {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IRef`1<IBitmapImpl> _bitmap;
    [NullableAttribute("2")]
private IPlatformRenderInterfaceContext _createdWithContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IRef`1<IBitmapImpl> Bitmap { get; }
    public ServerCompositionDrawingSurface(ServerCompositor compositor);
    public virtual IRef`1<IBitmapImpl> get_Bitmap();
    private void PerformSanityChecks(CompositionImportedGpuImage image);
    private void Update(IBitmapImpl newImage, IPlatformRenderInterfaceContext context);
    public void UpdateWithAutomaticSync(CompositionImportedGpuImage image);
    public void UpdateWithKeyedMutex(CompositionImportedGpuImage image, UInt32 acquireIndex, UInt32 releaseIndex);
    public void UpdateWithSemaphores(CompositionImportedGpuImage image, CompositionImportedGpuSemaphore wait, CompositionImportedGpuSemaphore signal);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionDrawListVisual : ServerCompositionContainerVisual {
    [NullableAttribute("2")]
private ServerCompositionRenderData _renderCommands;
    public LtrbRect OwnContentBounds { get; }
    public ServerCompositionDrawListVisual(ServerCompositor compositor, Visual v);
    public virtual LtrbRect get_OwnContentBounds();
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    protected virtual void RenderCore(ServerVisualRenderContext context, LtrbRect currentTransformedClip);
    public sealed virtual void DependencyQueuedInvalidate(IServerRenderResource sender);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionExperimentalAcrylicVisual : ServerCompositionDrawListVisual {
    private ImmutableExperimentalAcrylicMaterial _material;
    internal static CompositionProperty`1<ImmutableExperimentalAcrylicMaterial> s_IdOfMaterialProperty;
    private CornerRadius _cornerRadius;
    internal static CompositionProperty`1<CornerRadius> s_IdOfCornerRadiusProperty;
    public LtrbRect OwnContentBounds { get; }
    public ImmutableExperimentalAcrylicMaterial Material { get; public set; }
    public CornerRadius CornerRadius { get; public set; }
    public ServerCompositionExperimentalAcrylicVisual(ServerCompositor compositor, Visual v);
    private static ServerCompositionExperimentalAcrylicVisual();
    protected virtual void RenderCore(ServerVisualRenderContext context, LtrbRect currentTransformedClip);
    public virtual LtrbRect get_OwnContentBounds();
    public ImmutableExperimentalAcrylicMaterial get_Material();
    public void set_Material(ImmutableExperimentalAcrylicMaterial value);
    public CornerRadius get_CornerRadius();
    public void set_CornerRadius(CornerRadius value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleBrush : SimpleServerRenderResource {
    private double _opacity;
    internal static CompositionProperty`1<double> s_IdOfOpacityProperty;
    private RelativePoint _transformOrigin;
    internal static CompositionProperty`1<RelativePoint> s_IdOfTransformOriginProperty;
    [NullableAttribute("2")]
private ITransform _transform;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<ITransform> s_IdOfTransformProperty;
    [NullableAttribute("2")]
private ITransform Avalonia.Media.IBrush.Transform { get; }
    public double Opacity { get; public set; }
    public RelativePoint TransformOrigin { get; public set; }
    [NullableAttribute("2")]
public ITransform Transform { get; public set; }
    internal ServerCompositionSimpleBrush(ServerCompositor compositor);
    private static ServerCompositionSimpleBrush();
    [NullableContextAttribute("2")]
private sealed virtual override ITransform Avalonia.Media.IBrush.get_Transform();
    public sealed virtual double get_Opacity();
    public void set_Opacity(double value);
    public sealed virtual RelativePoint get_TransformOrigin();
    public void set_TransformOrigin(RelativePoint value);
    [NullableContextAttribute("2")]
public ITransform get_Transform();
    [NullableContextAttribute("2")]
public void set_Transform(ITransform value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    internal static void SerializeAllChanges(BatchStreamWriter writer, double opacity, RelativePoint transformOrigin, ITransform transform);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleConicGradientBrush : ServerCompositionSimpleGradientBrush {
    private double _angle;
    internal static CompositionProperty`1<double> s_IdOfAngleProperty;
    private RelativePoint _center;
    internal static CompositionProperty`1<RelativePoint> s_IdOfCenterProperty;
    public double Angle { get; public set; }
    public RelativePoint Center { get; public set; }
    internal ServerCompositionSimpleConicGradientBrush(ServerCompositor compositor);
    private static ServerCompositionSimpleConicGradientBrush();
    public sealed virtual double get_Angle();
    public void set_Angle(double value);
    public sealed virtual RelativePoint get_Center();
    public void set_Center(RelativePoint value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    internal static void SerializeAllChanges(BatchStreamWriter writer, double angle, RelativePoint center);
}
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleContentBrush : ServerCompositionSimpleTileBrush {
    [NullableAttribute("2")]
private Properties _content;
    [NullableContextAttribute("1")]
internal ServerCompositionSimpleContentBrush(ServerCompositor compositor);
    [NullableContextAttribute("2")]
public sealed virtual ISceneBrushContent CreateContent();
    [NullableContextAttribute("1")]
protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleGradientBrush : ServerCompositionSimpleBrush {
    private List`1<IGradientStop> _gradientStops;
    [CompilerGeneratedAttribute]
private GradientSpreadMethod <SpreadMethod>k__BackingField;
    public IReadOnlyList`1<IGradientStop> GradientStops { get; }
    public GradientSpreadMethod SpreadMethod { get; private set; }
    internal ServerCompositionSimpleGradientBrush(ServerCompositor compositor);
    public sealed virtual IReadOnlyList`1<IGradientStop> get_GradientStops();
    [CompilerGeneratedAttribute]
public sealed virtual GradientSpreadMethod get_SpreadMethod();
    [CompilerGeneratedAttribute]
private void set_SpreadMethod(GradientSpreadMethod value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
}
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleImageBrush : ServerCompositionSimpleTileBrush {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IRef`1<IBitmapImpl> <Bitmap>k__BackingField;
    [NullableAttribute("2")]
public IImageBrushSource Source { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IRef`1<IBitmapImpl> Bitmap { get; private set; }
    [NullableContextAttribute("1")]
internal ServerCompositionSimpleImageBrush(ServerCompositor compositor);
    [NullableContextAttribute("2")]
public sealed virtual IImageBrushSource get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual IRef`1<IBitmapImpl> get_Bitmap();
    [CompilerGeneratedAttribute]
private void set_Bitmap(IRef`1<IBitmapImpl> value);
    public virtual void Dispose();
    [NullableContextAttribute("1")]
protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleLinearGradientBrush : ServerCompositionSimpleGradientBrush {
    private RelativePoint _startPoint;
    internal static CompositionProperty`1<RelativePoint> s_IdOfStartPointProperty;
    private RelativePoint _endPoint;
    internal static CompositionProperty`1<RelativePoint> s_IdOfEndPointProperty;
    public RelativePoint StartPoint { get; public set; }
    public RelativePoint EndPoint { get; public set; }
    internal ServerCompositionSimpleLinearGradientBrush(ServerCompositor compositor);
    private static ServerCompositionSimpleLinearGradientBrush();
    public sealed virtual RelativePoint get_StartPoint();
    public void set_StartPoint(RelativePoint value);
    public sealed virtual RelativePoint get_EndPoint();
    public void set_EndPoint(RelativePoint value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    internal static void SerializeAllChanges(BatchStreamWriter writer, RelativePoint startPoint, RelativePoint endPoint);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimplePen : SimpleServerRenderResource {
    private IBrush _brush;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<IBrush> s_IdOfBrushProperty;
    private ImmutableDashStyle _dashStyle;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<ImmutableDashStyle> s_IdOfDashStyleProperty;
    private PenLineCap _lineCap;
    [NullableAttribute("1")]
internal static CompositionProperty`1<PenLineCap> s_IdOfLineCapProperty;
    private PenLineJoin _lineJoin;
    [NullableAttribute("1")]
internal static CompositionProperty`1<PenLineJoin> s_IdOfLineJoinProperty;
    private double _miterLimit;
    [NullableAttribute("1")]
internal static CompositionProperty`1<double> s_IdOfMiterLimitProperty;
    private double _thickness;
    [NullableAttribute("1")]
internal static CompositionProperty`1<double> s_IdOfThicknessProperty;
    private IDashStyle Avalonia.Media.IPen.DashStyle { get; }
    public IBrush Brush { get; public set; }
    public ImmutableDashStyle DashStyle { get; public set; }
    public PenLineCap LineCap { get; public set; }
    public PenLineJoin LineJoin { get; public set; }
    public double MiterLimit { get; public set; }
    public double Thickness { get; public set; }
    [NullableContextAttribute("1")]
internal ServerCompositionSimplePen(ServerCompositor compositor);
    private static ServerCompositionSimplePen();
    private sealed virtual override IDashStyle Avalonia.Media.IPen.get_DashStyle();
    public sealed virtual IBrush get_Brush();
    public void set_Brush(IBrush value);
    public ImmutableDashStyle get_DashStyle();
    public void set_DashStyle(ImmutableDashStyle value);
    public sealed virtual PenLineCap get_LineCap();
    public void set_LineCap(PenLineCap value);
    public sealed virtual PenLineJoin get_LineJoin();
    public void set_LineJoin(PenLineJoin value);
    public sealed virtual double get_MiterLimit();
    public void set_MiterLimit(double value);
    public sealed virtual double get_Thickness();
    public void set_Thickness(double value);
    [NullableContextAttribute("1")]
protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    internal static void SerializeAllChanges(BatchStreamWriter writer, IBrush brush, ImmutableDashStyle dashStyle, PenLineCap lineCap, PenLineJoin lineJoin, double miterLimit, double thickness);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleRadialGradientBrush : ServerCompositionSimpleGradientBrush {
    private RelativePoint _center;
    internal static CompositionProperty`1<RelativePoint> s_IdOfCenterProperty;
    private RelativePoint _gradientOrigin;
    internal static CompositionProperty`1<RelativePoint> s_IdOfGradientOriginProperty;
    private RelativeScalar _radiusX;
    internal static CompositionProperty`1<RelativeScalar> s_IdOfRadiusXProperty;
    private RelativeScalar _radiusY;
    internal static CompositionProperty`1<RelativeScalar> s_IdOfRadiusYProperty;
    public double Radius { get; }
    public RelativePoint Center { get; public set; }
    public RelativePoint GradientOrigin { get; public set; }
    public RelativeScalar RadiusX { get; public set; }
    public RelativeScalar RadiusY { get; public set; }
    internal ServerCompositionSimpleRadialGradientBrush(ServerCompositor compositor);
    private static ServerCompositionSimpleRadialGradientBrush();
    public sealed virtual double get_Radius();
    public sealed virtual RelativePoint get_Center();
    public void set_Center(RelativePoint value);
    public sealed virtual RelativePoint get_GradientOrigin();
    public void set_GradientOrigin(RelativePoint value);
    public sealed virtual RelativeScalar get_RadiusX();
    public void set_RadiusX(RelativeScalar value);
    public sealed virtual RelativeScalar get_RadiusY();
    public void set_RadiusY(RelativeScalar value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    internal static void SerializeAllChanges(BatchStreamWriter writer, RelativePoint center, RelativePoint gradientOrigin, RelativeScalar radiusX, RelativeScalar radiusY);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleSolidColorBrush : ServerCompositionSimpleBrush {
    private Color _color;
    internal static CompositionProperty`1<Color> s_IdOfColorProperty;
    public Color Color { get; public set; }
    internal ServerCompositionSimpleSolidColorBrush(ServerCompositor compositor);
    private static ServerCompositionSimpleSolidColorBrush();
    public sealed virtual Color get_Color();
    public void set_Color(Color value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    internal static void SerializeAllChanges(BatchStreamWriter writer, Color color);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleTileBrush : ServerCompositionSimpleBrush {
    private AlignmentX _alignmentX;
    internal static CompositionProperty`1<AlignmentX> s_IdOfAlignmentXProperty;
    private AlignmentY _alignmentY;
    internal static CompositionProperty`1<AlignmentY> s_IdOfAlignmentYProperty;
    private RelativeRect _destinationRect;
    internal static CompositionProperty`1<RelativeRect> s_IdOfDestinationRectProperty;
    private RelativeRect _sourceRect;
    internal static CompositionProperty`1<RelativeRect> s_IdOfSourceRectProperty;
    private Stretch _stretch;
    internal static CompositionProperty`1<Stretch> s_IdOfStretchProperty;
    private TileMode _tileMode;
    internal static CompositionProperty`1<TileMode> s_IdOfTileModeProperty;
    public AlignmentX AlignmentX { get; public set; }
    public AlignmentY AlignmentY { get; public set; }
    public RelativeRect DestinationRect { get; public set; }
    public RelativeRect SourceRect { get; public set; }
    public Stretch Stretch { get; public set; }
    public TileMode TileMode { get; public set; }
    internal ServerCompositionSimpleTileBrush(ServerCompositor compositor);
    private static ServerCompositionSimpleTileBrush();
    public sealed virtual AlignmentX get_AlignmentX();
    public void set_AlignmentX(AlignmentX value);
    public sealed virtual AlignmentY get_AlignmentY();
    public void set_AlignmentY(AlignmentY value);
    public sealed virtual RelativeRect get_DestinationRect();
    public void set_DestinationRect(RelativeRect value);
    public sealed virtual RelativeRect get_SourceRect();
    public void set_SourceRect(RelativeRect value);
    public sealed virtual Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public sealed virtual TileMode get_TileMode();
    public void set_TileMode(TileMode value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    internal static void SerializeAllChanges(BatchStreamWriter writer, AlignmentX alignmentX, AlignmentY alignmentY, RelativeRect destinationRect, RelativeRect sourceRect, Stretch stretch, TileMode tileMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSimpleTransform : SimpleServerRenderResource {
    private Matrix _value;
    internal static CompositionProperty`1<Matrix> s_IdOfValueProperty;
    public Matrix Value { get; public set; }
    internal ServerCompositionSimpleTransform(ServerCompositor compositor);
    private static ServerCompositionSimpleTransform();
    public sealed virtual Matrix get_Value();
    public void set_Value(Matrix value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    internal static void SerializeAllChanges(BatchStreamWriter writer, Matrix value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSolidColorVisual : ServerCompositionContainerVisual {
    private Color _color;
    internal static CompositionProperty`1<Color> s_IdOfColorProperty;
    public Color Color { get; public set; }
    internal ServerCompositionSolidColorVisual(ServerCompositor compositor);
    private static ServerCompositionSolidColorVisual();
    protected virtual void RenderCore(ServerVisualRenderContext context, LtrbRect currentTransformedClip);
    public Color get_Color();
    public void set_Color(Color value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    public virtual CompositionProperty GetCompositionProperty(string name);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.Composition.Server.ServerCompositionSurface : ServerObject {
    [CompilerGeneratedAttribute]
private Action <Changed>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IRef`1<IBitmapImpl> Bitmap { get; }
    public Action Changed { get; public set; }
    [NullableContextAttribute("1")]
protected ServerCompositionSurface(ServerCompositor compositor);
    public abstract virtual IRef`1<IBitmapImpl> get_Bitmap();
    [CompilerGeneratedAttribute]
public Action get_Changed();
    [CompilerGeneratedAttribute]
public void set_Changed(Action value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionSurfaceVisual : ServerCompositionContainerVisual {
    [NullableAttribute("2")]
private ServerCompositionSurface _surface;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<ServerCompositionSurface> s_IdOfSurfaceProperty;
    [NullableAttribute("2")]
public ServerCompositionSurface Surface { get; public set; }
    internal ServerCompositionSurfaceVisual(ServerCompositor compositor);
    private static ServerCompositionSurfaceVisual();
    protected virtual void RenderCore(ServerVisualRenderContext context, LtrbRect currentTransformedClip);
    private void OnSurfaceInvalidated();
    protected virtual void OnAttachedToRoot(ServerCompositionTarget target);
    protected virtual void OnDetachedFromRoot(ServerCompositionTarget target);
    [NullableContextAttribute("2")]
public ServerCompositionSurface get_Surface();
    [NullableContextAttribute("2")]
public void set_Surface(ServerCompositionSurface value);
    private void OnSurfaceChanged();
    private void OnSurfaceChanging();
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionTarget : ServerObject {
    private ServerCompositor _compositor;
    private Func`1<IEnumerable`1<object>> _surfaces;
    private CompositionTargetOverlays _overlays;
    private static long s_nextId;
    [NullableAttribute("2")]
private IRenderTarget _renderTarget;
    private PixelSize _layerSize;
    [NullableAttribute("2")]
private IDrawingContextLayerImpl _layer;
    private bool _updateRequested;
    private bool _redrawRequested;
    private bool _fullRedrawRequested;
    private bool _disposed;
    private HashSet`1<ServerCompositionVisual> _attachedVisuals;
    private Queue`1<ServerCompositionVisual> _adornerUpdateQueue;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Revision>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICompositionTargetDebugEvents <DebugEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadbackIndices <Readback>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RenderedVisuals>k__BackingField;
    public IDirtyRectTracker DirtyRects;
    [NullableAttribute("2")]
private ServerCompositionVisual _root;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<ServerCompositionVisual> s_IdOfRootProperty;
    private bool _isEnabled;
    internal static CompositionProperty`1<bool> s_IdOfIsEnabledProperty;
    private RendererDebugOverlays _debugOverlays;
    internal static CompositionProperty`1<RendererDebugOverlays> s_IdOfDebugOverlaysProperty;
    private LayoutPassTiming _lastLayoutPassTiming;
    internal static CompositionProperty`1<LayoutPassTiming> s_IdOfLastLayoutPassTimingProperty;
    private double _scaling;
    internal static CompositionProperty`1<double> s_IdOfScalingProperty;
    private PixelSize _pixelSize;
    internal static CompositionProperty`1<PixelSize> s_IdOfPixelSizeProperty;
    public long Id { get; }
    public ulong Revision { get; private set; }
    [NullableAttribute("2")]
public ICompositionTargetDebugEvents DebugEvents { get; public set; }
    public ReadbackIndices Readback { get; }
    public int RenderedVisuals { get; public set; }
    [NullableAttribute("2")]
public ServerCompositionVisual Root { get; public set; }
    public bool IsEnabled { get; public set; }
    public RendererDebugOverlays DebugOverlays { get; public set; }
    public LayoutPassTiming LastLayoutPassTiming { get; public set; }
    public double Scaling { get; public set; }
    public PixelSize PixelSize { get; public set; }
    public ServerCompositionTarget(ServerCompositor compositor, Func`1<IEnumerable`1<object>> surfaces, DiagnosticTextRenderer diagnosticTextRenderer);
    private static ServerCompositionTarget();
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public ulong get_Revision();
    [CompilerGeneratedAttribute]
private void set_Revision(ulong value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICompositionTargetDebugEvents get_DebugEvents();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DebugEvents(ICompositionTargetDebugEvents value);
    [CompilerGeneratedAttribute]
public ReadbackIndices get_Readback();
    [CompilerGeneratedAttribute]
public int get_RenderedVisuals();
    [CompilerGeneratedAttribute]
public void set_RenderedVisuals(int value);
    public void Render();
    private void RenderRootToContextWithClip(IDrawingContextImpl context, ServerCompositionVisual root);
    public void RequestUpdate();
    public sealed virtual void Dispose();
    public void AddVisual(ServerCompositionVisual visual);
    public void RemoveVisual(ServerCompositionVisual visual);
    public void EnqueueAdornerUpdate(ServerCompositionVisual visual);
    private static int Clamp0(int value, int max);
    public void AddDirtyRect(LtrbRect rect);
    public Rect SnapToDevicePixels(Rect rect);
    public LtrbRect SnapToDevicePixels(LtrbRect rect);
    public static LtrbRect SnapToDevicePixels(LtrbRect rect, double scale);
    private void DeserializeChangesExtra(BatchStreamReader c);
    [NullableContextAttribute("2")]
public ServerCompositionVisual get_Root();
    [NullableContextAttribute("2")]
public void set_Root(ServerCompositionVisual value);
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    private void OnIsEnabledChanged();
    public RendererDebugOverlays get_DebugOverlays();
    public void set_DebugOverlays(RendererDebugOverlays value);
    private void OnDebugOverlaysChanged();
    public LayoutPassTiming get_LastLayoutPassTiming();
    public void set_LastLayoutPassTiming(LayoutPassTiming value);
    private void OnLastLayoutPassTimingChanged();
    public double get_Scaling();
    public void set_Scaling(double value);
    public PixelSize get_PixelSize();
    public void set_PixelSize(PixelSize value);
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    public virtual CompositionProperty GetCompositionProperty(string name);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.Composition.Server.ServerCompositionVisual : ServerObject {
    private bool _isDirtyForUpdate;
    private LtrbRect _oldOwnContentBounds;
    private bool _isBackface;
    private Nullable`1<LtrbRect> _transformedClipBounds;
    private LtrbRect _combinedTransformedClipBounds;
    private ReadbackData _readback0;
    private ReadbackData _readback1;
    private ReadbackData _readback2;
    [CompilerGeneratedAttribute]
private Matrix <CombinedTransformMatrix>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix <GlobalTransformMatrix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVisibleInFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHitTestVisibleInFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EffectiveOpacity>k__BackingField;
    [CompilerGeneratedAttribute]
private LtrbRect <TransformedOwnContentBounds>k__BackingField;
    protected bool IsDirtyComposition;
    private bool _combinedTransformDirty;
    private bool _clipSizeDirty;
    private static CompositionVisualChangedFields CompositionFieldsMask;
    private static CompositionVisualChangedFields CombinedTransformFieldsMask;
    private static CompositionVisualChangedFields ClipSizeDirtyMask;
    private ServerCompositionTarget _root;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<ServerCompositionTarget> s_IdOfRootProperty;
    private ServerCompositionVisual _parent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<ServerCompositionVisual> s_IdOfParentProperty;
    private bool _visible;
    [NullableAttribute("1")]
internal static CompositionProperty`1<bool> s_IdOfVisibleProperty;
    private float _opacity;
    [NullableAttribute("1")]
internal static CompositionProperty`1<float> s_IdOfOpacityProperty;
    private IGeometryImpl _clip;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<IGeometryImpl> s_IdOfClipProperty;
    private bool _clipToBounds;
    [NullableAttribute("1")]
internal static CompositionProperty`1<bool> s_IdOfClipToBoundsProperty;
    private Vector3D _offset;
    [NullableAttribute("1")]
internal static CompositionProperty`1<Vector3D> s_IdOfOffsetProperty;
    private Vector _size;
    [NullableAttribute("1")]
internal static CompositionProperty`1<Vector> s_IdOfSizeProperty;
    private Vector _anchorPoint;
    [NullableAttribute("1")]
internal static CompositionProperty`1<Vector> s_IdOfAnchorPointProperty;
    private Vector3D _centerPoint;
    [NullableAttribute("1")]
internal static CompositionProperty`1<Vector3D> s_IdOfCenterPointProperty;
    private float _rotationAngle;
    [NullableAttribute("1")]
internal static CompositionProperty`1<float> s_IdOfRotationAngleProperty;
    private Quaternion _orientation;
    [NullableAttribute("1")]
internal static CompositionProperty`1<Quaternion> s_IdOfOrientationProperty;
    private Vector3D _scale;
    [NullableAttribute("1")]
internal static CompositionProperty`1<Vector3D> s_IdOfScaleProperty;
    private Matrix _transformMatrix;
    [NullableAttribute("1")]
internal static CompositionProperty`1<Matrix> s_IdOfTransformMatrixProperty;
    private ServerCompositionVisual _adornedVisual;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<ServerCompositionVisual> s_IdOfAdornedVisualProperty;
    private bool _adornerIsClipped;
    [NullableAttribute("1")]
internal static CompositionProperty`1<bool> s_IdOfAdornerIsClippedProperty;
    private IImmutableBrush _opacityMaskBrush;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<IImmutableBrush> s_IdOfOpacityMaskBrushProperty;
    private IImmutableEffect _effect;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompositionProperty`1<IImmutableEffect> s_IdOfEffectProperty;
    private RenderOptions _renderOptions;
    [NullableAttribute("1")]
internal static CompositionProperty`1<RenderOptions> s_IdOfRenderOptionsProperty;
    protected bool HandlesClipToBounds { get; }
    public Matrix CombinedTransformMatrix { get; private set; }
    public Matrix GlobalTransformMatrix { get; private set; }
    public bool IsVisibleInFrame { get; public set; }
    public bool IsHitTestVisibleInFrame { get; public set; }
    public double EffectiveOpacity { get; public set; }
    public LtrbRect TransformedOwnContentBounds { get; public set; }
    public LtrbRect OwnContentBounds { get; }
    public ServerCompositionTarget Root { get; public set; }
    public ServerCompositionVisual Parent { get; public set; }
    public bool Visible { get; public set; }
    public float Opacity { get; public set; }
    public IGeometryImpl Clip { get; public set; }
    public bool ClipToBounds { get; public set; }
    public Vector3D Offset { get; public set; }
    public Vector Size { get; public set; }
    public Vector AnchorPoint { get; public set; }
    public Vector3D CenterPoint { get; public set; }
    public float RotationAngle { get; public set; }
    public Quaternion Orientation { get; public set; }
    public Vector3D Scale { get; public set; }
    public Matrix TransformMatrix { get; public set; }
    public ServerCompositionVisual AdornedVisual { get; public set; }
    public bool AdornerIsClipped { get; public set; }
    public IImmutableBrush OpacityMaskBrush { get; public set; }
    public IImmutableEffect Effect { get; public set; }
    public RenderOptions RenderOptions { get; public set; }
    [NullableContextAttribute("1")]
internal ServerCompositionVisual(ServerCompositor compositor);
    private static ServerCompositionVisual();
    [NullableContextAttribute("1")]
protected virtual void RenderCore(ServerVisualRenderContext canvas, LtrbRect currentTransformedClip);
    [NullableContextAttribute("1")]
public void Render(ServerVisualRenderContext context, Nullable`1<LtrbRect> parentTransformedClip);
    protected virtual bool get_HandlesClipToBounds();
    public ReadbackData& GetReadback(int idx);
    [CompilerGeneratedAttribute]
public Matrix get_CombinedTransformMatrix();
    [CompilerGeneratedAttribute]
private void set_CombinedTransformMatrix(Matrix value);
    [CompilerGeneratedAttribute]
public Matrix get_GlobalTransformMatrix();
    [CompilerGeneratedAttribute]
private void set_GlobalTransformMatrix(Matrix value);
    [NullableContextAttribute("1")]
public virtual UpdateResult Update(ServerCompositionTarget root, Matrix parentVisualTransform);
    protected void AddDirtyRect(LtrbRect rc);
    [NullableContextAttribute("1")]
protected virtual void OnDetachedFromRoot(ServerCompositionTarget target);
    [NullableContextAttribute("1")]
protected virtual void OnAttachedToRoot(ServerCompositionTarget target);
    protected virtual void ValuesInvalidated();
    [CompilerGeneratedAttribute]
public bool get_IsVisibleInFrame();
    [CompilerGeneratedAttribute]
public void set_IsVisibleInFrame(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsHitTestVisibleInFrame();
    [CompilerGeneratedAttribute]
public void set_IsHitTestVisibleInFrame(bool value);
    [CompilerGeneratedAttribute]
public double get_EffectiveOpacity();
    [CompilerGeneratedAttribute]
public void set_EffectiveOpacity(double value);
    [CompilerGeneratedAttribute]
public LtrbRect get_TransformedOwnContentBounds();
    [CompilerGeneratedAttribute]
public void set_TransformedOwnContentBounds(LtrbRect value);
    public virtual LtrbRect get_OwnContentBounds();
    [NullableContextAttribute("1")]
public virtual void NotifyAnimatedValueChanged(CompositionProperty offset);
    [NullableContextAttribute("1")]
private void DeserializeChangesExtra(BatchStreamReader c);
    public ServerCompositionTarget get_Root();
    public void set_Root(ServerCompositionTarget value);
    private void OnRootChanged();
    private void OnRootChanging();
    public ServerCompositionVisual get_Parent();
    public void set_Parent(ServerCompositionVisual value);
    public bool get_Visible();
    public void set_Visible(bool value);
    public float get_Opacity();
    public void set_Opacity(float value);
    public IGeometryImpl get_Clip();
    public void set_Clip(IGeometryImpl value);
    public bool get_ClipToBounds();
    public void set_ClipToBounds(bool value);
    public Vector3D get_Offset();
    public void set_Offset(Vector3D value);
    public Vector get_Size();
    public void set_Size(Vector value);
    public Vector get_AnchorPoint();
    public void set_AnchorPoint(Vector value);
    public Vector3D get_CenterPoint();
    public void set_CenterPoint(Vector3D value);
    public float get_RotationAngle();
    public void set_RotationAngle(float value);
    public Quaternion get_Orientation();
    public void set_Orientation(Quaternion value);
    public Vector3D get_Scale();
    public void set_Scale(Vector3D value);
    public Matrix get_TransformMatrix();
    public void set_TransformMatrix(Matrix value);
    public ServerCompositionVisual get_AdornedVisual();
    public void set_AdornedVisual(ServerCompositionVisual value);
    public bool get_AdornerIsClipped();
    public void set_AdornerIsClipped(bool value);
    public IImmutableBrush get_OpacityMaskBrush();
    public void set_OpacityMaskBrush(IImmutableBrush value);
    public IImmutableEffect get_Effect();
    public void set_Effect(IImmutableEffect value);
    public RenderOptions get_RenderOptions();
    public void set_RenderOptions(RenderOptions value);
    [NullableContextAttribute("1")]
protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    private void OnFieldsDeserialized(CompositionVisualChangedFields changed);
    [NullableContextAttribute("1")]
public virtual CompositionProperty GetCompositionProperty(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositionVisualCollection : ServerList`1<ServerCompositionVisual> {
    internal ServerCompositionVisualCollection(ServerCompositor compositor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositor : object {
    private IRenderLoop _renderLoop;
    private Queue`1<CompositionBatch> _batches;
    private Queue`1<Action> _receivedJobQueue;
    private Queue`1<Action> _receivedPostTargetJobQueue;
    [CompilerGeneratedAttribute]
private long <LastBatchId>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Clock>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ServerNow>k__BackingField;
    private List`1<ServerCompositionTarget> _activeTargets;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal BatchStreamObjectPool`1<object> BatchObjectPool;
    internal BatchStreamMemoryPool BatchMemoryPool;
    private object _lock;
    [NullableAttribute("2")]
private Thread _safeThread;
    private bool _uiThreadIsInsideRender;
    [CompilerGeneratedAttribute]
private PlatformRenderInterfaceContextManager <RenderInterface>k__BackingField;
    internal static object RenderThreadDisposeStartMarker;
    internal static object RenderThreadJobsStartMarker;
    internal static object RenderThreadJobsEndMarker;
    internal static object RenderThreadPostTargetJobsStartMarker;
    internal static object RenderThreadPostTargetJobsEndMarker;
    [CompilerGeneratedAttribute]
private CompositionOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCompositorAnimations <Animations>k__BackingField;
    private List`1<CompositionBatch> _reusableToNotifyProcessedList;
    private List`1<CompositionBatch> _reusableToNotifyRenderedList;
    private Queue`1<IServerRenderResource> _renderResourcesInvalidationQueue;
    private HashSet`1<IServerRenderResource> _renderResourcesInvalidationSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<Type, object> _renderInterfaceFeatureCache;
    private object _renderInterfaceFeaturesUserApiLock;
    public long LastBatchId { get; private set; }
    public Stopwatch Clock { get; }
    public TimeSpan ServerNow { get; private set; }
    public PlatformRenderInterfaceContextManager RenderInterface { get; }
    public CompositionOptions Options { get; }
    public ServerCompositorAnimations Animations { get; }
    public ServerCompositor(IRenderLoop renderLoop, IPlatformGraphics platformGraphics, CompositionOptions options, BatchStreamObjectPool`1<object> batchObjectPool, BatchStreamMemoryPool batchMemoryPool);
    private static ServerCompositor();
    [CompilerGeneratedAttribute]
public long get_LastBatchId();
    [CompilerGeneratedAttribute]
private void set_LastBatchId(long value);
    [CompilerGeneratedAttribute]
public Stopwatch get_Clock();
    [CompilerGeneratedAttribute]
public TimeSpan get_ServerNow();
    [CompilerGeneratedAttribute]
private void set_ServerNow(TimeSpan value);
    [CompilerGeneratedAttribute]
public PlatformRenderInterfaceContextManager get_RenderInterface();
    [CompilerGeneratedAttribute]
public CompositionOptions get_Options();
    [CompilerGeneratedAttribute]
public ServerCompositorAnimations get_Animations();
    public void EnqueueBatch(CompositionBatch batch);
    internal void UpdateServerTime();
    private void ApplyPendingBatches();
    private void ReadServerJobs(BatchStreamReader reader, Queue`1<Action> queue, object endMarker);
    private void ReadDisposeJobs(BatchStreamReader reader);
    private void ExecuteServerJobs(Queue`1<Action> queue);
    private void NotifyBatchesProcessed();
    private void NotifyBatchesRendered();
    public sealed virtual void Render();
    public void Render(bool catchExceptions);
    private void RenderReentrancySafe(bool catchExceptions);
    private void RenderCore(bool catchExceptions);
    public void AddCompositionTarget(ServerCompositionTarget target);
    public void RemoveCompositionTarget(ServerCompositionTarget target);
    public IRenderTarget CreateRenderTarget(IEnumerable`1<object> surfaces);
    public bool CheckAccess();
    public void VerifyAccess();
    public void ApplyEnqueuedRenderResourceChanges();
    public void EnqueueRenderResourceForInvalidation(IServerRenderResource resource);
    private void RT_OnContextCreated(IPlatformRenderInterfaceContext context);
    private bool RT_OnContextLostExceptionFilterObserver(Exception e);
    private void RT_OnContextDisposed();
    public IReadOnlyDictionary`2<Type, object> AT_TryGetCachedRenderInterfaceFeatures();
    public IReadOnlyDictionary`2<Type, object> RT_GetRenderInterfaceFeatures();
    public IBitmapImpl CreateCompositionVisualSnapshot(ServerCompositionVisual visual, double scaling);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerCompositorAnimations : object {
    private HashSet`1<IServerClockItem> _clockItems;
    private List`1<IServerClockItem> _clockItemsToUpdate;
    private HashSet`1<ServerObjectAnimations> _dirtyAnimatedObjects;
    private Queue`1<ServerObjectAnimations> _dirtyAnimatedObjectQueue;
    public void AddToClock(IServerClockItem item);
    public void RemoveFromClock(IServerClockItem item);
    public void Process();
    public void AddDirtyAnimatedObject(ServerObjectAnimations obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerList`1 : ServerObject {
    [CompilerGeneratedAttribute]
private List`1<T> <List>k__BackingField;
    public List`1<T> List { get; }
    public ServerList`1(ServerCompositor compositor);
    [CompilerGeneratedAttribute]
public List`1<T> get_List();
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    public Enumerator<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.Composition.Server.ServerObject : SimpleServerObject {
    private UInt32 _activationCount;
    [NullableAttribute("2")]
private ServerObjectAnimations _animations;
    [NullableAttribute("2")]
public ServerObjectAnimations Animations { get; }
    public bool IsActive { get; }
    public ServerObject(ServerCompositor compositor);
    [NullableContextAttribute("2")]
public ServerObjectAnimations get_Animations();
    public ServerObjectAnimations GetOrCreateAnimations();
    public bool get_IsActive();
    public void Activate();
    public void Deactivate();
    private void Activated();
    private void Deactivated();
    protected void SetValue(CompositionProperty prop, T& field, T value);
    [NullableContextAttribute("0")]
protected void SetAnimatedValue(CompositionProperty`1<T> prop, T& field, TimeSpan committedAt, IAnimationInstance animation);
    protected void SetAnimatedValue(CompositionProperty property, T& field, T value);
    public virtual void NotifyAnimatedValueChanged(CompositionProperty prop);
    public virtual CompositionProperty GetCompositionProperty(string fieldName);
    private sealed virtual override ExpressionVariant Avalonia.Rendering.Composition.Expressions.IExpressionObject.GetProperty(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerObjectAnimations : object {
    private ServerObject _owner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private InlineDictionary`2<CompositionProperty, ServerObjectSubscriptionStore> _subscriptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private InlineDictionary`2<CompositionProperty, ServerObjectAnimationInstance> _animations;
    private IReadOnlyDictionary`2<string, CompositionProperty> _properties;
    public ServerObjectAnimations(ServerObject owner);
    public void Activated();
    public void Deactivated();
    public void OnSetDirectValue(CompositionProperty property);
    [NullableContextAttribute("0")]
public void OnSetAnimatedValue(CompositionProperty`1<T> prop, T& field, TimeSpan committedAt, IAnimationInstance animation);
    public void RemoveAnimationForProperty(CompositionProperty property);
    public void SubscribeToInvalidation(CompositionProperty member, IAnimationInstance animation);
    public void UnsubscribeFromInvalidation(CompositionProperty member, IAnimationInstance animation);
    public ExpressionVariant GetPropertyForAnimation(string name);
    public void EvaluateAnimations();
    public void NotifyAnimationInstanceInvalidated(CompositionProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.ServerVisualRenderContext : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDirtyRectTracker <DirtyRects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetachedRendering>k__BackingField;
    [CompilerGeneratedAttribute]
private CompositorDrawingContextProxy <Canvas>k__BackingField;
    [NullableAttribute("2")]
private Stack`1<Matrix> _transformStack;
    [NullableAttribute("2")]
public IDirtyRectTracker DirtyRects { get; }
    public bool DetachedRendering { get; }
    public CompositorDrawingContextProxy Canvas { get; }
    public ServerVisualRenderContext(CompositorDrawingContextProxy canvas, IDirtyRectTracker dirtyRects, bool detachedRendering);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IDirtyRectTracker get_DirtyRects();
    [CompilerGeneratedAttribute]
public bool get_DetachedRendering();
    [CompilerGeneratedAttribute]
public CompositorDrawingContextProxy get_Canvas();
    public bool ShouldRender(ServerCompositionVisual visual, LtrbRect currentTransformedClip);
    public bool ShouldRenderOwnContent(ServerCompositionVisual visual, LtrbRect currentTransformedClip);
    public RestoreTransform SetOrPushTransform(ServerCompositionVisual visual);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.SimpleServerObject : object {
    [CompilerGeneratedAttribute]
private ServerCompositor <Compositor>k__BackingField;
    public ServerCompositor Compositor { get; }
    public SimpleServerObject(ServerCompositor compositor);
    [CompilerGeneratedAttribute]
public ServerCompositor get_Compositor();
    protected virtual void DeserializeChangesCore(BatchStreamReader reader, TimeSpan committedAt);
    public void DeserializeChanges(BatchStreamReader reader, CompositionBatch batch);
    protected virtual void ValuesInvalidated();
    protected void SetValue(CompositionProperty prop, T& field, T value);
    protected T GetValue(CompositionProperty prop, T& field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.Composition.Server.SimpleServerRenderResource : SimpleServerObject {
    private bool _pendingInvalidation;
    private bool _disposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RefCountingSmallDictionary`1<IServerRenderResourceObserver> _observers;
    public bool IsDisposed { get; }
    public SimpleServerRenderResource(ServerCompositor compositor);
    public bool get_IsDisposed();
    protected void SetValue(CompositionProperty prop, T& field, T value);
    protected void SetValue(T& field, T value);
    protected void Invalidated();
    protected virtual void ValuesInvalidated();
    protected void RemoveObserversFromProperty(T& field);
    public virtual void Dispose();
    public virtual void DependencyQueuedInvalidate(IServerRenderResource sender);
    protected virtual void PropertyChanged();
    public sealed virtual void AddObserver(IServerRenderResourceObserver observer);
    public sealed virtual void RemoveObserver(IServerRenderResourceObserver observer);
    public virtual void QueuedInvalidate();
}
internal class Avalonia.Rendering.Composition.Transport.BatchStreamData : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Queue`1<BatchStreamSegment`1<Object[]>> <Objects>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Queue`1<BatchStreamSegment`1<IntPtr>> <Structs>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Queue`1<BatchStreamSegment`1<Object[]>> Objects { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Queue`1<BatchStreamSegment`1<IntPtr>> Structs { get; }
    [CompilerGeneratedAttribute]
public Queue`1<BatchStreamSegment`1<Object[]>> get_Objects();
    [CompilerGeneratedAttribute]
public Queue`1<BatchStreamSegment`1<IntPtr>> get_Structs();
}
internal class Avalonia.Rendering.Composition.Transport.BatchStreamDebugMarkers : object {
    [NullableAttribute("1")]
public static object ObjectEndMarker;
    public static Guid ObjectEndMagic;
    private static BatchStreamDebugMarkers();
}
internal class Avalonia.Rendering.Composition.Transport.BatchStreamMemoryPool : BatchStreamPoolBase`1<IntPtr> {
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    public int BufferSize { get; }
    public BatchStreamMemoryPool(bool reclaimImmediately, int bufferSize, Action`1<Func`1<bool>> startTimer);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    protected virtual IntPtr CreateItem();
    protected virtual void DestroyItem(IntPtr item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Rendering.Composition.Transport.BatchStreamObjectPool`1 : BatchStreamPoolBase`1<T[]> {
    [CompilerGeneratedAttribute]
private int <ArraySize>k__BackingField;
    public int ArraySize { get; }
    public BatchStreamObjectPool`1(bool reclaimImmediately, int arraySize, Action`1<Func`1<bool>> startTimer);
    [CompilerGeneratedAttribute]
public int get_ArraySize();
    protected virtual T[] CreateItem();
    protected virtual void ClearItem(T[] item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.Composition.Transport.BatchStreamPoolBase`1 : object {
    private Stack`1<T> _pool;
    private bool _disposed;
    private int _usage;
    private Int32[] _usageStatistics;
    private int _usageStatisticsSlot;
    private bool _reclaimImmediately;
    public int CurrentUsage { get; }
    public int CurrentPool { get; }
    public BatchStreamPoolBase`1(bool needsFinalize, bool reclaimImmediately, Action`1<Func`1<bool>> startTimer);
    public int get_CurrentUsage();
    public int get_CurrentPool();
    private static void StartUpdateTimer(Action`1<Func`1<bool>> startTimer, WeakReference`1<BatchStreamPoolBase`1<T>> updateRef);
    private void UpdateStatistics();
    protected abstract virtual T CreateItem();
    protected virtual void ClearItem(T item);
    protected virtual void DestroyItem(T item);
    public T Get();
    public void Return(T item);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal class Avalonia.Rendering.Composition.Transport.BatchStreamReader : object {
    [NullableAttribute("1")]
private BatchStreamData _input;
    [NullableAttribute("1")]
private BatchStreamMemoryPool _memoryPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BatchStreamObjectPool`1<object> _objectPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BatchStreamSegment`1<Object[]> _currentObjectSegment;
    private BatchStreamSegment`1<IntPtr> _currentDataSegment;
    private int _memoryOffset;
    private int _objectOffset;
    public bool IsObjectEof { get; }
    public bool IsStructEof { get; }
    [NullableContextAttribute("1")]
public BatchStreamReader(BatchStreamData input, BatchStreamMemoryPool memoryPool, BatchStreamObjectPool`1<object> objectPool);
    public T Read();
    [NullableContextAttribute("1")]
public T ReadObject();
    [NullableContextAttribute("2")]
public object ReadObject();
    public bool get_IsObjectEof();
    public bool get_IsStructEof();
    public sealed virtual void Dispose();
}
public class Avalonia.Rendering.Composition.Transport.BatchStreamSegment`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ElementCount>k__BackingField;
    [NullableAttribute("1")]
public TData Data { get; public set; }
    public int ElementCount { get; public set; }
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TData get_Data();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Data(TData value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ElementCount();
    [CompilerGeneratedAttribute]
public void set_ElementCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BatchStreamSegment`1<TData> left, BatchStreamSegment`1<TData> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BatchStreamSegment`1<TData> left, BatchStreamSegment`1<TData> right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BatchStreamSegment`1<TData> other);
}
internal class Avalonia.Rendering.Composition.Transport.BatchStreamWriter : object {
    [NullableAttribute("1")]
private BatchStreamData _output;
    [NullableAttribute("1")]
private BatchStreamMemoryPool _memoryPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BatchStreamObjectPool`1<object> _objectPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BatchStreamSegment`1<Object[]> _currentObjectSegment;
    private BatchStreamSegment`1<IntPtr> _currentDataSegment;
    [NullableContextAttribute("1")]
public BatchStreamWriter(BatchStreamData output, BatchStreamMemoryPool memoryPool, BatchStreamObjectPool`1<object> objectPool);
    private void CommitDataSegment();
    private void NextDataSegment();
    private void CommitObjectSegment();
    private void NextObjectSegment();
    public void Write(T item);
    [NullableContextAttribute("2")]
public void WriteObject(object item);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.Transport.CompositionBatch : object {
    private static long _nextSequenceId;
    private static ConcurrentBag`1<BatchStreamData> _pool;
    private TaskCompletionSource`1<int> _acceptedTcs;
    private TaskCompletionSource`1<int> _renderedTcs;
    [CompilerGeneratedAttribute]
private long <SequenceId>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchStreamData <Changes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CommittedAt>k__BackingField;
    internal long SequenceId { get; }
    internal BatchStreamData Changes { get; private set; }
    internal TimeSpan CommittedAt { get; internal set; }
    public Task Processed { get; }
    public Task Rendered { get; }
    private static CompositionBatch();
    [CompilerGeneratedAttribute]
internal long get_SequenceId();
    [CompilerGeneratedAttribute]
internal BatchStreamData get_Changes();
    [CompilerGeneratedAttribute]
private void set_Changes(BatchStreamData value);
    [CompilerGeneratedAttribute]
internal TimeSpan get_CommittedAt();
    [CompilerGeneratedAttribute]
internal void set_CommittedAt(TimeSpan value);
    public Task get_Processed();
    public Task get_Rendered();
    internal void NotifyProcessed();
    internal void NotifyRendered();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Avalonia.Rendering.Composition.Transport.ServerListProxyHelper`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IRegisterForSerialization<TClient, TServer> _parent;
    private bool _changed;
    private List`1<TClient> _list;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TClient Item { get; public set; }
    public ServerListProxyHelper`2(IRegisterForSerialization<TClient, TServer> parent);
    private sealed virtual override IEnumerator`1<TClient> System.Collections.Generic.IEnumerable<TClient>.GetEnumerator();
    public Enumerator<TClient> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TClient item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TClient item);
    public sealed virtual void CopyTo(TClient[] array, int arrayIndex);
    public sealed virtual bool Remove(TClient item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(TClient item);
    public sealed virtual void Insert(int index, TClient item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual TClient get_Item(int index);
    public sealed virtual void set_Item(int index, TClient value);
    public void Serialize(BatchStreamWriter writer);
}
internal static class Avalonia.Rendering.Composition.Transport.UnalignedMemoryHelper : object {
    public static T ReadUnaligned(Byte* src);
    public static void WriteUnaligned(Byte* dst, T value);
    private static void UnalignedMemcpy(Byte* dst, Byte* src, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.Vector2KeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<Vector2> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public Vector2KeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, Vector2 value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, Vector2 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.Vector3DKeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<Vector3D> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public Vector3DKeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, Vector3D value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, Vector3D value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.Vector3KeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<Vector3> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public Vector3KeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, Vector3 value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, Vector3 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.Vector4KeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<Vector4> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public Vector4KeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, Vector4 value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, Vector4 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Rendering.Composition.VectorKeyFrameAnimation : KeyFrameAnimation {
    private KeyFrames`1<Vector> _keyFrames;
    private protected IKeyFrames KeyFrames { get; }
    public VectorKeyFrameAnimation(Compositor compositor);
    internal virtual IAnimationInstance CreateInstance(ServerObject targetObject, Nullable`1<ExpressionVariant> finalValue);
    private protected virtual IKeyFrames get_KeyFrames();
    public void InsertKeyFrame(float normalizedProgressKey, Vector value, IEasing easingFunction);
    public void InsertKeyFrame(float normalizedProgressKey, Vector value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Rendering.DefaultRenderTimer : object {
    private int _subscriberCount;
    [NullableAttribute("2")]
private Action`1<TimeSpan> _tick;
    [NullableAttribute("2")]
private IDisposable _subscription;
    [CompilerGeneratedAttribute]
private int <FramesPerSecond>k__BackingField;
    public int FramesPerSecond { get; }
    public bool RunsInBackground { get; }
    public DefaultRenderTimer(int framesPerSecond);
    [CompilerGeneratedAttribute]
public int get_FramesPerSecond();
    public sealed virtual void add_Tick(Action`1<TimeSpan> value);
    public sealed virtual void remove_Tick(Action`1<TimeSpan> value);
    public virtual bool get_RunsInBackground();
    protected void Start();
    protected virtual IDisposable StartCore(Action`1<TimeSpan> tick);
    protected void Stop();
    private void InternalTick(TimeSpan tickCount);
}
public interface Avalonia.Rendering.ICustomHitTest {
    public abstract virtual bool HitTest(Point point);
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
public interface Avalonia.Rendering.IHitTester {
    public abstract virtual IEnumerable`1<Visual> HitTest(Point p, Visual root, Func`2<Visual, bool> filter);
    public abstract virtual Visual HitTestFirst(Point p, Visual root, Func`2<Visual, bool> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.ImmediateRenderer : object {
    public static void Render(Visual visual, DrawingContext context);
    private static Rect GetTransformedBounds(Visual visual);
    public static void Render(DrawingContext context, Visual visual, Rect clipRect);
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
public interface Avalonia.Rendering.IRenderer {
    public RendererDiagnostics Diagnostics { get; }
    public abstract virtual RendererDiagnostics get_Diagnostics();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SceneInvalidated(EventHandler`1<SceneInvalidatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SceneInvalidated(EventHandler`1<SceneInvalidatedEventArgs> value);
    public abstract virtual void AddDirty(Visual visual);
    public abstract virtual void RecalculateChildren(Visual visual);
    public abstract virtual void Resized(Size size);
    public abstract virtual void Paint(Rect rect);
    public abstract virtual void Start();
    public abstract virtual void Stop();
    public abstract virtual ValueTask`1<object> TryGetRenderInterfaceFeature(Type featureType);
}
internal interface Avalonia.Rendering.IRendererWithCompositor {
    [NullableAttribute("1")]
public Compositor Compositor { get; }
    [NullableContextAttribute("1")]
public abstract virtual Compositor get_Compositor();
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
internal interface Avalonia.Rendering.IRenderLoop {
    public bool RunsInBackground { get; }
    public abstract virtual void Add(IRenderLoopTask i);
    public abstract virtual void Remove(IRenderLoopTask i);
    public abstract virtual bool get_RunsInBackground();
}
internal interface Avalonia.Rendering.IRenderLoopTask {
    public abstract virtual void Render();
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Rendering.IRenderRoot {
    public Size ClientSize { get; }
    public IRenderer Renderer { get; }
    public IHitTester HitTester { get; }
    public double RenderScaling { get; }
    public abstract virtual Size get_ClientSize();
    public abstract virtual IRenderer get_Renderer();
    public abstract virtual IHitTester get_HitTester();
    public abstract virtual double get_RenderScaling();
    public abstract virtual Point PointToClient(PixelPoint point);
    public abstract virtual PixelPoint PointToScreen(Point point);
}
[NullableContextAttribute("1")]
[PrivateApiAttribute]
public interface Avalonia.Rendering.IRenderTimer {
    public bool RunsInBackground { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Tick(Action`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Tick(Action`1<TimeSpan> value);
    public abstract virtual bool get_RunsInBackground();
}
[NullableContextAttribute("2")]
internal interface Avalonia.Rendering.ISwapchainImage {
    public PixelSize Size { get; }
    public Task LastPresent { get; }
    public abstract virtual PixelSize get_Size();
    public abstract virtual Task get_LastPresent();
    public abstract virtual void BeginDraw();
    public abstract virtual void Present();
}
[UnstableAttribute]
internal interface Avalonia.Rendering.IVisualBrushInitialize {
    public abstract virtual void EnsureInitialized();
}
[IsReadOnlyAttribute]
internal class Avalonia.Rendering.LayoutPassTiming : ValueType {
    [CompilerGeneratedAttribute]
private int <PassCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Elapsed>k__BackingField;
    public int PassCounter { get; public set; }
    public TimeSpan Elapsed { get; public set; }
    public LayoutPassTiming(int PassCounter, TimeSpan Elapsed);
    [CompilerGeneratedAttribute]
public int get_PassCounter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PassCounter(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Elapsed();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Elapsed(TimeSpan value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(LayoutPassTiming left, LayoutPassTiming right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(LayoutPassTiming left, LayoutPassTiming right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LayoutPassTiming other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& PassCounter, TimeSpan& Elapsed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.OwnedDisposable`1 : ValueType {
    private bool _owns;
    [NullableAttribute("2")]
private T _value;
    public T Value { get; }
    public OwnedDisposable`1(T value, bool owns);
    public T get_Value();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.PlatformRenderInterfaceContextManager : object {
    private IPlatformGraphics _graphics;
    private IPlatformRenderInterfaceContext _backend;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<OwnedDisposable`1<IPlatformGraphicsContext>> _gpuContext;
    private IPlatformGraphicsReadyStateFeature _readyStateFeature;
    [CompilerGeneratedAttribute]
private Action ContextDisposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<IPlatformRenderInterfaceContext> ContextCreated;
    public bool IsReady { get; }
    [NullableAttribute("1")]
public IPlatformRenderInterfaceContext Value { get; }
    internal IPlatformGraphicsContext GpuContext { get; }
    public PlatformRenderInterfaceContextManager(IPlatformGraphics graphics);
    [CompilerGeneratedAttribute]
public void add_ContextDisposed(Action value);
    [CompilerGeneratedAttribute]
public void remove_ContextDisposed(Action value);
    [CompilerGeneratedAttribute]
public void add_ContextCreated(Action`1<IPlatformRenderInterfaceContext> value);
    [CompilerGeneratedAttribute]
public void remove_ContextCreated(Action`1<IPlatformRenderInterfaceContext> value);
    public bool get_IsReady();
    public void EnsureValidBackendContext();
    [NullableContextAttribute("1")]
public IPlatformRenderInterfaceContext get_Value();
    internal IPlatformGraphicsContext get_GpuContext();
    [NullableContextAttribute("1")]
public IDisposable EnsureCurrent();
    [NullableContextAttribute("1")]
public IRenderTarget CreateRenderTarget(IEnumerable`1<object> surfaces);
}
[FlagsAttribute]
public enum Avalonia.Rendering.RendererDebugOverlays : Enum {
    public int value__;
    public static RendererDebugOverlays None;
    public static RendererDebugOverlays Fps;
    public static RendererDebugOverlays DirtyRects;
    public static RendererDebugOverlays LayoutTimeGraph;
    public static RendererDebugOverlays RenderTimeGraph;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Rendering.RendererDiagnostics : object {
    private RendererDebugOverlays _debugOverlays;
    private LayoutPassTiming _lastLayoutPassTiming;
    private PropertyChangedEventArgs _debugOverlaysChangedEventArgs;
    private PropertyChangedEventArgs _lastLayoutPassTimingChangedEventArgs;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public RendererDebugOverlays DebugOverlays { get; public set; }
    internal LayoutPassTiming LastLayoutPassTiming { get; internal set; }
    public RendererDebugOverlays get_DebugOverlays();
    public void set_DebugOverlays(RendererDebugOverlays value);
    internal LayoutPassTiming get_LastLayoutPassTiming();
    internal void set_LastLayoutPassTiming(LayoutPassTiming value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("1")]
protected virtual void OnPropertyChanged(PropertyChangedEventArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.RenderLoop : object {
    private List`1<IRenderLoopTask> _items;
    private List`1<IRenderLoopTask> _itemsCopy;
    [NullableAttribute("2")]
private IRenderTimer _timer;
    private int _inTick;
    public static IRenderLoop LocatorAutoInstance { get; }
    protected IRenderTimer Timer { get; }
    public bool RunsInBackground { get; }
    public RenderLoop(IRenderTimer timer);
    public static IRenderLoop get_LocatorAutoInstance();
    protected IRenderTimer get_Timer();
    public sealed virtual void Add(IRenderLoopTask i);
    public sealed virtual void Remove(IRenderLoopTask i);
    public sealed virtual bool get_RunsInBackground();
    private void TimerTick(TimeSpan time);
}
public interface Avalonia.Rendering.SceneGraph.ICustomDrawOperation {
    public Rect Bounds { get; }
    public abstract virtual Rect get_Bounds();
    public abstract virtual bool HitTest(Point p);
    [NullableContextAttribute("1")]
public abstract virtual void Render(ImmediateDrawingContext context);
}
internal static class Avalonia.Rendering.SceneGraph.LineBoundsHelper : object {
    private static double CalculateAngle(Point p1, Point p2);
    internal static double CalculateOppSide(double angle, double hyp);
    internal static double CalculateAdjSide(double angle, double hyp);
    private static ValueTuple`2<Point, Point> TranslatePointsAlongTangent(Point p1, Point p2, double angle, double distance);
    private static Rect CalculateBounds(Point p1, Point p2, double thickness, double angleToCorner);
    [NullableContextAttribute("1")]
public static Rect CalculateBounds(Point p1, Point p2, IPen p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Rendering.SceneInvalidatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Rect <DirtyRect>k__BackingField;
    [CompilerGeneratedAttribute]
private IRenderRoot <RenderRoot>k__BackingField;
    public Rect DirtyRect { get; }
    public IRenderRoot RenderRoot { get; }
    public SceneInvalidatedEventArgs(IRenderRoot root, Rect dirtyRect);
    [CompilerGeneratedAttribute]
public Rect get_DirtyRect();
    [CompilerGeneratedAttribute]
public IRenderRoot get_RenderRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Rendering.SleepLoopRenderTimer : object {
    [NullableAttribute("2")]
private Action`1<TimeSpan> _tick;
    private int _count;
    private object _lock;
    private bool _running;
    private Stopwatch _st;
    private TimeSpan _timeBetweenTicks;
    public bool RunsInBackground { get; }
    public SleepLoopRenderTimer(int fps);
    public sealed virtual void add_Tick(Action`1<TimeSpan> value);
    public sealed virtual void remove_Tick(Action`1<TimeSpan> value);
    public sealed virtual bool get_RunsInBackground();
    private void LoopProc();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Rendering.SwapchainBase`1 : object {
    [CompilerGeneratedAttribute]
private ICompositionGpuInterop <Interop>k__BackingField;
    [CompilerGeneratedAttribute]
private CompositionDrawingSurface <Target>k__BackingField;
    private List`1<TImage> _pendingImages;
    protected ICompositionGpuInterop Interop { get; }
    protected CompositionDrawingSurface Target { get; }
    public SwapchainBase`1(ICompositionGpuInterop interop, CompositionDrawingSurface target);
    [CompilerGeneratedAttribute]
protected ICompositionGpuInterop get_Interop();
    [CompilerGeneratedAttribute]
protected CompositionDrawingSurface get_Target();
    private static bool IsBroken(TImage image);
    private static bool IsReady(TImage image);
    [NullableContextAttribute("2")]
private TImage CleanupAndFindNextImage(PixelSize size);
    protected abstract virtual TImage CreateImage(PixelSize size);
    protected IDisposable BeginDrawCore(PixelSize size, TImage& image);
    [AsyncStateMachineAttribute("Avalonia.Rendering.SwapchainBase`1/<DisposeAsync>d__13")]
public sealed virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PrivateApiAttribute]
public class Avalonia.Rendering.ThreadProxyRenderTimer : object {
    private IRenderTimer _inner;
    private Stopwatch _stopwatch;
    private Thread _timerThread;
    private AutoResetEvent _autoResetEvent;
    [NullableAttribute("2")]
private Action`1<TimeSpan> _tick;
    private int _subscriberCount;
    private bool _registered;
    public bool RunsInBackground { get; }
    public ThreadProxyRenderTimer(IRenderTimer inner, int maxStackSize);
    public sealed virtual void add_Tick(Action`1<TimeSpan> value);
    public sealed virtual void remove_Tick(Action`1<TimeSpan> value);
    private void RenderTimerThreadFunc();
    private void InnerTick(TimeSpan obj);
    public sealed virtual bool get_RunsInBackground();
}
[PrivateApiAttribute]
public class Avalonia.Rendering.UiThreadRenderTimer : DefaultRenderTimer {
    public bool RunsInBackground { get; }
    public UiThreadRenderTimer(int framesPerSecond);
    public virtual bool get_RunsInBackground();
    [NullableContextAttribute("1")]
protected virtual IDisposable StartCore(Action`1<TimeSpan> tick);
}
internal class Avalonia.Rendering.Utilities.TileBrushCalculator : object {
    private Size _imageSize;
    private Rect _drawRect;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <DestinationRect>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <IntermediateSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix <IntermediateTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <SourceRect>k__BackingField;
    public bool IsValid { get; }
    public Rect DestinationRect { get; }
    public Rect IntermediateClip { get; }
    public Size IntermediateSize { get; }
    public Matrix IntermediateTransform { get; }
    public bool NeedsIntermediate { get; }
    public Rect SourceRect { get; }
    [NullableContextAttribute("1")]
public TileBrushCalculator(ITileBrush brush, Size contentSize, Size targetSize);
    public TileBrushCalculator(TileMode tileMode, Stretch stretch, AlignmentX alignmentX, AlignmentY alignmentY, RelativeRect sourceRect, RelativeRect destinationRect, Size contentSize, Size targetSize);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public Rect get_DestinationRect();
    public Rect get_IntermediateClip();
    [CompilerGeneratedAttribute]
public Size get_IntermediateSize();
    [CompilerGeneratedAttribute]
public Matrix get_IntermediateTransform();
    public bool get_NeedsIntermediate();
    [CompilerGeneratedAttribute]
public Rect get_SourceRect();
    public static Vector CalculateTranslate(AlignmentX alignmentX, AlignmentY alignmentY, Rect sourceRect, Rect destinationRect, Vector scale);
    public static Matrix CalculateIntermediateTransform(TileMode tileMode, Rect sourceRect, Rect destinationRect, Vector scale, Vector translate, Rect& drawRect);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Rendering.ZIndexComparer : object {
    public static ZIndexComparer Instance;
    public static Comparison`1<Visual> ComparisonInstance;
    private static ZIndexComparer();
    [NullableContextAttribute("2")]
public sealed virtual int Compare(Visual x, Visual y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.RenderTargetCorruptedException : Exception {
    public RenderTargetCorruptedException(string message);
    public RenderTargetCorruptedException(Exception innerException);
    public RenderTargetCorruptedException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.RenderTargetNotReadyException : Exception {
    public RenderTargetNotReadyException(string message);
    public RenderTargetNotReadyException(Exception innerException);
    public RenderTargetNotReadyException(string message, Exception innerException);
}
public class Avalonia.RoundedRect : ValueType {
    [CompilerGeneratedAttribute]
private Rect <Rect>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <RadiiTopLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <RadiiTopRight>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <RadiiBottomLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <RadiiBottomRight>k__BackingField;
    public Rect Rect { get; }
    public Vector RadiiTopLeft { get; }
    public Vector RadiiTopRight { get; }
    public Vector RadiiBottomLeft { get; }
    public Vector RadiiBottomRight { get; }
    public bool IsRounded { get; }
    public bool IsUniform { get; }
    public RoundedRect(Rect rect, Vector radiiTopLeft, Vector radiiTopRight, Vector radiiBottomRight, Vector radiiBottomLeft);
    public RoundedRect(Rect rect, double radiusTopLeft, double radiusTopRight, double radiusBottomRight, double radiusBottomLeft);
    public RoundedRect(Rect rect, Vector radii);
    public RoundedRect(Rect rect, double radiusX, double radiusY);
    public RoundedRect(Rect rect, double radius);
    public RoundedRect(Rect rect);
    public RoundedRect(Rect& bounds, CornerRadius& radius);
    public bool Equals(RoundedRect other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RoundedRect left, RoundedRect right);
    public static bool op_Inequality(RoundedRect left, RoundedRect right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Rect get_Rect();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector get_RadiiTopLeft();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector get_RadiiTopRight();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector get_RadiiBottomLeft();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector get_RadiiBottomRight();
    public static RoundedRect op_Implicit(Rect r);
    public bool get_IsRounded();
    public bool get_IsUniform();
    public RoundedRect Inflate(double dx, double dy);
    public RoundedRect Deflate(double dx, double dy);
    internal bool IsEmpty();
    private static bool IsOutsideCorner(double dx, double dy, double radius);
    public bool ContainsExclusive(Point p);
}
[IsReadOnlyAttribute]
public class Avalonia.Size : ValueType {
    public static Size Infinity;
    private double _width;
    private double _height;
    public double AspectRatio { get; }
    public double Width { get; }
    public double Height { get; }
    public Size(double width, double height);
    public Size(Vector2 vector2);
    private static Size();
    public double get_AspectRatio();
    public double get_Width();
    public double get_Height();
    public static bool op_Equality(Size left, Size right);
    public static bool op_Inequality(Size left, Size right);
    public static Size op_Multiply(Size size, Vector scale);
    public static Size op_Division(Size size, Vector scale);
    public static Vector op_Division(Size left, Size right);
    public static Size op_Multiply(Size size, double scale);
    public static Size op_Division(Size size, double scale);
    public static Size op_Addition(Size size, Size toAdd);
    public static Size op_Subtraction(Size size, Size toSubtract);
    [NullableContextAttribute("1")]
public static Size Parse(string s);
    public Size Constrain(Size constraint);
    public Size Deflate(Thickness thickness);
    public sealed virtual bool Equals(Size other);
    public bool NearlyEquals(Size other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Size Inflate(Thickness thickness);
    public Size WithWidth(double width);
    public Size WithHeight(double height);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public void Deconstruct(Double& width, Double& height);
}
[AttributeUsageAttribute("64")]
internal class Avalonia.SourceGenerator.GenerateEnumValueDictionaryAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class Avalonia.SourceGenerator.GenerateEnumValueListAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Avalonia.SourceGenerator.GetProcAddressAttribute : Attribute {
    public GetProcAddressAttribute(string proc);
    public GetProcAddressAttribute(string proc, bool optional);
    public GetProcAddressAttribute(bool optional);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Avalonia.SourceGenerator.SubtypesFactoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    public string Namespace { get; }
    public Type BaseType { get; }
    public SubtypesFactoryAttribute(Type baseType, string namespace);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public Type get_BaseType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.StreamBindingExtensions : object {
    internal static string StreamBindingName;
    private static StreamBindingExtensions();
    [ExtensionAttribute]
public static T StreamBinding(Task`1<T> this);
    [ExtensionAttribute]
public static object StreamBinding(Task this);
    [ExtensionAttribute]
public static T StreamBinding(IObservable`1<T> this);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.StyledElement : Animatable {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<object> DataContextProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<StyledElement, string> NameProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<StyledElement, StyledElement> ParentProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<StyledElement, AvaloniaObject> TemplatedParentProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<ControlTheme> ThemeProperty;
    private static ControlTheme s_invalidTheme;
    private int _initCount;
    [NullableAttribute("2")]
private string _name;
    [NullableAttribute("2")]
private Classes _classes;
    [NullableAttribute("2")]
private ILogicalRoot _logicalRoot;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IAvaloniaList`1<ILogical> _logicalChildren;
    [NullableAttribute("2")]
private IResourceDictionary _resources;
    [NullableAttribute("2")]
private Styles _styles;
    private bool _stylesApplied;
    private bool _themeApplied;
    private bool _templatedParentThemeApplied;
    [NullableAttribute("2")]
private AvaloniaObject _templatedParent;
    private bool _dataContextUpdating;
    [NullableAttribute("2")]
private ControlTheme _implicitTheme;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<LogicalTreeAttachmentEventArgs> AttachedToLogicalTree;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<LogicalTreeAttachmentEventArgs> DetachedFromLogicalTree;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler DataContextChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Initialized;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ResourcesChangedEventArgs> ResourcesChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler ActualThemeVariantChanged;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private StyledElement <Parent>k__BackingField;
    [NullableAttribute("2")]
public string Name { get; public set; }
    public Classes Classes { get; }
    [NullableAttribute("2")]
public object DataContext { get; public set; }
    public bool IsInitialized { get; private set; }
    public Styles Styles { get; }
    public Type StyleKey { get; }
    public IResourceDictionary Resources { get; public set; }
    [NullableAttribute("2")]
public AvaloniaObject TemplatedParent { get; internal set; }
    [NullableAttribute("2")]
public ControlTheme Theme { get; public set; }
    protected internal IAvaloniaList`1<ILogical> LogicalChildren { get; }
    protected IPseudoClasses PseudoClasses { get; }
    protected Type StyleKeyOverride { get; }
    private bool Avalonia.LogicalTree.ILogical.IsAttachedToLogicalTree { get; }
    [NullableAttribute("2")]
public StyledElement Parent { get; private set; }
    public ThemeVariant ActualThemeVariant { get; }
    [NullableAttribute("2")]
private ILogical Avalonia.LogicalTree.ILogical.LogicalParent { get; }
    private IAvaloniaReadOnlyList`1<ILogical> Avalonia.LogicalTree.ILogical.LogicalChildren { get; }
    private bool Avalonia.Controls.IResourceNode.HasResources { get; }
    private IAvaloniaReadOnlyList`1<string> Avalonia.Styling.IStyleable.Classes { get; }
    private bool Avalonia.Styling.IStyleHost.IsStylesInitialized { get; }
    [NullableAttribute("2")]
private IStyleHost Avalonia.Styling.IStyleHost.StylingParent { get; }
    private static StyledElement();
    [CompilerGeneratedAttribute]
public sealed virtual void add_AttachedToLogicalTree(EventHandler`1<LogicalTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AttachedToLogicalTree(EventHandler`1<LogicalTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DetachedFromLogicalTree(EventHandler`1<LogicalTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DetachedFromLogicalTree(EventHandler`1<LogicalTreeAttachmentEventArgs> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_DataContextChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_DataContextChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_Initialized(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_Initialized(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ResourcesChanged(EventHandler`1<ResourcesChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ResourcesChanged(EventHandler`1<ResourcesChangedEventArgs> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_ActualThemeVariantChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_ActualThemeVariantChanged(EventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public void set_Name(string value);
    public Classes get_Classes();
    [NullableContextAttribute("2")]
public sealed virtual object get_DataContext();
    [NullableContextAttribute("2")]
public sealed virtual void set_DataContext(object value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public sealed virtual Styles get_Styles();
    public sealed virtual Type get_StyleKey();
    public IResourceDictionary get_Resources();
    public void set_Resources(IResourceDictionary value);
    [NullableContextAttribute("2")]
public sealed virtual AvaloniaObject get_TemplatedParent();
    [NullableContextAttribute("2")]
internal void set_TemplatedParent(AvaloniaObject value);
    [NullableContextAttribute("2")]
public ControlTheme get_Theme();
    [NullableContextAttribute("2")]
public void set_Theme(ControlTheme value);
    protected internal IAvaloniaList`1<ILogical> get_LogicalChildren();
    protected IPseudoClasses get_PseudoClasses();
    protected virtual Type get_StyleKeyOverride();
    private sealed virtual override bool Avalonia.LogicalTree.ILogical.get_IsAttachedToLogicalTree();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public StyledElement get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Parent(StyledElement value);
    public sealed virtual ThemeVariant get_ActualThemeVariant();
    [NullableContextAttribute("2")]
private sealed virtual override ILogical Avalonia.LogicalTree.ILogical.get_LogicalParent();
    private sealed virtual override IAvaloniaReadOnlyList`1<ILogical> Avalonia.LogicalTree.ILogical.get_LogicalChildren();
    private sealed virtual override bool Avalonia.Controls.IResourceNode.get_HasResources();
    private sealed virtual override IAvaloniaReadOnlyList`1<string> Avalonia.Styling.IStyleable.get_Classes();
    private sealed virtual override bool Avalonia.Styling.IStyleHost.get_IsStylesInitialized();
    [NullableContextAttribute("2")]
private sealed virtual override IStyleHost Avalonia.Styling.IStyleHost.get_StylingParent();
    public virtual void BeginInit();
    public virtual void EndInit();
    public bool ApplyStyling();
    protected void InitializeIfNeeded();
    private sealed virtual override void Avalonia.LogicalTree.ILogical.NotifyAttachedToLogicalTree(LogicalTreeAttachmentEventArgs e);
    private sealed virtual override void Avalonia.LogicalTree.ILogical.NotifyDetachedFromLogicalTree(LogicalTreeAttachmentEventArgs e);
    private sealed virtual override void Avalonia.LogicalTree.ILogical.NotifyResourcesChanged(ResourcesChangedEventArgs e);
    private sealed virtual override void Avalonia.Controls.IResourceHost.NotifyHostedResourcesChanged(ResourcesChangedEventArgs e);
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetResource(object key, ThemeVariant theme, Object& value);
    [NullableContextAttribute("2")]
private sealed virtual override void Avalonia.Controls.ISetLogicalParent.SetParent(ILogical parent);
    [NullableContextAttribute("2")]
private sealed virtual override void Avalonia.Controls.ISetInheritanceParent.SetParent(AvaloniaObject parent);
    private sealed virtual override void Avalonia.Styling.IStyleHost.StylesAdded(IReadOnlyList`1<IStyle> styles);
    private sealed virtual override void Avalonia.Styling.IStyleHost.StylesRemoved(IReadOnlyList`1<IStyle> styles);
    protected virtual void LogicalChildrenCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    internal virtual void NotifyChildResourcesChanged(ResourcesChangedEventArgs e);
    protected virtual void OnAttachedToLogicalTree(LogicalTreeAttachmentEventArgs e);
    protected virtual void OnDetachedFromLogicalTree(LogicalTreeAttachmentEventArgs e);
    protected virtual void OnDataContextChanged(EventArgs e);
    protected virtual void OnDataContextBeginUpdate();
    protected virtual void OnDataContextEndUpdate();
    protected virtual void OnInitialized();
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    private protected virtual void OnControlThemeChanged();
    internal virtual void OnTemplatedParentControlThemeChanged();
    [NullableContextAttribute("2")]
internal ControlTheme GetEffectiveTheme();
    internal virtual void InvalidateStyles(bool recurse);
    internal static Type GetStyleKey(StyledElement e);
    private static void DataContextNotifying(AvaloniaObject o, bool updateStarted);
    private static void DataContextNotifying(StyledElement element, bool updateStarted);
    [NullableContextAttribute("2")]
private static ILogicalRoot FindLogicalRoot(IStyleHost e);
    private sealed virtual override void Avalonia.Collections.IAvaloniaListItemValidator<Avalonia.LogicalTree.ILogical>.Validate(ILogical item);
    private void ApplyControlTheme();
    private void ApplyTemplatedParentControlTheme();
    private void ApplyControlTheme(ControlTheme theme, FrameType type);
    private void ApplyStyles(IStyleHost host);
    private void ApplyStyle(IStyle style, IStyleHost host, FrameType type);
    private void ReevaluateImplicitTheme();
    private void OnAttachedToLogicalTreeCore(LogicalTreeAttachmentEventArgs e);
    private void OnDetachedFromLogicalTreeCore(LogicalTreeAttachmentEventArgs e);
    private void OnDataContextChangedCore(AvaloniaPropertyChangedEventArgs e);
    private void SetLogicalParent(IList children);
    private void ClearLogicalParent(IList children);
    private void DetachStyles(IReadOnlyList`1<Style> styles);
    [NullableContextAttribute("2")]
private void NotifyResourcesChanged(ResourcesChangedEventArgs e, bool propagate);
    internal virtual void BuildDebugDisplay(StringBuilder builder, bool includeContent);
    private static IReadOnlyList`1<Style> FlattenStyles(IReadOnlyList`1<IStyle> styles);
    private static bool HasSettersOrAnimations(IReadOnlyList`1<IStyle> styles);
    private static IReadOnlyList`1<StyleBase> RecurseStyles(IReadOnlyList`1<IStyle> styles);
    private static void RecurseStyles(IReadOnlyList`1<IStyle> styles, List`1<StyleBase> result);
    [CompilerGeneratedAttribute]
internal static void <FlattenStyles>g__FlattenStyle|135_0(IStyle style, List`1& result);
    [CompilerGeneratedAttribute]
internal static void <FlattenStyles>g__FlattenStyles|135_1(IReadOnlyList`1<IStyle> styles, List`1& result);
    [CompilerGeneratedAttribute]
internal static bool <HasSettersOrAnimations>g__StyleHasSettersOrAnimations|136_0(IStyle style);
}
[ExtensionAttribute]
public static class Avalonia.StyledElementExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IDisposable BindClass(StyledElement target, string className, IBinding source, object anchor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Avalonia.StyledProperty`1 : AvaloniaProperty`1<TValue> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Optional`1<TValue> _singleDefaultValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<TValue, bool> <ValidateValue>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<TValue, bool> ValidateValue { get; }
    internal StyledProperty`1(string name, Type ownerType, Type hostType, StyledPropertyMetadata`1<TValue> metadata, bool inherits, Func`2<TValue, bool> validate, Action`2<AvaloniaObject, bool> notifying);
    [CompilerGeneratedAttribute]
public Func`2<TValue, bool> get_ValidateValue();
    public StyledProperty`1<TValue> AddOwner(StyledPropertyMetadata`1<TValue> metadata);
    public TValue CoerceValue(AvaloniaObject instance, TValue baseValue);
    public TValue GetDefaultValue(Type type);
    public TValue GetDefaultValue(AvaloniaObject owner);
    public StyledPropertyMetadata`1<TValue> GetMetadata(Type type);
    public StyledPropertyMetadata`1<TValue> GetMetadata(AvaloniaObject owner);
    private static StyledPropertyMetadata`1<TValue> CastMetadata(AvaloniaPropertyMetadata metadata);
    public void OverrideDefaultValue(TValue defaultValue);
    public void OverrideDefaultValue(Type type, TValue defaultValue);
    public void OverrideMetadata(StyledPropertyMetadata`1<TValue> metadata);
    public void OverrideMetadata(Type type, StyledPropertyMetadata`1<TValue> metadata);
    public virtual string ToString();
    private sealed virtual override object Avalonia.IStyledPropertyAccessor.GetDefaultValue(Type type);
    private sealed virtual override object Avalonia.IStyledPropertyAccessor.GetDefaultValue(AvaloniaObject owner);
    [NullableContextAttribute("2")]
private sealed virtual override bool Avalonia.IStyledPropertyAccessor.ValidateValue(object value);
    internal virtual EffectiveValue CreateEffectiveValue(AvaloniaObject o);
    internal virtual void RouteClearValue(AvaloniaObject o);
    internal virtual void RouteCoerceDefaultValue(AvaloniaObject o);
    internal virtual object RouteGetValue(AvaloniaObject o);
    internal virtual object RouteGetBaseValue(AvaloniaObject o);
    [NullableContextAttribute("2")]
internal virtual IDisposable RouteSetValue(AvaloniaObject target, object value, BindingPriority priority);
    internal virtual void RouteSetCurrentValue(AvaloniaObject target, object value);
    internal virtual IDisposable RouteBind(AvaloniaObject target, IObservable`1<object> source, BindingPriority priority);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
private bool ShouldSetValue(AvaloniaObject target, object value, TValue& converted);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.StyledPropertyMetadata`1 : AvaloniaPropertyMetadata {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Optional`1<TValue> _defaultValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`3<AvaloniaObject, TValue, TValue> <CoerceValue>k__BackingField;
    public TValue DefaultValue { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`3<AvaloniaObject, TValue, TValue> CoerceValue { get; private set; }
    [NullableAttribute("2")]
private object Avalonia.IStyledPropertyMetadata.DefaultValue { get; }
    public StyledPropertyMetadata`1(Optional`1<TValue> defaultValue, BindingMode defaultBindingMode, Func`3<AvaloniaObject, TValue, TValue> coerce, bool enableDataValidation);
    public TValue get_DefaultValue();
    [CompilerGeneratedAttribute]
public Func`3<AvaloniaObject, TValue, TValue> get_CoerceValue();
    [CompilerGeneratedAttribute]
private void set_CoerceValue(Func`3<AvaloniaObject, TValue, TValue> value);
    [NullableContextAttribute("2")]
private sealed virtual override object Avalonia.IStyledPropertyMetadata.get_DefaultValue();
    public virtual void Merge(AvaloniaPropertyMetadata baseMetadata, AvaloniaProperty property);
    public virtual AvaloniaPropertyMetadata GenerateTypeSafeMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.StyledPropertyNonGenericHelper : object {
    [DoesNotReturnAttribute]
public static void ThrowInvalidValue(string propertyName, object value, string paramName);
    public static void ThrowInvalidDefaultValue(string propertyName, object defaultValue, string paramName);
}
internal class Avalonia.Styling.Activators.AndActivator : StyleActivatorBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IStyleActivator> _sources;
    public int Count { get; }
    public int get_Count();
    [NullableContextAttribute("1")]
public void Add(IStyleActivator activator);
    private sealed virtual override void Avalonia.Styling.Activators.IStyleActivatorSink.OnNext(bool value);
    protected virtual bool EvaluateIsActive();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.Activators.AndActivatorBuilder : ValueType {
    private IStyleActivator _single;
    private AndActivator _multiple;
    public void Add(IStyleActivator activator);
    [NullableContextAttribute("1")]
public IStyleActivator Get();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Styling.Activators.IStyleActivator {
    public bool IsSubscribed { get; }
    public abstract virtual bool get_IsSubscribed();
    public abstract virtual bool GetIsActive();
    public abstract virtual void Subscribe(IStyleActivatorSink sink);
    public abstract virtual void Unsubscribe(IStyleActivatorSink sink);
}
internal interface Avalonia.Styling.Activators.IStyleActivatorSink {
    public abstract virtual void OnNext(bool value);
}
internal class Avalonia.Styling.Activators.NotActivator : StyleActivatorBase {
    [NullableAttribute("1")]
private IStyleActivator _source;
    [NullableContextAttribute("1")]
public NotActivator(IStyleActivator source);
    private sealed virtual override void Avalonia.Styling.Activators.IStyleActivatorSink.OnNext(bool value);
    protected virtual bool EvaluateIsActive();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Styling.Activators.NthChildActivator : StyleActivatorBase {
    private ILogical _control;
    private IChildIndexProvider _provider;
    private int _step;
    private int _offset;
    private bool _reversed;
    private int _index;
    public NthChildActivator(ILogical control, IChildIndexProvider provider, int step, int offset, bool reversed);
    protected virtual bool EvaluateIsActive();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
    private void ChildIndexChanged(object sender, ChildIndexChangedEventArgs e);
}
internal class Avalonia.Styling.Activators.OrActivator : StyleActivatorBase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IStyleActivator> _sources;
    public int Count { get; }
    public int get_Count();
    [NullableContextAttribute("1")]
public void Add(IStyleActivator activator);
    private sealed virtual override void Avalonia.Styling.Activators.IStyleActivatorSink.OnNext(bool value);
    protected virtual bool EvaluateIsActive();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.Activators.OrActivatorBuilder : ValueType {
    private IStyleActivator _single;
    private OrActivator _multiple;
    public int Count { get; }
    public int get_Count();
    public void Add(IStyleActivator activator);
    [NullableContextAttribute("1")]
public IStyleActivator Get();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Styling.Activators.PropertyEqualsActivator : StyleActivatorBase {
    private StyledElement _control;
    private AvaloniaProperty _property;
    [NullableAttribute("2")]
private object _value;
    [NullableAttribute("2")]
private IDisposable _subscription;
    public PropertyEqualsActivator(StyledElement control, AvaloniaProperty property, object value);
    protected virtual bool EvaluateIsActive();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
    private sealed virtual override void System.IObserver<System.Object>.OnCompleted();
    private sealed virtual override void System.IObserver<System.Object>.OnError(Exception error);
    [NullableContextAttribute("2")]
private sealed virtual override void System.IObserver<System.Object>.OnNext(object value);
}
internal abstract class Avalonia.Styling.Activators.StyleActivatorBase : object {
    [NullableAttribute("2")]
private IStyleActivatorSink _sink;
    private Nullable`1<bool> _value;
    public bool IsSubscribed { get; }
    public sealed virtual bool GetIsActive();
    public sealed virtual bool get_IsSubscribed();
    [NullableContextAttribute("1")]
public sealed virtual void Subscribe(IStyleActivatorSink sink);
    [NullableContextAttribute("1")]
public sealed virtual void Unsubscribe(IStyleActivatorSink sink);
    public sealed virtual void Dispose();
    protected abstract virtual bool EvaluateIsActive();
    protected bool ReevaluateIsActive();
    protected abstract virtual void Initialize();
    protected abstract virtual void Deinitialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Styling.Activators.StyleClassActivator : StyleActivatorBase {
    private IList`1<string> _match;
    private Classes _classes;
    public StyleClassActivator(Classes classes, IList`1<string> match);
    public static bool AreClassesMatching(IReadOnlyList`1<string> classes, IList`1<string> toMatch);
    private sealed virtual override void Avalonia.Controls.IClassesChangedListener.Changed();
    protected virtual bool EvaluateIsActive();
    protected virtual void Initialize();
    protected virtual void Deinitialize();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.ChildSelector : Selector {
    [NullableAttribute("1")]
private Selector _parent;
    private string _selectorString;
    internal bool InTemplate { get; }
    internal bool IsCombinator { get; }
    internal Type TargetType { get; }
    [NullableContextAttribute("1")]
public ChildSelector(Selector parent);
    internal virtual bool get_InTemplate();
    internal virtual bool get_IsCombinator();
    internal virtual Type get_TargetType();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Styling.ControlTheme : StyleBase {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlTheme <BasedOn>k__BackingField;
    public Type TargetType { get; public set; }
    public ControlTheme BasedOn { get; public set; }
    [NullableContextAttribute("1")]
public ControlTheme(Type targetType);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
public ControlTheme get_BasedOn();
    [CompilerGeneratedAttribute]
public void set_BasedOn(ControlTheme value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal virtual void SetParent(StyleBase parent);
    [NullableContextAttribute("1")]
internal SelectorMatchResult TryAttach(StyledElement target, FrameType type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.DescendantSelector : Selector {
    [NullableAttribute("1")]
private Selector _parent;
    private string _selectorString;
    internal bool IsCombinator { get; }
    internal bool InTemplate { get; }
    internal Type TargetType { get; }
    public DescendantSelector(Selector parent);
    internal virtual bool get_IsCombinator();
    internal virtual bool get_InTemplate();
    internal virtual Type get_TargetType();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
}
internal class Avalonia.Styling.DirectPropertySetterBindingInstance : object {
}
internal class Avalonia.Styling.DirectPropertySetterInstance : object {
}
[NotClientImplementableAttribute]
public interface Avalonia.Styling.IGlobalStyles {
    [CompilerGeneratedAttribute]
public abstract virtual void add_GlobalStylesAdded(Action`1<IReadOnlyList`1<IStyle>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GlobalStylesAdded(Action`1<IReadOnlyList`1<IStyle>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GlobalStylesRemoved(Action`1<IReadOnlyList`1<IStyle>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GlobalStylesRemoved(Action`1<IReadOnlyList`1<IStyle>> value);
}
[UnstableAttribute]
public interface Avalonia.Styling.ISetterInstance {
}
[NullableContextAttribute("1")]
public interface Avalonia.Styling.ISetterValue {
    public abstract virtual void Initialize(SetterBase setter);
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Styling.IStyle {
    public IReadOnlyList`1<IStyle> Children { get; }
    public abstract virtual IReadOnlyList`1<IStyle> get_Children();
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("This interface may be removed in 12.0. Use StyledElement, or override StyledElement.StyleKeyOverride to override the StyleKey for a class.")]
public interface Avalonia.Styling.IStyleable {
    public IAvaloniaReadOnlyList`1<string> Classes { get; }
    [ObsoleteAttribute("Override StyledElement.StyleKeyOverride instead.")]
public Type StyleKey { get; }
    [NullableAttribute("2")]
public AvaloniaObject TemplatedParent { get; }
    public abstract virtual IAvaloniaReadOnlyList`1<string> get_Classes();
    public abstract virtual Type get_StyleKey();
    [NullableContextAttribute("2")]
public abstract virtual AvaloniaObject get_TemplatedParent();
}
[NullableContextAttribute("1")]
[NotClientImplementableAttribute]
public interface Avalonia.Styling.IStyleHost {
    public bool IsStylesInitialized { get; }
    public Styles Styles { get; }
    [NullableAttribute("2")]
public IStyleHost StylingParent { get; }
    public abstract virtual bool get_IsStylesInitialized();
    public abstract virtual Styles get_Styles();
    [NullableContextAttribute("2")]
public abstract virtual IStyleHost get_StylingParent();
    public abstract virtual void StylesAdded(IReadOnlyList`1<IStyle> styles);
    public abstract virtual void StylesRemoved(IReadOnlyList`1<IStyle> styles);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Styling.IStyleInstance {
    public IStyle Source { get; }
    public bool HasActivator { get; }
    public bool IsActive { get; }
    public abstract virtual IStyle get_Source();
    public abstract virtual bool get_HasActivator();
    public abstract virtual bool get_IsActive();
}
[NullableContextAttribute("2")]
public interface Avalonia.Styling.ITemplate {
    public abstract virtual object Build();
}
[NullableContextAttribute("2")]
public interface Avalonia.Styling.IThemeVariantHost {
    [NullableAttribute("1")]
public ThemeVariant ActualThemeVariant { get; }
    [NullableContextAttribute("1")]
public abstract virtual ThemeVariant get_ActualThemeVariant();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ActualThemeVariantChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ActualThemeVariantChanged(EventHandler value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.NestingSelector : Selector {
    internal bool InTemplate { get; }
    internal bool IsCombinator { get; }
    internal Type TargetType { get; }
    internal virtual bool get_InTemplate();
    internal virtual bool get_IsCombinator();
    internal virtual Type get_TargetType();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.NotSelector : Selector {
    private Selector _previous;
    [NullableAttribute("1")]
private Selector _argument;
    private string _selectorString;
    internal bool InTemplate { get; }
    internal bool IsCombinator { get; }
    internal Type TargetType { get; }
    [NullableContextAttribute("1")]
public NotSelector(Selector previous, Selector argument);
    internal virtual bool get_InTemplate();
    internal virtual bool get_IsCombinator();
    internal virtual Type get_TargetType();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.NthChildSelector : Selector {
    [NullableAttribute("1")]
private static string NthChildSelectorName;
    [NullableAttribute("1")]
private static string NthLastChildSelectorName;
    private Selector _previous;
    private bool _reversed;
    [CompilerGeneratedAttribute]
private int <Step>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    internal bool InTemplate { get; }
    internal bool IsCombinator { get; }
    internal Type TargetType { get; }
    public int Step { get; }
    public int Offset { get; }
    protected internal NthChildSelector(Selector previous, int step, int offset, bool reversed);
    public NthChildSelector(Selector previous, int step, int offset);
    internal virtual bool get_InTemplate();
    internal virtual bool get_IsCombinator();
    internal virtual Type get_TargetType();
    [CompilerGeneratedAttribute]
public int get_Step();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    [NullableContextAttribute("1")]
internal static SelectorMatch Evaluate(int index, IChildIndexProvider childIndexProvider, int step, int offset, bool reversed);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
}
internal class Avalonia.Styling.NthLastChildSelector : NthChildSelector {
    [NullableContextAttribute("2")]
public NthLastChildSelector(Selector previous, int step, int offset);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.OrSelector : Selector {
    [NullableAttribute("1")]
private IReadOnlyList`1<Selector> _selectors;
    private string _selectorString;
    private Type _targetType;
    internal bool InTemplate { get; }
    internal bool IsCombinator { get; }
    internal Type TargetType { get; }
    [NullableContextAttribute("1")]
public OrSelector(IReadOnlyList`1<Selector> selectors);
    internal virtual bool get_InTemplate();
    internal virtual bool get_IsCombinator();
    internal virtual Type get_TargetType();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
    internal virtual void ValidateNestingSelector(bool inControlTheme);
    private Type EvaluateTargetType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.PropertyEqualsSelector : Selector {
    private Selector _previous;
    [NullableAttribute("1")]
private AvaloniaProperty _property;
    private object _value;
    private string _selectorString;
    internal bool InTemplate { get; }
    internal bool IsCombinator { get; }
    internal Type TargetType { get; }
    public PropertyEqualsSelector(Selector previous, AvaloniaProperty property, object value);
    internal virtual bool get_InTemplate();
    internal virtual bool get_IsCombinator();
    internal virtual Type get_TargetType();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2067")]
internal static bool Compare(Type propertyType, object propertyValue, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Styling.PropertySetterInstance`1 : SingleSubscriberObservableBase`1<BindingValue`1<T>> {
    private StyledElement _target;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private StyledProperty`1<T> _styledProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private DirectPropertyBase`1<T> _directProperty;
    private T _value;
    [NullableAttribute("2")]
private IDisposable _subscription;
    [NullableAttribute("0")]
private State<T> _state;
    private bool IsActive { get; }
    public PropertySetterInstance`1(StyledElement target, StyledProperty`1<T> property, T value);
    public PropertySetterInstance`1(StyledElement target, DirectPropertyBase`1<T> property, T value);
    private bool get_IsActive();
    public void Start(bool hasActivator);
    public void Activate();
    public void Deactivate();
    public virtual void Dispose();
    protected virtual void Subscribed();
    protected virtual void Unsubscribed();
    private void PublishNext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Styling.PropertySetterTemplateInstance : object {
    private ITemplate _template;
    [NullableAttribute("2")]
private object _value;
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    public AvaloniaProperty Property { get; }
    public PropertySetterTemplateInstance(AvaloniaProperty property, ITemplate template);
    [CompilerGeneratedAttribute]
public sealed virtual AvaloniaProperty get_Property();
    public sealed virtual bool HasValue();
    [NullableContextAttribute("2")]
public sealed virtual object GetValue();
    [NullableContextAttribute("2")]
private sealed virtual override bool Avalonia.PropertyStore.IValueEntry.GetDataValidationState(BindingValueType& state, Exception& error);
    private sealed virtual override void Avalonia.PropertyStore.IValueEntry.Unsubscribe();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Styling.Selector : object {
    internal bool InTemplate { get; }
    internal bool IsCombinator { get; }
    [NullableAttribute("2")]
internal Type TargetType { get; }
    internal abstract virtual bool get_InTemplate();
    internal abstract virtual bool get_IsCombinator();
    [NullableContextAttribute("2")]
internal abstract virtual Type get_TargetType();
    internal SelectorMatch Match(StyledElement control, IStyle parent, bool subscribe);
    public virtual string ToString();
    public abstract virtual string ToString(Style owner);
    private protected abstract virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    [NullableContextAttribute("2")]
private protected abstract virtual Selector MovePrevious();
    [NullableContextAttribute("2")]
private protected abstract virtual Selector MovePreviousOrParent();
    internal virtual void ValidateNestingSelector(bool inControlTheme);
    private static SelectorMatch MatchUntilCombinator(StyledElement control, Selector start, IStyle parent, bool subscribe, Selector& combinator);
    private static SelectorMatchResult Match(StyledElement control, Selector selector, IStyle parent, bool subscribe, AndActivatorBuilder& activators, Selector& combinator);
}
[IsReadOnlyAttribute]
internal class Avalonia.Styling.SelectorMatch : ValueType {
    public static SelectorMatch NeverThisType;
    public static SelectorMatch NeverThisInstance;
    public static SelectorMatch AlwaysThisType;
    public static SelectorMatch AlwaysThisInstance;
    [CompilerGeneratedAttribute]
private SelectorMatchResult <Result>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IStyleActivator <Activator>k__BackingField;
    public bool IsMatch { get; }
    public SelectorMatchResult Result { get; }
    [NullableAttribute("2")]
public IStyleActivator Activator { get; }
    [NullableContextAttribute("1")]
public SelectorMatch(IStyleActivator match);
    public SelectorMatch(SelectorMatchResult result);
    private static SelectorMatch();
    public bool get_IsMatch();
    [CompilerGeneratedAttribute]
public SelectorMatchResult get_Result();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IStyleActivator get_Activator();
    public SelectorMatch And(SelectorMatch& other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SelectorMatch left, SelectorMatch right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SelectorMatch left, SelectorMatch right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SelectorMatch other);
}
internal enum Avalonia.Styling.SelectorMatchResult : Enum {
    public int value__;
    public static SelectorMatchResult NeverThisType;
    public static SelectorMatchResult NeverThisInstance;
    public static SelectorMatchResult Sometimes;
    public static SelectorMatchResult AlwaysThisInstance;
    public static SelectorMatchResult AlwaysThisType;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Styling.Selectors : object {
    [ExtensionAttribute]
public static Selector Child(Selector previous);
    [ExtensionAttribute]
public static Selector Class(Selector previous, string name);
    [ExtensionAttribute]
public static Selector Descendant(Selector previous);
    [ExtensionAttribute]
public static Selector Is(Selector previous, Type type);
    [ExtensionAttribute]
public static Selector Is(Selector previous);
    [ExtensionAttribute]
public static Selector Name(Selector previous, string name);
    [ExtensionAttribute]
public static Selector Nesting(Selector previous);
    [ExtensionAttribute]
public static Selector Not(Selector previous, Func`2<Selector, Selector> argument);
    [ExtensionAttribute]
public static Selector Not(Selector previous, Selector argument);
    [ExtensionAttribute]
public static Selector NthChild(Selector previous, int step, int offset);
    [ExtensionAttribute]
public static Selector NthLastChild(Selector previous, int step, int offset);
    [ExtensionAttribute]
public static Selector OfType(Selector previous, Type type);
    [ExtensionAttribute]
public static Selector OfType(Selector previous);
    public static Selector Or(Selector[] selectors);
    public static Selector Or(IReadOnlyList`1<Selector> selectors);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Selector PropertyEquals(Selector previous, AvaloniaProperty`1<T> property, object value);
    [ExtensionAttribute]
public static Selector PropertyEquals(Selector previous, AvaloniaProperty property, object value);
    [ExtensionAttribute]
public static Selector Template(Selector previous);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Styling.Setter : SetterBase {
    private object _value;
    private DirectPropertySetterInstance _direct;
    [CompilerGeneratedAttribute]
private AvaloniaProperty <Property>k__BackingField;
    public AvaloniaProperty Property { get; public set; }
    [ContentAttribute]
[AssignBindingAttribute]
[DependsOnAttribute("Property")]
public object Value { get; public set; }
    [NullableAttribute("1")]
private AvaloniaProperty Avalonia.PropertyStore.IValueEntry.Property { get; }
    [NullableContextAttribute("1")]
public Setter(AvaloniaProperty property, object value);
    [CompilerGeneratedAttribute]
public sealed virtual AvaloniaProperty get_Property();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Property(AvaloniaProperty value);
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    [NullableContextAttribute("1")]
private sealed virtual override AvaloniaProperty Avalonia.PropertyStore.IValueEntry.get_Property();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override void Avalonia.PropertyStore.IValueEntry.Unsubscribe();
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
internal virtual ISetterInstance Instance(IStyleInstance instance, StyledElement target);
    private sealed virtual override bool Avalonia.PropertyStore.IValueEntry.HasValue();
    private sealed virtual override object Avalonia.PropertyStore.IValueEntry.GetValue();
    private sealed virtual override bool Avalonia.PropertyStore.IValueEntry.GetDataValidationState(BindingValueType& state, Exception& error);
    [NullableContextAttribute("1")]
private AvaloniaProperty EnsureProperty();
    [NullableContextAttribute("1")]
private ISetterInstance SetBinding(StyleInstance instance, AvaloniaObject target, IBinding2 binding);
    [NullableContextAttribute("1")]
private ISetterInstance SetDirectValue(StyledElement target);
}
public abstract class Avalonia.Styling.SetterBase : object {
    [NullableContextAttribute("1")]
internal abstract virtual ISetterInstance Instance(IStyleInstance styleInstance, StyledElement target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Styling.Style : StyleBase {
    private Selector _selector;
    public Selector Selector { get; public set; }
    public Style(Func`2<Selector, Selector> selector);
    public Selector get_Selector();
    public void set_Selector(Selector value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal virtual void SetParent(StyleBase parent);
    [NullableContextAttribute("1")]
internal SelectorMatchResult TryAttach(StyledElement target, object host, FrameType type);
    private static Selector ValidateSelector(Selector selector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Styling.StyleBase : AvaloniaObject {
    [NullableAttribute("2")]
private IResourceHost _owner;
    [NullableAttribute("2")]
private StyleChildren _children;
    [NullableAttribute("2")]
private IResourceDictionary _resources;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SetterBase> _setters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IAnimation> _animations;
    [NullableAttribute("2")]
private StyleInstance _sharedInstance;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IStyle <Parent>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler OwnerChanged;
    public IList`1<IStyle> Children { get; }
    [NullableAttribute("2")]
public IResourceHost Owner { get; private set; }
    [NullableAttribute("2")]
public IStyle Parent { get; private set; }
    public IResourceDictionary Resources { get; public set; }
    public IList`1<SetterBase> Setters { get; }
    public IList`1<IAnimation> Animations { get; }
    private bool Avalonia.Controls.IResourceNode.HasResources { get; }
    private IReadOnlyList`1<IStyle> Avalonia.Styling.IStyle.Children { get; }
    internal bool HasChildren { get; }
    internal bool HasSettersOrAnimations { get; }
    public IList`1<IStyle> get_Children();
    [NullableContextAttribute("2")]
public sealed virtual IResourceHost get_Owner();
    [NullableContextAttribute("2")]
private void set_Owner(IResourceHost value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IStyle get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Parent(IStyle value);
    public IResourceDictionary get_Resources();
    public void set_Resources(IResourceDictionary value);
    public IList`1<SetterBase> get_Setters();
    public IList`1<IAnimation> get_Animations();
    private sealed virtual override bool Avalonia.Controls.IResourceNode.get_HasResources();
    private sealed virtual override IReadOnlyList`1<IStyle> Avalonia.Styling.IStyle.get_Children();
    internal bool get_HasChildren();
    internal bool get_HasSettersOrAnimations();
    public void Add(SetterBase setter);
    public void Add(IStyle style);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_OwnerChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_OwnerChanged(EventHandler value);
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetResource(object key, ThemeVariant themeVariant, Object& result);
    internal ValueFrame Attach(StyledElement target, IStyleActivator activator, FrameType type, bool canShareInstance);
    [NullableContextAttribute("2")]
internal virtual void SetParent(StyleBase parent);
    private sealed virtual override void Avalonia.Controls.IResourceProvider.AddOwner(IResourceHost owner);
    private sealed virtual override void Avalonia.Controls.IResourceProvider.RemoveOwner(IResourceHost owner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Styling.StyleChildren : Collection`1<IStyle> {
    private StyleBase _owner;
    public StyleChildren(StyleBase owner);
    protected virtual void InsertItem(int index, IStyle item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, IStyle item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Styling.StyleInstance : ValueFrame {
    [NullableAttribute("2")]
private IStyleActivator _activator;
    private bool _isActive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ISetterInstance> _setters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IAnimation> _animations;
    [NullableAttribute("2")]
private LightweightSubject`1<bool> _animationTrigger;
    [CompilerGeneratedAttribute]
private IStyle <Source>k__BackingField;
    public bool HasActivator { get; }
    public IStyle Source { get; }
    private bool Avalonia.Styling.IStyleInstance.IsActive { get; }
    public StyleInstance(IStyle style, IStyleActivator activator, FrameType type);
    public sealed virtual bool get_HasActivator();
    [CompilerGeneratedAttribute]
public sealed virtual IStyle get_Source();
    private sealed virtual override bool Avalonia.Styling.IStyleInstance.get_IsActive();
    public void Add(ISetterInstance instance);
    public void Add(IList`1<IAnimation> animations);
    public void ApplyAnimations(AvaloniaObject control);
    public virtual void Dispose();
    public void MakeShared();
    private sealed virtual override void Avalonia.Styling.Activators.IStyleActivatorSink.OnNext(bool value);
    protected virtual bool GetIsActive(Boolean& hasChanged);
    [NullableContextAttribute("2")]
private static BindingPriority GetPriority(IStyleActivator activator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Avalonia.Styling.Styles : AvaloniaObject {
    private AvaloniaList`1<IStyle> _styles;
    [NullableAttribute("2")]
private IResourceHost _owner;
    [NullableAttribute("2")]
private IResourceDictionary _resources;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler OwnerChanged;
    public int Count { get; }
    [NullableAttribute("2")]
public IResourceHost Owner { get; private set; }
    public IResourceDictionary Resources { get; public set; }
    private bool System.Collections.Generic.ICollection<Avalonia.Styling.IStyle>.IsReadOnly { get; }
    private bool Avalonia.Controls.IResourceNode.HasResources { get; }
    private IStyle System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle>.Item { get; }
    private IReadOnlyList`1<IStyle> Avalonia.Styling.IStyle.Children { get; }
    public IStyle Item { get; public set; }
    public Styles(IResourceHost owner);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_OwnerChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_OwnerChanged(EventHandler value);
    public sealed virtual int get_Count();
    [NullableContextAttribute("2")]
public sealed virtual IResourceHost get_Owner();
    [NullableContextAttribute("2")]
private void set_Owner(IResourceHost value);
    public IResourceDictionary get_Resources();
    public void set_Resources(IResourceDictionary value);
    private sealed virtual override bool System.Collections.Generic.ICollection<Avalonia.Styling.IStyle>.get_IsReadOnly();
    private sealed virtual override bool Avalonia.Controls.IResourceNode.get_HasResources();
    private sealed virtual override IStyle System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle>.get_Item(int index);
    private sealed virtual override IReadOnlyList`1<IStyle> Avalonia.Styling.IStyle.get_Children();
    public sealed virtual IStyle get_Item(int index);
    public sealed virtual void set_Item(int index, IStyle value);
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetResource(object key, ThemeVariant theme, Object& value);
    public sealed virtual void AddRange(IEnumerable`1<IStyle> items);
    public sealed virtual void InsertRange(int index, IEnumerable`1<IStyle> items);
    public sealed virtual void Move(int oldIndex, int newIndex);
    public sealed virtual void MoveRange(int oldIndex, int count, int newIndex);
    public sealed virtual void RemoveAll(IEnumerable`1<IStyle> items);
    public sealed virtual void RemoveRange(int index, int count);
    public sealed virtual int IndexOf(IStyle item);
    public sealed virtual void Insert(int index, IStyle item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(IStyle item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IStyle item);
    public sealed virtual void CopyTo(IStyle[] array, int arrayIndex);
    public sealed virtual bool Remove(IStyle item);
    public Enumerator<IStyle> GetEnumerator();
    private sealed virtual override IEnumerator`1<IStyle> System.Collections.Generic.IEnumerable<Avalonia.Styling.IStyle>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void Avalonia.Controls.IResourceProvider.AddOwner(IResourceHost owner);
    private sealed virtual override void Avalonia.Controls.IResourceProvider.RemoveOwner(IResourceHost owner);
    internal SelectorMatchResult TryAttach(StyledElement target, object host);
    private static IReadOnlyList`1<T> ToReadOnlyList(ICollection list);
    private static void InternalAdd(IList items, IResourceHost owner);
    private static void InternalRemove(IList items, IResourceHost owner);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private sealed virtual override void Avalonia.Collections.IAvaloniaListItemValidator<Avalonia.Styling.IStyle>.Validate(IStyle item);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.TemplateSelector : Selector {
    [NullableAttribute("1")]
private Selector _parent;
    private string _selectorString;
    internal bool InTemplate { get; }
    internal bool IsCombinator { get; }
    internal Type TargetType { get; }
    [NullableContextAttribute("1")]
public TemplateSelector(Selector parent);
    internal virtual bool get_InTemplate();
    internal virtual bool get_IsCombinator();
    internal virtual Type get_TargetType();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeConverterAttribute("Avalonia.Styling.ThemeVariantTypeConverter")]
public class Avalonia.Styling.ThemeVariant : object {
    internal static StyledProperty`1<ThemeVariant> ActualThemeVariantProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StyledProperty`1<ThemeVariant> RequestedThemeVariantProperty;
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ThemeVariant <InheritVariant>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThemeVariant <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThemeVariant <Light>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThemeVariant <Dark>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public object Key { get; }
    [NullableAttribute("2")]
public ThemeVariant InheritVariant { get; }
    public static ThemeVariant Default { get; }
    public static ThemeVariant Light { get; }
    public static ThemeVariant Dark { get; }
    public ThemeVariant(object key, ThemeVariant inheritVariant);
    private ThemeVariant(object key);
    [CompilerGeneratedAttribute]
private ThemeVariant(ThemeVariant original);
    private static ThemeVariant();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public object get_Key();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ThemeVariant get_InheritVariant();
    [CompilerGeneratedAttribute]
public static ThemeVariant get_Default();
    [CompilerGeneratedAttribute]
public static ThemeVariant get_Light();
    [CompilerGeneratedAttribute]
public static ThemeVariant get_Dark();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ThemeVariant other);
    public static ThemeVariant op_Explicit(PlatformThemeVariant themeVariant);
    public static Nullable`1<PlatformThemeVariant> op_Explicit(ThemeVariant themeVariant);
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ThemeVariant left, ThemeVariant right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ThemeVariant left, ThemeVariant right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public ThemeVariant <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Styling.ThemeVariantTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Styling.TypeNameAndClassSelector : Selector {
    private Selector _previous;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> _classes;
    private Type _targetType;
    private string _selectorString;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConcreteType>k__BackingField;
    internal bool InTemplate { get; }
    public string Name { get; public set; }
    internal Type TargetType { get; }
    internal bool IsCombinator { get; }
    public bool IsConcreteType { get; private set; }
    [NullableAttribute("1")]
public IList`1<string> Classes { get; }
    private TypeNameAndClassSelector(Selector previous);
    [NullableContextAttribute("1")]
public static TypeNameAndClassSelector OfType(Selector previous, Type targetType);
    [NullableContextAttribute("1")]
public static TypeNameAndClassSelector Is(Selector previous, Type targetType);
    [NullableContextAttribute("1")]
public static TypeNameAndClassSelector ForName(Selector previous, string name);
    [NullableContextAttribute("1")]
public static TypeNameAndClassSelector ForClass(Selector previous, string className);
    internal virtual bool get_InTemplate();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal virtual Type get_TargetType();
    internal virtual bool get_IsCombinator();
    [CompilerGeneratedAttribute]
public bool get_IsConcreteType();
    [CompilerGeneratedAttribute]
private void set_IsConcreteType(bool value);
    [NullableContextAttribute("1")]
public IList`1<string> get_Classes();
    [NullableContextAttribute("1")]
public virtual string ToString(Style owner);
    [NullableContextAttribute("1")]
private protected virtual SelectorMatch Evaluate(StyledElement control, IStyle parent, bool subscribe);
    private protected virtual Selector MovePrevious();
    private protected virtual Selector MovePreviousOrParent();
    [NullableContextAttribute("1")]
private string BuildSelectorString(Style owner);
}
[IsReadOnlyAttribute]
public class Avalonia.Thickness : ValueType {
    private double _left;
    private double _top;
    private double _right;
    private double _bottom;
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public bool IsUniform { get; }
    public Thickness(double uniformLength);
    public Thickness(double horizontal, double vertical);
    public Thickness(double left, double top, double right, double bottom);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public bool get_IsUniform();
    public static bool op_Equality(Thickness a, Thickness b);
    public static bool op_Inequality(Thickness a, Thickness b);
    public static Thickness op_Addition(Thickness a, Thickness b);
    public static Thickness op_Subtraction(Thickness a, Thickness b);
    public static Thickness op_Multiply(Thickness a, double b);
    public static Size op_Addition(Size size, Thickness thickness);
    public static Size op_Subtraction(Size size, Thickness thickness);
    [NullableContextAttribute("1")]
public static Thickness Parse(string s);
    public sealed virtual bool Equals(Thickness other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public void Deconstruct(Double& left, Double& top, Double& right, Double& bottom);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.AvaloniaSynchronizationContext : SynchronizationContext {
    internal DispatcherPriority Priority;
    [NullableAttribute("2")]
private IHelperImpl _nonPumpingHelper;
    private Dispatcher _dispatcher;
    [CompilerGeneratedAttribute]
private static bool <AutoInstall>k__BackingField;
    public static bool AutoInstall { get; public set; }
    internal AvaloniaSynchronizationContext(Dispatcher dispatcher, DispatcherPriority priority, bool isStaThread);
    public AvaloniaSynchronizationContext(DispatcherPriority priority);
    public AvaloniaSynchronizationContext(Dispatcher dispatcher, DispatcherPriority priority);
    private static AvaloniaSynchronizationContext();
    [CompilerGeneratedAttribute]
public static bool get_AutoInstall();
    [CompilerGeneratedAttribute]
public static void set_AutoInstall(bool value);
    public static void InstallIfNeeded();
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    public static RestoreContext Ensure(DispatcherPriority priority);
    public static RestoreContext Ensure(Dispatcher dispatcher, DispatcherPriority priority);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.Dispatcher : object {
    private IDispatcherImpl _impl;
    [CompilerGeneratedAttribute]
private object <InstanceLock>k__BackingField;
    [NullableAttribute("2")]
private IControlledDispatcherImpl _controlledImpl;
    [NullableAttribute("2")]
private static Dispatcher s_uiThread;
    [NullableAttribute("2")]
private IDispatcherImplWithPendingInput _pendingInputImpl;
    [NullableAttribute("2")]
private IDispatcherImplWithExplicitBackgroundProcessing _backgroundProcessingImpl;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AvaloniaSynchronizationContext[] _priorityContexts;
    internal static object ExceptionDataKey;
    [NullableAttribute("2")]
private DispatcherUnhandledExceptionFilterEventHandler _unhandledExceptionFilter;
    private DispatcherUnhandledExceptionEventArgs _unhandledExceptionEventArgs;
    private DispatcherUnhandledExceptionFilterEventArgs _exceptionFilterEventArgs;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DispatcherUnhandledExceptionEventHandler UnhandledException;
    [CompilerGeneratedAttribute]
private bool <ExitAllFramesRequested>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasShutdownStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DisabledProcessingCount>k__BackingField;
    private bool _hasShutdownFinished;
    private bool _startingShutdown;
    private Stack`1<DispatcherFrame> _frames;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler ShutdownStarted;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler ShutdownFinished;
    private DispatcherPriorityQueue _queue;
    private bool _signaled;
    private bool _explicitBackgroundProcessingRequested;
    private static int MaximumInputStarvationTimeInFallbackMode;
    private static int MaximumInputStarvationTimeInExplicitProcessingExplicitMode;
    private int _maximumInputStarvationTime;
    private List`1<DispatcherTimer> _timers;
    private long _timersVersion;
    private bool _dueTimeFound;
    private long _dueTimeInMs;
    private Nullable`1<long> _dueTimeForTimers;
    private Nullable`1<long> _dueTimeForBackgroundProcessing;
    private Nullable`1<long> _osTimerSetTo;
    internal object InstanceLock { get; }
    public static Dispatcher UIThread { get; }
    public bool SupportsRunLoops { get; }
    internal bool ExitAllFramesRequested { get; private set; }
    internal bool HasShutdownStarted { get; private set; }
    internal int DisabledProcessingCount { get; internal set; }
    internal long Now { get; }
    internal Dispatcher(IDispatcherImpl impl);
    private static Dispatcher();
    [CompilerGeneratedAttribute]
internal object get_InstanceLock();
    public static Dispatcher get_UIThread();
    public bool get_SupportsRunLoops();
    private static Dispatcher CreateUIThreadDispatcher();
    public sealed virtual bool CheckAccess();
    public sealed virtual void VerifyAccess();
    internal AvaloniaSynchronizationContext GetContextWithPriority(DispatcherPriority priority);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_UnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [NullableContextAttribute("2")]
public void add_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    [NullableContextAttribute("2")]
public void remove_UnhandledExceptionFilter(DispatcherUnhandledExceptionFilterEventHandler value);
    internal bool ExceptionFilter(Exception e);
    internal bool CatchException(Exception e);
    internal bool TryCatchWhen(Exception e);
    public void Invoke(Action callback);
    public void Invoke(Action callback, DispatcherPriority priority);
    public void Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public void Invoke(Action callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout);
    public TResult Invoke(Func`1<TResult> callback);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public TResult Invoke(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken, TimeSpan timeout);
    public DispatcherOperation InvokeAsync(Action callback);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority);
    public DispatcherOperation InvokeAsync(Action callback, DispatcherPriority priority, CancellationToken cancellationToken);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback, DispatcherPriority priority);
    public DispatcherOperation`1<TResult> InvokeAsync(Func`1<TResult> callback, DispatcherPriority priority, CancellationToken cancellationToken);
    internal void InvokeAsyncImpl(DispatcherOperation operation, CancellationToken cancellationToken);
    private object InvokeImpl(DispatcherOperation operation, CancellationToken cancellationToken, TimeSpan timeout);
    public sealed virtual void Post(Action action, DispatcherPriority priority);
    public Task InvokeAsync(Func`1<Task> callback);
    public Task InvokeAsync(Func`1<Task> callback, DispatcherPriority priority);
    public Task`1<TResult> InvokeAsync(Func`1<Task`1<TResult>> action);
    public Task`1<TResult> InvokeAsync(Func`1<Task`1<TResult>> action, DispatcherPriority priority);
    public void Post(SendOrPostCallback action, object arg, DispatcherPriority priority);
    internal void Send(SendOrPostCallback action, object arg, Nullable`1<DispatcherPriority> priority);
    public DispatcherPriorityAwaitable AwaitWithPriority(Task task, DispatcherPriority priority);
    public DispatcherPriorityAwaitable`1<T> AwaitWithPriority(Task`1<T> task, DispatcherPriority priority);
    [CompilerGeneratedAttribute]
internal bool get_ExitAllFramesRequested();
    [CompilerGeneratedAttribute]
private void set_ExitAllFramesRequested(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HasShutdownStarted();
    [CompilerGeneratedAttribute]
private void set_HasShutdownStarted(bool value);
    [CompilerGeneratedAttribute]
internal int get_DisabledProcessingCount();
    [CompilerGeneratedAttribute]
internal void set_DisabledProcessingCount(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_ShutdownStarted(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_ShutdownStarted(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_ShutdownFinished(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_ShutdownFinished(EventHandler value);
    public void PushFrame(DispatcherFrame frame);
    public void MainLoop(CancellationToken cancellationToken);
    public void ExitAllFrames();
    public void BeginInvokeShutdown(DispatcherPriority priority);
    public void InvokeShutdown();
    private void StartShutdownImpl();
    private void ShutdownImpl();
    public DispatcherProcessingDisabled DisableProcessing();
    private void RequestBackgroundProcessing();
    private void OnReadyForExplicitBackgroundProcessing();
    public void RunJobs(Nullable`1<DispatcherPriority> priority);
    internal void RunJobs(Nullable`1<DispatcherPriority> priority, CancellationToken cancellationToken);
    internal static void ResetBeforeUnitTests();
    internal static void ResetForUnitTests();
    private void ExecuteJob(DispatcherOperation job);
    private void Signaled();
    private void ExecuteJobsCore(bool fromExplicitBackgroundProcessingCallback);
    internal bool RequestProcessing();
    private void RequestForegroundProcessing();
    internal void Abort(DispatcherOperation operation);
    internal bool SetPriority(DispatcherOperation operation, DispatcherPriority priority);
    public bool HasJobsWithPriority(DispatcherPriority priority);
    internal long get_Now();
    private void UpdateOSTimer();
    internal void RescheduleTimers();
    internal void AddTimer(DispatcherTimer timer);
    internal void RemoveTimer(DispatcherTimer timer);
    private void OnOSTimer();
    internal void PromoteTimers();
    internal static List`1<DispatcherTimer> SnapshotTimersForUnitTests();
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
internal static void <VerifyAccess>g__ThrowVerifyAccess|16_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.Threading.DispatcherEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Dispatcher <Dispatcher>k__BackingField;
    public Dispatcher Dispatcher { get; }
    internal DispatcherEventArgs(Dispatcher dispatcher);
    [CompilerGeneratedAttribute]
public Dispatcher get_Dispatcher();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.DispatcherFrame : object {
    private bool _exitWhenRequested;
    private bool _continue;
    private bool _isRunning;
    [NullableAttribute("2")]
private CancellationTokenSource _cancellationTokenSource;
    [CompilerGeneratedAttribute]
private Dispatcher <Dispatcher>k__BackingField;
    public Dispatcher Dispatcher { get; }
    public bool Continue { get; public set; }
    public DispatcherFrame(bool exitWhenRequested);
    internal DispatcherFrame(Dispatcher dispatcher, bool exitWhenRequested);
    [CompilerGeneratedAttribute]
public Dispatcher get_Dispatcher();
    public bool get_Continue();
    public void set_Continue(bool value);
    internal void Run(IControlledDispatcherImpl impl);
    internal void MaybeExitOnDispatcherRequest();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Threading.DispatcherOperation : object {
    protected bool ThrowOnUiThread;
    [CompilerGeneratedAttribute]
private DispatcherOperationStatus <Status>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Dispatcher <Dispatcher>k__BackingField;
    protected object Callback;
    protected object TaskSource;
    [CompilerGeneratedAttribute]
private DispatcherOperation <SequentialPrev>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatcherOperation <SequentialNext>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatcherOperation <PriorityPrev>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatcherOperation <PriorityNext>k__BackingField;
    [CompilerGeneratedAttribute]
private PriorityChain <Chain>k__BackingField;
    private EventHandler _aborted;
    private EventHandler _completed;
    private DispatcherPriority _priority;
    [NullableAttribute("1")]
private static Task s_abortedTask;
    public DispatcherOperationStatus Status { get; protected set; }
    [NullableAttribute("1")]
public Dispatcher Dispatcher { get; }
    public DispatcherPriority Priority { get; public set; }
    internal DispatcherOperation SequentialPrev { get; internal set; }
    internal DispatcherOperation SequentialNext { get; internal set; }
    internal DispatcherOperation PriorityPrev { get; internal set; }
    internal DispatcherOperation PriorityNext { get; internal set; }
    internal PriorityChain Chain { get; internal set; }
    internal bool IsQueued { get; }
    [NullableContextAttribute("1")]
internal DispatcherOperation(Dispatcher dispatcher, DispatcherPriority priority, Action callback, bool throwOnUiThread);
    [NullableContextAttribute("1")]
private protected DispatcherOperation(Dispatcher dispatcher, DispatcherPriority priority, bool throwOnUiThread);
    private static DispatcherOperation();
    [CompilerGeneratedAttribute]
public DispatcherOperationStatus get_Status();
    [CompilerGeneratedAttribute]
protected void set_Status(DispatcherOperationStatus value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Dispatcher get_Dispatcher();
    public DispatcherPriority get_Priority();
    public void set_Priority(DispatcherPriority value);
    [CompilerGeneratedAttribute]
internal DispatcherOperation get_SequentialPrev();
    [CompilerGeneratedAttribute]
internal void set_SequentialPrev(DispatcherOperation value);
    [CompilerGeneratedAttribute]
internal DispatcherOperation get_SequentialNext();
    [CompilerGeneratedAttribute]
internal void set_SequentialNext(DispatcherOperation value);
    [CompilerGeneratedAttribute]
internal DispatcherOperation get_PriorityPrev();
    [CompilerGeneratedAttribute]
internal void set_PriorityPrev(DispatcherOperation value);
    [CompilerGeneratedAttribute]
internal DispatcherOperation get_PriorityNext();
    [CompilerGeneratedAttribute]
internal void set_PriorityNext(DispatcherOperation value);
    [CompilerGeneratedAttribute]
internal PriorityChain get_Chain();
    [CompilerGeneratedAttribute]
internal void set_Chain(PriorityChain value);
    internal bool get_IsQueued();
    [NullableContextAttribute("1")]
public void add_Aborted(EventHandler value);
    [NullableContextAttribute("1")]
public void remove_Aborted(EventHandler value);
    [NullableContextAttribute("1")]
public void add_Completed(EventHandler value);
    [NullableContextAttribute("1")]
public void remove_Completed(EventHandler value);
    public bool Abort();
    public void Wait();
    public void Wait(TimeSpan timeout);
    [NullableContextAttribute("1")]
public Task GetTask();
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public TaskAwaiter GetAwaiter();
    internal void DoAbort();
    internal void Execute();
    protected virtual void InvokeCore();
    internal virtual object GetResult();
    protected virtual void AbortTask();
    private static CancellationToken CreateCancelledToken();
    [NullableContextAttribute("1")]
protected virtual Task GetTaskCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.DispatcherOperation`1 : DispatcherOperation {
    private TaskCompletionSource`1<T> TaskCompletionSource { get; }
    public T Result { get; }
    public DispatcherOperation`1(Dispatcher dispatcher, DispatcherPriority priority, Func`1<T> callback);
    private TaskCompletionSource`1<T> get_TaskCompletionSource();
    public TaskAwaiter`1<T> GetAwaiter();
    public Task`1<T> GetTask();
    protected virtual Task GetTaskCore();
    protected virtual void AbortTask();
    [NullableContextAttribute("2")]
internal virtual object GetResult();
    protected virtual void InvokeCore();
    public T get_Result();
}
public enum Avalonia.Threading.DispatcherOperationStatus : Enum {
    public int value__;
    public static DispatcherOperationStatus Pending;
    public static DispatcherOperationStatus Aborted;
    public static DispatcherOperationStatus Completed;
    public static DispatcherOperationStatus Executing;
}
public class Avalonia.Threading.DispatcherOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <InputStarvationTimeout>k__BackingField;
    public TimeSpan InputStarvationTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_InputStarvationTimeout();
    [CompilerGeneratedAttribute]
public void set_InputStarvationTimeout(TimeSpan value);
}
[IsReadOnlyAttribute]
public class Avalonia.Threading.DispatcherPriority : ValueType {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public static DispatcherPriority Default;
    internal static DispatcherPriority MinimumForegroundPriority;
    public static DispatcherPriority Input;
    public static DispatcherPriority Background;
    public static DispatcherPriority ContextIdle;
    public static DispatcherPriority ApplicationIdle;
    public static DispatcherPriority SystemIdle;
    internal static DispatcherPriority MinimumActiveValue;
    public static DispatcherPriority Inactive;
    internal static DispatcherPriority MinValue;
    public static DispatcherPriority Invalid;
    public static DispatcherPriority Loaded;
    [PrivateApiAttribute]
public static DispatcherPriority UiThreadRender;
    internal static DispatcherPriority AfterRender;
    public static DispatcherPriority Render;
    [PrivateApiAttribute]
public static DispatcherPriority BeforeRender;
    [PrivateApiAttribute]
public static DispatcherPriority AsyncRenderTargetResize;
    [ObsoleteAttribute("WPF compatibility")]
[EditorBrowsableAttribute("1")]
public static DispatcherPriority DataBind;
    public static DispatcherPriority Normal;
    public static DispatcherPriority Send;
    public static DispatcherPriority MaxValue;
    public int Value { get; }
    private DispatcherPriority(int value);
    private static DispatcherPriority();
    [CompilerGeneratedAttribute]
public int get_Value();
    public static DispatcherPriority FromValue(int value);
    public static int op_Implicit(DispatcherPriority priority);
    public static DispatcherPriority op_Implicit(int value);
    public sealed virtual bool Equals(DispatcherPriority other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DispatcherPriority left, DispatcherPriority right);
    public static bool op_Inequality(DispatcherPriority left, DispatcherPriority right);
    public static bool op_LessThan(DispatcherPriority left, DispatcherPriority right);
    public static bool op_GreaterThan(DispatcherPriority left, DispatcherPriority right);
    public static bool op_LessThanOrEqual(DispatcherPriority left, DispatcherPriority right);
    public static bool op_GreaterThanOrEqual(DispatcherPriority left, DispatcherPriority right);
    public sealed virtual int CompareTo(DispatcherPriority other);
    [NullableContextAttribute("1")]
public static void Validate(DispatcherPriority priority, string parameterName);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.DispatcherPriorityAwaitable : object {
    private Dispatcher _dispatcher;
    private protected Task Task;
    private DispatcherPriority _priority;
    public bool IsCompleted { get; }
    internal DispatcherPriorityAwaitable(Dispatcher dispatcher, Task task, DispatcherPriority priority);
    public sealed virtual void OnCompleted(Action continuation);
    public bool get_IsCompleted();
    public void GetResult();
    public DispatcherPriorityAwaitable GetAwaiter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.DispatcherPriorityAwaitable`1 : DispatcherPriorityAwaitable {
    internal DispatcherPriorityAwaitable`1(Dispatcher dispatcher, Task`1<T> task, DispatcherPriority priority);
    public T GetResult();
    public DispatcherPriorityAwaitable`1<T> GetAwaiter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Threading.DispatcherPriorityQueue : object {
    private SortedList`2<int, PriorityChain> _priorityChains;
    private Stack`1<PriorityChain> _cacheReusableChains;
    [NullableAttribute("2")]
private DispatcherOperation _head;
    [NullableAttribute("2")]
private DispatcherOperation _tail;
    public DispatcherPriority MaxPriority { get; }
    public DispatcherPriority get_MaxPriority();
    public DispatcherOperation Enqueue(DispatcherPriority priority, DispatcherOperation item);
    public DispatcherOperation Dequeue();
    [NullableContextAttribute("2")]
public DispatcherOperation Peek();
    public void RemoveItem(DispatcherOperation item);
    public void ChangeItemPriority(DispatcherOperation item, DispatcherPriority priority);
    private PriorityChain GetChain(DispatcherPriority priority);
    private void InsertItemInPriorityChain(DispatcherOperation item, PriorityChain chain);
    internal void InsertItemInPriorityChain(DispatcherOperation item, PriorityChain chain, DispatcherOperation after);
    private void RemoveItemFromPriorityChain(DispatcherOperation item);
    internal void InsertItemInSequentialChain(DispatcherOperation item, DispatcherOperation after);
    private void RemoveItemFromSequentialChain(DispatcherOperation item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.DispatcherTimer : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Tick;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    private object _instanceLock;
    private Dispatcher _dispatcher;
    private DispatcherPriority _priority;
    private TimeSpan _interval;
    [NullableAttribute("2")]
private DispatcherOperation _operation;
    private bool _isEnabled;
    [CompilerGeneratedAttribute]
private long <DueTimeInMs>k__BackingField;
    public Dispatcher Dispatcher { get; }
    public bool IsEnabled { get; public set; }
    public TimeSpan Interval { get; public set; }
    [NullableAttribute("2")]
public object Tag { get; public set; }
    internal long DueTimeInMs { get; private set; }
    public DispatcherTimer(DispatcherPriority priority);
    internal DispatcherTimer(DispatcherPriority priority, Dispatcher dispatcher);
    public DispatcherTimer(TimeSpan interval, DispatcherPriority priority, EventHandler callback);
    internal DispatcherTimer(Dispatcher dispatcher, DispatcherPriority priority, TimeSpan interval);
    public Dispatcher get_Dispatcher();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public TimeSpan get_Interval();
    public void set_Interval(TimeSpan value);
    public void Start();
    public void Stop();
    public static IDisposable Run(Func`1<bool> action, TimeSpan interval, DispatcherPriority priority);
    public static IDisposable RunOnce(Action action, TimeSpan interval, DispatcherPriority priority);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_Tick(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_Tick(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Tag();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Tag(object value);
    private void Restart();
    internal void Promote();
    private void FireTick();
    [CompilerGeneratedAttribute]
internal long get_DueTimeInMs();
    [CompilerGeneratedAttribute]
private void set_DueTimeInMs(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.DispatcherUnhandledExceptionEventArgs : DispatcherEventArgs {
    private Exception _exception;
    private bool _handled;
    public Exception Exception { get; }
    public bool Handled { get; public set; }
    internal DispatcherUnhandledExceptionEventArgs(Dispatcher dispatcher);
    public Exception get_Exception();
    public bool get_Handled();
    public void set_Handled(bool value);
    internal void Initialize(Exception exception, bool handled);
}
public class Avalonia.Threading.DispatcherUnhandledExceptionEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, DispatcherUnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Threading.DispatcherUnhandledExceptionFilterEventArgs : DispatcherEventArgs {
    [NullableAttribute("2")]
private Exception _exception;
    private bool _requestCatch;
    public Exception Exception { get; }
    public bool RequestCatch { get; public set; }
    internal DispatcherUnhandledExceptionFilterEventArgs(Dispatcher dispatcher);
    public Exception get_Exception();
    public bool get_RequestCatch();
    public void set_RequestCatch(bool value);
    internal void Initialize(Exception exception, bool requestCatch);
}
public class Avalonia.Threading.DispatcherUnhandledExceptionFilterEventHandler : MulticastDelegate {
    public DispatcherUnhandledExceptionFilterEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DispatcherUnhandledExceptionFilterEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[PrivateApiAttribute]
public interface Avalonia.Threading.IControlledDispatcherImpl {
    public abstract virtual void RunLoop(CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Avalonia.Threading.IDispatcher {
    public abstract virtual bool CheckAccess();
    public abstract virtual void VerifyAccess();
    public abstract virtual void Post(Action action, DispatcherPriority priority);
}
[NullableContextAttribute("2")]
[PrivateApiAttribute]
public interface Avalonia.Threading.IDispatcherImpl {
    public bool CurrentThreadIsLoopThread { get; }
    public long Now { get; }
    public abstract virtual bool get_CurrentThreadIsLoopThread();
    public abstract virtual void Signal();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Signaled(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Signaled(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Timer(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Timer(Action value);
    public abstract virtual long get_Now();
    public abstract virtual void UpdateTimer(Nullable`1<long> dueTimeInMs);
}
[NullableContextAttribute("2")]
[PrivateApiAttribute]
public interface Avalonia.Threading.IDispatcherImplWithExplicitBackgroundProcessing {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ReadyForBackgroundProcessing(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ReadyForBackgroundProcessing(Action value);
    public abstract virtual void RequestBackgroundProcessing();
}
[PrivateApiAttribute]
public interface Avalonia.Threading.IDispatcherImplWithPendingInput {
    public bool CanQueryPendingInput { get; }
    public bool HasPendingInput { get; }
    public abstract virtual bool get_CanQueryPendingInput();
    public abstract virtual bool get_HasPendingInput();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Threading.LegacyDispatcherImpl : object {
    [NullableAttribute("1")]
private IPlatformThreadingInterface _platformThreading;
    private IDisposable _timer;
    [NullableAttribute("1")]
private Stopwatch _clock;
    [CompilerGeneratedAttribute]
private Action Signaled;
    [CompilerGeneratedAttribute]
private Action Timer;
    public bool CurrentThreadIsLoopThread { get; }
    public long Now { get; }
    [NullableContextAttribute("1")]
public LegacyDispatcherImpl(IPlatformThreadingInterface platformThreading);
    public sealed virtual bool get_CurrentThreadIsLoopThread();
    public sealed virtual void Signal();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Signaled(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Signaled(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Timer(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Timer(Action value);
    public sealed virtual long get_Now();
    public sealed virtual void UpdateTimer(Nullable`1<long> dueTimeInMs);
    private void OnTick();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(Nullable`1<DispatcherPriority> <p0>);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Threading.NonPumpingSyncContext : SynchronizationContext {
    private IHelperImpl _impl;
    [NullableAttribute("2")]
private SynchronizationContext _inner;
    public NonPumpingSyncContext(IHelperImpl impl, SynchronizationContext inner);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    public sealed virtual void Dispose();
    internal static IDisposable Use(IHelperImpl impl);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Threading.NullDispatcherImpl : object {
    public bool CurrentThreadIsLoopThread { get; }
    public long Now { get; }
    public sealed virtual bool get_CurrentThreadIsLoopThread();
    public sealed virtual void Signal();
    public sealed virtual void add_Signaled(Action value);
    public sealed virtual void remove_Signaled(Action value);
    public sealed virtual void add_Timer(Action value);
    public sealed virtual void remove_Timer(Action value);
    public sealed virtual long get_Now();
    public sealed virtual void UpdateTimer(Nullable`1<long> dueTimeInMs);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Threading.PriorityChain : object {
    [CompilerGeneratedAttribute]
private DispatcherPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatcherOperation <Head>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatcherOperation <Tail>k__BackingField;
    public DispatcherPriority Priority { get; public set; }
    public int Count { get; public set; }
    public DispatcherOperation Head { get; public set; }
    public DispatcherOperation Tail { get; public set; }
    public PriorityChain(DispatcherPriority priority);
    [CompilerGeneratedAttribute]
public DispatcherPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(DispatcherPriority value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public DispatcherOperation get_Head();
    [CompilerGeneratedAttribute]
public void set_Head(DispatcherOperation value);
    [CompilerGeneratedAttribute]
public DispatcherOperation get_Tail();
    [CompilerGeneratedAttribute]
public void set_Tail(DispatcherOperation value);
}
internal class Avalonia.Threading.SendOrPostCallbackDispatcherOperation : DispatcherOperation {
    [NullableAttribute("2")]
private object _arg;
    [NullableContextAttribute("1")]
internal SendOrPostCallbackDispatcherOperation(Dispatcher dispatcher, DispatcherPriority priority, SendOrPostCallback callback, object arg, bool throwOnUiThread);
    protected virtual void InvokeCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Threading.ThreadSafeObjectPool`1 : object {
    private Stack`1<T> _stack;
    [CompilerGeneratedAttribute]
private static ThreadSafeObjectPool`1<T> <Default>k__BackingField;
    public static ThreadSafeObjectPool`1<T> Default { get; }
    private static ThreadSafeObjectPool`1();
    [CompilerGeneratedAttribute]
public static ThreadSafeObjectPool`1<T> get_Default();
    public T Get();
    [NullableContextAttribute("2")]
public void ReturnAndSetNull(T& obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.TrimmingMessages : object {
    public static string ImplicitTypeConversionSupressWarningMessage;
    public static string ImplicitTypeConversionRequiresUnreferencedCodeMessage;
    public static string TypeConversionSupressWarningMessage;
    public static string TypeConversionRequiresUnreferencedCodeMessage;
    public static string ReflectionBindingRequiresUnreferencedCodeMessage;
    public static string ReflectionBindingSupressWarningMessage;
    public static string CompiledBindingSafeSupressWarningMessage;
    public static string ExpressionNodeRequiresUnreferencedCodeMessage;
    public static string ExpressionSafeSupressWarningMessage;
    public static string SelectorsParseRequiresUnreferencedCodeMessage;
    public static string PropertyAccessorsRequiresUnreferencedCodeMessage;
    public static string DataValidationPluginRequiresUnreferencedCodeMessage;
    public static string StreamPluginRequiresUnreferencedCodeMessage;
    public static string StyleResourceIncludeRequiresUnreferenceCodeMessage;
    public static string AvaloniaXamlLoaderRequiresUnreferenceCodeMessage;
    public static string XamlTypeResolvedRequiresUnreferenceCodeMessage;
    public static string IgnoreNativeAotSupressWarningMessage;
    public static string DesignTimeSupressWarningMessage;
}
public class Avalonia.UnsetValueType : object {
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Avalonia.Utilities.ArrayBuilder`1 : ValueType {
    private static int DefaultCapacity;
    private static int MaxCoreClrArrayLength;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] _data;
    private int _size;
    public int Length { get; public set; }
    public int Capacity { get; }
    public T& Item { get; }
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public T& get_Item(int index);
    public ArraySlice`1<T> Add(int length, bool clear);
    public ArraySlice`1<T> Add(ArraySlice`1& value);
    public void AddItem(T value);
    public void Clear();
    private void ClearArray();
    private void EnsureCapacity(int min);
    public ArraySlice`1<T> AsSlice();
    public ArraySlice`1<T> AsSlice(int length);
    public ArraySlice`1<T> AsSlice(int start, int length);
    public Span`1<T> AsSpan();
}
internal class Avalonia.Utilities.ArrayItemList`1 : FrugalListBase`1<T> {
    private static int MINSIZE;
    private static int GROWTH;
    private static int LARGEGROWTH;
    private T[] _entries;
    public int Capacity { get; }
    public ArrayItemList`1(int size);
    public ArrayItemList`1(ICollection collection);
    public ArrayItemList`1(ICollection`1<T> collection);
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SixItemList`1<T> oldList);
    public void Promote(ArrayItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
    public virtual Compacter<T> NewCompacter(int newCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Avalonia.Utilities.ArraySlice`1 : ValueType {
    private T[] _data;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArraySlice`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public int Start { get; }
    public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    public T& Item { get; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    public ArraySlice`1(T[] data);
    public ArraySlice`1(T[] data, int start, int length);
    public static ArraySlice`1<T> get_Empty();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    public Span`1<T> get_Span();
    public T& get_Item(int index);
    public static ArraySlice`1<T> op_Implicit(T[] array);
    public void Fill(T value);
    public ArraySlice`1<T> Slice(int start, int length);
    public ArraySlice`1<T> Take(int length);
    public ArraySlice`1<T> Skip(int length);
    public ImmutableReadOnlyListStructEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Utilities.AsyncEnumerableHelper : object {
    [ExtensionAttribute]
public static IAsyncEnumerable`1<T> AsAsyncEnumerable(IEnumerable`1<T> enumerable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Avalonia.Utilities.AvaloniaPropertyDictionary`1 : ValueType {
    private static int DefaultInitialCapacity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Entry[] _entries;
    private int _entryCount;
    public int Count { get; }
    public TValue Item { get; public set; }
    public TValue Item { get; }
    public AvaloniaPropertyDictionary`1(int capactity);
    public int get_Count();
    public TValue get_Item(AvaloniaProperty property);
    public void set_Item(AvaloniaProperty property, TValue value);
    public TValue get_Item(int index);
    public void Add(AvaloniaProperty property, TValue value);
    public void Clear();
    public bool ContainsKey(AvaloniaProperty property);
    public TValue GetValue(int index);
    public bool Remove(AvaloniaProperty property);
    public bool Remove(AvaloniaProperty property, TValue& value);
    public void RemoveAt(int index);
    public bool TryAdd(AvaloniaProperty property, TValue value);
    public bool TryGetValue(AvaloniaProperty property, TValue& value);
    private int FindEntry(int propertyId);
    [NullableContextAttribute("0")]
[MemberNotNullAttribute("_entries")]
private void InsertEntry(Entry<TValue> entry, int entryIndex);
    [NullableContextAttribute("0")]
private Entry& UnsafeGetEntryRef(int index);
    [DoesNotReturnAttribute]
private static void ThrowOutOfRange();
    [DoesNotReturnAttribute]
private static void ThrowDuplicate();
    [DoesNotReturnAttribute]
private static void ThrowNotFound();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Utilities.AvaloniaResourcesEntry : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<Stream> <Open>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemPath>k__BackingField;
    public string Path { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<Stream> Open { get; public set; }
    public int Size { get; public set; }
    public string SystemPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Path(string value);
    [CompilerGeneratedAttribute]
public Func`1<Stream> get_Open();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Open(Func`1<Stream> value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Size(int value);
    [CompilerGeneratedAttribute]
public string get_SystemPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SystemPath(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.Utilities.AvaloniaResourcesIndexEntry : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public string Path { get; public set; }
    public int Offset { get; public set; }
    public int Size { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Utilities.AvaloniaResourcesIndexReaderWriter : object {
    private static int XmlLegacyVersion;
    private static int BinaryCurrentVersion;
    public static List`1<AvaloniaResourcesIndexEntry> ReadIndex(Stream stream);
    private static List`1<AvaloniaResourcesIndexEntry> ReadXmlIndex();
    private static List`1<AvaloniaResourcesIndexEntry> ReadBinaryIndex(BinaryReader reader);
    public static void WriteIndex(Stream output, List`1<AvaloniaResourcesIndexEntry> entries);
    private static void WriteIndex(BinaryWriter writer, List`1<AvaloniaResourcesIndexEntry> entries);
    [ObsoleteAttribute]
public static void WriteResources(Stream output, List`1<ValueTuple`3<string, int, Func`1<Stream>>> resources);
    public static void WriteResources(Stream output, IReadOnlyList`1<AvaloniaResourcesEntry> resources);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.BidiDictionary`2 : object {
    private Dictionary`2<T1, T2> _forward;
    private Dictionary`2<T2, T1> _reverse;
    public void ClearThenResetIfTooLarge();
    public void Add(T1 key, T2 value);
    public bool TryGetValue(T1 key, T2& value);
    public bool TryGetKey(T2 value, T1& key);
    public bool ContainsKey(T1 key);
    public bool ContainsValue(T2 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Utilities.BinarySearchExtension : object {
    private static int GetMedian(int low, int hi);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, T value, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(IReadOnlyList`1<T> list, int index, int length, T value, IComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Utilities.ByteSizeHelper : object {
    private static string formatTemplateSeparated;
    private static string formatTemplate;
    private static String[] Prefixes;
    private static ByteSizeHelper();
    public static string ToString(ulong bytes, bool separate);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class Avalonia.Utilities.CharacterReader : ValueType {
    private ReadOnlySpan`1<char> _s;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public bool End { get; }
    public char Peek { get; }
    public int Position { get; private set; }
    public CharacterReader(ReadOnlySpan`1<char> s);
    public bool get_End();
    public char get_Peek();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public char Take();
    public void SkipWhitespace();
    public bool TakeIf(char c);
    [NullableContextAttribute("1")]
public bool TakeIf(Func`2<char, bool> condition);
    public ReadOnlySpan`1<char> TakeUntil(char c);
    public ReadOnlySpan`1<char> TakeWhile(Func`2<char, bool> condition);
    public ReadOnlySpan`1<char> TryPeek(int count);
    public ReadOnlySpan`1<char> PeekWhitespace();
    public void Skip(int count);
}
internal class Avalonia.Utilities.DisposableLock : object {
    [NullableAttribute("1")]
private object _lock;
    [NullableContextAttribute("2")]
public IDisposable TryLock();
    [NullableContextAttribute("1")]
public IDisposable Lock();
}
internal class Avalonia.Utilities.EnumHelper : object {
    public static T Parse(ReadOnlySpan`1<char> key, bool ignoreCase);
}
internal class Avalonia.Utilities.Equals : MulticastDelegate {
    public Equals(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual bool Invoke(object first, object second);
    public virtual IAsyncResult BeginInvoke(object first, object second, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal abstract class Avalonia.Utilities.FrugalListBase`1 : object {
    protected int _count;
    public int Count { get; }
    public int Capacity { get; }
    public int get_Count();
    internal void TrustedSetCount(int newCount);
    public abstract virtual int get_Capacity();
    public abstract virtual FrugalListStoreState Add(T value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T value);
    public abstract virtual int IndexOf(T value);
    public abstract virtual void Insert(int index, T value);
    public abstract virtual void SetAt(int index, T value);
    public abstract virtual bool Remove(T value);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual T EntryAt(int index);
    public abstract virtual void Promote(FrugalListBase`1<T> newList);
    public abstract virtual T[] ToArray();
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual object Clone();
    public virtual Compacter<T> NewCompacter(int newCount);
}
internal enum Avalonia.Utilities.FrugalListStoreState : Enum {
    public int value__;
    public static FrugalListStoreState Success;
    public static FrugalListStoreState SingleItemList;
    public static FrugalListStoreState ThreeItemList;
    public static FrugalListStoreState SixItemList;
    public static FrugalListStoreState Array;
}
[DefaultMemberAttribute("Item")]
internal class Avalonia.Utilities.FrugalObjectList`1 : object {
    internal FrugalListBase`1<T> _listStore;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public FrugalObjectList`1(int size);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int Add(T value);
    public void Clear();
    public bool Contains(T value);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public bool Remove(T value);
    public void RemoveAt(int index);
    public void EnsureIndex(int index);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    public FrugalObjectList`1<T> Clone();
}
[DefaultMemberAttribute("Item")]
internal class Avalonia.Utilities.FrugalStructList`1 : ValueType {
    internal FrugalListBase`1<T> _listStore;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public FrugalStructList`1(int size);
    public FrugalStructList`1(ICollection collection);
    public FrugalStructList`1(ICollection`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int Add(T value);
    public void Clear();
    public bool Contains(T value);
    public int IndexOf(T value);
    public void Insert(int index, T value);
    public bool Remove(T value);
    public void RemoveAt(int index);
    public void EnsureIndex(int index);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    public FrugalStructList`1<T> Clone();
}
[ExtensionAttribute]
public static class Avalonia.Utilities.IdentifierParser : object {
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseIdentifier(CharacterReader& r);
    private static bool IsValidIdentifierStart(char c);
    private static bool IsValidIdentifierChar(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Utilities.ImmutableReadOnlyListStructEnumerator`1 : ValueType {
    private IReadOnlyList`1<T> _readOnlyList;
    private int _pos;
    [NullableAttribute("2")]
private T _current;
    public T Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public ImmutableReadOnlyListStructEnumerator`1(IReadOnlyList`1<T> readOnlyList);
    public sealed virtual T get_Current();
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Avalonia.Utilities.InlineDictionary`2 : ValueType {
    [NullableAttribute("2")]
private object _data;
    [NullableAttribute("2")]
private TValue _value;
    public TValue Item { get; public set; }
    public bool HasEntries { get; }
    private void SetCore(TKey key, TValue value, bool overwrite);
    public void Add(TKey key, TValue value);
    public void Set(TKey key, TValue value);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool Remove(TKey key);
    public void Clear();
    public bool get_HasEntries();
    public bool TryGetValue(TKey key, TValue& value);
    [UnscopedRefAttribute]
public TValue& GetValueRefOrNullRef(TKey key);
    [UnscopedRefAttribute]
public TValue& GetValueRefOrAddDefault(TKey key, Boolean& exists);
    public bool TryGetAndRemoveValue(TKey key, TValue& value);
    public TValue GetAndRemove(TKey key);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
internal interface Avalonia.Utilities.IRef`1 {
    public T Item { get; }
    public int RefCount { get; }
    public abstract virtual T get_Item();
    public abstract virtual IRef`1<T> Clone();
    public abstract virtual IRef`1<TResult> CloneAs();
    public abstract virtual int get_RefCount();
}
[NullableContextAttribute("1")]
public interface Avalonia.Utilities.IWeakEventSubscriber`1 {
    public abstract virtual void OnEvent(object sender, WeakEvent ev, TEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.Utilities.KeywordParser : object {
    [ExtensionAttribute]
public static bool CheckKeyword(CharacterReader& r, string keyword);
    [ExtensionAttribute]
private static int CheckKeywordInternal(CharacterReader& r, string keyword);
    [NullableContextAttribute("0")]
private static bool SpanEquals(ReadOnlySpan`1<char> left, ReadOnlySpan`1<char> right);
    [ExtensionAttribute]
public static bool TakeIfKeyword(CharacterReader& r, string keyword);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Avalonia.Utilities.MappedArraySlice`1 : ValueType {
    private ArraySlice`1<T> _data;
    private ArraySlice`1<int> _map;
    public int Length { get; }
    public T& Item { get; }
    public MappedArraySlice`1(ArraySlice`1& data, ArraySlice`1& map);
    public int get_Length();
    public T& get_Item(int index);
}
[UnstableAttribute("This API might be removed in next major version. Please use corresponding BCL APIs.")]
public static class Avalonia.Utilities.MathUtilities : object {
    internal static double DoubleEpsilon;
    private static float FloatEpsilon;
    public static bool AreClose(double value1, double value2);
    public static bool AreClose(double value1, double value2, double eps);
    public static bool AreClose(float value1, float value2);
    public static bool LessThan(double value1, double value2);
    public static bool LessThan(float value1, float value2);
    public static bool GreaterThan(double value1, double value2);
    public static bool GreaterThan(float value1, float value2);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool LessThanOrClose(float value1, float value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool GreaterThanOrClose(float value1, float value2);
    public static bool IsOne(double value);
    public static bool IsOne(float value);
    public static bool IsZero(double value);
    public static bool IsZero(float value);
    public static double Clamp(double val, double min, double max);
    public static decimal Clamp(decimal val, decimal min, decimal max);
    public static float Clamp(float value, float min, float max);
    public static int Clamp(int val, int min, int max);
    public static double Deg2Rad(double angle);
    public static double Grad2Rad(double angle);
    public static double Turn2Rad(double angle);
    public static Point GetEllipsePoint(Point centre, double radiusX, double radiusY, double angle);
    public static ValueTuple`2<double, double> GetMinMax(double a, double b);
    public static ValueTuple`2<double, double> GetMinMaxFromDelta(double initialValue, double delta);
    internal static int WhichPolygonSideIntersects(UInt32 cPoly, ReadOnlySpan`1<Vector> pPtPoly, Vector ptCurrent, Vector vecEdge);
    internal static bool DoPolygonsIntersect(UInt32 cPolyA, ReadOnlySpan`1<Vector> pPtPolyA, UInt32 cPolyB, ReadOnlySpan`1<Vector> pPtPolyB);
    internal static bool IsEntirelyContained(UInt32 cPolyA, ReadOnlySpan`1<Vector> pPtPolyA, UInt32 cPolyB, ReadOnlySpan`1<Vector> pPtPolyB);
    [NullableContextAttribute("1")]
private static void ThrowCannotBeGreaterThanException(T min, T max);
}
internal class Avalonia.Utilities.NonPumpingLockHelper : object {
    [NullableContextAttribute("2")]
public static IDisposable Use();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.PooledInlineList`1 : ValueType {
    [NullableAttribute("2")]
private object _item;
    public int Count { get; }
    [NullableContextAttribute("2")]
public PooledInlineList`1(object rawState);
    public void Add(T item);
    public bool Remove(T item);
    private void ConvertToList();
    public void EnsureCapacity(int count);
    public sealed virtual void Dispose();
    public int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [NullableContextAttribute("2")]
public object TransferRawState();
}
internal static class Avalonia.Utilities.RefCountable : object {
    [NullableContextAttribute("1")]
public static IRef`1<T> Create(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.RefCountingSmallDictionary`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private InlineDictionary`2<TKey, int> _counts;
    public bool Add(TKey key);
    public bool Remove(TKey key);
    public Enumerator<TKey, int> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, int>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,System.Int32>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Utilities.RefTrackingDictionary`1 : Dictionary`2<TKey, int> {
    public bool AddRef(TKey key);
    public bool ReleaseRef(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.SafeEnumerableHashSet`1 : object {
    private HashSet`1<T> _hashSet;
    private int _generation;
    private int _enumCount;
    public int Count { get; }
    internal HashSet`1<T> Inner { get; }
    public int get_Count();
    internal HashSet`1<T> get_Inner();
    public void Add(T item);
    public bool Remove(T item);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private HashSet`1<T> GetSet();
}
internal class Avalonia.Utilities.SingleItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _loneEntry;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SingleItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.SingleOrDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<KeyValuePair`2<TKey, TValue>> _singleValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TKey, TValue> dictionary;
    public IEnumerable`1<TValue> Values { get; }
    public void Add(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<TValue> get_Values();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.SingleOrQueue`1 : object {
    [NullableAttribute("2")]
private T _head;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<T> _tail;
    [CompilerGeneratedAttribute]
private bool <Empty>k__BackingField;
    private Queue`1<T> Tail { get; }
    private bool HasTail { get; }
    public bool Empty { get; private set; }
    private Queue`1<T> get_Tail();
    private bool get_HasTail();
    [CompilerGeneratedAttribute]
public bool get_Empty();
    [CompilerGeneratedAttribute]
private void set_Empty(bool value);
    public void Enqueue(T value);
    public T Dequeue();
}
internal class Avalonia.Utilities.SixItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _entry0;
    private T _entry1;
    private T _entry2;
    private T _entry3;
    private T _entry4;
    private T _entry5;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(ThreeItemList`1<T> oldList);
    public void Promote(SixItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.Span : object {
    public object element;
    public int length;
    public Span(object element, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.SpanEnumerator : object {
    private SpanVector _spans;
    private int _current;
    public object Current { get; }
    internal SpanEnumerator(SpanVector spans);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[ExtensionAttribute]
public static class Avalonia.Utilities.SpanHelpers : object {
    [ExtensionAttribute]
public static bool TryParseUInt(ReadOnlySpan`1<char> span, NumberStyles style, IFormatProvider provider, UInt32& value);
    [ExtensionAttribute]
public static bool TryParseInt(ReadOnlySpan`1<char> span, Int32& value);
    [ExtensionAttribute]
public static bool TryParseDouble(ReadOnlySpan`1<char> span, NumberStyles style, IFormatProvider provider, Double& value);
    [ExtensionAttribute]
public static bool TryParseByte(ReadOnlySpan`1<char> span, NumberStyles style, IFormatProvider provider, Byte& value);
}
[IsReadOnlyAttribute]
internal class Avalonia.Utilities.SpanPosition : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    internal int Index { get; }
    internal int Offset { get; }
    internal SpanPosition(int spanIndex, int spanOffset);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal int get_Offset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.SpanRider : ValueType {
    private SpanVector _spans;
    private SpanPosition _spanPosition;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentPosition>k__BackingField;
    public int CurrentSpanStart { get; }
    public int Length { get; private set; }
    public int CurrentPosition { get; private set; }
    [NullableAttribute("2")]
public object CurrentElement { get; }
    public int CurrentSpanIndex { get; }
    public SpanPosition SpanPosition { get; }
    public SpanRider(SpanVector spans, SpanPosition latestPosition);
    public SpanRider(SpanVector spans, SpanPosition latestPosition, int cp);
    public bool At(int cp);
    public bool At(SpanPosition latestPosition, int cp);
    public int get_CurrentSpanStart();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentPosition();
    [CompilerGeneratedAttribute]
private void set_CurrentPosition(int value);
    [NullableContextAttribute("2")]
public object get_CurrentElement();
    public int get_CurrentSpanIndex();
    public SpanPosition get_SpanPosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Avalonia.Utilities.SpanVector : object {
    private static Equals s_referenceEquals;
    private static Equals s_equals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private FrugalStructList`1<Span> _spans;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Default>k__BackingField;
    public int Count { get; }
    [NullableAttribute("2")]
public object Default { get; }
    public Span Item { get; }
    [NullableContextAttribute("2")]
internal SpanVector(object defaultObject, FrugalStructList`1<Span> spans);
    private static SpanVector();
    public sealed virtual IEnumerator GetEnumerator();
    private void Add(Span span);
    internal void Delete(int index, int count, SpanPosition& latestPosition);
    private void DeleteInternal(int index, int count);
    private void Insert(int index, int count);
    internal bool FindSpan(int cp, SpanPosition latestPosition, SpanPosition& spanPosition);
    public void SetValue(int first, int length, object element);
    public SpanPosition SetValue(int first, int length, object element, SpanPosition spanPosition);
    public void SetReference(int first, int length, object element);
    public SpanPosition SetReference(int first, int length, object element, SpanPosition spanPosition);
    private SpanPosition Set(int first, int length, object element, Equals equals, SpanPosition spanPosition);
    public int get_Count();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Default();
    public Span get_Item(int index);
    private bool Resize(int targetCount);
}
internal class Avalonia.Utilities.SpringSolver : ValueType {
    private double m_w0;
    private double m_zeta;
    private double m_wd;
    private double m_A;
    private double m_B;
    public SpringSolver(TimeSpan period, double zeta, double initialVelocity);
    public SpringSolver(double m, double k, double c, double initialVelocity);
    public SpringSolver(double ωn, double zeta, double initialVelocity);
    [IsReadOnlyAttribute]
public double Solve(double t);
}
internal static class Avalonia.Utilities.StopwatchHelper : object {
    private static double s_timestampToTicks;
    private static StopwatchHelper();
    public static TimeSpan GetElapsedTime(long startingTimestamp);
    public static TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Utilities.StringBuilderCache : object {
    internal static int MaxBuilderSize;
    private static int DefaultCapacity;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Utilities.StringTokenizer : ValueType {
    private static char DefaultSeparatorChar;
    private string _s;
    private int _length;
    private char _separator;
    [NullableAttribute("2")]
private string _exceptionMessage;
    private IFormatProvider _formatProvider;
    private int _index;
    private int _tokenIndex;
    private int _tokenLength;
    [NullableAttribute("2")]
public string CurrentToken { get; }
    public StringTokenizer(string s, IFormatProvider formatProvider, string exceptionMessage);
    public StringTokenizer(string s, char separator, string exceptionMessage);
    [NullableContextAttribute("2")]
public string get_CurrentToken();
    public sealed virtual void Dispose();
    public bool TryReadInt32(Int32& result, Nullable`1<char> separator);
    public int ReadInt32(Nullable`1<char> separator);
    public bool TryReadDouble(Double& result, Nullable`1<char> separator);
    public double ReadDouble(Nullable`1<char> separator);
    public bool TryReadString(String& result, Nullable`1<char> separator);
    public string ReadString(Nullable`1<char> separator);
    private bool TryReadToken(char separator);
    private void SkipToNextToken(char separator);
    private FormatException GetFormatException();
    private static char GetSeparatorFromFormatProvider(IFormatProvider provider);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StringTokenizer left, StringTokenizer right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StringTokenizer left, StringTokenizer right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringTokenizer other);
}
[ExtensionAttribute]
public static class Avalonia.Utilities.StyleClassParser : object {
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseStyleClass(CharacterReader& r);
    private static bool IsValidIdentifierStart(char c);
    private static bool IsValidIdentifierChar(char c);
}
public class Avalonia.Utilities.SynchronousCompletionAsyncResult`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SynchronousCompletionAsyncResultSource`1<T> _source;
    [NullableAttribute("2")]
private T _result;
    private bool _isValid;
    public bool IsCompleted { get; }
    [NullableContextAttribute("1")]
internal SynchronousCompletionAsyncResult`1(SynchronousCompletionAsyncResultSource`1<T> source);
    [NullableContextAttribute("1")]
public SynchronousCompletionAsyncResult`1(T result);
    private static void ThrowNotInitialized();
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public T GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    public SynchronousCompletionAsyncResult`1<T> GetAwaiter();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SynchronousCompletionAsyncResult`1<T> left, SynchronousCompletionAsyncResult`1<T> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SynchronousCompletionAsyncResult`1<T> left, SynchronousCompletionAsyncResult`1<T> right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SynchronousCompletionAsyncResult`1<T> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Utilities.SynchronousCompletionAsyncResultSource`1 : object {
    [NullableAttribute("2")]
private T _result;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Action> _continuations;
    internal bool IsCompleted { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SynchronousCompletionAsyncResult`1<T> AsyncResult { get; }
    internal T Result { get; }
    [CompilerGeneratedAttribute]
internal bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    public SynchronousCompletionAsyncResult`1<T> get_AsyncResult();
    internal T get_Result();
    internal void OnCompleted(Action continuation);
    public void SetResult(T result);
    public void TrySetResult(T result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Utilities.TargetWeakEventSubscriber`2 : object {
    private TTarget _target;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`4<TTarget, object, WeakEvent, TEventArgs> _dispatchFunc;
    public TargetWeakEventSubscriber`2(TTarget target, Action`4<TTarget, object, WeakEvent, TEventArgs> dispatchFunc);
    private sealed virtual override void Avalonia.Utilities.IWeakEventSubscriber<TEventArgs>.OnEvent(object sender, WeakEvent ev, TEventArgs e);
}
internal class Avalonia.Utilities.ThreeItemList`1 : FrugalListBase`1<T> {
    private static int SIZE;
    private T _entry0;
    private T _entry1;
    private T _entry2;
    public int Capacity { get; }
    public virtual int get_Capacity();
    public virtual FrugalListStoreState Add(T value);
    public virtual void Clear();
    public virtual bool Contains(T value);
    public virtual int IndexOf(T value);
    public virtual void Insert(int index, T value);
    public virtual void SetAt(int index, T value);
    public virtual bool Remove(T value);
    public virtual void RemoveAt(int index);
    public virtual T EntryAt(int index);
    public virtual void Promote(FrugalListBase`1<T> oldList);
    public void Promote(SingleItemList`1<T> oldList);
    public void Promote(ThreeItemList`1<T> oldList);
    public virtual T[] ToArray();
    public virtual void CopyTo(T[] array, int index);
    public virtual object Clone();
    private void SetCount(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.ThrowHelper : object {
    public static void ThrowIfNull(object argument, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowArgumentNullException(string paramName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Utilities.TypeUtilities : object {
    private static Int32[] Conversions;
    private static Int32[] ImplicitConversions;
    private static Type[] InbuiltTypes;
    private static Type[] NumericTypes;
    private static TypeUtilities();
    public static bool AcceptsNull(Type type);
    [NullableContextAttribute("2")]
public static bool AcceptsNull();
    [NullableContextAttribute("2")]
public static bool CanCast(object value);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
public static bool TryConvert(Type to, object value, CultureInfo culture, Object& result);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
public static bool TryConvertImplicit(Type to, object value, Object& result);
    [RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
public static object ConvertOrDefault(object value, Type type, CultureInfo culture);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
public static object ConvertImplicitOrDefault(object value, Type type);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
public static T ConvertImplicit(object value);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2067")]
public static object Default(Type type);
    public static bool IsNumeric(Type type);
    private static bool IsNullableType(Type type);
    internal static MethodInfo FindTypeConversionOperatorMethod(Type fromType, Type toType, OperatorType operatorType);
    [NullableContextAttribute("2")]
internal static bool IdentityEquals(object a, object b, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Utilities.UriExtensions : object {
    [ExtensionAttribute]
public static bool IsAbsoluteResm(Uri uri);
    [ExtensionAttribute]
public static bool IsResm(Uri uri);
    [ExtensionAttribute]
public static bool IsAvares(Uri uri);
    [ExtensionAttribute]
public static bool IsFontCollection(Uri uri);
    [ExtensionAttribute]
public static Uri EnsureAbsolute(Uri uri, Uri baseUri);
    [ExtensionAttribute]
public static string GetUnescapeAbsolutePath(Uri uri);
    [ExtensionAttribute]
public static string GetUnescapeAbsoluteUri(Uri uri);
    [ExtensionAttribute]
public static string GetAssemblyNameFromQuery(Uri uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class Avalonia.Utilities.ValueSingleOrList`1 : ValueType {
    private bool _isSingleSet;
    [CompilerGeneratedAttribute]
private T <Single>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<T> <List>k__BackingField;
    public T Single { get; private set; }
    public List`1<T> List { get; private set; }
    public bool HasList { get; }
    public bool IsSingle { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T get_Single();
    [CompilerGeneratedAttribute]
private void set_Single(T value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public List`1<T> get_List();
    [CompilerGeneratedAttribute]
private void set_List(List`1<T> value);
    public bool get_HasList();
    public bool get_IsSingle();
    public void Add(T value);
    public bool Remove(T value);
}
[IsReadOnlyAttribute]
public class Avalonia.Utilities.ValueSpan`1 : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public int Start { get; }
    public int Length { get; }
    [NullableAttribute("1")]
public T Value { get; }
    [NullableContextAttribute("1")]
public ValueSpan`1(int start, int length, T value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ValueSpan`1<T> left, ValueSpan`1<T> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ValueSpan`1<T> left, ValueSpan`1<T> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueSpan`1<T> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Utilities.WeakEvent : object {
    public static WeakEvent`2<TSender, TEventArgs> Register(Action`2<TSender, EventHandler`1<TEventArgs>> subscribe, Action`2<TSender, EventHandler`1<TEventArgs>> unsubscribe);
    public static WeakEvent`2<TSender, TEventArgs> Register(Func`3<TSender, EventHandler`1<TEventArgs>, Action> subscribe);
    public static WeakEvent`2<TSender, EventArgs> Register(Action`2<TSender, EventHandler> subscribe, Action`2<TSender, EventHandler> unsubscribe);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Utilities.WeakEvent`2 : WeakEvent {
    private Func`3<TSender, EventHandler`1<TEventArgs>, Action> _subscribe;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConditionalWeakTable`2<object, Subscription<TSender, TEventArgs>> _subscriptions;
    internal WeakEvent`2(Action`2<TSender, EventHandler`1<TEventArgs>> subscribe, Action`2<TSender, EventHandler`1<TEventArgs>> unsubscribe);
    internal WeakEvent`2(Func`3<TSender, EventHandler`1<TEventArgs>, Action> subscribe);
    public void Subscribe(TSender target, IWeakEventSubscriber`1<TEventArgs> subscriber);
    public void Unsubscribe(TSender target, IWeakEventSubscriber`1<TEventArgs> subscriber);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Utilities.WeakEventHandlerManager : object {
    private static Dictionary`2<Type, Dictionary`2<string, EventInfo>> s_accessors;
    private static WeakEventHandlerManager();
    public static void Subscribe(TTarget target, string eventName, EventHandler`1<TEventArgs> subscriber);
    public static void Unsubscribe(object target, string eventName, EventHandler`1<TEventArgs> subscriber);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Utilities.WeakEvents : object {
    public static WeakEvent`2<INotifyCollectionChanged, NotifyCollectionChangedEventArgs> CollectionChanged;
    public static WeakEvent`2<INotifyPropertyChanged, PropertyChangedEventArgs> ThreadSafePropertyChanged;
    public static WeakEvent`2<AvaloniaObject, AvaloniaPropertyChangedEventArgs> AvaloniaPropertyChanged;
    public static WeakEvent`2<ICommand, EventArgs> CommandCanExecuteChanged;
    private static WeakEvents();
}
public class Avalonia.Utilities.WeakEventSubscriber`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`3<object, WeakEvent, TEventArgs> Event;
    [CompilerGeneratedAttribute]
public void add_Event(Action`3<object, WeakEvent, TEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Event(Action`3<object, WeakEvent, TEventArgs> value);
    [NullableContextAttribute("1")]
private sealed virtual override void Avalonia.Utilities.IWeakEventSubscriber<TEventArgs>.OnEvent(object sender, WeakEvent ev, TEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.WeakHashList`1 : object {
    public static int DefaultArraySize;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Key<T>, int> _dic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1[] _arr;
    private int _arrCount;
    [CompilerGeneratedAttribute]
private bool <NeedCompact>k__BackingField;
    private static Stack`1<PooledList`1<T>> s_listPool;
    public bool IsEmpty { get; }
    public bool NeedCompact { get; private set; }
    private static WeakHashList`1();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public bool get_NeedCompact();
    [CompilerGeneratedAttribute]
private void set_NeedCompact(bool value);
    public void Add(T item);
    public void Remove(T item);
    private void ArrCompact();
    public void Compact();
    public static void ReturnToSharedPool(PooledList`1<T> list);
    public PooledList`1<T> GetAlive(Func`1<PooledList`1<T>> factory);
}
[IsReadOnlyAttribute]
public class Avalonia.Vector : ValueType {
    private double _x;
    private double _y;
    public double X { get; }
    public double Y { get; }
    public double Length { get; }
    public double SquaredLength { get; }
    public static Vector Zero { get; }
    public static Vector One { get; }
    public static Vector UnitX { get; }
    public static Vector UnitY { get; }
    public Vector(double x, double y);
    internal Vector(Vector2 v);
    public double get_X();
    public double get_Y();
    public static Point op_Explicit(Vector a);
    public static double op_Multiply(Vector a, Vector b);
    public static Vector op_Multiply(Vector vector, double scale);
    public static Vector op_Multiply(double scale, Vector vector);
    public static Vector op_Division(Vector vector, double scale);
    [NullableContextAttribute("1")]
public static Vector Parse(string s);
    public double get_Length();
    public double get_SquaredLength();
    public static Vector op_UnaryNegation(Vector a);
    public static Vector op_Addition(Vector a, Vector b);
    public static Vector op_Subtraction(Vector a, Vector b);
    public sealed virtual bool Equals(Vector other);
    public bool NearlyEquals(Vector other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Vector left, Vector right);
    public static bool op_Inequality(Vector left, Vector right);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Vector WithX(double x);
    public Vector WithY(double y);
    public Vector Normalize();
    public Vector Negate();
    public static double Dot(Vector a, Vector b);
    public static double Cross(Vector a, Vector b);
    public static Vector Normalize(Vector vector);
    public static Vector Divide(Vector a, Vector b);
    public static Vector Divide(Vector vector, double scalar);
    public static Vector Multiply(Vector a, Vector b);
    public static Vector Multiply(Vector vector, double scalar);
    public static Vector Add(Vector a, Vector b);
    public static Vector Subtract(Vector a, Vector b);
    public static Vector Negate(Vector vector);
    public static Vector get_Zero();
    public static Vector get_One();
    public static Vector get_UnitX();
    public static Vector get_UnitY();
    public void Deconstruct(Double& x, Double& y);
    internal Vector2 ToVector2();
    public Vector Abs();
    public static Vector Clamp(Vector value, Vector min, Vector max);
    public static Vector Max(Vector left, Vector right);
    public static Vector Min(Vector left, Vector right);
    public static double Distance(Vector value1, Vector value2);
    public static double DistanceSquared(Vector value1, Vector value2);
    public static Vector op_Implicit(Vector2 v);
}
[IsReadOnlyAttribute]
public class Avalonia.Vector3D : ValueType {
    [CompilerGeneratedAttribute]
private double <X>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Z>k__BackingField;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double Length { get; }
    public Vector3D(double X, double Y, double Z);
    internal Vector3D(Vector3 v);
    [CompilerGeneratedAttribute]
public double get_X();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_X(double value);
    [CompilerGeneratedAttribute]
public double get_Y();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Y(double value);
    [CompilerGeneratedAttribute]
public double get_Z();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Z(double value);
    [NullableContextAttribute("1")]
public static Vector3D Parse(string s);
    internal Vector3 ToVector3();
    public static Vector3D op_Implicit(Vector3 vector);
    public static double Dot(Vector3D vector1, Vector3D vector2);
    public static Vector3D Add(Vector3D left, Vector3D right);
    public static Vector3D op_Addition(Vector3D left, Vector3D right);
    public static Vector3D Substract(Vector3D left, Vector3D right);
    public static Vector3D op_Subtraction(Vector3D left, Vector3D right);
    public static Vector3D op_UnaryNegation(Vector3D v);
    public static Vector3D Multiply(Vector3D left, Vector3D right);
    public static Vector3D Multiply(Vector3D left, double right);
    public static Vector3D op_Multiply(Vector3D left, double right);
    public static Vector3D Divide(Vector3D left, Vector3D right);
    public static Vector3D Divide(Vector3D left, double right);
    public Vector3D Abs();
    public static Vector3D Clamp(Vector3D value, Vector3D min, Vector3D max);
    public static Vector3D Max(Vector3D left, Vector3D right);
    public static Vector3D Min(Vector3D left, Vector3D right);
    public double get_Length();
    public static Vector3D Normalize(Vector3D value);
    public static double DistanceSquared(Vector3D value1, Vector3D value2);
    public static double Distance(Vector3D value1, Vector3D value2);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Vector3D left, Vector3D right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Vector3D left, Vector3D right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Vector3D other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Double& X, Double& Y, Double& Z);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UsableDuringInitializationAttribute]
public class Avalonia.Visual : StyledElement {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CompositionDrawListVisual <CompositionVisual>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CompositionVisual <ChildCompositionVisual>k__BackingField;
    public static DirectProperty`2<Visual, Rect> BoundsProperty;
    public static StyledProperty`1<bool> ClipToBoundsProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<Geometry> ClipProperty;
    public static StyledProperty`1<bool> IsVisibleProperty;
    public static StyledProperty`1<double> OpacityProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IBrush> OpacityMaskProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<IEffect> EffectProperty;
    public static DirectProperty`2<Visual, bool> HasMirrorTransformProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StyledProperty`1<ITransform> RenderTransformProperty;
    public static StyledProperty`1<RelativePoint> RenderTransformOriginProperty;
    public static AttachedProperty`1<FlowDirection> FlowDirectionProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectProperty`2<Visual, Visual> VisualParentProperty;
    public static StyledProperty`1<int> ZIndexProperty;
    private static WeakEvent`2<IAffectsRender, EventArgs> InvalidatedWeakEvent;
    private Rect _bounds;
    [NullableAttribute("2")]
private IRenderRoot _visualRoot;
    [NullableAttribute("2")]
private Visual _visualParent;
    private bool _hasMirrorTransform;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TargetWeakEventSubscriber`2<Visual, EventArgs> _affectsRenderWeakSubscriber;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<VisualTreeAttachmentEventArgs> AttachedToVisualTree;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<VisualTreeAttachmentEventArgs> DetachedFromVisualTree;
    [CompilerGeneratedAttribute]
private bool <IsEffectivelyVisible>k__BackingField;
    [CompilerGeneratedAttribute]
private IAvaloniaList`1<Visual> <VisualChildren>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderOptions <RenderOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNonUniformZIndexChildren>k__BackingField;
    [NullableAttribute("2")]
internal CompositionDrawListVisual CompositionVisual { get; private set; }
    [NullableAttribute("2")]
internal CompositionVisual ChildCompositionVisual { get; internal set; }
    public Rect Bounds { get; protected set; }
    public bool ClipToBounds { get; public set; }
    [NullableAttribute("2")]
public Geometry Clip { get; public set; }
    public bool IsEffectivelyVisible { get; private set; }
    public bool IsVisible { get; public set; }
    public double Opacity { get; public set; }
    [NullableAttribute("2")]
public IBrush OpacityMask { get; public set; }
    [NullableAttribute("2")]
public IEffect Effect { get; public set; }
    public bool HasMirrorTransform { get; protected set; }
    [NullableAttribute("2")]
public ITransform RenderTransform { get; public set; }
    public RelativePoint RenderTransformOrigin { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    public int ZIndex { get; public set; }
    protected internal IAvaloniaList`1<Visual> VisualChildren { get; private set; }
    [NullableAttribute("2")]
protected internal IRenderRoot VisualRoot { get; }
    internal RenderOptions RenderOptions { get; internal set; }
    internal bool HasNonUniformZIndexChildren { get; private set; }
    internal bool IsAttachedToVisualTree { get; }
    [NullableAttribute("2")]
internal Visual VisualParent { get; }
    protected bool BypassFlowDirectionPolicies { get; }
    private static Visual();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal CompositionDrawListVisual get_CompositionVisual();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_CompositionVisual(CompositionDrawListVisual value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal CompositionVisual get_ChildCompositionVisual();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ChildCompositionVisual(CompositionVisual value);
    private protected virtual CompositionDrawListVisual CreateCompositionVisual(Compositor compositor);
    internal CompositionVisual AttachToCompositor(Compositor compositor);
    internal virtual void DetachFromCompositor();
    internal virtual void SynchronizeCompositionChildVisuals();
    internal virtual void SynchronizeCompositionProperties();
    [CompilerGeneratedAttribute]
public void add_AttachedToVisualTree(EventHandler`1<VisualTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AttachedToVisualTree(EventHandler`1<VisualTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DetachedFromVisualTree(EventHandler`1<VisualTreeAttachmentEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DetachedFromVisualTree(EventHandler`1<VisualTreeAttachmentEventArgs> value);
    public Rect get_Bounds();
    protected void set_Bounds(Rect value);
    public bool get_ClipToBounds();
    public void set_ClipToBounds(bool value);
    [NullableContextAttribute("2")]
public Geometry get_Clip();
    [NullableContextAttribute("2")]
public void set_Clip(Geometry value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEffectivelyVisible();
    [CompilerGeneratedAttribute]
private void set_IsEffectivelyVisible(bool value);
    private void UpdateIsEffectivelyVisible(bool parentState);
    public bool get_IsVisible();
    public void set_IsVisible(bool value);
    public double get_Opacity();
    public void set_Opacity(double value);
    [NullableContextAttribute("2")]
public IBrush get_OpacityMask();
    [NullableContextAttribute("2")]
public void set_OpacityMask(IBrush value);
    [NullableContextAttribute("2")]
public IEffect get_Effect();
    [NullableContextAttribute("2")]
public void set_Effect(IEffect value);
    public bool get_HasMirrorTransform();
    protected void set_HasMirrorTransform(bool value);
    [NullableContextAttribute("2")]
public ITransform get_RenderTransform();
    [NullableContextAttribute("2")]
public void set_RenderTransform(ITransform value);
    public RelativePoint get_RenderTransformOrigin();
    public void set_RenderTransformOrigin(RelativePoint value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public int get_ZIndex();
    public void set_ZIndex(int value);
    [CompilerGeneratedAttribute]
protected internal IAvaloniaList`1<Visual> get_VisualChildren();
    [CompilerGeneratedAttribute]
private void set_VisualChildren(IAvaloniaList`1<Visual> value);
    [NullableContextAttribute("2")]
protected internal IRenderRoot get_VisualRoot();
    [CompilerGeneratedAttribute]
internal RenderOptions get_RenderOptions();
    [CompilerGeneratedAttribute]
internal void set_RenderOptions(RenderOptions value);
    [CompilerGeneratedAttribute]
internal bool get_HasNonUniformZIndexChildren();
    [CompilerGeneratedAttribute]
private void set_HasNonUniformZIndexChildren(bool value);
    internal bool get_IsAttachedToVisualTree();
    [NullableContextAttribute("2")]
internal Visual get_VisualParent();
    protected virtual bool get_BypassFlowDirectionPolicies();
    public static FlowDirection GetFlowDirection(Visual visual);
    public static void SetFlowDirection(Visual visual, FlowDirection value);
    public void InvalidateVisual();
    public virtual void Render(DrawingContext context);
    protected static void AffectsRender(AvaloniaProperty[] properties);
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    protected virtual void LogicalChildrenCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    protected virtual void OnAttachedToVisualTreeCore(VisualTreeAttachmentEventArgs e);
    protected virtual void OnDetachedFromVisualTreeCore(VisualTreeAttachmentEventArgs e);
    protected virtual void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e);
    protected virtual void OnDetachedFromVisualTree(VisualTreeAttachmentEventArgs e);
    [NullableContextAttribute("2")]
protected virtual void OnVisualParentChanged(Visual oldParent, Visual newParent);
    private static void RenderTransformChanged(AvaloniaPropertyChangedEventArgs`1<ITransform> e);
    private sealed virtual override void Avalonia.Collections.IAvaloniaListItemValidator<Avalonia.Visual>.Validate(Visual item);
    private static void ZIndexChanged(AvaloniaPropertyChangedEventArgs e);
    private void RenderTransformChanged(object sender, EventArgs e);
    [NullableContextAttribute("2")]
private void SetVisualParent(Visual value);
    private void VisualChildrenChanged(object sender, NotifyCollectionChangedEventArgs e);
    private static void SetVisualParent(IList children, Visual parent);
    internal virtual void OnTemplatedParentControlThemeChanged();
    protected internal virtual void InvalidateMirrorTransform();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.VisualExtensions : object {
    [ExtensionAttribute]
public static Point PointToClient(Visual visual, PixelPoint point);
    [ExtensionAttribute]
public static PixelPoint PointToScreen(Visual visual, Point point);
    [ExtensionAttribute]
public static Nullable`1<Matrix> TransformToVisual(Visual from, Visual to);
    [ExtensionAttribute]
public static Nullable`1<Point> TranslatePoint(Visual visual, Point point, Visual relativeTo);
    private static Matrix GetOffsetFrom(Visual ancestor, Visual visual);
}
public class Avalonia.Visuals.Platform.PathGeometryContext : object {
    [NullableAttribute("2")]
private PathFigure _currentFigure;
    [NullableAttribute("2")]
private PathGeometry _pathGeometry;
    [NullableContextAttribute("1")]
public PathGeometryContext(PathGeometry pathGeometry);
    public sealed virtual void Dispose();
    public sealed virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection);
    public sealed virtual void BeginFigure(Point startPoint, bool isFilled);
    public sealed virtual void CubicBezierTo(Point controlPoint1, Point controlPoint2, Point endPoint);
    public sealed virtual void QuadraticBezierTo(Point controlPoint, Point endPoint);
    public sealed virtual void LineTo(Point endPoint);
    public sealed virtual void EndFigure(bool isClosed);
    public sealed virtual void SetFillRule(FillRule fillRule);
    [MemberNotNullAttribute("_pathGeometry")]
private void ThrowIfDisposed();
    [NullableContextAttribute("1")]
private PathSegments CurrentFigureSegments();
}
[NullableContextAttribute("2")]
public interface Avalonia.VisualTree.IHostedVisualTreeRoot {
    public Visual Host { get; }
    public abstract virtual Visual get_Host();
}
internal interface Avalonia.VisualTree.IVisualWithRoundRectClip {
    public CornerRadius ClipToBoundsRadius { get; }
    public abstract virtual CornerRadius get_ClipToBoundsRadius();
}
[IsReadOnlyAttribute]
public class Avalonia.VisualTree.TransformedBounds : ValueType {
    [CompilerGeneratedAttribute]
private Rect <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <Clip>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix <Transform>k__BackingField;
    public Rect Bounds { get; }
    public Rect Clip { get; }
    public Matrix Transform { get; }
    public TransformedBounds(Rect bounds, Rect clip, Matrix transform);
    [CompilerGeneratedAttribute]
public Rect get_Bounds();
    [CompilerGeneratedAttribute]
public Rect get_Clip();
    [CompilerGeneratedAttribute]
public Matrix get_Transform();
    public bool Contains(Point point);
    public sealed virtual bool Equals(TransformedBounds other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TransformedBounds left, TransformedBounds right);
    public static bool op_Inequality(TransformedBounds left, TransformedBounds right);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Avalonia.VisualTree.VisualExtensions : object {
    [ExtensionAttribute]
public static int CalculateDistanceFromAncestor(Visual visual, Visual ancestor);
    public static int CalculateDistanceFromRoot(Visual visual);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Visual FindCommonVisualAncestor(Visual visual, Visual target);
    [IteratorStateMachineAttribute("Avalonia.VisualTree.VisualExtensions/<GetVisualAncestors>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<Visual> GetVisualAncestors(Visual visual);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FindAncestorOfType(Visual visual, bool includeSelf);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FindDescendantOfType(Visual visual, bool includeSelf);
    [IteratorStateMachineAttribute("Avalonia.VisualTree.VisualExtensions/<GetSelfAndVisualAncestors>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<Visual> GetSelfAndVisualAncestors(Visual visual);
    [ExtensionAttribute]
public static Nullable`1<TransformedBounds> GetTransformedBounds(Visual visual);
    [ExtensionAttribute]
public static Visual GetVisualAt(Visual visual, Point p);
    [ExtensionAttribute]
public static Visual GetVisualAt(Visual visual, Point p, Func`2<Visual, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<Visual> GetVisualsAt(Visual visual, Point p);
    [ExtensionAttribute]
public static IEnumerable`1<Visual> GetVisualsAt(Visual visual, Point p, Func`2<Visual, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<Visual> GetVisualChildren(Visual visual);
    [IteratorStateMachineAttribute("Avalonia.VisualTree.VisualExtensions/<GetVisualDescendants>d__13")]
[ExtensionAttribute]
public static IEnumerable`1<Visual> GetVisualDescendants(Visual visual);
    [IteratorStateMachineAttribute("Avalonia.VisualTree.VisualExtensions/<GetSelfAndVisualDescendants>d__14")]
[ExtensionAttribute]
public static IEnumerable`1<Visual> GetSelfAndVisualDescendants(Visual visual);
    [ExtensionAttribute]
public static Visual GetVisualParent(Visual visual);
    [ExtensionAttribute]
public static T GetVisualParent(Visual visual);
    [ExtensionAttribute]
public static IRenderRoot GetVisualRoot(Visual visual);
    [ExtensionAttribute]
public static bool IsAttachedToVisualTree(Visual visual);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsVisualAncestorOf(Visual visual, Visual target);
    [ExtensionAttribute]
public static IEnumerable`1<Visual> SortByZIndex(IEnumerable`1<Visual> elements);
    private static T FindDescendantOfTypeCore(Visual visual);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <FindCommonVisualAncestor>g__GoUpwards|2_0(Visual& node, int count);
    [CompilerGeneratedAttribute]
internal static bool <GetTransformedBounds>g__Visit|7_0(Visual visual, <>c__DisplayClass7_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.VisualTree.VisualLocator : object {
    public static IObservable`1<Visual> Track(Visual relativeTo, int ancestorLevel, Type ancestorType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.VisualTreeAttachmentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Visual <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IRenderRoot <Root>k__BackingField;
    public Visual Parent { get; }
    public IRenderRoot Root { get; }
    public VisualTreeAttachmentEventArgs(Visual parent, IRenderRoot root);
    [CompilerGeneratedAttribute]
public Visual get_Parent();
    [CompilerGeneratedAttribute]
public IRenderRoot get_Root();
}
[FlagsAttribute]
internal enum CompositionContainerVisualChangedFields : Enum {
    public byte value__;
}
[FlagsAttribute]
internal enum CompositionExperimentalAcrylicVisualChangedFields : Enum {
    public byte value__;
    public static CompositionExperimentalAcrylicVisualChangedFields Material;
    public static CompositionExperimentalAcrylicVisualChangedFields CornerRadius;
}
[FlagsAttribute]
internal enum CompositionSimpleBrushChangedFields : Enum {
    public byte value__;
    public static CompositionSimpleBrushChangedFields Opacity;
    public static CompositionSimpleBrushChangedFields TransformOrigin;
    public static CompositionSimpleBrushChangedFields Transform;
}
[FlagsAttribute]
internal enum CompositionSimpleConicGradientBrushChangedFields : Enum {
    public byte value__;
    public static CompositionSimpleConicGradientBrushChangedFields Angle;
    public static CompositionSimpleConicGradientBrushChangedFields Center;
}
[FlagsAttribute]
internal enum CompositionSimpleLinearGradientBrushChangedFields : Enum {
    public byte value__;
    public static CompositionSimpleLinearGradientBrushChangedFields StartPoint;
    public static CompositionSimpleLinearGradientBrushChangedFields EndPoint;
}
[FlagsAttribute]
internal enum CompositionSimplePenChangedFields : Enum {
    public byte value__;
    public static CompositionSimplePenChangedFields Brush;
    public static CompositionSimplePenChangedFields DashStyle;
    public static CompositionSimplePenChangedFields LineCap;
    public static CompositionSimplePenChangedFields LineJoin;
    public static CompositionSimplePenChangedFields MiterLimit;
    public static CompositionSimplePenChangedFields Thickness;
}
[FlagsAttribute]
internal enum CompositionSimpleRadialGradientBrushChangedFields : Enum {
    public byte value__;
    public static CompositionSimpleRadialGradientBrushChangedFields Center;
    public static CompositionSimpleRadialGradientBrushChangedFields GradientOrigin;
    public static CompositionSimpleRadialGradientBrushChangedFields RadiusX;
    public static CompositionSimpleRadialGradientBrushChangedFields RadiusY;
}
[FlagsAttribute]
internal enum CompositionSimpleSolidColorBrushChangedFields : Enum {
    public byte value__;
    public static CompositionSimpleSolidColorBrushChangedFields Color;
}
[FlagsAttribute]
internal enum CompositionSimpleTileBrushChangedFields : Enum {
    public byte value__;
    public static CompositionSimpleTileBrushChangedFields AlignmentX;
    public static CompositionSimpleTileBrushChangedFields AlignmentY;
    public static CompositionSimpleTileBrushChangedFields DestinationRect;
    public static CompositionSimpleTileBrushChangedFields SourceRect;
    public static CompositionSimpleTileBrushChangedFields Stretch;
    public static CompositionSimpleTileBrushChangedFields TileMode;
}
[FlagsAttribute]
internal enum CompositionSimpleTransformChangedFields : Enum {
    public byte value__;
    public static CompositionSimpleTransformChangedFields Value;
}
[FlagsAttribute]
internal enum CompositionSolidColorVisualChangedFields : Enum {
    public byte value__;
    public static CompositionSolidColorVisualChangedFields Color;
    public static CompositionSolidColorVisualChangedFields ColorAnimated;
}
[FlagsAttribute]
internal enum CompositionSurfaceVisualChangedFields : Enum {
    public byte value__;
    public static CompositionSurfaceVisualChangedFields Surface;
}
[FlagsAttribute]
internal enum CompositionTargetChangedFields : Enum {
    public byte value__;
    public static CompositionTargetChangedFields Root;
    public static CompositionTargetChangedFields IsEnabled;
    public static CompositionTargetChangedFields DebugOverlays;
    public static CompositionTargetChangedFields LastLayoutPassTiming;
    public static CompositionTargetChangedFields Scaling;
    public static CompositionTargetChangedFields PixelSize;
}
[FlagsAttribute]
internal enum CompositionVisualChangedFields : Enum {
    public UInt32 value__;
    public static CompositionVisualChangedFields Root;
    public static CompositionVisualChangedFields Parent;
    public static CompositionVisualChangedFields Visible;
    public static CompositionVisualChangedFields VisibleAnimated;
    public static CompositionVisualChangedFields Opacity;
    public static CompositionVisualChangedFields OpacityAnimated;
    public static CompositionVisualChangedFields Clip;
    public static CompositionVisualChangedFields ClipToBounds;
    public static CompositionVisualChangedFields ClipToBoundsAnimated;
    public static CompositionVisualChangedFields Offset;
    public static CompositionVisualChangedFields OffsetAnimated;
    public static CompositionVisualChangedFields Size;
    public static CompositionVisualChangedFields SizeAnimated;
    public static CompositionVisualChangedFields AnchorPoint;
    public static CompositionVisualChangedFields AnchorPointAnimated;
    public static CompositionVisualChangedFields CenterPoint;
    public static CompositionVisualChangedFields CenterPointAnimated;
    public static CompositionVisualChangedFields RotationAngle;
    public static CompositionVisualChangedFields RotationAngleAnimated;
    public static CompositionVisualChangedFields Orientation;
    public static CompositionVisualChangedFields OrientationAnimated;
    public static CompositionVisualChangedFields Scale;
    public static CompositionVisualChangedFields ScaleAnimated;
    public static CompositionVisualChangedFields TransformMatrix;
    public static CompositionVisualChangedFields TransformMatrixAnimated;
    public static CompositionVisualChangedFields AdornedVisual;
    public static CompositionVisualChangedFields AdornerIsClipped;
    public static CompositionVisualChangedFields OpacityMaskBrush;
    public static CompositionVisualChangedFields Effect;
    public static CompositionVisualChangedFields RenderOptions;
}
[FlagsAttribute]
internal enum CompositionVisualCollectionChangedFields : Enum {
    public byte value__;
}
internal static class Polyfills : object {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
