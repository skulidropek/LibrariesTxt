[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.OpenGL.Controls.CompositionOpenGlSwapchain : SwapchainBase`1<IGlSwapchainImage> {
    private IGlContext _context;
    [NullableAttribute("2")]
private IGlContextExternalObjectsFeature _externalObjectsFeature;
    [NullableAttribute("2")]
private IOpenGlTextureSharingRenderInterfaceContextFeature _sharingFeature;
    public CompositionOpenGlSwapchain(IGlContext context, ICompositionGpuInterop interop, CompositionDrawingSurface target, IOpenGlTextureSharingRenderInterfaceContextFeature sharingFeature);
    public CompositionOpenGlSwapchain(IGlContext context, ICompositionGpuInterop interop, CompositionDrawingSurface target, IGlContextExternalObjectsFeature externalObjectsFeature);
    protected virtual IGlSwapchainImage CreateImage(PixelSize size);
    public IDisposable BeginDraw(PixelSize size, IGlTexture& texture);
}
internal class Avalonia.OpenGL.Controls.CompositionOpenGlSwapChainImage : object {
    [NullableAttribute("1")]
private ICompositionGpuInterop _interop;
    [NullableAttribute("1")]
private CompositionDrawingSurface _target;
    [NullableAttribute("1")]
private ICompositionImportableOpenGlSharedTexture _texture;
    [NullableAttribute("2")]
private ICompositionImportedGpuImage _imported;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Task <LastPresent>k__BackingField;
    public int TextureId { get; }
    public int InternalFormat { get; }
    public PixelSize Size { get; }
    [NullableAttribute("2")]
public Task LastPresent { get; private set; }
    [NullableContextAttribute("1")]
public CompositionOpenGlSwapChainImage(IGlContext context, IOpenGlTextureSharingRenderInterfaceContextFeature sharingFeature, PixelSize size, ICompositionGpuInterop interop, CompositionDrawingSurface target);
    [AsyncStateMachineAttribute("Avalonia.OpenGL.Controls.CompositionOpenGlSwapChainImage/<DisposeAsync>d__5")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual int get_TextureId();
    public sealed virtual int get_InternalFormat();
    public sealed virtual PixelSize get_Size();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Task get_LastPresent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_LastPresent(Task value);
    public sealed virtual void BeginDraw();
    public sealed virtual void Present();
}
internal class Avalonia.OpenGL.Controls.DxgiMutexOpenGlSwapChainImage : object {
    [NullableAttribute("1")]
private ICompositionGpuInterop _interop;
    [NullableAttribute("1")]
private CompositionDrawingSurface _surface;
    [NullableAttribute("1")]
private IGlExportableExternalImageTexture _texture;
    [NullableAttribute("2")]
private Task _lastPresent;
    [NullableAttribute("2")]
private ICompositionImportedGpuImage _imported;
    public int TextureId { get; }
    public int InternalFormat { get; }
    public PixelSize Size { get; }
    [NullableAttribute("2")]
public Task LastPresent { get; }
    [NullableContextAttribute("1")]
public DxgiMutexOpenGlSwapChainImage(ICompositionGpuInterop interop, CompositionDrawingSurface surface, IGlContextExternalObjectsFeature externalObjects, PixelSize size);
    [AsyncStateMachineAttribute("Avalonia.OpenGL.Controls.DxgiMutexOpenGlSwapChainImage/<DisposeAsync>d__6")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual int get_TextureId();
    public sealed virtual int get_InternalFormat();
    public sealed virtual PixelSize get_Size();
    [NullableContextAttribute("2")]
public sealed virtual Task get_LastPresent();
    public sealed virtual void BeginDraw();
    public sealed virtual void Present();
}
internal interface Avalonia.OpenGL.Controls.IGlSwapchainImage {
}
internal interface Avalonia.OpenGL.Controls.IGlTexture {
    public int TextureId { get; }
    public int InternalFormat { get; }
    public PixelSize Size { get; }
    public abstract virtual int get_TextureId();
    public abstract virtual int get_InternalFormat();
    public abstract virtual PixelSize get_Size();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.OpenGL.Controls.OpenGlControlBase : Control {
    [NullableAttribute("2")]
private CompositionSurfaceVisual _visual;
    private Action _update;
    private bool _updateQueued;
    [NullableAttribute("2")]
private Task`1<bool> _initialization;
    [NullableAttribute("2")]
private OpenGlControlBaseResources _resources;
    [NullableAttribute("2")]
private Compositor _compositor;
    protected GlVersion GlVersion { get; }
    protected GlVersion get_GlVersion();
    private void DoCleanup();
    protected virtual void OnDetachedFromVisualTree(VisualTreeAttachmentEventArgs e);
    protected virtual void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e);
    [MemberNotNullWhenAttribute("True", "_resources")]
private bool EnsureInitializedCore(ICompositionGpuInterop interop, IOpenGlTextureSharingRenderInterfaceContextFeature contextSharingFeature);
    protected virtual void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change);
    private void ContextLost();
    [MemberNotNullWhenAttribute("True", "_resources")]
private bool EnsureInitialized();
    private void Update();
    [AsyncStateMachineAttribute("Avalonia.OpenGL.Controls.OpenGlControlBase/<InitializeAsync>d__17")]
private Task`1<bool> InitializeAsync();
    [ObsoleteAttribute("Use RequestNextFrameRendering()")]
[EditorBrowsableAttribute("1")]
public void InvalidateVisual();
    public void RequestNextFrameRendering();
    private PixelSize GetPixelSize(IRenderRoot visualRoot);
    protected virtual void OnOpenGlInit(GlInterface gl);
    protected virtual void OnOpenGlDeinit(GlInterface gl);
    protected virtual void OnOpenGlLost();
    protected abstract virtual void OnOpenGlRender(GlInterface gl, int fb);
    [AsyncStateMachineAttribute("Avalonia.OpenGL.Controls.OpenGlControlBase/<<EnsureInitialized>g__ContinueOnInitialization|15_0>d")]
[CompilerGeneratedAttribute]
private void <EnsureInitialized>g__ContinueOnInitialization|15_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.OpenGL.Controls.OpenGlControlBaseResources : object {
    private int _depthBuffer;
    [CompilerGeneratedAttribute]
private int <Fbo>k__BackingField;
    private PixelSize _depthBufferSize;
    [CompilerGeneratedAttribute]
private CompositionDrawingSurface <Surface>k__BackingField;
    private CompositionOpenGlSwapchain _swapchain;
    [CompilerGeneratedAttribute]
private IGlContext <Context>k__BackingField;
    public int Fbo { get; private set; }
    public CompositionDrawingSurface Surface { get; }
    public IGlContext Context { get; private set; }
    private OpenGlControlBaseResources(IGlContext context, CompositionDrawingSurface surface, ICompositionGpuInterop interop, IOpenGlTextureSharingRenderInterfaceContextFeature feature, IGlContextExternalObjectsFeature externalObjects);
    [CompilerGeneratedAttribute]
public int get_Fbo();
    [CompilerGeneratedAttribute]
private void set_Fbo(int value);
    [CompilerGeneratedAttribute]
public CompositionDrawingSurface get_Surface();
    [CompilerGeneratedAttribute]
public IGlContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(IGlContext value);
    public static OpenGlControlBaseResources TryCreate(CompositionDrawingSurface surface, ICompositionGpuInterop interop, IOpenGlTextureSharingRenderInterfaceContextFeature feature);
    public static OpenGlControlBaseResources TryCreate(IGlContext context, CompositionDrawingSurface surface, ICompositionGpuInterop interop, IGlContextExternalObjectsFeature externalObjects);
    private void UpdateDepthRenderbuffer(PixelSize size);
    public IDisposable BeginDraw(PixelSize size);
    [AsyncStateMachineAttribute("Avalonia.OpenGL.Controls.OpenGlControlBaseResources/<DisposeAsync>d__19")]
public sealed virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.OpenGL.Egl.EglConfigInfo : object {
    [CompilerGeneratedAttribute]
private IntPtr <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private GlVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SurfaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StencilSize>k__BackingField;
    public IntPtr Config { get; }
    public GlVersion Version { get; }
    public int SurfaceType { get; }
    public Int32[] Attributes { get; }
    public int SampleCount { get; }
    public int StencilSize { get; }
    public EglConfigInfo(IntPtr config, GlVersion version, int surfaceType, Int32[] attributes, int sampleCount, int stencilSize);
    [CompilerGeneratedAttribute]
public IntPtr get_Config();
    [CompilerGeneratedAttribute]
public GlVersion get_Version();
    [CompilerGeneratedAttribute]
public int get_SurfaceType();
    [CompilerGeneratedAttribute]
public Int32[] get_Attributes();
    [CompilerGeneratedAttribute]
public int get_SampleCount();
    [CompilerGeneratedAttribute]
public int get_StencilSize();
}
public static class Avalonia.OpenGL.Egl.EglConsts : object {
    public static int EGL_ALPHA_SIZE;
    public static int EGL_BAD_ACCESS;
    public static int EGL_BAD_ALLOC;
    public static int EGL_BAD_ATTRIBUTE;
    public static int EGL_BAD_CONFIG;
    public static int EGL_BAD_CONTEXT;
    public static int EGL_BAD_CURRENT_SURFACE;
    public static int EGL_BAD_DISPLAY;
    public static int EGL_BAD_MATCH;
    public static int EGL_BAD_NATIVE_PIXMAP;
    public static int EGL_BAD_NATIVE_WINDOW;
    public static int EGL_BAD_PARAMETER;
    public static int EGL_BAD_SURFACE;
    public static int EGL_BLUE_SIZE;
    public static int EGL_CORE_NATIVE_ENGINE;
    public static int EGL_DEPTH_SIZE;
    public static int EGL_DRAW;
    public static int EGL_EXTENSIONS;
    public static int EGL_FALSE;
    public static int EGL_GREEN_SIZE;
    public static int EGL_HEIGHT;
    public static int EGL_NONE;
    public static int EGL_NOT_INITIALIZED;
    public static int EGL_NO_CONTEXT;
    public static int EGL_NO_DISPLAY;
    public static int EGL_NO_SURFACE;
    public static int EGL_PBUFFER_BIT;
    public static int EGL_READ;
    public static int EGL_RED_SIZE;
    public static int EGL_SAMPLES;
    public static int EGL_STENCIL_SIZE;
    public static int EGL_SUCCESS;
    public static int EGL_SURFACE_TYPE;
    public static int EGL_TRUE;
    public static int EGL_WIDTH;
    public static int EGL_WINDOW_BIT;
    public static int EGL_BACK_BUFFER;
    public static int EGL_CONTEXT_LOST;
    public static int EGL_TEXTURE_2D;
    public static int EGL_TEXTURE_FORMAT;
    public static int EGL_TEXTURE_RGBA;
    public static int EGL_TEXTURE_TARGET;
    public static int EGL_OPENGL_ES_BIT;
    public static int EGL_OPENGL_ES_API;
    public static int EGL_RENDERABLE_TYPE;
    public static int EGL_OPENGL_ES2_BIT;
    public static int EGL_CONTEXT_MAJOR_VERSION;
    public static int EGL_CONTEXT_MINOR_VERSION;
    public static int EGL_OPENGL_ES3_BIT;
    public static int EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE;
    public static int EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE;
    public static int EGL_PLATFORM_ANGLE_ANGLE;
    public static int EGL_PLATFORM_ANGLE_TYPE_ANGLE;
    public static int EGL_PLATFORM_DEVICE_EXT;
    public static int EGL_DEVICE_EXT;
    public static int EGL_D3D9_DEVICE_ANGLE;
    public static int EGL_D3D11_DEVICE_ANGLE;
    public static int EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE;
    public static int EGL_D3D_TEXTURE_ANGLE;
    public static int EGL_TEXTURE_OFFSET_X_ANGLE;
    public static int EGL_TEXTURE_OFFSET_Y_ANGLE;
    public static int EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE;
    public static int EGL_TEXTURE_INTERNAL_FORMAT_ANGLE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Egl.EglContext : object {
    private EglDisplay _disp;
    private EglInterface _egl;
    [NullableAttribute("2")]
private EglContext _sharedWith;
    private bool _isLost;
    private IntPtr _context;
    [NullableAttribute("2")]
private Action _disposeCallback;
    private Dictionary`2<Type, object> _features;
    private object _lock;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EglSurface <OffscreenSurface>k__BackingField;
    [CompilerGeneratedAttribute]
private GlVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private GlInterface <GlInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StencilSize>k__BackingField;
    public IntPtr Context { get; }
    [NullableAttribute("2")]
public EglSurface OffscreenSurface { get; }
    public GlVersion Version { get; }
    public GlInterface GlInterface { get; }
    public int SampleCount { get; }
    public int StencilSize { get; }
    public EglDisplay Display { get; }
    public EglInterface EglInterface { get; }
    public bool IsLost { get; }
    public bool CanCreateSharedContext { get; }
    public bool IsCurrent { get; }
    internal EglContext(EglDisplay display, EglInterface egl, EglContext sharedWith, IntPtr ctx, EglSurface offscreenSurface, GlVersion version, int sampleCount, int stencilSize, Action disposeCallback, Dictionary`2<Type, Func`2<EglContext, object>> features);
    public IntPtr get_Context();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public EglSurface get_OffscreenSurface();
    [CompilerGeneratedAttribute]
public sealed virtual GlVersion get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual GlInterface get_GlInterface();
    [CompilerGeneratedAttribute]
public sealed virtual int get_SampleCount();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StencilSize();
    public EglDisplay get_Display();
    public EglInterface get_EglInterface();
    public sealed virtual IDisposable MakeCurrent();
    public IDisposable MakeCurrent(EglSurface surface);
    public void NotifyContextLost();
    public sealed virtual bool get_IsLost();
    public sealed virtual IDisposable EnsureCurrent();
    public IDisposable EnsureLocked();
    public sealed virtual bool IsSharedWith(IGlContext context);
    public sealed virtual bool get_CanCreateSharedContext();
    public sealed virtual IGlContext CreateSharedContext(IEnumerable`1<GlVersion> preferredVersions);
    public bool get_IsCurrent();
    public sealed virtual void Dispose();
    public sealed virtual object TryGetFeature(Type featureType);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private object <.ctor>b__8_1(KeyValuePair`2<Type, Func`2<EglContext, object>> x);
    [CompilerGeneratedAttribute]
private void <EnsureLocked>b__37_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Egl.EglContextOptions : object {
    [CompilerGeneratedAttribute]
private EglContext <ShareWith>k__BackingField;
    [CompilerGeneratedAttribute]
private EglSurface <OffscreenSurface>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <DisposeCallback>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<Type, Func`2<EglContext, object>> <ExtraFeatures>k__BackingField;
    public EglContext ShareWith { get; public set; }
    public EglSurface OffscreenSurface { get; public set; }
    public Action DisposeCallback { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<Type, Func`2<EglContext, object>> ExtraFeatures { get; public set; }
    [CompilerGeneratedAttribute]
public EglContext get_ShareWith();
    [CompilerGeneratedAttribute]
public void set_ShareWith(EglContext value);
    [CompilerGeneratedAttribute]
public EglSurface get_OffscreenSurface();
    [CompilerGeneratedAttribute]
public void set_OffscreenSurface(EglSurface value);
    [CompilerGeneratedAttribute]
public Action get_DisposeCallback();
    [CompilerGeneratedAttribute]
public void set_DisposeCallback(Action value);
    [CompilerGeneratedAttribute]
public Dictionary`2<Type, Func`2<EglContext, object>> get_ExtraFeatures();
    [CompilerGeneratedAttribute]
public void set_ExtraFeatures(Dictionary`2<Type, Func`2<EglContext, object>> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Egl.EglDisplay : object {
    private EglInterface _egl;
    private IntPtr _display;
    private EglDisplayOptions _options;
    private EglConfigInfo _config;
    private bool _isLost;
    private object _lock;
    [CompilerGeneratedAttribute]
private bool <SupportsSharing>k__BackingField;
    private List`1<EglContext> _contexts;
    public bool SupportsSharing { get; }
    public IntPtr Handle { get; }
    public IntPtr Config { get; }
    internal bool SingleContext { get; }
    public EglInterface EglInterface { get; }
    protected bool DisplayLockIsSharedWithContexts { get; }
    [NullableAttribute("2")]
internal object ContextSharedSyncRoot { get; }
    public bool IsLost { get; }
    public EglDisplay(EglDisplayCreationOptions options);
    public EglDisplay(IntPtr display, EglDisplayOptions options);
    [CompilerGeneratedAttribute]
public bool get_SupportsSharing();
    public IntPtr get_Handle();
    public IntPtr get_Config();
    internal bool get_SingleContext();
    public EglInterface get_EglInterface();
    public EglContext CreateContext(EglContextOptions options);
    public EglSurface CreateWindowSurface(IntPtr window);
    public EglSurface CreatePBufferFromClientBuffer(int bufferType, IntPtr handle, Int32[] attribs);
    [NullableContextAttribute("0")]
public EglSurface CreatePBufferFromClientBuffer(int bufferType, IntPtr handle, Int32* attribs);
    protected virtual bool get_DisplayLockIsSharedWithContexts();
    [NullableContextAttribute("2")]
internal object get_ContextSharedSyncRoot();
    internal void OnContextLost(EglContext context);
    internal void OnContextDisposed(EglContext context);
    public bool get_IsLost();
    public IDisposable Lock();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Lock>b__33_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Egl.EglDisplayCreationOptions : EglDisplayOptions {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PlatformType>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <PlatformDisplay>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <PlatformDisplayAttrs>k__BackingField;
    public Nullable`1<int> PlatformType { get; public set; }
    public IntPtr PlatformDisplay { get; public set; }
    public Int32[] PlatformDisplayAttrs { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PlatformType();
    [CompilerGeneratedAttribute]
public void set_PlatformType(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IntPtr get_PlatformDisplay();
    [CompilerGeneratedAttribute]
public void set_PlatformDisplay(IntPtr value);
    [CompilerGeneratedAttribute]
public Int32[] get_PlatformDisplayAttrs();
    [CompilerGeneratedAttribute]
public void set_PlatformDisplayAttrs(Int32[] value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Egl.EglDisplayOptions : object {
    [CompilerGeneratedAttribute]
private EglInterface <Egl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsContextSharing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsMultipleContexts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContextLossIsDisplayLoss>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<bool> <DeviceLostCheckCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <DisposeCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<GlVersion> <GlVersions>k__BackingField;
    public EglInterface Egl { get; public set; }
    public bool SupportsContextSharing { get; public set; }
    public bool SupportsMultipleContexts { get; public set; }
    public bool ContextLossIsDisplayLoss { get; public set; }
    public Func`1<bool> DeviceLostCheckCallback { get; public set; }
    public Action DisposeCallback { get; public set; }
    public IEnumerable`1<GlVersion> GlVersions { get; public set; }
    [CompilerGeneratedAttribute]
public EglInterface get_Egl();
    [CompilerGeneratedAttribute]
public void set_Egl(EglInterface value);
    [CompilerGeneratedAttribute]
public bool get_SupportsContextSharing();
    [CompilerGeneratedAttribute]
public void set_SupportsContextSharing(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportsMultipleContexts();
    [CompilerGeneratedAttribute]
public void set_SupportsMultipleContexts(bool value);
    [CompilerGeneratedAttribute]
public bool get_ContextLossIsDisplayLoss();
    [CompilerGeneratedAttribute]
public void set_ContextLossIsDisplayLoss(bool value);
    [CompilerGeneratedAttribute]
public Func`1<bool> get_DeviceLostCheckCallback();
    [CompilerGeneratedAttribute]
public void set_DeviceLostCheckCallback(Func`1<bool> value);
    [CompilerGeneratedAttribute]
public Action get_DisposeCallback();
    [CompilerGeneratedAttribute]
public void set_DisposeCallback(Action value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<GlVersion> get_GlVersions();
    [CompilerGeneratedAttribute]
public void set_GlVersions(IEnumerable`1<GlVersion> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.OpenGL.Egl.EglDisplayUtils : object {
    public static IntPtr CreateDisplay(EglDisplayCreationOptions options);
    public static EglConfigInfo InitializeAndGetConfig(EglInterface egl, IntPtr display, IEnumerable`1<GlVersion> versions);
}
public enum Avalonia.OpenGL.Egl.EglErrors : Enum {
    public int value__;
    public static EglErrors EGL_SUCCESS;
    public static EglErrors EGL_NOT_INITIALIZED;
    public static EglErrors EGL_BAD_ACCESS;
    public static EglErrors EGL_BAD_ALLOC;
    public static EglErrors EGL_BAD_ATTRIBUTE;
    public static EglErrors EGL_BAD_CONTEXT;
    public static EglErrors EGL_BAD_CONFIG;
    public static EglErrors EGL_BAD_CURRENT_SURFACE;
    public static EglErrors EGL_BAD_DISPLAY;
    public static EglErrors EGL_BAD_SURFACE;
    public static EglErrors EGL_BAD_MATCH;
    public static EglErrors EGL_BAD_PARAMETER;
    public static EglErrors EGL_BAD_NATIVE_PIXMAP;
    public static EglErrors EGL_BAD_NATIVE_WINDOW;
    public static EglErrors EGL_CONTEXT_LOST;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Egl.EglGlPlatformSurface : EglGlPlatformSurfaceBase {
    private IEglWindowGlPlatformSurfaceInfo _info;
    public EglGlPlatformSurface(IEglWindowGlPlatformSurfaceInfo info);
    public virtual IGlPlatformSurfaceRenderTarget CreateGlRenderTarget(IGlContext context);
}
public abstract class Avalonia.OpenGL.Egl.EglGlPlatformSurfaceBase : object {
    [NullableContextAttribute("1")]
public abstract virtual IGlPlatformSurfaceRenderTarget CreateGlRenderTarget(IGlContext context);
}
public class Avalonia.OpenGL.Egl.EglInterface : object {
    private method _addr_GetError;
    private method _addr_GetDisplay;
    private method _addr_GetPlatformDisplayExt;
    private method _addr_Initialize;
    private method _addr_Terminate;
    private method _addr_GetProcAddress;
    private method _addr_BindApi;
    private method _addr_ChooseConfig;
    private method _addr_CreateContext;
    private method _addr_DestroyContext;
    private method _addr_CreatePBufferSurface;
    private method _addr_MakeCurrent;
    private method _addr_GetCurrentContext;
    private method _addr_GetCurrentDisplay;
    private method _addr_GetCurrentSurface;
    private method _addr_DestroySurface;
    private method _addr_SwapBuffers;
    private method _addr_CreateWindowSurface;
    private method _addr_BindTexImage;
    private method _addr_GetConfigAttrib;
    private method _addr_WaitGL;
    private method _addr_WaitClient;
    private method _addr_WaitNative;
    private method _addr_QueryStringNative;
    private method _addr_CreatePbufferFromClientBuffer;
    private method _addr_CreatePbufferFromClientBufferPtr;
    private method _addr_QueryDisplayAttribExt;
    private method _addr_QueryDeviceAttribExt;
    public bool IsGetPlatformDisplayExtAvailable { get; }
    public bool IsQueryDisplayAttribExtAvailable { get; }
    public bool IsQueryDeviceAttribExtAvailable { get; }
    [NullableContextAttribute("1")]
public EglInterface(Func`2<string, IntPtr> getProcAddress);
    [NullableContextAttribute("1")]
public EglInterface(string library);
    [NullableContextAttribute("1")]
private static Func`2<string, IntPtr> Load();
    [NullableContextAttribute("1")]
private static Func`2<string, IntPtr> Load(string library);
    [GetProcAddressAttribute("eglGetError")]
public int GetError();
    [GetProcAddressAttribute("eglGetDisplay")]
public IntPtr GetDisplay(IntPtr nativeDisplay);
    [NullableContextAttribute("2")]
[GetProcAddressAttribute("eglGetPlatformDisplayEXT", "True")]
public IntPtr GetPlatformDisplayExt(int platform, IntPtr nativeDisplay, Int32[] attrs);
    [GetProcAddressAttribute("eglInitialize")]
public bool Initialize(IntPtr display, Int32& major, Int32& minor);
    [GetProcAddressAttribute("eglTerminate")]
public void Terminate(IntPtr display);
    [GetProcAddressAttribute("eglGetProcAddress")]
public IntPtr GetProcAddress(IntPtr proc);
    [GetProcAddressAttribute("eglBindAPI")]
public bool BindApi(int api);
    [NullableContextAttribute("1")]
[GetProcAddressAttribute("eglChooseConfig")]
public bool ChooseConfig(IntPtr display, Int32[] attribs, IntPtr& surfaceConfig, int numConfigs, Int32& choosenConfig);
    [NullableContextAttribute("1")]
[GetProcAddressAttribute("eglCreateContext")]
public IntPtr CreateContext(IntPtr display, IntPtr config, IntPtr share, Int32[] attrs);
    [GetProcAddressAttribute("eglDestroyContext")]
public bool DestroyContext(IntPtr display, IntPtr context);
    [NullableContextAttribute("2")]
[GetProcAddressAttribute("eglCreatePbufferSurface")]
public IntPtr CreatePBufferSurface(IntPtr display, IntPtr config, Int32[] attrs);
    [GetProcAddressAttribute("eglMakeCurrent")]
public bool MakeCurrent(IntPtr display, IntPtr draw, IntPtr read, IntPtr context);
    [GetProcAddressAttribute("eglGetCurrentContext")]
public IntPtr GetCurrentContext();
    [GetProcAddressAttribute("eglGetCurrentDisplay")]
public IntPtr GetCurrentDisplay();
    [GetProcAddressAttribute("eglGetCurrentSurface")]
public IntPtr GetCurrentSurface(int readDraw);
    [GetProcAddressAttribute("eglDestroySurface")]
public void DestroySurface(IntPtr display, IntPtr surface);
    [GetProcAddressAttribute("eglSwapBuffers")]
public void SwapBuffers(IntPtr display, IntPtr surface);
    [NullableContextAttribute("2")]
[GetProcAddressAttribute("eglCreateWindowSurface")]
public IntPtr CreateWindowSurface(IntPtr display, IntPtr config, IntPtr window, Int32[] attrs);
    [GetProcAddressAttribute("eglBindTexImage")]
public int BindTexImage(IntPtr display, IntPtr surface, int buffer);
    [GetProcAddressAttribute("eglGetConfigAttrib")]
public bool GetConfigAttrib(IntPtr display, IntPtr config, int attr, Int32& rv);
    [GetProcAddressAttribute("eglWaitGL")]
public bool WaitGL();
    [GetProcAddressAttribute("eglWaitClient")]
public bool WaitClient();
    [GetProcAddressAttribute("eglWaitNative")]
public bool WaitNative(int engine);
    [GetProcAddressAttribute("eglQueryString")]
public IntPtr QueryStringNative(IntPtr display, int i);
    [NullableContextAttribute("2")]
public string QueryString(IntPtr display, int i);
    [NullableContextAttribute("2")]
[GetProcAddressAttribute("eglCreatePbufferFromClientBuffer")]
public IntPtr CreatePbufferFromClientBuffer(IntPtr display, int buftype, IntPtr buffer, IntPtr config, Int32[] attrib_list);
    [GetProcAddressAttribute("eglCreatePbufferFromClientBuffer")]
public IntPtr CreatePbufferFromClientBufferPtr(IntPtr display, int buftype, IntPtr buffer, IntPtr config, Int32* attrib_list);
    [GetProcAddressAttribute("eglQueryDisplayAttribEXT", "True")]
public bool QueryDisplayAttribExt(IntPtr display, int attr, IntPtr& res);
    [GetProcAddressAttribute("eglQueryDeviceAttribEXT", "True")]
public bool QueryDeviceAttribExt(IntPtr display, int attr, IntPtr& res);
    public bool get_IsGetPlatformDisplayExtAvailable();
    public bool get_IsQueryDisplayAttribExtAvailable();
    public bool get_IsQueryDeviceAttribExtAvailable();
    [NullableContextAttribute("1")]
private void Initialize(Func`2<string, IntPtr> getProcAddress);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Egl.EglPlatformGraphics : object {
    private EglDisplay _display;
    public bool UsesSharedContext { get; }
    public EglPlatformGraphics(EglDisplay display);
    public sealed virtual bool get_UsesSharedContext();
    public sealed virtual IPlatformGraphicsContext CreateContext();
    public sealed virtual IPlatformGraphicsContext GetSharedContext();
    [NullableContextAttribute("2")]
public static EglPlatformGraphics TryCreate();
    public static EglPlatformGraphics TryCreate(Func`1<EglDisplay> displayFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Avalonia.OpenGL.Egl.EglPlatformSurfaceRenderTargetBase : object {
    [CompilerGeneratedAttribute]
private EglContext <Context>k__BackingField;
    protected EglContext Context { get; }
    public bool IsCorrupted { get; }
    protected EglPlatformSurfaceRenderTargetBase(EglContext context);
    [CompilerGeneratedAttribute]
protected EglContext get_Context();
    public virtual void Dispose();
    public sealed virtual IGlPlatformSurfaceRenderingSession BeginDraw();
    public abstract virtual IGlPlatformSurfaceRenderingSession BeginDrawCore();
    protected IGlPlatformSurfaceRenderingSession BeginDraw(EglSurface surface, PixelSize size, double scaling, Action onFinish, bool isYFlipped);
    public virtual bool get_IsCorrupted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Egl.EglSurface : SafeHandle {
    private EglDisplay _display;
    private EglInterface _egl;
    public bool IsInvalid { get; }
    public EglSurface(EglDisplay display, IntPtr surface);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    public void SwapBuffers();
}
internal class Avalonia.OpenGL.Features.ExternalObjectsInterface : object {
    private method _addr_ImportMemoryFdEXT;
    private method _addr_ImportSemaphoreFdEXT;
    private method _addr_CreateMemoryObjectsEXT;
    private method _addr_DeleteMemoryObjectsEXT;
    private method _addr_TexStorageMem2DEXT;
    private method _addr_GenSemaphoresEXT;
    private method _addr_DeleteSemaphoresEXT;
    private method _addr_WaitSemaphoreEXT;
    private method _addr_SignalSemaphoreEXT;
    private method _addr_GetUnsignedBytei_vEXT;
    private method _addr_GetUnsignedBytevEXT;
    public bool IsImportMemoryFdEXTAvailable { get; }
    public bool IsImportSemaphoreFdEXTAvailable { get; }
    public bool IsGetUnsignedBytei_vEXTAvailable { get; }
    public bool IsGetUnsignedBytevEXTAvailable { get; }
    [NullableContextAttribute("1")]
public ExternalObjectsInterface(Func`2<string, IntPtr> getProcAddress);
    [GetProcAddressAttribute("glImportMemoryFdEXT", "True")]
public void ImportMemoryFdEXT(UInt32 memory, ulong size, int handleType, int fd);
    [GetProcAddressAttribute("glImportSemaphoreFdEXT", "True")]
public void ImportSemaphoreFdEXT(UInt32 semaphore, int handleType, int fd);
    [GetProcAddressAttribute("glCreateMemoryObjectsEXT")]
public void CreateMemoryObjectsEXT(int n, UInt32& memoryObjects);
    [GetProcAddressAttribute("glDeleteMemoryObjectsEXT")]
public void DeleteMemoryObjectsEXT(int n, UInt32& objects);
    [GetProcAddressAttribute("glTexStorageMem2DEXT")]
public void TexStorageMem2DEXT(int target, int levels, int internalFormat, int width, int height, UInt32 memory, ulong offset);
    [GetProcAddressAttribute("glGenSemaphoresEXT")]
public void GenSemaphoresEXT(int n, UInt32& semaphores);
    [GetProcAddressAttribute("glDeleteSemaphoresEXT")]
public void DeleteSemaphoresEXT(int n, UInt32& semaphores);
    [GetProcAddressAttribute("glWaitSemaphoreEXT")]
public void WaitSemaphoreEXT(UInt32 semaphore, UInt32 numBufferBarriers, UInt32* buffers, UInt32 numTextureBarriers, Int32* textures, Int32* srcLayouts);
    [GetProcAddressAttribute("glSignalSemaphoreEXT")]
public void SignalSemaphoreEXT(UInt32 semaphore, UInt32 numBufferBarriers, UInt32* buffers, UInt32 numTextureBarriers, Int32* textures, Int32* dstLayouts);
    [GetProcAddressAttribute("glGetUnsignedBytei_vEXT", "True")]
public void GetUnsignedBytei_vEXT(int target, UInt32 index, Byte* data);
    [GetProcAddressAttribute("glGetUnsignedBytevEXT", "True")]
public void GetUnsignedBytevEXT(int target, Byte* data);
    public bool get_IsImportMemoryFdEXTAvailable();
    public bool get_IsImportSemaphoreFdEXTAvailable();
    public bool get_IsGetUnsignedBytei_vEXTAvailable();
    public bool get_IsGetUnsignedBytevEXTAvailable();
    [NullableContextAttribute("1")]
private void Initialize(Func`2<string, IntPtr> getProcAddress);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.Features.ExternalObjectsOpenGlExtensionFeature : object {
    private IGlContext _context;
    private ExternalObjectsInterface _ext;
    private List`1<string> _imageTypes;
    private List`1<string> _semaphoreTypes;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <SupportedExportableExternalImageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <SupportedExportableExternalSemaphoreTypes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <DeviceLuid>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <DeviceUuid>k__BackingField;
    public IReadOnlyList`1<string> SupportedImportableExternalImageTypes { get; }
    public IReadOnlyList`1<string> SupportedExportableExternalImageTypes { get; }
    public IReadOnlyList`1<string> SupportedImportableExternalSemaphoreTypes { get; }
    public IReadOnlyList`1<string> SupportedExportableExternalSemaphoreTypes { get; }
    [NullableAttribute("2")]
public Byte[] DeviceLuid { get; }
    [NullableAttribute("2")]
public Byte[] DeviceUuid { get; }
    private ExternalObjectsOpenGlExtensionFeature(IGlContext context, List`1<string> extensions);
    public static ExternalObjectsOpenGlExtensionFeature TryCreate(IGlContext context);
    public sealed virtual IReadOnlyList`1<string> get_SupportedImportableExternalImageTypes();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_SupportedExportableExternalImageTypes();
    public sealed virtual IReadOnlyList`1<string> get_SupportedImportableExternalSemaphoreTypes();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_SupportedExportableExternalSemaphoreTypes();
    public sealed virtual IReadOnlyList`1<PlatformGraphicsExternalImageFormat> GetSupportedFormatsForExternalMemoryType(string type);
    public sealed virtual IGlExportableExternalImageTexture CreateImage(string type, PixelSize size, PlatformGraphicsExternalImageFormat format);
    public sealed virtual IGlExportableExternalImageTexture CreateSemaphore(string type);
    public sealed virtual IGlExternalImageTexture ImportImage(IPlatformHandle handle, PlatformGraphicsExternalImageProperties properties);
    public sealed virtual IGlExternalSemaphore ImportSemaphore(IPlatformHandle handle);
    public sealed virtual CompositionGpuImportedImageSynchronizationCapabilities GetSynchronizationCapabilities(string imageHandleType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Byte[] get_DeviceLuid();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Byte[] get_DeviceUuid();
}
public class Avalonia.OpenGL.GlBasicInfoInterface : object {
    private method _addr_GetIntegerv;
    private method _addr_GetFloatv;
    private method _addr_GetStringNative;
    private method _addr_GetStringiNative;
    private method _addr_GetError;
    [NullableContextAttribute("1")]
public GlBasicInfoInterface(Func`2<string, IntPtr> getProcAddress);
    [GetProcAddressAttribute("glGetIntegerv")]
public void GetIntegerv(int name, Int32& rv);
    [GetProcAddressAttribute("glGetFloatv")]
public void GetFloatv(int name, Single& rv);
    [GetProcAddressAttribute("glGetString")]
public IntPtr GetStringNative(int v);
    [GetProcAddressAttribute("glGetStringi")]
public IntPtr GetStringiNative(int v, int v1);
    [GetProcAddressAttribute("glGetError")]
public int GetError();
    [NullableContextAttribute("2")]
public string GetString(int v);
    [NullableContextAttribute("2")]
public string GetString(int v, int index);
    [NullableContextAttribute("1")]
public List`1<string> GetExtensions();
    [NullableContextAttribute("1")]
private void Initialize(Func`2<string, IntPtr> getProcAddress);
}
public static class Avalonia.OpenGL.GlConsts : object {
    public static int GL_UNSIGNED_BYTE;
    public static int GL_UNSIGNED_SHORT;
    public static int GL_FLOAT;
    public static int GL_TRIANGLES;
    public static int GL_CULL_FACE;
    public static int GL_LESS;
    public static int GL_GREATER;
    public static int GL_DEPTH_TEST;
    public static int GL_DEPTH_COMPONENT;
    public static int GL_LINEAR;
    public static int GL_STENCIL_BITS;
    public static int GL_RGBA;
    public static int GL_SCISSOR_TEST;
    public static int GL_TEXTURE_2D;
    public static int GL_TEXTURE_MAG_FILTER;
    public static int GL_TEXTURE_MIN_FILTER;
    public static int GL_NEAREST;
    public static int GL_VENDOR;
    public static int GL_RENDERER;
    public static int GL_VERSION;
    public static int GL_EXTENSIONS;
    public static int GL_NO_ERROR;
    public static int GL_INVALID_ENUM;
    public static int GL_INVALID_VALUE;
    public static int GL_INVALID_OPERATION;
    public static int GL_STACK_OVERFLOW;
    public static int GL_STACK_UNDERFLOW;
    public static int GL_OUT_OF_MEMORY;
    public static int GL_INVALID_FRAMEBUFFER_OPERATION;
    public static int GL_CONTEXT_LOST;
    public static int GL_DEPTH_BUFFER_BIT;
    public static int GL_STENCIL_BUFFER_BIT;
    public static int GL_COLOR_BUFFER_BIT;
    public static int GL_TEXTURE_BINDING_2D;
    public static int GL_RGBA8;
    public static int GL_BGRA;
    public static int GL_TEXTURE0;
    public static int GL_ACTIVE_TEXTURE;
    public static int GL_SAMPLES;
    public static int GL_DEPTH_COMPONENT16;
    public static int GL_ARRAY_BUFFER;
    public static int GL_ELEMENT_ARRAY_BUFFER;
    public static int GL_STATIC_DRAW;
    public static int GL_FRAGMENT_SHADER;
    public static int GL_VERTEX_SHADER;
    public static int GL_COMPILE_STATUS;
    public static int GL_LINK_STATUS;
    public static int GL_INFO_LOG_LENGTH;
    public static int GL_MAJOR_VERSION;
    public static int GL_MINOR_VERSION;
    public static int GL_NUM_EXTENSIONS;
    public static int GL_DEPTH_STENCIL;
    public static int GL_DEPTH24_STENCIL8;
    public static int GL_FRAMEBUFFER_BINDING;
    public static int GL_RENDERBUFFER_BINDING;
    public static int GL_READ_FRAMEBUFFER;
    public static int GL_DRAW_FRAMEBUFFER;
    public static int GL_READ_FRAMEBUFFER_BINDING;
    public static int GL_FRAMEBUFFER_COMPLETE;
    public static int GL_COLOR_ATTACHMENT0;
    public static int GL_DEPTH_ATTACHMENT;
    public static int GL_STENCIL_ATTACHMENT;
    public static int GL_FRAMEBUFFER;
    public static int GL_RENDERBUFFER;
    public static int GL_RENDERBUFFER_WIDTH;
    public static int GL_RENDERBUFFER_HEIGHT;
    public static int GL_STENCIL_INDEX8;
    public static int GL_CONTEXT_CORE_PROFILE_BIT;
    public static int GL_CONTEXT_COMPATIBILITY_PROFILE_BIT;
    public static int GL_CONTEXT_PROFILE_MASK;
    internal static int GL_NUM_DEVICE_UUIDS_EXT;
    internal static int GL_DEVICE_UUID_EXT;
    internal static int GL_HANDLE_TYPE_OPAQUE_FD_EXT;
    public static int GL_DEVICE_LUID_EXT;
    internal static int GL_LAYOUT_COLOR_ATTACHMENT_EXT;
    internal static int GL_LAYOUT_TRANSFER_SRC_EXT;
}
public enum Avalonia.OpenGL.GlErrors : Enum {
    public int value__;
    public static GlErrors GL_NO_ERROR;
    public static GlErrors GL_INVALID_ENUM;
    public static GlErrors GL_INVALID_VALUE;
    public static GlErrors GL_INVALID_OPERATION;
    public static GlErrors GL_INVALID_FRAMEBUFFER_OPERATION;
    public static GlErrors GL_STACK_OVERFLOW;
    public static GlErrors GL_STACK_UNDERFLOW;
    public static GlErrors GL_OUT_OF_MEMORY;
    public static GlErrors GL_CONTEXT_LOST;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Avalonia.OpenGL.GlExtensionEntryPoint : Attribute {
    public GlExtensionEntryPoint(string entry, string extension);
    public GlExtensionEntryPoint(string entry, string extension, GlProfileType profile);
    public static IntPtr GetProcAddress(Func`2<string, IntPtr> getProcAddress, GlContextInfo context, string entry, string extension, Nullable`1<GlProfileType> profile);
}
public class Avalonia.OpenGL.GlInterface : GlBasicInfoInterface {
    [NullableAttribute("1")]
private Func`2<string, IntPtr> _getProcAddress;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Vendor>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Renderer>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private GlContextInfo <ContextInfo>k__BackingField;
    private method _addr_ClearStencil;
    private method _addr_ClearColor;
    private method _addr_ClearDepthDouble;
    private method _addr_ClearDepthFloat;
    private method _addr_DepthFunc;
    private method _addr_DepthMask;
    private method _addr_Clear;
    private method _addr_Viewport;
    private method _addr_Flush;
    private method _addr_Finish;
    private method _addr_GenFramebuffers;
    private method _addr_DeleteFramebuffers;
    private method _addr_BindFramebuffer;
    private method _addr_CheckFramebufferStatus;
    private method _addr_BlitFramebuffer;
    private method _addr_GenRenderbuffers;
    private method _addr_DeleteRenderbuffers;
    private method _addr_BindRenderbuffer;
    private method _addr_RenderbufferStorage;
    private method _addr_FramebufferRenderbuffer;
    private method _addr_GenTextures;
    private method _addr_BindTexture;
    private method _addr_ActiveTexture;
    private method _addr_DeleteTextures;
    private method _addr_TexImage2D;
    private method _addr_CopyTexSubImage2D;
    private method _addr_TexParameteri;
    private method _addr_FramebufferTexture2D;
    private method _addr_CreateShader;
    private method _addr_ShaderSource;
    private method _addr_CompileShader;
    private method _addr_GetShaderiv;
    private method _addr_GetShaderInfoLog;
    private method _addr_CreateProgram;
    private method _addr_AttachShader;
    private method _addr_LinkProgram;
    private method _addr_GetProgramiv;
    private method _addr_GetProgramInfoLog;
    private method _addr_BindAttribLocation;
    private method _addr_GenBuffers;
    private method _addr_BindBuffer;
    private method _addr_BufferData;
    private method _addr_GetAttribLocation;
    private method _addr_VertexAttribPointer;
    private method _addr_EnableVertexAttribArray;
    private method _addr_UseProgram;
    private method _addr_DrawArrays;
    private method _addr_DrawElements;
    private method _addr_GetUniformLocation;
    private method _addr_Uniform1f;
    private method _addr_UniformMatrix4fv;
    private method _addr_Enable;
    private method _addr_Disable;
    private method _addr_DeleteBuffers;
    private method _addr_DeleteProgram;
    private method _addr_DeleteShader;
    private method _addr_GetRenderbufferParameteriv;
    private method _addr_DeleteVertexArrays;
    private method _addr_BindVertexArray;
    private method _addr_GenVertexArrays;
    [NullableAttribute("2")]
public string Version { get; }
    [NullableAttribute("2")]
public string Vendor { get; }
    [NullableAttribute("2")]
public string Renderer { get; }
    [NullableAttribute("1")]
public GlContextInfo ContextInfo { get; }
    internal bool IsClearDepthDoubleAvailable { get; }
    internal bool IsClearDepthFloatAvailable { get; }
    public bool IsBlitFramebufferAvailable { get; }
    public bool IsDeleteVertexArraysAvailable { get; }
    public bool IsBindVertexArrayAvailable { get; }
    public bool IsGenVertexArraysAvailable { get; }
    [NullableContextAttribute("1")]
private GlInterface(GlContextInfo info, Func`2<string, IntPtr> getProcAddress);
    [NullableContextAttribute("1")]
public GlInterface(GlVersion version, Func`2<string, IntPtr> getProcAddress);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Version();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Vendor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Renderer();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public GlContextInfo get_ContextInfo();
    [NullableContextAttribute("1")]
public IntPtr GetProcAddress(string proc);
    [GetProcAddressAttribute("glClearStencil")]
public void ClearStencil(int s);
    [GetProcAddressAttribute("glClearColor")]
public void ClearColor(float r, float g, float b, float a);
    [GetProcAddressAttribute("glClearDepth", "True")]
internal void ClearDepthDouble(double value);
    [GetProcAddressAttribute("glClearDepthf", "True")]
internal void ClearDepthFloat(float value);
    public void ClearDepth(float value);
    [GetProcAddressAttribute("glDepthFunc")]
public void DepthFunc(int value);
    [GetProcAddressAttribute("glDepthMask")]
public void DepthMask(int value);
    [GetProcAddressAttribute("glClear")]
public void Clear(int bits);
    [GetProcAddressAttribute("glViewport")]
public void Viewport(int x, int y, int width, int height);
    [GetProcAddressAttribute("glFlush")]
public void Flush();
    [GetProcAddressAttribute("glFinish")]
public void Finish();
    [GetProcAddressAttribute("glGenFramebuffers")]
public void GenFramebuffers(int count, Int32* res);
    public int GenFramebuffer();
    [GetProcAddressAttribute("glDeleteFramebuffers")]
public void DeleteFramebuffers(int count, Int32* framebuffers);
    public void DeleteFramebuffer(int fb);
    [GetProcAddressAttribute("glBindFramebuffer")]
public void BindFramebuffer(int target, int fb);
    [GetProcAddressAttribute("glCheckFramebufferStatus")]
public int CheckFramebufferStatus(int target);
    [GlMinVersionEntryPoint("glBlitFramebuffer", "3", "0")]
[GetProcAddressAttribute("True")]
public void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter);
    [GetProcAddressAttribute("glGenRenderbuffers")]
public void GenRenderbuffers(int count, Int32* res);
    public int GenRenderbuffer();
    [GetProcAddressAttribute("glDeleteRenderbuffers")]
public void DeleteRenderbuffers(int count, Int32* renderbuffers);
    public void DeleteRenderbuffer(int renderbuffer);
    [GetProcAddressAttribute("glBindRenderbuffer")]
public void BindRenderbuffer(int target, int fb);
    [GetProcAddressAttribute("glRenderbufferStorage")]
public void RenderbufferStorage(int target, int internalFormat, int width, int height);
    [GetProcAddressAttribute("glFramebufferRenderbuffer")]
public void FramebufferRenderbuffer(int target, int attachment, int renderbufferTarget, int renderbuffer);
    [GetProcAddressAttribute("glGenTextures")]
public void GenTextures(int count, Int32* res);
    public int GenTexture();
    [GetProcAddressAttribute("glBindTexture")]
public void BindTexture(int target, int fb);
    [GetProcAddressAttribute("glActiveTexture")]
public void ActiveTexture(int texture);
    [GetProcAddressAttribute("glDeleteTextures")]
public void DeleteTextures(int count, Int32* textures);
    public void DeleteTexture(int texture);
    [GetProcAddressAttribute("glTexImage2D")]
public void TexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, IntPtr data);
    [GetProcAddressAttribute("glCopyTexSubImage2D")]
public void CopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height);
    [GetProcAddressAttribute("glTexParameteri")]
public void TexParameteri(int target, int name, int value);
    [GetProcAddressAttribute("glFramebufferTexture2D")]
public void FramebufferTexture2D(int target, int attachment, int texTarget, int texture, int level);
    [GetProcAddressAttribute("glCreateShader")]
public int CreateShader(int shaderType);
    [GetProcAddressAttribute("glShaderSource")]
public void ShaderSource(int shader, int count, IntPtr strings, IntPtr lengths);
    [NullableContextAttribute("1")]
public void ShaderSourceString(int shader, string source);
    [GetProcAddressAttribute("glCompileShader")]
public void CompileShader(int shader);
    [GetProcAddressAttribute("glGetShaderiv")]
public void GetShaderiv(int shader, int name, Int32* parameters);
    [GetProcAddressAttribute("glGetShaderInfoLog")]
public void GetShaderInfoLog(int shader, int maxLength, Int32& length, Void* infoLog);
    [NullableContextAttribute("1")]
public string CompileShaderAndGetError(int shader, string source);
    [GetProcAddressAttribute("glCreateProgram")]
public int CreateProgram();
    [GetProcAddressAttribute("glAttachShader")]
public void AttachShader(int program, int shader);
    [GetProcAddressAttribute("glLinkProgram")]
public void LinkProgram(int program);
    [GetProcAddressAttribute("glGetProgramiv")]
public void GetProgramiv(int program, int name, Int32* parameters);
    [GetProcAddressAttribute("glGetProgramInfoLog")]
public void GetProgramInfoLog(int program, int maxLength, Int32& len, Void* infoLog);
    [NullableContextAttribute("2")]
public string LinkProgramAndGetError(int program);
    [GetProcAddressAttribute("glBindAttribLocation")]
public void BindAttribLocation(int program, int index, IntPtr name);
    [NullableContextAttribute("1")]
public void BindAttribLocationString(int program, int index, string name);
    [GetProcAddressAttribute("glGenBuffers")]
public void GenBuffers(int len, Int32* rv);
    public int GenBuffer();
    [GetProcAddressAttribute("glBindBuffer")]
public void BindBuffer(int target, int buffer);
    [GetProcAddressAttribute("glBufferData")]
public void BufferData(int target, IntPtr size, IntPtr data, int usage);
    [GetProcAddressAttribute("glGetAttribLocation")]
public int GetAttribLocation(int program, IntPtr name);
    [NullableContextAttribute("1")]
public int GetAttribLocationString(int program, string name);
    [GetProcAddressAttribute("glVertexAttribPointer")]
public void VertexAttribPointer(int index, int size, int type, int normalized, int stride, IntPtr pointer);
    [GetProcAddressAttribute("glEnableVertexAttribArray")]
public void EnableVertexAttribArray(int index);
    [GetProcAddressAttribute("glUseProgram")]
public void UseProgram(int program);
    [GetProcAddressAttribute("glDrawArrays")]
public void DrawArrays(int mode, int first, IntPtr count);
    [GetProcAddressAttribute("glDrawElements")]
public void DrawElements(int mode, int count, int type, IntPtr indices);
    [GetProcAddressAttribute("glGetUniformLocation")]
public int GetUniformLocation(int program, IntPtr name);
    [NullableContextAttribute("1")]
public int GetUniformLocationString(int program, string name);
    [GetProcAddressAttribute("glUniform1f")]
public void Uniform1f(int location, float falue);
    [GetProcAddressAttribute("glUniformMatrix4fv")]
public void UniformMatrix4fv(int location, int count, bool transpose, Void* value);
    [GetProcAddressAttribute("glEnable")]
public void Enable(int what);
    [GetProcAddressAttribute("glDisable")]
public void Disable(int what);
    [GetProcAddressAttribute("glDeleteBuffers")]
public void DeleteBuffers(int count, Int32* buffers);
    public void DeleteBuffer(int buffer);
    [GetProcAddressAttribute("glDeleteProgram")]
public void DeleteProgram(int program);
    [GetProcAddressAttribute("glDeleteShader")]
public void DeleteShader(int shader);
    [GetProcAddressAttribute("glGetRenderbufferParameteriv")]
public void GetRenderbufferParameteriv(int target, int name, Int32& value);
    [GetProcAddressAttribute("True")]
[GlMinVersionEntryPoint("glDeleteVertexArrays", "3", "0")]
[GlExtensionEntryPoint("glDeleteVertexArraysOES", "GL_OES_vertex_array_object")]
public void DeleteVertexArrays(int count, Int32* arrays);
    public void DeleteVertexArray(int array);
    [GetProcAddressAttribute("True")]
[GlMinVersionEntryPoint("glBindVertexArray", "3", "0")]
[GlExtensionEntryPoint("glBindVertexArrayOES", "GL_OES_vertex_array_object")]
public void BindVertexArray(int array);
    [GetProcAddressAttribute("True")]
[GlMinVersionEntryPoint("glGenVertexArrays", "3", "0")]
[GlExtensionEntryPoint("glGenVertexArraysOES", "GL_OES_vertex_array_object")]
public void GenVertexArrays(int n, Int32* rv);
    public int GenVertexArray();
    [NullableContextAttribute("1")]
public static GlInterface FromNativeUtf8GetProcAddress(GlVersion version, Func`2<IntPtr, IntPtr> getProcAddress);
    internal bool get_IsClearDepthDoubleAvailable();
    internal bool get_IsClearDepthFloatAvailable();
    public bool get_IsBlitFramebufferAvailable();
    public bool get_IsDeleteVertexArraysAvailable();
    public bool get_IsBindVertexArrayAvailable();
    public bool get_IsGenVertexArraysAvailable();
    [NullableContextAttribute("1")]
private void Initialize(Func`2<string, IntPtr> getProcAddress, GlContextInfo context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Avalonia.OpenGL.GlMinVersionEntryPoint : Attribute {
    public GlMinVersionEntryPoint(string entry, int minVersionMajor, int minVersionMinor);
    public GlMinVersionEntryPoint(string entry, int minVersionMajor, int minVersionMinor, GlProfileType profile);
    public static IntPtr GetProcAddress(Func`2<string, IntPtr> getProcAddress, GlContextInfo context, string entry, int minVersionMajor, int minVersionMinor, Nullable`1<GlProfileType> profile);
}
public enum Avalonia.OpenGL.GlProfileType : Enum {
    public int value__;
    public static GlProfileType OpenGL;
    public static GlProfileType OpenGLES;
}
public class Avalonia.OpenGL.GlVersion : ValueType {
    [CompilerGeneratedAttribute]
private GlProfileType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompatibilityProfile>k__BackingField;
    public GlProfileType Type { get; }
    public int Major { get; }
    public int Minor { get; }
    public bool IsCompatibilityProfile { get; }
    public GlVersion(GlProfileType type, int major, int minor);
    public GlVersion(GlProfileType type, int major, int minor, bool isCompatibilityProfile);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GlProfileType get_Type();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Major();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Minor();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsCompatibilityProfile();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GlVersion left, GlVersion right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GlVersion left, GlVersion right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GlVersion other);
}
public interface Avalonia.OpenGL.ICompositionImportableOpenGlSharedTexture {
    public int TextureId { get; }
    public int InternalFormat { get; }
    public PixelSize Size { get; }
    public abstract virtual int get_TextureId();
    public abstract virtual int get_InternalFormat();
    public abstract virtual PixelSize get_Size();
}
[NullableContextAttribute("1")]
public interface Avalonia.OpenGL.IGlContext {
    public GlVersion Version { get; }
    public GlInterface GlInterface { get; }
    public int SampleCount { get; }
    public int StencilSize { get; }
    public bool CanCreateSharedContext { get; }
    public abstract virtual GlVersion get_Version();
    public abstract virtual GlInterface get_GlInterface();
    public abstract virtual int get_SampleCount();
    public abstract virtual int get_StencilSize();
    public abstract virtual IDisposable MakeCurrent();
    public abstract virtual bool IsSharedWith(IGlContext context);
    public abstract virtual bool get_CanCreateSharedContext();
    [NullableContextAttribute("2")]
public abstract virtual IGlContext CreateSharedContext(IEnumerable`1<GlVersion> preferredVersions);
}
[NullableContextAttribute("1")]
public interface Avalonia.OpenGL.IGlContextExternalObjectsFeature {
    public IReadOnlyList`1<string> SupportedImportableExternalImageTypes { get; }
    public IReadOnlyList`1<string> SupportedExportableExternalImageTypes { get; }
    public IReadOnlyList`1<string> SupportedImportableExternalSemaphoreTypes { get; }
    public IReadOnlyList`1<string> SupportedExportableExternalSemaphoreTypes { get; }
    [NullableAttribute("2")]
public Byte[] DeviceLuid { get; }
    [NullableAttribute("2")]
public Byte[] DeviceUuid { get; }
    public abstract virtual IReadOnlyList`1<string> get_SupportedImportableExternalImageTypes();
    public abstract virtual IReadOnlyList`1<string> get_SupportedExportableExternalImageTypes();
    public abstract virtual IReadOnlyList`1<string> get_SupportedImportableExternalSemaphoreTypes();
    public abstract virtual IReadOnlyList`1<string> get_SupportedExportableExternalSemaphoreTypes();
    public abstract virtual IReadOnlyList`1<PlatformGraphicsExternalImageFormat> GetSupportedFormatsForExternalMemoryType(string type);
    public abstract virtual IGlExportableExternalImageTexture CreateImage(string type, PixelSize size, PlatformGraphicsExternalImageFormat format);
    public abstract virtual IGlExportableExternalImageTexture CreateSemaphore(string type);
    public abstract virtual IGlExternalImageTexture ImportImage(IPlatformHandle handle, PlatformGraphicsExternalImageProperties properties);
    public abstract virtual IGlExternalSemaphore ImportSemaphore(IPlatformHandle handle);
    public abstract virtual CompositionGpuImportedImageSynchronizationCapabilities GetSynchronizationCapabilities(string imageHandleType);
    [NullableContextAttribute("2")]
public abstract virtual Byte[] get_DeviceLuid();
    [NullableContextAttribute("2")]
public abstract virtual Byte[] get_DeviceUuid();
}
public interface Avalonia.OpenGL.IGlExportableExternalImageTexture {
    [NullableContextAttribute("1")]
public abstract virtual IPlatformHandle GetHandle();
}
public interface Avalonia.OpenGL.IGlExportableExternalSemaphore {
    [NullableContextAttribute("1")]
public abstract virtual IPlatformHandle GetHandle();
}
public interface Avalonia.OpenGL.IGlExternalImageTexture {
    public int TextureId { get; }
    public int InternalFormat { get; }
    public PlatformGraphicsExternalImageProperties Properties { get; }
    public abstract virtual void AcquireKeyedMutex(UInt32 key);
    public abstract virtual void ReleaseKeyedMutex(UInt32 key);
    public abstract virtual int get_TextureId();
    public abstract virtual int get_InternalFormat();
    public abstract virtual PlatformGraphicsExternalImageProperties get_Properties();
}
[NullableContextAttribute("1")]
public interface Avalonia.OpenGL.IGlExternalSemaphore {
    public abstract virtual void WaitSemaphore(IGlExternalImageTexture texture);
    public abstract virtual void SignalSemaphore(IGlExternalImageTexture texture);
}
[NullableContextAttribute("1")]
public interface Avalonia.OpenGL.IGlPlatformSurfaceRenderTargetFactory {
    public abstract virtual bool CanRenderToSurface(IGlContext context, object surface);
    public abstract virtual IGlPlatformSurfaceRenderTarget CreateRenderTarget(IGlContext context, object surface);
}
[NullableContextAttribute("1")]
public interface Avalonia.OpenGL.IOpenGlTextureSharingRenderInterfaceContextFeature {
    public bool CanCreateSharedContext { get; }
    public abstract virtual bool get_CanCreateSharedContext();
    [NullableContextAttribute("2")]
public abstract virtual IGlContext CreateSharedContext(IEnumerable`1<GlVersion> preferredVersions);
    public abstract virtual ICompositionImportableOpenGlSharedTexture CreateSharedTextureForComposition(IGlContext context, PixelSize size);
}
[NullableContextAttribute("1")]
public interface Avalonia.OpenGL.IPlatformGraphicsOpenGlContextFactory {
    public abstract virtual IGlContext CreateContext(IEnumerable`1<GlVersion> versions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.OpenGL.OpenGlException : Exception {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ErrorCode>k__BackingField;
    public Nullable`1<int> ErrorCode { get; }
    [NullableContextAttribute("2")]
public OpenGlException(string message);
    [NullableContextAttribute("2")]
private OpenGlException(string message, int errorCode);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ErrorCode();
    public static OpenGlException GetFormattedException(string funcName, EglInterface egl);
    public static OpenGlException GetFormattedException(string funcName, GlInterface gl);
    public static OpenGlException GetFormattedException(string funcName, int errorCode);
    public static OpenGlException GetFormattedEglException(string funcName, int errorCode);
    private static OpenGlException GetFormattedException(string funcName, T errorCode, int intErrorCode);
}
[NullableContextAttribute("1")]
public interface Avalonia.OpenGL.Surfaces.IGlPlatformSurface {
    public abstract virtual IGlPlatformSurfaceRenderTarget CreateGlRenderTarget(IGlContext context);
}
[NullableContextAttribute("1")]
public interface Avalonia.OpenGL.Surfaces.IGlPlatformSurfaceRenderingSession {
    public IGlContext Context { get; }
    public PixelSize Size { get; }
    public double Scaling { get; }
    public bool IsYFlipped { get; }
    public abstract virtual IGlContext get_Context();
    public abstract virtual PixelSize get_Size();
    public abstract virtual double get_Scaling();
    public abstract virtual bool get_IsYFlipped();
}
public interface Avalonia.OpenGL.Surfaces.IGlPlatformSurfaceRenderTarget {
    [NullableContextAttribute("1")]
public abstract virtual IGlPlatformSurfaceRenderingSession BeginDraw();
}
public interface Avalonia.OpenGL.Surfaces.IGlPlatformSurfaceRenderTargetWithCorruptionInfo {
    public bool IsCorrupted { get; }
    public abstract virtual bool get_IsCorrupted();
}
