[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Build.Tasks.ComInteropHelper : object {
    public static void PatchAssembly(AssemblyDefinition asm, CecilTypeSystem typeSystem);
    private static void PatchMethod(MethodDefinition method);
    private static void PatchType(TypeDefinition type, List`1<TypeDefinition> classToRemoveList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Build.Tasks.CompileAvaloniaXamlTask : object {
    public static string AvaloniaCompileOutputMetadataName;
    [CompilerGeneratedAttribute]
private string <ProjectDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <AssemblyFile>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITaskItem <RefAssemblyFile>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ITaskItem[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerifyIl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCompileBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipXamlCompilation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyOriginatorKeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SignAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReportImportance>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebuggerLaunch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerboseExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AnalyzerConfigFiles>k__BackingField;
    [RequiredAttribute]
public string ProjectDirectory { get; public set; }
    [RequiredAttribute]
public ITaskItem AssemblyFile { get; public set; }
    [NullableAttribute("2")]
public ITaskItem RefAssemblyFile { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] References { get; public set; }
    public bool VerifyIl { get; public set; }
    public bool DefaultCompileBindings { get; public set; }
    public bool SkipXamlCompilation { get; public set; }
    public string AssemblyOriginatorKeyFile { get; public set; }
    public bool SignAssembly { get; public set; }
    public bool DelaySign { get; public set; }
    public string ReportImportance { get; public set; }
    public IBuildEngine BuildEngine { get; public set; }
    public ITaskHost HostObject { get; public set; }
    public bool DebuggerLaunch { get; public set; }
    public bool VerboseExceptions { get; public set; }
    public ITaskItem[] AnalyzerConfigFiles { get; public set; }
    public sealed virtual bool Execute();
    private static void CopyAndTouch(string source, string destination, bool shouldExist);
    [CompilerGeneratedAttribute]
public string get_ProjectDirectory();
    [CompilerGeneratedAttribute]
public void set_ProjectDirectory(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_AssemblyFile();
    [CompilerGeneratedAttribute]
public void set_AssemblyFile(ITaskItem value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ITaskItem get_RefAssemblyFile();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_RefAssemblyFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
public void set_References(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_VerifyIl();
    [CompilerGeneratedAttribute]
public void set_VerifyIl(bool value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCompileBindings();
    [CompilerGeneratedAttribute]
public void set_DefaultCompileBindings(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipXamlCompilation();
    [CompilerGeneratedAttribute]
public void set_SkipXamlCompilation(bool value);
    [CompilerGeneratedAttribute]
public string get_AssemblyOriginatorKeyFile();
    [CompilerGeneratedAttribute]
public void set_AssemblyOriginatorKeyFile(string value);
    [CompilerGeneratedAttribute]
public bool get_SignAssembly();
    [CompilerGeneratedAttribute]
public void set_SignAssembly(bool value);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
    [CompilerGeneratedAttribute]
public void set_DelaySign(bool value);
    [CompilerGeneratedAttribute]
public string get_ReportImportance();
    [CompilerGeneratedAttribute]
public void set_ReportImportance(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    [CompilerGeneratedAttribute]
public bool get_DebuggerLaunch();
    [CompilerGeneratedAttribute]
public void set_DebuggerLaunch(bool value);
    [CompilerGeneratedAttribute]
public bool get_VerboseExceptions();
    [CompilerGeneratedAttribute]
public void set_VerboseExceptions(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AnalyzerConfigFiles();
    [CompilerGeneratedAttribute]
public void set_AnalyzerConfigFiles(ITaskItem[] value);
}
public class Avalonia.Build.Tasks.DeterministicIdGenerator : object {
    private int _nextId;
    [NullableContextAttribute("1")]
public sealed virtual string GenerateIdentifierPart();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Build.Tasks.Extensions : object {
    [ExtensionAttribute]
public static void LogError(IBuildEngine engine, string code, string file, Exception ex, Nullable`1<int> lineNumber, Nullable`1<int> linePosition);
    [ExtensionAttribute]
public static void LogDiagnostic(IBuildEngine engine, XamlDiagnostic diagnostic);
    [ExtensionAttribute]
public static void LogError(IBuildEngine engine, string code, string file, string message, Nullable`1<int> lineNumber, Nullable`1<int> linePosition);
    [ExtensionAttribute]
public static void LogWarning(IBuildEngine engine, string code, string file, string message, int lineNumber, int linePosition);
    [ExtensionAttribute]
public static void LogMessage(IBuildEngine engine, string message, MessageImportance imp);
    [ExtensionAttribute]
public static string FormatException(Exception exception, bool verbose);
    [CompilerGeneratedAttribute]
internal static void <FormatException>g__Process|5_0(Exception exception, <>c__DisplayClass5_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Build.Tasks.GenerateAvaloniaResourcesTask : object {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Resources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReportImportance>k__BackingField;
    private MessageImportance _reportImportance;
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Resources { get; public set; }
    [RequiredAttribute]
public string Root { get; public set; }
    [RequiredAttribute]
public string Output { get; public set; }
    public string ReportImportance { get; public set; }
    public IBuildEngine BuildEngine { get; public set; }
    public ITaskHost HostObject { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Resources();
    [CompilerGeneratedAttribute]
public void set_Resources(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(string value);
    [CompilerGeneratedAttribute]
public string get_Output();
    [CompilerGeneratedAttribute]
public void set_Output(string value);
    [CompilerGeneratedAttribute]
public string get_ReportImportance();
    [CompilerGeneratedAttribute]
public void set_ReportImportance(string value);
    private List`1<Source> BuildResourceSources();
    private void Pack(Stream output, List`1<Source> sources);
    private bool PreProcessXamlFiles(List`1<Source> sources);
    public sealed virtual bool Execute();
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Source <BuildResourceSources>b__18_0(ITaskItem r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Build.Tasks.XamlCompilerDiagnosticsFilter : object {
    private static Regex s_editorConfigRegex;
    private Lazy`1<Dictionary`2<string, string>> _lazyEditorConfig;
    public XamlCompilerDiagnosticsFilter(ITaskItem[] analyzerConfigFiles);
    private static XamlCompilerDiagnosticsFilter();
    internal XamlDiagnosticSeverity Handle(XamlDiagnostic diagnostic);
    internal XamlDiagnosticSeverity Handle(XamlDiagnosticSeverity currentSeverity, string diagnosticCode);
    private Dictionary`2<string, string> ParseEditorConfigFiles(ITaskItem[] analyzerConfigFiles);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Avalonia.Build.Tasks.XamlCompilerTaskExecutor : object {
    private static string CompiledAvaloniaXamlNamespace;
    private static bool CheckXamlName(IResource r);
    internal static CompileResult Compile(IBuildEngine engine, string input, string output, string refInput, string refOutput, String[] references, string projectDirectory, bool verifyIl, bool defaultCompileBindings, MessageImportance logImportance, XamlCompilerDiagnosticsFilter diagnosticsFilter, string strongNameKey, bool skipXamlCompilation, bool debuggerLaunch, bool verboseExceptions);
    private static Nullable`1<bool> CompileCore(IBuildEngine engine, CecilTypeSystem typeSystem, string projectDirectory, bool verifyIl, bool defaultCompileBindings, MessageImportance logImportance, XamlCompilerDiagnosticsFilter diagnosticsFilter, bool debuggerLaunch, bool verboseExceptions);
    private static bool ReportDiagnostics(IBuildEngine engine, IReadOnlyCollection`1<XamlDiagnostic> diagnostics);
    private static Nullable`1<bool> CompileCoreForRefAssembly(IBuildEngine engine, CecilTypeSystem sourceTypeSystem, CecilTypeSystem refTypeSystem);
    private static void CopyDebugDocument(MethodDefinition method, MethodDefinition copyFrom);
    private static bool MatchThisCall(Collection`1<Instruction> instructions, int idx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Avalonia.Build.Tasks.XamlFileInfo : object {
    [CompilerGeneratedAttribute]
private string <XClass>k__BackingField;
    public string XClass { get; public set; }
    [CompilerGeneratedAttribute]
public string get_XClass();
    [CompilerGeneratedAttribute]
public void set_XClass(string value);
    public static XamlFileInfo Parse(string data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Controls.GridLength : ValueType {
    private GridUnitType _type;
    private double _value;
    public static GridLength Auto { get; }
    public static GridLength Star { get; }
    public GridUnitType GridUnitType { get; }
    public bool IsAbsolute { get; }
    public bool IsAuto { get; }
    public bool IsStar { get; }
    public double Value { get; }
    public GridLength(double value);
    public GridLength(double value, GridUnitType type);
    public static GridLength get_Auto();
    public static GridLength get_Star();
    public GridUnitType get_GridUnitType();
    public bool get_IsAbsolute();
    public bool get_IsAuto();
    public bool get_IsStar();
    public double get_Value();
    public static bool op_Equality(GridLength a, GridLength b);
    public static bool op_Inequality(GridLength gl1, GridLength gl2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public sealed virtual bool Equals(GridLength gridLength);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static GridLength Parse(string s);
    [IteratorStateMachineAttribute("Avalonia.Controls.GridLength/<ParseLengths>d__25")]
public static IEnumerable`1<GridLength> ParseLengths(string s);
}
internal enum Avalonia.Controls.GridUnitType : Enum {
    public int value__;
    public static GridUnitType Auto;
    public static GridUnitType Pixel;
    public static GridUnitType Star;
}
[IsReadOnlyAttribute]
internal class Avalonia.CornerRadius : ValueType {
    [CompilerGeneratedAttribute]
private double <TopLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TopRight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BottomRight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BottomLeft>k__BackingField;
    public double TopLeft { get; }
    public double TopRight { get; }
    public double BottomRight { get; }
    public double BottomLeft { get; }
    public bool IsUniform { get; }
    public CornerRadius(double uniformRadius);
    public CornerRadius(double top, double bottom);
    public CornerRadius(double topLeft, double topRight, double bottomRight, double bottomLeft);
    [CompilerGeneratedAttribute]
public double get_TopLeft();
    [CompilerGeneratedAttribute]
public double get_TopRight();
    [CompilerGeneratedAttribute]
public double get_BottomRight();
    [CompilerGeneratedAttribute]
public double get_BottomLeft();
    public bool get_IsUniform();
    public sealed virtual bool Equals(CornerRadius other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static CornerRadius Parse(string s);
    public static bool op_Equality(CornerRadius left, CornerRadius right);
    public static bool op_Inequality(CornerRadius left, CornerRadius right);
}
public enum Avalonia.Data.BindingPriority : Enum {
    public int value__;
    public static BindingPriority Animation;
    public static BindingPriority LocalValue;
    public static BindingPriority StyleTrigger;
    public static BindingPriority Template;
    public static BindingPriority Style;
    public static BindingPriority Inherited;
    public static BindingPriority Unset;
    [ObsoleteAttribute("Use Template priority")]
[EditorBrowsableAttribute("1")]
public static BindingPriority TemplatedParent;
}
internal class Avalonia.Data.Core.ExpressionParseException : Exception {
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Column { get; }
    [NullableContextAttribute("1")]
public ExpressionParseException(int column, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_Column();
}
[ExtensionAttribute]
internal static class Avalonia.Markup.Parsers.ArgumentListParser : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IList`1<string> ParseArguments(CharacterReader& r, char open, char close, char delimiter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Markup.Parsers.BindingExpressionGrammar : object {
    private static List`1<INode> s_pool;
    private static BindingExpressionGrammar();
    public static ValueTuple`2<List`1<INode>, SourceMode> Parse(CharacterReader& r);
    public static ValueTuple`2<List`1<INode>, SourceMode> ParseToPooledList(CharacterReader& r);
    private static SourceMode Parse(CharacterReader& r, List`1<INode> nodes);
    private static State ParseStart(CharacterReader& r, IList`1<INode> nodes);
    private static State ParseAfterMember(CharacterReader& r, IList`1<INode> nodes);
    private static State ParseBeforeMember(CharacterReader& r, IList`1<INode> nodes);
    private static State ParseAttachedProperty(CharacterReader& r, List`1<INode> nodes);
    private static State ParseIndexer(CharacterReader& r, List`1<INode> nodes);
    private static State ParseTypeCast(CharacterReader& r, List`1<INode> nodes);
    private static State ParseElementName(CharacterReader& r, List`1<INode> nodes);
    private static State ParseRelativeSource(CharacterReader& r, List`1<INode> nodes);
    private static TypeName ParseTypeName(CharacterReader& r);
    private static bool ParseNot(CharacterReader& r);
    private static bool ParseMemberAccessor(CharacterReader& r);
    private static bool ParseOpenBrace(CharacterReader& r);
    private static bool ParseCloseBrace(CharacterReader& r);
    private static bool PeekOpenBracket(CharacterReader& r);
    private static bool PeekOpenBrace(CharacterReader& r);
    private static bool ParseStreamOperator(CharacterReader& r);
    private static bool ParseDollarSign(CharacterReader& r);
    private static bool ParseSharp(CharacterReader& r);
    private static bool ParseDot(CharacterReader& r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Parsers.PropertyPathGrammar : object {
    public static IEnumerable`1<ISyntax> Parse(string s);
    private static IEnumerable`1<ISyntax> Parse(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseNext(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseStart(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseTypeQualifiedProperty(CharacterReader& r);
    private static ValueTuple`2<string, string> ParseXamlIdentifier(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseProperty(CharacterReader& r);
    private static bool TryParseCasts(CharacterReader& r, ValueTuple`2& rv);
    private static ValueTuple`2<State, ISyntax> ParseAfterProperty(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseEnsureType(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseCastType(CharacterReader& r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Markup.Parsers.SelectorGrammar : object {
    public static IEnumerable`1<ISyntax> Parse(string s);
    private static IEnumerable`1<ISyntax> Parse(CharacterReader& r, Nullable`1<char> end);
    private static ValueTuple`2<State, ISyntax> ParseStart(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseMiddle(CharacterReader& r, Nullable`1<char> end);
    private static State ParseCanHaveType(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseColon(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseTraversal(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseClass(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseTemplate(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseName(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseTypeName(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseProperty(CharacterReader& r);
    private static ValueTuple`2<State, ISyntax> ParseAttachedProperty(CharacterReader& r);
    private static TSyntax ParseType(CharacterReader& r, TSyntax syntax);
    [NullableContextAttribute("0")]
private static ValueTuple`2<int, int> ParseNthChildArguments(CharacterReader& r);
    private static void Expect(CharacterReader& r, char c);
}
internal enum Avalonia.Markup.Parsers.SourceMode : Enum {
    public int value__;
    public static SourceMode Data;
    public static SourceMode Control;
}
internal class Avalonia.Markup.Xaml.Parsers.PropertyParser : object {
    public static ValueTuple`3<string, string, string> Parse(CharacterReader r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Avalonia.Markup.Xaml.PortableXaml.AvaloniaResourceXamlInfo : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ClassToResourcePathIndex>k__BackingField;
    [DataMemberAttribute]
public Dictionary`2<string, string> ClassToResourcePathIndex { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ClassToResourcePathIndex();
    [CompilerGeneratedAttribute]
public void set_ClassToResourcePathIndex(Dictionary`2<string, string> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AstNodes.AvaloniaXamlIlArrayConstantAstNode : XamlAstNode {
    private IXamlType _elementType;
    private IReadOnlyList`1<IXamlAstValueNode> _values;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public AvaloniaXamlIlArrayConstantAstNode(IXamlLineInfo lineInfo, IXamlType arrayType, IXamlType elementType, IReadOnlyList`1<IXamlAstValueNode> values);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AstNodes.AvaloniaXamlIlAvaloniaListConstantAstNode : XamlAstNode {
    private IXamlType _elementType;
    private IReadOnlyList`1<IXamlAstValueNode> _values;
    private IXamlConstructor _constructor;
    private IXamlMethod _listAddMethod;
    private IXamlMethod _listSetCapacityMethod;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public AvaloniaXamlIlAvaloniaListConstantAstNode(IXamlLineInfo lineInfo, AvaloniaXamlIlWellKnownTypes types, IXamlType listType, IXamlType elementType, IReadOnlyList`1<IXamlAstValueNode> values);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AstNodes.AvaloniaXamlIlFontFamilyAstNode : XamlAstNode {
    private AvaloniaXamlIlWellKnownTypes _types;
    private string _text;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public AvaloniaXamlIlFontFamilyAstNode(AvaloniaXamlIlWellKnownTypes types, string text, IXamlLineInfo lineInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AstNodes.AvaloniaXamlIlGridLengthAstNode : XamlAstNode {
    private AvaloniaXamlIlWellKnownTypes _types;
    private GridLength _gridLength;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public AvaloniaXamlIlGridLengthAstNode(IXamlLineInfo lineInfo, AvaloniaXamlIlWellKnownTypes types, GridLength gridLength);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AstNodes.AvaloniaXamlIlVectorLikeConstantAstNode : XamlAstNode {
    private IXamlConstructor _constructor;
    private Double[] _values;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public AvaloniaXamlIlVectorLikeConstantAstNode(IXamlLineInfo lineInfo, AvaloniaXamlIlWellKnownTypes types, IXamlType type, IXamlConstructor constructor, Double[] values);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AvaloniaXamlDiagnosticCodes : object {
    public static string Unknown;
    public static string ParseError;
    public static string InvalidXAML;
    public static string TransformError;
    public static string DuplicateXClass;
    public static string TypeSystemError;
    public static string AvaloniaIntrinsicsError;
    public static string BindingsError;
    public static string DataContextResolvingError;
    public static string StyleTransformError;
    public static string SelectorsTransformError;
    public static string PropertyPathError;
    public static string DuplicateSetterError;
    public static string StyleInMergedDictionaries;
    public static string RequiredTemplatePartMissing;
    public static string OptionalTemplatePartMissing;
    public static string TemplatePartWrongType;
    public static string EmitError;
    public static string XamlLoaderUnreachable;
    public static string NameGeneratorError;
    public static string Obsolete;
    internal static string XamlXDiagnosticCodeToAvalonia(object xamlException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AvaloniaXamlIlCompiler : XamlILCompiler {
    private IXamlType _contextType;
    private AvaloniaXamlIlDesignPropertiesTransformer _designTransformer;
    private AvaloniaBindingExtensionTransformer _bindingTransformer;
    public static string PopulateName;
    public static string BuildName;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstGroupTransformer> <GroupTransformers>k__BackingField;
    public bool IsDesignMode { get; public set; }
    public bool DefaultCompileBindings { get; public set; }
    public List`1<IXamlAstGroupTransformer> GroupTransformers { get; }
    private AvaloniaXamlIlCompiler(TransformerConfiguration configuration, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult> emitMappings);
    public AvaloniaXamlIlCompiler(TransformerConfiguration configuration, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult> emitMappings, IXamlTypeBuilder`1<IXamlILEmitter> contextTypeBuilder);
    public AvaloniaXamlIlCompiler(TransformerConfiguration configuration, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult> emitMappings, IXamlType contextType);
    public bool get_IsDesignMode();
    public void set_IsDesignMode(bool value);
    public bool get_DefaultCompileBindings();
    public void set_DefaultCompileBindings(bool value);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstGroupTransformer> get_GroupTransformers();
    public void TransformGroup(IReadOnlyCollection`1<IXamlDocumentResource> documents);
    public XamlDocument Parse(string xaml, IXamlType overrideRootType);
    public void Compile(XamlDocument document, XamlDocumentTypeBuilderProvider typeBuilderProvider, string baseUri, IFileSource fileSource);
    public void ParseAndCompile(string xaml, string baseUri, IFileSource fileSource, IXamlTypeBuilder`1<IXamlILEmitter> tb, IXamlType overrideRootType);
    public void OverrideRootType(XamlDocument doc, IXamlAstTypeReference newType);
    [CompilerGeneratedAttribute]
private void <.ctor>g__InsertAfter|3_0(IXamlAstTransformer[] t);
    [CompilerGeneratedAttribute]
private void <.ctor>g__InsertBefore|3_1(IXamlAstTransformer[] t);
    [CompilerGeneratedAttribute]
private void <.ctor>g__InsertBeforeMany|3_2(Type[] types, IXamlAstTransformer[] t);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private int <.ctor>b__3_5(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AvaloniaXamlIlCompilerConfiguration : TransformerConfiguration {
    [CompilerGeneratedAttribute]
private XamlIlClrPropertyInfoEmitter <ClrPropertyEmitter>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlIlPropertyInfoAccessorFactoryEmitter <AccessorFactoryEmitter>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlIlTrampolineBuilder <TrampolineBuilder>k__BackingField;
    public XamlIlClrPropertyInfoEmitter ClrPropertyEmitter { get; }
    public XamlIlPropertyInfoAccessorFactoryEmitter AccessorFactoryEmitter { get; }
    public XamlIlTrampolineBuilder TrampolineBuilder { get; }
    public AvaloniaXamlIlCompilerConfiguration(IXamlTypeSystem typeSystem, IXamlAssembly defaultAssembly, XamlLanguageTypeMappings typeMappings, XamlXmlnsMappings xmlnsMappings, XamlValueConverter customValueConverter, XamlIlClrPropertyInfoEmitter clrPropertyEmitter, XamlIlPropertyInfoAccessorFactoryEmitter accessorFactoryEmitter, XamlIlTrampolineBuilder trampolineBuilder, IXamlIdentifierGenerator identifierGenerator, XamlDiagnosticsHandler diagnosticsHandler);
    [CompilerGeneratedAttribute]
public XamlIlClrPropertyInfoEmitter get_ClrPropertyEmitter();
    [CompilerGeneratedAttribute]
public XamlIlPropertyInfoAccessorFactoryEmitter get_AccessorFactoryEmitter();
    [CompilerGeneratedAttribute]
public XamlIlTrampolineBuilder get_TrampolineBuilder();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AvaloniaXamlIlLanguage : object {
    public static string ContextNameScopeFieldName;
    public static ValueTuple`2<XamlLanguageTypeMappings, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult>> Configure(IXamlTypeSystem typeSystem);
    private static void EmitNameScopeField(XamlLanguageTypeMappings mappings, IXamlTypeSystem typeSystem, IXamlILContextDefinition`1<IXamlILEmitter> definition);
    private static void EmitEagerParentStackProvider(XamlLanguageTypeMappings mappings, IXamlTypeSystem typeSystem, IXamlILContextDefinition`1<IXamlILEmitter> definition, IXamlType runtimeHelpers);
    public static bool CustomValueConverter(AstTransformationContext context, IXamlAstValueNode node, IReadOnlyList`1<IXamlCustomAttribute> customAttributes, IXamlType type, IXamlAstValueNode& result);
    [CompilerGeneratedAttribute]
internal static IXamlMethodBuilder`1<IXamlILEmitter> <EmitEagerParentStackProvider>g__ImplementInterfacePropertyGetter|3_0(string propertyName, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.AvaloniaXamlIlLanguageParseIntrinsics : object {
    public static bool TryConvert(AstTransformationContext context, IXamlAstValueNode node, string text, IXamlType type, AvaloniaXamlIlWellKnownTypes types, IXamlAstValueNode& result);
    private static IXamlType GetElementType(IXamlType type, XamlTypeWellKnownTypes types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.GroupTransformers.AstGroupTransformationContext : AstTransformationContext {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlDocumentResource <CurrentDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IXamlDocumentResource> <Documents>k__BackingField;
    public string Document { get; }
    [NullableAttribute("2")]
public IXamlDocumentResource CurrentDocument { get; public set; }
    public IReadOnlyCollection`1<IXamlDocumentResource> Documents { get; }
    public AstGroupTransformationContext(IReadOnlyCollection`1<IXamlDocumentResource> documents, TransformerConfiguration configuration);
    public virtual string get_Document();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IXamlDocumentResource get_CurrentDocument();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_CurrentDocument(IXamlDocumentResource value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IXamlDocumentResource> get_Documents();
    public IXamlAstNode Visit(IXamlAstNode root, IXamlAstGroupTransformer transformer);
    public void VisitChildren(IXamlAstNode root, IXamlAstGroupTransformer transformer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.GroupTransformers.AvaloniaXamlIncludeTransformer : object {
    public sealed virtual IXamlAstNode Transform(AstGroupTransformationContext context, IXamlAstNode node);
    private static IXamlAstNode FromType(AstGroupTransformationContext context, IXamlType type, IXamlAstNode li, IXamlType expectedLoadedType, IXamlAstNode fallbackNode, string assetPathUri, string assembly, IEnumerable`1<IXamlAstManipulationNode> manipulationNodes);
    private static IXamlAstNode FromMethod(AstGroupTransformationContext context, IXamlMethod method, IXamlAstNode li, IXamlType expectedLoadedType, IXamlAstNode fallbackNode, string assetPathUri, string assembly, IEnumerable`1<IXamlAstManipulationNode> manipulationNodes);
    internal static ValueTuple`2<string, IXamlAstNode> ResolveSourceFromXamlInclude(AstGroupTransformationContext context, string nodeTypeName, XamlPropertyAssignmentNode sourceProperty, bool strictSourceValueType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <ResolveSourceFromXamlInclude>g__OnInvalidSource|3_0(IXamlAstNode node, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
internal interface Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.GroupTransformers.IXamlAstGroupTransformer {
    public abstract virtual IXamlAstNode Transform(AstGroupTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.GroupTransformers.XamlMergeResourceGroupTransformer : object {
    public sealed virtual IXamlAstNode Transform(AstGroupTransformationContext context, IXamlAstNode node);
    private static void FixEnsureCapacityNodes(AstGroupTransformationContext context, XamlManipulationGroupNode manipulation);
    public static bool ThemeVariantNodeEquals(AstGroupTransformationContext context, IXamlAstValueNode left, IXamlAstValueNode right);
    [CompilerGeneratedAttribute]
internal static void <Transform>g__ProcessXamlPropertyAssignmentNode|0_0(XamlManipulationGroupNode parent, XamlPropertyAssignmentNode assignmentNode, <>c__DisplayClass0_0& );
}
[NullableContextAttribute("2")]
internal interface Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.IXamlDocumentResource {
    public IXamlMethod BuildMethod { get; }
    public IXamlType ClassType { get; }
    public string Uri { get; }
    [NullableAttribute("1")]
public IXamlMethod PopulateMethod { get; }
    public IFileSource FileSource { get; }
    [NullableAttribute("1")]
public XamlDocument XamlDocument { get; }
    public XamlDocumentUsage Usage { get; public set; }
    public abstract virtual IXamlMethod get_BuildMethod();
    public abstract virtual IXamlType get_ClassType();
    public abstract virtual string get_Uri();
    [NullableContextAttribute("1")]
public abstract virtual IXamlMethod get_PopulateMethod();
    public abstract virtual IFileSource get_FileSource();
    [NullableContextAttribute("1")]
public abstract virtual XamlDocument get_XamlDocument();
    public abstract virtual XamlDocumentUsage get_Usage();
    public abstract virtual void set_Usage(XamlDocumentUsage value);
}
[NullableContextAttribute("1")]
internal interface Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.IXamlIlAvaloniaProperty {
    public IXamlField AvaloniaProperty { get; }
    public abstract virtual IXamlField get_AvaloniaProperty();
}
internal interface Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.IXamlIlAvaloniaPropertyNode {
    [NullableAttribute("1")]
public IXamlType AvaloniaPropertyType { get; }
    [NullableContextAttribute("1")]
public abstract virtual IXamlType get_AvaloniaPropertyType();
}
internal interface Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.IXamlIlBindingPathNode {
    [NullableAttribute("1")]
public IXamlType BindingResultType { get; }
    [NullableContextAttribute("1")]
public abstract virtual IXamlType get_BindingResultType();
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AddNameScopeRegistration : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaBindingExtensionTransformer : object {
    [CompilerGeneratedAttribute]
private bool <CompileBindingsByDefault>k__BackingField;
    public bool CompileBindingsByDefault { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CompileBindingsByDefault();
    [CompilerGeneratedAttribute]
public void set_CompileBindingsByDefault(bool value);
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaNameScopeRegistrationXamlIlNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlType <TargetType>k__BackingField;
    public IXamlAstValueNode Name { get; public set; }
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    public AvaloniaNameScopeRegistrationXamlIlNode(IXamlAstValueNode name, IXamlType targetType);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(IXamlAstValueNode value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IXamlType get_TargetType();
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaNameScopeRegistrationXamlIlNodeEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaSyntheticCompiledBindingProperty : XamlAstNode {
    [CompilerGeneratedAttribute]
private SyntheticCompiledBindingPropertyName <Name>k__BackingField;
    public SyntheticCompiledBindingPropertyName Name { get; }
    [NullableContextAttribute("1")]
public AvaloniaSyntheticCompiledBindingProperty(IXamlLineInfo lineInfo, SyntheticCompiledBindingPropertyName name);
    [CompilerGeneratedAttribute]
public SyntheticCompiledBindingPropertyName get_Name();
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlAvaloniaPropertyResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlBindingPathParser : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [NullableContextAttribute("1")]
private static INode ConvertLongFormPropertiesToBindingExpressionNode(AstTransformationContext context, XamlAstObjectNode binding);
    [NullableContextAttribute("2")]
private static bool GetRelativeSourceObjectFromAssignment(AstTransformationContext context, XamlAstXamlPropertyValueNode relativeSourceProperty, XamlAstObjectNode& relativeSourceObject);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlBindingPathTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <Transform>g__matchProperty|0_4(IXamlAstNode node, IXamlType styledElementType, string propertyName);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <Transform>g__getResourceValue_xKey|0_5(XamlPropertyAssignmentNode node);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static IXamlType <Transform>g__getResourceValue_Type|0_6(XamlPropertyAssignmentNode node, IXamlType xamlType);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlBindingPathTransformer/<<Transform>g__getResourceValues|0_7>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<XamlPropertyAssignmentNode> <Transform>g__getResourceValues|0_7(IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlClassesTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlCompileBindingsNode : XamlValueWithSideEffectNodeBase {
    [CompilerGeneratedAttribute]
private bool <CompileBindings>k__BackingField;
    public bool CompileBindings { get; }
    [NullableContextAttribute("1")]
public AvaloniaXamlIlCompileBindingsNode(IXamlAstValueNode value, bool compileBindings);
    [CompilerGeneratedAttribute]
public bool get_CompileBindings();
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlCompiledBindingsMetadataRemover : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlConstructorServiceProviderTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlControlTemplatePartsChecker : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [NullableContextAttribute("1")]
private static Dictionary`2<string, ValueTuple`2<IXamlType, bool>> ResolveTemplateParts(IXamlType targetType);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlControlTemplatePriorityTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlControlTemplateTargetTypeMetadataTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlControlThemeTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("DataType = {DataContextType}")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlDataContextTypeMetadataNode : XamlValueWithSideEffectNodeBase {
    [CompilerGeneratedAttribute]
private IXamlType <DataContextType>k__BackingField;
    public IXamlType DataContextType { get; }
    public AvaloniaXamlIlDataContextTypeMetadataNode(IXamlAstValueNode value, IXamlType targetType);
    [CompilerGeneratedAttribute]
public IXamlType get_DataContextType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlDataContextTypeTransformer : object {
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    private static AvaloniaXamlIlDataContextTypeMetadataNode InferDataContextOfPresentedItem(AstTransformationContext context, XamlAstConstructableObjectNode on, XamlAstConstructableObjectNode parentObject, string propertyName);
    private static AvaloniaXamlIlDataContextTypeMetadataNode ParseDataContext(AstTransformationContext context, XamlAstConstructableObjectNode on, XamlAstConstructableObjectNode obj);
    [IteratorStateMachineAttribute("Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlDataContextTypeTransformer/<GetAllInterfacesIncludingSelf>d__3")]
private static IEnumerable`1<IXamlType> GetAllInterfacesIncludingSelf(IXamlType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlDeferredResourceTransformer : object {
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    private static bool ShouldBeDeferred(IXamlAstValueNode node);
    [CompilerGeneratedAttribute]
internal static bool <Transform>g__TryGetSharedValue|0_0(IXamlAstValueNode valueNode, Boolean& value, <>c__DisplayClass0_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlDesignPropertiesTransformer : object {
    [CompilerGeneratedAttribute]
private bool <IsDesignMode>k__BackingField;
    private static Dictionary`2<string, string> DesignDirectives;
    private static string AvaloniaNs;
    public bool IsDesignMode { get; public set; }
    private static AvaloniaXamlIlDesignPropertiesTransformer();
    [CompilerGeneratedAttribute]
public bool get_IsDesignMode();
    [CompilerGeneratedAttribute]
public void set_IsDesignMode(bool value);
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlDuplicateSettersChecker : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlEnsureResourceDictionaryCapacityTransformer : object {
    private HashSet`1<XamlManipulationGroupNode> _processedGroups;
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    public void Apply(AstTransformationContext context, XamlManipulationGroupNode group);
    private ResourcesInfo GetResourcesInfo(IXamlAstManipulationNode node, AvaloniaXamlIlWellKnownTypes types);
    private ResourcesInfo GetResourcesInfo(XamlManipulationGroupNode node, AvaloniaXamlIlWellKnownTypes types);
    private static ResourcesInfo GetResourcesInfo(XamlPropertyAssignmentNode node, AvaloniaXamlIlWellKnownTypes types);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlMetadataRemover : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlOptionMarkupExtensionTransformer : object {
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlPropertyPathTransformer : object {
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [CompilerGeneratedAttribute]
internal static IXamlType <Transform>g__GetType|0_0(string ns, string name, <>c__DisplayClass0_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <Transform>g__HandleProperty|0_1(string name, string typeNamespace, string typeName, <>c__DisplayClass0_0& , <>c__DisplayClass0_1& );
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlReorderClassesPropertiesTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlResolveByNameMarkupExtensionReplacer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlResolveClassesPropertiesTransformer : object {
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlRootObjectScope : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlSelectorTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [NullableContextAttribute("2")]
private static IXamlType GetLastTemplateTypeFromSelector(XamlIlSelectorNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlSetterTargetTypeMetadataTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlSetterTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlStyleValidatorTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlTargetTypeMetadataNode : XamlValueWithSideEffectNodeBase {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopeTypes <ScopeType>k__BackingField;
    public IXamlAstTypeReference TargetType { get; public set; }
    public ScopeTypes ScopeType { get; }
    public AvaloniaXamlIlTargetTypeMetadataNode(IXamlAstValueNode value, IXamlAstTypeReference targetType, ScopeTypes type);
    [CompilerGeneratedAttribute]
public IXamlAstTypeReference get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(IXamlAstTypeReference value);
    [CompilerGeneratedAttribute]
public ScopeTypes get_ScopeType();
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlThemeVariantProviderTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlTransformInstanceAttachedProperties : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlTransformRoutedEvent : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlTransformSyntheticCompiledBindingMembers : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlTransitionsTypeMetadataTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[DebuggerDisplayAttribute("DataType = Unknown")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlUninferrableDataContextMetadataNode : AvaloniaXamlIlDataContextTypeMetadataNode {
    [NullableContextAttribute("1")]
public AvaloniaXamlIlUninferrableDataContextMetadataNode(IXamlAstValueNode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlWellKnownTypes : object {
    [CompilerGeneratedAttribute]
private IXamlType <RuntimeHelpers>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaObject>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <BindingPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaObjectExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaPropertyT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <StyledPropertyT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <AvaloniaObjectSetStyledPropertyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaAttachedPropertyT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <MultiBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <AvaloniaObjectBindMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <AvaloniaObjectSetValueMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IDisposable>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ICommand>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlTypeWellKnownTypes <XamlIlTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Transitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AssignBindingAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <DependsOnAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <DataTypeAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <InheritDataTypeFromItemsAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <InheritDataTypeFromAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <MarkupExtensionOptionAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <MarkupExtensionDefaultOptionAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaListAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaList>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <OnExtensionType>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <UnsetValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <StyledElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <NameScope>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <NameScopeSetNameScope>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <INameScope>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <INameScopeRegister>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <INameScopeComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IPropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ClrPropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <PropertyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <PropertyPathBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IPropertyAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <PropertyInfoAccessorFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <CompiledBindingPathBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <CompiledBindingPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <CompiledBindingExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ResolveByNameExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <DataTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IDataTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ITemplateOfControl>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Control>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ItemsControl>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ReflectionBindingExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <RelativeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <UInt>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Int>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Long>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IDictionaryT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <FontFamilyConstructorUriName>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Thickness>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <ThicknessFullConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ThemeVariant>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <PointFullConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Vector>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <VectorFullConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <SizeFullConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Matrix>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <MatrixFullConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <CornerRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <CornerRadiusFullConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <RelativeUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <RelativePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <RelativePointFullConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <GridLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <GridLengthConstructorValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <StandardCursorType>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Cursor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <CursorTypeConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <RowDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <RowDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ColumnDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ColumnDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Classes>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <ClassesBindMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlProperty <StyledElementClassesProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ImmutableSolidColorBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <ImmutableSolidColorBrushConstructorColor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <TypeUtilities>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <TextDecorationCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <TextDecorations>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <TextTrimming>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <SetterBase>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <StyleInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ResourceInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <MergeResourceInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IResourceDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ResourceDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <ResourceDictionaryDeferredAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <ResourceDictionaryNotSharedDeferredAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <ResourceDictionaryEnsureCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <ResourceDictionaryGetCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IThemeVariantProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <UriKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <UriConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ControlTheme>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <WindowTransparencyLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IReadOnlyListOfT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ControlTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <EventHandlerT>k__BackingField;
    [CompilerGeneratedAttribute]
private InteractivityWellKnownTypes <Interactivity>k__BackingField;
    public IXamlType RuntimeHelpers { get; }
    public IXamlType AvaloniaObject { get; }
    public IXamlType BindingPriority { get; }
    public IXamlType AvaloniaObjectExtensions { get; }
    public IXamlType AvaloniaProperty { get; }
    public IXamlType AvaloniaPropertyT { get; }
    public IXamlType StyledPropertyT { get; }
    public IXamlMethod AvaloniaObjectSetStyledPropertyValue { get; }
    public IXamlType AvaloniaAttachedPropertyT { get; }
    public IXamlType IBinding { get; }
    public IXamlType MultiBinding { get; }
    public IXamlMethod AvaloniaObjectBindMethod { get; }
    public IXamlMethod AvaloniaObjectSetValueMethod { get; }
    public IXamlType IDisposable { get; }
    public IXamlType ICommand { get; }
    public XamlTypeWellKnownTypes XamlIlTypes { get; }
    public IXamlType Transitions { get; }
    public IXamlType AssignBindingAttribute { get; }
    public IXamlType DependsOnAttribute { get; }
    public IXamlType DataTypeAttribute { get; }
    public IXamlType InheritDataTypeFromItemsAttribute { get; }
    public IXamlType InheritDataTypeFromAttribute { get; }
    public IXamlType MarkupExtensionOptionAttribute { get; }
    public IXamlType MarkupExtensionDefaultOptionAttribute { get; }
    public IXamlType AvaloniaListAttribute { get; }
    public IXamlType AvaloniaList { get; }
    public IXamlType OnExtensionType { get; }
    public IXamlType UnsetValueType { get; }
    public IXamlType StyledElement { get; }
    public IXamlType NameScope { get; }
    public IXamlMethod NameScopeSetNameScope { get; }
    public IXamlType INameScope { get; }
    public IXamlMethod INameScopeRegister { get; }
    public IXamlMethod INameScopeComplete { get; }
    public IXamlType IPropertyInfo { get; }
    public IXamlType ClrPropertyInfo { get; }
    public IXamlType PropertyPath { get; }
    public IXamlType PropertyPathBuilder { get; }
    public IXamlType IPropertyAccessor { get; }
    public IXamlType PropertyInfoAccessorFactory { get; }
    public IXamlType CompiledBindingPathBuilder { get; }
    public IXamlType CompiledBindingPath { get; }
    public IXamlType CompiledBindingExtension { get; }
    public IXamlType ResolveByNameExtension { get; }
    public IXamlType DataTemplate { get; }
    public IXamlType IDataTemplate { get; }
    public IXamlType ITemplateOfControl { get; }
    public IXamlType Control { get; }
    public IXamlType ItemsControl { get; }
    public IXamlType ReflectionBindingExtension { get; }
    public IXamlType RelativeSource { get; }
    public IXamlType UInt { get; }
    public IXamlType Int { get; }
    public IXamlType Long { get; }
    public IXamlType Uri { get; }
    public IXamlType IDictionaryT { get; }
    public IXamlType FontFamily { get; }
    public IXamlConstructor FontFamilyConstructorUriName { get; }
    public IXamlType Thickness { get; }
    public IXamlConstructor ThicknessFullConstructor { get; }
    public IXamlType ThemeVariant { get; }
    public IXamlType Point { get; }
    public IXamlConstructor PointFullConstructor { get; }
    public IXamlType Vector { get; }
    public IXamlConstructor VectorFullConstructor { get; }
    public IXamlType Size { get; }
    public IXamlConstructor SizeFullConstructor { get; }
    public IXamlType Matrix { get; }
    public IXamlConstructor MatrixFullConstructor { get; }
    public IXamlType CornerRadius { get; }
    public IXamlConstructor CornerRadiusFullConstructor { get; }
    public IXamlType RelativeUnit { get; }
    public IXamlType RelativePoint { get; }
    public IXamlConstructor RelativePointFullConstructor { get; }
    public IXamlType GridLength { get; }
    public IXamlConstructor GridLengthConstructorValueType { get; }
    public IXamlType Color { get; }
    public IXamlType StandardCursorType { get; }
    public IXamlType Cursor { get; }
    public IXamlConstructor CursorTypeConstructor { get; }
    public IXamlType RowDefinition { get; }
    public IXamlType RowDefinitions { get; }
    public IXamlType ColumnDefinition { get; }
    public IXamlType ColumnDefinitions { get; }
    public IXamlType Classes { get; }
    public IXamlMethod ClassesBindMethod { get; }
    public IXamlProperty StyledElementClassesProperty { get; }
    public IXamlType IBrush { get; }
    public IXamlType ImmutableSolidColorBrush { get; }
    public IXamlConstructor ImmutableSolidColorBrushConstructorColor { get; }
    public IXamlType TypeUtilities { get; }
    public IXamlType TextDecorationCollection { get; }
    public IXamlType TextDecorations { get; }
    public IXamlType TextTrimming { get; }
    public IXamlType SetterBase { get; }
    public IXamlType Setter { get; }
    public IXamlType IStyle { get; }
    public IXamlType StyleInclude { get; }
    public IXamlType ResourceInclude { get; }
    public IXamlType MergeResourceInclude { get; }
    public IXamlType IResourceDictionary { get; }
    public IXamlType ResourceDictionary { get; }
    public IXamlMethod ResourceDictionaryDeferredAdd { get; }
    public IXamlMethod ResourceDictionaryNotSharedDeferredAdd { get; }
    public IXamlMethod ResourceDictionaryEnsureCapacity { get; }
    public IXamlMethod ResourceDictionaryGetCount { get; }
    public IXamlType IThemeVariantProvider { get; }
    public IXamlType UriKind { get; }
    public IXamlConstructor UriConstructor { get; }
    public IXamlType Style { get; }
    public IXamlType ControlTheme { get; }
    public IXamlType WindowTransparencyLevel { get; }
    public IXamlType IReadOnlyListOfT { get; }
    public IXamlType ControlTemplate { get; }
    public IXamlType EventHandlerT { get; }
    public InteractivityWellKnownTypes Interactivity { get; }
    public AvaloniaXamlIlWellKnownTypes(TransformerConfiguration cfg);
    [CompilerGeneratedAttribute]
public IXamlType get_RuntimeHelpers();
    [CompilerGeneratedAttribute]
public IXamlType get_AvaloniaObject();
    [CompilerGeneratedAttribute]
public IXamlType get_BindingPriority();
    [CompilerGeneratedAttribute]
public IXamlType get_AvaloniaObjectExtensions();
    [CompilerGeneratedAttribute]
public IXamlType get_AvaloniaProperty();
    [CompilerGeneratedAttribute]
public IXamlType get_AvaloniaPropertyT();
    [CompilerGeneratedAttribute]
public IXamlType get_StyledPropertyT();
    [CompilerGeneratedAttribute]
public IXamlMethod get_AvaloniaObjectSetStyledPropertyValue();
    [CompilerGeneratedAttribute]
public IXamlType get_AvaloniaAttachedPropertyT();
    [CompilerGeneratedAttribute]
public IXamlType get_IBinding();
    [CompilerGeneratedAttribute]
public IXamlType get_MultiBinding();
    [CompilerGeneratedAttribute]
public IXamlMethod get_AvaloniaObjectBindMethod();
    [CompilerGeneratedAttribute]
public IXamlMethod get_AvaloniaObjectSetValueMethod();
    [CompilerGeneratedAttribute]
public IXamlType get_IDisposable();
    [CompilerGeneratedAttribute]
public IXamlType get_ICommand();
    [CompilerGeneratedAttribute]
public XamlTypeWellKnownTypes get_XamlIlTypes();
    [CompilerGeneratedAttribute]
public IXamlType get_Transitions();
    [CompilerGeneratedAttribute]
public IXamlType get_AssignBindingAttribute();
    [CompilerGeneratedAttribute]
public IXamlType get_DependsOnAttribute();
    [CompilerGeneratedAttribute]
public IXamlType get_DataTypeAttribute();
    [CompilerGeneratedAttribute]
public IXamlType get_InheritDataTypeFromItemsAttribute();
    [CompilerGeneratedAttribute]
public IXamlType get_InheritDataTypeFromAttribute();
    [CompilerGeneratedAttribute]
public IXamlType get_MarkupExtensionOptionAttribute();
    [CompilerGeneratedAttribute]
public IXamlType get_MarkupExtensionDefaultOptionAttribute();
    [CompilerGeneratedAttribute]
public IXamlType get_AvaloniaListAttribute();
    [CompilerGeneratedAttribute]
public IXamlType get_AvaloniaList();
    [CompilerGeneratedAttribute]
public IXamlType get_OnExtensionType();
    [CompilerGeneratedAttribute]
public IXamlType get_UnsetValueType();
    [CompilerGeneratedAttribute]
public IXamlType get_StyledElement();
    [CompilerGeneratedAttribute]
public IXamlType get_NameScope();
    [CompilerGeneratedAttribute]
public IXamlMethod get_NameScopeSetNameScope();
    [CompilerGeneratedAttribute]
public IXamlType get_INameScope();
    [CompilerGeneratedAttribute]
public IXamlMethod get_INameScopeRegister();
    [CompilerGeneratedAttribute]
public IXamlMethod get_INameScopeComplete();
    [CompilerGeneratedAttribute]
public IXamlType get_IPropertyInfo();
    [CompilerGeneratedAttribute]
public IXamlType get_ClrPropertyInfo();
    [CompilerGeneratedAttribute]
public IXamlType get_PropertyPath();
    [CompilerGeneratedAttribute]
public IXamlType get_PropertyPathBuilder();
    [CompilerGeneratedAttribute]
public IXamlType get_IPropertyAccessor();
    [CompilerGeneratedAttribute]
public IXamlType get_PropertyInfoAccessorFactory();
    [CompilerGeneratedAttribute]
public IXamlType get_CompiledBindingPathBuilder();
    [CompilerGeneratedAttribute]
public IXamlType get_CompiledBindingPath();
    [CompilerGeneratedAttribute]
public IXamlType get_CompiledBindingExtension();
    [CompilerGeneratedAttribute]
public IXamlType get_ResolveByNameExtension();
    [CompilerGeneratedAttribute]
public IXamlType get_DataTemplate();
    [CompilerGeneratedAttribute]
public IXamlType get_IDataTemplate();
    [CompilerGeneratedAttribute]
public IXamlType get_ITemplateOfControl();
    [CompilerGeneratedAttribute]
public IXamlType get_Control();
    [CompilerGeneratedAttribute]
public IXamlType get_ItemsControl();
    [CompilerGeneratedAttribute]
public IXamlType get_ReflectionBindingExtension();
    [CompilerGeneratedAttribute]
public IXamlType get_RelativeSource();
    [CompilerGeneratedAttribute]
public IXamlType get_UInt();
    [CompilerGeneratedAttribute]
public IXamlType get_Int();
    [CompilerGeneratedAttribute]
public IXamlType get_Long();
    [CompilerGeneratedAttribute]
public IXamlType get_Uri();
    [CompilerGeneratedAttribute]
public IXamlType get_IDictionaryT();
    [CompilerGeneratedAttribute]
public IXamlType get_FontFamily();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_FontFamilyConstructorUriName();
    [CompilerGeneratedAttribute]
public IXamlType get_Thickness();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_ThicknessFullConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_ThemeVariant();
    [CompilerGeneratedAttribute]
public IXamlType get_Point();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_PointFullConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_Vector();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_VectorFullConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_Size();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_SizeFullConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_Matrix();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_MatrixFullConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_CornerRadius();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_CornerRadiusFullConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_RelativeUnit();
    [CompilerGeneratedAttribute]
public IXamlType get_RelativePoint();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_RelativePointFullConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_GridLength();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_GridLengthConstructorValueType();
    [CompilerGeneratedAttribute]
public IXamlType get_Color();
    [CompilerGeneratedAttribute]
public IXamlType get_StandardCursorType();
    [CompilerGeneratedAttribute]
public IXamlType get_Cursor();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_CursorTypeConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_RowDefinition();
    [CompilerGeneratedAttribute]
public IXamlType get_RowDefinitions();
    [CompilerGeneratedAttribute]
public IXamlType get_ColumnDefinition();
    [CompilerGeneratedAttribute]
public IXamlType get_ColumnDefinitions();
    [CompilerGeneratedAttribute]
public IXamlType get_Classes();
    [CompilerGeneratedAttribute]
public IXamlMethod get_ClassesBindMethod();
    [CompilerGeneratedAttribute]
public IXamlProperty get_StyledElementClassesProperty();
    [CompilerGeneratedAttribute]
public IXamlType get_IBrush();
    [CompilerGeneratedAttribute]
public IXamlType get_ImmutableSolidColorBrush();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_ImmutableSolidColorBrushConstructorColor();
    [CompilerGeneratedAttribute]
public IXamlType get_TypeUtilities();
    [CompilerGeneratedAttribute]
public IXamlType get_TextDecorationCollection();
    [CompilerGeneratedAttribute]
public IXamlType get_TextDecorations();
    [CompilerGeneratedAttribute]
public IXamlType get_TextTrimming();
    [CompilerGeneratedAttribute]
public IXamlType get_SetterBase();
    [CompilerGeneratedAttribute]
public IXamlType get_Setter();
    [CompilerGeneratedAttribute]
public IXamlType get_IStyle();
    [CompilerGeneratedAttribute]
public IXamlType get_StyleInclude();
    [CompilerGeneratedAttribute]
public IXamlType get_ResourceInclude();
    [CompilerGeneratedAttribute]
public IXamlType get_MergeResourceInclude();
    [CompilerGeneratedAttribute]
public IXamlType get_IResourceDictionary();
    [CompilerGeneratedAttribute]
public IXamlType get_ResourceDictionary();
    [CompilerGeneratedAttribute]
public IXamlMethod get_ResourceDictionaryDeferredAdd();
    [CompilerGeneratedAttribute]
public IXamlMethod get_ResourceDictionaryNotSharedDeferredAdd();
    [CompilerGeneratedAttribute]
public IXamlMethod get_ResourceDictionaryEnsureCapacity();
    [CompilerGeneratedAttribute]
public IXamlMethod get_ResourceDictionaryGetCount();
    [CompilerGeneratedAttribute]
public IXamlType get_IThemeVariantProvider();
    [CompilerGeneratedAttribute]
public IXamlType get_UriKind();
    [CompilerGeneratedAttribute]
public IXamlConstructor get_UriConstructor();
    [CompilerGeneratedAttribute]
public IXamlType get_Style();
    [CompilerGeneratedAttribute]
public IXamlType get_ControlTheme();
    [CompilerGeneratedAttribute]
public IXamlType get_WindowTransparencyLevel();
    [CompilerGeneratedAttribute]
public IXamlType get_IReadOnlyListOfT();
    [CompilerGeneratedAttribute]
public IXamlType get_ControlTemplate();
    [CompilerGeneratedAttribute]
public IXamlType get_EventHandlerT();
    [CompilerGeneratedAttribute]
public InteractivityWellKnownTypes get_Interactivity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.AvaloniaXamlIlWellKnownTypesExtensions : object {
    [ExtensionAttribute]
public static AvaloniaXamlIlWellKnownTypes GetAvaloniaTypes(AstTransformationContext ctx);
    [ExtensionAttribute]
public static AvaloniaXamlIlWellKnownTypes GetAvaloniaTypes(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> ctx);
    [ExtensionAttribute]
public static AvaloniaXamlIlWellKnownTypes GetAvaloniaTypes(AstGroupTransformationContext ctx);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.IgnoredDirectivesTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal interface Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.IXamlIlPropertyPathNode {
    [NullableAttribute("2")]
public IXamlType PropertyType { get; }
    [NullableContextAttribute("2")]
public abstract virtual IXamlType get_PropertyType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.LogicalAncestorBindingExpressionNode : object {
    [CompilerGeneratedAttribute]
private IXamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    public IXamlType Type { get; public set; }
    public int Level { get; public set; }
    public LogicalAncestorBindingExpressionNode(IXamlType type);
    [CompilerGeneratedAttribute]
public IXamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlType value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.NestedScopeMetadataNode : XamlValueWithSideEffectNodeBase {
    [NullableContextAttribute("1")]
public NestedScopeMetadataNode(IXamlAstValueNode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.ParsedBindingPathNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<INode> <Path>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public IList`1<INode> Path { get; }
    public ParsedBindingPathNode(IXamlLineInfo lineInfo, IXamlType compiledBindingType, IList`1<INode> path);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    [CompilerGeneratedAttribute]
public IList`1<INode> get_Path();
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
internal enum Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.SyntheticCompiledBindingPropertyName : Enum {
    public int value__;
    public static SyntheticCompiledBindingPropertyName ElementName;
    public static SyntheticCompiledBindingPropertyName RelativeSource;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.TemplatedParentBindingExpressionNode : object {
    [CompilerGeneratedAttribute]
private IXamlType <Type>k__BackingField;
    public IXamlType Type { get; public set; }
    public TemplatedParentBindingExpressionNode(IXamlType type);
    [CompilerGeneratedAttribute]
public IXamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlType value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.VisualAncestorBindingExpressionNode : object {
    [CompilerGeneratedAttribute]
private IXamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    public IXamlType Type { get; public set; }
    public int Level { get; public set; }
    public VisualAncestorBindingExpressionNode(IXamlType type);
    [CompilerGeneratedAttribute]
public IXamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlType value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlBindingsTransformException : XamlTransformException {
    [NullableContextAttribute("1")]
public XamlBindingsTransformException(string message, IXamlLineInfo lineInfo, Exception innerException);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlDataContextException : XamlTransformException {
    [NullableContextAttribute("1")]
public XamlDataContextException(string message, IXamlLineInfo lineInfo, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlAttachedPropertyEqualsSelector : XamlIlSelectorNode {
    [CompilerGeneratedAttribute]
private IXamlField <PropertyFiled>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    public IXamlField PropertyFiled { get; public set; }
    public IXamlAstValueNode Value { get; public set; }
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    public XamlIlAttachedPropertyEqualsSelector(XamlIlSelectorNode previous, IXamlField propertyFiled, IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlField get_PropertyFiled();
    [CompilerGeneratedAttribute]
public void set_PropertyFiled(IXamlField value);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    [NullableContextAttribute("2")]
public virtual IXamlType get_TargetType();
    protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlCombinatorSelector : XamlIlSelectorNode {
    private CombinatorSelectorType _type;
    public CombinatorSelectorType SelectorType { get; }
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    [NullableContextAttribute("1")]
public XamlIlCombinatorSelector(XamlIlSelectorNode previous, CombinatorSelectorType type);
    public CombinatorSelectorType get_SelectorType();
    [NullableContextAttribute("2")]
public virtual IXamlType get_TargetType();
    [NullableContextAttribute("1")]
protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlNestingSelector : XamlIlSelectorNode {
    [CompilerGeneratedAttribute]
private IXamlType <TargetType>k__BackingField;
    public IXamlType TargetType { get; }
    public XamlIlNestingSelector(XamlIlSelectorNode previous, IXamlType targetType);
    [CompilerGeneratedAttribute]
public virtual IXamlType get_TargetType();
    protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlNotSelector : XamlIlSelectorNode {
    [CompilerGeneratedAttribute]
private XamlIlSelectorNode <Argument>k__BackingField;
    public XamlIlSelectorNode Argument { get; }
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    public XamlIlNotSelector(XamlIlSelectorNode previous, XamlIlSelectorNode argument);
    [CompilerGeneratedAttribute]
public XamlIlSelectorNode get_Argument();
    [NullableContextAttribute("2")]
public virtual IXamlType get_TargetType();
    protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    [CompilerGeneratedAttribute]
private bool <DoEmit>b__6_0(IXamlMethod m);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlNthChildSelector : XamlIlSelectorNode {
    private int _step;
    private int _offset;
    private SelectorType _type;
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    [NullableContextAttribute("1")]
public XamlIlNthChildSelector(XamlIlSelectorNode previous, int step, int offset, SelectorType type);
    [NullableContextAttribute("2")]
public virtual IXamlType get_TargetType();
    [NullableContextAttribute("1")]
protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <DoEmit>b__7_0(IXamlMethod m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlOrSelectorNode : XamlIlSelectorNode {
    private List`1<XamlIlSelectorNode> _selectors;
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    public XamlIlOrSelectorNode(IXamlLineInfo info, IXamlType selectorType);
    public void Add(XamlIlSelectorNode node);
    [NullableContextAttribute("2")]
public virtual IXamlType get_TargetType();
    protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlPropertyEqualsSelector : XamlIlSelectorNode {
    [CompilerGeneratedAttribute]
private IXamlProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    public IXamlProperty Property { get; public set; }
    public IXamlAstValueNode Value { get; public set; }
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    public XamlIlPropertyEqualsSelector(XamlIlSelectorNode previous, IXamlProperty property, IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(IXamlProperty value);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    [NullableContextAttribute("2")]
public virtual IXamlType get_TargetType();
    protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlSelectorInitialNode : XamlIlSelectorNode {
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    public XamlIlSelectorInitialNode(IXamlLineInfo info, IXamlType selectorType);
    [NullableContextAttribute("2")]
public virtual IXamlType get_TargetType();
    protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlSelectorNode : XamlAstNode {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private XamlIlSelectorNode <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    [NullableAttribute("2")]
internal XamlIlSelectorNode Previous { get; }
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    public IXamlAstTypeReference Type { get; }
    [NullableContextAttribute("2")]
public XamlIlSelectorNode(XamlIlSelectorNode previous, IXamlLineInfo info, IXamlType selectorType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal XamlIlSelectorNode get_Previous();
    [NullableContextAttribute("2")]
public abstract virtual IXamlType get_TargetType();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    protected abstract virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    protected void EmitCall(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen, Func`2<IXamlMethod, bool> method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlStringSelector : XamlIlSelectorNode {
    [CompilerGeneratedAttribute]
private string <String>k__BackingField;
    private SelectorType _type;
    public string String { get; public set; }
    [NullableAttribute("2")]
public IXamlType TargetType { get; }
    public XamlIlStringSelector(XamlIlSelectorNode previous, SelectorType type, string s);
    [CompilerGeneratedAttribute]
public string get_String();
    [CompilerGeneratedAttribute]
public void set_String(string value);
    [NullableContextAttribute("2")]
public virtual IXamlType get_TargetType();
    protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlIlTypeSelector : XamlIlSelectorNode {
    [CompilerGeneratedAttribute]
private bool <Concrete>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <TargetType>k__BackingField;
    public bool Concrete { get; }
    public IXamlType TargetType { get; }
    public XamlIlTypeSelector(XamlIlSelectorNode previous, IXamlType type, bool concrete);
    [CompilerGeneratedAttribute]
public bool get_Concrete();
    [CompilerGeneratedAttribute]
public virtual IXamlType get_TargetType();
    protected virtual void DoEmit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlPropertyPathException : XamlTransformException {
    [NullableContextAttribute("1")]
public XamlPropertyPathException(string message, IXamlLineInfo lineInfo, Exception innerException);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlSelectorsTransformException : XamlTransformException {
    [NullableContextAttribute("1")]
public XamlSelectorsTransformException(string message, IXamlLineInfo lineInfo, Exception innerException);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XamlStyleTransformException : XamlTransformException {
    [NullableContextAttribute("1")]
public XamlStyleTransformException(string message, IXamlLineInfo lineInfo, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XDataTypeTransformer : object {
    private static string DataTypePropertyName;
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [IteratorStateMachineAttribute("Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XDataTypeTransformer/<GetAllProperties>d__2")]
private static IEnumerable`1<ValueTuple`2<IXamlType, IXamlProperty>> GetAllProperties(IXamlType t);
}
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Transformers.XNameTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.Visitors.NameScopeRegistrationVisitor : Dictionary`2<string, ValueTuple`2<IXamlType, IXamlLineInfo>> {
    private int _targetMetadataScopeLevel;
    private Stack`1<IXamlAstNode> _parents;
    private int _metadataScopeLevel;
    public NameScopeRegistrationVisitor(int initialMetadataScopeLevel, int targetMetadataScopeLevel);
    private sealed virtual override IXamlAstNode XamlX.Ast.IXamlAstVisitor.Visit(IXamlAstNode node);
    private sealed virtual override void XamlX.Ast.IXamlAstVisitor.Push(IXamlAstNode node);
    private sealed virtual override void XamlX.Ast.IXamlAstVisitor.Pop();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlDocumentResource : object {
    [NullableAttribute("1")]
private Func`1<XamlDocumentTypeBuilderProvider> _createTypeBuilderProvider;
    private XamlDocumentTypeBuilderProvider _typeBuilderProvider;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private XamlDocument <XamlDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSource <FileSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ClassType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlDocumentUsage <Usage>k__BackingField;
    [NullableAttribute("1")]
public XamlDocument XamlDocument { get; }
    public string Uri { get; }
    public IFileSource FileSource { get; }
    public IXamlType ClassType { get; }
    public bool IsPublic { get; }
    public XamlDocumentUsage Usage { get; public set; }
    [NullableAttribute("1")]
public XamlDocumentTypeBuilderProvider TypeBuilderProvider { get; }
    private IXamlMethod Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.IXamlDocumentResource.BuildMethod { get; }
    [NullableAttribute("1")]
private IXamlMethod Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.IXamlDocumentResource.PopulateMethod { get; }
    public XamlDocumentResource(XamlDocument xamlDocument, string uri, IFileSource fileSource, IXamlType classType, bool isPublic, Func`1<XamlDocumentTypeBuilderProvider> createTypeBuilderProvider);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual XamlDocument get_XamlDocument();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Uri();
    [CompilerGeneratedAttribute]
public sealed virtual IFileSource get_FileSource();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlType get_ClassType();
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public sealed virtual XamlDocumentUsage get_Usage();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Usage(XamlDocumentUsage value);
    [NullableContextAttribute("1")]
public XamlDocumentTypeBuilderProvider get_TypeBuilderProvider();
    private sealed virtual override IXamlMethod Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.IXamlDocumentResource.get_BuildMethod();
    [NullableContextAttribute("1")]
private sealed virtual override IXamlMethod Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.IXamlDocumentResource.get_PopulateMethod();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlDocumentTypeBuilderProvider : object {
    [CompilerGeneratedAttribute]
private IXamlTypeBuilder`1<IXamlILEmitter> <PopulateDeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethodBuilder`1<IXamlILEmitter> <PopulateMethod>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IXamlTypeBuilder`1<IXamlILEmitter> <BuildDeclaringType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IXamlMethodBuilder`1<IXamlILEmitter> <BuildMethod>k__BackingField;
    public IXamlTypeBuilder`1<IXamlILEmitter> PopulateDeclaringType { get; }
    public IXamlMethodBuilder`1<IXamlILEmitter> PopulateMethod { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IXamlTypeBuilder`1<IXamlILEmitter> BuildDeclaringType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IXamlMethodBuilder`1<IXamlILEmitter> BuildMethod { get; }
    public XamlDocumentTypeBuilderProvider(IXamlTypeBuilder`1<IXamlILEmitter> populateDeclaringType, IXamlMethodBuilder`1<IXamlILEmitter> populateMethod, IXamlTypeBuilder`1<IXamlILEmitter> buildDeclaringType, IXamlMethodBuilder`1<IXamlILEmitter> buildMethod);
    [CompilerGeneratedAttribute]
public IXamlTypeBuilder`1<IXamlILEmitter> get_PopulateDeclaringType();
    [CompilerGeneratedAttribute]
public IXamlMethodBuilder`1<IXamlILEmitter> get_PopulateMethod();
    [CompilerGeneratedAttribute]
public IXamlTypeBuilder`1<IXamlILEmitter> get_BuildDeclaringType();
    [CompilerGeneratedAttribute]
public IXamlMethodBuilder`1<IXamlILEmitter> get_BuildMethod();
}
internal enum Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlDocumentUsage : Enum {
    public int value__;
    public static XamlDocumentUsage Unknown;
    public static XamlDocumentUsage Merged;
    public static XamlDocumentUsage Used;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlAvaloniaProperty : XamlAstClrProperty {
    [CompilerGeneratedAttribute]
private IXamlField <AvaloniaProperty>k__BackingField;
    public IXamlField AvaloniaProperty { get; }
    public XamlIlAvaloniaProperty(XamlAstClrProperty original, IXamlField field, AvaloniaXamlIlWellKnownTypes types);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlField get_AvaloniaProperty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlAvaloniaPropertyFieldNode : XamlAstNode {
    private IXamlField _field;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaPropertyType>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public IXamlType AvaloniaPropertyType { get; }
    public XamlIlAvaloniaPropertyFieldNode(AvaloniaXamlIlWellKnownTypes types, IXamlLineInfo lineInfo, IXamlField field);
    public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlType get_AvaloniaPropertyType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlAvaloniaPropertyHelper : object {
    public static bool EmitProvideValueTarget(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter emitter, XamlAstClrProperty property);
    public static bool Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter emitter, XamlAstClrProperty property);
    public static bool Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter emitter, IXamlProperty property);
    public static IXamlIlAvaloniaPropertyNode CreateNode(AstTransformationContext context, string propertyName, IXamlAstTypeReference selectorTypeReference, IXamlLineInfo lineInfo);
    public static IXamlType GetAvaloniaPropertyType(IXamlField field, AvaloniaXamlIlWellKnownTypes types, IXamlLineInfo lineInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlAvaloniaPropertyNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private XamlAstClrProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <AvaloniaPropertyType>k__BackingField;
    public XamlAstClrProperty Property { get; }
    public IXamlAstTypeReference Type { get; }
    public IXamlType AvaloniaPropertyType { get; }
    public XamlIlAvaloniaPropertyNode(IXamlLineInfo lineInfo, IXamlType type, XamlAstClrProperty property, IXamlType propertyType);
    public XamlIlAvaloniaPropertyNode(IXamlLineInfo lineInfo, IXamlType type, XamlAstClrProperty property);
    [CompilerGeneratedAttribute]
public XamlAstClrProperty get_Property();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlType get_AvaloniaPropertyType();
    private static IXamlType GetPropertyType(XamlAstClrProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlBindingPathHelper : object {
    public static IXamlType UpdateCompiledBindingExtension(AstTransformationContext context, XamlAstConstructableObjectNode binding, Func`1<IXamlType> startTypeResolver, IXamlType selfType);
    private static XamlIlBindingPathNode TransformForTargetTyping(XamlIlBindingPathNode transformed, AstTransformationContext context);
    private static IXamlType GetPropertyType(AstTransformationContext context, XamlPropertyAssignmentNode node);
    private static XamlIlBindingPathNode TransformBindingPath(AstTransformationContext context, IXamlLineInfo lineInfo, Func`1<IXamlType> startTypeResolver, IXamlType selfType, IEnumerable`1<INode> bindingExpression);
    [IteratorStateMachineAttribute("Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlBindingPathHelper/<<TransformBindingPath>g__GetAllDefinedProperties|3_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<IXamlProperty> <TransformBindingPath>g__GetAllDefinedProperties|3_1(IXamlType type);
    [IteratorStateMachineAttribute("Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlBindingPathHelper/<<TransformBindingPath>g__GetAllDefinedMethods|3_2>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<IXamlMethod> <TransformBindingPath>g__GetAllDefinedMethods|3_2(IXamlType type);
    [IteratorStateMachineAttribute("Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlBindingPathHelper/<<TransformBindingPath>g__TraverseTypeHierarchy|3_3>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<IXamlType> <TransformBindingPath>g__TraverseTypeHierarchy|3_3(IXamlType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlClrPropertyInfoEmitter : object {
    private IXamlTypeBuilder`1<IXamlILEmitter> _builder;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, List`1<ValueTuple`2<IXamlProperty, IXamlMethod>>> _fields;
    public XamlIlClrPropertyInfoEmitter(IXamlTypeBuilder`1<IXamlILEmitter> builder);
    private static string GetKey(IXamlProperty property, string indexerArgumentsKey);
    public IXamlType Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen, IXamlProperty property, IReadOnlyCollection`1<IXamlAstValueNode> indexerArguments, string indexerArgumentsKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlPropertyInfoAccessorFactoryEmitter : object {
    private static string IndexerClosureFactoryMethodName;
    private IXamlTypeBuilder`1<IXamlILEmitter> _indexerClosureTypeBuilder;
    [NullableAttribute("2")]
private IXamlType _indexerClosureType;
    public XamlIlPropertyInfoAccessorFactoryEmitter(IXamlTypeBuilder`1<IXamlILEmitter> indexerClosureType);
    public IXamlType EmitLoadInpcPropertyAccessorFactory(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    public IXamlType EmitLoadAvaloniaPropertyAccessorFactory(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    private void EmitLoadPropertyAccessorFactory(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen, IXamlType type, string accessorFactoryName, bool isStatic);
    public IXamlType EmitLoadIndexerAccessorFactory(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen, IXamlAstValueNode value);
    private IXamlType InitializeClosureType(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context);
    private IXamlType EmitCreateAccessorFactoryDelegate(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Markup.Xaml.XamlIl.CompilerExtensions.XamlIlTrampolineBuilder : object {
    private IXamlTypeBuilder`1<IXamlILEmitter> _builder;
    private Dictionary`2<string, IXamlMethod> _trampolines;
    public XamlIlTrampolineBuilder(IXamlTypeBuilder`1<IXamlILEmitter> builder);
    public IXamlMethod EmitCommandExecuteTrampoline(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlMethod executeMethod);
    public IXamlMethod EmitCommandCanExecuteTrampoline(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlMethod canExecuteMethod);
}
[IsReadOnlyAttribute]
internal class Avalonia.Matrix : ValueType {
    private double _m11;
    private double _m12;
    private double _m13;
    private double _m21;
    private double _m22;
    private double _m23;
    private double _m31;
    private double _m32;
    private double _m33;
    [CompilerGeneratedAttribute]
private static Matrix <Identity>k__BackingField;
    public static Matrix Identity { get; }
    public bool IsIdentity { get; }
    public bool HasInverse { get; }
    public double M11 { get; }
    public double M12 { get; }
    public double M13 { get; }
    public double M21 { get; }
    public double M22 { get; }
    public double M23 { get; }
    public double M31 { get; }
    public double M32 { get; }
    public double M33 { get; }
    public Matrix(double scaleX, double skewY, double skewX, double scaleY, double offsetX, double offsetY);
    public Matrix(double scaleX, double skewY, double perspX, double skewX, double scaleY, double perspY, double offsetX, double offsetY, double perspZ);
    private static Matrix();
    [CompilerGeneratedAttribute]
public static Matrix get_Identity();
    public bool get_IsIdentity();
    public bool get_HasInverse();
    public double get_M11();
    public double get_M12();
    public double get_M13();
    public double get_M21();
    public double get_M22();
    public double get_M23();
    public double get_M31();
    public double get_M32();
    public double get_M33();
    public static Matrix op_Multiply(Matrix value1, Matrix value2);
    public static Matrix op_UnaryNegation(Matrix value);
    public static bool op_Equality(Matrix value1, Matrix value2);
    public static bool op_Inequality(Matrix value1, Matrix value2);
    public static Matrix CreateRotation(double radians);
    public static Matrix CreateSkew(double xAngle, double yAngle);
    public static Matrix CreateScale(double xScale, double yScale);
    public static Matrix CreateScale(Vector scales);
    public static Matrix CreateTranslation(Vector position);
    public static Matrix CreateTranslation(double xPosition, double yPosition);
    public static double ToRadians(double angle);
    public Matrix Append(Matrix value);
    public Matrix Prepend(Matrix value);
    public double GetDeterminant();
    public Point Transform(Point p);
    public sealed virtual bool Equals(Matrix other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool ContainsPerspective();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public bool TryInvert(Matrix& inverted);
    public Matrix Invert();
    [NullableContextAttribute("1")]
public static Matrix Parse(string s);
    public static bool TryDecomposeTransform(Matrix matrix, Decomposed& decomposed);
}
[IsReadOnlyAttribute]
internal class Avalonia.Media.Color : ValueType {
    private static double byteToDouble;
    [CompilerGeneratedAttribute]
private byte <A>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <R>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <G>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <B>k__BackingField;
    public byte A { get; }
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }
    public Color(byte a, byte r, byte g, byte b);
    [CompilerGeneratedAttribute]
public byte get_A();
    [CompilerGeneratedAttribute]
public byte get_R();
    [CompilerGeneratedAttribute]
public byte get_G();
    [CompilerGeneratedAttribute]
public byte get_B();
    public static Color FromArgb(byte a, byte r, byte g, byte b);
    public static Color FromRgb(byte r, byte g, byte b);
    public static Color FromUInt32(UInt32 value);
    [NullableContextAttribute("1")]
public static Color Parse(string s);
    public static Color Parse(ReadOnlySpan`1<char> s);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Color& color);
    public static bool TryParse(ReadOnlySpan`1<char> s, Color& color);
    private static bool TryParseHexFormat(ReadOnlySpan`1<char> s, Color& color);
    [NullableContextAttribute("2")]
private static bool TryParseCssFormat(string s, Color& color);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal void ToString(StringBuilder builder);
    public UInt32 ToUInt32();
    [ObsoleteAttribute("Use Color.ToUInt32() instead.")]
[EditorBrowsableAttribute("1")]
public UInt32 ToUint32();
    public HslColor ToHsl();
    public HsvColor ToHsv();
    public sealed virtual bool Equals(Color other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static HslColor ToHsl(byte red, byte green, byte blue, byte alpha);
    internal static HslColor ToHsl(double r, double g, double b, double a);
    public static HsvColor ToHsv(byte red, byte green, byte blue, byte alpha);
    internal static HsvColor ToHsv(double r, double g, double b, double a);
    public static bool op_Equality(Color left, Color right);
    public static bool op_Inequality(Color left, Color right);
    [CompilerGeneratedAttribute]
internal static bool <TryParseHexFormat>g__TryParseCore|21_0(ReadOnlySpan`1<char> input, Color& color);
    [CompilerGeneratedAttribute]
internal static bool <TryParseCssFormat>g__InternalTryParseByte|22_0(ReadOnlySpan`1<char> inString, Byte& outByte);
    [CompilerGeneratedAttribute]
internal static bool <TryParseCssFormat>g__InternalTryParseDouble|22_1(ReadOnlySpan`1<char> inString, Double& outDouble);
}
[IsReadOnlyAttribute]
internal class Avalonia.Media.HslColor : ValueType {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <H>k__BackingField;
    [CompilerGeneratedAttribute]
private double <S>k__BackingField;
    [CompilerGeneratedAttribute]
private double <L>k__BackingField;
    public double A { get; }
    public double H { get; }
    public double S { get; }
    public double L { get; }
    public HslColor(double alpha, double hue, double saturation, double lightness);
    internal HslColor(double alpha, double hue, double saturation, double lightness, bool clampValues);
    public HslColor(Color color);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
public double get_H();
    [CompilerGeneratedAttribute]
public double get_S();
    [CompilerGeneratedAttribute]
public double get_L();
    public sealed virtual bool Equals(HslColor other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Color ToRgb();
    public HsvColor ToHsv();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static HslColor Parse(string s);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, HslColor& hslColor);
    public static HslColor FromAhsl(double a, double h, double s, double l);
    public static HslColor FromHsl(double h, double s, double l);
    public static Color ToRgb(double hue, double saturation, double lightness, double alpha);
    public static HsvColor ToHsv(double hue, double saturation, double lightness, double alpha);
    public static bool op_Equality(HslColor left, HslColor right);
    public static bool op_Inequality(HslColor left, HslColor right);
    public static Color op_Explicit(HslColor hslColor);
    [CompilerGeneratedAttribute]
internal static bool <TryParse>g__TryInternalParse|22_0(ReadOnlySpan`1<char> inString, Double& outDouble);
}
[IsReadOnlyAttribute]
internal class Avalonia.Media.HsvColor : ValueType {
    [CompilerGeneratedAttribute]
private double <A>k__BackingField;
    [CompilerGeneratedAttribute]
private double <H>k__BackingField;
    [CompilerGeneratedAttribute]
private double <S>k__BackingField;
    [CompilerGeneratedAttribute]
private double <V>k__BackingField;
    public double A { get; }
    public double H { get; }
    public double S { get; }
    public double V { get; }
    public HsvColor(double alpha, double hue, double saturation, double value);
    internal HsvColor(double alpha, double hue, double saturation, double value, bool clampValues);
    public HsvColor(Color color);
    [CompilerGeneratedAttribute]
public double get_A();
    [CompilerGeneratedAttribute]
public double get_H();
    [CompilerGeneratedAttribute]
public double get_S();
    [CompilerGeneratedAttribute]
public double get_V();
    public sealed virtual bool Equals(HsvColor other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Color ToRgb();
    public HslColor ToHsl();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static HsvColor Parse(string s);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, HsvColor& hsvColor);
    public static HsvColor FromAhsv(double a, double h, double s, double v);
    public static HsvColor FromHsv(double h, double s, double v);
    public static Color ToRgb(double hue, double saturation, double value, double alpha);
    public static HslColor ToHsl(double hue, double saturation, double value, double alpha);
    public static bool op_Equality(HsvColor left, HsvColor right);
    public static bool op_Inequality(HsvColor left, HsvColor right);
    public static Color op_Explicit(HsvColor hsvColor);
    [CompilerGeneratedAttribute]
internal static bool <TryParse>g__TryInternalParse|22_0(ReadOnlySpan`1<char> inString, Double& outDouble);
}
internal enum Avalonia.Media.KnownColor : Enum {
    public UInt32 value__;
    public static KnownColor None;
    public static KnownColor AliceBlue;
    public static KnownColor AntiqueWhite;
    public static KnownColor Aqua;
    public static KnownColor Aquamarine;
    public static KnownColor Azure;
    public static KnownColor Beige;
    public static KnownColor Bisque;
    public static KnownColor Black;
    public static KnownColor BlanchedAlmond;
    public static KnownColor Blue;
    public static KnownColor BlueViolet;
    public static KnownColor Brown;
    public static KnownColor BurlyWood;
    public static KnownColor CadetBlue;
    public static KnownColor Chartreuse;
    public static KnownColor Chocolate;
    public static KnownColor Coral;
    public static KnownColor CornflowerBlue;
    public static KnownColor Cornsilk;
    public static KnownColor Crimson;
    public static KnownColor Cyan;
    public static KnownColor DarkBlue;
    public static KnownColor DarkCyan;
    public static KnownColor DarkGoldenrod;
    public static KnownColor DarkGray;
    public static KnownColor DarkGreen;
    public static KnownColor DarkKhaki;
    public static KnownColor DarkMagenta;
    public static KnownColor DarkOliveGreen;
    public static KnownColor DarkOrange;
    public static KnownColor DarkOrchid;
    public static KnownColor DarkRed;
    public static KnownColor DarkSalmon;
    public static KnownColor DarkSeaGreen;
    public static KnownColor DarkSlateBlue;
    public static KnownColor DarkSlateGray;
    public static KnownColor DarkTurquoise;
    public static KnownColor DarkViolet;
    public static KnownColor DeepPink;
    public static KnownColor DeepSkyBlue;
    public static KnownColor DimGray;
    public static KnownColor DodgerBlue;
    public static KnownColor Firebrick;
    public static KnownColor FloralWhite;
    public static KnownColor ForestGreen;
    public static KnownColor Fuchsia;
    public static KnownColor Gainsboro;
    public static KnownColor GhostWhite;
    public static KnownColor Gold;
    public static KnownColor Goldenrod;
    public static KnownColor Gray;
    public static KnownColor Green;
    public static KnownColor GreenYellow;
    public static KnownColor Honeydew;
    public static KnownColor HotPink;
    public static KnownColor IndianRed;
    public static KnownColor Indigo;
    public static KnownColor Ivory;
    public static KnownColor Khaki;
    public static KnownColor Lavender;
    public static KnownColor LavenderBlush;
    public static KnownColor LawnGreen;
    public static KnownColor LemonChiffon;
    public static KnownColor LightBlue;
    public static KnownColor LightCoral;
    public static KnownColor LightCyan;
    public static KnownColor LightGoldenrodYellow;
    public static KnownColor LightGreen;
    public static KnownColor LightGray;
    public static KnownColor LightPink;
    public static KnownColor LightSalmon;
    public static KnownColor LightSeaGreen;
    public static KnownColor LightSkyBlue;
    public static KnownColor LightSlateGray;
    public static KnownColor LightSteelBlue;
    public static KnownColor LightYellow;
    public static KnownColor Lime;
    public static KnownColor LimeGreen;
    public static KnownColor Linen;
    public static KnownColor Magenta;
    public static KnownColor Maroon;
    public static KnownColor MediumAquamarine;
    public static KnownColor MediumBlue;
    public static KnownColor MediumOrchid;
    public static KnownColor MediumPurple;
    public static KnownColor MediumSeaGreen;
    public static KnownColor MediumSlateBlue;
    public static KnownColor MediumSpringGreen;
    public static KnownColor MediumTurquoise;
    public static KnownColor MediumVioletRed;
    public static KnownColor MidnightBlue;
    public static KnownColor MintCream;
    public static KnownColor MistyRose;
    public static KnownColor Moccasin;
    public static KnownColor NavajoWhite;
    public static KnownColor Navy;
    public static KnownColor OldLace;
    public static KnownColor Olive;
    public static KnownColor OliveDrab;
    public static KnownColor Orange;
    public static KnownColor OrangeRed;
    public static KnownColor Orchid;
    public static KnownColor PaleGoldenrod;
    public static KnownColor PaleGreen;
    public static KnownColor PaleTurquoise;
    public static KnownColor PaleVioletRed;
    public static KnownColor PapayaWhip;
    public static KnownColor PeachPuff;
    public static KnownColor Peru;
    public static KnownColor Pink;
    public static KnownColor Plum;
    public static KnownColor PowderBlue;
    public static KnownColor Purple;
    public static KnownColor Red;
    public static KnownColor RosyBrown;
    public static KnownColor RoyalBlue;
    public static KnownColor SaddleBrown;
    public static KnownColor Salmon;
    public static KnownColor SandyBrown;
    public static KnownColor SeaGreen;
    public static KnownColor SeaShell;
    public static KnownColor Sienna;
    public static KnownColor Silver;
    public static KnownColor SkyBlue;
    public static KnownColor SlateBlue;
    public static KnownColor SlateGray;
    public static KnownColor Snow;
    public static KnownColor SpringGreen;
    public static KnownColor SteelBlue;
    public static KnownColor Tan;
    public static KnownColor Teal;
    public static KnownColor Thistle;
    public static KnownColor Tomato;
    public static KnownColor Transparent;
    public static KnownColor Turquoise;
    public static KnownColor Violet;
    public static KnownColor Wheat;
    public static KnownColor White;
    public static KnownColor WhiteSmoke;
    public static KnownColor Yellow;
    public static KnownColor YellowGreen;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Media.KnownColors : object {
    private static IReadOnlyDictionary`2<string, KnownColor> _knownColorNames;
    private static IReadOnlyDictionary`2<UInt32, string> _knownColors;
    private static KnownColors();
    [GenerateEnumValueDictionaryAttribute]
private static Dictionary`2<string, KnownColor> GetKnownColors();
    public static KnownColor GetKnownColor(string s);
    [NullableContextAttribute("2")]
public static string GetKnownColorName(UInt32 rgb);
    [NullableContextAttribute("2")]
internal static bool TryGetKnownColorName(UInt32 rgb, String& name);
    [ExtensionAttribute]
public static Color ToColor(KnownColor color);
}
public static class Avalonia.Platform.AssetLoader : object {
    internal static void RegisterResUriParsers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Platform.Internal.Constants : object {
    public static string AvaloniaResourceName { get; }
    public static string get_AvaloniaResourceName();
}
[IsReadOnlyAttribute]
internal class Avalonia.Point : ValueType {
    private double _x;
    private double _y;
    public double X { get; }
    public double Y { get; }
    public Point(double x, double y);
    public double get_X();
    public double get_Y();
    public static Vector op_Implicit(Point p);
    public static Point op_UnaryNegation(Point a);
    public static bool op_Equality(Point left, Point right);
    public static bool op_Inequality(Point left, Point right);
    public static Point op_Addition(Point a, Point b);
    public static Point op_Addition(Point a, Vector b);
    public static Point op_Subtraction(Point a, Point b);
    public static Point op_Subtraction(Point a, Vector b);
    public static Point op_Multiply(Point p, double k);
    public static Point op_Multiply(double k, Point p);
    public static Point op_Division(Point p, double k);
    public static Point op_Multiply(Point point, Matrix matrix);
    public static double Distance(Point value1, Point value2);
    [NullableContextAttribute("1")]
public static Point Parse(string s);
    public sealed virtual bool Equals(Point other);
    public bool NearlyEquals(Point other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Point Transform(Matrix transform);
    internal Point Transform(Matrix4x4 matrix);
    public Point WithX(double x);
    public Point WithY(double y);
    public void Deconstruct(Double& x, Double& y);
}
[IsReadOnlyAttribute]
internal class Avalonia.RelativePoint : ValueType {
    public static RelativePoint TopLeft;
    public static RelativePoint Center;
    public static RelativePoint BottomRight;
    private Point _point;
    private RelativeUnit _unit;
    public Point Point { get; }
    public RelativeUnit Unit { get; }
    public RelativePoint(double x, double y, RelativeUnit unit);
    public RelativePoint(Point point, RelativeUnit unit);
    private static RelativePoint();
    public Point get_Point();
    public RelativeUnit get_Unit();
    public static bool op_Equality(RelativePoint left, RelativePoint right);
    public static bool op_Inequality(RelativePoint left, RelativePoint right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RelativePoint p);
    public virtual int GetHashCode();
    public Point ToPixels(Size size);
    [NullableContextAttribute("1")]
public static RelativePoint Parse(string s);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal enum Avalonia.RelativeUnit : Enum {
    public int value__;
    public static RelativeUnit Relative;
    public static RelativeUnit Absolute;
}
[IsReadOnlyAttribute]
internal class Avalonia.Size : ValueType {
    public static Size Infinity;
    private double _width;
    private double _height;
    public double AspectRatio { get; }
    public double Width { get; }
    public double Height { get; }
    public Size(double width, double height);
    private static Size();
    public double get_AspectRatio();
    public double get_Width();
    public double get_Height();
    public static bool op_Equality(Size left, Size right);
    public static bool op_Inequality(Size left, Size right);
    public static Size op_Multiply(Size size, Vector scale);
    public static Size op_Division(Size size, Vector scale);
    public static Vector op_Division(Size left, Size right);
    public static Size op_Multiply(Size size, double scale);
    public static Size op_Division(Size size, double scale);
    public static Size op_Addition(Size size, Size toAdd);
    public static Size op_Subtraction(Size size, Size toSubtract);
    [NullableContextAttribute("1")]
public static Size Parse(string s);
    public Size Constrain(Size constraint);
    public Size Deflate(Thickness thickness);
    public sealed virtual bool Equals(Size other);
    public bool NearlyEquals(Size other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Size Inflate(Thickness thickness);
    public Size WithWidth(double width);
    public Size WithHeight(double height);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public void Deconstruct(Double& width, Double& height);
}
[AttributeUsageAttribute("64")]
internal class Avalonia.SourceGenerator.GenerateEnumValueDictionaryAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class Avalonia.SourceGenerator.GenerateEnumValueListAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Avalonia.SourceGenerator.GetProcAddressAttribute : Attribute {
    public GetProcAddressAttribute(string proc);
    public GetProcAddressAttribute(string proc, bool optional);
    public GetProcAddressAttribute(bool optional);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Avalonia.SourceGenerator.SubtypesFactoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    public string Namespace { get; }
    public Type BaseType { get; }
    public SubtypesFactoryAttribute(Type baseType, string namespace);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public Type get_BaseType();
}
[IsReadOnlyAttribute]
internal class Avalonia.Thickness : ValueType {
    private double _left;
    private double _top;
    private double _right;
    private double _bottom;
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public bool IsUniform { get; }
    public Thickness(double uniformLength);
    public Thickness(double horizontal, double vertical);
    public Thickness(double left, double top, double right, double bottom);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public bool get_IsUniform();
    public static bool op_Equality(Thickness a, Thickness b);
    public static bool op_Inequality(Thickness a, Thickness b);
    public static Thickness op_Addition(Thickness a, Thickness b);
    public static Thickness op_Subtraction(Thickness a, Thickness b);
    public static Thickness op_Multiply(Thickness a, double b);
    public static Size op_Addition(Size size, Thickness thickness);
    public static Size op_Subtraction(Size size, Thickness thickness);
    [NullableContextAttribute("1")]
public static Thickness Parse(string s);
    public sealed virtual bool Equals(Thickness other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public void Deconstruct(Double& left, Double& top, Double& right, Double& bottom);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.AvaloniaResourcesEntry : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<Stream> <Open>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemPath>k__BackingField;
    public string Path { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<Stream> Open { get; public set; }
    public int Size { get; public set; }
    public string SystemPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Path(string value);
    [CompilerGeneratedAttribute]
public Func`1<Stream> get_Open();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Open(Func`1<Stream> value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Size(int value);
    [CompilerGeneratedAttribute]
public string get_SystemPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SystemPath(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.AvaloniaResourcesIndexEntry : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public string Path { get; public set; }
    public int Offset { get; public set; }
    public int Size { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Utilities.AvaloniaResourcesIndexReaderWriter : object {
    private static int XmlLegacyVersion;
    private static int BinaryCurrentVersion;
    public static List`1<AvaloniaResourcesIndexEntry> ReadIndex(Stream stream);
    private static List`1<AvaloniaResourcesIndexEntry> ReadXmlIndex();
    private static List`1<AvaloniaResourcesIndexEntry> ReadBinaryIndex(BinaryReader reader);
    public static void WriteIndex(Stream output, List`1<AvaloniaResourcesIndexEntry> entries);
    private static void WriteIndex(BinaryWriter writer, List`1<AvaloniaResourcesIndexEntry> entries);
    [ObsoleteAttribute]
public static void WriteResources(Stream output, List`1<ValueTuple`3<string, int, Func`1<Stream>>> resources);
    public static void WriteResources(Stream output, IReadOnlyList`1<AvaloniaResourcesEntry> resources);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Avalonia.Utilities.CharacterReader : ValueType {
    private ReadOnlySpan`1<char> _s;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public bool End { get; }
    public char Peek { get; }
    public int Position { get; private set; }
    public CharacterReader(ReadOnlySpan`1<char> s);
    public bool get_End();
    public char get_Peek();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public char Take();
    public void SkipWhitespace();
    public bool TakeIf(char c);
    [NullableContextAttribute("1")]
public bool TakeIf(Func`2<char, bool> condition);
    public ReadOnlySpan`1<char> TakeUntil(char c);
    public ReadOnlySpan`1<char> TakeWhile(Func`2<char, bool> condition);
    public ReadOnlySpan`1<char> TryPeek(int count);
    public ReadOnlySpan`1<char> PeekWhitespace();
    public void Skip(int count);
}
[ExtensionAttribute]
internal static class Avalonia.Utilities.IdentifierParser : object {
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseIdentifier(CharacterReader& r);
    private static bool IsValidIdentifierStart(char c);
    private static bool IsValidIdentifierChar(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Avalonia.Utilities.KeywordParser : object {
    [ExtensionAttribute]
public static bool CheckKeyword(CharacterReader& r, string keyword);
    [ExtensionAttribute]
private static int CheckKeywordInternal(CharacterReader& r, string keyword);
    [NullableContextAttribute("0")]
private static bool SpanEquals(ReadOnlySpan`1<char> left, ReadOnlySpan`1<char> right);
    [ExtensionAttribute]
public static bool TakeIfKeyword(CharacterReader& r, string keyword);
}
internal static class Avalonia.Utilities.MathUtilities : object {
    internal static double DoubleEpsilon;
    private static float FloatEpsilon;
    public static bool AreClose(double value1, double value2);
    public static bool AreClose(double value1, double value2, double eps);
    public static bool AreClose(float value1, float value2);
    public static bool LessThan(double value1, double value2);
    public static bool LessThan(float value1, float value2);
    public static bool GreaterThan(double value1, double value2);
    public static bool GreaterThan(float value1, float value2);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool LessThanOrClose(float value1, float value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool GreaterThanOrClose(float value1, float value2);
    public static bool IsOne(double value);
    public static bool IsOne(float value);
    public static bool IsZero(double value);
    public static bool IsZero(float value);
    public static double Clamp(double val, double min, double max);
    public static decimal Clamp(decimal val, decimal min, decimal max);
    public static float Clamp(float value, float min, float max);
    public static int Clamp(int val, int min, int max);
    public static double Deg2Rad(double angle);
    public static double Grad2Rad(double angle);
    public static double Turn2Rad(double angle);
    public static Point GetEllipsePoint(Point centre, double radiusX, double radiusY, double angle);
    public static ValueTuple`2<double, double> GetMinMax(double a, double b);
    public static ValueTuple`2<double, double> GetMinMaxFromDelta(double initialValue, double delta);
    [NullableContextAttribute("1")]
private static void ThrowCannotBeGreaterThanException(T min, T max);
}
[ExtensionAttribute]
internal static class Avalonia.Utilities.SpanHelpers : object {
    [ExtensionAttribute]
public static bool TryParseUInt(ReadOnlySpan`1<char> span, NumberStyles style, IFormatProvider provider, UInt32& value);
    [ExtensionAttribute]
public static bool TryParseInt(ReadOnlySpan`1<char> span, Int32& value);
    [ExtensionAttribute]
public static bool TryParseDouble(ReadOnlySpan`1<char> span, NumberStyles style, IFormatProvider provider, Double& value);
    [ExtensionAttribute]
public static bool TryParseByte(ReadOnlySpan`1<char> span, NumberStyles style, IFormatProvider provider, Byte& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Avalonia.Utilities.StringBuilderCache : object {
    internal static int MaxBuilderSize;
    private static int DefaultCapacity;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Avalonia.Utilities.StringTokenizer : ValueType {
    private static char DefaultSeparatorChar;
    private string _s;
    private int _length;
    private char _separator;
    [NullableAttribute("2")]
private string _exceptionMessage;
    private IFormatProvider _formatProvider;
    private int _index;
    private int _tokenIndex;
    private int _tokenLength;
    [NullableAttribute("2")]
public string CurrentToken { get; }
    public StringTokenizer(string s, IFormatProvider formatProvider, string exceptionMessage);
    public StringTokenizer(string s, char separator, string exceptionMessage);
    [NullableContextAttribute("2")]
public string get_CurrentToken();
    public sealed virtual void Dispose();
    public bool TryReadInt32(Int32& result, Nullable`1<char> separator);
    public int ReadInt32(Nullable`1<char> separator);
    public bool TryReadDouble(Double& result, Nullable`1<char> separator);
    public double ReadDouble(Nullable`1<char> separator);
    public bool TryReadString(String& result, Nullable`1<char> separator);
    public string ReadString(Nullable`1<char> separator);
    private bool TryReadToken(char separator);
    private void SkipToNextToken(char separator);
    private FormatException GetFormatException();
    private static char GetSeparatorFromFormatProvider(IFormatProvider provider);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StringTokenizer left, StringTokenizer right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StringTokenizer left, StringTokenizer right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringTokenizer other);
}
[ExtensionAttribute]
internal static class Avalonia.Utilities.StyleClassParser : object {
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseStyleClass(CharacterReader& r);
    private static bool IsValidIdentifierStart(char c);
    private static bool IsValidIdentifierChar(char c);
}
[IsReadOnlyAttribute]
internal class Avalonia.Vector : ValueType {
    private double _x;
    private double _y;
    public double X { get; }
    public double Y { get; }
    public double Length { get; }
    public double SquaredLength { get; }
    public static Vector Zero { get; }
    public static Vector One { get; }
    public static Vector UnitX { get; }
    public static Vector UnitY { get; }
    public Vector(double x, double y);
    internal Vector(Vector2 v);
    public double get_X();
    public double get_Y();
    public static Point op_Explicit(Vector a);
    public static double op_Multiply(Vector a, Vector b);
    public static Vector op_Multiply(Vector vector, double scale);
    public static Vector op_Multiply(double scale, Vector vector);
    public static Vector op_Division(Vector vector, double scale);
    [NullableContextAttribute("1")]
public static Vector Parse(string s);
    public double get_Length();
    public double get_SquaredLength();
    public static Vector op_UnaryNegation(Vector a);
    public static Vector op_Addition(Vector a, Vector b);
    public static Vector op_Subtraction(Vector a, Vector b);
    public sealed virtual bool Equals(Vector other);
    public bool NearlyEquals(Vector other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Vector left, Vector right);
    public static bool op_Inequality(Vector left, Vector right);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Vector WithX(double x);
    public Vector WithY(double y);
    public Vector Normalize();
    public Vector Negate();
    public static double Dot(Vector a, Vector b);
    public static double Cross(Vector a, Vector b);
    public static Vector Normalize(Vector vector);
    public static Vector Divide(Vector a, Vector b);
    public static Vector Divide(Vector vector, double scalar);
    public static Vector Multiply(Vector a, Vector b);
    public static Vector Multiply(Vector vector, double scalar);
    public static Vector Add(Vector a, Vector b);
    public static Vector Subtract(Vector a, Vector b);
    public static Vector Negate(Vector vector);
    public static Vector get_Zero();
    public static Vector get_One();
    public static Vector get_UnitX();
    public static Vector get_UnitY();
    public void Deconstruct(Double& x, Double& y);
    internal Vector2 ToVector2();
    public Vector Abs();
    public static Vector Clamp(Vector value, Vector min, Vector max);
    public static Vector Max(Vector left, Vector right);
    public static Vector Min(Vector left, Vector right);
    public static double Distance(Vector value1, Vector value2);
    public static double DistanceSquared(Vector value1, Vector value2);
    public static Vector op_Implicit(Vector2 v);
}
internal static class Consts : object {
    public static string AssemblyName;
    public static string PublicKey;
}
internal class Microsoft.Cci.Pdb.AlignSym : ValueType {
}
internal class Microsoft.Cci.Pdb.AnnotationSym : ValueType {
    internal UInt32 off;
    internal ushort seg;
    internal ushort csz;
    internal String[] rgsz;
}
internal class Microsoft.Cci.Pdb.AttrManyRegSym : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal byte count;
    internal Byte[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrManyRegSym2 : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal ushort count;
    internal UInt16[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrRegRel : ValueType {
    internal UInt32 off;
    internal UInt32 typind;
    internal ushort reg;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrRegSym : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrSlotSym : ValueType {
    internal UInt32 index;
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.BitAccess : object {
    private Byte[] buffer;
    private int offset;
    internal Byte[] Buffer { get; }
    internal int Position { get; internal set; }
    internal BitAccess(int capacity);
    internal BitAccess(Byte[] buffer);
    internal Byte[] get_Buffer();
    internal void FillBuffer(Stream stream, int capacity);
    internal void Append(Stream stream, int count);
    internal int get_Position();
    internal void set_Position(int value);
    internal void MinCapacity(int capacity);
    internal void Align(int alignment);
    internal void ReadInt16(Int16& value);
    internal void ReadInt8(SByte& value);
    internal void ReadInt32(Int32& value);
    internal void ReadInt64(Int64& value);
    internal void ReadUInt16(UInt16& value);
    internal void ReadUInt8(Byte& value);
    internal void ReadUInt32(UInt32& value);
    internal void ReadUInt64(UInt64& value);
    internal void ReadInt32(Int32[] values);
    internal void ReadUInt32(UInt32[] values);
    internal void ReadBytes(Byte[] bytes);
    internal float ReadFloat();
    internal double ReadDouble();
    internal decimal ReadDecimal();
    internal void ReadBString(String& value);
    internal string ReadBString(int len);
    internal void ReadCString(String& value);
    internal void SkipCString(String& value);
    internal void ReadGuid(Guid& guid);
    internal string ReadString();
}
internal class Microsoft.Cci.Pdb.BitSet : ValueType {
    private int size;
    private UInt32[] words;
    internal bool IsEmpty { get; }
    internal BitSet(BitAccess bits);
    internal bool IsSet(int index);
    private static UInt32 GetBit(int index);
    internal bool get_IsEmpty();
}
internal class Microsoft.Cci.Pdb.BlockSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 len;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.BpRelSym32 : ValueType {
    internal int off;
    internal UInt32 typind;
    internal string name;
}
internal class Microsoft.Cci.Pdb.CallsiteInfo : ValueType {
    internal int off;
    internal ushort ect;
    internal ushort pad0;
    internal UInt32 typind;
}
internal class Microsoft.Cci.Pdb.CFlagSym : ValueType {
    internal byte machine;
    internal byte language;
    internal ushort flags;
    internal string ver;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CFLAGSYM_FLAGS : Enum {
    public ushort value__;
    public static CFLAGSYM_FLAGS pcode;
    public static CFLAGSYM_FLAGS floatprec;
    public static CFLAGSYM_FLAGS floatpkg;
    public static CFLAGSYM_FLAGS ambdata;
    public static CFLAGSYM_FLAGS ambcode;
    public static CFLAGSYM_FLAGS mode32;
}
internal class Microsoft.Cci.Pdb.CoffGroupSym : ValueType {
    internal UInt32 cb;
    internal UInt32 characteristics;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.CompileSym : ValueType {
    internal UInt32 flags;
    internal ushort machine;
    internal ushort verFEMajor;
    internal ushort verFEMinor;
    internal ushort verFEBuild;
    internal ushort verMajor;
    internal ushort verMinor;
    internal ushort verBuild;
    internal string verSt;
    internal String[] verArgs;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.COMPILESYM_FLAGS : Enum {
    public UInt32 value__;
    public static COMPILESYM_FLAGS iLanguage;
    public static COMPILESYM_FLAGS fEC;
    public static COMPILESYM_FLAGS fNoDbgInfo;
    public static COMPILESYM_FLAGS fLTCG;
    public static COMPILESYM_FLAGS fNoDataAlign;
    public static COMPILESYM_FLAGS fManagedPresent;
    public static COMPILESYM_FLAGS fSecurityChecks;
    public static COMPILESYM_FLAGS fHotPatch;
    public static COMPILESYM_FLAGS fCVTCIL;
    public static COMPILESYM_FLAGS fMSILModule;
}
internal class Microsoft.Cci.Pdb.ConstSym : ValueType {
    internal UInt32 typind;
    internal ushort value;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_CODE : Enum {
    public int value__;
    public static CV_CFL_CODE CV_CFL_CNEAR;
    public static CV_CFL_CODE CV_CFL_CFAR;
    public static CV_CFL_CODE CV_CFL_CHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_DATA : Enum {
    public int value__;
    public static CV_CFL_DATA CV_CFL_DNEAR;
    public static CV_CFL_DATA CV_CFL_DFAR;
    public static CV_CFL_DATA CV_CFL_DHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_FPKG : Enum {
    public int value__;
    public static CV_CFL_FPKG CV_CFL_NDP;
    public static CV_CFL_FPKG CV_CFL_EMU;
    public static CV_CFL_FPKG CV_CFL_ALT;
}
internal class Microsoft.Cci.Pdb.CV_Column : ValueType {
    internal ushort offColumnStart;
    internal ushort offColumnEnd;
}
internal enum Microsoft.Cci.Pdb.CV_cookietype : Enum {
    public int value__;
    public static CV_cookietype CV_COOKIETYPE_COPY;
    public static CV_cookietype CV_COOKIETYPE_XOR_SP;
    public static CV_cookietype CV_COOKIETYPE_XOR_BP;
    public static CV_cookietype CV_COOKIETYPE_XOR_R13;
}
internal enum Microsoft.Cci.Pdb.CV_DISCARDED : Enum {
    public UInt32 value__;
    public static CV_DISCARDED CV_DISCARDED_UNKNOWN;
    public static CV_DISCARDED CV_DISCARDED_NOT_SELECTED;
    public static CV_DISCARDED CV_DISCARDED_NOT_REFERENCED;
}
internal class Microsoft.Cci.Pdb.CV_EXPROCFLAGS : ValueType {
    internal byte flags;
    internal byte reserved;
}
internal enum Microsoft.Cci.Pdb.CV_FILE_CHECKSUM_TYPE : Enum {
    public byte value__;
    public static CV_FILE_CHECKSUM_TYPE None;
    public static CV_FILE_CHECKSUM_TYPE MD5;
}
internal class Microsoft.Cci.Pdb.CV_FileCheckSum : ValueType {
    internal UInt32 name;
    internal byte len;
    internal byte type;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_fldattr : Enum {
    public int value__;
    public static CV_fldattr access;
    public static CV_fldattr mprop;
    public static CV_fldattr pseudo;
    public static CV_fldattr noinherit;
    public static CV_fldattr noconstruct;
    public static CV_fldattr compgenx;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_GENERIC_FLAG : Enum {
    public ushort value__;
    public static CV_GENERIC_FLAG cstyle;
    public static CV_GENERIC_FLAG rsclean;
}
internal enum Microsoft.Cci.Pdb.CV_GENERIC_STYLE : Enum {
    public int value__;
    public static CV_GENERIC_STYLE CV_GENERIC_VOID;
    public static CV_GENERIC_STYLE CV_GENERIC_REG;
    public static CV_GENERIC_STYLE CV_GENERIC_ICAN;
    public static CV_GENERIC_STYLE CV_GENERIC_ICAF;
    public static CV_GENERIC_STYLE CV_GENERIC_IRAN;
    public static CV_GENERIC_STYLE CV_GENERIC_IRAF;
    public static CV_GENERIC_STYLE CV_GENERIC_UNUSED;
}
internal enum Microsoft.Cci.Pdb.CV_int : Enum {
    public int value__;
    public static CV_int CV_RI_CHAR;
    public static CV_int CV_RI_INT1;
    public static CV_int CV_RI_WCHAR;
    public static CV_int CV_RI_UINT1;
    public static CV_int CV_RI_INT2;
    public static CV_int CV_RI_UINT2;
    public static CV_int CV_RI_INT4;
    public static CV_int CV_RI_UINT4;
    public static CV_int CV_RI_INT8;
    public static CV_int CV_RI_UINT8;
    public static CV_int CV_RI_INT16;
    public static CV_int CV_RI_UINT16;
}
internal enum Microsoft.Cci.Pdb.CV_integral : Enum {
    public int value__;
    public static CV_integral CV_IN_1BYTE;
    public static CV_integral CV_IN_2BYTE;
    public static CV_integral CV_IN_4BYTE;
    public static CV_integral CV_IN_8BYTE;
    public static CV_integral CV_IN_16BYTE;
}
internal enum Microsoft.Cci.Pdb.CV_LABEL_TYPE : Enum {
    public int value__;
    public static CV_LABEL_TYPE CV_LABEL_NEAR;
    public static CV_LABEL_TYPE CV_LABEL_FAR;
}
internal class Microsoft.Cci.Pdb.CV_Line : ValueType {
    internal UInt32 offset;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_Line_Flags : Enum {
    public UInt32 value__;
    public static CV_Line_Flags linenumStart;
    public static CV_Line_Flags deltaLineEnd;
    public static CV_Line_Flags fStatement;
}
internal enum Microsoft.Cci.Pdb.CV_LINE_SUBSECTION_FLAGS : Enum {
    public ushort value__;
    public static CV_LINE_SUBSECTION_FLAGS CV_LINES_HAVE_COLUMNS;
}
internal class Microsoft.Cci.Pdb.CV_LineSection : ValueType {
    internal UInt32 off;
    internal ushort sec;
    internal ushort flags;
    internal UInt32 cod;
}
internal class Microsoft.Cci.Pdb.CV_lvar_addr_range : ValueType {
    internal UInt32 offStart;
    internal ushort isectStart;
    internal UInt32 cbRange;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_LVARFLAGS : Enum {
    public ushort value__;
    public static CV_LVARFLAGS fIsParam;
    public static CV_LVARFLAGS fAddrTaken;
    public static CV_LVARFLAGS fCompGenx;
    public static CV_LVARFLAGS fIsAggregate;
    public static CV_LVARFLAGS fIsAggregated;
    public static CV_LVARFLAGS fIsAliased;
    public static CV_LVARFLAGS fIsAlias;
}
internal enum Microsoft.Cci.Pdb.CV_methodprop : Enum {
    public int value__;
    public static CV_methodprop CV_MTvanilla;
    public static CV_methodprop CV_MTvirtual;
    public static CV_methodprop CV_MTstatic;
    public static CV_methodprop CV_MTfriend;
    public static CV_methodprop CV_MTintro;
    public static CV_methodprop CV_MTpurevirt;
    public static CV_methodprop CV_MTpureintro;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_modifier : Enum {
    public ushort value__;
    public static CV_modifier MOD_const;
    public static CV_modifier MOD_volatile;
    public static CV_modifier MOD_unaligned;
}
internal class Microsoft.Cci.Pdb.CV_PDMR32_NVVFCN : ValueType {
    internal int mdisp;
}
internal class Microsoft.Cci.Pdb.CV_PDMR32_VBASE : ValueType {
    internal int mdisp;
    internal int pdisp;
    internal int vdisp;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_NVMA : ValueType {
    internal UInt32 off;
    internal int disp;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_NVSA : ValueType {
    internal UInt32 off;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_VBASE : ValueType {
    internal UInt32 off;
    internal int mdisp;
    internal int pdisp;
    internal int vdisp;
}
internal enum Microsoft.Cci.Pdb.CV_pmtype : Enum {
    public int value__;
    public static CV_pmtype CV_PMTYPE_Undef;
    public static CV_pmtype CV_PMTYPE_D_Single;
    public static CV_pmtype CV_PMTYPE_D_Multiple;
    public static CV_pmtype CV_PMTYPE_D_Virtual;
    public static CV_pmtype CV_PMTYPE_D_General;
    public static CV_pmtype CV_PMTYPE_F_Single;
    public static CV_pmtype CV_PMTYPE_F_Multiple;
    public static CV_pmtype CV_PMTYPE_F_Virtual;
    public static CV_pmtype CV_PMTYPE_F_General;
}
internal class Microsoft.Cci.Pdb.CV_PRIMITIVE_TYPE : ValueType {
    private static UInt32 CV_MMASK;
    private static UInt32 CV_TMASK;
    private static UInt32 CV_SMASK;
    private static int CV_MSHIFT;
    private static int CV_TSHIFT;
    private static int CV_SSHIFT;
    private static UInt32 CV_FIRST_NONPRIM;
}
internal enum Microsoft.Cci.Pdb.CV_prmode : Enum {
    public int value__;
    public static CV_prmode CV_TM_DIRECT;
    public static CV_prmode CV_TM_NPTR32;
    public static CV_prmode CV_TM_NPTR64;
    public static CV_prmode CV_TM_NPTR128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PROCFLAGS : Enum {
    public byte value__;
    public static CV_PROCFLAGS CV_PFLAG_NOFPO;
    public static CV_PROCFLAGS CV_PFLAG_INT;
    public static CV_PROCFLAGS CV_PFLAG_FAR;
    public static CV_PROCFLAGS CV_PFLAG_NEVER;
    public static CV_PROCFLAGS CV_PFLAG_NOTREACHED;
    public static CV_PROCFLAGS CV_PFLAG_CUST_CALL;
    public static CV_PROCFLAGS CV_PFLAG_NOINLINE;
    public static CV_PROCFLAGS CV_PFLAG_OPTDBGINFO;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_prop : Enum {
    public ushort value__;
    public static CV_prop packed;
    public static CV_prop ctor;
    public static CV_prop ovlops;
    public static CV_prop isnested;
    public static CV_prop cnested;
    public static CV_prop opassign;
    public static CV_prop opcast;
    public static CV_prop fwdref;
    public static CV_prop scoped;
}
internal enum Microsoft.Cci.Pdb.CV_ptrmode : Enum {
    public int value__;
    public static CV_ptrmode CV_PTR_MODE_PTR;
    public static CV_ptrmode CV_PTR_MODE_REF;
    public static CV_ptrmode CV_PTR_MODE_PMEM;
    public static CV_ptrmode CV_PTR_MODE_PMFUNC;
    public static CV_ptrmode CV_PTR_MODE_RESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_ptrtype : Enum {
    public int value__;
    public static CV_ptrtype CV_PTR_BASE_SEG;
    public static CV_ptrtype CV_PTR_BASE_VAL;
    public static CV_ptrtype CV_PTR_BASE_SEGVAL;
    public static CV_ptrtype CV_PTR_BASE_ADDR;
    public static CV_ptrtype CV_PTR_BASE_SEGADDR;
    public static CV_ptrtype CV_PTR_BASE_TYPE;
    public static CV_ptrtype CV_PTR_BASE_SELF;
    public static CV_ptrtype CV_PTR_NEAR32;
    public static CV_ptrtype CV_PTR_64;
    public static CV_ptrtype CV_PTR_UNUSEDPTR;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PUBSYMFLAGS : Enum {
    public UInt32 value__;
    public static CV_PUBSYMFLAGS fNone;
    public static CV_PUBSYMFLAGS fCode;
    public static CV_PUBSYMFLAGS fFunction;
    public static CV_PUBSYMFLAGS fManaged;
    public static CV_PUBSYMFLAGS fMSIL;
}
internal enum Microsoft.Cci.Pdb.CV_real : Enum {
    public int value__;
    public static CV_real CV_RC_REAL32;
    public static CV_real CV_RC_REAL64;
    public static CV_real CV_RC_REAL80;
    public static CV_real CV_RC_REAL128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_SEPCODEFLAGS : Enum {
    public UInt32 value__;
    public static CV_SEPCODEFLAGS fIsLexicalScope;
    public static CV_SEPCODEFLAGS fReturnsToParent;
}
internal enum Microsoft.Cci.Pdb.CV_SIGNATURE : Enum {
    public int value__;
    public static CV_SIGNATURE C6;
    public static CV_SIGNATURE C7;
    public static CV_SIGNATURE C11;
    public static CV_SIGNATURE C13;
    public static CV_SIGNATURE RESERVERD;
}
internal class Microsoft.Cci.Pdb.CV_SourceFile : ValueType {
    internal UInt32 index;
    internal UInt32 count;
    internal UInt32 linsiz;
}
internal enum Microsoft.Cci.Pdb.CV_special : Enum {
    public int value__;
    public static CV_special CV_SP_NOTYPE;
    public static CV_special CV_SP_ABS;
    public static CV_special CV_SP_SEGMENT;
    public static CV_special CV_SP_VOID;
    public static CV_special CV_SP_CURRENCY;
    public static CV_special CV_SP_NBASICSTR;
    public static CV_special CV_SP_FBASICSTR;
    public static CV_special CV_SP_NOTTRANS;
    public static CV_special CV_SP_HRESULT;
}
internal enum Microsoft.Cci.Pdb.CV_special2 : Enum {
    public int value__;
    public static CV_special2 CV_S2_BIT;
    public static CV_special2 CV_S2_PASCHAR;
}
internal enum Microsoft.Cci.Pdb.CV_type : Enum {
    public int value__;
    public static CV_type CV_SPECIAL;
    public static CV_type CV_SIGNED;
    public static CV_type CV_UNSIGNED;
    public static CV_type CV_BOOLEAN;
    public static CV_type CV_REAL;
    public static CV_type CV_COMPLEX;
    public static CV_type CV_SPECIAL2;
    public static CV_type CV_INT;
    public static CV_type CV_CVRESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_VTS_desc : Enum {
    public int value__;
    public static CV_VTS_desc CV_VTS_near;
    public static CV_VTS_desc CV_VTS_far;
    public static CV_VTS_desc CV_VTS_thin;
    public static CV_VTS_desc CV_VTS_outer;
    public static CV_VTS_desc CV_VTS_meta;
    public static CV_VTS_desc CV_VTS_near32;
    public static CV_VTS_desc CV_VTS_far32;
    public static CV_VTS_desc CV_VTS_unused;
}
internal class Microsoft.Cci.Pdb.DatasSym32 : ValueType {
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.DataStream : object {
    internal int contentSize;
    internal Int32[] pages;
    internal int Length { get; }
    internal DataStream(int contentSize, BitAccess bits, int count);
    internal void Read(PdbReader reader, BitAccess bits);
    internal void Read(PdbReader reader, int position, Byte[] bytes, int offset, int data);
    internal int get_Length();
}
internal class Microsoft.Cci.Pdb.DbiDbgHdr : ValueType {
    internal ushort snFPO;
    internal ushort snException;
    internal ushort snFixup;
    internal ushort snOmapToSrc;
    internal ushort snOmapFromSrc;
    internal ushort snSectionHdr;
    internal ushort snTokenRidMap;
    internal ushort snXdata;
    internal ushort snPdata;
    internal ushort snNewFPO;
    internal ushort snSectionHdrOrig;
    internal DbiDbgHdr(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiHeader : ValueType {
    internal int sig;
    internal int ver;
    internal int age;
    internal short gssymStream;
    internal ushort vers;
    internal short pssymStream;
    internal ushort pdbver;
    internal short symrecStream;
    internal ushort pdbver2;
    internal int gpmodiSize;
    internal int secconSize;
    internal int secmapSize;
    internal int filinfSize;
    internal int tsmapSize;
    internal int mfcIndex;
    internal int dbghdrSize;
    internal int ecinfoSize;
    internal ushort flags;
    internal ushort machine;
    internal int reserved;
    internal DbiHeader(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiModuleInfo : object {
    internal int opened;
    internal ushort flags;
    internal short stream;
    internal int cbSyms;
    internal int cbOldLines;
    internal int cbLines;
    internal short files;
    internal short pad1;
    internal UInt32 offsets;
    internal int niSource;
    internal int niCompiler;
    internal string moduleName;
    internal string objectName;
    internal DbiModuleInfo(BitAccess bits, bool readStrings);
}
internal class Microsoft.Cci.Pdb.DbiSecCon : ValueType {
    internal short section;
    internal short pad1;
    internal int offset;
    internal int size;
    internal UInt32 flags;
    internal short module;
    internal short pad2;
    internal UInt32 dataCrc;
    internal UInt32 relocCrc;
    internal DbiSecCon(BitAccess bits);
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION : Enum {
    public int value__;
    public static DEBUG_S_SUBSECTION SYMBOLS;
    public static DEBUG_S_SUBSECTION LINES;
    public static DEBUG_S_SUBSECTION STRINGTABLE;
    public static DEBUG_S_SUBSECTION FILECHKSMS;
    public static DEBUG_S_SUBSECTION FRAMEDATA;
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION_TYPE : Enum {
    public UInt32 value__;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_IGNORE;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_SYMBOLS;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_LINES;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_STRINGTABLE;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FILECHKSMS;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FRAMEDATA;
}
internal class Microsoft.Cci.Pdb.DefRangeSym : ValueType {
    internal UInt32 id;
    internal UInt32 program;
    internal CV_lvar_addr_range range;
}
internal class Microsoft.Cci.Pdb.DefRangeSym2 : ValueType {
    internal UInt32 id;
    internal UInt32 program;
    internal ushort count;
    internal CV_lvar_addr_range[] range;
}
internal class Microsoft.Cci.Pdb.DiscardedSym : ValueType {
    internal CV_DISCARDED iscarded;
    internal UInt32 fileid;
    internal UInt32 linenum;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.EndArgSym : ValueType {
}
internal class Microsoft.Cci.Pdb.EntryThisSym : ValueType {
    internal byte thissym;
}
internal class Microsoft.Cci.Pdb.ExportSym : ValueType {
    internal ushort ordinal;
    internal ushort flags;
    internal string name;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.EXPORTSYM_FLAGS : Enum {
    public ushort value__;
    public static EXPORTSYM_FLAGS fConstant;
    public static EXPORTSYM_FLAGS fData;
    public static EXPORTSYM_FLAGS fPrivate;
    public static EXPORTSYM_FLAGS fNoName;
    public static EXPORTSYM_FLAGS fOrdinal;
    public static EXPORTSYM_FLAGS fForwarder;
}
internal class Microsoft.Cci.Pdb.FLOAT10 : ValueType {
    internal byte Data_0;
    internal byte Data_1;
    internal byte Data_2;
    internal byte Data_3;
    internal byte Data_4;
    internal byte Data_5;
    internal byte Data_6;
    internal byte Data_7;
    internal byte Data_8;
    internal byte Data_9;
}
internal class Microsoft.Cci.Pdb.FrameCookie : ValueType {
    internal int off;
    internal ushort reg;
    internal int cookietype;
    internal byte flags;
}
internal class Microsoft.Cci.Pdb.FrameData : ValueType {
    internal UInt32 ulRvaStart;
    internal UInt32 cbBlock;
    internal UInt32 cbLocals;
    internal UInt32 cbParams;
    internal UInt32 cbStkMax;
    internal UInt32 frameFunc;
    internal ushort cbProlog;
    internal ushort cbSavedRegs;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEDATA_FLAGS : Enum {
    public UInt32 value__;
    public static FRAMEDATA_FLAGS fHasSEH;
    public static FRAMEDATA_FLAGS fHasEH;
    public static FRAMEDATA_FLAGS fIsFunctionStart;
}
internal class Microsoft.Cci.Pdb.FrameProcSym : ValueType {
    internal UInt32 cbFrame;
    internal UInt32 cbPad;
    internal UInt32 offPad;
    internal UInt32 cbSaveRegs;
    internal UInt32 offExHdlr;
    internal ushort secExHdlr;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEPROCSYM_FLAGS : Enum {
    public UInt32 value__;
    public static FRAMEPROCSYM_FLAGS fHasAlloca;
    public static FRAMEPROCSYM_FLAGS fHasSetJmp;
    public static FRAMEPROCSYM_FLAGS fHasLongJmp;
    public static FRAMEPROCSYM_FLAGS fHasInlAsm;
    public static FRAMEPROCSYM_FLAGS fHasEH;
    public static FRAMEPROCSYM_FLAGS fInlSpec;
    public static FRAMEPROCSYM_FLAGS fHasSEH;
    public static FRAMEPROCSYM_FLAGS fNaked;
    public static FRAMEPROCSYM_FLAGS fSecurityChecks;
    public static FRAMEPROCSYM_FLAGS fAsyncEH;
    public static FRAMEPROCSYM_FLAGS fGSNoStackOrdering;
    public static FRAMEPROCSYM_FLAGS fWasInlined;
}
internal class Microsoft.Cci.Pdb.FrameRelSym : ValueType {
    internal int off;
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
internal interface Microsoft.Cci.Pdb.ILocalScope {
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    public abstract virtual UInt32 get_Offset();
    public abstract virtual UInt32 get_Length();
}
internal interface Microsoft.Cci.Pdb.IName {
    public int UniqueKey { get; }
    public int UniqueKeyIgnoringCase { get; }
    public string Value { get; }
    public abstract virtual int get_UniqueKey();
    public abstract virtual int get_UniqueKeyIgnoringCase();
    public abstract virtual string get_Value();
}
internal interface Microsoft.Cci.Pdb.INamespaceScope {
    public IEnumerable`1<IUsedNamespace> UsedNamespaces { get; }
    public abstract virtual IEnumerable`1<IUsedNamespace> get_UsedNamespaces();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.Pdb.IntHashTable : object {
    private static Int32[] primes;
    private bucket[] buckets;
    private int count;
    private int occupancy;
    private int loadsize;
    private int loadFactorPerc;
    private int version;
    internal object Item { get; }
    internal IntHashTable(int capacity, int loadFactorPerc);
    private static IntHashTable();
    private static int GetPrime(int minSize);
    private static UInt32 InitHash(int key, int hashsize, UInt32& seed, UInt32& incr);
    internal void Add(int key, object value);
    internal object get_Item(int key);
    private void expand();
    private void rehash();
    private void rehash(int newsize);
    private void Insert(int key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, int key, object nvalue, int hashcode);
}
internal interface Microsoft.Cci.Pdb.IUsedNamespace {
    public IName Alias { get; }
    public IName NamespaceName { get; }
    public abstract virtual IName get_Alias();
    public abstract virtual IName get_NamespaceName();
}
internal class Microsoft.Cci.Pdb.LabelSym32 : ValueType {
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.LEAF : Enum {
    public int value__;
    public static LEAF LF_VTSHAPE;
    public static LEAF LF_COBOL1;
    public static LEAF LF_LABEL;
    public static LEAF LF_NULL;
    public static LEAF LF_NOTTRAN;
    public static LEAF LF_ENDPRECOMP;
    public static LEAF LF_TYPESERVER_ST;
    public static LEAF LF_LIST;
    public static LEAF LF_REFSYM;
    public static LEAF LF_ENUMERATE_ST;
    public static LEAF LF_TI16_MAX;
    public static LEAF LF_MODIFIER;
    public static LEAF LF_POINTER;
    public static LEAF LF_ARRAY_ST;
    public static LEAF LF_CLASS_ST;
    public static LEAF LF_STRUCTURE_ST;
    public static LEAF LF_UNION_ST;
    public static LEAF LF_ENUM_ST;
    public static LEAF LF_PROCEDURE;
    public static LEAF LF_MFUNCTION;
    public static LEAF LF_COBOL0;
    public static LEAF LF_BARRAY;
    public static LEAF LF_DIMARRAY_ST;
    public static LEAF LF_VFTPATH;
    public static LEAF LF_PRECOMP_ST;
    public static LEAF LF_OEM;
    public static LEAF LF_ALIAS_ST;
    public static LEAF LF_OEM2;
    public static LEAF LF_SKIP;
    public static LEAF LF_ARGLIST;
    public static LEAF LF_DEFARG_ST;
    public static LEAF LF_FIELDLIST;
    public static LEAF LF_DERIVED;
    public static LEAF LF_BITFIELD;
    public static LEAF LF_METHODLIST;
    public static LEAF LF_DIMCONU;
    public static LEAF LF_DIMCONLU;
    public static LEAF LF_DIMVARU;
    public static LEAF LF_DIMVARLU;
    public static LEAF LF_BCLASS;
    public static LEAF LF_VBCLASS;
    public static LEAF LF_IVBCLASS;
    public static LEAF LF_FRIENDFCN_ST;
    public static LEAF LF_INDEX;
    public static LEAF LF_MEMBER_ST;
    public static LEAF LF_STMEMBER_ST;
    public static LEAF LF_METHOD_ST;
    public static LEAF LF_NESTTYPE_ST;
    public static LEAF LF_VFUNCTAB;
    public static LEAF LF_FRIENDCLS;
    public static LEAF LF_ONEMETHOD_ST;
    public static LEAF LF_VFUNCOFF;
    public static LEAF LF_NESTTYPEEX_ST;
    public static LEAF LF_MEMBERMODIFY_ST;
    public static LEAF LF_MANAGED_ST;
    public static LEAF LF_ST_MAX;
    public static LEAF LF_TYPESERVER;
    public static LEAF LF_ENUMERATE;
    public static LEAF LF_ARRAY;
    public static LEAF LF_CLASS;
    public static LEAF LF_STRUCTURE;
    public static LEAF LF_UNION;
    public static LEAF LF_ENUM;
    public static LEAF LF_DIMARRAY;
    public static LEAF LF_PRECOMP;
    public static LEAF LF_ALIAS;
    public static LEAF LF_DEFARG;
    public static LEAF LF_FRIENDFCN;
    public static LEAF LF_MEMBER;
    public static LEAF LF_STMEMBER;
    public static LEAF LF_METHOD;
    public static LEAF LF_NESTTYPE;
    public static LEAF LF_ONEMETHOD;
    public static LEAF LF_NESTTYPEEX;
    public static LEAF LF_MEMBERMODIFY;
    public static LEAF LF_MANAGED;
    public static LEAF LF_TYPESERVER2;
    public static LEAF LF_NUMERIC;
    public static LEAF LF_CHAR;
    public static LEAF LF_SHORT;
    public static LEAF LF_USHORT;
    public static LEAF LF_LONG;
    public static LEAF LF_ULONG;
    public static LEAF LF_REAL32;
    public static LEAF LF_REAL64;
    public static LEAF LF_REAL80;
    public static LEAF LF_REAL128;
    public static LEAF LF_QUADWORD;
    public static LEAF LF_UQUADWORD;
    public static LEAF LF_COMPLEX32;
    public static LEAF LF_COMPLEX64;
    public static LEAF LF_COMPLEX80;
    public static LEAF LF_COMPLEX128;
    public static LEAF LF_VARSTRING;
    public static LEAF LF_OCTWORD;
    public static LEAF LF_UOCTWORD;
    public static LEAF LF_DECIMAL;
    public static LEAF LF_DATE;
    public static LEAF LF_UTF8STRING;
    public static LEAF LF_PAD0;
    public static LEAF LF_PAD1;
    public static LEAF LF_PAD2;
    public static LEAF LF_PAD3;
    public static LEAF LF_PAD4;
    public static LEAF LF_PAD5;
    public static LEAF LF_PAD6;
    public static LEAF LF_PAD7;
    public static LEAF LF_PAD8;
    public static LEAF LF_PAD9;
    public static LEAF LF_PAD10;
    public static LEAF LF_PAD11;
    public static LEAF LF_PAD12;
    public static LEAF LF_PAD13;
    public static LEAF LF_PAD14;
    public static LEAF LF_PAD15;
}
internal class Microsoft.Cci.Pdb.LeafAlias : ValueType {
    internal UInt32 utype;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafArgList : ValueType {
    internal UInt32 count;
    internal UInt32[] arg;
}
internal class Microsoft.Cci.Pdb.LeafArray : ValueType {
    internal UInt32 elemtype;
    internal UInt32 idxtype;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafBArray : ValueType {
    internal UInt32 utype;
}
internal class Microsoft.Cci.Pdb.LeafBClass : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal Byte[] offset;
}
internal class Microsoft.Cci.Pdb.LeafBitfield : ValueType {
    internal UInt32 type;
    internal byte length;
    internal byte position;
}
internal class Microsoft.Cci.Pdb.LeafChar : ValueType {
    internal sbyte val;
}
internal class Microsoft.Cci.Pdb.LeafClass : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 field;
    internal UInt32 derived;
    internal UInt32 vshape;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafCmplx128 : ValueType {
    internal ulong val0_real;
    internal ulong val1_real;
    internal ulong val0_imag;
    internal ulong val1_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx32 : ValueType {
    internal float val_real;
    internal float val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx64 : ValueType {
    internal double val_real;
    internal double val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx80 : ValueType {
    internal FLOAT10 val_real;
    internal FLOAT10 val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCobol0 : ValueType {
    internal UInt32 type;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafCobol1 : ValueType {
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafDefArg : ValueType {
    internal UInt32 type;
    internal Byte[] expr;
}
internal class Microsoft.Cci.Pdb.LeafDerived : ValueType {
    internal UInt32 count;
    internal UInt32[] drvdcls;
}
internal class Microsoft.Cci.Pdb.LeafDimArray : ValueType {
    internal UInt32 utype;
    internal UInt32 diminfo;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafDimCon : ValueType {
    internal UInt32 typ;
    internal ushort rank;
    internal Byte[] dim;
}
internal class Microsoft.Cci.Pdb.LeafDimVar : ValueType {
    internal UInt32 rank;
    internal UInt32 typ;
    internal UInt32[] dim;
}
internal class Microsoft.Cci.Pdb.LeafEndPreComp : ValueType {
    internal UInt32 signature;
}
internal class Microsoft.Cci.Pdb.LeafEnum : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 utype;
    internal UInt32 field;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafEnumerate : ValueType {
    internal ushort attr;
    internal Byte[] value;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafFieldList : ValueType {
    internal Char[] data;
}
internal class Microsoft.Cci.Pdb.LeafFriendCls : ValueType {
    internal ushort pad0;
    internal UInt32 index;
}
internal class Microsoft.Cci.Pdb.LeafFriendFcn : ValueType {
    internal ushort pad0;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafIndex : ValueType {
    internal ushort pad0;
    internal UInt32 index;
}
internal class Microsoft.Cci.Pdb.LeafLabel : ValueType {
    internal ushort mode;
}
internal class Microsoft.Cci.Pdb.LeafList : ValueType {
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafLong : ValueType {
    internal int val;
}
internal class Microsoft.Cci.Pdb.LeafManaged : ValueType {
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMember : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal Byte[] offset;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMemberModify : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMethod : ValueType {
    internal ushort count;
    internal UInt32 mList;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMethodList : ValueType {
    internal Byte[] mList;
}
internal class Microsoft.Cci.Pdb.LeafMFunc : ValueType {
    internal UInt32 rvtype;
    internal UInt32 classtype;
    internal UInt32 thistype;
    internal byte calltype;
    internal byte reserved;
    internal ushort parmcount;
    internal UInt32 arglist;
    internal int thisadjust;
}
internal class Microsoft.Cci.Pdb.LeafModifier : ValueType {
    internal UInt32 type;
    internal CV_modifier attr;
}
internal class Microsoft.Cci.Pdb.LeafNestType : ValueType {
    internal ushort pad0;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafNestTypeEx : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafOct : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafOEM : ValueType {
    internal ushort cvOEM;
    internal ushort recOEM;
    internal UInt32 count;
    internal UInt32[] index;
}
internal class Microsoft.Cci.Pdb.LeafOEM2 : ValueType {
    internal Guid idOem;
    internal UInt32 count;
    internal UInt32[] index;
}
internal class Microsoft.Cci.Pdb.LeafOneMethod : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal UInt32[] vbaseoff;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafPad : ValueType {
    internal byte leaf;
}
internal class Microsoft.Cci.Pdb.LeafPointer : ValueType {
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.LeafPointerAttr : Enum {
    public UInt32 value__;
    public static LeafPointerAttr ptrtype;
    public static LeafPointerAttr ptrmode;
    public static LeafPointerAttr isflat32;
    public static LeafPointerAttr isvolatile;
    public static LeafPointerAttr isconst;
    public static LeafPointerAttr isunaligned;
    public static LeafPointerAttr isrestrict;
}
internal class Microsoft.Cci.Pdb.LeafPreComp : ValueType {
    internal UInt32 start;
    internal UInt32 count;
    internal UInt32 signature;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafProc : ValueType {
    internal UInt32 rvtype;
    internal byte calltype;
    internal byte reserved;
    internal ushort parmcount;
    internal UInt32 arglist;
}
internal class Microsoft.Cci.Pdb.LeafQuad : ValueType {
    internal long val;
}
internal class Microsoft.Cci.Pdb.LeafReal128 : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafReal32 : ValueType {
    internal float val;
}
internal class Microsoft.Cci.Pdb.LeafReal64 : ValueType {
    internal double val;
}
internal class Microsoft.Cci.Pdb.LeafReal80 : ValueType {
    internal FLOAT10 val;
}
internal class Microsoft.Cci.Pdb.LeafRefSym : ValueType {
    internal Byte[] Sym;
}
internal class Microsoft.Cci.Pdb.LeafShort : ValueType {
    internal short val;
}
internal class Microsoft.Cci.Pdb.LeafSkip : ValueType {
    internal UInt32 type;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafSTMember : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafTypeServer : ValueType {
    internal UInt32 signature;
    internal UInt32 age;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafTypeServer2 : ValueType {
    internal Guid sig70;
    internal UInt32 age;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafULong : ValueType {
    internal UInt32 val;
}
internal class Microsoft.Cci.Pdb.LeafUnion : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 field;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafUOct : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafUQuad : ValueType {
    internal ulong val;
}
internal class Microsoft.Cci.Pdb.LeafUShort : ValueType {
    internal ushort val;
}
internal class Microsoft.Cci.Pdb.LeafVarString : ValueType {
    internal ushort len;
    internal Byte[] value;
}
internal class Microsoft.Cci.Pdb.LeafVBClass : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal UInt32 vbptr;
    internal Byte[] vbpoff;
}
internal class Microsoft.Cci.Pdb.LeafVFTPath : ValueType {
    internal UInt32 count;
    internal UInt32[] bases;
}
internal class Microsoft.Cci.Pdb.LeafVFuncOff : ValueType {
    internal ushort pad0;
    internal UInt32 type;
    internal int offset;
}
internal class Microsoft.Cci.Pdb.LeafVFuncTab : ValueType {
    internal ushort pad0;
    internal UInt32 type;
}
internal class Microsoft.Cci.Pdb.LeafVTShape : ValueType {
    internal ushort count;
    internal Byte[] desc;
}
internal class Microsoft.Cci.Pdb.LocalSym : ValueType {
    internal UInt32 id;
    internal UInt32 typind;
    internal ushort flags;
    internal UInt32 idParent;
    internal UInt32 offParent;
    internal UInt32 expr;
    internal UInt32 pad0;
    internal UInt32 pad1;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManProcSym : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 token;
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal ushort retReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManProcSymMips : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 regSave;
    internal UInt32 fpSave;
    internal UInt32 intOff;
    internal UInt32 fpOff;
    internal UInt32 token;
    internal UInt32 off;
    internal ushort seg;
    internal byte retReg;
    internal byte frameReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyRegSym : ValueType {
    internal UInt32 typind;
    internal byte count;
    internal Byte[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyRegSym2 : ValueType {
    internal UInt32 typind;
    internal ushort count;
    internal UInt16[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyTypRef : ValueType {
    internal UInt32 typind;
}
internal class Microsoft.Cci.Pdb.mlMethod : ValueType {
    internal ushort attr;
    internal ushort pad0;
    internal UInt32 index;
    internal UInt32[] vbaseoff;
}
internal class Microsoft.Cci.Pdb.MsfDirectory : object {
    internal DataStream[] streams;
    internal MsfDirectory(PdbReader reader, PdbFileHeader head, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.ObjNameSym : ValueType {
    internal UInt32 signature;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.OEM_ID : Enum {
    public int value__;
    public static OEM_ID OEM_MS_FORTRAN90;
    public static OEM_ID OEM_ODI;
    public static OEM_ID OEM_THOMSON_SOFTWARE;
    public static OEM_ID OEM_ODI_REC_BASELIST;
}
internal class Microsoft.Cci.Pdb.OemSymbol : ValueType {
    internal Guid idOem;
    internal UInt32 typind;
    internal Byte[] rgl;
}
internal class Microsoft.Cci.Pdb.PdbConstant : object {
    internal string name;
    internal UInt32 token;
    internal object value;
    internal PdbConstant(string name, UInt32 token, object value);
    internal PdbConstant(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbDebugException : IOException {
    internal PdbDebugException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbException : IOException {
    internal PdbException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbFile : object {
    private static Guid BasicLanguageGuid;
    public static Guid SymDocumentType_Text;
    private static PdbFile();
    private static void LoadInjectedSourceInformation(BitAccess bits, Guid& doctype, Guid& language, Guid& vendor, Guid& checksumAlgo, Byte[]& checksum);
    private static Dictionary`2<string, int> LoadNameIndex(BitAccess bits, Int32& age, Guid& guid);
    private static IntHashTable LoadNameStream(BitAccess bits);
    private static int FindFunction(PdbFunction[] funcs, ushort sec, UInt32 off);
    private static void LoadManagedLines(PdbFunction[] funcs, IntHashTable names, BitAccess bits, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, UInt32 limit, Dictionary`2<string, PdbSource> sourceCache);
    private static void LoadFuncsFromDbiModule(BitAccess bits, DbiModuleInfo info, IntHashTable names, List`1<PdbFunction> funcList, bool readStrings, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<string, PdbSource> sourceCache);
    private static void LoadDbiStream(BitAccess bits, DbiModuleInfo[]& modules, DbiDbgHdr& header, bool readStrings);
    internal static PdbInfo LoadFunctions(Stream read);
    private static void LoadTokenToSourceInfo(BitAccess bits, DbiModuleInfo module, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<UInt32, PdbTokenLine> tokenToSourceMapping, Dictionary`2<string, PdbSource> sourceCache);
    private static IntHashTable ReadSourceFileInfo(BitAccess bits, UInt32 limit, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<string, PdbSource> sourceCache);
}
internal class Microsoft.Cci.Pdb.PdbFileHeader : object {
    private Byte[] windowsPdbMagic;
    internal Byte[] magic;
    internal int pageSize;
    internal int freePageMap;
    internal int pagesUsed;
    internal int directorySize;
    internal int zero;
    internal Int32[] directoryRoot;
    internal PdbFileHeader(Stream reader, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbFunction : object {
    internal static Guid msilMetaData;
    internal static IComparer byAddress;
    internal static IComparer byAddressAndToken;
    internal UInt32 token;
    internal UInt32 slotToken;
    internal UInt32 tokenOfMethodWhoseUsingInfoAppliesToThisMethod;
    internal UInt32 segment;
    internal UInt32 address;
    internal UInt32 length;
    internal PdbScope[] scopes;
    internal PdbSlot[] slots;
    internal PdbConstant[] constants;
    internal String[] usedNamespaces;
    internal PdbLines[] lines;
    internal UInt16[] usingCounts;
    internal IEnumerable`1<INamespaceScope> namespaceScopes;
    internal string iteratorClass;
    internal List`1<ILocalScope> iteratorScopes;
    internal PdbSynchronizationInformation synchronizationInformation;
    private bool visualBasicScopesAdjusted;
    internal PdbFunction(ManProcSym proc, BitAccess bits);
    private static PdbFunction();
    private static string StripNamespace(string module);
    internal void AdjustVisualBasicScopes();
    private void AdjustVisualBasicScopes(PdbScope[] scopes);
    internal static PdbFunction[] LoadManagedFunctions(BitAccess bits, UInt32 limit, bool readStrings);
    internal static void CountScopesAndSlots(BitAccess bits, UInt32 limit, Int32& constants, Int32& scopes, Int32& slots, Int32& usedNamespaces);
    internal void ReadMD2CustomMetadata(BitAccess bits);
    private void ReadCustomMetadata(BitAccess bits);
    private void ReadForwardIterator(BitAccess bits);
    private void ReadIteratorLocals(BitAccess bits);
    private void ReadForwardInfo(BitAccess bits);
    private void ReadUsingInfo(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbInfo : object {
    public PdbFunction[] Functions;
    public Dictionary`2<UInt32, PdbTokenLine> TokenToSourceMapping;
    public string SourceServerData;
    public int Age;
    public Guid Guid;
    public Byte[] SourceLinkData;
}
internal class Microsoft.Cci.Pdb.PdbIteratorScope : object {
    private UInt32 offset;
    private UInt32 length;
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    internal PdbIteratorScope(UInt32 offset, UInt32 length);
    public sealed virtual UInt32 get_Offset();
    public sealed virtual UInt32 get_Length();
}
internal class Microsoft.Cci.Pdb.PdbLine : ValueType {
    internal UInt32 offset;
    internal UInt32 lineBegin;
    internal UInt32 lineEnd;
    internal ushort colBegin;
    internal ushort colEnd;
    internal PdbLine(UInt32 offset, UInt32 lineBegin, ushort colBegin, UInt32 lineEnd, ushort colEnd);
}
internal class Microsoft.Cci.Pdb.PdbLines : object {
    internal PdbSource file;
    internal PdbLine[] lines;
    internal PdbLines(PdbSource file, UInt32 count);
}
internal class Microsoft.Cci.Pdb.PdbReader : object {
    internal int pageSize;
    internal Stream reader;
    internal PdbReader(Stream reader, int pageSize);
    internal void Seek(int page, int offset);
    internal void Read(Byte[] bytes, int offset, int count);
    internal int PagesFromSize(int size);
}
internal class Microsoft.Cci.Pdb.PdbScope : object {
    internal PdbConstant[] constants;
    internal PdbSlot[] slots;
    internal PdbScope[] scopes;
    internal String[] usedNamespaces;
    internal UInt32 address;
    internal UInt32 offset;
    internal UInt32 length;
    internal PdbScope(UInt32 address, UInt32 offset, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces);
    internal PdbScope(UInt32 address, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces);
    internal PdbScope(UInt32 funcOffset, BlockSym32 block, BitAccess bits, UInt32& typind);
}
internal class Microsoft.Cci.Pdb.PdbSlot : object {
    internal UInt32 slot;
    internal UInt32 typeToken;
    internal string name;
    internal ushort flags;
    internal PdbSlot(UInt32 slot, UInt32 typeToken, string name, ushort flags);
    internal PdbSlot(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbSource : object {
    internal string name;
    internal Guid doctype;
    internal Guid language;
    internal Guid vendor;
    internal Guid checksumAlgorithm;
    internal Byte[] checksum;
    internal PdbSource(string name, Guid doctype, Guid language, Guid vendor, Guid checksumAlgorithm, Byte[] checksum);
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationInformation : object {
    internal UInt32 kickoffMethodToken;
    internal UInt32 generatedCatchHandlerIlOffset;
    internal PdbSynchronizationPoint[] synchronizationPoints;
    public UInt32 GeneratedCatchHandlerOffset { get; }
    internal PdbSynchronizationInformation(BitAccess bits);
    public UInt32 get_GeneratedCatchHandlerOffset();
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationPoint : object {
    internal UInt32 synchronizeOffset;
    internal UInt32 continuationMethodToken;
    internal UInt32 continuationOffset;
    public UInt32 SynchronizeOffset { get; }
    public UInt32 ContinuationOffset { get; }
    internal PdbSynchronizationPoint(BitAccess bits);
    public UInt32 get_SynchronizeOffset();
    public UInt32 get_ContinuationOffset();
}
internal class Microsoft.Cci.Pdb.PdbTokenLine : object {
    internal UInt32 token;
    internal UInt32 file_id;
    internal UInt32 line;
    internal UInt32 column;
    internal UInt32 endLine;
    internal UInt32 endColumn;
    internal PdbSource sourceFile;
    internal PdbTokenLine nextLine;
    internal PdbTokenLine(UInt32 token, UInt32 file_id, UInt32 line, UInt32 column, UInt32 endLine, UInt32 endColumn);
}
internal class Microsoft.Cci.Pdb.ProcSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ProcSymIa64 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal ushort retReg;
    internal byte flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ProcSymMips : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 regSave;
    internal UInt32 fpSave;
    internal UInt32 intOff;
    internal UInt32 fpOff;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal byte retReg;
    internal byte frameReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.PubSym32 : ValueType {
    internal UInt32 flags;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RefSym : ValueType {
    internal UInt32 sumName;
    internal UInt32 ibSym;
    internal ushort imod;
    internal ushort usFill;
}
internal class Microsoft.Cci.Pdb.RefSym2 : ValueType {
    internal UInt32 sumName;
    internal UInt32 ibSym;
    internal ushort imod;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RegRel32 : ValueType {
    internal UInt32 off;
    internal UInt32 typind;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RegSym : ValueType {
    internal UInt32 typind;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ReturnSym : ValueType {
    internal CV_GENERIC_FLAG flags;
    internal byte style;
}
internal class Microsoft.Cci.Pdb.SearchSym : ValueType {
    internal UInt32 startsym;
    internal ushort seg;
}
internal class Microsoft.Cci.Pdb.SectionSym : ValueType {
    internal ushort isec;
    internal byte align;
    internal byte bReserved;
    internal UInt32 rva;
    internal UInt32 cb;
    internal UInt32 characteristics;
    internal string name;
}
internal class Microsoft.Cci.Pdb.SepCodSym : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 length;
    internal UInt32 scf;
    internal UInt32 off;
    internal UInt32 offParent;
    internal ushort sec;
    internal ushort secParent;
}
internal class Microsoft.Cci.Pdb.Slink32 : ValueType {
    internal UInt32 framesize;
    internal int off;
    internal ushort reg;
}
internal class Microsoft.Cci.Pdb.SlotSym32 : ValueType {
    internal UInt32 index;
    internal UInt32 typind;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.SYM : Enum {
    public int value__;
    public static SYM S_END;
    public static SYM S_OEM;
    public static SYM S_REGISTER_ST;
    public static SYM S_CONSTANT_ST;
    public static SYM S_UDT_ST;
    public static SYM S_COBOLUDT_ST;
    public static SYM S_MANYREG_ST;
    public static SYM S_BPREL32_ST;
    public static SYM S_LDATA32_ST;
    public static SYM S_GDATA32_ST;
    public static SYM S_PUB32_ST;
    public static SYM S_LPROC32_ST;
    public static SYM S_GPROC32_ST;
    public static SYM S_VFTABLE32;
    public static SYM S_REGREL32_ST;
    public static SYM S_LTHREAD32_ST;
    public static SYM S_GTHREAD32_ST;
    public static SYM S_LPROCMIPS_ST;
    public static SYM S_GPROCMIPS_ST;
    public static SYM S_FRAMEPROC;
    public static SYM S_COMPILE2_ST;
    public static SYM S_MANYREG2_ST;
    public static SYM S_LPROCIA64_ST;
    public static SYM S_GPROCIA64_ST;
    public static SYM S_LOCALSLOT_ST;
    public static SYM S_PARAMSLOT_ST;
    public static SYM S_ANNOTATION;
    public static SYM S_GMANPROC_ST;
    public static SYM S_LMANPROC_ST;
    public static SYM S_RESERVED1;
    public static SYM S_RESERVED2;
    public static SYM S_RESERVED3;
    public static SYM S_RESERVED4;
    public static SYM S_LMANDATA_ST;
    public static SYM S_GMANDATA_ST;
    public static SYM S_MANFRAMEREL_ST;
    public static SYM S_MANREGISTER_ST;
    public static SYM S_MANSLOT_ST;
    public static SYM S_MANMANYREG_ST;
    public static SYM S_MANREGREL_ST;
    public static SYM S_MANMANYREG2_ST;
    public static SYM S_MANTYPREF;
    public static SYM S_UNAMESPACE_ST;
    public static SYM S_ST_MAX;
    public static SYM S_OBJNAME;
    public static SYM S_THUNK32;
    public static SYM S_BLOCK32;
    public static SYM S_WITH32;
    public static SYM S_LABEL32;
    public static SYM S_REGISTER;
    public static SYM S_CONSTANT;
    public static SYM S_UDT;
    public static SYM S_COBOLUDT;
    public static SYM S_MANYREG;
    public static SYM S_BPREL32;
    public static SYM S_LDATA32;
    public static SYM S_GDATA32;
    public static SYM S_PUB32;
    public static SYM S_LPROC32;
    public static SYM S_GPROC32;
    public static SYM S_REGREL32;
    public static SYM S_LTHREAD32;
    public static SYM S_GTHREAD32;
    public static SYM S_LPROCMIPS;
    public static SYM S_GPROCMIPS;
    public static SYM S_COMPILE2;
    public static SYM S_MANYREG2;
    public static SYM S_LPROCIA64;
    public static SYM S_GPROCIA64;
    public static SYM S_LOCALSLOT;
    public static SYM S_SLOT;
    public static SYM S_PARAMSLOT;
    public static SYM S_LMANDATA;
    public static SYM S_GMANDATA;
    public static SYM S_MANFRAMEREL;
    public static SYM S_MANREGISTER;
    public static SYM S_MANSLOT;
    public static SYM S_MANMANYREG;
    public static SYM S_MANREGREL;
    public static SYM S_MANMANYREG2;
    public static SYM S_UNAMESPACE;
    public static SYM S_PROCREF;
    public static SYM S_DATAREF;
    public static SYM S_LPROCREF;
    public static SYM S_ANNOTATIONREF;
    public static SYM S_TOKENREF;
    public static SYM S_GMANPROC;
    public static SYM S_LMANPROC;
    public static SYM S_TRAMPOLINE;
    public static SYM S_MANCONSTANT;
    public static SYM S_ATTR_FRAMEREL;
    public static SYM S_ATTR_REGISTER;
    public static SYM S_ATTR_REGREL;
    public static SYM S_ATTR_MANYREG;
    public static SYM S_SEPCODE;
    public static SYM S_LOCAL;
    public static SYM S_DEFRANGE;
    public static SYM S_DEFRANGE2;
    public static SYM S_SECTION;
    public static SYM S_COFFGROUP;
    public static SYM S_EXPORT;
    public static SYM S_CALLSITEINFO;
    public static SYM S_FRAMECOOKIE;
    public static SYM S_DISCARDED;
    public static SYM S_RECTYPE_MAX;
    public static SYM S_RECTYPE_LAST;
}
internal class Microsoft.Cci.Pdb.SYMTYPE : ValueType {
    internal ushort reclen;
    internal ushort rectyp;
}
internal class Microsoft.Cci.Pdb.ThreadSym32 : ValueType {
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ThunkSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 off;
    internal ushort seg;
    internal ushort len;
    internal byte ord;
    internal string name;
    internal Byte[] variant;
}
internal enum Microsoft.Cci.Pdb.TRAMP : Enum {
    public int value__;
    public static TRAMP trampIncremental;
    public static TRAMP trampBranchIsland;
}
internal class Microsoft.Cci.Pdb.TrampolineSym : ValueType {
    internal ushort trampType;
    internal ushort cbThunk;
    internal UInt32 offThunk;
    internal UInt32 offTarget;
    internal ushort sectThunk;
    internal ushort sectTarget;
}
internal enum Microsoft.Cci.Pdb.TYPE_ENUM : Enum {
    public int value__;
    public static TYPE_ENUM T_NOTYPE;
    public static TYPE_ENUM T_ABS;
    public static TYPE_ENUM T_SEGMENT;
    public static TYPE_ENUM T_VOID;
    public static TYPE_ENUM T_HRESULT;
    public static TYPE_ENUM T_32PHRESULT;
    public static TYPE_ENUM T_64PHRESULT;
    public static TYPE_ENUM T_PVOID;
    public static TYPE_ENUM T_PFVOID;
    public static TYPE_ENUM T_PHVOID;
    public static TYPE_ENUM T_32PVOID;
    public static TYPE_ENUM T_64PVOID;
    public static TYPE_ENUM T_CURRENCY;
    public static TYPE_ENUM T_NOTTRANS;
    public static TYPE_ENUM T_BIT;
    public static TYPE_ENUM T_PASCHAR;
    public static TYPE_ENUM T_CHAR;
    public static TYPE_ENUM T_32PCHAR;
    public static TYPE_ENUM T_64PCHAR;
    public static TYPE_ENUM T_UCHAR;
    public static TYPE_ENUM T_32PUCHAR;
    public static TYPE_ENUM T_64PUCHAR;
    public static TYPE_ENUM T_RCHAR;
    public static TYPE_ENUM T_32PRCHAR;
    public static TYPE_ENUM T_64PRCHAR;
    public static TYPE_ENUM T_WCHAR;
    public static TYPE_ENUM T_32PWCHAR;
    public static TYPE_ENUM T_64PWCHAR;
    public static TYPE_ENUM T_INT1;
    public static TYPE_ENUM T_32PINT1;
    public static TYPE_ENUM T_64PINT1;
    public static TYPE_ENUM T_UINT1;
    public static TYPE_ENUM T_32PUINT1;
    public static TYPE_ENUM T_64PUINT1;
    public static TYPE_ENUM T_SHORT;
    public static TYPE_ENUM T_32PSHORT;
    public static TYPE_ENUM T_64PSHORT;
    public static TYPE_ENUM T_USHORT;
    public static TYPE_ENUM T_32PUSHORT;
    public static TYPE_ENUM T_64PUSHORT;
    public static TYPE_ENUM T_INT2;
    public static TYPE_ENUM T_32PINT2;
    public static TYPE_ENUM T_64PINT2;
    public static TYPE_ENUM T_UINT2;
    public static TYPE_ENUM T_32PUINT2;
    public static TYPE_ENUM T_64PUINT2;
    public static TYPE_ENUM T_LONG;
    public static TYPE_ENUM T_ULONG;
    public static TYPE_ENUM T_32PLONG;
    public static TYPE_ENUM T_32PULONG;
    public static TYPE_ENUM T_64PLONG;
    public static TYPE_ENUM T_64PULONG;
    public static TYPE_ENUM T_INT4;
    public static TYPE_ENUM T_32PINT4;
    public static TYPE_ENUM T_64PINT4;
    public static TYPE_ENUM T_UINT4;
    public static TYPE_ENUM T_32PUINT4;
    public static TYPE_ENUM T_64PUINT4;
    public static TYPE_ENUM T_QUAD;
    public static TYPE_ENUM T_32PQUAD;
    public static TYPE_ENUM T_64PQUAD;
    public static TYPE_ENUM T_UQUAD;
    public static TYPE_ENUM T_32PUQUAD;
    public static TYPE_ENUM T_64PUQUAD;
    public static TYPE_ENUM T_INT8;
    public static TYPE_ENUM T_32PINT8;
    public static TYPE_ENUM T_64PINT8;
    public static TYPE_ENUM T_UINT8;
    public static TYPE_ENUM T_32PUINT8;
    public static TYPE_ENUM T_64PUINT8;
    public static TYPE_ENUM T_OCT;
    public static TYPE_ENUM T_32POCT;
    public static TYPE_ENUM T_64POCT;
    public static TYPE_ENUM T_UOCT;
    public static TYPE_ENUM T_32PUOCT;
    public static TYPE_ENUM T_64PUOCT;
    public static TYPE_ENUM T_INT16;
    public static TYPE_ENUM T_32PINT16;
    public static TYPE_ENUM T_64PINT16;
    public static TYPE_ENUM T_UINT16;
    public static TYPE_ENUM T_32PUINT16;
    public static TYPE_ENUM T_64PUINT16;
    public static TYPE_ENUM T_REAL32;
    public static TYPE_ENUM T_32PREAL32;
    public static TYPE_ENUM T_64PREAL32;
    public static TYPE_ENUM T_REAL64;
    public static TYPE_ENUM T_32PREAL64;
    public static TYPE_ENUM T_64PREAL64;
    public static TYPE_ENUM T_REAL80;
    public static TYPE_ENUM T_32PREAL80;
    public static TYPE_ENUM T_64PREAL80;
    public static TYPE_ENUM T_REAL128;
    public static TYPE_ENUM T_32PREAL128;
    public static TYPE_ENUM T_64PREAL128;
    public static TYPE_ENUM T_CPLX32;
    public static TYPE_ENUM T_32PCPLX32;
    public static TYPE_ENUM T_64PCPLX32;
    public static TYPE_ENUM T_CPLX64;
    public static TYPE_ENUM T_32PCPLX64;
    public static TYPE_ENUM T_64PCPLX64;
    public static TYPE_ENUM T_CPLX80;
    public static TYPE_ENUM T_32PCPLX80;
    public static TYPE_ENUM T_64PCPLX80;
    public static TYPE_ENUM T_CPLX128;
    public static TYPE_ENUM T_32PCPLX128;
    public static TYPE_ENUM T_64PCPLX128;
    public static TYPE_ENUM T_BOOL08;
    public static TYPE_ENUM T_32PBOOL08;
    public static TYPE_ENUM T_64PBOOL08;
    public static TYPE_ENUM T_BOOL16;
    public static TYPE_ENUM T_32PBOOL16;
    public static TYPE_ENUM T_64PBOOL16;
    public static TYPE_ENUM T_BOOL32;
    public static TYPE_ENUM T_32PBOOL32;
    public static TYPE_ENUM T_64PBOOL32;
    public static TYPE_ENUM T_BOOL64;
    public static TYPE_ENUM T_32PBOOL64;
    public static TYPE_ENUM T_64PBOOL64;
}
internal class Microsoft.Cci.Pdb.TYPTYPE : ValueType {
    internal ushort len;
    internal ushort leaf;
}
internal class Microsoft.Cci.Pdb.UdtSym : ValueType {
    internal UInt32 typind;
    internal string name;
}
internal class Microsoft.Cci.Pdb.UnamespaceSym : ValueType {
    internal string name;
}
internal class Microsoft.Cci.Pdb.VpathSym32 : ValueType {
    internal UInt32 root;
    internal UInt32 path;
    internal UInt32 off;
    internal ushort seg;
}
internal class Microsoft.Cci.Pdb.WithSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 len;
    internal UInt32 off;
    internal ushort seg;
    internal string expr;
}
internal class Microsoft.Cci.Pdb.XFixupData : ValueType {
    internal ushort wType;
    internal ushort wExtra;
    internal UInt32 rva;
    internal UInt32 rvaTarget;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Mono.ArgumentNullOrEmptyException : ArgumentException {
    public ArgumentNullOrEmptyException(string paramName);
}
internal class Mono.Cecil.ArrayDimension : ValueType {
    private Nullable`1<int> lower_bound;
    private Nullable`1<int> upper_bound;
    public Nullable`1<int> LowerBound { get; public set; }
    public Nullable`1<int> UpperBound { get; public set; }
    public bool IsSized { get; }
    public ArrayDimension(Nullable`1<int> lowerBound, Nullable`1<int> upperBound);
    public Nullable`1<int> get_LowerBound();
    public void set_LowerBound(Nullable`1<int> value);
    public Nullable`1<int> get_UpperBound();
    public void set_UpperBound(Nullable`1<int> value);
    public bool get_IsSized();
    public virtual string ToString();
}
internal class Mono.Cecil.ArrayMarshalInfo : MarshalInfo {
    internal NativeType element_type;
    internal int size_parameter_index;
    internal int size;
    internal int size_parameter_multiplier;
    public NativeType ElementType { get; public set; }
    public int SizeParameterIndex { get; public set; }
    public int Size { get; public set; }
    public int SizeParameterMultiplier { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_SizeParameterIndex();
    public void set_SizeParameterIndex(int value);
    public int get_Size();
    public void set_Size(int value);
    public int get_SizeParameterMultiplier();
    public void set_SizeParameterMultiplier(int value);
}
internal class Mono.Cecil.ArrayType : TypeSpecification {
    private Collection`1<ArrayDimension> dimensions;
    public Collection`1<ArrayDimension> Dimensions { get; }
    public int Rank { get; }
    public bool IsVector { get; }
    public bool IsValueType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsArray { get; }
    public ArrayType(TypeReference type);
    public ArrayType(TypeReference type, int rank);
    public Collection`1<ArrayDimension> get_Dimensions();
    public int get_Rank();
    public bool get_IsVector();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsArray();
}
[FlagsAttribute]
public enum Mono.Cecil.AssemblyAttributes : Enum {
    public UInt32 value__;
    public static AssemblyAttributes PublicKey;
    public static AssemblyAttributes SideBySideCompatible;
    public static AssemblyAttributes Retargetable;
    public static AssemblyAttributes WindowsRuntime;
    public static AssemblyAttributes DisableJITCompileOptimizer;
    public static AssemblyAttributes EnableJITCompileTracking;
}
public class Mono.Cecil.AssemblyDefinition : object {
    private AssemblyNameDefinition name;
    internal ModuleDefinition main_module;
    private Collection`1<ModuleDefinition> modules;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    public AssemblyNameDefinition Name { get; public set; }
    public string FullName { get; }
    public MetadataToken MetadataToken { get; public set; }
    public Collection`1<ModuleDefinition> Modules { get; }
    public ModuleDefinition MainModule { get; }
    public MethodDefinition EntryPoint { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public AssemblyNameDefinition get_Name();
    public void set_Name(AssemblyNameDefinition value);
    public string get_FullName();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public Collection`1<ModuleDefinition> get_Modules();
    public ModuleDefinition get_MainModule();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual void Dispose();
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind);
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters);
    public static AssemblyDefinition ReadAssembly(string fileName);
    public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters);
    public static AssemblyDefinition ReadAssembly(Stream stream);
    public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters);
    private static AssemblyDefinition ReadAssembly(ModuleDefinition module);
    public void Write(string fileName);
    public void Write(string fileName, WriterParameters parameters);
    public void Write();
    public void Write(WriterParameters parameters);
    public void Write(Stream stream);
    public void Write(Stream stream, WriterParameters parameters);
    public virtual string ToString();
}
public enum Mono.Cecil.AssemblyHashAlgorithm : Enum {
    public UInt32 value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
    public static AssemblyHashAlgorithm Reserved;
}
internal class Mono.Cecil.AssemblyLinkedResource : Resource {
    private AssemblyNameReference reference;
    public AssemblyNameReference Assembly { get; public set; }
    public ResourceType ResourceType { get; }
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags);
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference);
    public AssemblyNameReference get_Assembly();
    public void set_Assembly(AssemblyNameReference value);
    public virtual ResourceType get_ResourceType();
}
public class Mono.Cecil.AssemblyNameDefinition : AssemblyNameReference {
    public Byte[] Hash { get; }
    public AssemblyNameDefinition(string name, Version version);
    public virtual Byte[] get_Hash();
}
public class Mono.Cecil.AssemblyNameReference : object {
    private string name;
    private string culture;
    private Version version;
    private UInt32 attributes;
    private Byte[] public_key;
    private Byte[] public_key_token;
    private AssemblyHashAlgorithm hash_algorithm;
    private Byte[] hash;
    internal MetadataToken token;
    private string full_name;
    public string Name { get; public set; }
    public string Culture { get; public set; }
    public Version Version { get; public set; }
    public AssemblyAttributes Attributes { get; public set; }
    public bool HasPublicKey { get; public set; }
    public bool IsSideBySideCompatible { get; public set; }
    public bool IsRetargetable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public Byte[] PublicKey { get; public set; }
    public Byte[] PublicKeyToken { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public string FullName { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] Hash { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public AssemblyNameReference(string name, Version version);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public string get_Culture();
    public void set_Culture(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyAttributes get_Attributes();
    public void set_Attributes(AssemblyAttributes value);
    public bool get_HasPublicKey();
    public void set_HasPublicKey(bool value);
    public bool get_IsSideBySideCompatible();
    public void set_IsSideBySideCompatible(bool value);
    public bool get_IsRetargetable();
    public void set_IsRetargetable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public Byte[] get_PublicKey();
    public void set_PublicKey(Byte[] value);
    public Byte[] get_PublicKeyToken();
    public void set_PublicKeyToken(Byte[] value);
    private Byte[] HashPublicKey();
    public virtual MetadataScopeType get_MetadataScopeType();
    public string get_FullName();
    public static AssemblyNameReference Parse(string fullName);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public virtual Byte[] get_Hash();
    public virtual void set_Hash(Byte[] value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.AssemblyRefTable : MetadataTable`1<Row`9<ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.AssemblyResolutionException : FileNotFoundException {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolutionException(AssemblyNameReference reference);
    public AssemblyResolutionException(AssemblyNameReference reference, Exception innerException);
    public AssemblyNameReference get_AssemblyReference();
}
internal class Mono.Cecil.AssemblyResolveEventArgs : EventArgs {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolveEventArgs(AssemblyNameReference reference);
    public AssemblyNameReference get_AssemblyReference();
}
internal class Mono.Cecil.AssemblyResolveEventHandler : MulticastDelegate {
    public AssemblyResolveEventHandler(object object, IntPtr method);
    public virtual AssemblyDefinition Invoke(object sender, AssemblyNameReference reference);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyNameReference reference, AsyncCallback callback, object object);
    public virtual AssemblyDefinition EndInvoke(IAsyncResult result);
}
internal class Mono.Cecil.AssemblyTable : OneRowTable`1<Row`9<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.BaseAssemblyResolver : object {
    private static bool on_mono;
    private Collection`1<string> directories;
    internal static Lazy`1<Dictionary`2<string, string>> TrustedPlatformAssemblies;
    [CompilerGeneratedAttribute]
private AssemblyResolveEventHandler ResolveFailure;
    private static BaseAssemblyResolver();
    public void AddSearchDirectory(string directory);
    public void RemoveSearchDirectory(string directory);
    public String[] GetSearchDirectories();
    [CompilerGeneratedAttribute]
public void add_ResolveFailure(AssemblyResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ResolveFailure(AssemblyResolveEventHandler value);
    private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    private AssemblyDefinition SearchTrustedPlatformAssemblies(AssemblyNameReference name, ReaderParameters parameters);
    private static Dictionary`2<string, string> CreateTrustedPlatformAssemblyMap();
    protected virtual AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable`1<string> directories, ReaderParameters parameters);
    private static bool IsZero(Version version);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Mono.Cecil.ByReferenceType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsByReference { get; }
    public ByReferenceType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsByReference();
}
public class Mono.Cecil.CallSite : object {
    private MethodReference signature;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; }
    public MetadataToken MetadataToken { get; public set; }
    public string FullName { get; }
    public CallSite(TypeReference returnType);
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ModuleDefinition get_Module();
    public IMetadataScope get_Scope();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public string get_FullName();
    public virtual string ToString();
}
internal class Mono.Cecil.Cil.AsyncMethodBodyDebugInformation : CustomDebugInformation {
    internal InstructionOffset catch_handler;
    internal Collection`1<InstructionOffset> yields;
    internal Collection`1<InstructionOffset> resumes;
    internal Collection`1<MethodDefinition> resume_methods;
    public static Guid KindIdentifier;
    public InstructionOffset CatchHandler { get; public set; }
    public Collection`1<InstructionOffset> Yields { get; }
    public Collection`1<InstructionOffset> Resumes { get; }
    public Collection`1<MethodDefinition> ResumeMethods { get; }
    public CustomDebugInformationKind Kind { get; }
    internal AsyncMethodBodyDebugInformation(int catchHandler);
    public AsyncMethodBodyDebugInformation(Instruction catchHandler);
    private static AsyncMethodBodyDebugInformation();
    public InstructionOffset get_CatchHandler();
    public void set_CatchHandler(InstructionOffset value);
    public Collection`1<InstructionOffset> get_Yields();
    public Collection`1<InstructionOffset> get_Resumes();
    public Collection`1<MethodDefinition> get_ResumeMethods();
    public virtual CustomDebugInformationKind get_Kind();
}
internal class Mono.Cecil.Cil.BinaryCustomDebugInformation : CustomDebugInformation {
    private Byte[] data;
    public Byte[] Data { get; public set; }
    public CustomDebugInformationKind Kind { get; }
    public BinaryCustomDebugInformation(Guid identifier, Byte[] data);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual CustomDebugInformationKind get_Kind();
}
public enum Mono.Cecil.Cil.Code : Enum {
    public int value__;
    public static Code Nop;
    public static Code Break;
    public static Code Ldarg_0;
    public static Code Ldarg_1;
    public static Code Ldarg_2;
    public static Code Ldarg_3;
    public static Code Ldloc_0;
    public static Code Ldloc_1;
    public static Code Ldloc_2;
    public static Code Ldloc_3;
    public static Code Stloc_0;
    public static Code Stloc_1;
    public static Code Stloc_2;
    public static Code Stloc_3;
    public static Code Ldarg_S;
    public static Code Ldarga_S;
    public static Code Starg_S;
    public static Code Ldloc_S;
    public static Code Ldloca_S;
    public static Code Stloc_S;
    public static Code Ldnull;
    public static Code Ldc_I4_M1;
    public static Code Ldc_I4_0;
    public static Code Ldc_I4_1;
    public static Code Ldc_I4_2;
    public static Code Ldc_I4_3;
    public static Code Ldc_I4_4;
    public static Code Ldc_I4_5;
    public static Code Ldc_I4_6;
    public static Code Ldc_I4_7;
    public static Code Ldc_I4_8;
    public static Code Ldc_I4_S;
    public static Code Ldc_I4;
    public static Code Ldc_I8;
    public static Code Ldc_R4;
    public static Code Ldc_R8;
    public static Code Dup;
    public static Code Pop;
    public static Code Jmp;
    public static Code Call;
    public static Code Calli;
    public static Code Ret;
    public static Code Br_S;
    public static Code Brfalse_S;
    public static Code Brtrue_S;
    public static Code Beq_S;
    public static Code Bge_S;
    public static Code Bgt_S;
    public static Code Ble_S;
    public static Code Blt_S;
    public static Code Bne_Un_S;
    public static Code Bge_Un_S;
    public static Code Bgt_Un_S;
    public static Code Ble_Un_S;
    public static Code Blt_Un_S;
    public static Code Br;
    public static Code Brfalse;
    public static Code Brtrue;
    public static Code Beq;
    public static Code Bge;
    public static Code Bgt;
    public static Code Ble;
    public static Code Blt;
    public static Code Bne_Un;
    public static Code Bge_Un;
    public static Code Bgt_Un;
    public static Code Ble_Un;
    public static Code Blt_Un;
    public static Code Switch;
    public static Code Ldind_I1;
    public static Code Ldind_U1;
    public static Code Ldind_I2;
    public static Code Ldind_U2;
    public static Code Ldind_I4;
    public static Code Ldind_U4;
    public static Code Ldind_I8;
    public static Code Ldind_I;
    public static Code Ldind_R4;
    public static Code Ldind_R8;
    public static Code Ldind_Ref;
    public static Code Stind_Ref;
    public static Code Stind_I1;
    public static Code Stind_I2;
    public static Code Stind_I4;
    public static Code Stind_I8;
    public static Code Stind_R4;
    public static Code Stind_R8;
    public static Code Add;
    public static Code Sub;
    public static Code Mul;
    public static Code Div;
    public static Code Div_Un;
    public static Code Rem;
    public static Code Rem_Un;
    public static Code And;
    public static Code Or;
    public static Code Xor;
    public static Code Shl;
    public static Code Shr;
    public static Code Shr_Un;
    public static Code Neg;
    public static Code Not;
    public static Code Conv_I1;
    public static Code Conv_I2;
    public static Code Conv_I4;
    public static Code Conv_I8;
    public static Code Conv_R4;
    public static Code Conv_R8;
    public static Code Conv_U4;
    public static Code Conv_U8;
    public static Code Callvirt;
    public static Code Cpobj;
    public static Code Ldobj;
    public static Code Ldstr;
    public static Code Newobj;
    public static Code Castclass;
    public static Code Isinst;
    public static Code Conv_R_Un;
    public static Code Unbox;
    public static Code Throw;
    public static Code Ldfld;
    public static Code Ldflda;
    public static Code Stfld;
    public static Code Ldsfld;
    public static Code Ldsflda;
    public static Code Stsfld;
    public static Code Stobj;
    public static Code Conv_Ovf_I1_Un;
    public static Code Conv_Ovf_I2_Un;
    public static Code Conv_Ovf_I4_Un;
    public static Code Conv_Ovf_I8_Un;
    public static Code Conv_Ovf_U1_Un;
    public static Code Conv_Ovf_U2_Un;
    public static Code Conv_Ovf_U4_Un;
    public static Code Conv_Ovf_U8_Un;
    public static Code Conv_Ovf_I_Un;
    public static Code Conv_Ovf_U_Un;
    public static Code Box;
    public static Code Newarr;
    public static Code Ldlen;
    public static Code Ldelema;
    public static Code Ldelem_I1;
    public static Code Ldelem_U1;
    public static Code Ldelem_I2;
    public static Code Ldelem_U2;
    public static Code Ldelem_I4;
    public static Code Ldelem_U4;
    public static Code Ldelem_I8;
    public static Code Ldelem_I;
    public static Code Ldelem_R4;
    public static Code Ldelem_R8;
    public static Code Ldelem_Ref;
    public static Code Stelem_I;
    public static Code Stelem_I1;
    public static Code Stelem_I2;
    public static Code Stelem_I4;
    public static Code Stelem_I8;
    public static Code Stelem_R4;
    public static Code Stelem_R8;
    public static Code Stelem_Ref;
    public static Code Ldelem_Any;
    public static Code Stelem_Any;
    public static Code Unbox_Any;
    public static Code Conv_Ovf_I1;
    public static Code Conv_Ovf_U1;
    public static Code Conv_Ovf_I2;
    public static Code Conv_Ovf_U2;
    public static Code Conv_Ovf_I4;
    public static Code Conv_Ovf_U4;
    public static Code Conv_Ovf_I8;
    public static Code Conv_Ovf_U8;
    public static Code Refanyval;
    public static Code Ckfinite;
    public static Code Mkrefany;
    public static Code Ldtoken;
    public static Code Conv_U2;
    public static Code Conv_U1;
    public static Code Conv_I;
    public static Code Conv_Ovf_I;
    public static Code Conv_Ovf_U;
    public static Code Add_Ovf;
    public static Code Add_Ovf_Un;
    public static Code Mul_Ovf;
    public static Code Mul_Ovf_Un;
    public static Code Sub_Ovf;
    public static Code Sub_Ovf_Un;
    public static Code Endfinally;
    public static Code Leave;
    public static Code Leave_S;
    public static Code Stind_I;
    public static Code Conv_U;
    public static Code Arglist;
    public static Code Ceq;
    public static Code Cgt;
    public static Code Cgt_Un;
    public static Code Clt;
    public static Code Clt_Un;
    public static Code Ldftn;
    public static Code Ldvirtftn;
    public static Code Ldarg;
    public static Code Ldarga;
    public static Code Starg;
    public static Code Ldloc;
    public static Code Ldloca;
    public static Code Stloc;
    public static Code Localloc;
    public static Code Endfilter;
    public static Code Unaligned;
    public static Code Volatile;
    public static Code Tail;
    public static Code Initobj;
    public static Code Constrained;
    public static Code Cpblk;
    public static Code Initblk;
    public static Code No;
    public static Code Rethrow;
    public static Code Sizeof;
    public static Code Refanytype;
    public static Code Readonly;
}
internal class Mono.Cecil.Cil.CodeReader : BinaryStreamReader {
    internal MetadataReader reader;
    private int start;
    private MethodDefinition method;
    private MethodBody body;
    private int Offset { get; }
    public CodeReader(MetadataReader reader);
    private int get_Offset();
    public int MoveTo(MethodDefinition method);
    public void MoveBackTo(int position);
    public MethodBody ReadMethodBody(MethodDefinition method);
    public int ReadCodeSize(MethodDefinition method);
    private int ReadCodeSize();
    private void ReadMethodBody();
    private void ReadFatMethod();
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token);
    private void ReadCode();
    private OpCode ReadOpCode();
    private object ReadOperand(Instruction instruction);
    public string GetString(MetadataToken token);
    public ParameterDefinition GetParameter(int index);
    public VariableDefinition GetVariable(int index);
    public CallSite GetCallSite(MetadataToken token);
    private void ResolveBranches(Collection`1<Instruction> instructions);
    private Instruction GetInstruction(int offset);
    private static Instruction GetInstruction(Collection`1<Instruction> instructions, int offset);
    private void ReadSection();
    private void ReadSmallSection();
    private void ReadFatSection();
    private void ReadExceptionHandlers(int count, Func`1<int> read_entry, Func`1<int> read_length);
    private void ReadExceptionHandlerSpecific(ExceptionHandler handler);
    public MetadataToken ReadToken();
    private void ReadDebugInfo();
    private void ReadCustomDebugInformations(MethodDefinition method);
    private void ReadAsyncMethodBody(AsyncMethodBodyDebugInformation async_method);
    private void ReadStateMachineScope(StateMachineScopeDebugInformation state_machine_scope);
    private void ReadSequencePoints();
    private void ReadScopes(Collection`1<ScopeDebugInformation> scopes);
    private void ReadScope(ScopeDebugInformation scope);
    public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, Int32& code_size, MetadataToken& local_var_token);
    private void PatchRawFatMethod(ByteBuffer buffer, CodeWriter writer, Int32& code_size, MetadataToken& local_var_token);
    private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer);
    private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry);
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__26_0();
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__26_1();
}
internal class Mono.Cecil.Cil.CodeWriter : ByteBuffer {
    private UInt32 code_base;
    internal MetadataBuilder metadata;
    private Dictionary`2<UInt32, MetadataToken> standalone_signatures;
    private Dictionary`2<ByteBuffer, UInt32> tiny_method_bodies;
    private MethodBody body;
    public CodeWriter(MetadataBuilder metadata);
    public UInt32 WriteMethodBody(MethodDefinition method);
    private static bool IsEmptyMethodBody(MethodBody body);
    private static bool IsUnresolved(MethodDefinition method);
    private UInt32 WriteUnresolvedMethodBody(MethodDefinition method);
    private UInt32 WriteResolvedMethodBody(MethodDefinition method);
    private bool GetOrMapTinyMethodBody(ByteBuffer body, UInt32& rva);
    private void WriteFatHeader();
    private void WriteInstructions();
    private void WriteOpCode(OpCode opcode);
    private void WriteOperand(Instruction instruction);
    private int GetTargetOffset(Instruction instruction);
    private UInt32 GetUserStringIndex(string string);
    private static int GetVariableIndex(VariableDefinition variable);
    private int GetParameterIndex(ParameterDefinition parameter);
    private bool RequiresFatHeader();
    private void ComputeHeader();
    private void ComputeExceptionHandlerStackSize(Dictionary`2& stack_sizes);
    private static void AddExceptionStackSize(Instruction handler_start, Dictionary`2& stack_sizes);
    private static void ComputeStackSize(Instruction instruction, Dictionary`2& stack_sizes, Int32& stack_size, Int32& max_stack);
    private static void CopyBranchStackSize(Instruction instruction, Dictionary`2& stack_sizes, int stack_size);
    private static void CopyBranchStackSize(Dictionary`2& stack_sizes, Instruction target, int stack_size);
    private static void ComputeStackSize(Instruction instruction, Int32& stack_size);
    private static void ComputeStackDelta(Instruction instruction, Int32& stack_size);
    private static void ComputePopDelta(StackBehaviour pop_behavior, Int32& stack_size);
    private static void ComputePushDelta(StackBehaviour push_behaviour, Int32& stack_size);
    private void WriteExceptionHandlers();
    private static bool RequiresFatSection(Collection`1<ExceptionHandler> handlers);
    private static bool IsFatRange(Instruction start, Instruction end);
    private void WriteSmallSection(Collection`1<ExceptionHandler> handlers);
    private void WriteFatSection(Collection`1<ExceptionHandler> handlers);
    private void WriteExceptionHandlers(Collection`1<ExceptionHandler> handlers, Action`1<int> write_entry, Action`1<int> write_length);
    private void WriteExceptionHandlerSpecific(ExceptionHandler handler);
    public MetadataToken GetStandAloneSignature(Collection`1<VariableDefinition> variables);
    public MetadataToken GetStandAloneSignature(CallSite call_site);
    private MetadataToken GetStandAloneSignatureToken(UInt32 signature);
    private UInt32 BeginMethod();
    private void WriteMetadataToken(MetadataToken token);
    private void Align(int align);
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_0(int i);
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_1(int i);
}
public class Mono.Cecil.Cil.ConstantDebugInformation : DebugInformation {
    private string name;
    private TypeReference constant_type;
    private object value;
    public string Name { get; public set; }
    public TypeReference ConstantType { get; public set; }
    public object Value { get; public set; }
    public ConstantDebugInformation(string name, TypeReference constant_type, object value);
    public string get_Name();
    public void set_Name(string value);
    public TypeReference get_ConstantType();
    public void set_ConstantType(TypeReference value);
    public object get_Value();
    public void set_Value(object value);
}
public abstract class Mono.Cecil.Cil.CustomDebugInformation : DebugInformation {
    private Guid identifier;
    public Guid Identifier { get; }
    public CustomDebugInformationKind Kind { get; }
    internal CustomDebugInformation(Guid identifier);
    public Guid get_Identifier();
    public abstract virtual CustomDebugInformationKind get_Kind();
}
public enum Mono.Cecil.Cil.CustomDebugInformationKind : Enum {
    public int value__;
    public static CustomDebugInformationKind Binary;
    public static CustomDebugInformationKind StateMachineScope;
    public static CustomDebugInformationKind DynamicVariable;
    public static CustomDebugInformationKind DefaultNamespace;
    public static CustomDebugInformationKind AsyncMethodBody;
    public static CustomDebugInformationKind EmbeddedSource;
    public static CustomDebugInformationKind SourceLink;
}
public abstract class Mono.Cecil.Cil.DebugInformation : object {
    internal MetadataToken token;
    internal Collection`1<CustomDebugInformation> custom_infos;
    public MetadataToken MetadataToken { get; public set; }
    public bool HasCustomDebugInformations { get; }
    public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
}
internal class Mono.Cecil.Cil.DefaultSymbolReaderProvider : object {
    private bool throw_if_no_symbol;
    public DefaultSymbolReaderProvider(bool throwIfNoSymbol);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Cil.DefaultSymbolWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
public class Mono.Cecil.Cil.Document : DebugInformation {
    private string url;
    private Guid type;
    private Guid hash_algorithm;
    private Guid language;
    private Guid language_vendor;
    private Byte[] hash;
    private Byte[] embedded_source;
    public string Url { get; public set; }
    public DocumentType Type { get; public set; }
    public Guid TypeGuid { get; public set; }
    public DocumentHashAlgorithm HashAlgorithm { get; public set; }
    public Guid HashAlgorithmGuid { get; public set; }
    public DocumentLanguage Language { get; public set; }
    public Guid LanguageGuid { get; public set; }
    public DocumentLanguageVendor LanguageVendor { get; public set; }
    public Guid LanguageVendorGuid { get; public set; }
    public Byte[] Hash { get; public set; }
    public Byte[] EmbeddedSource { get; public set; }
    public Document(string url);
    public string get_Url();
    public void set_Url(string value);
    public DocumentType get_Type();
    public void set_Type(DocumentType value);
    public Guid get_TypeGuid();
    public void set_TypeGuid(Guid value);
    public DocumentHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(DocumentHashAlgorithm value);
    public Guid get_HashAlgorithmGuid();
    public void set_HashAlgorithmGuid(Guid value);
    public DocumentLanguage get_Language();
    public void set_Language(DocumentLanguage value);
    public Guid get_LanguageGuid();
    public void set_LanguageGuid(Guid value);
    public DocumentLanguageVendor get_LanguageVendor();
    public void set_LanguageVendor(DocumentLanguageVendor value);
    public Guid get_LanguageVendorGuid();
    public void set_LanguageVendorGuid(Guid value);
    public Byte[] get_Hash();
    public void set_Hash(Byte[] value);
    public Byte[] get_EmbeddedSource();
    public void set_EmbeddedSource(Byte[] value);
}
public enum Mono.Cecil.Cil.DocumentHashAlgorithm : Enum {
    public int value__;
    public static DocumentHashAlgorithm None;
    public static DocumentHashAlgorithm MD5;
    public static DocumentHashAlgorithm SHA1;
    public static DocumentHashAlgorithm SHA256;
}
public enum Mono.Cecil.Cil.DocumentLanguage : Enum {
    public int value__;
    public static DocumentLanguage Other;
    public static DocumentLanguage C;
    public static DocumentLanguage Cpp;
    public static DocumentLanguage CSharp;
    public static DocumentLanguage Basic;
    public static DocumentLanguage Java;
    public static DocumentLanguage Cobol;
    public static DocumentLanguage Pascal;
    public static DocumentLanguage Cil;
    public static DocumentLanguage JScript;
    public static DocumentLanguage Smc;
    public static DocumentLanguage MCpp;
    public static DocumentLanguage FSharp;
}
public enum Mono.Cecil.Cil.DocumentLanguageVendor : Enum {
    public int value__;
    public static DocumentLanguageVendor Other;
    public static DocumentLanguageVendor Microsoft;
}
public enum Mono.Cecil.Cil.DocumentType : Enum {
    public int value__;
    public static DocumentType Other;
    public static DocumentType Text;
}
internal class Mono.Cecil.Cil.EmbeddedPortablePdbReader : object {
    private PortablePdbReader reader;
    internal EmbeddedPortablePdbReader(PortablePdbReader reader);
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Cil.EmbeddedPortablePdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    private static Stream GetPortablePdbStream(ImageDebugHeaderEntry entry);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Cil.EmbeddedPortablePdbWriter : object {
    private Stream stream;
    private PortablePdbWriter writer;
    internal EmbeddedPortablePdbWriter(Stream stream, PortablePdbWriter writer);
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    public sealed virtual void Write(MethodDebugInformation info);
    public sealed virtual ImageDebugHeader GetDebugHeader();
    public sealed virtual void Write();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Cil.EmbeddedPortablePdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Cil.EmbeddedSourceDebugInformation : CustomDebugInformation {
    internal UInt32 index;
    internal MetadataReader debug_reader;
    internal bool resolved;
    internal Byte[] content;
    internal bool compress;
    public static Guid KindIdentifier;
    public Byte[] Content { get; public set; }
    public bool Compress { get; public set; }
    public CustomDebugInformationKind Kind { get; }
    internal EmbeddedSourceDebugInformation(UInt32 index, MetadataReader debug_reader);
    public EmbeddedSourceDebugInformation(Byte[] content, bool compress);
    private static EmbeddedSourceDebugInformation();
    public Byte[] get_Content();
    public void set_Content(Byte[] value);
    public bool get_Compress();
    public void set_Compress(bool value);
    public virtual CustomDebugInformationKind get_Kind();
    internal Byte[] ReadRawEmbeddedSourceDebugInformation();
    private void Resolve();
}
public class Mono.Cecil.Cil.ExceptionHandler : object {
    private Instruction try_start;
    private Instruction try_end;
    private Instruction filter_start;
    private Instruction handler_start;
    private Instruction handler_end;
    private TypeReference catch_type;
    private ExceptionHandlerType handler_type;
    public Instruction TryStart { get; public set; }
    public Instruction TryEnd { get; public set; }
    public Instruction FilterStart { get; public set; }
    public Instruction HandlerStart { get; public set; }
    public Instruction HandlerEnd { get; public set; }
    public TypeReference CatchType { get; public set; }
    public ExceptionHandlerType HandlerType { get; public set; }
    public ExceptionHandler(ExceptionHandlerType handlerType);
    public Instruction get_TryStart();
    public void set_TryStart(Instruction value);
    public Instruction get_TryEnd();
    public void set_TryEnd(Instruction value);
    public Instruction get_FilterStart();
    public void set_FilterStart(Instruction value);
    public Instruction get_HandlerStart();
    public void set_HandlerStart(Instruction value);
    public Instruction get_HandlerEnd();
    public void set_HandlerEnd(Instruction value);
    public TypeReference get_CatchType();
    public void set_CatchType(TypeReference value);
    public ExceptionHandlerType get_HandlerType();
    public void set_HandlerType(ExceptionHandlerType value);
}
public enum Mono.Cecil.Cil.ExceptionHandlerType : Enum {
    public int value__;
    public static ExceptionHandlerType Catch;
    public static ExceptionHandlerType Filter;
    public static ExceptionHandlerType Finally;
    public static ExceptionHandlerType Fault;
}
public enum Mono.Cecil.Cil.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
internal interface Mono.Cecil.Cil.ICustomDebugInformationProvider {
    public bool HasCustomDebugInformations { get; }
    public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    public abstract virtual bool get_HasCustomDebugInformations();
    public abstract virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
}
public class Mono.Cecil.Cil.ILProcessor : object {
    private MethodBody body;
    private Collection`1<Instruction> instructions;
    public MethodBody Body { get; }
    internal ILProcessor(MethodBody body);
    public MethodBody get_Body();
    public Instruction Create(OpCode opcode);
    public Instruction Create(OpCode opcode, TypeReference type);
    public Instruction Create(OpCode opcode, CallSite site);
    public Instruction Create(OpCode opcode, MethodReference method);
    public Instruction Create(OpCode opcode, FieldReference field);
    public Instruction Create(OpCode opcode, string value);
    public Instruction Create(OpCode opcode, sbyte value);
    public Instruction Create(OpCode opcode, byte value);
    public Instruction Create(OpCode opcode, int value);
    public Instruction Create(OpCode opcode, long value);
    public Instruction Create(OpCode opcode, float value);
    public Instruction Create(OpCode opcode, double value);
    public Instruction Create(OpCode opcode, Instruction target);
    public Instruction Create(OpCode opcode, Instruction[] targets);
    public Instruction Create(OpCode opcode, VariableDefinition variable);
    public Instruction Create(OpCode opcode, ParameterDefinition parameter);
    public void Emit(OpCode opcode);
    public void Emit(OpCode opcode, TypeReference type);
    public void Emit(OpCode opcode, MethodReference method);
    public void Emit(OpCode opcode, CallSite site);
    public void Emit(OpCode opcode, FieldReference field);
    public void Emit(OpCode opcode, string value);
    public void Emit(OpCode opcode, byte value);
    public void Emit(OpCode opcode, sbyte value);
    public void Emit(OpCode opcode, int value);
    public void Emit(OpCode opcode, long value);
    public void Emit(OpCode opcode, float value);
    public void Emit(OpCode opcode, double value);
    public void Emit(OpCode opcode, Instruction target);
    public void Emit(OpCode opcode, Instruction[] targets);
    public void Emit(OpCode opcode, VariableDefinition variable);
    public void Emit(OpCode opcode, ParameterDefinition parameter);
    public void InsertBefore(Instruction target, Instruction instruction);
    public void InsertAfter(Instruction target, Instruction instruction);
    public void InsertAfter(int index, Instruction instruction);
    public void Append(Instruction instruction);
    public void Replace(Instruction target, Instruction instruction);
    public void Replace(int index, Instruction instruction);
    public void Remove(Instruction instruction);
    public void RemoveAt(int index);
    public void Clear();
}
public class Mono.Cecil.Cil.ImageDebugDirectory : ValueType {
    public static int Size;
    public int Characteristics;
    public int TimeDateStamp;
    public short MajorVersion;
    public short MinorVersion;
    public ImageDebugType Type;
    public int SizeOfData;
    public int AddressOfRawData;
    public int PointerToRawData;
}
public class Mono.Cecil.Cil.ImageDebugHeader : object {
    private ImageDebugHeaderEntry[] entries;
    public bool HasEntries { get; }
    public ImageDebugHeaderEntry[] Entries { get; }
    public ImageDebugHeader(ImageDebugHeaderEntry[] entries);
    public ImageDebugHeader(ImageDebugHeaderEntry entry);
    public bool get_HasEntries();
    public ImageDebugHeaderEntry[] get_Entries();
}
public class Mono.Cecil.Cil.ImageDebugHeaderEntry : object {
    private ImageDebugDirectory directory;
    private Byte[] data;
    public ImageDebugDirectory Directory { get; internal set; }
    public Byte[] Data { get; }
    public ImageDebugHeaderEntry(ImageDebugDirectory directory, Byte[] data);
    public ImageDebugDirectory get_Directory();
    internal void set_Directory(ImageDebugDirectory value);
    public Byte[] get_Data();
}
public enum Mono.Cecil.Cil.ImageDebugType : Enum {
    public int value__;
    public static ImageDebugType CodeView;
    public static ImageDebugType Deterministic;
    public static ImageDebugType EmbeddedPortablePdb;
    public static ImageDebugType PdbChecksum;
}
public class Mono.Cecil.Cil.ImportDebugInformation : DebugInformation {
    internal ImportDebugInformation parent;
    internal Collection`1<ImportTarget> targets;
    public bool HasTargets { get; }
    public Collection`1<ImportTarget> Targets { get; }
    public ImportDebugInformation Parent { get; public set; }
    public bool get_HasTargets();
    public Collection`1<ImportTarget> get_Targets();
    public ImportDebugInformation get_Parent();
    public void set_Parent(ImportDebugInformation value);
}
public class Mono.Cecil.Cil.ImportTarget : object {
    internal ImportTargetKind kind;
    internal string namespace;
    internal TypeReference type;
    internal AssemblyNameReference reference;
    internal string alias;
    public string Namespace { get; public set; }
    public TypeReference Type { get; public set; }
    public AssemblyNameReference AssemblyReference { get; public set; }
    public string Alias { get; public set; }
    public ImportTargetKind Kind { get; public set; }
    public ImportTarget(ImportTargetKind kind);
    public string get_Namespace();
    public void set_Namespace(string value);
    public TypeReference get_Type();
    public void set_Type(TypeReference value);
    public AssemblyNameReference get_AssemblyReference();
    public void set_AssemblyReference(AssemblyNameReference value);
    public string get_Alias();
    public void set_Alias(string value);
    public ImportTargetKind get_Kind();
    public void set_Kind(ImportTargetKind value);
}
public enum Mono.Cecil.Cil.ImportTargetKind : Enum {
    public byte value__;
    public static ImportTargetKind ImportNamespace;
    public static ImportTargetKind ImportNamespaceInAssembly;
    public static ImportTargetKind ImportType;
    public static ImportTargetKind ImportXmlNamespaceWithAlias;
    public static ImportTargetKind ImportAlias;
    public static ImportTargetKind DefineAssemblyAlias;
    public static ImportTargetKind DefineNamespaceAlias;
    public static ImportTargetKind DefineNamespaceInAssemblyAlias;
    public static ImportTargetKind DefineTypeAlias;
}
public class Mono.Cecil.Cil.Instruction : object {
    internal int offset;
    internal OpCode opcode;
    internal object operand;
    internal Instruction previous;
    internal Instruction next;
    public int Offset { get; public set; }
    public OpCode OpCode { get; public set; }
    public object Operand { get; public set; }
    public Instruction Previous { get; public set; }
    public Instruction Next { get; public set; }
    internal Instruction(int offset, OpCode opCode);
    internal Instruction(OpCode opcode, object operand);
    public int get_Offset();
    public void set_Offset(int value);
    public OpCode get_OpCode();
    public void set_OpCode(OpCode value);
    public object get_Operand();
    public void set_Operand(object value);
    public Instruction get_Previous();
    public void set_Previous(Instruction value);
    public Instruction get_Next();
    public void set_Next(Instruction value);
    public int GetSize();
    public virtual string ToString();
    private static void AppendLabel(StringBuilder builder, Instruction instruction);
    public static Instruction Create(OpCode opcode);
    public static Instruction Create(OpCode opcode, TypeReference type);
    public static Instruction Create(OpCode opcode, CallSite site);
    public static Instruction Create(OpCode opcode, MethodReference method);
    public static Instruction Create(OpCode opcode, FieldReference field);
    public static Instruction Create(OpCode opcode, string value);
    public static Instruction Create(OpCode opcode, sbyte value);
    public static Instruction Create(OpCode opcode, byte value);
    public static Instruction Create(OpCode opcode, int value);
    public static Instruction Create(OpCode opcode, long value);
    public static Instruction Create(OpCode opcode, float value);
    public static Instruction Create(OpCode opcode, double value);
    public static Instruction Create(OpCode opcode, Instruction target);
    public static Instruction Create(OpCode opcode, Instruction[] targets);
    public static Instruction Create(OpCode opcode, VariableDefinition variable);
    public static Instruction Create(OpCode opcode, ParameterDefinition parameter);
}
internal class Mono.Cecil.Cil.InstructionCollection : Collection`1<Instruction> {
    private MethodDefinition method;
    internal InstructionCollection(MethodDefinition method);
    internal InstructionCollection(MethodDefinition method, int capacity);
    protected virtual void OnAdd(Instruction item, int index);
    protected virtual void OnInsert(Instruction item, int index);
    protected virtual void OnSet(Instruction item, int index);
    protected virtual void OnRemove(Instruction item, int index);
    private void RemoveSequencePoint(Instruction instruction);
    private void UpdateDebugInformation(Instruction removedInstruction, Instruction existingInstruction);
    private void UpdateLocalScope(ScopeDebugInformation scope, InstructionOffsetResolver& resolver);
    private void UpdateStateMachineScope(StateMachineScopeDebugInformation debugInfo, InstructionOffsetResolver& resolver);
    private void UpdateAsyncMethodBody(AsyncMethodBodyDebugInformation debugInfo, InstructionOffsetResolver& resolver);
}
public class Mono.Cecil.Cil.InstructionOffset : ValueType {
    private Instruction instruction;
    private Nullable`1<int> offset;
    public int Offset { get; }
    public bool IsEndOfMethod { get; }
    internal bool IsResolved { get; }
    internal Instruction ResolvedInstruction { get; }
    public InstructionOffset(Instruction instruction);
    public InstructionOffset(int offset);
    public int get_Offset();
    public bool get_IsEndOfMethod();
    internal bool get_IsResolved();
    internal Instruction get_ResolvedInstruction();
}
public interface Mono.Cecil.Cil.ISymbolReader {
    public abstract virtual ISymbolWriterProvider GetWriterProvider();
    public abstract virtual bool ProcessDebugHeader(ImageDebugHeader header);
    public abstract virtual MethodDebugInformation Read(MethodDefinition method);
}
public interface Mono.Cecil.Cil.ISymbolReaderProvider {
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
public interface Mono.Cecil.Cil.ISymbolWriter {
    public abstract virtual ISymbolReaderProvider GetReaderProvider();
    public abstract virtual ImageDebugHeader GetDebugHeader();
    public abstract virtual void Write(MethodDebugInformation info);
    public abstract virtual void Write();
}
public interface Mono.Cecil.Cil.ISymbolWriterProvider {
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
public class Mono.Cecil.Cil.MethodBody : object {
    internal MethodDefinition method;
    internal ParameterDefinition this_parameter;
    internal int max_stack_size;
    internal int code_size;
    internal bool init_locals;
    internal MetadataToken local_var_token;
    internal Collection`1<Instruction> instructions;
    internal Collection`1<ExceptionHandler> exceptions;
    internal Collection`1<VariableDefinition> variables;
    public MethodDefinition Method { get; }
    public int MaxStackSize { get; public set; }
    public int CodeSize { get; }
    public bool InitLocals { get; public set; }
    public MetadataToken LocalVarToken { get; public set; }
    public Collection`1<Instruction> Instructions { get; }
    public bool HasExceptionHandlers { get; }
    public Collection`1<ExceptionHandler> ExceptionHandlers { get; }
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public ParameterDefinition ThisParameter { get; }
    public MethodBody(MethodDefinition method);
    public MethodDefinition get_Method();
    public int get_MaxStackSize();
    public void set_MaxStackSize(int value);
    public int get_CodeSize();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public MetadataToken get_LocalVarToken();
    public void set_LocalVarToken(MetadataToken value);
    public Collection`1<Instruction> get_Instructions();
    public bool get_HasExceptionHandlers();
    public Collection`1<ExceptionHandler> get_ExceptionHandlers();
    public bool get_HasVariables();
    public Collection`1<VariableDefinition> get_Variables();
    public ParameterDefinition get_ThisParameter();
    private static ParameterDefinition CreateThisParameter(MethodDefinition method);
    public ILProcessor GetILProcessor();
}
public class Mono.Cecil.Cil.MethodDebugInformation : DebugInformation {
    internal MethodDefinition method;
    internal Collection`1<SequencePoint> sequence_points;
    internal ScopeDebugInformation scope;
    internal MethodDefinition kickoff_method;
    internal int code_size;
    internal MetadataToken local_var_token;
    public MethodDefinition Method { get; }
    public bool HasSequencePoints { get; }
    public Collection`1<SequencePoint> SequencePoints { get; }
    public ScopeDebugInformation Scope { get; public set; }
    public MethodDefinition StateMachineKickOffMethod { get; public set; }
    internal MethodDebugInformation(MethodDefinition method);
    public MethodDefinition get_Method();
    public bool get_HasSequencePoints();
    public Collection`1<SequencePoint> get_SequencePoints();
    public ScopeDebugInformation get_Scope();
    public void set_Scope(ScopeDebugInformation value);
    public MethodDefinition get_StateMachineKickOffMethod();
    public void set_StateMachineKickOffMethod(MethodDefinition value);
    public SequencePoint GetSequencePoint(Instruction instruction);
    public IDictionary`2<Instruction, SequencePoint> GetSequencePointMapping();
    public IEnumerable`1<ScopeDebugInformation> GetScopes();
    [IteratorStateMachineAttribute("Mono.Cecil.Cil.MethodDebugInformation/<GetScopes>d__22")]
private static IEnumerable`1<ScopeDebugInformation> GetScopes(IList`1<ScopeDebugInformation> scopes);
    public bool TryGetName(VariableDefinition variable, String& name);
}
public class Mono.Cecil.Cil.OpCode : ValueType {
    private byte op1;
    private byte op2;
    private byte code;
    private byte flow_control;
    private byte opcode_type;
    private byte operand_type;
    private byte stack_behavior_pop;
    private byte stack_behavior_push;
    public string Name { get; }
    public int Size { get; }
    public byte Op1 { get; }
    public byte Op2 { get; }
    public short Value { get; }
    public Code Code { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public OperandType OperandType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    internal OpCode(int x, int y);
    public string get_Name();
    public int get_Size();
    public byte get_Op1();
    public byte get_Op2();
    public short get_Value();
    public Code get_Code();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public OperandType get_OperandType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCode opcode);
    public static bool op_Equality(OpCode one, OpCode other);
    public static bool op_Inequality(OpCode one, OpCode other);
    public virtual string ToString();
}
internal static class Mono.Cecil.Cil.OpCodeNames : object {
    internal static String[] names;
    private static OpCodeNames();
}
internal static class Mono.Cecil.Cil.OpCodes : object {
    internal static OpCode[] OneByteOpCode;
    internal static OpCode[] TwoBytesOpCode;
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem_Any;
    public static OpCode Stelem_Any;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tail;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode No;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
}
public enum Mono.Cecil.Cil.OpCodeType : Enum {
    public int value__;
    public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
public enum Mono.Cecil.Cil.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType InlineArg;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
    public static OperandType ShortInlineArg;
}
[ExtensionAttribute]
internal static class Mono.Cecil.Cil.PdbGuidMapping : object {
    private static Dictionary`2<Guid, DocumentLanguage> guid_language;
    private static Dictionary`2<DocumentLanguage, Guid> language_guid;
    private static Guid type_text;
    private static Guid hash_md5;
    private static Guid hash_sha1;
    private static Guid hash_sha256;
    private static Guid vendor_ms;
    private static PdbGuidMapping();
    private static void AddMapping(DocumentLanguage language, Guid guid);
    [ExtensionAttribute]
public static DocumentType ToType(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentType type);
    [ExtensionAttribute]
public static DocumentHashAlgorithm ToHashAlgorithm(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentHashAlgorithm hash_algo);
    [ExtensionAttribute]
public static DocumentLanguage ToLanguage(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentLanguage language);
    [ExtensionAttribute]
public static DocumentLanguageVendor ToVendor(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentLanguageVendor vendor);
}
internal class Mono.Cecil.Cil.PortablePdbReader : object {
    private Image image;
    private ModuleDefinition module;
    private MetadataReader reader;
    private MetadataReader debug_reader;
    private bool IsEmbedded { get; }
    internal PortablePdbReader(Image image, ModuleDefinition module);
    private bool get_IsEmbedded();
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    private static bool IsMatchingEntry(PdbHeap heap, ImageDebugHeaderEntry entry);
    private static int ReadInt32(Byte[] bytes, int start);
    private void ReadModule();
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    private void ReadSequencePoints(MethodDebugInformation method_info);
    private void ReadScope(MethodDebugInformation method_info);
    private void ReadStateMachineKickOffMethod(MethodDebugInformation method_info);
    private void ReadCustomDebugInformations(MethodDebugInformation info);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Cil.PortablePdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
    private ISymbolReader GetSymbolReader(ModuleDefinition module, Disposable`1<Stream> symbolStream, string fileName);
}
internal class Mono.Cecil.Cil.PortablePdbWriter : object {
    private MetadataBuilder pdb_metadata;
    private ModuleDefinition module;
    private ImageWriter writer;
    private Disposable`1<Stream> final_stream;
    private MetadataBuilder module_metadata;
    internal Byte[] pdb_checksum;
    internal Guid pdb_id_guid;
    internal UInt32 pdb_id_stamp;
    private bool IsEmbedded { get; }
    internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module);
    internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module, ImageWriter writer, Disposable`1<Stream> final_stream);
    private bool get_IsEmbedded();
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    public sealed virtual void Write(MethodDebugInformation info);
    public sealed virtual void Write();
    public sealed virtual ImageDebugHeader GetDebugHeader();
    private void CheckMethodDebugInformationTable();
    public sealed virtual void Dispose();
    private void WritePdbFile();
    private void WritePdbHeap();
    private void WriteTableHeap();
    private void ComputeChecksumAndPdbId();
    private void WritePdbId();
}
internal class Mono.Cecil.Cil.PortablePdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
    private ISymbolWriter GetSymbolWriter(ModuleDefinition module, Disposable`1<Stream> stream, Disposable`1<Stream> final_stream);
}
public class Mono.Cecil.Cil.ScopeDebugInformation : DebugInformation {
    internal InstructionOffset start;
    internal InstructionOffset end;
    internal ImportDebugInformation import;
    internal Collection`1<ScopeDebugInformation> scopes;
    internal Collection`1<VariableDebugInformation> variables;
    internal Collection`1<ConstantDebugInformation> constants;
    public InstructionOffset Start { get; public set; }
    public InstructionOffset End { get; public set; }
    public ImportDebugInformation Import { get; public set; }
    public bool HasScopes { get; }
    public Collection`1<ScopeDebugInformation> Scopes { get; }
    public bool HasVariables { get; }
    public Collection`1<VariableDebugInformation> Variables { get; }
    public bool HasConstants { get; }
    public Collection`1<ConstantDebugInformation> Constants { get; }
    public ScopeDebugInformation(Instruction start, Instruction end);
    public InstructionOffset get_Start();
    public void set_Start(InstructionOffset value);
    public InstructionOffset get_End();
    public void set_End(InstructionOffset value);
    public ImportDebugInformation get_Import();
    public void set_Import(ImportDebugInformation value);
    public bool get_HasScopes();
    public Collection`1<ScopeDebugInformation> get_Scopes();
    public bool get_HasVariables();
    public Collection`1<VariableDebugInformation> get_Variables();
    public bool get_HasConstants();
    public Collection`1<ConstantDebugInformation> get_Constants();
    public bool TryGetName(VariableDefinition variable, String& name);
}
public class Mono.Cecil.Cil.SequencePoint : object {
    internal InstructionOffset offset;
    private Document document;
    private int start_line;
    private int start_column;
    private int end_line;
    private int end_column;
    public int Offset { get; }
    public int StartLine { get; public set; }
    public int StartColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public bool IsHidden { get; }
    public Document Document { get; public set; }
    internal SequencePoint(int offset, Document document);
    public SequencePoint(Instruction instruction, Document document);
    public int get_Offset();
    public int get_StartLine();
    public void set_StartLine(int value);
    public int get_StartColumn();
    public void set_StartColumn(int value);
    public int get_EndLine();
    public void set_EndLine(int value);
    public int get_EndColumn();
    public void set_EndColumn(int value);
    public bool get_IsHidden();
    public Document get_Document();
    public void set_Document(Document value);
}
internal class Mono.Cecil.Cil.SourceLinkDebugInformation : CustomDebugInformation {
    internal string content;
    public static Guid KindIdentifier;
    public string Content { get; public set; }
    public CustomDebugInformationKind Kind { get; }
    public SourceLinkDebugInformation(string content);
    private static SourceLinkDebugInformation();
    public string get_Content();
    public void set_Content(string value);
    public virtual CustomDebugInformationKind get_Kind();
}
public enum Mono.Cecil.Cil.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour PopAll;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
}
internal class Mono.Cecil.Cil.StateMachineScope : object {
    internal InstructionOffset start;
    internal InstructionOffset end;
    public InstructionOffset Start { get; public set; }
    public InstructionOffset End { get; public set; }
    internal StateMachineScope(int start, int end);
    public StateMachineScope(Instruction start, Instruction end);
    public InstructionOffset get_Start();
    public void set_Start(InstructionOffset value);
    public InstructionOffset get_End();
    public void set_End(InstructionOffset value);
}
internal class Mono.Cecil.Cil.StateMachineScopeDebugInformation : CustomDebugInformation {
    internal Collection`1<StateMachineScope> scopes;
    public static Guid KindIdentifier;
    public Collection`1<StateMachineScope> Scopes { get; }
    public CustomDebugInformationKind Kind { get; }
    private static StateMachineScopeDebugInformation();
    public Collection`1<StateMachineScope> get_Scopes();
    public virtual CustomDebugInformationKind get_Kind();
}
internal enum Mono.Cecil.Cil.SymbolKind : Enum {
    public int value__;
    public static SymbolKind NativePdb;
    public static SymbolKind PortablePdb;
    public static SymbolKind EmbeddedPortablePdb;
    public static SymbolKind Mdb;
}
internal static class Mono.Cecil.Cil.SymbolProvider : object {
    private static AssemblyName GetSymbolAssemblyName(SymbolKind kind);
    private static Type GetSymbolType(SymbolKind kind, string fullname);
    public static ISymbolReaderProvider GetReaderProvider(SymbolKind kind);
    private static string GetSymbolTypeName(SymbolKind kind, string name);
    private static string GetSymbolNamespace(SymbolKind kind);
}
internal class Mono.Cecil.Cil.SymbolsNotFoundException : FileNotFoundException {
    public SymbolsNotFoundException(string message);
}
internal class Mono.Cecil.Cil.SymbolsNotMatchingException : InvalidOperationException {
    public SymbolsNotMatchingException(string message);
}
[FlagsAttribute]
public enum Mono.Cecil.Cil.VariableAttributes : Enum {
    public ushort value__;
    public static VariableAttributes None;
    public static VariableAttributes DebuggerHidden;
}
public class Mono.Cecil.Cil.VariableDebugInformation : DebugInformation {
    private string name;
    private ushort attributes;
    internal VariableIndex index;
    public int Index { get; }
    public string Name { get; public set; }
    public VariableAttributes Attributes { get; public set; }
    public bool IsDebuggerHidden { get; public set; }
    internal VariableDebugInformation(int index, string name);
    public VariableDebugInformation(VariableDefinition variable, string name);
    public int get_Index();
    public string get_Name();
    public void set_Name(string value);
    public VariableAttributes get_Attributes();
    public void set_Attributes(VariableAttributes value);
    public bool get_IsDebuggerHidden();
    public void set_IsDebuggerHidden(bool value);
}
public class Mono.Cecil.Cil.VariableDefinition : VariableReference {
    public bool IsPinned { get; }
    public VariableDefinition(TypeReference variableType);
    public bool get_IsPinned();
    public virtual VariableDefinition Resolve();
}
internal class Mono.Cecil.Cil.VariableDefinitionCollection : Collection`1<VariableDefinition> {
    private MethodDefinition method;
    internal VariableDefinitionCollection(MethodDefinition method);
    internal VariableDefinitionCollection(MethodDefinition method, int capacity);
    protected virtual void OnAdd(VariableDefinition item, int index);
    protected virtual void OnInsert(VariableDefinition item, int index);
    protected virtual void OnSet(VariableDefinition item, int index);
    protected virtual void OnRemove(VariableDefinition item, int index);
    private void UpdateVariableIndices(int startIndex, int offset, VariableDefinition variableToRemove);
}
internal class Mono.Cecil.Cil.VariableIndex : ValueType {
    private VariableDefinition variable;
    private Nullable`1<int> index;
    public int Index { get; }
    internal bool IsResolved { get; }
    internal VariableDefinition ResolvedVariable { get; }
    public VariableIndex(VariableDefinition variable);
    public VariableIndex(int index);
    public int get_Index();
    internal bool get_IsResolved();
    internal VariableDefinition get_ResolvedVariable();
}
public abstract class Mono.Cecil.Cil.VariableReference : object {
    internal int index;
    protected TypeReference variable_type;
    public TypeReference VariableType { get; public set; }
    public int Index { get; }
    internal VariableReference(TypeReference variable_type);
    public TypeReference get_VariableType();
    public void set_VariableType(TypeReference value);
    public int get_Index();
    public abstract virtual VariableDefinition Resolve();
    public virtual string ToString();
}
internal class Mono.Cecil.ClassLayoutTable : SortedTable`1<Row`3<ushort, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ushort, UInt32, UInt32> x, Row`3<ushort, UInt32, UInt32> y);
}
internal class Mono.Cecil.ConstantTable : SortedTable`1<Row`3<ElementType, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ElementType, UInt32, UInt32> x, Row`3<ElementType, UInt32, UInt32> y);
}
internal static class Mono.Cecil.CryptoService : object {
    public static Byte[] GetPublicKey(WriterParameters parameters);
    public static void StrongName(Stream stream, ImageWriter writer, WriterParameters parameters);
    private static void PatchStrongName(Stream stream, int strong_name_pointer, Byte[] strong_name);
    private static Byte[] CreateStrongName(WriterParameters parameters, Byte[] hash);
    private static Byte[] HashStream(Stream stream, ImageWriter writer, Int32& strong_name_pointer);
    public static void CopyStreamChunk(Stream stream, Stream dest_stream, Byte[] buffer, int length);
    public static Byte[] ComputeHash(string file);
    public static Byte[] ComputeHash(Stream stream);
    public static Byte[] ComputeHash(ByteBuffer[] buffers);
    public static Guid ComputeGuid(Byte[] hash);
}
[DebuggerDisplayAttribute("{AttributeType}")]
public class Mono.Cecil.CustomAttribute : object {
    internal CustomAttributeValueProjection projection;
    internal UInt32 signature;
    internal bool resolved;
    private MethodReference constructor;
    private Byte[] blob;
    internal Collection`1<CustomAttributeArgument> arguments;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public MethodReference Constructor { get; public set; }
    public TypeReference AttributeType { get; }
    public bool IsResolved { get; }
    public bool HasConstructorArguments { get; }
    public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    internal bool HasImage { get; }
    internal ModuleDefinition Module { get; }
    internal CustomAttribute(UInt32 signature, MethodReference constructor);
    public CustomAttribute(MethodReference constructor);
    public CustomAttribute(MethodReference constructor, Byte[] blob);
    public MethodReference get_Constructor();
    public void set_Constructor(MethodReference value);
    public sealed virtual TypeReference get_AttributeType();
    public bool get_IsResolved();
    public sealed virtual bool get_HasConstructorArguments();
    public sealed virtual Collection`1<CustomAttributeArgument> get_ConstructorArguments();
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    internal bool get_HasImage();
    internal ModuleDefinition get_Module();
    public Byte[] GetBlob();
    private void Resolve();
    [CompilerGeneratedAttribute]
private void <Resolve>b__35_0(CustomAttribute attribute, MetadataReader reader);
}
public class Mono.Cecil.CustomAttributeArgument : ValueType {
    private TypeReference type;
    private object value;
    public TypeReference Type { get; }
    public object Value { get; }
    public CustomAttributeArgument(TypeReference type, object value);
    public TypeReference get_Type();
    public object get_Value();
}
public class Mono.Cecil.CustomAttributeNamedArgument : ValueType {
    private string name;
    private CustomAttributeArgument argument;
    public string Name { get; }
    public CustomAttributeArgument Argument { get; }
    public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument);
    public string get_Name();
    public CustomAttributeArgument get_Argument();
}
internal class Mono.Cecil.CustomAttributeTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.CustomAttributeValueProjection : object {
    public AttributeTargets Targets;
    public CustomAttributeValueTreatment Treatment;
    public CustomAttributeValueProjection(AttributeTargets targets, CustomAttributeValueTreatment treatment);
}
internal enum Mono.Cecil.CustomAttributeValueTreatment : Enum {
    public int value__;
    public static CustomAttributeValueTreatment None;
    public static CustomAttributeValueTreatment AllowSingle;
    public static CustomAttributeValueTreatment AllowMultiple;
    public static CustomAttributeValueTreatment VersionAttribute;
    public static CustomAttributeValueTreatment DeprecatedAttribute;
}
internal class Mono.Cecil.CustomDebugInformationTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.CustomMarshalInfo : MarshalInfo {
    internal Guid guid;
    internal string unmanaged_type;
    internal TypeReference managed_type;
    internal string cookie;
    public Guid Guid { get; public set; }
    public string UnmanagedType { get; public set; }
    public TypeReference ManagedType { get; public set; }
    public string Cookie { get; public set; }
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_UnmanagedType();
    public void set_UnmanagedType(string value);
    public TypeReference get_ManagedType();
    public void set_ManagedType(TypeReference value);
    public string get_Cookie();
    public void set_Cookie(string value);
}
internal class Mono.Cecil.DeclSecurityTable : SortedTable`1<Row`3<SecurityAction, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<SecurityAction, UInt32, UInt32> x, Row`3<SecurityAction, UInt32, UInt32> y);
}
internal class Mono.Cecil.DefaultAssemblyResolver : BaseAssemblyResolver {
    private IDictionary`2<string, AssemblyDefinition> cache;
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    protected void RegisterAssembly(AssemblyDefinition assembly);
    protected virtual void Dispose(bool disposing);
}
internal class Mono.Cecil.DefaultMetadataImporter : object {
    protected ModuleDefinition module;
    public DefaultMetadataImporter(ModuleDefinition module);
    private TypeReference ImportType(TypeReference type, ImportGenericContext context);
    protected virtual IMetadataScope ImportScope(TypeReference type);
    protected IMetadataScope ImportScope(IMetadataScope scope);
    public virtual AssemblyNameReference ImportReference(AssemblyNameReference name);
    private static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original);
    private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context);
    private FieldReference ImportField(FieldReference field, ImportGenericContext context);
    private MethodReference ImportMethod(MethodReference method, ImportGenericContext context);
    private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context);
    public virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    public virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    public virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}
internal class Mono.Cecil.DefaultReflectionImporter : object {
    protected ModuleDefinition module;
    private static Dictionary`2<Type, ElementType> type_etype_mapping;
    public DefaultReflectionImporter(ModuleDefinition module);
    private static DefaultReflectionImporter();
    private TypeReference ImportType(Type type, ImportGenericContext context);
    private TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind);
    protected virtual IMetadataScope ImportScope(Type type);
    private static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind);
    private static bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind);
    private static bool IsNestedType(Type type);
    private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context);
    private static TypeReference ImportGenericParameter(Type type, ImportGenericContext context);
    private static string NormalizeMethodName(MethodBase method);
    private static string NormalizeTypeFullName(Type type);
    private TypeReference ImportGenericInstance(Type type, ImportGenericContext context);
    private static bool IsTypeSpecification(Type type);
    private static bool IsGenericInstance(Type type);
    private static ElementType ImportElementType(Type type);
    protected AssemblyNameReference ImportScope(Assembly assembly);
    public virtual AssemblyNameReference ImportReference(AssemblyName name);
    private bool TryGetAssemblyNameReference(AssemblyName name, AssemblyNameReference& assembly_reference);
    private FieldReference ImportField(FieldInfo field, ImportGenericContext context);
    private static FieldInfo ResolveFieldDefinition(FieldInfo field);
    private static MethodBase ResolveMethodDefinition(MethodBase method);
    private MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind);
    private static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments);
    private static bool IsMethodSpecification(MethodBase method);
    private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context);
    private static bool HasCallingConvention(MethodBase method, CallingConventions conventions);
    public virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    public virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}
internal class Mono.Cecil.DeferredModuleReader : ModuleReader {
    public DeferredModuleReader(Image image);
    protected virtual void ReadModule();
    public virtual void ReadSymbols(ModuleDefinition module);
    [CompilerGeneratedAttribute]
private void <ReadModule>b__1_0(ModuleDefinition _, MetadataReader reader);
}
internal class Mono.Cecil.DocumentTable : MetadataTable`1<Row`4<UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.EmbeddedResource : Resource {
    private MetadataReader reader;
    private Nullable`1<UInt32> offset;
    private Byte[] data;
    private Stream stream;
    public ResourceType ResourceType { get; }
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Byte[] data);
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream);
    internal EmbeddedResource(string name, ManifestResourceAttributes attributes, UInt32 offset, MetadataReader reader);
    public virtual ResourceType get_ResourceType();
    public Stream GetResourceStream();
    public Byte[] GetResourceData();
    private static Byte[] ReadStream(Stream stream);
}
[FlagsAttribute]
public enum Mono.Cecil.EventAttributes : Enum {
    public ushort value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
}
public class Mono.Cecil.EventDefinition : EventReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition add_method;
    internal MethodDefinition invoke_method;
    internal MethodDefinition remove_method;
    internal Collection`1<MethodDefinition> other_methods;
    public EventAttributes Attributes { get; public set; }
    public MethodDefinition AddMethod { get; public set; }
    public MethodDefinition InvokeMethod { get; public set; }
    public MethodDefinition RemoveMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public EventDefinition(string name, EventAttributes attributes, TypeReference eventType);
    public EventAttributes get_Attributes();
    public void set_Attributes(EventAttributes value);
    public MethodDefinition get_AddMethod();
    public void set_AddMethod(MethodDefinition value);
    public MethodDefinition get_InvokeMethod();
    public void set_InvokeMethod(MethodDefinition value);
    public MethodDefinition get_RemoveMethod();
    public void set_RemoveMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    private void InitializeMethods();
    public virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.EventReference : MemberReference {
    private TypeReference event_type;
    public TypeReference EventType { get; public set; }
    public string FullName { get; }
    protected EventReference(string name, TypeReference eventType);
    public TypeReference get_EventType();
    public void set_EventType(TypeReference value);
    public virtual string get_FullName();
    protected virtual IMemberDefinition ResolveDefinition();
    public abstract virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventTable : MetadataTable`1<Row`3<EventAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.ExportedType : object {
    private string namespace;
    private string name;
    private UInt32 attributes;
    private IMetadataScope scope;
    private ModuleDefinition module;
    private int identifier;
    private ExportedType declaring_type;
    internal MetadataToken token;
    public string Namespace { get; public set; }
    public string Name { get; public set; }
    public TypeAttributes Attributes { get; public set; }
    public IMetadataScope Scope { get; public set; }
    public ExportedType DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public int Identifier { get; public set; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsForwarder { get; public set; }
    public string FullName { get; }
    public ExportedType(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Name();
    public void set_Name(string value);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public IMetadataScope get_Scope();
    public void set_Scope(IMetadataScope value);
    public ExportedType get_DeclaringType();
    public void set_DeclaringType(ExportedType value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public int get_Identifier();
    public void set_Identifier(int value);
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public bool get_IsRuntimeSpecialName();
    public void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsForwarder();
    public void set_IsForwarder(bool value);
    public string get_FullName();
    public virtual string ToString();
    public TypeDefinition Resolve();
    internal TypeReference CreateReference();
}
internal class Mono.Cecil.ExportedTypeTable : MetadataTable`1<Row`5<TypeAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[FlagsAttribute]
public enum Mono.Cecil.FieldAttributes : Enum {
    public ushort value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes CompilerControlled;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PInvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
}
public class Mono.Cecil.FieldDefinition : FieldReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    private int offset;
    internal int rva;
    private Byte[] initial_value;
    private object constant;
    private MarshalInfo marshal_info;
    public bool HasLayoutInfo { get; }
    public int Offset { get; public set; }
    internal FieldDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public int RVA { get; }
    public Byte[] InitialValue { get; public set; }
    public FieldAttributes Attributes { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsInitOnly { get; public set; }
    public bool IsLiteral { get; public set; }
    public bool IsNotSerialized { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public bool HasFieldRVA { get; public set; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public int get_Offset();
    public void set_Offset(int value);
    internal FieldDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(FieldDefinitionProjection value);
    private void ResolveRVA();
    public int get_RVA();
    public Byte[] get_InitialValue();
    public void set_InitialValue(Byte[] value);
    public FieldAttributes get_Attributes();
    public void set_Attributes(FieldAttributes value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsInitOnly();
    public void set_IsInitOnly(bool value);
    public bool get_IsLiteral();
    public void set_IsLiteral(bool value);
    public bool get_IsNotSerialized();
    public void set_IsNotSerialized(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public bool get_HasFieldRVA();
    public void set_HasFieldRVA(bool value);
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldDefinitionProjection : object {
    public FieldAttributes Attributes;
    public FieldDefinitionTreatment Treatment;
    public FieldDefinitionProjection(FieldDefinition field, FieldDefinitionTreatment treatment);
}
internal enum Mono.Cecil.FieldDefinitionTreatment : Enum {
    public int value__;
    public static FieldDefinitionTreatment None;
    public static FieldDefinitionTreatment Public;
}
internal class Mono.Cecil.FieldLayoutTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldMarshalTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
public class Mono.Cecil.FieldReference : MemberReference {
    private TypeReference field_type;
    public TypeReference FieldType { get; public set; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public FieldReference(string name, TypeReference fieldType);
    public FieldReference(string name, TypeReference fieldType, TypeReference declaringType);
    public TypeReference get_FieldType();
    public void set_FieldType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldRVATable : SortedTable`1<Row`2<UInt32, UInt32>> {
    internal int position;
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldTable : MetadataTable`1<Row`3<FieldAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.FileAttributes : Enum {
    public UInt32 value__;
    public static FileAttributes ContainsMetaData;
    public static FileAttributes ContainsNoMetaData;
}
internal class Mono.Cecil.FileTable : MetadataTable`1<Row`3<FileAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.FixedArrayMarshalInfo : MarshalInfo {
    internal NativeType element_type;
    internal int size;
    public NativeType ElementType { get; public set; }
    public int Size { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_Size();
    public void set_Size(int value);
}
internal class Mono.Cecil.FixedSysStringMarshalInfo : MarshalInfo {
    internal int size;
    public int Size { get; public set; }
    public int get_Size();
    public void set_Size(int value);
}
internal class Mono.Cecil.FunctionPointerType : TypeSpecification {
    private MethodReference function;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsFunctionPointer { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual ModuleDefinition get_Module();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
    public virtual TypeDefinition Resolve();
    public virtual TypeReference GetElementType();
}
internal class Mono.Cecil.GenericInstanceMethod : MethodSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public bool IsGenericInstance { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public GenericInstanceMethod(MethodReference method);
    internal GenericInstanceMethod(MethodReference method, int arity);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual bool get_IsGenericInstance();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
}
internal class Mono.Cecil.GenericInstanceType : TypeSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public GenericInstanceType(TypeReference type);
    internal GenericInstanceType(TypeReference type, int arity);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
}
internal class Mono.Cecil.GenericParamConstraintTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.GenericParameter : TypeReference {
    internal int position;
    internal GenericParameterType type;
    internal IGenericParameterProvider owner;
    private ushort attributes;
    private GenericParameterConstraintCollection constraints;
    private Collection`1<CustomAttribute> custom_attributes;
    public GenericParameterAttributes Attributes { get; public set; }
    public int Position { get; }
    public GenericParameterType Type { get; }
    public IGenericParameterProvider Owner { get; }
    public bool HasConstraints { get; }
    public Collection`1<GenericParameterConstraint> Constraints { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public IMetadataScope Scope { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public MethodReference DeclaringMethod { get; }
    public ModuleDefinition Module { get; }
    public string Name { get; }
    public string Namespace { get; public set; }
    public string FullName { get; }
    public bool IsGenericParameter { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    public bool IsNonVariant { get; public set; }
    public bool IsCovariant { get; public set; }
    public bool IsContravariant { get; public set; }
    public bool HasReferenceTypeConstraint { get; public set; }
    public bool HasNotNullableValueTypeConstraint { get; public set; }
    public bool HasDefaultConstructorConstraint { get; public set; }
    public GenericParameter(IGenericParameterProvider owner);
    public GenericParameter(string name, IGenericParameterProvider owner);
    internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module);
    public GenericParameterAttributes get_Attributes();
    public void set_Attributes(GenericParameterAttributes value);
    public int get_Position();
    public GenericParameterType get_Type();
    public IGenericParameterProvider get_Owner();
    public bool get_HasConstraints();
    public Collection`1<GenericParameterConstraint> get_Constraints();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public MethodReference get_DeclaringMethod();
    public virtual ModuleDefinition get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public bool get_IsNonVariant();
    public void set_IsNonVariant(bool value);
    public bool get_IsCovariant();
    public void set_IsCovariant(bool value);
    public bool get_IsContravariant();
    public void set_IsContravariant(bool value);
    public bool get_HasReferenceTypeConstraint();
    public void set_HasReferenceTypeConstraint(bool value);
    public bool get_HasNotNullableValueTypeConstraint();
    public void set_HasNotNullableValueTypeConstraint(bool value);
    public bool get_HasDefaultConstructorConstraint();
    public void set_HasDefaultConstructorConstraint(bool value);
    private static ElementType ConvertGenericParameterType(GenericParameterType type);
    public virtual TypeDefinition Resolve();
}
[FlagsAttribute]
public enum Mono.Cecil.GenericParameterAttributes : Enum {
    public ushort value__;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes NonVariant;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
internal class Mono.Cecil.GenericParameterCollection : Collection`1<GenericParameter> {
    private IGenericParameterProvider owner;
    internal GenericParameterCollection(IGenericParameterProvider owner);
    internal GenericParameterCollection(IGenericParameterProvider owner, int capacity);
    protected virtual void OnAdd(GenericParameter item, int index);
    protected virtual void OnInsert(GenericParameter item, int index);
    protected virtual void OnSet(GenericParameter item, int index);
    private void UpdateGenericParameter(GenericParameter item, int index);
    protected virtual void OnRemove(GenericParameter item, int index);
}
public class Mono.Cecil.GenericParameterConstraint : object {
    internal GenericParameter generic_parameter;
    internal MetadataToken token;
    private TypeReference constraint_type;
    private Collection`1<CustomAttribute> custom_attributes;
    public TypeReference ConstraintType { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MetadataToken MetadataToken { get; public set; }
    internal GenericParameterConstraint(TypeReference constraintType, MetadataToken token);
    public GenericParameterConstraint(TypeReference constraintType);
    public TypeReference get_ConstraintType();
    public void set_ConstraintType(TypeReference value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
}
internal class Mono.Cecil.GenericParameterConstraintCollection : Collection`1<GenericParameterConstraint> {
    private GenericParameter generic_parameter;
    internal GenericParameterConstraintCollection(GenericParameter genericParameter);
    internal GenericParameterConstraintCollection(GenericParameter genericParameter, int length);
    protected virtual void OnAdd(GenericParameterConstraint item, int index);
    protected virtual void OnInsert(GenericParameterConstraint item, int index);
    protected virtual void OnSet(GenericParameterConstraint item, int index);
    protected virtual void OnRemove(GenericParameterConstraint item, int index);
}
internal class Mono.Cecil.GenericParameterResolver : object {
    internal static TypeReference ResolveReturnTypeIfNeeded(MethodReference methodReference);
    internal static TypeReference ResolveFieldTypeIfNeeded(FieldReference fieldReference);
    internal static TypeReference ResolveParameterTypeIfNeeded(MethodReference method, ParameterReference parameter);
    internal static TypeReference ResolveVariableTypeIfNeeded(MethodReference method, VariableReference variable);
    private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance declaringGenericInstanceType, TypeReference parameterType);
    private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericParameter genericParameterElement);
    private static ArrayType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ArrayType arrayType);
    private static ByReferenceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ByReferenceType byReferenceType);
    private static GenericInstanceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericInstanceType genericInstanceType1);
    private static bool ContainsGenericParameters(TypeReference typeReference);
}
public enum Mono.Cecil.GenericParameterType : Enum {
    public int value__;
    public static GenericParameterType Type;
    public static GenericParameterType Method;
}
internal class Mono.Cecil.GenericParamTable : MetadataTable`1<Row`4<ushort, GenericParameterAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public interface Mono.Cecil.IAssemblyResolver {
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
}
internal interface Mono.Cecil.IConstantProvider {
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public abstract virtual bool get_HasConstant();
    public abstract virtual void set_HasConstant(bool value);
    public abstract virtual object get_Constant();
    public abstract virtual void set_Constant(object value);
}
internal interface Mono.Cecil.ICustomAttribute {
    public TypeReference AttributeType { get; }
    public bool HasFields { get; }
    public bool HasProperties { get; }
    public bool HasConstructorArguments { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public abstract virtual TypeReference get_AttributeType();
    public abstract virtual bool get_HasFields();
    public abstract virtual bool get_HasProperties();
    public abstract virtual bool get_HasConstructorArguments();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    public abstract virtual Collection`1<CustomAttributeArgument> get_ConstructorArguments();
}
internal interface Mono.Cecil.ICustomAttributeProvider {
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasCustomAttributes { get; }
    public abstract virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public abstract virtual bool get_HasCustomAttributes();
}
internal interface Mono.Cecil.IGenericContext {
    public bool IsDefinition { get; }
    public IGenericParameterProvider Type { get; }
    public IGenericParameterProvider Method { get; }
    public abstract virtual bool get_IsDefinition();
    public abstract virtual IGenericParameterProvider get_Type();
    public abstract virtual IGenericParameterProvider get_Method();
}
internal interface Mono.Cecil.IGenericInstance {
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public abstract virtual bool get_HasGenericArguments();
    public abstract virtual Collection`1<TypeReference> get_GenericArguments();
}
public interface Mono.Cecil.IGenericParameterProvider {
    public bool HasGenericParameters { get; }
    public bool IsDefinition { get; }
    public ModuleDefinition Module { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public GenericParameterType GenericParameterType { get; }
    public abstract virtual bool get_HasGenericParameters();
    public abstract virtual bool get_IsDefinition();
    public abstract virtual ModuleDefinition get_Module();
    public abstract virtual Collection`1<GenericParameter> get_GenericParameters();
    public abstract virtual GenericParameterType get_GenericParameterType();
}
internal interface Mono.Cecil.IMarshalInfoProvider {
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public abstract virtual bool get_HasMarshalInfo();
    public abstract virtual MarshalInfo get_MarshalInfo();
    public abstract virtual void set_MarshalInfo(MarshalInfo value);
}
public interface Mono.Cecil.IMemberDefinition {
    public string Name { get; public set; }
    public string FullName { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual void set_IsSpecialName(bool value);
    public abstract virtual bool get_IsRuntimeSpecialName();
    public abstract virtual void set_IsRuntimeSpecialName(bool value);
    public abstract virtual TypeDefinition get_DeclaringType();
    public abstract virtual void set_DeclaringType(TypeDefinition value);
}
public interface Mono.Cecil.IMetadataImporter {
    public abstract virtual AssemblyNameReference ImportReference(AssemblyNameReference reference);
    public abstract virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    public abstract virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    public abstract virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}
public interface Mono.Cecil.IMetadataImporterProvider {
    public abstract virtual IMetadataImporter GetMetadataImporter(ModuleDefinition module);
}
public interface Mono.Cecil.IMetadataResolver {
    public abstract virtual TypeDefinition Resolve(TypeReference type);
    public abstract virtual FieldDefinition Resolve(FieldReference field);
    public abstract virtual MethodDefinition Resolve(MethodReference method);
}
public interface Mono.Cecil.IMetadataScope {
    public MetadataScopeType MetadataScopeType { get; }
    public string Name { get; public set; }
    public abstract virtual MetadataScopeType get_MetadataScopeType();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public interface Mono.Cecil.IMetadataTokenProvider {
    public MetadataToken MetadataToken { get; public set; }
    public abstract virtual MetadataToken get_MetadataToken();
    public abstract virtual void set_MetadataToken(MetadataToken value);
}
public interface Mono.Cecil.IMethodSignature {
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public abstract virtual bool get_HasThis();
    public abstract virtual void set_HasThis(bool value);
    public abstract virtual bool get_ExplicitThis();
    public abstract virtual void set_ExplicitThis(bool value);
    public abstract virtual MethodCallingConvention get_CallingConvention();
    public abstract virtual void set_CallingConvention(MethodCallingConvention value);
    public abstract virtual bool get_HasParameters();
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    public abstract virtual TypeReference get_ReturnType();
    public abstract virtual void set_ReturnType(TypeReference value);
    public abstract virtual MethodReturnType get_MethodReturnType();
}
internal class Mono.Cecil.ImmediateModuleReader : ModuleReader {
    private bool resolve_attributes;
    public ImmediateModuleReader(Image image);
    protected virtual void ReadModule();
    public void ReadModule(ModuleDefinition module, bool resolve_attributes);
    private void ReadTypes(Collection`1<TypeDefinition> types);
    private void ReadType(TypeDefinition type);
    private void ReadInterfaces(TypeDefinition type);
    private void ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParameterConstraints(GenericParameter parameter);
    private void ReadSecurityDeclarations(ISecurityDeclarationProvider provider);
    private void ReadCustomAttributes(ICustomAttributeProvider provider);
    private void ReadFields(TypeDefinition type);
    private void ReadMethods(TypeDefinition type);
    private void ReadParameters(MethodDefinition method);
    private void ReadProperties(TypeDefinition type);
    private void ReadEvents(TypeDefinition type);
    public virtual void ReadSymbols(ModuleDefinition module);
    private void ReadTypesSymbols(Collection`1<TypeDefinition> types, ISymbolReader symbol_reader);
    private void ReadMethodsSymbols(TypeDefinition type, ISymbolReader symbol_reader);
    [CompilerGeneratedAttribute]
private void <ReadModule>b__2_0(ModuleDefinition module, MetadataReader reader);
}
internal interface Mono.Cecil.IModifierType {
    public TypeReference ModifierType { get; }
    public TypeReference ElementType { get; }
    public abstract virtual TypeReference get_ModifierType();
    public abstract virtual TypeReference get_ElementType();
}
internal class Mono.Cecil.ImplMapTable : SortedTable`1<Row`4<PInvokeAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> x, Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.ImportGenericContext : ValueType {
    private Collection`1<IGenericParameterProvider> stack;
    public bool IsEmpty { get; }
    public ImportGenericContext(IGenericParameterProvider provider);
    public bool get_IsEmpty();
    public void Push(IGenericParameterProvider provider);
    public void Pop();
    public TypeReference MethodParameter(string method, int position);
    public string NormalizeMethodName(MethodReference method);
    public TypeReference TypeParameter(string type, int position);
    private static TypeReference GenericTypeFor(IGenericParameterProvider context);
    public static ImportGenericContext For(IGenericParameterProvider context);
}
internal class Mono.Cecil.ImportScopeTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.InterfaceImplementation : object {
    internal TypeDefinition type;
    internal MetadataToken token;
    private TypeReference interface_type;
    private Collection`1<CustomAttribute> custom_attributes;
    public TypeReference InterfaceType { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MetadataToken MetadataToken { get; public set; }
    internal InterfaceImplementation(TypeReference interfaceType, MetadataToken token);
    public InterfaceImplementation(TypeReference interfaceType);
    public TypeReference get_InterfaceType();
    public void set_InterfaceType(TypeReference value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
}
internal class Mono.Cecil.InterfaceImplementationCollection : Collection`1<InterfaceImplementation> {
    private TypeDefinition type;
    internal InterfaceImplementationCollection(TypeDefinition type);
    internal InterfaceImplementationCollection(TypeDefinition type, int length);
    protected virtual void OnAdd(InterfaceImplementation item, int index);
    protected virtual void OnInsert(InterfaceImplementation item, int index);
    protected virtual void OnSet(InterfaceImplementation item, int index);
    protected virtual void OnRemove(InterfaceImplementation item, int index);
}
internal class Mono.Cecil.InterfaceImplTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public interface Mono.Cecil.IReflectionImporter {
    public abstract virtual AssemblyNameReference ImportReference(AssemblyName reference);
    public abstract virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    public abstract virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public abstract virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}
public interface Mono.Cecil.IReflectionImporterProvider {
    public abstract virtual IReflectionImporter GetReflectionImporter(ModuleDefinition module);
}
internal interface Mono.Cecil.ISecurityDeclarationProvider {
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public abstract virtual bool get_HasSecurityDeclarations();
    public abstract virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
}
internal class Mono.Cecil.LinkedResource : Resource {
    internal Byte[] hash;
    private string file;
    public Byte[] Hash { get; }
    public string File { get; public set; }
    public ResourceType ResourceType { get; }
    public LinkedResource(string name, ManifestResourceAttributes flags);
    public LinkedResource(string name, ManifestResourceAttributes flags, string file);
    public Byte[] get_Hash();
    public string get_File();
    public void set_File(string value);
    public virtual ResourceType get_ResourceType();
}
internal class Mono.Cecil.LocalConstantTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.LocalScopeTable : MetadataTable`1<Row`6<UInt32, UInt32, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.LocalVariableTable : MetadataTable`1<Row`3<VariableAttributes, ushort, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[FlagsAttribute]
public enum Mono.Cecil.ManifestResourceAttributes : Enum {
    public UInt32 value__;
    public static ManifestResourceAttributes VisibilityMask;
    public static ManifestResourceAttributes Public;
    public static ManifestResourceAttributes Private;
}
internal class Mono.Cecil.ManifestResourceTable : MetadataTable`1<Row`4<UInt32, ManifestResourceAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.MarshalInfo : object {
    internal NativeType native;
    public NativeType NativeType { get; public set; }
    public MarshalInfo(NativeType native);
    public NativeType get_NativeType();
    public void set_NativeType(NativeType value);
}
internal class Mono.Cecil.Mdb.MdbReader : object {
    private ModuleDefinition module;
    private MonoSymbolFile symbol_file;
    private Dictionary`2<string, Document> documents;
    public MdbReader(ModuleDefinition module, MonoSymbolFile symFile);
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    private static int ReadCodeSize(MethodDefinition method);
    private static void ReadLocalVariables(MethodEntry entry, ScopeDebugInformation[] scopes);
    private void ReadLineNumbers(MethodEntry entry, MethodDebugInformation info);
    private Document GetDocument(SourceFileEntry file);
    private static ScopeDebugInformation[] ReadScopes(MethodEntry entry, MethodDebugInformation info);
    private static bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope);
    private SequencePoint LineToSequencePoint(LineNumberEntry line);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Mdb.MdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Mdb.MdbWriter : object {
    private ModuleDefinition module;
    private MonoSymbolWriter writer;
    private Dictionary`2<string, SourceFile> source_files;
    public MdbWriter(ModuleDefinition module, string assembly);
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    private SourceFile GetSourceFile(Document document);
    private void Populate(Collection`1<SequencePoint> sequencePoints, Int32[] offsets, Int32[] startRows, Int32[] endRows, Int32[] startCols, Int32[] endCols, SourceFile& file);
    public sealed virtual void Write(MethodDebugInformation info);
    private void WriteRootScope(ScopeDebugInformation scope, MethodDebugInformation info);
    private void WriteScope(ScopeDebugInformation scope, MethodDebugInformation info);
    private void WriteScopes(Collection`1<ScopeDebugInformation> scopes, MethodDebugInformation info);
    private void WriteScopeVariables(ScopeDebugInformation scope);
    public sealed virtual ImageDebugHeader GetDebugHeader();
    public sealed virtual void Write();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Mdb.MdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Mdb.MethodEntryExtensions : object {
    [ExtensionAttribute]
public static bool HasColumnInfo(MethodEntry entry);
    [ExtensionAttribute]
public static bool HasEndInfo(MethodEntry entry);
}
internal class Mono.Cecil.MemberDefinitionCollection`1 : Collection`1<T> {
    private TypeDefinition container;
    internal MemberDefinitionCollection`1(TypeDefinition container);
    internal MemberDefinitionCollection`1(TypeDefinition container, int capacity);
    protected virtual void OnAdd(T item, int index);
    protected sealed virtual void OnSet(T item, int index);
    protected sealed virtual void OnInsert(T item, int index);
    protected sealed virtual void OnRemove(T item, int index);
    protected sealed virtual void OnClear();
    private void Attach(T element);
    private static void Detach(T element);
}
public abstract class Mono.Cecil.MemberReference : object {
    private string name;
    private TypeReference declaring_type;
    internal MetadataToken token;
    internal object projection;
    public string Name { get; public set; }
    public string FullName { get; }
    public TypeReference DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public bool IsWindowsRuntimeProjection { get; }
    internal bool HasImage { get; }
    public ModuleDefinition Module { get; }
    public bool IsDefinition { get; }
    public bool ContainsGenericParameter { get; }
    internal MemberReference(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public bool get_IsWindowsRuntimeProjection();
    internal bool get_HasImage();
    public virtual ModuleDefinition get_Module();
    public virtual bool get_IsDefinition();
    public virtual bool get_ContainsGenericParameter();
    internal string MemberFullName();
    public IMemberDefinition Resolve();
    protected abstract virtual IMemberDefinition ResolveDefinition();
    public virtual string ToString();
}
internal class Mono.Cecil.MemberRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Metadata.BlobHeap : Heap {
    public BlobHeap(Byte[] data);
    public Byte[] Read(UInt32 index);
    public void GetView(UInt32 signature, Byte[]& buffer, Int32& index, Int32& length);
}
internal class Mono.Cecil.Metadata.BlobHeapBuffer : HeapBuffer {
    private Dictionary`2<ByteBuffer, UInt32> blobs;
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public UInt32 GetBlobIndex(ByteBuffer blob);
    private void WriteBlob(ByteBuffer blob);
}
internal enum Mono.Cecil.Metadata.CodedIndex : Enum {
    public int value__;
    public static CodedIndex TypeDefOrRef;
    public static CodedIndex HasConstant;
    public static CodedIndex HasCustomAttribute;
    public static CodedIndex HasFieldMarshal;
    public static CodedIndex HasDeclSecurity;
    public static CodedIndex MemberRefParent;
    public static CodedIndex HasSemantics;
    public static CodedIndex MethodDefOrRef;
    public static CodedIndex MemberForwarded;
    public static CodedIndex Implementation;
    public static CodedIndex CustomAttributeType;
    public static CodedIndex ResolutionScope;
    public static CodedIndex TypeOrMethodDef;
    public static CodedIndex HasCustomDebugInformation;
}
internal class Mono.Cecil.Metadata.DataBuffer : ByteBuffer {
    private int buffer_align;
    public int BufferAlign { get; }
    private void Align(int align);
    public UInt32 AddData(Byte[] data, int align);
    public int get_BufferAlign();
}
internal enum Mono.Cecil.Metadata.ElementType : Enum {
    public byte value__;
    public static ElementType None;
    public static ElementType Void;
    public static ElementType Boolean;
    public static ElementType Char;
    public static ElementType I1;
    public static ElementType U1;
    public static ElementType I2;
    public static ElementType U2;
    public static ElementType I4;
    public static ElementType U4;
    public static ElementType I8;
    public static ElementType U8;
    public static ElementType R4;
    public static ElementType R8;
    public static ElementType String;
    public static ElementType Ptr;
    public static ElementType ByRef;
    public static ElementType ValueType;
    public static ElementType Class;
    public static ElementType Var;
    public static ElementType Array;
    public static ElementType GenericInst;
    public static ElementType TypedByRef;
    public static ElementType I;
    public static ElementType U;
    public static ElementType FnPtr;
    public static ElementType Object;
    public static ElementType SzArray;
    public static ElementType MVar;
    public static ElementType CModReqD;
    public static ElementType CModOpt;
    public static ElementType Internal;
    public static ElementType Modifier;
    public static ElementType Sentinel;
    public static ElementType Pinned;
    public static ElementType Type;
    public static ElementType Boxed;
    public static ElementType Enum;
}
internal class Mono.Cecil.Metadata.GuidHeap : Heap {
    public GuidHeap(Byte[] data);
    public Guid Read(UInt32 index);
}
internal class Mono.Cecil.Metadata.GuidHeapBuffer : HeapBuffer {
    private Dictionary`2<Guid, UInt32> guids;
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public UInt32 GetGuidIndex(Guid guid);
    private void WriteGuid(Guid guid);
}
internal abstract class Mono.Cecil.Metadata.Heap : object {
    public int IndexSize;
    internal Byte[] data;
    protected Heap(Byte[] data);
}
internal abstract class Mono.Cecil.Metadata.HeapBuffer : ByteBuffer {
    public bool IsLarge { get; }
    public bool IsEmpty { get; }
    protected HeapBuffer(int length);
    public bool get_IsLarge();
    public abstract virtual bool get_IsEmpty();
}
internal class Mono.Cecil.Metadata.PdbHeap : Heap {
    public Byte[] Id;
    public UInt32 EntryPoint;
    public long TypeSystemTables;
    public UInt32[] TypeSystemTableRows;
    public PdbHeap(Byte[] data);
    public bool HasTable(Table table);
}
internal class Mono.Cecil.Metadata.PdbHeapBuffer : HeapBuffer {
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
}
internal class Mono.Cecil.Metadata.ResourceBuffer : ByteBuffer {
    public UInt32 AddResource(Byte[] resource);
}
internal class Mono.Cecil.Metadata.Row`2 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    public Row`2(T1 col1, T2 col2);
}
internal class Mono.Cecil.Metadata.Row`3 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    public Row`3(T1 col1, T2 col2, T3 col3);
}
internal class Mono.Cecil.Metadata.Row`4 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    public Row`4(T1 col1, T2 col2, T3 col3, T4 col4);
}
internal class Mono.Cecil.Metadata.Row`5 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    public Row`5(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5);
}
internal class Mono.Cecil.Metadata.Row`6 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    public Row`6(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6);
}
internal class Mono.Cecil.Metadata.Row`9 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    internal T7 Col7;
    internal T8 Col8;
    internal T9 Col9;
    public Row`9(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9);
}
internal class Mono.Cecil.Metadata.RowEqualityComparer : object {
    public sealed virtual bool Equals(Row`2<string, string> x, Row`2<string, string> y);
    public sealed virtual int GetHashCode(Row`2<string, string> obj);
    public sealed virtual bool Equals(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`2<UInt32, UInt32> obj);
    public sealed virtual bool Equals(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`3<UInt32, UInt32, UInt32> obj);
}
internal class Mono.Cecil.Metadata.StringHeap : Heap {
    private Dictionary`2<UInt32, string> strings;
    public StringHeap(Byte[] data);
    public string Read(UInt32 index);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.StringHeapBuffer : HeapBuffer {
    protected Dictionary`2<string, UInt32> strings;
    public bool IsEmpty { get; }
    public sealed virtual bool get_IsEmpty();
    public virtual UInt32 GetStringIndex(string string);
    public UInt32[] WriteStrings();
    private static List`1<KeyValuePair`2<string, UInt32>> SortStrings(Dictionary`2<string, UInt32> strings);
    private static bool IsLowSurrogateChar(int c);
    protected virtual void WriteString(string string);
}
internal enum Mono.Cecil.Metadata.Table : Enum {
    public byte value__;
    public static Table Module;
    public static Table TypeRef;
    public static Table TypeDef;
    public static Table FieldPtr;
    public static Table Field;
    public static Table MethodPtr;
    public static Table Method;
    public static Table ParamPtr;
    public static Table Param;
    public static Table InterfaceImpl;
    public static Table MemberRef;
    public static Table Constant;
    public static Table CustomAttribute;
    public static Table FieldMarshal;
    public static Table DeclSecurity;
    public static Table ClassLayout;
    public static Table FieldLayout;
    public static Table StandAloneSig;
    public static Table EventMap;
    public static Table EventPtr;
    public static Table Event;
    public static Table PropertyMap;
    public static Table PropertyPtr;
    public static Table Property;
    public static Table MethodSemantics;
    public static Table MethodImpl;
    public static Table ModuleRef;
    public static Table TypeSpec;
    public static Table ImplMap;
    public static Table FieldRVA;
    public static Table EncLog;
    public static Table EncMap;
    public static Table Assembly;
    public static Table AssemblyProcessor;
    public static Table AssemblyOS;
    public static Table AssemblyRef;
    public static Table AssemblyRefProcessor;
    public static Table AssemblyRefOS;
    public static Table File;
    public static Table ExportedType;
    public static Table ManifestResource;
    public static Table NestedClass;
    public static Table GenericParam;
    public static Table MethodSpec;
    public static Table GenericParamConstraint;
    public static Table Document;
    public static Table MethodDebugInformation;
    public static Table LocalScope;
    public static Table LocalVariable;
    public static Table LocalConstant;
    public static Table ImportScope;
    public static Table StateMachineMethod;
    public static Table CustomDebugInformation;
}
[DefaultMemberAttribute("Item")]
internal class Mono.Cecil.Metadata.TableHeap : Heap {
    public long Valid;
    public long Sorted;
    public TableInformation[] Tables;
    public TableInformation Item { get; }
    public TableHeap(Byte[] data);
    public TableInformation get_Item(Table table);
    public bool HasTable(Table table);
}
internal class Mono.Cecil.Metadata.TableHeapBuffer : HeapBuffer {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    internal TableInformation[] table_infos;
    internal MetadataTable[] tables;
    private bool large_string;
    private bool large_blob;
    private bool large_guid;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    internal UInt32[] string_offsets;
    public bool IsEmpty { get; }
    public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata);
    public virtual bool get_IsEmpty();
    private int GetTableLength(Table table);
    public TTable GetTable(Table table);
    public void WriteBySize(UInt32 value, int size);
    public void WriteBySize(UInt32 value, bool large);
    public void WriteString(UInt32 string);
    public void WriteBlob(UInt32 blob);
    public void WriteGuid(UInt32 guid);
    public void WriteRID(UInt32 rid, Table table);
    private int GetCodedIndexSize(CodedIndex coded_index);
    public void WriteCodedRID(UInt32 rid, CodedIndex coded_index);
    public void WriteTableHeap();
    private void WriteRowCount();
    private void WriteTables();
    private ulong GetValid();
    public void ComputeTableInformations();
    private void ComputeTableInformations(TableHeapBuffer table_heap);
    private byte GetHeapSizes();
    private byte GetTableHeapVersion();
    public void FixupData(UInt32 data_rva);
}
internal class Mono.Cecil.Metadata.TableInformation : ValueType {
    public UInt32 Offset;
    public UInt32 Length;
    public UInt32 RowSize;
    public bool IsLarge { get; }
    public bool get_IsLarge();
}
internal class Mono.Cecil.Metadata.UserStringHeap : StringHeap {
    public UserStringHeap(Byte[] data);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.UserStringHeapBuffer : StringHeapBuffer {
    public virtual UInt32 GetStringIndex(string string);
    protected virtual void WriteString(string string);
}
internal class Mono.Cecil.MetadataBuilder : object {
    internal ModuleDefinition module;
    internal ISymbolWriterProvider symbol_writer_provider;
    internal ISymbolWriter symbol_writer;
    internal TextMap text_map;
    internal string fq_name;
    internal UInt32 timestamp;
    private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> type_ref_map;
    private Dictionary`2<UInt32, MetadataToken> type_spec_map;
    private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> member_ref_map;
    private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> method_spec_map;
    private Collection`1<GenericParameter> generic_parameters;
    internal CodeWriter code;
    internal DataBuffer data;
    internal ResourceBuffer resources;
    internal StringHeapBuffer string_heap;
    internal GuidHeapBuffer guid_heap;
    internal UserStringHeapBuffer user_string_heap;
    internal BlobHeapBuffer blob_heap;
    internal TableHeapBuffer table_heap;
    internal PdbHeapBuffer pdb_heap;
    internal MetadataToken entry_point;
    internal UInt32 type_rid;
    internal UInt32 field_rid;
    internal UInt32 method_rid;
    internal UInt32 param_rid;
    internal UInt32 property_rid;
    internal UInt32 event_rid;
    internal UInt32 local_variable_rid;
    internal UInt32 local_constant_rid;
    private TypeRefTable type_ref_table;
    private TypeDefTable type_def_table;
    private FieldTable field_table;
    private MethodTable method_table;
    private ParamTable param_table;
    private InterfaceImplTable iface_impl_table;
    private MemberRefTable member_ref_table;
    private ConstantTable constant_table;
    private CustomAttributeTable custom_attribute_table;
    private DeclSecurityTable declsec_table;
    private StandAloneSigTable standalone_sig_table;
    private EventMapTable event_map_table;
    private EventTable event_table;
    private PropertyMapTable property_map_table;
    private PropertyTable property_table;
    private TypeSpecTable typespec_table;
    private MethodSpecTable method_spec_table;
    internal MetadataBuilder metadata_builder;
    private DocumentTable document_table;
    private MethodDebugInformationTable method_debug_information_table;
    private LocalScopeTable local_scope_table;
    private LocalVariableTable local_variable_table;
    private LocalConstantTable local_constant_table;
    private ImportScopeTable import_scope_table;
    private StateMachineMethodTable state_machine_method_table;
    private CustomDebugInformationTable custom_debug_information_table;
    private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> import_scope_map;
    private Dictionary`2<string, MetadataToken> document_map;
    public MetadataBuilder(ModuleDefinition module, string fq_name, UInt32 timestamp, ISymbolWriterProvider symbol_writer_provider);
    public MetadataBuilder(ModuleDefinition module, PortablePdbWriterProvider writer_provider);
    public void SetSymbolWriter(ISymbolWriter writer);
    private TextMap CreateTextMap();
    private TTable GetTable(Table table);
    private UInt32 GetStringIndex(string string);
    private UInt32 GetGuidIndex(Guid guid);
    private UInt32 GetBlobIndex(ByteBuffer blob);
    private UInt32 GetBlobIndex(Byte[] blob);
    public void BuildMetadata();
    private void BuildModule();
    private void BuildAssembly();
    private void BuildModules();
    private void AddAssemblyReferences();
    private void AddModuleReferences();
    private void AddResources();
    private UInt32 AddLinkedResource(LinkedResource resource);
    private UInt32 AddEmbeddedResource(EmbeddedResource resource);
    private void AddExportedTypes();
    private MetadataToken GetExportedTypeScope(ExportedType exported_type);
    private void BuildTypes();
    private void AttachTokens();
    private void AttachTypeToken(TypeDefinition type);
    private void AttachNestedTypesToken(TypeDefinition type);
    private void AttachFieldsToken(TypeDefinition type);
    private void AttachMethodsToken(TypeDefinition type);
    private MetadataToken GetTypeToken(TypeReference type);
    private MetadataToken GetTypeSpecToken(TypeReference type);
    private MetadataToken AddTypeSpecification(TypeReference type, UInt32 row);
    private MetadataToken GetTypeRefToken(TypeReference type);
    private Row`3<UInt32, UInt32, UInt32> CreateTypeRefRow(TypeReference type);
    private MetadataToken GetScopeToken(TypeReference type);
    private static UInt32 MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index);
    private static UInt32 MakeCodedRID(MetadataToken token, CodedIndex index);
    private MetadataToken AddTypeReference(TypeReference type, Row`3<UInt32, UInt32, UInt32> row);
    private void AddTypes();
    private void AddType(TypeDefinition type);
    private void AddGenericParameters(IGenericParameterProvider owner);
    private void AddGenericParameters();
    private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table);
    private void AddInterfaces(TypeDefinition type);
    private void AddLayoutInfo(TypeDefinition type);
    private void AddNestedTypes(TypeDefinition type);
    private void AddFields(TypeDefinition type);
    private void AddField(FieldDefinition field);
    private void AddFieldRVA(FieldDefinition field);
    private void AddFieldLayout(FieldDefinition field);
    private void AddMethods(TypeDefinition type);
    private void AddMethod(MethodDefinition method);
    private void AddParameters(MethodDefinition method);
    private void AddPInvokeInfo(MethodDefinition method);
    private void AddOverrides(MethodDefinition method);
    private static bool RequiresParameterRow(ParameterDefinition parameter);
    private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table);
    private void AddMarshalInfo(IMarshalInfoProvider owner);
    private void AddProperties(TypeDefinition type);
    private void AddProperty(PropertyDefinition property);
    private void AddOtherSemantic(IMetadataTokenProvider owner, Collection`1<MethodDefinition> others);
    private void AddEvents(TypeDefinition type);
    private void AddEvent(EventDefinition event);
    private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method);
    private void AddConstant(IConstantProvider owner, TypeReference type);
    private static ElementType GetConstantType(TypeReference constant_type, object constant);
    private static ElementType GetConstantType(Type type);
    private void AddCustomAttributes(ICustomAttributeProvider owner);
    private void AddSecurityDeclarations(ISecurityDeclarationProvider owner);
    private MetadataToken GetMemberRefToken(MemberReference member);
    private Row`3<UInt32, UInt32, UInt32> CreateMemberRefRow(MemberReference member);
    private MetadataToken AddMemberReference(MemberReference member, Row`3<UInt32, UInt32, UInt32> row);
    private MetadataToken GetMethodSpecToken(MethodSpecification method_spec);
    private void AddMethodSpecification(MethodSpecification method_spec, Row`2<UInt32, UInt32> row);
    private Row`2<UInt32, UInt32> CreateMethodSpecRow(MethodSpecification method_spec);
    private SignatureWriter CreateSignatureWriter();
    private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec);
    public UInt32 AddStandAloneSignature(UInt32 signature);
    public UInt32 GetLocalVariableBlobIndex(Collection`1<VariableDefinition> variables);
    public UInt32 GetCallSiteBlobIndex(CallSite call_site);
    public UInt32 GetConstantTypeBlobIndex(TypeReference constant_type);
    private SignatureWriter GetVariablesSignature(Collection`1<VariableDefinition> variables);
    private SignatureWriter GetConstantTypeSignature(TypeReference constant_type);
    private SignatureWriter GetFieldSignature(FieldReference field);
    private SignatureWriter GetMethodSignature(IMethodSignature method);
    private SignatureWriter GetMemberRefSignature(MemberReference member);
    private SignatureWriter GetPropertySignature(PropertyDefinition property);
    private SignatureWriter GetTypeSpecSignature(TypeReference type);
    private SignatureWriter GetConstantSignature(ElementType type, object value);
    private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute);
    private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration);
    private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner);
    private static Exception CreateForeignMemberException(MemberReference member);
    public MetadataToken LookupToken(IMetadataTokenProvider provider);
    public void AddMethodDebugInformation(MethodDebugInformation method_info);
    private void AddStateMachineMethod(MethodDebugInformation method_info);
    private void AddLocalScope(MethodDebugInformation method_info, ScopeDebugInformation scope);
    private void AddLocalVariables(ScopeDebugInformation scope);
    private void AddLocalConstants(ScopeDebugInformation scope);
    private SignatureWriter GetConstantSignature(ConstantDebugInformation constant);
    public void AddCustomDebugInformations(ICustomDebugInformationProvider provider);
    private void AddStateMachineScopeDebugInformation(ICustomDebugInformationProvider provider, StateMachineScopeDebugInformation state_machine_scope);
    private void AddAsyncMethodBodyDebugInformation(ICustomDebugInformationProvider provider, AsyncMethodBodyDebugInformation async_method);
    private void AddEmbeddedSourceDebugInformation(ICustomDebugInformationProvider provider, EmbeddedSourceDebugInformation embedded_source);
    private void AddSourceLinkDebugInformation(ICustomDebugInformationProvider provider, SourceLinkDebugInformation source_link);
    private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, SignatureWriter signature);
    private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, UInt32 blob_index);
    private UInt32 AddImportScope(ImportDebugInformation import);
    private void AddImportTarget(ImportTarget target, SignatureWriter signature);
    private UInt32 GetUTF8StringBlobIndex(string s);
    public MetadataToken GetDocumentToken(Document document);
    private SignatureWriter GetDocumentNameSignature(Document document);
    private static bool TryGetDocumentNameSeparator(string path, Char& separator);
    private void AddSequencePoints(MethodDebugInformation info);
}
public enum Mono.Cecil.MetadataKind : Enum {
    public int value__;
    public static MetadataKind Ecma335;
    public static MetadataKind WindowsMetadata;
    public static MetadataKind ManagedWindowsMetadata;
}
internal class Mono.Cecil.MetadataReader : ByteBuffer {
    internal Image image;
    internal ModuleDefinition module;
    internal MetadataSystem metadata;
    internal CodeReader code;
    internal IGenericContext context;
    private MetadataReader metadata_reader;
    public MetadataReader(ModuleDefinition module);
    public MetadataReader(Image image, ModuleDefinition module, MetadataReader metadata_reader);
    private int GetCodedIndexSize(CodedIndex index);
    private UInt32 ReadByIndexSize(int size);
    private Byte[] ReadBlob();
    private Byte[] ReadBlob(UInt32 signature);
    private UInt32 ReadBlobIndex();
    private void GetBlobView(UInt32 signature, Byte[]& blob, Int32& index, Int32& count);
    private string ReadString();
    private UInt32 ReadStringIndex();
    private Guid ReadGuid();
    private UInt32 ReadTableIndex(Table table);
    private MetadataToken ReadMetadataToken(CodedIndex index);
    private int MoveTo(Table table);
    private bool MoveTo(Table table, UInt32 row);
    public AssemblyNameDefinition ReadAssemblyNameDefinition();
    public ModuleDefinition Populate(ModuleDefinition module);
    private void InitializeAssemblyReferences();
    public Collection`1<AssemblyNameReference> ReadAssemblyReferences();
    public MethodDefinition ReadEntryPoint();
    public Collection`1<ModuleDefinition> ReadModules();
    private string GetModuleFileName(string name);
    private void InitializeModuleReferences();
    public Collection`1<ModuleReference> ReadModuleReferences();
    public bool HasFileResource();
    public Collection`1<Resource> ReadResources();
    private Row`3<FileAttributes, string, UInt32> ReadFileRecord(UInt32 rid);
    public Byte[] GetManagedResource(UInt32 offset);
    private void PopulateVersionAndFlags(AssemblyNameReference name);
    private void PopulateNameAndCulture(AssemblyNameReference name);
    public TypeDefinitionCollection ReadTypes();
    private void CompleteTypes();
    private void InitializeTypeDefinitions();
    private static bool IsNested(TypeAttributes attributes);
    public bool HasNestedTypes(TypeDefinition type);
    public Collection`1<TypeDefinition> ReadNestedTypes(TypeDefinition type);
    private void InitializeNestedTypes();
    private void AddNestedMapping(UInt32 declaring, UInt32 nested);
    private static Collection`1<TValue> AddMapping(Dictionary`2<TKey, Collection`1<TValue>> cache, TKey key, TValue value);
    private TypeDefinition ReadType(UInt32 rid);
    private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type);
    private Range ReadListRange(UInt32 current_index, Table current, Table target);
    public Row`2<short, int> ReadTypeLayout(TypeDefinition type);
    private void InitializeTypeLayouts();
    public TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    private TypeDefinition ReadTypeDefinition(UInt32 rid);
    private void InitializeTypeReferences();
    public TypeReference GetTypeReference(string scope, string full_name);
    private TypeReference GetTypeReference(UInt32 rid);
    private TypeReference ReadTypeReference(UInt32 rid);
    private IMetadataScope GetTypeReferenceScope(MetadataToken scope);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    private TypeReference GetTypeSpecification(UInt32 rid);
    private SignatureReader ReadSignature(UInt32 signature);
    public bool HasInterfaces(TypeDefinition type);
    public InterfaceImplementationCollection ReadInterfaces(TypeDefinition type);
    private void InitializeInterfaces();
    private void AddInterfaceMapping(UInt32 type, Row`2<UInt32, MetadataToken> interface);
    public Collection`1<FieldDefinition> ReadFields(TypeDefinition type);
    private void ReadField(UInt32 field_rid, Collection`1<FieldDefinition> fields);
    private void InitializeFields();
    private TypeReference ReadFieldType(UInt32 signature);
    public int ReadFieldRVA(FieldDefinition field);
    private Byte[] GetFieldInitializeValue(int size, UInt32 rva);
    private static int GetFieldTypeSize(TypeReference type);
    private void InitializeFieldRVAs();
    public int ReadFieldLayout(FieldDefinition field);
    private void InitializeFieldLayouts();
    public bool HasEvents(TypeDefinition type);
    public Collection`1<EventDefinition> ReadEvents(TypeDefinition type);
    private void ReadEvent(UInt32 event_rid, Collection`1<EventDefinition> events);
    private void InitializeEvents();
    public bool HasProperties(TypeDefinition type);
    public Collection`1<PropertyDefinition> ReadProperties(TypeDefinition type);
    private void ReadProperty(UInt32 property_rid, Collection`1<PropertyDefinition> properties);
    private void InitializeProperties();
    private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method);
    private static EventDefinition GetEvent(TypeDefinition type, MetadataToken token);
    private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token);
    private static TMember GetMember(Collection`1<TMember> members, MetadataToken token);
    private void InitializeMethodSemantics();
    public void ReadMethods(PropertyDefinition property);
    public void ReadMethods(EventDefinition event);
    public void ReadAllSemantics(MethodDefinition method);
    private void ReadAllSemantics(TypeDefinition type);
    public Collection`1<MethodDefinition> ReadMethods(TypeDefinition type);
    private void ReadPointers(Table ptr, Table table, Range range, Collection`1<TMember> members, Action`2<UInt32, Collection`1<TMember>> reader);
    private static bool IsDeleted(IMemberDefinition member);
    private void InitializeMethods();
    private void ReadMethod(UInt32 method_rid, Collection`1<MethodDefinition> methods);
    private void ReadParameters(MethodDefinition method, Range param_range);
    private void ReadParameterPointers(MethodDefinition method, Range range);
    private void ReadParameter(UInt32 param_rid, MethodDefinition method);
    private void ReadMethodSignature(UInt32 signature, IMethodSignature method);
    public PInvokeInfo ReadPInvokeInfo(MethodDefinition method);
    private void InitializePInvokes();
    public bool HasGenericParameters(IGenericParameterProvider provider);
    public Collection`1<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters);
    private void InitializeGenericParameters();
    private Dictionary`2<MetadataToken, Range[]> InitializeRanges(Table table, Func`1<MetadataToken> get_next);
    private static void AddRange(Dictionary`2<MetadataToken, Range[]> ranges, MetadataToken owner, Range range);
    public bool HasGenericConstraints(GenericParameter generic_parameter);
    public GenericParameterConstraintCollection ReadGenericConstraints(GenericParameter generic_parameter);
    private void InitializeGenericConstraints();
    private void AddGenericConstraintMapping(UInt32 generic_parameter, Row`2<UInt32, MetadataToken> constraint);
    public bool HasOverrides(MethodDefinition method);
    public Collection`1<MethodReference> ReadOverrides(MethodDefinition method);
    private void InitializeOverrides();
    private void AddOverrideMapping(UInt32 method_rid, MetadataToken override);
    public MethodBody ReadMethodBody(MethodDefinition method);
    public int ReadCodeSize(MethodDefinition method);
    public CallSite ReadCallSite(MetadataToken token);
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token, MethodDefinition method);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    private FieldDefinition LookupField(UInt32 rid);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    private MethodDefinition LookupMethod(UInt32 rid);
    private MethodSpecification GetMethodSpecification(UInt32 rid);
    private MethodSpecification ReadMethodSpecSignature(UInt32 signature, MethodReference method);
    private MemberReference GetMemberReference(UInt32 rid);
    private MemberReference ReadMemberReference(UInt32 rid);
    private MemberReference ReadTypeMemberReference(MetadataToken type, string name, UInt32 signature);
    private MemberReference ReadMemberReferenceSignature(UInt32 signature, TypeReference declaring_type);
    private MemberReference ReadMethodMemberReference(MetadataToken token, string name, UInt32 signature);
    private void InitializeMemberReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    private void InitializeConstants();
    public TypeReference ReadConstantSignature(MetadataToken token);
    public object ReadConstant(IConstantProvider owner);
    private object ReadConstantValue(ElementType etype, UInt32 signature);
    private string ReadConstantString(UInt32 signature);
    private object ReadConstantPrimitive(ElementType type, UInt32 signature);
    internal void InitializeCustomAttributes();
    public bool HasCustomAttributes(ICustomAttributeProvider owner);
    public Collection`1<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner);
    private void ReadCustomAttributeRange(Range range, Collection`1<CustomAttribute> custom_attributes);
    private static int RangesSize(Range[] ranges);
    public IEnumerable`1<CustomAttribute> GetCustomAttributes();
    public Byte[] ReadCustomAttributeBlob(UInt32 signature);
    public void ReadCustomAttributeSignature(CustomAttribute attribute);
    private void InitializeMarshalInfos();
    public bool HasMarshalInfo(IMarshalInfoProvider owner);
    public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner);
    private void InitializeSecurityDeclarations();
    public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner);
    public Collection`1<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner);
    private void ReadSecurityDeclarationRange(Range range, Collection`1<SecurityDeclaration> security_declarations);
    public Byte[] ReadSecurityDeclarationBlob(UInt32 signature);
    public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration);
    private void ReadXmlSecurityDeclaration(UInt32 signature, SecurityDeclaration declaration);
    public Collection`1<ExportedType> ReadExportedTypes();
    private IMetadataScope GetExportedTypeScope(MetadataToken token);
    private ModuleReference GetModuleReferenceFromFile(MetadataToken token);
    private void InitializeDocuments();
    public Collection`1<SequencePoint> ReadSequencePoints(MethodDefinition method);
    public Document GetDocument(UInt32 rid);
    private void InitializeLocalScopes();
    public ScopeDebugInformation ReadScope(MethodDefinition method);
    private static bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope);
    private ScopeDebugInformation ReadLocalScope(Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32> record);
    private VariableDebugInformation ReadLocalVariable(UInt32 rid);
    private ConstantDebugInformation ReadLocalConstant(UInt32 rid);
    private void InitializeImportScopes();
    public string ReadUTF8StringBlob(UInt32 signature);
    private string ReadUnicodeStringBlob(UInt32 signature);
    private string ReadStringBlob(UInt32 signature, Encoding encoding);
    private ImportTarget ReadImportTarget(SignatureReader signature);
    private void InitializeStateMachineMethods();
    public MethodDefinition ReadStateMachineKickoffMethod(MethodDefinition method);
    private void InitializeCustomDebugInformations();
    public Collection`1<CustomDebugInformation> GetCustomDebugInformation(ICustomDebugInformationProvider provider);
    public Byte[] ReadRawEmbeddedSourceDebugInformation(UInt32 index);
    public Row`2<Byte[], bool> ReadEmbeddedSourceDebugInformation(UInt32 index);
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeGenericParameters>b__106_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeCustomAttributes>b__141_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeSecurityDeclarations>b__152_0();
}
internal class Mono.Cecil.MetadataResolver : object {
    private IAssemblyResolver assembly_resolver;
    public IAssemblyResolver AssemblyResolver { get; }
    public MetadataResolver(IAssemblyResolver assemblyResolver);
    public IAssemblyResolver get_AssemblyResolver();
    public virtual TypeDefinition Resolve(TypeReference type);
    private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference);
    private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type);
    public virtual FieldDefinition Resolve(FieldReference field);
    private FieldDefinition GetField(TypeDefinition type, FieldReference reference);
    private static FieldDefinition GetField(Collection`1<FieldDefinition> fields, FieldReference reference);
    public virtual MethodDefinition Resolve(MethodReference method);
    private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference);
    public static MethodDefinition GetMethod(Collection`1<MethodDefinition> methods, MethodReference reference);
    private static bool AreSame(Collection`1<ParameterDefinition> a, Collection`1<ParameterDefinition> b);
    private static bool IsVarArgCallTo(MethodDefinition method, MethodReference reference);
    private static bool AreSame(TypeSpecification a, TypeSpecification b);
    private static bool AreSame(FunctionPointerType a, FunctionPointerType b);
    private static bool AreSame(ArrayType a, ArrayType b);
    private static bool AreSame(IModifierType a, IModifierType b);
    private static bool AreSame(GenericInstanceType a, GenericInstanceType b);
    private static bool AreSame(GenericParameter a, GenericParameter b);
    private static bool AreSame(TypeReference a, TypeReference b);
}
public enum Mono.Cecil.MetadataScopeType : Enum {
    public int value__;
    public static MetadataScopeType AssemblyNameReference;
    public static MetadataScopeType ModuleReference;
    public static MetadataScopeType ModuleDefinition;
}
internal class Mono.Cecil.MetadataSystem : object {
    internal AssemblyNameReference[] AssemblyReferences;
    internal ModuleReference[] ModuleReferences;
    internal TypeDefinition[] Types;
    internal TypeReference[] TypeReferences;
    internal FieldDefinition[] Fields;
    internal MethodDefinition[] Methods;
    internal MemberReference[] MemberReferences;
    internal Dictionary`2<UInt32, Collection`1<UInt32>> NestedTypes;
    internal Dictionary`2<UInt32, UInt32> ReverseNestedTypes;
    internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> Interfaces;
    internal Dictionary`2<UInt32, Row`2<ushort, UInt32>> ClassLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldRVAs;
    internal Dictionary`2<MetadataToken, UInt32> FieldMarshals;
    internal Dictionary`2<MetadataToken, Row`2<ElementType, UInt32>> Constants;
    internal Dictionary`2<UInt32, Collection`1<MetadataToken>> Overrides;
    internal Dictionary`2<MetadataToken, Range[]> CustomAttributes;
    internal Dictionary`2<MetadataToken, Range[]> SecurityDeclarations;
    internal Dictionary`2<UInt32, Range> Events;
    internal Dictionary`2<UInt32, Range> Properties;
    internal Dictionary`2<UInt32, Row`2<MethodSemanticsAttributes, MetadataToken>> Semantics;
    internal Dictionary`2<UInt32, Row`3<PInvokeAttributes, UInt32, UInt32>> PInvokes;
    internal Dictionary`2<MetadataToken, Range[]> GenericParameters;
    internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> GenericConstraints;
    internal Document[] Documents;
    internal Dictionary`2<UInt32, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>>> LocalScopes;
    internal ImportDebugInformation[] ImportScopes;
    internal Dictionary`2<UInt32, UInt32> StateMachineMethods;
    internal Dictionary`2<MetadataToken, Row`3[]> CustomDebugInformations;
    private static Dictionary`2<string, Row`2<ElementType, bool>> primitive_value_types;
    private static void InitializePrimitives();
    public static void TryProcessPrimitiveTypeReference(TypeReference type);
    public static bool TryGetPrimitiveElementType(TypeDefinition type, ElementType& etype);
    private static bool TryGetPrimitiveData(TypeReference type, Row`2& primitive_data);
    public void Clear();
    public AssemblyNameReference GetAssemblyNameReference(UInt32 rid);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    public void AddTypeDefinition(TypeDefinition type);
    public TypeReference GetTypeReference(UInt32 rid);
    public void AddTypeReference(TypeReference type);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    public void AddFieldDefinition(FieldDefinition field);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    public void AddMethodDefinition(MethodDefinition method);
    public MemberReference GetMemberReference(UInt32 rid);
    public void AddMemberReference(MemberReference member);
    public bool TryGetNestedTypeMapping(TypeDefinition type, Collection`1& mapping);
    public void SetNestedTypeMapping(UInt32 type_rid, Collection`1<UInt32> mapping);
    public bool TryGetReverseNestedTypeMapping(TypeDefinition type, UInt32& declaring);
    public void SetReverseNestedTypeMapping(UInt32 nested, UInt32 declaring);
    public bool TryGetInterfaceMapping(TypeDefinition type, Collection`1& mapping);
    public void SetInterfaceMapping(UInt32 type_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping);
    public void AddPropertiesRange(UInt32 type_rid, Range range);
    public bool TryGetPropertiesRange(TypeDefinition type, Range& range);
    public void AddEventsRange(UInt32 type_rid, Range range);
    public bool TryGetEventsRange(TypeDefinition type, Range& range);
    public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, Range[]& ranges);
    public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, Range[]& ranges);
    public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, Range[]& ranges);
    public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, Collection`1& mapping);
    public void SetGenericConstraintMapping(UInt32 gp_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping);
    public bool TryGetOverrideMapping(MethodDefinition method, Collection`1& mapping);
    public void SetOverrideMapping(UInt32 rid, Collection`1<MetadataToken> mapping);
    public Document GetDocument(UInt32 rid);
    public bool TryGetLocalScopes(MethodDefinition method, Collection`1& scopes);
    public void SetLocalScopes(UInt32 method_rid, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>> records);
    public ImportDebugInformation GetImportScope(UInt32 rid);
    public bool TryGetStateMachineKickOffMethod(MethodDefinition method, UInt32& rid);
    public TypeDefinition GetFieldDeclaringType(UInt32 field_rid);
    public TypeDefinition GetMethodDeclaringType(UInt32 method_rid);
    private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, UInt32 rid, bool field);
}
internal abstract class Mono.Cecil.MetadataTable : object {
    public int Length { get; }
    public bool IsLarge { get; }
    public abstract virtual int get_Length();
    public bool get_IsLarge();
    public abstract virtual void Write(TableHeapBuffer buffer);
    public abstract virtual void Sort();
}
internal abstract class Mono.Cecil.MetadataTable`1 : MetadataTable {
    internal TRow[] rows;
    internal int length;
    public int Length { get; }
    public sealed virtual int get_Length();
    public int AddRow(TRow row);
    private void Grow();
    public virtual void Sort();
}
public class Mono.Cecil.MetadataToken : ValueType {
    private UInt32 token;
    public static MetadataToken Zero;
    public UInt32 RID { get; }
    public TokenType TokenType { get; }
    public MetadataToken(UInt32 token);
    public MetadataToken(TokenType type);
    public MetadataToken(TokenType type, UInt32 rid);
    public MetadataToken(TokenType type, int rid);
    private static MetadataToken();
    public UInt32 get_RID();
    public TokenType get_TokenType();
    public int ToInt32();
    public UInt32 ToUInt32();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetadataToken other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(MetadataToken one, MetadataToken other);
    public static bool op_Inequality(MetadataToken one, MetadataToken other);
    public virtual string ToString();
}
public enum Mono.Cecil.MetadataType : Enum {
    public byte value__;
    public static MetadataType Void;
    public static MetadataType Boolean;
    public static MetadataType Char;
    public static MetadataType SByte;
    public static MetadataType Byte;
    public static MetadataType Int16;
    public static MetadataType UInt16;
    public static MetadataType Int32;
    public static MetadataType UInt32;
    public static MetadataType Int64;
    public static MetadataType UInt64;
    public static MetadataType Single;
    public static MetadataType Double;
    public static MetadataType String;
    public static MetadataType Pointer;
    public static MetadataType ByReference;
    public static MetadataType ValueType;
    public static MetadataType Class;
    public static MetadataType Var;
    public static MetadataType Array;
    public static MetadataType GenericInstance;
    public static MetadataType TypedByReference;
    public static MetadataType IntPtr;
    public static MetadataType UIntPtr;
    public static MetadataType FunctionPointer;
    public static MetadataType Object;
    public static MetadataType MVar;
    public static MetadataType RequiredModifier;
    public static MetadataType OptionalModifier;
    public static MetadataType Sentinel;
    public static MetadataType Pinned;
}
[FlagsAttribute]
public enum Mono.Cecil.MethodAttributes : Enum {
    public ushort value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes CompilerControlled;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PInvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
}
public enum Mono.Cecil.MethodCallingConvention : Enum {
    public byte value__;
    public static MethodCallingConvention Default;
    public static MethodCallingConvention C;
    public static MethodCallingConvention StdCall;
    public static MethodCallingConvention ThisCall;
    public static MethodCallingConvention FastCall;
    public static MethodCallingConvention VarArg;
    public static MethodCallingConvention Unmanaged;
    public static MethodCallingConvention Generic;
}
internal class Mono.Cecil.MethodDebugInformationTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.MethodDefinition : MethodReference {
    private ushort attributes;
    private ushort impl_attributes;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sem_attrs_ready;
    internal MethodSemanticsAttributes sem_attrs;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    internal UInt32 rva;
    internal PInvokeInfo pinvoke;
    private Collection`1<MethodReference> overrides;
    internal MethodBody body;
    internal MethodDebugInformation debug_info;
    internal Collection`1<CustomDebugInformation> custom_infos;
    public string Name { get; public set; }
    public MethodAttributes Attributes { get; public set; }
    public MethodImplAttributes ImplAttributes { get; public set; }
    public MethodSemanticsAttributes SemanticsAttributes { get; public set; }
    internal MethodDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public int RVA { get; }
    public bool HasBody { get; }
    public MethodBody Body { get; public set; }
    public MethodDebugInformation DebugInformation { get; public set; }
    public bool HasPInvokeInfo { get; }
    public PInvokeInfo PInvokeInfo { get; public set; }
    public bool HasOverrides { get; }
    public Collection`1<MethodReference> Overrides { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool HasCustomDebugInformations { get; }
    public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsFinal { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsHideBySig { get; public set; }
    public bool IsReuseSlot { get; public set; }
    public bool IsNewSlot { get; public set; }
    public bool IsCheckAccessOnOverride { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsUnmanagedExport { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsIL { get; public set; }
    public bool IsNative { get; public set; }
    public bool IsRuntime { get; public set; }
    public bool IsUnmanaged { get; public set; }
    public bool IsManaged { get; public set; }
    public bool IsForwardRef { get; public set; }
    public bool IsPreserveSig { get; public set; }
    public bool IsInternalCall { get; public set; }
    public bool IsSynchronized { get; public set; }
    public bool NoInlining { get; public set; }
    public bool NoOptimization { get; public set; }
    public bool AggressiveInlining { get; public set; }
    public bool AggressiveOptimization { get; public set; }
    public bool IsSetter { get; public set; }
    public bool IsGetter { get; public set; }
    public bool IsOther { get; public set; }
    public bool IsAddOn { get; public set; }
    public bool IsRemoveOn { get; public set; }
    public bool IsFire { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsConstructor { get; }
    public bool IsDefinition { get; }
    public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public MethodAttributes get_Attributes();
    public void set_Attributes(MethodAttributes value);
    public MethodImplAttributes get_ImplAttributes();
    public void set_ImplAttributes(MethodImplAttributes value);
    public MethodSemanticsAttributes get_SemanticsAttributes();
    public void set_SemanticsAttributes(MethodSemanticsAttributes value);
    internal MethodDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(MethodDefinitionProjection value);
    internal void ReadSemantics();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public int get_RVA();
    public bool get_HasBody();
    public MethodBody get_Body();
    public void set_Body(MethodBody value);
    public MethodDebugInformation get_DebugInformation();
    public void set_DebugInformation(MethodDebugInformation value);
    public bool get_HasPInvokeInfo();
    public PInvokeInfo get_PInvokeInfo();
    public void set_PInvokeInfo(PInvokeInfo value);
    public bool get_HasOverrides();
    public Collection`1<MethodReference> get_Overrides();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsFinal();
    public void set_IsFinal(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsHideBySig();
    public void set_IsHideBySig(bool value);
    public bool get_IsReuseSlot();
    public void set_IsReuseSlot(bool value);
    public bool get_IsNewSlot();
    public void set_IsNewSlot(bool value);
    public bool get_IsCheckAccessOnOverride();
    public void set_IsCheckAccessOnOverride(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public bool get_IsUnmanagedExport();
    public void set_IsUnmanagedExport(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsIL();
    public void set_IsIL(bool value);
    public bool get_IsNative();
    public void set_IsNative(bool value);
    public bool get_IsRuntime();
    public void set_IsRuntime(bool value);
    public bool get_IsUnmanaged();
    public void set_IsUnmanaged(bool value);
    public bool get_IsManaged();
    public void set_IsManaged(bool value);
    public bool get_IsForwardRef();
    public void set_IsForwardRef(bool value);
    public bool get_IsPreserveSig();
    public void set_IsPreserveSig(bool value);
    public bool get_IsInternalCall();
    public void set_IsInternalCall(bool value);
    public bool get_IsSynchronized();
    public void set_IsSynchronized(bool value);
    public bool get_NoInlining();
    public void set_NoInlining(bool value);
    public bool get_NoOptimization();
    public void set_NoOptimization(bool value);
    public bool get_AggressiveInlining();
    public void set_AggressiveInlining(bool value);
    public bool get_AggressiveOptimization();
    public void set_AggressiveOptimization(bool value);
    public bool get_IsSetter();
    public void set_IsSetter(bool value);
    public bool get_IsGetter();
    public void set_IsGetter(bool value);
    public bool get_IsOther();
    public void set_IsOther(bool value);
    public bool get_IsAddOn();
    public void set_IsAddOn(bool value);
    public bool get_IsRemoveOn();
    public void set_IsRemoveOn(bool value);
    public bool get_IsFire();
    public void set_IsFire(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public bool get_IsConstructor();
    public virtual bool get_IsDefinition();
    public virtual MethodDefinition Resolve();
}
internal class Mono.Cecil.MethodDefinitionProjection : object {
    public MethodAttributes Attributes;
    public MethodImplAttributes ImplAttributes;
    public string Name;
    public MethodDefinitionTreatment Treatment;
    public MethodDefinitionProjection(MethodDefinition method, MethodDefinitionTreatment treatment);
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodDefinitionTreatment : Enum {
    public int value__;
    public static MethodDefinitionTreatment None;
    public static MethodDefinitionTreatment Abstract;
    public static MethodDefinitionTreatment Private;
    public static MethodDefinitionTreatment Public;
    public static MethodDefinitionTreatment Runtime;
    public static MethodDefinitionTreatment InternalCall;
}
[FlagsAttribute]
public enum Mono.Cecil.MethodImplAttributes : Enum {
    public ushort value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes AggressiveOptimization;
}
internal class Mono.Cecil.MethodImplTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.MethodReference : MemberReference {
    internal ParameterDefinitionCollection parameters;
    private MethodReturnType return_type;
    private bool has_this;
    private bool explicit_this;
    private MethodCallingConvention calling_convention;
    internal Collection`1<GenericParameter> generic_parameters;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    public MethodReference(string name, TypeReference returnType);
    public MethodReference(string name, TypeReference returnType, TypeReference declaringType);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    public virtual MethodReference GetElementMethod();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual MethodDefinition Resolve();
}
internal class Mono.Cecil.MethodReferenceComparer : EqualityComparer`1<MethodReference> {
    [ThreadStaticAttribute]
private static List`1<MethodReference> xComparisonStack;
    [ThreadStaticAttribute]
private static List`1<MethodReference> yComparisonStack;
    public virtual bool Equals(MethodReference x, MethodReference y);
    public virtual int GetHashCode(MethodReference obj);
    public static bool AreEqual(MethodReference x, MethodReference y);
    public static bool AreSignaturesEqual(MethodReference x, MethodReference y, TypeComparisonMode comparisonMode);
    public static int GetHashCodeFor(MethodReference obj);
}
public class Mono.Cecil.MethodReturnType : object {
    internal IMethodSignature method;
    internal ParameterDefinition parameter;
    private TypeReference return_type;
    public IMethodSignature Method { get; }
    public TypeReference ReturnType { get; public set; }
    internal ParameterDefinition Parameter { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ParameterAttributes Attributes { get; public set; }
    public string Name { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasDefault { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public MethodReturnType(IMethodSignature method);
    public IMethodSignature get_Method();
    public TypeReference get_ReturnType();
    public void set_ReturnType(TypeReference value);
    internal ParameterDefinition get_Parameter();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
}
[FlagsAttribute]
public enum Mono.Cecil.MethodSemanticsAttributes : Enum {
    public ushort value__;
    public static MethodSemanticsAttributes None;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
internal class Mono.Cecil.MethodSemanticsTable : SortedTable`1<Row`3<MethodSemanticsAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<MethodSemanticsAttributes, UInt32, UInt32> x, Row`3<MethodSemanticsAttributes, UInt32, UInt32> y);
}
internal abstract class Mono.Cecil.MethodSpecification : MethodReference {
    private MethodReference method;
    public MethodReference ElementMethod { get; }
    public string Name { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public ModuleDefinition Module { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool ContainsGenericParameter { get; }
    internal MethodSpecification(MethodReference method);
    public MethodReference get_ElementMethod();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual ModuleDefinition get_Module();
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    public virtual bool get_ContainsGenericParameter();
    public sealed virtual MethodReference GetElementMethod();
}
internal class Mono.Cecil.MethodSpecTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MethodTable : MetadataTable`1<Row`6<UInt32, MethodImplAttributes, MethodAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Mixin : object {
    public static Version ZeroVersion;
    public static int NotResolvedMarker;
    public static int NoDataMarker;
    internal static object NoValue;
    internal static object NotResolved;
    public static string mscorlib;
    public static string system_runtime;
    public static string system_private_corelib;
    public static string netstandard;
    public static int TableCount;
    public static int CodedIndexCount;
    private static Mixin();
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] self);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Collection`1<T> self);
    [ExtensionAttribute]
public static T[] Resize(T[] self, int length);
    [ExtensionAttribute]
public static T[] Add(T[] self, T item);
    public static Version CheckVersion(Version version);
    [ExtensionAttribute]
public static bool TryGetUniqueDocument(MethodDebugInformation info, Document& document);
    [ExtensionAttribute]
public static void ResolveConstant(IConstantProvider self, Object& constant, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasCustomAttributes(ICustomAttributeProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool ContainsGenericParameter(IGenericInstance self);
    [ExtensionAttribute]
public static void GenericInstanceFullName(IGenericInstance self, StringBuilder builder);
    [ExtensionAttribute]
public static bool GetHasGenericParameters(IGenericParameterProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<GenericParameter> GetGenericParameters(IGenericParameterProvider self, Collection`1& collection, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasMarshalInfo(IMarshalInfoProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static MarshalInfo GetMarshalInfo(IMarshalInfoProvider self, MarshalInfo& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetAttributes(UInt32 self, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetAttributes(UInt32 self, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetAttributes(ushort self, ushort attributes);
    [ExtensionAttribute]
public static ushort SetAttributes(ushort self, ushort attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(ushort self, ushort mask, UInt32 attributes);
    [ExtensionAttribute]
public static ushort SetMaskedAttributes(ushort self, ushort mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool HasImplicitThis(IMethodSignature self);
    [ExtensionAttribute]
public static void MethodSignatureFullName(IMethodSignature self, StringBuilder builder);
    public static void CheckModule(ModuleDefinition module);
    [ExtensionAttribute]
public static bool TryGetAssemblyNameReference(ModuleDefinition module, AssemblyNameReference name_reference, AssemblyNameReference& assembly_reference);
    private static bool Equals(Byte[] a, Byte[] b);
    private static bool Equals(T a, T b);
    private static bool Equals(AssemblyNameReference a, AssemblyNameReference b);
    [ExtensionAttribute]
public static ParameterDefinition GetParameter(MethodBody self, int index);
    [ExtensionAttribute]
public static VariableDefinition GetVariable(MethodBody self, int index);
    [ExtensionAttribute]
public static bool GetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics);
    [ExtensionAttribute]
public static void SetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics, bool value);
    [ExtensionAttribute]
public static bool IsVarArg(IMethodSignature self);
    [ExtensionAttribute]
public static int GetSentinelPosition(IMethodSignature self);
    public static void CheckName(object name);
    public static void CheckName(string name);
    public static void CheckFileName(string fileName);
    public static void CheckFullName(string fullName);
    public static void CheckStream(object stream);
    public static void CheckWriteSeek(Stream stream);
    public static void CheckReadSeek(Stream stream);
    public static void CheckType(object type);
    public static void CheckType(object type, Argument argument);
    public static void CheckField(object field);
    public static void CheckMethod(object method);
    public static void CheckParameters(object parameters);
    public static UInt32 GetTimestamp();
    [ExtensionAttribute]
public static bool HasImage(ModuleDefinition self);
    [ExtensionAttribute]
public static string GetFileName(Stream self);
    [ExtensionAttribute]
public static TargetRuntime ParseRuntime(string self);
    [ExtensionAttribute]
public static string RuntimeVersionString(TargetRuntime runtime);
    [ExtensionAttribute]
public static bool IsWindowsMetadata(ModuleDefinition module);
    [ExtensionAttribute]
public static Byte[] ReadAll(Stream self);
    public static void Read(object o);
    [ExtensionAttribute]
public static bool GetHasSecurityDeclarations(ISecurityDeclarationProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<SecurityDeclaration> GetSecurityDeclarations(ISecurityDeclarationProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
    [ExtensionAttribute]
public static TypeDefinition GetNestedType(TypeDefinition self, string fullname);
    [ExtensionAttribute]
public static bool IsPrimitive(ElementType self);
    [ExtensionAttribute]
public static string TypeFullName(TypeReference self);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference self, string namespace, string name);
    [ExtensionAttribute]
public static bool IsTypeSpecification(TypeReference type);
    [ExtensionAttribute]
public static TypeDefinition CheckedResolve(TypeReference self);
    [ExtensionAttribute]
public static bool TryGetCoreLibraryReference(ModuleDefinition module, AssemblyNameReference& reference);
    [ExtensionAttribute]
public static bool IsCoreLibrary(ModuleDefinition module);
    [ExtensionAttribute]
public static void KnownValueType(TypeReference type);
    private static bool IsCoreLibrary(AssemblyNameReference reference);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetCodeViewEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetDeterministicEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeader AddDeterministicEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetEmbeddedPortablePdbEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetPdbChecksumEntry(ImageDebugHeader header);
    [ExtensionAttribute]
private static ImageDebugHeaderEntry GetEntry(ImageDebugHeader header, ImageDebugType type);
    public static string GetPdbFileName(string assemblyFileName);
    public static string GetMdbFileName(string assemblyFileName);
    public static bool IsPortablePdb(string fileName);
    public static bool IsPortablePdb(Stream stream);
    [ExtensionAttribute]
public static UInt32 ReadCompressedUInt32(Byte[] data, Int32& position);
    [ExtensionAttribute]
public static MetadataToken GetMetadataToken(CodedIndex self, UInt32 data);
    [ExtensionAttribute]
public static UInt32 CompressMetadataToken(CodedIndex self, MetadataToken token);
    [ExtensionAttribute]
public static int GetSize(CodedIndex self, Func`2<Table, int> counter);
    [ExtensionAttribute]
public static RSA CreateRSA(WriterParameters writer_parameters);
    private static bool TryGetKeyContainer(ISerializable key_pair, Byte[]& key, String& key_container);
}
[FlagsAttribute]
public enum Mono.Cecil.ModuleAttributes : Enum {
    public int value__;
    public static ModuleAttributes ILOnly;
    public static ModuleAttributes Required32Bit;
    public static ModuleAttributes ILLibrary;
    public static ModuleAttributes StrongNameSigned;
    public static ModuleAttributes Preferred32Bit;
}
[FlagsAttribute]
public enum Mono.Cecil.ModuleCharacteristics : Enum {
    public int value__;
    public static ModuleCharacteristics HighEntropyVA;
    public static ModuleCharacteristics DynamicBase;
    public static ModuleCharacteristics NoSEH;
    public static ModuleCharacteristics NXCompat;
    public static ModuleCharacteristics AppContainer;
    public static ModuleCharacteristics TerminalServerAware;
}
public class Mono.Cecil.ModuleDefinition : ModuleReference {
    internal Image Image;
    internal MetadataSystem MetadataSystem;
    internal ReadingMode ReadingMode;
    internal ISymbolReaderProvider SymbolReaderProvider;
    internal ISymbolReader symbol_reader;
    internal Disposable`1<IAssemblyResolver> assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    internal TypeSystem type_system;
    internal MetadataReader reader;
    private string file_name;
    internal string runtime_version;
    internal ModuleKind kind;
    private WindowsRuntimeProjections projections;
    private MetadataKind metadata_kind;
    private TargetRuntime runtime;
    private TargetArchitecture architecture;
    private ModuleAttributes attributes;
    private ModuleCharacteristics characteristics;
    private Guid mvid;
    internal ushort linker_version;
    internal ushort subsystem_major;
    internal ushort subsystem_minor;
    internal UInt32 timestamp;
    internal AssemblyDefinition assembly;
    private MethodDefinition entry_point;
    private bool entry_point_set;
    internal IReflectionImporter reflection_importer;
    internal IMetadataImporter metadata_importer;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<AssemblyNameReference> references;
    private Collection`1<ModuleReference> modules;
    private Collection`1<Resource> resources;
    private Collection`1<ExportedType> exported_types;
    private TypeDefinitionCollection types;
    internal Collection`1<CustomDebugInformation> custom_infos;
    internal MetadataBuilder metadata_builder;
    private object module_lock;
    public bool IsMain { get; }
    public ModuleKind Kind { get; public set; }
    public MetadataKind MetadataKind { get; public set; }
    internal WindowsRuntimeProjections Projections { get; }
    public TargetRuntime Runtime { get; public set; }
    public string RuntimeVersion { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public ModuleAttributes Attributes { get; public set; }
    public ModuleCharacteristics Characteristics { get; public set; }
    [ObsoleteAttribute("Use FileName")]
public string FullyQualifiedName { get; }
    public string FileName { get; }
    public Guid Mvid { get; public set; }
    internal bool HasImage { get; }
    public bool HasSymbols { get; }
    public ISymbolReader SymbolReader { get; }
    public MetadataScopeType MetadataScopeType { get; }
    public AssemblyDefinition Assembly { get; }
    internal IReflectionImporter ReflectionImporter { get; }
    internal IMetadataImporter MetadataImporter { get; }
    public IAssemblyResolver AssemblyResolver { get; }
    public IMetadataResolver MetadataResolver { get; }
    public TypeSystem TypeSystem { get; }
    public bool HasAssemblyReferences { get; }
    public Collection`1<AssemblyNameReference> AssemblyReferences { get; }
    public bool HasModuleReferences { get; }
    public Collection`1<ModuleReference> ModuleReferences { get; }
    public bool HasResources { get; }
    public Collection`1<Resource> Resources { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasTypes { get; }
    public Collection`1<TypeDefinition> Types { get; }
    public bool HasExportedTypes { get; }
    public Collection`1<ExportedType> ExportedTypes { get; }
    public MethodDefinition EntryPoint { get; public set; }
    public bool HasCustomDebugInformations { get; }
    public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    internal object SyncRoot { get; }
    public bool HasDebugHeader { get; }
    internal ModuleDefinition(Image image);
    public bool get_IsMain();
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public MetadataKind get_MetadataKind();
    public void set_MetadataKind(MetadataKind value);
    internal WindowsRuntimeProjections get_Projections();
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public string get_RuntimeVersion();
    public void set_RuntimeVersion(string value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public ModuleAttributes get_Attributes();
    public void set_Attributes(ModuleAttributes value);
    public ModuleCharacteristics get_Characteristics();
    public void set_Characteristics(ModuleCharacteristics value);
    public string get_FullyQualifiedName();
    public string get_FileName();
    public Guid get_Mvid();
    public void set_Mvid(Guid value);
    internal bool get_HasImage();
    public bool get_HasSymbols();
    public ISymbolReader get_SymbolReader();
    public virtual MetadataScopeType get_MetadataScopeType();
    public AssemblyDefinition get_Assembly();
    internal IReflectionImporter get_ReflectionImporter();
    internal IMetadataImporter get_MetadataImporter();
    public IAssemblyResolver get_AssemblyResolver();
    public IMetadataResolver get_MetadataResolver();
    public TypeSystem get_TypeSystem();
    public bool get_HasAssemblyReferences();
    public Collection`1<AssemblyNameReference> get_AssemblyReferences();
    public bool get_HasModuleReferences();
    public Collection`1<ModuleReference> get_ModuleReferences();
    public bool get_HasResources();
    public Collection`1<Resource> get_Resources();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasTypes();
    public Collection`1<TypeDefinition> get_Types();
    public bool get_HasExportedTypes();
    public Collection`1<ExportedType> get_ExportedTypes();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
    public sealed virtual void Dispose();
    public bool HasTypeReference(string fullName);
    public bool HasTypeReference(string scope, string fullName);
    public bool TryGetTypeReference(string fullName, TypeReference& type);
    public bool TryGetTypeReference(string scope, string fullName, TypeReference& type);
    private TypeReference GetTypeReference(string scope, string fullname);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    public IEnumerable`1<CustomAttribute> GetCustomAttributes();
    public TypeReference GetType(string fullName, bool runtimeName);
    public TypeDefinition GetType(string fullName);
    public TypeDefinition GetType(string namespace, string name);
    public IEnumerable`1<TypeDefinition> GetTypes();
    [IteratorStateMachineAttribute("Mono.Cecil.ModuleDefinition/<GetTypes>d__134")]
private static IEnumerable`1<TypeDefinition> GetTypes(Collection`1<TypeDefinition> types);
    private TypeDefinition GetNestedType(string fullname);
    internal FieldDefinition Resolve(FieldReference field);
    internal MethodDefinition Resolve(MethodReference method);
    internal TypeDefinition Resolve(TypeReference type);
    private static void CheckContext(IGenericParameterProvider context, ModuleDefinition module);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(Type type);
    public TypeReference ImportReference(Type type);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(Type type, IGenericParameterProvider context);
    public TypeReference ImportReference(Type type, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldInfo field);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldInfo field, IGenericParameterProvider context);
    public FieldReference ImportReference(FieldInfo field);
    public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodBase method);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodBase method, IGenericParameterProvider context);
    public MethodReference ImportReference(MethodBase method);
    public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(TypeReference type);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(TypeReference type, IGenericParameterProvider context);
    public TypeReference ImportReference(TypeReference type);
    public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldReference field);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldReference field, IGenericParameterProvider context);
    public FieldReference ImportReference(FieldReference field);
    public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodReference method);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodReference method, IGenericParameterProvider context);
    public MethodReference ImportReference(MethodReference method);
    public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
    public IMetadataTokenProvider LookupToken(int token);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    public void ImmediateRead();
    internal object get_SyncRoot();
    internal void Read(TItem item, Action`2<TItem, MetadataReader> read);
    internal TRet Read(TItem item, Func`3<TItem, MetadataReader, TRet> read);
    internal TRet Read(TRet& variable, TItem item, Func`3<TItem, MetadataReader, TRet> read);
    public bool get_HasDebugHeader();
    public ImageDebugHeader GetDebugHeader();
    public static ModuleDefinition CreateModule(string name, ModuleKind kind);
    public static ModuleDefinition CreateModule(string name, ModuleParameters parameters);
    private static AssemblyNameDefinition CreateAssemblyName(string name);
    public void ReadSymbols();
    public void ReadSymbols(ISymbolReader reader);
    public void ReadSymbols(ISymbolReader reader, bool throwIfSymbolsAreNotMaching);
    public static ModuleDefinition ReadModule(string fileName);
    public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters);
    private static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share);
    public static ModuleDefinition ReadModule(Stream stream);
    public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters);
    private static ModuleDefinition ReadModule(Disposable`1<Stream> stream, string fileName, ReaderParameters parameters);
    public void Write(string fileName);
    public void Write(string fileName, WriterParameters parameters);
    public void Write();
    public void Write(WriterParameters parameters);
    public void Write(Stream stream);
    public void Write(Stream stream, WriterParameters parameters);
}
public enum Mono.Cecil.ModuleKind : Enum {
    public int value__;
    public static ModuleKind Dll;
    public static ModuleKind Console;
    public static ModuleKind Windows;
    public static ModuleKind NetModule;
}
public class Mono.Cecil.ModuleParameters : object {
    private ModuleKind kind;
    private TargetRuntime runtime;
    private Nullable`1<UInt32> timestamp;
    private TargetArchitecture architecture;
    private IAssemblyResolver assembly_resolver;
    private IMetadataResolver metadata_resolver;
    private IMetadataImporterProvider metadata_importer_provider;
    private IReflectionImporterProvider reflection_importer_provider;
    public ModuleKind Kind { get; public set; }
    public TargetRuntime Runtime { get; public set; }
    public Nullable`1<UInt32> Timestamp { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public IMetadataImporterProvider MetadataImporterProvider { get; public set; }
    public IReflectionImporterProvider ReflectionImporterProvider { get; public set; }
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public Nullable`1<UInt32> get_Timestamp();
    public void set_Timestamp(Nullable`1<UInt32> value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public IMetadataImporterProvider get_MetadataImporterProvider();
    public void set_MetadataImporterProvider(IMetadataImporterProvider value);
    public IReflectionImporterProvider get_ReflectionImporterProvider();
    public void set_ReflectionImporterProvider(IReflectionImporterProvider value);
    private static TargetRuntime GetCurrentRuntime();
}
internal abstract class Mono.Cecil.ModuleReader : object {
    protected ModuleDefinition module;
    protected ModuleReader(Image image, ReadingMode mode);
    protected abstract virtual void ReadModule();
    public abstract virtual void ReadSymbols(ModuleDefinition module);
    protected void ReadModuleManifest(MetadataReader reader);
    private void ReadAssembly(MetadataReader reader);
    public static ModuleDefinition CreateModule(Image image, ReaderParameters parameters);
    private static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters);
    private static void GetMetadataKind(ModuleDefinition module, ReaderParameters parameters);
    private static ModuleReader CreateModuleReader(Image image, ReadingMode mode);
}
public class Mono.Cecil.ModuleReference : object {
    private string name;
    internal MetadataToken token;
    public string Name { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ModuleReference(string name);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public virtual MetadataScopeType get_MetadataScopeType();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.ModuleRefTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.ModuleTable : OneRowTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal static class Mono.Cecil.ModuleWriter : object {
    public static void WriteModule(ModuleDefinition module, Disposable`1<Stream> stream, WriterParameters parameters);
    private static void Write(ModuleDefinition module, Disposable`1<Stream> stream, WriterParameters parameters);
    private static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata);
    private static ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, WriterParameters parameters);
    private static void ComputeDeterministicMvid(ImageWriter writer, ModuleDefinition module);
}
public enum Mono.Cecil.NativeType : Enum {
    public int value__;
    public static NativeType None;
    public static NativeType Boolean;
    public static NativeType I1;
    public static NativeType U1;
    public static NativeType I2;
    public static NativeType U2;
    public static NativeType I4;
    public static NativeType U4;
    public static NativeType I8;
    public static NativeType U8;
    public static NativeType R4;
    public static NativeType R8;
    public static NativeType LPStr;
    public static NativeType Int;
    public static NativeType UInt;
    public static NativeType Func;
    public static NativeType Array;
    public static NativeType Currency;
    public static NativeType BStr;
    public static NativeType LPWStr;
    public static NativeType LPTStr;
    public static NativeType FixedSysString;
    public static NativeType IUnknown;
    public static NativeType IDispatch;
    public static NativeType Struct;
    public static NativeType IntF;
    public static NativeType SafeArray;
    public static NativeType FixedArray;
    public static NativeType ByValStr;
    public static NativeType ANSIBStr;
    public static NativeType TBStr;
    public static NativeType VariantBool;
    public static NativeType ASAny;
    public static NativeType LPStruct;
    public static NativeType CustomMarshaler;
    public static NativeType Error;
    public static NativeType Max;
}
internal class Mono.Cecil.NestedClassTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal abstract class Mono.Cecil.OneRowTable`1 : MetadataTable {
    internal TRow row;
    public int Length { get; }
    public sealed virtual int get_Length();
    public sealed virtual void Sort();
}
internal class Mono.Cecil.OptionalModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsOptionalModifier { get; }
    public bool ContainsGenericParameter { get; }
    public OptionalModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_ContainsGenericParameter();
}
[FlagsAttribute]
public enum Mono.Cecil.ParameterAttributes : Enum {
    public ushort value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Unused;
}
public class Mono.Cecil.ParameterDefinition : ParameterReference {
    private ushort attributes;
    internal IMethodSignature method;
    private object constant;
    private Collection`1<CustomAttribute> custom_attributes;
    private MarshalInfo marshal_info;
    public ParameterAttributes Attributes { get; public set; }
    public IMethodSignature Method { get; }
    public int Sequence { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public bool IsIn { get; public set; }
    public bool IsOut { get; public set; }
    public bool IsLcid { get; public set; }
    public bool IsReturnValue { get; public set; }
    public bool IsOptional { get; public set; }
    public bool HasDefault { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    internal ParameterDefinition(TypeReference parameterType, IMethodSignature method);
    public ParameterDefinition(TypeReference parameterType);
    public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public IMethodSignature get_Method();
    public int get_Sequence();
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsIn();
    public void set_IsIn(bool value);
    public bool get_IsOut();
    public void set_IsOut(bool value);
    public bool get_IsLcid();
    public void set_IsLcid(bool value);
    public bool get_IsReturnValue();
    public void set_IsReturnValue(bool value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParameterDefinitionCollection : Collection`1<ParameterDefinition> {
    private IMethodSignature method;
    internal ParameterDefinitionCollection(IMethodSignature method);
    internal ParameterDefinitionCollection(IMethodSignature method, int capacity);
    protected virtual void OnAdd(ParameterDefinition item, int index);
    protected virtual void OnInsert(ParameterDefinition item, int index);
    protected virtual void OnSet(ParameterDefinition item, int index);
    protected virtual void OnRemove(ParameterDefinition item, int index);
}
public abstract class Mono.Cecil.ParameterReference : object {
    private string name;
    internal int index;
    protected TypeReference parameter_type;
    internal MetadataToken token;
    public string Name { get; public set; }
    public int Index { get; }
    public TypeReference ParameterType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    internal ParameterReference(string name, TypeReference parameterType);
    public string get_Name();
    public void set_Name(string value);
    public int get_Index();
    public TypeReference get_ParameterType();
    public void set_ParameterType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
    public abstract virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParamTable : MetadataTable`1<Row`3<ParameterAttributes, ushort, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.Pdb.CustomMetadataType : Enum {
    public byte value__;
    public static CustomMetadataType UsingInfo;
    public static CustomMetadataType ForwardInfo;
    public static CustomMetadataType IteratorScopes;
    public static CustomMetadataType ForwardIterator;
}
internal class Mono.Cecil.Pdb.CustomMetadataWriter : object {
    private SymWriter sym_writer;
    private MemoryStream stream;
    private BinaryStreamWriter writer;
    private int count;
    private static byte version;
    public CustomMetadataWriter(SymWriter sym_writer);
    public void WriteUsingInfo(ImportDebugInformation import_info);
    public void WriteForwardInfo(MetadataToken import_parent);
    public void WriteIteratorScopes(StateMachineScopeDebugInformation state_machine, MethodDebugInformation debug_info);
    public void WriteForwardIterator(TypeReference type);
    private void Write(CustomMetadataType type, Action write);
    public void WriteCustomMetadata();
    public sealed virtual void Dispose();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
internal interface Mono.Cecil.Pdb.IMetaDataEmit {
    public abstract virtual void SetModuleProps(string szName);
    public abstract virtual void Save(string szFile, UInt32 dwSaveFlags);
    public abstract virtual void SaveToStream(IntPtr pIStream, UInt32 dwSaveFlags);
    public abstract virtual UInt32 GetSaveSize(UInt32 fSave);
    public abstract virtual UInt32 DefineTypeDef(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public abstract virtual UInt32 DefineNestedType(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements, UInt32 tdEncloser);
    public abstract virtual void SetHandler(object pUnk);
    public abstract virtual UInt32 DefineMethod(UInt32 td, IntPtr zName, UInt32 dwMethodFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    public abstract virtual UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, IntPtr szName);
    public abstract virtual UInt32 DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    public abstract virtual UInt32 DefineMemberRef(UInt32 tkImport, string szName, IntPtr pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    public abstract virtual UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public abstract virtual void SetClassLayout(UInt32 td, UInt32 dwPackSize, IntPtr rFieldOffsets, UInt32 ulClassSize);
    public abstract virtual void DeleteClassLayout(UInt32 td);
    public abstract virtual void SetFieldMarshal(UInt32 tk, IntPtr pvNativeType, UInt32 cbNativeType);
    public abstract virtual void DeleteFieldMarshal(UInt32 tk);
    public abstract virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public abstract virtual void SetRVA(UInt32 md, UInt32 ulRVA);
    public abstract virtual UInt32 GetTokenFromSig(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual UInt32 DefineModuleRef(string szName);
    public abstract virtual void SetParent(UInt32 mr, UInt32 tk);
    public abstract virtual UInt32 GetTokenFromTypeSpec(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual void SaveToMemory(IntPtr pbData, UInt32 cbData);
    public abstract virtual UInt32 DefineUserString(string szString, UInt32 cchString);
    public abstract virtual void DeleteToken(UInt32 tkObj);
    public abstract virtual void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public abstract virtual void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public abstract virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public abstract virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void DeletePinvokeMap(UInt32 tk);
    public abstract virtual UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual void SetCustomAttributeValue(UInt32 pcv, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, IntPtr pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public abstract virtual UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public abstract virtual void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    public abstract virtual void ApplyEditAndContinue(object pImport);
    public abstract virtual UInt32 TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, UInt32 cbTranslatedSigMax);
    public abstract virtual void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    public abstract virtual void SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    public abstract virtual void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    public abstract virtual void MergeEnd();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
internal interface Mono.Cecil.Pdb.IMetaDataImport {
    public abstract virtual void CloseEnum(UInt32 hEnum);
    public abstract virtual UInt32 CountEnum(UInt32 hEnum);
    public abstract virtual void ResetEnum(UInt32 hEnum, UInt32 ulPos);
    public abstract virtual UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    public abstract virtual UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    public abstract virtual UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    public abstract virtual UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    public abstract virtual Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    public abstract virtual UInt32 GetModuleFromScope();
    public abstract virtual UInt32 GetTypeDefProps(UInt32 td, Char* szTypeDef, UInt32 cchTypeDef, UInt32* pchTypeDef, UInt32* pdwTypeDefFlags, UInt32* ptkExtends);
    public abstract virtual UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    public abstract virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public abstract virtual UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, IntPtr rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumFields(UInt32& phEnum, UInt32 cl, IntPtr rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    public abstract virtual UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    public abstract virtual UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    public abstract virtual UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 GetMethodProps(UInt32 mb, UInt32* pClass, Char* szMethod, UInt32 cchMethod, UInt32* pchMethod, UInt32* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, UInt32* pulCodeRVA, UInt32* pdwImplFlags);
    public abstract virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, IntPtr& ppvSigBlob);
    public abstract virtual UInt32 EnumProperties(UInt32& phEnum, UInt32 td, IntPtr rProperties, UInt32 cMax);
    public abstract virtual UInt32 EnumEvents(UInt32& phEnum, UInt32 td, IntPtr rEvents, UInt32 cMax);
    public abstract virtual UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    public abstract virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    public abstract virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, IntPtr rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    public abstract virtual UInt32 GetFieldMarshal(UInt32 tk, IntPtr& ppvNativeType);
    public abstract virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public abstract virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, IntPtr& ppvPermission);
    public abstract virtual UInt32 GetSigFromToken(UInt32 mdSig, IntPtr& ppvSig);
    public abstract virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    public abstract virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, IntPtr& ppvSig);
    public abstract virtual UInt32 GetNameFromToken(UInt32 tk);
    public abstract virtual UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    public abstract virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    public abstract virtual UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    public abstract virtual UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    public abstract virtual UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    public abstract virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    public abstract virtual UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    public abstract virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, IntPtr& ppBlob);
    public abstract virtual UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName);
    public abstract virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, IntPtr& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, IntPtr& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, IntPtr& ppData);
    public abstract virtual bool IsValidToken(UInt32 tk);
    public abstract virtual UInt32 GetNestedClassProps(UInt32 tdNestedClass, UInt32* ptdEnclosingClass);
    public abstract virtual UInt32 GetNativeCallConvFromSig(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual int IsGlobal(UInt32 pd);
}
[GuidAttribute("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
[InterfaceTypeAttribute("1")]
internal interface Mono.Cecil.Pdb.ISymUnmanagedDocumentWriter {
    public abstract virtual void SetSource(UInt32 sourceSize, Byte[] source);
    public abstract virtual void SetCheckSum(Guid algorithmId, UInt32 checkSumSize, Byte[] checkSum);
}
[GuidAttribute("0B97726E-9E6D-4f05-9A26-424022093CAA")]
[InterfaceTypeAttribute("1")]
internal interface Mono.Cecil.Pdb.ISymUnmanagedWriter2 {
    public abstract virtual void DefineDocument(string url, Guid& langauge, Guid& languageVendor, Guid& documentType, ISymUnmanagedDocumentWriter& pRetVal);
    public abstract virtual void SetUserEntryPoint(int methodToken);
    public abstract virtual void OpenMethod(int methodToken);
    public abstract virtual void CloseMethod();
    public abstract virtual void OpenScope(int startOffset, Int32& pRetVal);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void SetScopeRange_Placeholder();
    public abstract virtual void DefineLocalVariable_Placeholder();
    public abstract virtual void DefineParameter_Placeholder();
    public abstract virtual void DefineField_Placeholder();
    public abstract virtual void DefineGlobalVariable_Placeholder();
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute(UInt32 parent, string name, UInt32 data, IntPtr signature);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange_Placeholder();
    public abstract virtual void Initialize(object emitter, string filename, IStream pIStream, bool fFullBuild);
    public abstract virtual void GetDebugInfo(ImageDebugDirectory& pIDD, int cData, Int32& pcData, Byte[] data);
    public abstract virtual void DefineSequencePoints(ISymUnmanagedDocumentWriter document, int spCount, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual void RemapToken_Placeholder();
    public abstract virtual void Initialize2_Placeholder();
    public abstract virtual void DefineConstant_Placeholder();
    public abstract virtual void Abort_Placeholder();
    public abstract virtual void DefineLocalVariable2(string name, int attributes, int sigToken, int addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public abstract virtual void DefineGlobalVariable2_Placeholder();
    public abstract virtual void DefineConstant2(string name, object variant, int sigToken);
}
internal class Mono.Cecil.Pdb.ModuleMetadata : object {
    private ModuleDefinition module;
    private Dictionary`2<UInt32, TypeDefinition> types;
    private Dictionary`2<UInt32, MethodDefinition> methods;
    private static UInt32 S_OK;
    private static UInt32 E_FAIL;
    public ModuleMetadata(ModuleDefinition module);
    private bool TryGetType(UInt32 token, TypeDefinition& type);
    private bool TryGetMethod(UInt32 token, MethodDefinition& method);
    private void InitializeMetadata(ModuleDefinition module);
    private void InitializeMethods(TypeDefinition type);
    public sealed virtual void SetModuleProps(string szName);
    public sealed virtual void Save(string szFile, UInt32 dwSaveFlags);
    public sealed virtual void SaveToStream(IntPtr pIStream, UInt32 dwSaveFlags);
    public sealed virtual UInt32 GetSaveSize(UInt32 fSave);
    public sealed virtual UInt32 DefineTypeDef(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public sealed virtual UInt32 DefineNestedType(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements, UInt32 tdEncloser);
    public sealed virtual void SetHandler(object pUnk);
    public sealed virtual UInt32 DefineMethod(UInt32 td, IntPtr zName, UInt32 dwMethodFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public sealed virtual void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    public sealed virtual UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, IntPtr szName);
    public sealed virtual UInt32 DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    public sealed virtual UInt32 DefineMemberRef(UInt32 tkImport, string szName, IntPtr pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    public sealed virtual UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public sealed virtual void SetClassLayout(UInt32 td, UInt32 dwPackSize, IntPtr rFieldOffsets, UInt32 ulClassSize);
    public sealed virtual void DeleteClassLayout(UInt32 td);
    public sealed virtual void SetFieldMarshal(UInt32 tk, IntPtr pvNativeType, UInt32 cbNativeType);
    public sealed virtual void DeleteFieldMarshal(UInt32 tk);
    public sealed virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public sealed virtual void SetRVA(UInt32 md, UInt32 ulRVA);
    public sealed virtual UInt32 GetTokenFromSig(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual UInt32 DefineModuleRef(string szName);
    public sealed virtual void SetParent(UInt32 mr, UInt32 tk);
    public sealed virtual UInt32 GetTokenFromTypeSpec(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual void SaveToMemory(IntPtr pbData, UInt32 cbData);
    public sealed virtual UInt32 DefineUserString(string szString, UInt32 cchString);
    public sealed virtual void DeleteToken(UInt32 tkObj);
    public sealed virtual void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public sealed virtual void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public sealed virtual void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public sealed virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public sealed virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public sealed virtual void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public sealed virtual void DeletePinvokeMap(UInt32 tk);
    public sealed virtual UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public sealed virtual void SetCustomAttributeValue(UInt32 pcv, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public sealed virtual UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, IntPtr pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public sealed virtual UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public sealed virtual void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    public sealed virtual void ApplyEditAndContinue(object pImport);
    public sealed virtual UInt32 TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, UInt32 cbTranslatedSigMax);
    public sealed virtual void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    public sealed virtual void SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    public sealed virtual void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    public sealed virtual void MergeEnd();
    public sealed virtual void CloseEnum(UInt32 hEnum);
    public sealed virtual UInt32 CountEnum(UInt32 hEnum);
    public sealed virtual void ResetEnum(UInt32 hEnum, UInt32 ulPos);
    public sealed virtual UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    public sealed virtual UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    public sealed virtual UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    public sealed virtual UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    public sealed virtual Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    public sealed virtual UInt32 GetModuleFromScope();
    public sealed virtual UInt32 GetTypeDefProps(UInt32 td, Char* szTypeDef, UInt32 cchTypeDef, UInt32* pchTypeDef, UInt32* pdwTypeDefFlags, UInt32* ptkExtends);
    public sealed virtual UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    public sealed virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    public sealed virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public sealed virtual UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    public sealed virtual UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    public sealed virtual UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, IntPtr rMethods, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    public sealed virtual UInt32 EnumFields(UInt32& phEnum, UInt32 cl, IntPtr rFields, UInt32 cMax);
    public sealed virtual UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    public sealed virtual UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    public sealed virtual UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    public sealed virtual UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    public sealed virtual UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 GetMethodProps(UInt32 mb, UInt32* pClass, Char* szMethod, UInt32 cchMethod, UInt32* pchMethod, UInt32* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, UInt32* pulCodeRVA, UInt32* pdwImplFlags);
    private static void WriteNameBuffer(string name, Char* buffer, UInt32 bufferLength, UInt32* actualLength);
    public sealed virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, IntPtr& ppvSigBlob);
    public sealed virtual UInt32 EnumProperties(UInt32& phEnum, UInt32 td, IntPtr rProperties, UInt32 cMax);
    public sealed virtual UInt32 EnumEvents(UInt32& phEnum, UInt32 td, IntPtr rEvents, UInt32 cMax);
    public sealed virtual UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    public sealed virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    public sealed virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, IntPtr rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    public sealed virtual UInt32 GetFieldMarshal(UInt32 tk, IntPtr& ppvNativeType);
    public sealed virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public sealed virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, IntPtr& ppvPermission);
    public sealed virtual UInt32 GetSigFromToken(UInt32 mdSig, IntPtr& ppvSig);
    public sealed virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    public sealed virtual UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    public sealed virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, IntPtr& ppvSig);
    public sealed virtual UInt32 GetNameFromToken(UInt32 tk);
    public sealed virtual UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    public sealed virtual UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    public sealed virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    public sealed virtual UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    public sealed virtual UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    public sealed virtual UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    public sealed virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    public sealed virtual UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    public sealed virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, IntPtr& ppBlob);
    public sealed virtual UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName);
    public sealed virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, IntPtr& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, IntPtr& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    public sealed virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, IntPtr& ppData);
    public sealed virtual bool IsValidToken(UInt32 tk);
    public sealed virtual UInt32 GetNestedClassProps(UInt32 tdNestedClass, UInt32* ptdEnclosingClass);
    public sealed virtual UInt32 GetNativeCallConvFromSig(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual int IsGlobal(UInt32 pd);
}
internal class Mono.Cecil.Pdb.NativePdbReader : object {
    private Disposable`1<Stream> pdb_file;
    private Dictionary`2<string, Document> documents;
    private Dictionary`2<UInt32, PdbFunction> functions;
    private Dictionary`2<PdbScope, ImportDebugInformation> imports;
    internal NativePdbReader(Disposable`1<Stream> file);
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    private static bool IsMatchingEntry(PdbInfo info, ImageDebugHeaderEntry entry);
    private static int ReadInt32(Byte[] bytes, int start);
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    private Collection`1<ScopeDebugInformation> ReadScopeAndLocals(PdbScope[] scopes, MethodDebugInformation info);
    private ScopeDebugInformation ReadScopeAndLocals(PdbScope scope, MethodDebugInformation info);
    private static bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope);
    private ImportDebugInformation GetImport(UInt32 token, ModuleDefinition module);
    private static ImportDebugInformation GetImport(PdbScope scope, ModuleDefinition module);
    private void ReadSequencePoints(PdbFunction function, MethodDebugInformation info);
    private void ReadLines(PdbLines lines, MethodDebugInformation info);
    private static void ReadLine(PdbLine line, Document document, MethodDebugInformation info);
    private Document GetDocument(PdbSource source);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Pdb.NativePdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.NativePdbWriter : object {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    private SymWriter writer;
    private Dictionary`2<string, SymDocumentWriter> documents;
    private Dictionary`2<ImportDebugInformation, MetadataToken> import_info_to_parent;
    private ImageDebugDirectory debug_directory;
    private Byte[] debug_info;
    internal NativePdbWriter(ModuleDefinition module, SymWriter writer);
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    public sealed virtual ImageDebugHeader GetDebugHeader();
    public sealed virtual void Write(MethodDebugInformation info);
    private void DefineCustomMetadata(MethodDebugInformation info, MetadataToken import_parent);
    private void DefineAsyncCustomMetadata(MethodDebugInformation info);
    private void DefineScope(ScopeDebugInformation scope, MethodDebugInformation info, MetadataToken& import_parent);
    private void DefineSequencePoints(Collection`1<SequencePoint> sequence_points);
    private void DefineLocalVariable(VariableDebugInformation variable, int local_var_token, int start_offset, int end_offset);
    private void DefineConstant(ConstantDebugInformation constant);
    private SymDocumentWriter GetDocument(Document document);
    public sealed virtual void Write();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Pdb.NativePdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    private static SymWriter CreateWriter(ModuleDefinition module, string pdb);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.PdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.PdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    private static bool HasPortablePdbSymbols(ModuleDefinition module);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.SymDocumentWriter : object {
    private ISymUnmanagedDocumentWriter writer;
    public ISymUnmanagedDocumentWriter Writer { get; }
    public SymDocumentWriter(ISymUnmanagedDocumentWriter writer);
    public ISymUnmanagedDocumentWriter get_Writer();
    public void SetSource(Byte[] source);
    public void SetCheckSum(Guid hashAlgo, Byte[] checkSum);
}
internal class Mono.Cecil.Pdb.SymWriter : object {
    private static Guid s_symUnmangedWriterIID;
    private static Guid s_CorSymWriter_SxS_ClassID;
    private ISymUnmanagedWriter2 writer;
    private Collection`1<ISymUnmanagedDocumentWriter> documents;
    private static SymWriter();
    private static int CoCreateInstance(Guid& rclsid, object pUnkOuter, UInt32 dwClsContext, Guid& riid, Object& ppv);
    public Byte[] GetDebugInfo(ImageDebugDirectory& idd);
    public void DefineLocalVariable2(string name, VariableAttributes attributes, int sigToken, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public void DefineConstant2(string name, object value, int sigToken);
    public void Close();
    public void CloseMethod();
    public void CloseNamespace();
    public void CloseScope(int endOffset);
    public SymDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public void DefineSequencePoints(SymDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public void Initialize(object emitter, string filename, bool fFullBuild);
    public void SetUserEntryPoint(int methodToken);
    public void OpenMethod(int methodToken);
    public void OpenNamespace(string name);
    public int OpenScope(int startOffset);
    public void UsingNamespace(string fullName);
    public void DefineCustomMetadata(string name, Byte[] metadata);
}
internal class Mono.Cecil.PE.BinaryStreamReader : BinaryReader {
    public int Position { get; public set; }
    public int Length { get; }
    public BinaryStreamReader(Stream stream);
    public int get_Position();
    public void set_Position(int value);
    public int get_Length();
    public void Advance(int bytes);
    public void MoveTo(UInt32 position);
    public void Align(int align);
    public DataDirectory ReadDataDirectory();
}
internal class Mono.Cecil.PE.BinaryStreamWriter : BinaryWriter {
    public int Position { get; public set; }
    public BinaryStreamWriter(Stream stream);
    public int get_Position();
    public void set_Position(int value);
    public void WriteByte(byte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteBytes(Byte[] bytes);
    public void WriteDataDirectory(DataDirectory directory);
    public void WriteBuffer(ByteBuffer buffer);
    protected void Advance(int bytes);
    public void Align(int align);
}
internal class Mono.Cecil.PE.ByteBuffer : object {
    internal Byte[] buffer;
    internal int length;
    internal int position;
    public ByteBuffer(int length);
    public ByteBuffer(Byte[] buffer);
    public void Advance(int length);
    public byte ReadByte();
    public sbyte ReadSByte();
    public Byte[] ReadBytes(int length);
    public ushort ReadUInt16();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public int ReadInt32();
    public ulong ReadUInt64();
    public long ReadInt64();
    public UInt32 ReadCompressedUInt32();
    public int ReadCompressedInt32();
    public float ReadSingle();
    public double ReadDouble();
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteInt64(long value);
    public void WriteCompressedUInt32(UInt32 value);
    public void WriteCompressedInt32(int value);
    public void WriteBytes(Byte[] bytes);
    public void WriteBytes(int length);
    public void WriteBytes(ByteBuffer buffer);
    public void WriteSingle(float value);
    public void WriteDouble(double value);
    private void Grow(int desired);
}
internal class Mono.Cecil.PE.ByteBufferEqualityComparer : object {
    public sealed virtual bool Equals(ByteBuffer x, ByteBuffer y);
    public sealed virtual int GetHashCode(ByteBuffer buffer);
}
internal class Mono.Cecil.PE.DataDirectory : ValueType {
    public UInt32 VirtualAddress;
    public UInt32 Size;
    public bool IsZero { get; }
    public DataDirectory(UInt32 rva, UInt32 size);
    public bool get_IsZero();
}
internal class Mono.Cecil.PE.Image : object {
    public Disposable`1<Stream> Stream;
    public string FileName;
    public ModuleKind Kind;
    public UInt32 Characteristics;
    public string RuntimeVersion;
    public TargetArchitecture Architecture;
    public ModuleCharacteristics DllCharacteristics;
    public ushort LinkerVersion;
    public ushort SubSystemMajor;
    public ushort SubSystemMinor;
    public ImageDebugHeader DebugHeader;
    public Section[] Sections;
    public Section MetadataSection;
    public UInt32 EntryPointToken;
    public UInt32 Timestamp;
    public ModuleAttributes Attributes;
    public DataDirectory Win32Resources;
    public DataDirectory Debug;
    public DataDirectory Resources;
    public DataDirectory StrongName;
    public StringHeap StringHeap;
    public BlobHeap BlobHeap;
    public UserStringHeap UserStringHeap;
    public GuidHeap GuidHeap;
    public TableHeap TableHeap;
    public PdbHeap PdbHeap;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    public bool HasTable(Table table);
    public int GetTableLength(Table table);
    public int GetTableIndexSize(Table table);
    public int GetCodedIndexSize(CodedIndex coded_index);
    public UInt32 ResolveVirtualAddress(UInt32 rva);
    public UInt32 ResolveVirtualAddressInSection(UInt32 rva, Section section);
    public Section GetSection(string name);
    public Section GetSectionAtVirtualAddress(UInt32 rva);
    private BinaryStreamReader GetReaderAt(UInt32 rva);
    public TRet GetReaderAt(UInt32 rva, TItem item, Func`3<TItem, BinaryStreamReader, TRet> read);
    public bool HasDebugTables();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.PE.ImageReader : BinaryStreamReader {
    private Image image;
    private DataDirectory cli;
    private DataDirectory metadata;
    private UInt32 table_heap_offset;
    private UInt32 pdb_heap_offset;
    public ImageReader(Disposable`1<Stream> stream, string file_name);
    private void MoveTo(DataDirectory directory);
    private void ReadImage();
    private TargetArchitecture ReadArchitecture();
    private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem);
    private void ReadOptionalHeaders(UInt16& subsystem, UInt16& dll_characteristics);
    private string ReadAlignedString(int length);
    private string ReadZeroTerminatedString(int length);
    private void ReadSections(ushort count);
    private void ReadCLIHeader();
    private void ReadMetadata();
    private void ReadDebugHeader();
    private void ReadMetadataStream(Section section);
    private Byte[] ReadHeapData(UInt32 offset, UInt32 size);
    private void ReadTableHeap();
    private static void SetIndexSize(Heap heap, UInt32 sizes, byte flag);
    private int GetTableIndexSize(Table table);
    private int GetCodedIndexSize(CodedIndex index);
    private void ComputeTableInformations();
    private void ReadPdbHeap();
    public static Image ReadImage(Disposable`1<Stream> stream, string file_name);
    public static Image ReadPortablePdb(Disposable`1<Stream> stream, string file_name, UInt32& pdb_heap_offset);
}
internal class Mono.Cecil.PE.ImageWriter : BinaryStreamWriter {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    private TextMap text_map;
    internal Disposable`1<Stream> stream;
    private string runtime_version;
    private ImageDebugHeader debug_header;
    private ByteBuffer win32_resources;
    private static UInt32 pe_header_size;
    private static UInt32 section_header_size;
    private static UInt32 file_alignment;
    private static UInt32 section_alignment;
    private static ulong image_base;
    internal static UInt32 text_rva;
    private bool pe64;
    private bool has_reloc;
    internal Section text;
    internal Section rsrc;
    internal Section reloc;
    private ushort sections;
    internal long debug_header_entries_position;
    private ImageWriter(ModuleDefinition module, string runtime_version, MetadataBuilder metadata, Disposable`1<Stream> stream, bool metadataOnly);
    private void GetDebugHeader();
    private void GetWin32Resources();
    public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable`1<Stream> stream);
    public static ImageWriter CreateDebugWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable`1<Stream> stream);
    private void BuildSections();
    private Section CreateSection(string name, UInt32 size, Section previous);
    private static UInt32 Align(UInt32 value, UInt32 align);
    private void WriteDOSHeader();
    private ushort SizeOfOptionalHeader();
    private void WritePEFileHeader();
    private Section LastSection();
    private void WriteOptionalHeaders();
    private void WriteZeroDataDirectory();
    private ushort GetSubSystem();
    private void WriteSectionHeaders();
    private void WriteSection(Section section, UInt32 characteristics);
    private UInt32 GetRVAFileOffset(Section section, UInt32 rva);
    private void MoveTo(UInt32 pointer);
    private void MoveToRVA(Section section, UInt32 rva);
    internal void MoveToRVA(TextSegment segment);
    private void WriteRVA(UInt32 rva);
    private void PrepareSection(Section section);
    private void WriteText();
    private UInt32 GetMetadataLength();
    public void WriteMetadataHeader();
    private ushort GetStreamCount();
    private void WriteStreamHeader(UInt32& offset, TextSegment heap, string name);
    private static int GetZeroTerminatedStringLength(string string);
    private static Byte[] GetZeroTerminatedString(string string);
    private static Byte[] GetSimpleString(string string);
    private static Byte[] GetString(string string, int length);
    public void WriteMetadata();
    private void WriteHeap(TextSegment heap, HeapBuffer buffer);
    private void WriteDebugDirectory();
    private void WriteImportDirectory();
    private Byte[] GetRuntimeMain();
    private void WriteStartupStub();
    private void WriteRsrc();
    private void WriteReloc();
    public void WriteImage();
    private void BuildTextMap();
    public void BuildMetadataTextMap();
    private UInt32 GetStartupStubLength();
    private int GetMetadataHeaderLength(string runtimeVersion);
    private int GetStrongNameLength();
    public DataDirectory GetStrongNameSignatureDirectory();
    public UInt32 GetHeaderSize();
    private void PatchWin32Resources(ByteBuffer resources);
    private void PatchResourceDirectoryTable(ByteBuffer resources);
    private void PatchResourceDirectoryEntry(ByteBuffer resources);
    private void PatchResourceDataEntry(ByteBuffer resources);
}
internal class Mono.Cecil.PE.Section : object {
    public string Name;
    public UInt32 VirtualAddress;
    public UInt32 VirtualSize;
    public UInt32 SizeOfRawData;
    public UInt32 PointerToRawData;
}
internal class Mono.Cecil.PE.TextMap : object {
    private Range[] map;
    public void AddMap(TextSegment segment, int length);
    private UInt32 AlignUp(UInt32 value, UInt32 align);
    public void AddMap(TextSegment segment, int length, int align);
    public void AddMap(TextSegment segment, Range range);
    public Range GetRange(TextSegment segment);
    public DataDirectory GetDataDirectory(TextSegment segment);
    public UInt32 GetRVA(TextSegment segment);
    public UInt32 GetNextRVA(TextSegment segment);
    public int GetLength(TextSegment segment);
    private UInt32 GetStart(TextSegment segment);
    private UInt32 ComputeStart(int index);
    public UInt32 GetLength();
}
internal enum Mono.Cecil.PE.TextSegment : Enum {
    public int value__;
    public static TextSegment ImportAddressTable;
    public static TextSegment CLIHeader;
    public static TextSegment Code;
    public static TextSegment Resources;
    public static TextSegment Data;
    public static TextSegment StrongNameSignature;
    public static TextSegment MetadataHeader;
    public static TextSegment TableHeap;
    public static TextSegment StringHeap;
    public static TextSegment UserStringHeap;
    public static TextSegment GuidHeap;
    public static TextSegment BlobHeap;
    public static TextSegment PdbHeap;
    public static TextSegment DebugDirectory;
    public static TextSegment ImportDirectory;
    public static TextSegment ImportHintNameTable;
    public static TextSegment StartupStub;
}
internal class Mono.Cecil.PinnedType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsPinned { get; }
    public PinnedType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPinned();
}
[FlagsAttribute]
public enum Mono.Cecil.PInvokeAttributes : Enum {
    public ushort value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdCall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
}
public class Mono.Cecil.PInvokeInfo : object {
    private ushort attributes;
    private string entry_point;
    private ModuleReference module;
    public PInvokeAttributes Attributes { get; public set; }
    public string EntryPoint { get; public set; }
    public ModuleReference Module { get; public set; }
    public bool IsNoMangle { get; public set; }
    public bool IsCharSetNotSpec { get; public set; }
    public bool IsCharSetAnsi { get; public set; }
    public bool IsCharSetUnicode { get; public set; }
    public bool IsCharSetAuto { get; public set; }
    public bool SupportsLastError { get; public set; }
    public bool IsCallConvWinapi { get; public set; }
    public bool IsCallConvCdecl { get; public set; }
    public bool IsCallConvStdCall { get; public set; }
    public bool IsCallConvThiscall { get; public set; }
    public bool IsCallConvFastcall { get; public set; }
    public bool IsBestFitEnabled { get; public set; }
    public bool IsBestFitDisabled { get; public set; }
    public bool IsThrowOnUnmappableCharEnabled { get; public set; }
    public bool IsThrowOnUnmappableCharDisabled { get; public set; }
    public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module);
    public PInvokeAttributes get_Attributes();
    public void set_Attributes(PInvokeAttributes value);
    public string get_EntryPoint();
    public void set_EntryPoint(string value);
    public ModuleReference get_Module();
    public void set_Module(ModuleReference value);
    public bool get_IsNoMangle();
    public void set_IsNoMangle(bool value);
    public bool get_IsCharSetNotSpec();
    public void set_IsCharSetNotSpec(bool value);
    public bool get_IsCharSetAnsi();
    public void set_IsCharSetAnsi(bool value);
    public bool get_IsCharSetUnicode();
    public void set_IsCharSetUnicode(bool value);
    public bool get_IsCharSetAuto();
    public void set_IsCharSetAuto(bool value);
    public bool get_SupportsLastError();
    public void set_SupportsLastError(bool value);
    public bool get_IsCallConvWinapi();
    public void set_IsCallConvWinapi(bool value);
    public bool get_IsCallConvCdecl();
    public void set_IsCallConvCdecl(bool value);
    public bool get_IsCallConvStdCall();
    public void set_IsCallConvStdCall(bool value);
    public bool get_IsCallConvThiscall();
    public void set_IsCallConvThiscall(bool value);
    public bool get_IsCallConvFastcall();
    public void set_IsCallConvFastcall(bool value);
    public bool get_IsBestFitEnabled();
    public void set_IsBestFitEnabled(bool value);
    public bool get_IsBestFitDisabled();
    public void set_IsBestFitDisabled(bool value);
    public bool get_IsThrowOnUnmappableCharEnabled();
    public void set_IsThrowOnUnmappableCharEnabled(bool value);
    public bool get_IsThrowOnUnmappableCharDisabled();
    public void set_IsThrowOnUnmappableCharDisabled(bool value);
}
internal class Mono.Cecil.PointerType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsPointer { get; }
    public PointerType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPointer();
}
[FlagsAttribute]
public enum Mono.Cecil.PropertyAttributes : Enum {
    public ushort value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Unused;
}
public class Mono.Cecil.PropertyDefinition : PropertyReference {
    private Nullable`1<bool> has_this;
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition get_method;
    internal MethodDefinition set_method;
    internal Collection`1<MethodDefinition> other_methods;
    private object constant;
    public PropertyAttributes Attributes { get; public set; }
    public bool HasThis { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MethodDefinition GetMethod { get; public set; }
    public MethodDefinition SetMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public string FullName { get; }
    public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType);
    public PropertyAttributes get_Attributes();
    public void set_Attributes(PropertyAttributes value);
    public bool get_HasThis();
    public void set_HasThis(bool value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public MethodDefinition get_GetMethod();
    public void set_GetMethod(MethodDefinition value);
    public MethodDefinition get_SetMethod();
    public void set_SetMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private static Collection`1<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    public virtual string get_FullName();
    private void InitializeMethods();
    public virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.PropertyReference : MemberReference {
    private TypeReference property_type;
    public TypeReference PropertyType { get; public set; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    internal PropertyReference(string name, TypeReference propertyType);
    public TypeReference get_PropertyType();
    public void set_PropertyType(TypeReference value);
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    protected virtual IMemberDefinition ResolveDefinition();
    public abstract virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyTable : MetadataTable`1<Row`3<PropertyAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Range : ValueType {
    public UInt32 Start;
    public UInt32 Length;
    public Range(UInt32 index, UInt32 length);
}
public class Mono.Cecil.ReaderParameters : object {
    private ReadingMode reading_mode;
    internal IAssemblyResolver assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    internal IMetadataImporterProvider metadata_importer_provider;
    internal IReflectionImporterProvider reflection_importer_provider;
    private Stream symbol_stream;
    private ISymbolReaderProvider symbol_reader_provider;
    private bool read_symbols;
    private bool throw_symbols_mismatch;
    private bool projections;
    private bool in_memory;
    private bool read_write;
    public ReadingMode ReadingMode { get; public set; }
    public bool InMemory { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public IMetadataImporterProvider MetadataImporterProvider { get; public set; }
    public IReflectionImporterProvider ReflectionImporterProvider { get; public set; }
    public Stream SymbolStream { get; public set; }
    public ISymbolReaderProvider SymbolReaderProvider { get; public set; }
    public bool ReadSymbols { get; public set; }
    public bool ThrowIfSymbolsAreNotMatching { get; public set; }
    public bool ReadWrite { get; public set; }
    public bool ApplyWindowsRuntimeProjections { get; public set; }
    public ReaderParameters(ReadingMode readingMode);
    public ReadingMode get_ReadingMode();
    public void set_ReadingMode(ReadingMode value);
    public bool get_InMemory();
    public void set_InMemory(bool value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public IMetadataImporterProvider get_MetadataImporterProvider();
    public void set_MetadataImporterProvider(IMetadataImporterProvider value);
    public IReflectionImporterProvider get_ReflectionImporterProvider();
    public void set_ReflectionImporterProvider(IReflectionImporterProvider value);
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolReaderProvider get_SymbolReaderProvider();
    public void set_SymbolReaderProvider(ISymbolReaderProvider value);
    public bool get_ReadSymbols();
    public void set_ReadSymbols(bool value);
    public bool get_ThrowIfSymbolsAreNotMatching();
    public void set_ThrowIfSymbolsAreNotMatching(bool value);
    public bool get_ReadWrite();
    public void set_ReadWrite(bool value);
    public bool get_ApplyWindowsRuntimeProjections();
    public void set_ApplyWindowsRuntimeProjections(bool value);
}
public enum Mono.Cecil.ReadingMode : Enum {
    public int value__;
    public static ReadingMode Immediate;
    public static ReadingMode Deferred;
}
internal class Mono.Cecil.RequiredModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsRequiredModifier { get; }
    public bool ContainsGenericParameter { get; }
    public RequiredModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_ContainsGenericParameter();
}
internal class Mono.Cecil.ResolutionException : Exception {
    private MemberReference member;
    public MemberReference Member { get; }
    public IMetadataScope Scope { get; }
    public ResolutionException(MemberReference member);
    public ResolutionException(MemberReference member, Exception innerException);
    public MemberReference get_Member();
    public IMetadataScope get_Scope();
}
public abstract class Mono.Cecil.Resource : object {
    private string name;
    private UInt32 attributes;
    public string Name { get; public set; }
    public ManifestResourceAttributes Attributes { get; public set; }
    public ResourceType ResourceType { get; }
    public bool IsPublic { get; public set; }
    public bool IsPrivate { get; public set; }
    internal Resource(string name, ManifestResourceAttributes attributes);
    public string get_Name();
    public void set_Name(string value);
    public ManifestResourceAttributes get_Attributes();
    public void set_Attributes(ManifestResourceAttributes value);
    public abstract virtual ResourceType get_ResourceType();
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
}
public enum Mono.Cecil.ResourceType : Enum {
    public int value__;
    public static ResourceType Linked;
    public static ResourceType Embedded;
    public static ResourceType AssemblyLinked;
}
internal class Mono.Cecil.Rocks.DocCommentId : object {
    private IMemberDefinition commentMember;
    private StringBuilder id;
    private DocCommentId(IMemberDefinition member);
    private void WriteField(FieldDefinition field);
    private void WriteEvent(EventDefinition event);
    private void WriteType(TypeDefinition type);
    private void WriteMethod(MethodDefinition method);
    private static bool IsConversionOperator(MethodDefinition self);
    private void WriteReturnType(MethodDefinition method);
    private void WriteProperty(PropertyDefinition property);
    private void WriteParameters(IList`1<ParameterDefinition> parameters);
    private void WriteTypeSignature(TypeReference type);
    private bool IsGenericMethodTypeParameter(TypeReference type);
    private void WriteGenericInstanceTypeSignature(GenericInstanceType type);
    private void WriteList(IList`1<T> list, Action`1<T> action);
    private void WriteModiferTypeSignature(IModifierType type, char id);
    private void WriteFunctionPointerTypeSignature(FunctionPointerType type);
    private void WriteArrayTypeSignature(ArrayType type);
    private void WriteDefinition(char id, IMemberDefinition member);
    private void WriteTypeFullName(TypeReference type);
    private void WriteTypeFullName(TypeReference type, GenericTypeOptions options);
    private void WriteGenericTypeParameters(TypeReference type, GenericTypeOptions options);
    private static bool IsGenericType(TypeReference type);
    private IList`1<TypeReference> GetGenericTypeArguments(TypeReference type, GenericTypeOptions options);
    private void WriteItemName(string name);
    public virtual string ToString();
    public static string GetDocCommentId(IMemberDefinition member);
    [CompilerGeneratedAttribute]
private void <WriteParameters>b__10_0(ParameterDefinition p);
    [CompilerGeneratedAttribute]
private void <WriteArrayTypeSignature>b__17_0(ArrayDimension dimension);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.Functional : object {
    public static Func`2<A, R> Y(Func`2<Func`2<A, R>, Func`2<A, R>> f);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element);
    [IteratorStateMachineAttribute("Mono.Cecil.Rocks.Functional/<PrependIterator>d__2`1")]
private static IEnumerable`1<TSource> PrependIterator(IEnumerable`1<TSource> source, TSource element);
}
internal interface Mono.Cecil.Rocks.IILVisitor {
    public abstract virtual void OnInlineNone(OpCode opcode);
    public abstract virtual void OnInlineSByte(OpCode opcode, sbyte value);
    public abstract virtual void OnInlineByte(OpCode opcode, byte value);
    public abstract virtual void OnInlineInt32(OpCode opcode, int value);
    public abstract virtual void OnInlineInt64(OpCode opcode, long value);
    public abstract virtual void OnInlineSingle(OpCode opcode, float value);
    public abstract virtual void OnInlineDouble(OpCode opcode, double value);
    public abstract virtual void OnInlineString(OpCode opcode, string value);
    public abstract virtual void OnInlineBranch(OpCode opcode, int offset);
    public abstract virtual void OnInlineSwitch(OpCode opcode, Int32[] offsets);
    public abstract virtual void OnInlineVariable(OpCode opcode, VariableDefinition variable);
    public abstract virtual void OnInlineArgument(OpCode opcode, ParameterDefinition parameter);
    public abstract virtual void OnInlineSignature(OpCode opcode, CallSite callSite);
    public abstract virtual void OnInlineType(OpCode opcode, TypeReference type);
    public abstract virtual void OnInlineField(OpCode opcode, FieldReference field);
    public abstract virtual void OnInlineMethod(OpCode opcode, MethodReference method);
}
internal static class Mono.Cecil.Rocks.ILParser : object {
    public static void Parse(MethodDefinition method, IILVisitor visitor);
    private static void ParseMethod(MethodDefinition method, IILVisitor visitor);
    private static ParseContext CreateContext(MethodDefinition method, IILVisitor visitor);
    private static void ParseFatMethod(ParseContext context);
    private static void ParseCode(int code_size, ParseContext context);
    private static VariableDefinition GetVariable(ParseContext context, int index);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.MethodBodyRocks : object {
    [ExtensionAttribute]
public static void SimplifyMacros(MethodBody self);
    private static void ExpandMacro(Instruction instruction, OpCode opcode, object operand);
    private static void MakeMacro(Instruction instruction, OpCode opcode);
    [ExtensionAttribute]
public static void Optimize(MethodBody self);
    [ExtensionAttribute]
private static void OptimizeLongs(MethodBody self);
    [ExtensionAttribute]
public static void OptimizeMacros(MethodBody self);
    private static void OptimizeBranches(MethodBody body);
    private static bool OptimizeBranch(Instruction instruction);
    private static void ComputeOffsets(MethodBody body);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.MethodDefinitionRocks : object {
    [ExtensionAttribute]
public static MethodDefinition GetBaseMethod(MethodDefinition self);
    [ExtensionAttribute]
public static MethodDefinition GetOriginalBaseMethod(MethodDefinition self);
    private static TypeDefinition ResolveBaseType(TypeDefinition type);
    private static MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.ModuleDefinitionRocks : object {
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinition> GetAllTypes(ModuleDefinition self);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.ParameterReferenceRocks : object {
    [ExtensionAttribute]
public static int GetSequence(ParameterReference self);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.TypeDefinitionRocks : object {
    [ExtensionAttribute]
public static IEnumerable`1<MethodDefinition> GetConstructors(TypeDefinition self);
    [ExtensionAttribute]
public static MethodDefinition GetStaticConstructor(TypeDefinition self);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDefinition> GetMethods(TypeDefinition self);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Rocks.TypeReferenceRocks : object {
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeReference self);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeReference self, int rank);
    [ExtensionAttribute]
public static PointerType MakePointerType(TypeReference self);
    [ExtensionAttribute]
public static ByReferenceType MakeByReferenceType(TypeReference self);
    [ExtensionAttribute]
public static OptionalModifierType MakeOptionalModifierType(TypeReference self, TypeReference modifierType);
    [ExtensionAttribute]
public static RequiredModifierType MakeRequiredModifierType(TypeReference self, TypeReference modifierType);
    [ExtensionAttribute]
public static GenericInstanceType MakeGenericInstanceType(TypeReference self, TypeReference[] arguments);
    [ExtensionAttribute]
public static PinnedType MakePinnedType(TypeReference self);
    [ExtensionAttribute]
public static SentinelType MakeSentinelType(TypeReference self);
}
internal class Mono.Cecil.SafeArrayMarshalInfo : MarshalInfo {
    internal VariantType element_type;
    public VariantType ElementType { get; public set; }
    public VariantType get_ElementType();
    public void set_ElementType(VariantType value);
}
public enum Mono.Cecil.SecurityAction : Enum {
    public ushort value__;
    public static SecurityAction Request;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
    public static SecurityAction PreJitGrant;
    public static SecurityAction PreJitDeny;
    public static SecurityAction NonCasDemand;
    public static SecurityAction NonCasLinkDemand;
    public static SecurityAction NonCasInheritance;
}
[DebuggerDisplayAttribute("{AttributeType}")]
public class Mono.Cecil.SecurityAttribute : object {
    private TypeReference attribute_type;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public TypeReference AttributeType { get; public set; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    private bool Mono.Cecil.ICustomAttribute.HasConstructorArguments { get; }
    private Collection`1<CustomAttributeArgument> Mono.Cecil.ICustomAttribute.ConstructorArguments { get; }
    public SecurityAttribute(TypeReference attributeType);
    public sealed virtual TypeReference get_AttributeType();
    public void set_AttributeType(TypeReference value);
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    private sealed virtual override bool Mono.Cecil.ICustomAttribute.get_HasConstructorArguments();
    private sealed virtual override Collection`1<CustomAttributeArgument> Mono.Cecil.ICustomAttribute.get_ConstructorArguments();
}
public class Mono.Cecil.SecurityDeclaration : object {
    internal UInt32 signature;
    private Byte[] blob;
    private ModuleDefinition module;
    internal bool resolved;
    private SecurityAction action;
    internal Collection`1<SecurityAttribute> security_attributes;
    public SecurityAction Action { get; public set; }
    public bool HasSecurityAttributes { get; }
    public Collection`1<SecurityAttribute> SecurityAttributes { get; }
    internal bool HasImage { get; }
    internal SecurityDeclaration(SecurityAction action, UInt32 signature, ModuleDefinition module);
    public SecurityDeclaration(SecurityAction action);
    public SecurityDeclaration(SecurityAction action, Byte[] blob);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public bool get_HasSecurityAttributes();
    public Collection`1<SecurityAttribute> get_SecurityAttributes();
    internal bool get_HasImage();
    public Byte[] GetBlob();
    private void Resolve();
}
internal class Mono.Cecil.SentinelType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsSentinel { get; }
    public SentinelType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsSentinel();
}
internal class Mono.Cecil.SignatureReader : ByteBuffer {
    private MetadataReader reader;
    internal UInt32 start;
    internal UInt32 sig_length;
    private TypeSystem TypeSystem { get; }
    public SignatureReader(UInt32 blob, MetadataReader reader);
    private TypeSystem get_TypeSystem();
    private MetadataToken ReadTypeTokenSignature();
    private GenericParameter GetGenericParameter(GenericParameterType type, UInt32 var);
    private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index);
    private static void CheckGenericContext(IGenericParameterProvider owner, int index);
    public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance, UInt32 arity);
    private ArrayType ReadArrayTypeSignature();
    private TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeReference ReadTypeSignature();
    public TypeReference ReadTypeToken();
    private TypeReference ReadTypeSignature(ElementType etype);
    public void ReadMethodSignature(IMethodSignature method);
    public object ReadConstantSignature(ElementType type);
    public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection`1<ParameterDefinition> parameters);
    private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type);
    public void ReadCustomAttributeNamedArguments(ushort count, Collection`1& fields, Collection`1& properties);
    private void ReadCustomAttributeNamedArgument(Collection`1& fields, Collection`1& properties);
    private static Collection`1<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(Collection`1& collection);
    private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type);
    private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type);
    private object ReadCustomAttributeElementValue(TypeReference type);
    private object ReadPrimitiveValue(ElementType type);
    private TypeReference GetPrimitiveType(ElementType etype);
    private TypeReference ReadCustomAttributeFieldOrPropType();
    public TypeReference ReadTypeReference();
    private object ReadCustomAttributeEnum(TypeReference enum_type);
    public SecurityAttribute ReadSecurityAttribute();
    public MarshalInfo ReadMarshalInfo();
    private NativeType ReadNativeType();
    private VariantType ReadVariantType();
    private string ReadUTF8String();
    public string ReadDocumentName();
    public Collection`1<SequencePoint> ReadSequencePoints(Document document);
    public bool CanReadMore();
}
internal class Mono.Cecil.SignatureWriter : ByteBuffer {
    private MetadataBuilder metadata;
    public SignatureWriter(MetadataBuilder metadata);
    public void WriteElementType(ElementType element_type);
    public void WriteUTF8String(string string);
    public void WriteMethodSignature(IMethodSignature method);
    private UInt32 MakeTypeDefOrRefCodedRID(TypeReference type);
    public void WriteTypeToken(TypeReference type);
    public void WriteTypeSignature(TypeReference type);
    private void WriteArrayTypeSignature(ArrayType array);
    public void WriteGenericInstanceSignature(IGenericInstance instance);
    private void WriteModifierSignature(ElementType element_type, IModifierType type);
    private bool TryWriteElementType(TypeReference type);
    public void WriteConstantString(string value);
    public void WriteConstantPrimitive(object value);
    public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute);
    private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument);
    private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeValue(TypeReference type, object value);
    private void WriteCustomAttributeTypeValue(TypeReference value);
    private void WritePrimitiveValue(object value);
    private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value);
    private void WriteCustomAttributeFieldOrPropType(TypeReference type);
    public void WriteCustomAttributeNamedArguments(CustomAttribute attribute);
    private static int GetNamedArgumentCount(ICustomAttribute attribute);
    private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute);
    private void WriteCustomAttributeNamedArguments(byte kind, Collection`1<CustomAttributeNamedArgument> named_arguments);
    private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument);
    private void WriteSecurityAttribute(SecurityAttribute attribute);
    public void WriteSecurityDeclaration(SecurityDeclaration declaration);
    public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration);
    private static string GetXmlSecurityDeclaration(SecurityDeclaration declaration);
    private void WriteTypeReference(TypeReference type);
    public void WriteMarshalInfo(MarshalInfo marshal_info);
    private void WriteNativeType(NativeType native);
    private void WriteVariantType(VariantType variant);
    public void WriteSequencePoints(MethodDebugInformation info);
}
internal abstract class Mono.Cecil.SortedTable`1 : MetadataTable`1<TRow> {
    public sealed virtual void Sort();
    protected static int Compare(UInt32 x, UInt32 y);
    public abstract virtual int Compare(TRow x, TRow y);
}
internal class Mono.Cecil.StandAloneSigTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.StateMachineMethodTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public enum Mono.Cecil.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture I386;
    public static TargetArchitecture AMD64;
    public static TargetArchitecture IA64;
    public static TargetArchitecture ARM;
    public static TargetArchitecture ARMv7;
    public static TargetArchitecture ARM64;
}
public enum Mono.Cecil.TargetRuntime : Enum {
    public int value__;
    public static TargetRuntime Net_1_0;
    public static TargetRuntime Net_1_1;
    public static TargetRuntime Net_2_0;
    public static TargetRuntime Net_4_0;
}
public enum Mono.Cecil.TokenType : Enum {
    public UInt32 value__;
    public static TokenType Module;
    public static TokenType TypeRef;
    public static TokenType TypeDef;
    public static TokenType Field;
    public static TokenType Method;
    public static TokenType Param;
    public static TokenType InterfaceImpl;
    public static TokenType MemberRef;
    public static TokenType CustomAttribute;
    public static TokenType Permission;
    public static TokenType Signature;
    public static TokenType Event;
    public static TokenType Property;
    public static TokenType ModuleRef;
    public static TokenType TypeSpec;
    public static TokenType Assembly;
    public static TokenType AssemblyRef;
    public static TokenType File;
    public static TokenType ExportedType;
    public static TokenType ManifestResource;
    public static TokenType GenericParam;
    public static TokenType MethodSpec;
    public static TokenType GenericParamConstraint;
    public static TokenType Document;
    public static TokenType MethodDebugInformation;
    public static TokenType LocalScope;
    public static TokenType LocalVariable;
    public static TokenType LocalConstant;
    public static TokenType ImportScope;
    public static TokenType StateMachineMethod;
    public static TokenType CustomDebugInformation;
    public static TokenType String;
}
[FlagsAttribute]
public enum Mono.Cecil.TypeAttributes : Enum {
    public UInt32 value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes Forwarder;
}
internal enum Mono.Cecil.TypeComparisonMode : Enum {
    public int value__;
    public static TypeComparisonMode Exact;
    public static TypeComparisonMode SignatureOnly;
    public static TypeComparisonMode SignatureOnlyLoose;
}
public class Mono.Cecil.TypeDefinition : TypeReference {
    private UInt32 attributes;
    private TypeReference base_type;
    internal Range fields_range;
    internal Range methods_range;
    private short packing_size;
    private int class_size;
    private InterfaceImplementationCollection interfaces;
    private Collection`1<TypeDefinition> nested_types;
    private Collection`1<MethodDefinition> methods;
    private Collection`1<FieldDefinition> fields;
    private Collection`1<EventDefinition> events;
    private Collection`1<PropertyDefinition> properties;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    public TypeAttributes Attributes { get; public set; }
    public TypeReference BaseType { get; public set; }
    public string Name { get; public set; }
    public bool HasLayoutInfo { get; }
    public short PackingSize { get; public set; }
    public int ClassSize { get; public set; }
    public bool HasInterfaces { get; }
    public Collection`1<InterfaceImplementation> Interfaces { get; }
    public bool HasNestedTypes { get; }
    public Collection`1<TypeDefinition> NestedTypes { get; }
    public bool HasMethods { get; }
    public Collection`1<MethodDefinition> Methods { get; }
    public bool HasFields { get; }
    public Collection`1<FieldDefinition> Fields { get; }
    public bool HasEvents { get; }
    public Collection`1<EventDefinition> Events { get; }
    public bool HasProperties { get; }
    public Collection`1<PropertyDefinition> Properties { get; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsEnum { get; }
    public bool IsValueType { get; public set; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    internal TypeDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public TypeDefinition(string namespace, string name, TypeAttributes attributes);
    public TypeDefinition(string namespace, string name, TypeAttributes attributes, TypeReference baseType);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public TypeReference get_BaseType();
    public void set_BaseType(TypeReference value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public short get_PackingSize();
    public void set_PackingSize(short value);
    public int get_ClassSize();
    public void set_ClassSize(int value);
    public bool get_HasInterfaces();
    public Collection`1<InterfaceImplementation> get_Interfaces();
    public bool get_HasNestedTypes();
    public Collection`1<TypeDefinition> get_NestedTypes();
    public bool get_HasMethods();
    public Collection`1<MethodDefinition> get_Methods();
    public bool get_HasFields();
    public Collection`1<FieldDefinition> get_Fields();
    public bool get_HasEvents();
    public Collection`1<EventDefinition> get_Events();
    public bool get_HasProperties();
    public Collection`1<PropertyDefinition> get_Properties();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsEnum();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    internal TypeDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(TypeDefinitionProjection value);
    protected virtual void ClearFullName();
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeDefinitionCollection : Collection`1<TypeDefinition> {
    private ModuleDefinition container;
    private Dictionary`2<Row`2<string, string>, TypeDefinition> name_cache;
    internal TypeDefinitionCollection(ModuleDefinition container);
    internal TypeDefinitionCollection(ModuleDefinition container, int capacity);
    protected virtual void OnAdd(TypeDefinition item, int index);
    protected virtual void OnSet(TypeDefinition item, int index);
    protected virtual void OnInsert(TypeDefinition item, int index);
    protected virtual void OnRemove(TypeDefinition item, int index);
    protected virtual void OnClear();
    private void Attach(TypeDefinition type);
    private void Detach(TypeDefinition type);
    public TypeDefinition GetType(string fullname);
    public TypeDefinition GetType(string namespace, string name);
}
internal class Mono.Cecil.TypeDefinitionProjection : object {
    public TypeAttributes Attributes;
    public string Name;
    public TypeDefinitionTreatment Treatment;
    public Collection`1<MethodDefinition> RedirectedMethods;
    public Collection`1<KeyValuePair`2<InterfaceImplementation, InterfaceImplementation>> RedirectedInterfaces;
    public TypeDefinitionProjection(TypeDefinition type, TypeDefinitionTreatment treatment, Collection`1<MethodDefinition> redirectedMethods, Collection`1<KeyValuePair`2<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces);
}
[FlagsAttribute]
internal enum Mono.Cecil.TypeDefinitionTreatment : Enum {
    public int value__;
    public static TypeDefinitionTreatment None;
    public static TypeDefinitionTreatment KindMask;
    public static TypeDefinitionTreatment NormalType;
    public static TypeDefinitionTreatment NormalAttribute;
    public static TypeDefinitionTreatment UnmangleWindowsRuntimeName;
    public static TypeDefinitionTreatment PrefixWindowsRuntimeName;
    public static TypeDefinitionTreatment RedirectToClrType;
    public static TypeDefinitionTreatment RedirectToClrAttribute;
    public static TypeDefinitionTreatment RedirectImplementedMethods;
    public static TypeDefinitionTreatment Abstract;
    public static TypeDefinitionTreatment Internal;
}
internal class Mono.Cecil.TypeDefTable : MetadataTable`1<Row`6<TypeAttributes, UInt32, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.TypeParser : object {
    private string fullname;
    private int length;
    private int position;
    private TypeParser(string fullname);
    private Type ParseType(bool fq_name);
    private static bool TryGetArity(Type type);
    private static bool TryGetArity(string name, Int32& arity);
    private static bool ParseInt32(string value, Int32& result);
    private static void TryAddArity(string name, Int32& arity);
    private string ParsePart();
    private static bool IsDelimiter(char chr);
    private void TryParseWhiteSpace();
    private String[] ParseNestedNames();
    private bool TryParse(char chr);
    private static void Add(T[]& array, T item);
    private Int32[] ParseSpecs();
    private Type[] ParseGenericArguments(int arity);
    private string ParseAssemblyName();
    public static TypeReference ParseType(ModuleDefinition module, string fullname, bool typeDefinitionOnly);
    private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info, bool type_def_only);
    private static TypeReference CreateSpecs(TypeReference type, Type type_info);
    private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info);
    public static void SplitFullName(string fullname, String& namespace, String& name);
    private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope);
    private static void AdjustGenericParameters(TypeReference type);
    private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info);
    private static bool TryGetDefinition(ModuleDefinition module, Type type_info, TypeReference& type);
    private static bool TryCurrentModule(ModuleDefinition module, Type type_info);
    public static string ToParseable(TypeReference type, bool top_level);
    private static void AppendNamePart(string part, StringBuilder name);
    private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level);
    private static string GetScopeFullName(TypeReference type);
    private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name);
    private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level);
}
public class Mono.Cecil.TypeReference : MemberReference {
    private string namespace;
    private bool value_type;
    internal IMetadataScope scope;
    internal ModuleDefinition module;
    internal ElementType etype;
    private string fullname;
    protected Collection`1<GenericParameter> generic_parameters;
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public bool IsValueType { get; public set; }
    public ModuleDefinition Module { get; }
    internal TypeReferenceProjection WindowsRuntimeProjection { get; internal set; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsNested { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsByReference { get; }
    public bool IsPointer { get; }
    public bool IsSentinel { get; }
    public bool IsArray { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericInstance { get; }
    public bool IsRequiredModifier { get; }
    public bool IsOptionalModifier { get; }
    public bool IsPinned { get; }
    public bool IsFunctionPointer { get; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    protected TypeReference(string namespace, string name);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual ModuleDefinition get_Module();
    internal TypeReferenceProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(TypeReferenceProjection value);
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public bool get_IsNested();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsByReference();
    public virtual bool get_IsPointer();
    public virtual bool get_IsSentinel();
    public virtual bool get_IsArray();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_IsPinned();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    protected virtual void ClearFullName();
    public virtual TypeReference GetElementType();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeReferenceEqualityComparer : EqualityComparer`1<TypeReference> {
    public virtual bool Equals(TypeReference x, TypeReference y);
    public virtual int GetHashCode(TypeReference obj);
    public static bool AreEqual(TypeReference a, TypeReference b, TypeComparisonMode comparisonMode);
    private static bool AreEqual(GenericParameter a, GenericParameter b, TypeComparisonMode comparisonMode);
    private static bool AreEqual(GenericInstanceType a, GenericInstanceType b, TypeComparisonMode comparisonMode);
    public static int GetHashCodeFor(TypeReference obj);
}
internal class Mono.Cecil.TypeReferenceProjection : object {
    public string Name;
    public string Namespace;
    public IMetadataScope Scope;
    public TypeReferenceTreatment Treatment;
    public TypeReferenceProjection(TypeReference type, TypeReferenceTreatment treatment);
}
internal enum Mono.Cecil.TypeReferenceTreatment : Enum {
    public int value__;
    public static TypeReferenceTreatment None;
    public static TypeReferenceTreatment SystemDelegate;
    public static TypeReferenceTreatment SystemAttribute;
    public static TypeReferenceTreatment UseProjectionInfo;
}
internal class Mono.Cecil.TypeRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.TypeResolver : object {
    private IGenericInstance _typeDefinitionContext;
    private IGenericInstance _methodDefinitionContext;
    public TypeResolver(GenericInstanceType typeDefinitionContext);
    public TypeResolver(GenericInstanceMethod methodDefinitionContext);
    public TypeResolver(GenericInstanceType typeDefinitionContext, GenericInstanceMethod methodDefinitionContext);
    public static TypeResolver For(TypeReference typeReference);
    public static TypeResolver For(TypeReference typeReference, MethodReference methodReference);
    public MethodReference Resolve(MethodReference method);
    public FieldReference Resolve(FieldReference field);
    public TypeReference ResolveReturnType(MethodReference method);
    public TypeReference ResolveParameterType(MethodReference method, ParameterReference parameter);
    public TypeReference ResolveVariableType(MethodReference method, VariableReference variable);
    public TypeReference ResolveFieldType(FieldReference field);
    public TypeReference Resolve(TypeReference typeReference);
    public TypeReference Resolve(TypeReference typeReference, bool includeTypeDefinitions);
    internal TypeResolver Nested(GenericInstanceMethod genericInstanceMethod);
    private TypeReference ResolveGenericParameter(GenericParameter genericParameter);
    private TypeReference HandleOwnerlessInvalidILCode(GenericParameter genericParameter);
    private bool IsDummy();
}
internal abstract class Mono.Cecil.TypeSpecification : TypeReference {
    private TypeReference element_type;
    public TypeReference ElementType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public IMetadataScope Scope { get; public set; }
    public ModuleDefinition Module { get; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    internal TypeSpecification(TypeReference type);
    public sealed virtual TypeReference get_ElementType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual ModuleDefinition get_Module();
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public virtual TypeReference GetElementType();
}
internal class Mono.Cecil.TypeSpecTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.TypeSystem : object {
    private ModuleDefinition module;
    private TypeReference type_object;
    private TypeReference type_void;
    private TypeReference type_bool;
    private TypeReference type_char;
    private TypeReference type_sbyte;
    private TypeReference type_byte;
    private TypeReference type_int16;
    private TypeReference type_uint16;
    private TypeReference type_int32;
    private TypeReference type_uint32;
    private TypeReference type_int64;
    private TypeReference type_uint64;
    private TypeReference type_single;
    private TypeReference type_double;
    private TypeReference type_intptr;
    private TypeReference type_uintptr;
    private TypeReference type_string;
    private TypeReference type_typedref;
    [ObsoleteAttribute("Use CoreLibrary")]
public IMetadataScope Corlib { get; }
    public IMetadataScope CoreLibrary { get; }
    public TypeReference Object { get; }
    public TypeReference Void { get; }
    public TypeReference Boolean { get; }
    public TypeReference Char { get; }
    public TypeReference SByte { get; }
    public TypeReference Byte { get; }
    public TypeReference Int16 { get; }
    public TypeReference UInt16 { get; }
    public TypeReference Int32 { get; }
    public TypeReference UInt32 { get; }
    public TypeReference Int64 { get; }
    public TypeReference UInt64 { get; }
    public TypeReference Single { get; }
    public TypeReference Double { get; }
    public TypeReference IntPtr { get; }
    public TypeReference UIntPtr { get; }
    public TypeReference String { get; }
    public TypeReference TypedReference { get; }
    private TypeSystem(ModuleDefinition module);
    internal static TypeSystem CreateTypeSystem(ModuleDefinition module);
    internal abstract virtual TypeReference LookupType(string namespace, string name);
    private TypeReference LookupSystemType(TypeReference& reference, string name, ElementType element_type);
    private TypeReference LookupSystemValueType(TypeReference& typeRef, string name, ElementType element_type);
    public IMetadataScope get_Corlib();
    public IMetadataScope get_CoreLibrary();
    public TypeReference get_Object();
    public TypeReference get_Void();
    public TypeReference get_Boolean();
    public TypeReference get_Char();
    public TypeReference get_SByte();
    public TypeReference get_Byte();
    public TypeReference get_Int16();
    public TypeReference get_UInt16();
    public TypeReference get_Int32();
    public TypeReference get_UInt32();
    public TypeReference get_Int64();
    public TypeReference get_UInt64();
    public TypeReference get_Single();
    public TypeReference get_Double();
    public TypeReference get_IntPtr();
    public TypeReference get_UIntPtr();
    public TypeReference get_String();
    public TypeReference get_TypedReference();
}
internal enum Mono.Cecil.VariantType : Enum {
    public int value__;
    public static VariantType None;
    public static VariantType I2;
    public static VariantType I4;
    public static VariantType R4;
    public static VariantType R8;
    public static VariantType CY;
    public static VariantType Date;
    public static VariantType BStr;
    public static VariantType Dispatch;
    public static VariantType Error;
    public static VariantType Bool;
    public static VariantType Variant;
    public static VariantType Unknown;
    public static VariantType Decimal;
    public static VariantType I1;
    public static VariantType UI1;
    public static VariantType UI2;
    public static VariantType UI4;
    public static VariantType I8;
    public static VariantType UI8;
    public static VariantType Int;
    public static VariantType UInt;
}
internal class Mono.Cecil.WindowsRuntimeProjections : object {
    private static Version version;
    private static Byte[] contract_pk_token;
    private static Byte[] contract_pk;
    private static Dictionary`2<string, ProjectionInfo> projections;
    private ModuleDefinition module;
    private Version corlib_version;
    private AssemblyNameReference[] virtual_references;
    private static Dictionary`2<string, ProjectionInfo> Projections { get; }
    private AssemblyNameReference[] VirtualReferences { get; }
    public WindowsRuntimeProjections(ModuleDefinition module);
    private static WindowsRuntimeProjections();
    private static Dictionary`2<string, ProjectionInfo> get_Projections();
    private AssemblyNameReference[] get_VirtualReferences();
    public static void Project(TypeDefinition type);
    private static TypeDefinitionTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinition type);
    private static TypeDefinitionTreatment GenerateRedirectionInformation(TypeDefinition type, Collection`1& redirectedMethods, Collection`1& redirectedInterfaces);
    private static void CollectImplementedInterfaces(TypeReference type, HashSet`1<TypeReference> results);
    private static void RedirectInterfaceMethods(TypeReference interfaceType, Collection`1<MethodDefinition> redirectedMethods);
    private static bool IsRedirectedType(TypeReference type);
    private static bool NeedsWindowsRuntimePrefix(TypeDefinition type);
    public static bool IsClrImplementationType(TypeDefinition type);
    public static void ApplyProjection(TypeDefinition type, TypeDefinitionProjection projection);
    public static TypeDefinitionProjection RemoveProjection(TypeDefinition type);
    public static void Project(TypeReference type);
    private static TypeReferenceTreatment GetSpecialTypeReferenceTreatment(TypeReference type);
    private static bool IsAttribute(TypeReference type);
    private static bool IsEnum(TypeReference type);
    public static void ApplyProjection(TypeReference type, TypeReferenceProjection projection);
    public static TypeReferenceProjection RemoveProjection(TypeReference type);
    public static void Project(MethodDefinition method);
    private static MethodDefinitionTreatment GetMethodDefinitionTreatmentFromCustomAttributes(MethodDefinition method);
    public static void ApplyProjection(MethodDefinition method, MethodDefinitionProjection projection);
    public static MethodDefinitionProjection RemoveProjection(MethodDefinition method);
    public static void Project(FieldDefinition field);
    public static void ApplyProjection(FieldDefinition field, FieldDefinitionProjection projection);
    public static FieldDefinitionProjection RemoveProjection(FieldDefinition field);
    private static bool ImplementsRedirectedInterface(MemberReference member);
    public void AddVirtualReferences(Collection`1<AssemblyNameReference> references);
    public void RemoveVirtualReferences(Collection`1<AssemblyNameReference> references);
    private static AssemblyNameReference[] GetAssemblyReferences(AssemblyNameReference corlib);
    private static AssemblyNameReference GetCoreLibrary(Collection`1<AssemblyNameReference> references);
    private AssemblyNameReference GetAssemblyReference(string name);
    public static void Project(ICustomAttributeProvider owner, Collection`1<CustomAttribute> owner_attributes, CustomAttribute attribute);
    private static bool IsWindowsAttributeUsageAttribute(ICustomAttributeProvider owner, CustomAttribute attribute);
    private static bool HasAttribute(Collection`1<CustomAttribute> attributes, string namespace, string name);
    public static void ApplyProjection(CustomAttribute attribute, CustomAttributeValueProjection projection);
    public static CustomAttributeValueProjection RemoveProjection(CustomAttribute attribute);
}
public class Mono.Cecil.WriterParameters : object {
    private Nullable`1<UInt32> timestamp;
    private Stream symbol_stream;
    private ISymbolWriterProvider symbol_writer_provider;
    private bool write_symbols;
    private Byte[] key_blob;
    private string key_container;
    private StrongNameKeyPair key_pair;
    [CompilerGeneratedAttribute]
private bool <DeterministicMvid>k__BackingField;
    public Nullable`1<UInt32> Timestamp { get; public set; }
    public Stream SymbolStream { get; public set; }
    public ISymbolWriterProvider SymbolWriterProvider { get; public set; }
    public bool WriteSymbols { get; public set; }
    public bool HasStrongNameKey { get; }
    public Byte[] StrongNameKeyBlob { get; public set; }
    public string StrongNameKeyContainer { get; public set; }
    public StrongNameKeyPair StrongNameKeyPair { get; public set; }
    public bool DeterministicMvid { get; public set; }
    public Nullable`1<UInt32> get_Timestamp();
    public void set_Timestamp(Nullable`1<UInt32> value);
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolWriterProvider get_SymbolWriterProvider();
    public void set_SymbolWriterProvider(ISymbolWriterProvider value);
    public bool get_WriteSymbols();
    public void set_WriteSymbols(bool value);
    public bool get_HasStrongNameKey();
    public Byte[] get_StrongNameKeyBlob();
    public void set_StrongNameKeyBlob(Byte[] value);
    public string get_StrongNameKeyContainer();
    public void set_StrongNameKeyContainer(string value);
    public StrongNameKeyPair get_StrongNameKeyPair();
    public void set_StrongNameKeyPair(StrongNameKeyPair value);
    [CompilerGeneratedAttribute]
public bool get_DeterministicMvid();
    [CompilerGeneratedAttribute]
public void set_DeterministicMvid(bool value);
}
[DefaultMemberAttribute("Item")]
public class Mono.Collections.Generic.Collection`1 : object {
    internal T[] items;
    internal int size;
    private int version;
    public int Count { get; }
    public T Item { get; public set; }
    public int Capacity { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Collection`1(int capacity);
    public Collection`1(ICollection`1<T> items);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public int get_Capacity();
    public void set_Capacity(int value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    private void CheckIndex(int index);
    private void Shift(int start, int delta);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnSet(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnClear();
    internal virtual void Grow(int desired);
    protected void Resize(int new_size);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
internal class Mono.Collections.Generic.ReadOnlyCollection`1 : Collection`1<T> {
    private static ReadOnlyCollection`1<T> empty;
    public static ReadOnlyCollection`1<T> Empty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    public ReadOnlyCollection`1(T[] array);
    public ReadOnlyCollection`1(Collection`1<T> collection);
    public static ReadOnlyCollection`1<T> get_Empty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private void Initialize(T[] items, int size);
    internal virtual void Grow(int desired);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnClear();
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnSet(T item, int index);
}
internal class Mono.CompilerServices.SymbolWriter.AnonymousScopeEntry : object {
    public int ID;
    private List`1<CapturedVariable> captured_vars;
    private List`1<CapturedScope> captured_scopes;
    public CapturedVariable[] CapturedVariables { get; }
    public CapturedScope[] CapturedScopes { get; }
    public AnonymousScopeEntry(int id);
    internal AnonymousScopeEntry(MyBinaryReader reader);
    internal void AddCapturedVariable(string name, string captured_name, CapturedKind kind);
    public CapturedVariable[] get_CapturedVariables();
    internal void AddCapturedScope(int scope, string captured_name);
    public CapturedScope[] get_CapturedScopes();
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CapturedScope : ValueType {
    public int Scope;
    public string CapturedName;
    public CapturedScope(int scope, string captured_name);
    internal CapturedScope(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CapturedVariable : ValueType {
    public string Name;
    public string CapturedName;
    public CapturedKind Kind;
    public CapturedVariable(string name, string captured_name, CapturedKind kind);
    internal CapturedVariable(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CodeBlockEntry : object {
    public int Index;
    public int Parent;
    public Type BlockType;
    public int StartOffset;
    public int EndOffset;
    public CodeBlockEntry(int index, int parent, Type type, int start_offset);
    internal CodeBlockEntry(int index, MyBinaryReader reader);
    public void Close(int end_offset);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CompileUnitEntry : object {
    public int Index;
    private int DataOffset;
    private MonoSymbolFile file;
    private SourceFileEntry source;
    private List`1<SourceFileEntry> include_files;
    private List`1<NamespaceEntry> namespaces;
    private bool creating;
    public static int Size { get; }
    private CompileUnitEntry Mono.CompilerServices.SymbolWriter.ICompileUnit.Entry { get; }
    public SourceFileEntry SourceFile { get; }
    public NamespaceEntry[] Namespaces { get; }
    public SourceFileEntry[] IncludeFiles { get; }
    public CompileUnitEntry(MonoSymbolFile file, SourceFileEntry source);
    internal CompileUnitEntry(MonoSymbolFile file, MyBinaryReader reader);
    public static int get_Size();
    private sealed virtual override CompileUnitEntry Mono.CompilerServices.SymbolWriter.ICompileUnit.get_Entry();
    public void AddFile(SourceFileEntry file);
    public SourceFileEntry get_SourceFile();
    public int DefineNamespace(string name, String[] using_clauses, int parent);
    internal void WriteData(MyBinaryWriter bw);
    internal void Write(BinaryWriter bw);
    public void ReadAll();
    private void ReadData();
    public NamespaceEntry[] get_Namespaces();
    public SourceFileEntry[] get_IncludeFiles();
}
internal interface Mono.CompilerServices.SymbolWriter.ICompileUnit {
    public CompileUnitEntry Entry { get; }
    public abstract virtual CompileUnitEntry get_Entry();
}
internal interface Mono.CompilerServices.SymbolWriter.IMethodDef {
    public string Name { get; }
    public int Token { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_Token();
}
internal interface Mono.CompilerServices.SymbolWriter.ISourceFile {
    public SourceFileEntry Entry { get; }
    public abstract virtual SourceFileEntry get_Entry();
}
internal class Mono.CompilerServices.SymbolWriter.LineNumberEntry : object {
    public int Row;
    public int Column;
    public int EndRow;
    public int EndColumn;
    public int File;
    public int Offset;
    public bool IsHidden;
    public static LineNumberEntry Null;
    public LineNumberEntry(int file, int row, int column, int offset);
    public LineNumberEntry(int file, int row, int offset);
    public LineNumberEntry(int file, int row, int column, int offset, bool is_hidden);
    public LineNumberEntry(int file, int row, int column, int end_row, int end_column, int offset, bool is_hidden);
    private static LineNumberEntry();
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.LineNumberTable : object {
    protected LineNumberEntry[] _line_numbers;
    public int LineBase;
    public int LineRange;
    public byte OpcodeBase;
    public int MaxAddressIncrement;
    public static int Default_LineBase;
    public static int Default_LineRange;
    public static byte Default_OpcodeBase;
    public static byte DW_LNS_copy;
    public static byte DW_LNS_advance_pc;
    public static byte DW_LNS_advance_line;
    public static byte DW_LNS_set_file;
    public static byte DW_LNS_const_add_pc;
    public static byte DW_LNE_end_sequence;
    public static byte DW_LNE_MONO_negate_is_hidden;
    internal static byte DW_LNE_MONO__extensions_start;
    internal static byte DW_LNE_MONO__extensions_end;
    public LineNumberEntry[] LineNumbers { get; }
    protected LineNumberTable(MonoSymbolFile file);
    internal LineNumberTable(MonoSymbolFile file, LineNumberEntry[] lines);
    public LineNumberEntry[] get_LineNumbers();
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw, bool hasColumnsInfo, bool hasEndInfo);
    internal static LineNumberTable Read(MonoSymbolFile file, MyBinaryReader br, bool readColumnsInfo, bool readEndInfo);
    private void DoRead(MonoSymbolFile file, MyBinaryReader br, bool includesColumns, bool includesEnds);
    public bool GetMethodBounds(LineNumberEntry& start, LineNumberEntry& end);
}
internal class Mono.CompilerServices.SymbolWriter.LocalVariableEntry : ValueType {
    public int Index;
    public string Name;
    public int BlockIndex;
    public LocalVariableEntry(int index, string name, int block);
    internal LocalVariableEntry(MonoSymbolFile file, MyBinaryReader reader);
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.MethodEntry : object {
    public int CompileUnitIndex;
    public int Token;
    public int NamespaceID;
    private int DataOffset;
    private int LocalVariableTableOffset;
    private int LineNumberTableOffset;
    private int CodeBlockTableOffset;
    private int ScopeVariableTableOffset;
    private int RealNameOffset;
    private Flags flags;
    private int index;
    public CompileUnitEntry CompileUnit;
    private LocalVariableEntry[] locals;
    private CodeBlockEntry[] code_blocks;
    private ScopeVariable[] scope_vars;
    private LineNumberTable lnt;
    private string real_name;
    public MonoSymbolFile SymbolFile;
    public static int Size;
    public Flags MethodFlags { get; }
    public int Index { get; public set; }
    internal MethodEntry(MonoSymbolFile file, MyBinaryReader reader, int index);
    internal MethodEntry(MonoSymbolFile file, CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id);
    public Flags get_MethodFlags();
    public int get_Index();
    public void set_Index(int value);
    private static void CheckLineNumberTable(LineNumberEntry[] line_numbers);
    internal void Write(MyBinaryWriter bw);
    internal void WriteData(MonoSymbolFile file, MyBinaryWriter bw);
    public void ReadAll();
    public LineNumberTable GetLineNumberTable();
    public LocalVariableEntry[] GetLocals();
    public CodeBlockEntry[] GetCodeBlocks();
    public ScopeVariable[] GetScopeVariables();
    public string GetRealName();
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolFile : object {
    private List`1<MethodEntry> methods;
    private List`1<SourceFileEntry> sources;
    private List`1<CompileUnitEntry> comp_units;
    private Dictionary`2<int, AnonymousScopeEntry> anonymous_scopes;
    private OffsetTable ot;
    private int last_type_index;
    private int last_method_index;
    private int last_namespace_index;
    public int MajorVersion;
    public int MinorVersion;
    public int NumLineNumbers;
    private MyBinaryReader reader;
    private Dictionary`2<int, SourceFileEntry> source_file_hash;
    private Dictionary`2<int, CompileUnitEntry> compile_unit_hash;
    private List`1<MethodEntry> method_list;
    private Dictionary`2<int, MethodEntry> method_token_hash;
    private Dictionary`2<string, int> source_name_hash;
    private Guid guid;
    internal int LineNumberCount;
    internal int LocalCount;
    internal int StringSize;
    internal int LineNumberSize;
    internal int ExtendedLineNumberSize;
    public int CompileUnitCount { get; }
    public int SourceCount { get; }
    public int MethodCount { get; }
    public int TypeCount { get; }
    public int AnonymousScopeCount { get; }
    public int NamespaceCount { get; }
    public Guid Guid { get; }
    public OffsetTable OffsetTable { get; }
    public SourceFileEntry[] Sources { get; }
    public CompileUnitEntry[] CompileUnits { get; }
    public MethodEntry[] Methods { get; }
    internal MyBinaryReader BinaryReader { get; }
    private MonoSymbolFile(Stream stream);
    public int AddSource(SourceFileEntry source);
    public int AddCompileUnit(CompileUnitEntry entry);
    public void AddMethod(MethodEntry entry);
    public MethodEntry DefineMethod(CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id);
    internal void DefineAnonymousScope(int id);
    internal void DefineCapturedVariable(int scope_id, string name, string captured_name, CapturedKind kind);
    internal void DefineCapturedScope(int scope_id, int id, string captured_name);
    internal int GetNextTypeIndex();
    internal int GetNextMethodIndex();
    internal int GetNextNamespaceIndex();
    private void Write(MyBinaryWriter bw, Guid guid);
    public void CreateSymbolFile(Guid guid, FileStream fs);
    public static MonoSymbolFile ReadSymbolFile(string mdbFilename);
    public static MonoSymbolFile ReadSymbolFile(string mdbFilename, Guid assemblyGuid);
    public static MonoSymbolFile ReadSymbolFile(Stream stream);
    public int get_CompileUnitCount();
    public int get_SourceCount();
    public int get_MethodCount();
    public int get_TypeCount();
    public int get_AnonymousScopeCount();
    public int get_NamespaceCount();
    public Guid get_Guid();
    public OffsetTable get_OffsetTable();
    public SourceFileEntry GetSourceFile(int index);
    public SourceFileEntry[] get_Sources();
    public CompileUnitEntry GetCompileUnit(int index);
    public CompileUnitEntry[] get_CompileUnits();
    private void read_methods();
    public MethodEntry GetMethodByToken(int token);
    public MethodEntry GetMethod(int index);
    public MethodEntry[] get_Methods();
    public int FindSource(string file_name);
    public AnonymousScopeEntry GetAnonymousScope(int id);
    internal MyBinaryReader get_BinaryReader();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolFileException : Exception {
    public MonoSymbolFileException(string message, Object[] args);
    public MonoSymbolFileException(string message, Exception innerException);
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolWriter : object {
    private List`1<SourceMethodBuilder> methods;
    private List`1<SourceFileEntry> sources;
    private List`1<CompileUnitEntry> comp_units;
    protected MonoSymbolFile file;
    private string filename;
    private SourceMethodBuilder current_method;
    private Stack`1<SourceMethodBuilder> current_method_stack;
    public MonoSymbolFile SymbolFile { get; }
    public MonoSymbolWriter(string filename);
    public MonoSymbolFile get_SymbolFile();
    public void CloseNamespace();
    public void DefineLocalVariable(int index, string name);
    public void DefineCapturedLocal(int scope_id, string name, string captured_name);
    public void DefineCapturedParameter(int scope_id, string name, string captured_name);
    public void DefineCapturedThis(int scope_id, string captured_name);
    public void DefineCapturedScope(int scope_id, int id, string captured_name);
    public void DefineScopeVariable(int scope, int index);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden);
    public SourceMethodBuilder OpenMethod(ICompileUnit file, int ns_id, IMethodDef method);
    public void CloseMethod();
    public SourceFileEntry DefineDocument(string url);
    public SourceFileEntry DefineDocument(string url, Byte[] guid, Byte[] checksum);
    public CompileUnitEntry DefineCompilationUnit(SourceFileEntry source);
    public int DefineNamespace(string name, CompileUnitEntry unit, String[] using_clauses, int parent);
    public int OpenScope(int start_offset);
    public void CloseScope(int end_offset);
    public void OpenCompilerGeneratedBlock(int start_offset);
    public void CloseCompilerGeneratedBlock(int end_offset);
    public void StartIteratorBody(int start_offset);
    public void EndIteratorBody(int end_offset);
    public void StartIteratorDispatcher(int start_offset);
    public void EndIteratorDispatcher(int end_offset);
    public void DefineAnonymousScope(int id);
    public void WriteSymbolFile(Guid guid);
}
internal class Mono.CompilerServices.SymbolWriter.MyBinaryReader : BinaryReader {
    public MyBinaryReader(Stream stream);
    public int ReadLeb128();
    public string ReadString(int offset);
}
internal class Mono.CompilerServices.SymbolWriter.MyBinaryWriter : BinaryWriter {
    public MyBinaryWriter(Stream stream);
    public void WriteLeb128(int value);
}
internal class Mono.CompilerServices.SymbolWriter.NamespaceEntry : ValueType {
    public string Name;
    public int Index;
    public int Parent;
    public String[] UsingClauses;
    public NamespaceEntry(string name, int index, String[] using_clauses, int parent);
    internal NamespaceEntry(MonoSymbolFile file, MyBinaryReader reader);
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.OffsetTable : object {
    public static int MajorVersion;
    public static int MinorVersion;
    public static long Magic;
    public int TotalFileSize;
    public int DataSectionOffset;
    public int DataSectionSize;
    public int CompileUnitCount;
    public int CompileUnitTableOffset;
    public int CompileUnitTableSize;
    public int SourceCount;
    public int SourceTableOffset;
    public int SourceTableSize;
    public int MethodCount;
    public int MethodTableOffset;
    public int MethodTableSize;
    public int TypeCount;
    public int AnonymousScopeCount;
    public int AnonymousScopeTableOffset;
    public int AnonymousScopeTableSize;
    public Flags FileFlags;
    public int LineNumberTable_LineBase;
    public int LineNumberTable_LineRange;
    public int LineNumberTable_OpcodeBase;
    internal OffsetTable(BinaryReader reader, int major_version, int minor_version);
    internal void Write(BinaryWriter bw, int major_version, int minor_version);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.ScopeVariable : ValueType {
    public int Scope;
    public int Index;
    public ScopeVariable(int scope, int index);
    internal ScopeVariable(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.SourceFileEntry : object {
    public int Index;
    private int DataOffset;
    private MonoSymbolFile file;
    private string file_name;
    private Byte[] guid;
    private Byte[] hash;
    private bool creating;
    private bool auto_generated;
    private string sourceFile;
    public static int Size { get; }
    public Byte[] Checksum { get; }
    public string FileName { get; public set; }
    public bool AutoGenerated { get; }
    public SourceFileEntry(MonoSymbolFile file, string file_name);
    public SourceFileEntry(MonoSymbolFile file, string sourceFile, Byte[] guid, Byte[] checksum);
    public SourceFileEntry(MonoSymbolFile file, string fileName, string sourceFile, Byte[] guid, Byte[] checksum);
    internal SourceFileEntry(MonoSymbolFile file, MyBinaryReader reader);
    public static int get_Size();
    public Byte[] get_Checksum();
    internal void WriteData(MyBinaryWriter bw);
    internal void Write(BinaryWriter bw);
    public string get_FileName();
    public void set_FileName(string value);
    public bool get_AutoGenerated();
    public void SetAutoGenerated();
    public bool CheckChecksum();
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.SourceMethodBuilder : object {
    private List`1<LocalVariableEntry> _locals;
    private List`1<CodeBlockEntry> _blocks;
    private List`1<ScopeVariable> _scope_vars;
    private Stack`1<CodeBlockEntry> _block_stack;
    private List`1<LineNumberEntry> method_lines;
    private ICompileUnit _comp_unit;
    private int ns_id;
    private IMethodDef method;
    public CodeBlockEntry[] Blocks { get; }
    public CodeBlockEntry CurrentBlock { get; }
    public LocalVariableEntry[] Locals { get; }
    public ICompileUnit SourceFile { get; }
    public ScopeVariable[] ScopeVariables { get; }
    public SourceMethodBuilder(ICompileUnit comp_unit);
    public SourceMethodBuilder(ICompileUnit comp_unit, int ns_id, IMethodDef method);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, int end_line, int end_column, bool is_hidden);
    public void StartBlock(Type type, int start_offset);
    public void StartBlock(Type type, int start_offset, int scopeIndex);
    public void EndBlock(int end_offset);
    public CodeBlockEntry[] get_Blocks();
    public CodeBlockEntry get_CurrentBlock();
    public LocalVariableEntry[] get_Locals();
    public ICompileUnit get_SourceFile();
    public void AddLocal(int index, string name);
    public ScopeVariable[] get_ScopeVariables();
    public void AddScopeVariable(int scope, int index);
    public void DefineMethod(MonoSymbolFile file);
    public void DefineMethod(MonoSymbolFile file, int token);
}
internal static class Mono.Disposable : object {
    public static Disposable`1<T> Owned(T value);
    public static Disposable`1<T> NotOwned(T value);
}
internal class Mono.Disposable`1 : ValueType {
    internal T value;
    private bool owned;
    public Disposable`1(T value, bool owned);
    public sealed virtual void Dispose();
}
internal static class Mono.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
internal class Mono.MergeSort`1 : object {
    private T[] elements;
    private T[] buffer;
    private IComparer`1<T> comparer;
    private MergeSort`1(T[] elements, IComparer`1<T> comparer);
    public static void Sort(T[] source, IComparer`1<T> comparer);
    public static void Sort(T[] source, int start, int length, IComparer`1<T> comparer);
    private void Sort(int start, int length);
    private void TopDownSplitMerge(T[] a, T[] b, int start, int end);
    private void TopDownMerge(T[] a, T[] b, int start, int middle, int end);
}
internal static class Mono.Security.Cryptography.CryptoConvert : object {
    private static int ToInt32LE(Byte[] bytes, int offset);
    private static UInt32 ToUInt32LE(Byte[] bytes, int offset);
    private static Byte[] GetBytesLE(int val);
    private static Byte[] Trim(Byte[] array);
    private static RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset);
    private static RSA FromCapiPublicKeyBlob(Byte[] blob, int offset);
    public static RSA FromCapiKeyBlob(Byte[] blob);
    public static RSA FromCapiKeyBlob(Byte[] blob, int offset);
    public static Byte[] ToCapiPublicKeyBlob(RSA rsa);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[DefaultMemberAttribute("Item")]
internal class System.ReadOnlySpan`1 : ValueType {
    [NullableAttribute("1")]
private string _s;
    private int _start;
    private int _length;
    public int Length { get; }
    public char Item { get; }
    public bool IsEmpty { get; }
    public static ReadOnlySpan`1<char> Empty { get; }
    [NullableContextAttribute("1")]
public ReadOnlySpan`1(string s);
    [NullableContextAttribute("1")]
public ReadOnlySpan`1(string s, int start, int len);
    public int get_Length();
    [NullableContextAttribute("1")]
public static ReadOnlySpan`1<T> op_Implicit(string s);
    public char get_Item(int c);
    public bool get_IsEmpty();
    public ReadOnlySpan`1<char> Slice(int start, int len);
    public static ReadOnlySpan`1<char> get_Empty();
    public ReadOnlySpan`1<char> Slice(int start);
    public bool SequenceEqual(ReadOnlySpan`1<char> other);
    public ReadOnlySpan`1<char> TrimStart();
    public ReadOnlySpan`1<char> TrimEnd();
    public ReadOnlySpan`1<char> Trim();
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal int IndexOf(ReadOnlySpan`1<char> v, StringComparison ordinal, int start);
    [NullableContextAttribute("1")]
public static ReadOnlySpan`1<T> op_Implicit(Char[] arr);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
[ExtensionAttribute]
internal static class System.SpanCompatExtensions : object {
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.StringCompatibilityExtensions : object {
    [ExtensionAttribute]
public static bool Contains(string str, char search);
    [ExtensionAttribute]
public static bool EndsWith(string str, char search);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsTopLevelInternal(Type t);
    [ExtensionAttribute]
public static bool IsNestedlPublic_Or_Internal(Type t);
}
internal interface XamlX.Ast.ISkipXamlAstNode {
}
internal interface XamlX.Ast.IXamlAstImperativeNode {
}
internal interface XamlX.Ast.IXamlAstManipulationNode {
}
[NullableContextAttribute("1")]
internal interface XamlX.Ast.IXamlAstNode {
    public abstract virtual void VisitChildren(IXamlAstVisitor visitor);
    public abstract virtual IXamlAstNode Visit(IXamlAstVisitor visitor);
}
internal interface XamlX.Ast.IXamlAstNodeNeedsParentStack {
    public bool NeedsParentStack { get; }
    public abstract virtual bool get_NeedsParentStack();
}
internal interface XamlX.Ast.IXamlAstPropertyReference {
}
internal interface XamlX.Ast.IXamlAstTypeReference {
    public bool IsMarkupExtension { get; }
    public abstract virtual bool get_IsMarkupExtension();
    [NullableContextAttribute("1")]
public abstract virtual bool Equals(IXamlAstTypeReference other);
}
internal interface XamlX.Ast.IXamlAstValueNode {
    [NullableAttribute("1")]
public IXamlAstTypeReference Type { get; }
    [NullableContextAttribute("1")]
public abstract virtual IXamlAstTypeReference get_Type();
}
[NullableContextAttribute("1")]
internal interface XamlX.Ast.IXamlAstVisitor {
    public abstract virtual IXamlAstNode Visit(IXamlAstNode node);
    public abstract virtual void Push(IXamlAstNode node);
    public abstract virtual void Pop();
}
internal interface XamlX.Ast.IXamlILOptimizedEmitablePropertySetter {
    [NullableContextAttribute("1")]
public abstract virtual void EmitWithArguments(XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter emitter, IReadOnlyList`1<IXamlAstValueNode> arguments);
}
internal interface XamlX.Ast.IXamlLineInfo {
    public int Line { get; public set; }
    public int Position { get; public set; }
    public abstract virtual int get_Line();
    public abstract virtual void set_Line(int value);
    public abstract virtual int get_Position();
    public abstract virtual void set_Position(int value);
}
[NullableContextAttribute("1")]
internal interface XamlX.Ast.IXamlPropertySetter {
    public IXamlType TargetType { get; }
    public PropertySetterBinderParameters BinderParameters { get; }
    public IReadOnlyList`1<IXamlType> Parameters { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public abstract virtual IXamlType get_TargetType();
    public abstract virtual PropertySetterBinderParameters get_BinderParameters();
    public abstract virtual IReadOnlyList`1<IXamlType> get_Parameters();
    public abstract virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
}
[NullableContextAttribute("1")]
internal interface XamlX.Ast.IXamlWrappedMethod {
    public string Name { get; }
    public IXamlType ReturnType { get; }
    public IXamlType DeclaringType { get; }
    public IReadOnlyList`1<IXamlType> ParametersWithThis { get; }
    public abstract virtual string get_Name();
    public abstract virtual IXamlType get_ReturnType();
    public abstract virtual IXamlType get_DeclaringType();
    public abstract virtual IReadOnlyList`1<IXamlType> get_ParametersWithThis();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class XamlX.Ast.PropertySetterBinderParameters : object {
    [CompilerGeneratedAttribute]
private bool <AllowMultiple>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowXNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowRuntimeNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAttributeSyntax>k__BackingField;
    public bool AllowMultiple { get; public set; }
    public bool AllowXNull { get; public set; }
    public bool AllowRuntimeNull { get; public set; }
    public bool AllowAttributeSyntax { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowMultiple();
    [CompilerGeneratedAttribute]
public void set_AllowMultiple(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowXNull();
    [CompilerGeneratedAttribute]
public void set_AllowXNull(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowRuntimeNull();
    [CompilerGeneratedAttribute]
public void set_AllowRuntimeNull(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAttributeSyntax();
    [CompilerGeneratedAttribute]
public void set_AllowAttributeSyntax(bool value);
    public sealed virtual bool Equals(PropertySetterBinderParameters other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class XamlX.Ast.SkipXamlAstNode : XamlAstNode {
    [NullableAttribute("1")]
public IXamlAstTypeReference Type { get; }
    [NullableContextAttribute("1")]
public SkipXamlAstNode(IXamlLineInfo lineInfo);
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstTypeReference get_Type();
    [NullableContextAttribute("1")]
public virtual void VisitChildren(IXamlAstVisitor visitor);
}
internal class XamlX.Ast.SkipXamlValueWithManipulationNode : XamlValueWithManipulationNode {
    [NullableContextAttribute("1")]
public SkipXamlValueWithManipulationNode(IXamlLineInfo lineInfo);
    [NullableContextAttribute("1")]
public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstClrProperty : XamlAstNode {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFamily>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlMethod <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlPropertySetter> <Setters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlCustomAttribute> <CustomAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IXamlType, IXamlType> <TypeConverters>k__BackingField;
    public string Name { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamily { get; public set; }
    [NullableAttribute("2")]
public IXamlMethod Getter { get; public set; }
    public List`1<IXamlPropertySetter> Setters { get; public set; }
    public List`1<IXamlCustomAttribute> CustomAttributes { get; public set; }
    public IXamlType DeclaringType { get; public set; }
    public Dictionary`2<IXamlType, IXamlType> TypeConverters { get; public set; }
    public XamlAstClrProperty(IXamlLineInfo lineInfo, IXamlProperty property, TransformerConfiguration cfg);
    public XamlAstClrProperty(IXamlLineInfo lineInfo, string name, IXamlType declaringType, IXamlMethod getter, IEnumerable`1<IXamlPropertySetter> setters);
    public XamlAstClrProperty(IXamlLineInfo lineInfo, string name, IXamlType declaringType, IXamlMethod getter, IXamlMethod[] setters);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public void set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPrivate();
    [CompilerGeneratedAttribute]
public void set_IsPrivate(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFamily();
    [CompilerGeneratedAttribute]
public void set_IsFamily(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IXamlMethod get_Getter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Getter(IXamlMethod value);
    [CompilerGeneratedAttribute]
public List`1<IXamlPropertySetter> get_Setters();
    [CompilerGeneratedAttribute]
public void set_Setters(List`1<IXamlPropertySetter> value);
    [CompilerGeneratedAttribute]
public List`1<IXamlCustomAttribute> get_CustomAttributes();
    [CompilerGeneratedAttribute]
public void set_CustomAttributes(List`1<IXamlCustomAttribute> value);
    [CompilerGeneratedAttribute]
public IXamlType get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(IXamlType value);
    [CompilerGeneratedAttribute]
public Dictionary`2<IXamlType, IXamlType> get_TypeConverters();
    [CompilerGeneratedAttribute]
public void set_TypeConverters(Dictionary`2<IXamlType, IXamlType> value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstClrTypeReference : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarkupExtension>k__BackingField;
    public IXamlType Type { get; }
    public bool IsMarkupExtension { get; }
    public XamlAstClrTypeReference(IXamlLineInfo lineInfo, IXamlType type, bool isMarkupExtension);
    [CompilerGeneratedAttribute]
public IXamlType get_Type();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMarkupExtension();
    public sealed virtual bool Equals(IXamlAstTypeReference other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstCompilerLocalNode : XamlAstNode {
    private XamlAstClrTypeReference _typeReference;
    [CompilerGeneratedAttribute]
private IXamlType <Type>k__BackingField;
    public IXamlType Type { get; }
    private IXamlAstTypeReference XamlX.Ast.IXamlAstValueNode.Type { get; }
    public XamlAstCompilerLocalNode(IXamlLineInfo lineInfo, XamlAstClrTypeReference type);
    public XamlAstCompilerLocalNode(IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlType get_Type();
    private sealed virtual override IXamlAstTypeReference XamlX.Ast.IXamlAstValueNode.get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstConstructableObjectNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstValueNode> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstNode> <Children>k__BackingField;
    public IXamlAstTypeReference Type { get; public set; }
    public IXamlConstructor Constructor { get; }
    public List`1<IXamlAstValueNode> Arguments { get; public set; }
    public List`1<IXamlAstNode> Children { get; public set; }
    public XamlAstConstructableObjectNode(IXamlLineInfo lineInfo, XamlAstClrTypeReference type, IXamlConstructor ctor, List`1<IXamlAstValueNode> arguments, List`1<IXamlAstNode> children);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlAstTypeReference value);
    [CompilerGeneratedAttribute]
public IXamlConstructor get_Constructor();
    [CompilerGeneratedAttribute]
public List`1<IXamlAstValueNode> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<IXamlAstValueNode> value);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstNode> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(List`1<IXamlAstNode> value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstContextLocalNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public XamlAstContextLocalNode(IXamlLineInfo lineInfo, IXamlType type);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class XamlX.Ast.XamlAstExtensions : object {
    [ExtensionAttribute]
public static IXamlType GetClrType(IXamlAstTypeReference r);
    [ExtensionAttribute]
public static XamlAstClrTypeReference GetClrTypeReference(IXamlAstTypeReference r);
    [ExtensionAttribute]
public static XamlAstClrProperty GetClrProperty(IXamlAstPropertyReference r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstImperativeValueManipulation : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstManipulationNode <Manipulation>k__BackingField;
    public IXamlAstValueNode Value { get; public set; }
    public IXamlAstManipulationNode Manipulation { get; public set; }
    public XamlAstImperativeValueManipulation(IXamlLineInfo lineInfo, IXamlAstValueNode value, IXamlAstManipulationNode manipulation);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlAstManipulationNode get_Manipulation();
    [CompilerGeneratedAttribute]
public void set_Manipulation(IXamlAstManipulationNode value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstLocalInitializationNodeEmitter : XamlValueWithSideEffectNodeBase {
    [CompilerGeneratedAttribute]
private XamlAstCompilerLocalNode <Local>k__BackingField;
    public XamlAstCompilerLocalNode Local { get; public set; }
    public XamlAstLocalInitializationNodeEmitter(IXamlLineInfo lineInfo, IXamlAstValueNode value, XamlAstCompilerLocalNode local);
    [CompilerGeneratedAttribute]
public XamlAstCompilerLocalNode get_Local();
    [CompilerGeneratedAttribute]
public void set_Local(XamlAstCompilerLocalNode value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstManipulationImperativeNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstImperativeNode <Imperative>k__BackingField;
    public IXamlAstImperativeNode Imperative { get; public set; }
    public XamlAstManipulationImperativeNode(IXamlLineInfo lineInfo, IXamlAstImperativeNode imperative);
    [CompilerGeneratedAttribute]
public IXamlAstImperativeNode get_Imperative();
    [CompilerGeneratedAttribute]
public void set_Imperative(IXamlAstImperativeNode value);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstNamePropertyReference : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <TargetType>k__BackingField;
    public IXamlAstTypeReference DeclaringType { get; public set; }
    public string Name { get; public set; }
    public IXamlAstTypeReference TargetType { get; public set; }
    public XamlAstNamePropertyReference(IXamlLineInfo lineInfo, IXamlAstTypeReference declaringType, string name, IXamlAstTypeReference targetType);
    [CompilerGeneratedAttribute]
public IXamlAstTypeReference get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(IXamlAstTypeReference value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IXamlAstTypeReference get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(IXamlAstTypeReference value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
internal class XamlX.Ast.XamlAstNeedsParentStackValueNode : XamlValueWithSideEffectNodeBase {
    public bool NeedsParentStack { get; }
    [NullableContextAttribute("1")]
public XamlAstNeedsParentStackValueNode(IXamlLineInfo lineInfo, IXamlAstValueNode value);
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    public sealed virtual bool get_NeedsParentStack();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstNewClrObjectNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructor <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstValueNode> <Arguments>k__BackingField;
    public IXamlAstTypeReference Type { get; public set; }
    public IXamlConstructor Constructor { get; }
    public List`1<IXamlAstValueNode> Arguments { get; public set; }
    public XamlAstNewClrObjectNode(IXamlLineInfo lineInfo, XamlAstClrTypeReference type, IXamlConstructor ctor, List`1<IXamlAstValueNode> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlAstTypeReference value);
    [CompilerGeneratedAttribute]
public IXamlConstructor get_Constructor();
    [CompilerGeneratedAttribute]
public List`1<IXamlAstValueNode> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<IXamlAstValueNode> value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class XamlX.Ast.XamlAstNode : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Line { get; public set; }
    public int Position { get; public set; }
    public XamlAstNode(IXamlLineInfo lineInfo);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Line();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Line(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Position(int value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public sealed virtual IXamlAstNode Visit(IXamlAstVisitor visitor);
    protected static void VisitList(IList`1<T> list, IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstObjectNode : XamlAstNode {
    private IXamlAstTypeReference _type;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstNode> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstValueNode> <Arguments>k__BackingField;
    public IXamlAstTypeReference Type { get; public set; }
    public List`1<IXamlAstNode> Children { get; public set; }
    public List`1<IXamlAstValueNode> Arguments { get; public set; }
    public XamlAstObjectNode(IXamlLineInfo lineInfo, IXamlAstTypeReference type);
    public sealed virtual IXamlAstTypeReference get_Type();
    public void set_Type(IXamlAstTypeReference value);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstNode> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(List`1<IXamlAstNode> value);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstValueNode> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<IXamlAstValueNode> value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstRuntimeCastNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstValueNode Value { get; public set; }
    public IXamlAstTypeReference Type { get; public set; }
    public XamlAstRuntimeCastNode(IXamlLineInfo lineInfo, IXamlAstValueNode value, IXamlAstTypeReference castTo);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlAstTypeReference value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstTextNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public string Text { get; public set; }
    public bool PreserveWhitespace { get; }
    public IXamlAstTypeReference Type { get; public set; }
    public XamlAstTextNode(IXamlLineInfo lineInfo, string text, bool preserveWhitespace, IXamlType type);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public bool get_PreserveWhitespace();
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlAstTypeReference value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstXamlPropertyValueNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstPropertyReference <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstValueNode> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttributeSyntax>k__BackingField;
    public IXamlAstPropertyReference Property { get; public set; }
    public List`1<IXamlAstValueNode> Values { get; public set; }
    public bool IsAttributeSyntax { get; }
    public XamlAstXamlPropertyValueNode(IXamlLineInfo lineInfo, IXamlAstPropertyReference property, IXamlAstValueNode value, bool isAttributeSyntax);
    public XamlAstXamlPropertyValueNode(IXamlLineInfo lineInfo, IXamlAstPropertyReference property, IEnumerable`1<IXamlAstValueNode> values, bool isAttributeSyntax);
    [CompilerGeneratedAttribute]
public IXamlAstPropertyReference get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(IXamlAstPropertyReference value);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstValueNode> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<IXamlAstValueNode> value);
    [CompilerGeneratedAttribute]
public bool get_IsAttributeSyntax();
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstXmlDirective : XamlAstNode {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstValueNode> <Values>k__BackingField;
    [NullableAttribute("2")]
public string Namespace { get; public set; }
    public string Name { get; public set; }
    public List`1<IXamlAstValueNode> Values { get; public set; }
    public XamlAstXmlDirective(IXamlLineInfo lineInfo, string ns, string name, IEnumerable`1<IXamlAstValueNode> values);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Namespace();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstValueNode> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<IXamlAstValueNode> value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlAstXmlTypeReference : XamlAstNode {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <XmlNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarkupExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<XamlAstXmlTypeReference> <GenericArguments>k__BackingField;
    [NullableAttribute("2")]
public string XmlNamespace { get; public set; }
    public string Name { get; public set; }
    public bool IsMarkupExtension { get; public set; }
    public List`1<XamlAstXmlTypeReference> GenericArguments { get; public set; }
    public XamlAstXmlTypeReference(IXamlLineInfo lineInfo, string xmlNamespace, string name, IEnumerable`1<XamlAstXmlTypeReference> genericArguments);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_XmlNamespace();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_XmlNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMarkupExtension();
    [CompilerGeneratedAttribute]
public void set_IsMarkupExtension(bool value);
    public sealed virtual bool Equals(IXamlAstTypeReference other);
    [CompilerGeneratedAttribute]
public List`1<XamlAstXmlTypeReference> get_GenericArguments();
    [CompilerGeneratedAttribute]
public void set_GenericArguments(List`1<XamlAstXmlTypeReference> value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlConstantNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private object <Constant>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public object Constant { get; }
    public IXamlAstTypeReference Type { get; }
    public XamlConstantNode(IXamlLineInfo lineInfo, IXamlType type, object constant);
    [CompilerGeneratedAttribute]
public object get_Constant();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlDeferredContentInitializeIntermediateRootNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    public IXamlAstValueNode Value { get; public set; }
    public IXamlAstTypeReference Type { get; }
    public XamlDeferredContentInitializeIntermediateRootNode(IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlDeferredContentNode : XamlAstNode {
    [NullableAttribute("2")]
private IXamlMethod _deferredContentCustomization;
    [NullableAttribute("2")]
private IXamlType _deferredContentCustomizationTypeParameter;
    private IXamlType _funcType;
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstValueNode Value { get; public set; }
    public IXamlAstTypeReference Type { get; }
    public XamlDeferredContentNode(IXamlAstValueNode value, IXamlType deferredContentCustomizationTypeParameter, TransformerConfiguration config);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    private void CompileBuilder(ILEmitContext context, XamlClosureInfo xamlClosure);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    private static bool IsFunctionPointerLike(IXamlType xamlType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlDirectCallPropertySetter : object {
    private IXamlMethod _method;
    [CompilerGeneratedAttribute]
private IXamlType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySetterBinderParameters <BinderParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IXamlType> <Parameters>k__BackingField;
    public IXamlType TargetType { get; }
    public PropertySetterBinderParameters BinderParameters { get; }
    public IReadOnlyList`1<IXamlType> Parameters { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public XamlDirectCallPropertySetter(IXamlMethod method);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlType get_TargetType();
    [CompilerGeneratedAttribute]
public sealed virtual PropertySetterBinderParameters get_BinderParameters();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IXamlType> get_Parameters();
    public sealed virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
    public sealed virtual void Emit(IXamlILEmitter emitter);
    public sealed virtual void EmitWithArguments(XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter emitter, IReadOnlyList`1<IXamlAstValueNode> arguments);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(XamlDirectCallPropertySetter other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlDocument : object {
    [NullableAttribute("2")]
private IXamlAstNode _root;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <NamespaceAliases>k__BackingField;
    public IXamlAstNode Root { get; public set; }
    [NullableAttribute("2")]
public string Document { get; public set; }
    public Dictionary`2<string, string> NamespaceAliases { get; public set; }
    public IXamlAstNode get_Root();
    public void set_Root(IXamlAstNode value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Document();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Document(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_NamespaceAliases();
    [CompilerGeneratedAttribute]
public void set_NamespaceAliases(Dictionary`2<string, string> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlIntermediateRootObjectNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; public set; }
    public XamlIntermediateRootObjectNode(IXamlLineInfo lineInfo, XamlTypeWellKnownTypes types);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlAstTypeReference value);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlLoadMethodDelegateNode : XamlValueWithSideEffectNodeBase {
    [CompilerGeneratedAttribute]
private IXamlType <DelegateType>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlType DelegateType { get; }
    public IXamlMethod Method { get; }
    public IXamlAstTypeReference Type { get; }
    public XamlLoadMethodDelegateNode(IXamlLineInfo lineInfo, IXamlAstValueNode value, IXamlType delegateType, IXamlMethod method);
    [CompilerGeneratedAttribute]
public IXamlType get_DelegateType();
    [CompilerGeneratedAttribute]
public IXamlMethod get_Method();
    [CompilerGeneratedAttribute]
public virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlManipulationGroupNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private List`1<IXamlAstManipulationNode> <Children>k__BackingField;
    public List`1<IXamlAstManipulationNode> Children { get; public set; }
    public XamlManipulationGroupNode(IXamlLineInfo lineInfo, IEnumerable`1<IXamlAstManipulationNode> children);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstManipulationNode> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(List`1<IXamlAstManipulationNode> value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlMarkupExtensionNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <ProvideValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstValueNode Value { get; public set; }
    public IXamlMethod ProvideValue { get; }
    public bool NeedsParentStack { get; }
    public IXamlAstTypeReference Type { get; }
    public XamlMarkupExtensionNode(IXamlLineInfo lineInfo, IXamlMethod provideValue, IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlMethod get_ProvideValue();
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public sealed virtual bool get_NeedsParentStack();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class XamlX.Ast.XamlMethodCallBaseNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlWrappedMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstValueNode> <Arguments>k__BackingField;
    public IXamlWrappedMethod Method { get; public set; }
    public List`1<IXamlAstValueNode> Arguments { get; public set; }
    public XamlMethodCallBaseNode(IXamlLineInfo lineInfo, IXamlWrappedMethod method, IEnumerable`1<IXamlAstValueNode> args);
    [CompilerGeneratedAttribute]
public IXamlWrappedMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(IXamlWrappedMethod value);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstValueNode> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<IXamlAstValueNode> value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlMethodWithCasts : object {
    private IXamlMethod _method;
    private IReadOnlyList`1<IXamlType> _baseParametersWithThis;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IXamlType> <Parameters>k__BackingField;
    public string Name { get; }
    public IXamlType ReturnType { get; }
    public IXamlType DeclaringType { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsStatic { get; }
    public IReadOnlyList`1<IXamlType> Parameters { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public bool IsGenericMethodDefinition { get; }
    public IReadOnlyList`1<IXamlType> GenericParameters { get; }
    public IReadOnlyList`1<IXamlType> GenericArguments { get; }
    public bool IsGenericMethod { get; }
    public bool ContainsGenericParameters { get; }
    public XamlMethodWithCasts(IXamlMethod method, IEnumerable`1<IXamlType> newArgumentTypes);
    public sealed virtual string get_Name();
    public sealed virtual IXamlType get_ReturnType();
    public sealed virtual IXamlType get_DeclaringType();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsStatic();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IXamlType> get_Parameters();
    public sealed virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
    public sealed virtual IXamlParameterInfo GetParameterInfo(int index);
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual IReadOnlyList`1<IXamlType> get_GenericParameters();
    public sealed virtual IReadOnlyList`1<IXamlType> get_GenericArguments();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual void EmitCall(IXamlILEmitter codeGen);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IXamlMethod other);
    public sealed virtual IXamlMethod MakeGenericMethod(IReadOnlyList`1<IXamlType> typeArguments);
}
internal class XamlX.Ast.XamlNoReturnMethodCallNode : XamlMethodCallBaseNode {
    [NullableContextAttribute("1")]
public XamlNoReturnMethodCallNode(IXamlLineInfo lineInfo, IXamlMethod method, IEnumerable`1<IXamlAstValueNode> args);
    [NullableContextAttribute("1")]
public XamlNoReturnMethodCallNode(IXamlLineInfo lineInfo, IXamlWrappedMethod method, IEnumerable`1<IXamlAstValueNode> args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlNullExtensionNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public XamlNullExtensionNode(IXamlLineInfo lineInfo);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlObjectInitializationNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstManipulationNode <Manipulation>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipBeginInit>k__BackingField;
    public IXamlAstManipulationNode Manipulation { get; public set; }
    public IXamlType Type { get; public set; }
    public bool SkipBeginInit { get; public set; }
    public XamlObjectInitializationNode(IXamlLineInfo lineInfo, IXamlAstManipulationNode manipulation, IXamlType type);
    [CompilerGeneratedAttribute]
public IXamlAstManipulationNode get_Manipulation();
    [CompilerGeneratedAttribute]
public void set_Manipulation(IXamlAstManipulationNode value);
    [CompilerGeneratedAttribute]
public IXamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IXamlType value);
    [CompilerGeneratedAttribute]
public bool get_SkipBeginInit();
    [CompilerGeneratedAttribute]
public void set_SkipBeginInit(bool value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlPropertyAssignmentNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private XamlAstClrProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlPropertySetter> <PossibleSetters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstValueNode> <Values>k__BackingField;
    public XamlAstClrProperty Property { get; }
    public List`1<IXamlPropertySetter> PossibleSetters { get; public set; }
    public List`1<IXamlAstValueNode> Values { get; public set; }
    public XamlPropertyAssignmentNode(IXamlLineInfo lineInfo, XamlAstClrProperty property, IEnumerable`1<IXamlPropertySetter> setters, IEnumerable`1<IXamlAstValueNode> values);
    [CompilerGeneratedAttribute]
public XamlAstClrProperty get_Property();
    [CompilerGeneratedAttribute]
public List`1<IXamlPropertySetter> get_PossibleSetters();
    [CompilerGeneratedAttribute]
public void set_PossibleSetters(List`1<IXamlPropertySetter> value);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstValueNode> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<IXamlAstValueNode> value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlPropertyValueManipulationNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private XamlAstClrProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstManipulationNode <Manipulation>k__BackingField;
    public XamlAstClrProperty Property { get; public set; }
    public IXamlAstManipulationNode Manipulation { get; public set; }
    public XamlPropertyValueManipulationNode(IXamlLineInfo lineInfo, XamlAstClrProperty property, IXamlAstManipulationNode manipulation);
    [CompilerGeneratedAttribute]
public XamlAstClrProperty get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(XamlAstClrProperty value);
    [CompilerGeneratedAttribute]
public IXamlAstManipulationNode get_Manipulation();
    [CompilerGeneratedAttribute]
public void set_Manipulation(IXamlAstManipulationNode value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlRootObjectNode : XamlAstNode {
    private IXamlAstTypeReference _type;
    public IXamlAstTypeReference Type { get; public set; }
    public XamlRootObjectNode(XamlAstObjectNode root);
    public sealed virtual IXamlAstTypeReference get_Type();
    public void set_Type(IXamlAstTypeReference value);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlStaticExtensionNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private string <Member>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlAstTypeReference <TargetType>k__BackingField;
    public string Member { get; public set; }
    [NullableAttribute("2")]
public IXamlAstTypeReference TargetType { get; public set; }
    public IXamlAstTypeReference Type { get; }
    public XamlStaticExtensionNode(XamlAstObjectNode lineInfo, IXamlAstTypeReference targetType, string member);
    [CompilerGeneratedAttribute]
public string get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IXamlAstTypeReference get_TargetType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TargetType(IXamlAstTypeReference value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    [NullableContextAttribute("2")]
internal IXamlMember ResolveMember(bool throwOnUnknown);
    public sealed virtual IXamlAstTypeReference get_Type();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ResolveMember>b__11_0(IXamlField f);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ResolveMember>b__11_1(IXamlProperty p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlStaticOrTargetedReturnMethodCallNode : XamlMethodCallBaseNode {
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public XamlStaticOrTargetedReturnMethodCallNode(IXamlLineInfo lineInfo, IXamlWrappedMethod method, IEnumerable`1<IXamlAstValueNode> args);
    public XamlStaticOrTargetedReturnMethodCallNode(IXamlLineInfo lineInfo, IXamlMethod method, IEnumerable`1<IXamlAstValueNode> args);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlToArrayNode : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    public IXamlAstValueNode Value { get; public set; }
    public IXamlAstTypeReference Type { get; }
    public XamlToArrayNode(IXamlLineInfo lineInfo, IXamlAstTypeReference arrayType, IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlTypeExtensionNode : XamlAstNode {
    private IXamlType _systemType;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlAstTypeReference <Value>k__BackingField;
    public IXamlAstTypeReference Type { get; }
    public IXamlAstTypeReference Value { get; public set; }
    public XamlTypeExtensionNode(IXamlLineInfo lineInfo, IXamlAstTypeReference value, IXamlType systemType);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlAstTypeReference get_Type();
    [CompilerGeneratedAttribute]
public IXamlAstTypeReference get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstTypeReference value);
    public virtual void VisitChildren(IXamlAstVisitor visitor);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlValueNodeWithBeginInit : XamlValueWithSideEffectNodeBase {
    public XamlValueNodeWithBeginInit(IXamlAstValueNode value);
    public sealed virtual XamlILNodeEmitResult Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlValueWithManipulationNode : XamlValueWithSideEffectNodeBase {
    [CompilerGeneratedAttribute]
private IXamlAstManipulationNode <Manipulation>k__BackingField;
    public IXamlAstManipulationNode Manipulation { get; public set; }
    [NullableContextAttribute("1")]
public XamlValueWithManipulationNode(IXamlLineInfo lineInfo, IXamlAstValueNode value, IXamlAstManipulationNode manipulation);
    [CompilerGeneratedAttribute]
public IXamlAstManipulationNode get_Manipulation();
    [CompilerGeneratedAttribute]
public void set_Manipulation(IXamlAstManipulationNode value);
    [NullableContextAttribute("1")]
public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class XamlX.Ast.XamlValueWithSideEffectNodeBase : XamlAstNode {
    [CompilerGeneratedAttribute]
private IXamlAstValueNode <Value>k__BackingField;
    public IXamlAstValueNode Value { get; public set; }
    public IXamlAstTypeReference Type { get; }
    protected XamlValueWithSideEffectNodeBase(IXamlLineInfo lineInfo, IXamlAstValueNode value);
    [CompilerGeneratedAttribute]
public IXamlAstValueNode get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(IXamlAstValueNode value);
    public virtual IXamlAstTypeReference get_Type();
    public virtual void VisitChildren(IXamlAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlWrappedMethod : object {
    private IXamlMethod _method;
    [CompilerGeneratedAttribute]
private IXamlType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IXamlType> <ParametersWithThis>k__BackingField;
    public string Name { get; }
    public IXamlType ReturnType { get; }
    public IXamlType DeclaringType { get; }
    public IReadOnlyList`1<IXamlType> ParametersWithThis { get; }
    public XamlWrappedMethod(IXamlMethod method);
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlType get_ReturnType();
    public sealed virtual IXamlType get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IXamlType> get_ParametersWithThis();
    public sealed virtual void Emit(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen, bool swallowResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Ast.XamlWrappedMethodWithCasts : object {
    private IXamlWrappedMethod _method;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IXamlType> <ParametersWithThis>k__BackingField;
    public string Name { get; }
    public IXamlType ReturnType { get; }
    public IXamlType DeclaringType { get; }
    public IReadOnlyList`1<IXamlType> ParametersWithThis { get; }
    public XamlWrappedMethodWithCasts(IXamlWrappedMethod method, IEnumerable`1<IXamlType> newArgumentTypes);
    public sealed virtual string get_Name();
    public sealed virtual IXamlType get_ReturnType();
    public sealed virtual IXamlType get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IXamlType> get_ParametersWithThis();
    public sealed virtual void Emit(XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen, bool swallowResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class XamlX.Compiler.XamlCompiler`2 : object {
    protected TransformerConfiguration _configuration;
    protected XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> _emitMappings;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstTransformer> <Transformers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IXamlAstTransformer> <SimplificationTransformers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<object> <Emitters>k__BackingField;
    public List`1<IXamlAstTransformer> Transformers { get; }
    public List`1<IXamlAstTransformer> SimplificationTransformers { get; }
    public List`1<object> Emitters { get; }
    public XamlCompiler`2(TransformerConfiguration configuration, XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> emitMappings, bool fillWithDefaults);
    [CompilerGeneratedAttribute]
public List`1<IXamlAstTransformer> get_Transformers();
    [CompilerGeneratedAttribute]
public List`1<IXamlAstTransformer> get_SimplificationTransformers();
    [CompilerGeneratedAttribute]
public List`1<object> get_Emitters();
    public AstTransformationContext CreateTransformationContext(XamlDocument doc);
    public void Transform(XamlDocument doc);
    protected abstract virtual XamlEmitContext`2<TBackendEmitter, TEmitResult> InitCodeGen(IFileSource file, IXamlTypeBuilder`1<TBackendEmitter> declaringType, TBackendEmitter codeGen, XamlRuntimeContext`2<TBackendEmitter, TEmitResult> context, bool needContextLocal);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class XamlX.Compiler.XamlImperativeCompiler`2 : XamlCompiler`2<TBackendEmitter, TEmitResult> {
    public XamlImperativeCompiler`2(TransformerConfiguration configuration, XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> emitMappings, bool fillWithDefaults);
    public IXamlMethodBuilder`1<TBackendEmitter> DefinePopulateMethod(IXamlTypeBuilder`1<TBackendEmitter> typeBuilder, XamlDocument doc, string name, XamlVisibility visibility);
    public IXamlMethodBuilder`1<TBackendEmitter> DefineBuildMethod(IXamlTypeBuilder`1<TBackendEmitter> typeBuilder, XamlDocument doc, string name, XamlVisibility visibility);
    public void Compile(XamlDocument doc, IXamlTypeBuilder`1<TBackendEmitter> typeBuilder, IXamlType contextType, string populateMethodName, string createMethodName, string namespaceInfoClassName, string baseUri, IFileSource fileSource);
    public void Compile(XamlDocument doc, IXamlType contextType, IXamlMethodBuilder`1<TBackendEmitter> populateMethod, IXamlTypeBuilder`1<TBackendEmitter> populateDeclaringType, IXamlMethodBuilder`1<TBackendEmitter> buildMethod, IXamlTypeBuilder`1<TBackendEmitter> buildDeclaringType, IXamlTypeBuilder`1<TBackendEmitter> namespaceInfoBuilder, string baseUri, IFileSource fileSource);
    protected abstract virtual void CompilePopulate(IFileSource fileSource, IXamlAstManipulationNode manipulation, IXamlTypeBuilder`1<TBackendEmitter> declaringType, TBackendEmitter codeGen, XamlRuntimeContext`2<TBackendEmitter, TEmitResult> context);
    protected abstract virtual void CompileBuild(IFileSource fileSource, IXamlAstValueNode rootInstance, IXamlTypeBuilder`1<TBackendEmitter> declaringType, TBackendEmitter codeGen, XamlRuntimeContext`2<TBackendEmitter, TEmitResult> context, IXamlMethod compiledPopulate);
    protected abstract virtual XamlRuntimeContext`2<TBackendEmitter, TEmitResult> CreateRuntimeContext(XamlDocument doc, IXamlType contextType, IXamlTypeBuilder`1<TBackendEmitter> namespaceInfoBuilder, string baseUri, IXamlType rootType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class XamlX.ContextDiagnosticExtensions : object {
    [ExtensionAttribute]
public static IXamlAstNode ReportDiagnostic(AstTransformationContext context, string diagnosticCode, XamlDiagnosticSeverity severity, string title, IXamlAstNode offender, XamlDiagnosticSeverity minSeverity);
    [ExtensionAttribute]
public static IXamlAstNode ReportTransformError(AstTransformationContext context, string title, IXamlAstNode offender);
    [ExtensionAttribute]
public static TReturn ReportTransformError(AstTransformationContext context, string title, IXamlLineInfo offender, TReturn ret);
    [ExtensionAttribute]
public static TReturn ReportError(AstTransformationContext context, Exception exception, TReturn ret);
    [ExtensionAttribute]
public static XamlDiagnostic ToDiagnostic(Exception exception, AstTransformationContext context);
    [ExtensionAttribute]
public static Exception ToException(XamlDiagnostic diagnostic);
    [ExtensionAttribute]
public static void ThrowExceptionIfAnyError(IEnumerable`1<XamlDiagnostic> diagnostics);
}
[NullableContextAttribute("1")]
internal interface XamlX.Emit.IHasLocalsPool {
    public XamlLocalsPool LocalsPool { get; }
    public abstract virtual XamlLocalsPool get_LocalsPool();
    public abstract virtual IXamlLocal DefineLocal(IXamlType type);
}
[NullableContextAttribute("1")]
internal interface XamlX.Emit.IXamlAstEmitableNode`2 {
    public abstract virtual TEmitResult Emit(XamlEmitContext`2<TBackendEmitter, TEmitResult> context, TBackendEmitter codeGen);
}
[NullableContextAttribute("1")]
internal interface XamlX.Emit.IXamlAstLocalsEmitableNode`2 {
    public abstract virtual TEmitResult Emit(XamlEmitContextWithLocals`2<TBackendEmitter, TEmitResult> context, TBackendEmitter codeGen);
}
[NullableContextAttribute("1")]
internal interface XamlX.Emit.IXamlAstLocalsNodeEmitter`2 {
    public abstract virtual TEmitResult Emit(IXamlAstNode node, XamlEmitContextWithLocals`2<TBackendEmitter, TEmitResult> context, TBackendEmitter codeGen);
}
[NullableContextAttribute("1")]
internal interface XamlX.Emit.IXamlAstNodeEmitter`2 {
    public abstract virtual TEmitResult Emit(IXamlAstNode node, XamlEmitContext`2<TBackendEmitter, TEmitResult> context, TBackendEmitter codeGen);
}
internal interface XamlX.Emit.IXamlCustomEmitMethod`1 {
    [NullableContextAttribute("1")]
public abstract virtual void EmitCall(TBackendEmitter emitter);
}
internal interface XamlX.Emit.IXamlCustomEmitMethodWithContext`2 {
    [NullableContextAttribute("1")]
public abstract virtual void EmitCall(XamlEmitContext`2<TBackendEmitter, TEmitResult> context, TBackendEmitter emitter);
}
internal interface XamlX.Emit.IXamlEmitablePropertySetter`1 {
    [NullableContextAttribute("1")]
public abstract virtual void Emit(TBackendEmitter emitter);
}
internal interface XamlX.Emit.IXamlEmitableWrappedMethod`2 {
    [NullableContextAttribute("1")]
public abstract virtual void Emit(XamlEmitContext`2<TBackendEmitter, TEmitResult> context, TBackendEmitter emitter, bool swallowResult);
}
internal interface XamlX.Emit.IXamlEmitableWrappedMethodWithLocals`2 {
    [NullableContextAttribute("1")]
public abstract virtual void Emit(XamlEmitContextWithLocals`2<TBackendEmitter, TEmitResult> context, TBackendEmitter emitter, bool swallowResult);
}
[NullableContextAttribute("2")]
internal interface XamlX.Emit.IXamlEmitResult {
    public IXamlType ReturnType { get; }
    public bool Valid { get; }
    public abstract virtual IXamlType get_ReturnType();
    public abstract virtual bool get_Valid();
}
[NullableContextAttribute("1")]
internal interface XamlX.Emit.IXamlPropertySetterEmitter`1 {
    public abstract virtual bool EmitCall(IXamlPropertySetter setter, TBackendEmitter emitter);
}
[NullableContextAttribute("1")]
internal interface XamlX.Emit.IXamlWrappedMethodEmitter`2 {
    public abstract virtual bool EmitCall(XamlEmitContext`2<TBackendEmitter, TEmitResult> context, IXamlWrappedMethod method, TBackendEmitter emitter, bool swallowResult);
}
[NullableContextAttribute("1")]
internal interface XamlX.Emit.IXamlWrappedMethodEmitterWithLocals`2 {
    public abstract virtual bool EmitCall(XamlEmitContextWithLocals`2<TBackendEmitter, TEmitResult> context, IXamlWrappedMethod method, TBackendEmitter emitter, bool swallowResult);
}
internal class XamlX.Emit.XamlContextFactoryCallback`2 : MulticastDelegate {
    public XamlContextFactoryCallback`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(XamlRuntimeContext`2<TBackendEmitter, TEmitResult> context, TBackendEmitter emitter);
    public virtual IAsyncResult BeginInvoke(XamlRuntimeContext`2<TBackendEmitter, TEmitResult> context, TBackendEmitter emitter, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class XamlX.Emit.XamlContextTypeBuilderCallback`1 : MulticastDelegate {
    public XamlContextTypeBuilderCallback`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(IXamlILContextDefinition`1<TBackendEmitter> contextDefinition);
    public virtual IAsyncResult BeginInvoke(IXamlILContextDefinition`1<TBackendEmitter> contextDefinition, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class XamlX.Emit.XamlEmitContext`2 : XamlContextBase {
    [NullableAttribute("2")]
private IXamlLocal _contextLocal;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IFileSource <File>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<object> <Emitters>k__BackingField;
    private List`1<Action> _afterEmitCallbacks;
    [NullableAttribute("2")]
private IXamlAstNode _currentNode;
    [CompilerGeneratedAttribute]
private TransformerConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> <EmitMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlRuntimeContext`2<TBackendEmitter, TEmitResult> <RuntimeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlTypeBuilder`1<TBackendEmitter> <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private TBackendEmitter <Emitter>k__BackingField;
    [NullableAttribute("2")]
public IFileSource File { get; }
    public List`1<object> Emitters { get; }
    public TransformerConfiguration Configuration { get; }
    public XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> EmitMappings { get; }
    public XamlRuntimeContext`2<TBackendEmitter, TEmitResult> RuntimeContext { get; }
    public IXamlTypeBuilder`1<TBackendEmitter> DeclaringType { get; }
    public TBackendEmitter Emitter { get; }
    public IXamlLocal ContextLocal { get; }
    public XamlEmitContext`2(TBackendEmitter emitter, TransformerConfiguration configuration, XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> emitMappings, XamlRuntimeContext`2<TBackendEmitter, TEmitResult> runtimeContext, IXamlLocal contextLocal, IXamlTypeBuilder`1<TBackendEmitter> declaringType, IFileSource file, IEnumerable`1<object> emitters);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IFileSource get_File();
    [CompilerGeneratedAttribute]
public List`1<object> get_Emitters();
    [CompilerGeneratedAttribute]
public TransformerConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> get_EmitMappings();
    [CompilerGeneratedAttribute]
public XamlRuntimeContext`2<TBackendEmitter, TEmitResult> get_RuntimeContext();
    [CompilerGeneratedAttribute]
public IXamlTypeBuilder`1<TBackendEmitter> get_DeclaringType();
    [CompilerGeneratedAttribute]
public TBackendEmitter get_Emitter();
    public IXamlLocal get_ContextLocal();
    public TEmitResult Emit(IXamlAstNode value, TBackendEmitter codeGen, IXamlType expectedType);
    public void Emit(IXamlPropertySetter setter, TBackendEmitter codeGen);
    protected virtual bool EmitCore(IXamlPropertySetter setter, TBackendEmitter codeGen);
    public void Emit(IXamlWrappedMethod wrapped, TBackendEmitter codeGen, bool swallowResult);
    protected virtual bool EmitCore(IXamlWrappedMethod wrapped, TBackendEmitter codeGen, bool swallowResult);
    private TEmitResult EmitCore(IXamlAstNode value, TBackendEmitter codeGen, IXamlType expectedType);
    protected virtual TEmitResult EmitNode(IXamlAstNode value, TBackendEmitter codeGen);
    protected abstract virtual void EmitConvert(IXamlAstNode value, TBackendEmitter codeGen, IXamlType expectedType, IXamlType returnedType);
    protected virtual TEmitResult EmitNodeCore(IXamlAstNode value, TBackendEmitter codeGen, Boolean& foundEmitter);
    public void AddAfterEmitCallbacks(Action callback);
    public void ExecuteAfterEmitCallbacks();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class XamlX.Emit.XamlEmitContextWithLocals`2 : XamlEmitContext`2<TBackendEmitter, TEmitResult> {
    protected Dictionary`2<XamlAstCompilerLocalNode, IXamlLocal> _locals;
    public XamlEmitContextWithLocals`2(TBackendEmitter emitter, TransformerConfiguration configuration, XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> emitMappings, XamlRuntimeContext`2<TBackendEmitter, TEmitResult> runtimeContext, IXamlLocal contextLocal, IXamlTypeBuilder`1<TBackendEmitter> declaringType, IFileSource file, IEnumerable`1<object> emitters);
    public IXamlLocal GetLocalForNode(XamlAstCompilerLocalNode node, TBackendEmitter codeGen, bool throwOnUninitialized);
    public abstract virtual void LoadLocalValue(XamlAstCompilerLocalNode node, TBackendEmitter codeGen);
    public PooledLocal GetLocalOfType(IXamlType type);
    protected virtual TEmitResult EmitNodeCore(IXamlAstNode value, TBackendEmitter codeGen, Boolean& foundEmitter);
    protected virtual bool EmitCore(IXamlWrappedMethod wrapped, TBackendEmitter codeGen, bool swallowResult);
}
internal class XamlX.Emit.XamlLanguageEmitMappings`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`4<XamlEmitContext`2<TBackendEmitter, TEmitResult>, TBackendEmitter, XamlAstClrProperty, bool> <ProvideValueTargetPropertyEmitter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XamlContextTypeBuilderCallback`1<TBackendEmitter> <ContextTypeBuilderCallback>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XamlContextFactoryCallback`2<TBackendEmitter, TEmitResult> <ContextFactoryCallback>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`4<XamlEmitContext`2<TBackendEmitter, TEmitResult>, TBackendEmitter, XamlAstClrProperty, bool> ProvideValueTargetPropertyEmitter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public XamlContextTypeBuilderCallback`1<TBackendEmitter> ContextTypeBuilderCallback { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public XamlContextFactoryCallback`2<TBackendEmitter, TEmitResult> ContextFactoryCallback { get; public set; }
    [CompilerGeneratedAttribute]
public Func`4<XamlEmitContext`2<TBackendEmitter, TEmitResult>, TBackendEmitter, XamlAstClrProperty, bool> get_ProvideValueTargetPropertyEmitter();
    [CompilerGeneratedAttribute]
public void set_ProvideValueTargetPropertyEmitter(Func`4<XamlEmitContext`2<TBackendEmitter, TEmitResult>, TBackendEmitter, XamlAstClrProperty, bool> value);
    [CompilerGeneratedAttribute]
public XamlContextTypeBuilderCallback`1<TBackendEmitter> get_ContextTypeBuilderCallback();
    [CompilerGeneratedAttribute]
public void set_ContextTypeBuilderCallback(XamlContextTypeBuilderCallback`1<TBackendEmitter> value);
    [CompilerGeneratedAttribute]
public XamlContextFactoryCallback`2<TBackendEmitter, TEmitResult> get_ContextFactoryCallback();
    [CompilerGeneratedAttribute]
public void set_ContextFactoryCallback(XamlContextFactoryCallback`2<TBackendEmitter, TEmitResult> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class XamlX.Emit.XamlRuntimeContext`2 : object {
    [CompilerGeneratedAttribute]
private IXamlField <RootObjectField>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlField <IntermediateRootObjectField>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlField <ParentListField>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IXamlType <ContextType>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlField <PropertyTargetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlField <PropertyTargetProperty>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IXamlConstructor <Constructor>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Action`1<TBackendEmitter> <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <PushParentMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <PopParentMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseUrl>k__BackingField;
    public IXamlField RootObjectField { get; public set; }
    public IXamlField IntermediateRootObjectField { get; public set; }
    public IXamlField ParentListField { get; public set; }
    [NullableAttribute("1")]
public IXamlType ContextType { get; public set; }
    public IXamlField PropertyTargetObject { get; public set; }
    public IXamlField PropertyTargetProperty { get; public set; }
    [NullableAttribute("1")]
public IXamlConstructor Constructor { get; public set; }
    [NullableAttribute("1")]
public Action`1<TBackendEmitter> Factory { get; public set; }
    public IXamlMethod PushParentMethod { get; public set; }
    public IXamlMethod PopParentMethod { get; public set; }
    public string BaseUrl { get; public set; }
    [NullableContextAttribute("1")]
public XamlRuntimeContext`2(IXamlType definition, IXamlType constructedType, string baseUri, XamlLanguageEmitMappings`2<TBackendEmitter, TEmitResult> mappings, Action`2<XamlRuntimeContext`2<TBackendEmitter, TEmitResult>, TBackendEmitter> factory);
    [CompilerGeneratedAttribute]
public IXamlField get_RootObjectField();
    [CompilerGeneratedAttribute]
public void set_RootObjectField(IXamlField value);
    [CompilerGeneratedAttribute]
public IXamlField get_IntermediateRootObjectField();
    [CompilerGeneratedAttribute]
public void set_IntermediateRootObjectField(IXamlField value);
    [CompilerGeneratedAttribute]
public IXamlField get_ParentListField();
    [CompilerGeneratedAttribute]
public void set_ParentListField(IXamlField value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IXamlType get_ContextType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_ContextType(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlField get_PropertyTargetObject();
    [CompilerGeneratedAttribute]
public void set_PropertyTargetObject(IXamlField value);
    [CompilerGeneratedAttribute]
public IXamlField get_PropertyTargetProperty();
    [CompilerGeneratedAttribute]
public void set_PropertyTargetProperty(IXamlField value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IXamlConstructor get_Constructor();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Constructor(IXamlConstructor value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Action`1<TBackendEmitter> get_Factory();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Factory(Action`1<TBackendEmitter> value);
    [CompilerGeneratedAttribute]
public IXamlMethod get_PushParentMethod();
    [CompilerGeneratedAttribute]
public void set_PushParentMethod(IXamlMethod value);
    [CompilerGeneratedAttribute]
public IXamlMethod get_PopParentMethod();
    [CompilerGeneratedAttribute]
public void set_PopParentMethod(IXamlMethod value);
    [CompilerGeneratedAttribute]
public string get_BaseUrl();
    [CompilerGeneratedAttribute]
public void set_BaseUrl(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class XamlX.Emit.XamlRuntimeContextDefintion : object {
    public static string RootObjectFieldName;
    public static string IntermediateRootObjectFieldName;
    public static string ParentListFieldName;
    public static string ProvideTargetObjectName;
    public static string ProvideTargetPropertyName;
    public static string PushParentMethodName;
    public static string PopParentMethodName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.IL.CheckingILEmitter : object {
    private IXamlILEmitter _inner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IXamlLabel, string> _unmarkedLabels;
    private Dictionary`2<IXamlLabel, Instruction> _labels;
    private List`1<IXamlLabel> _labelsToMarkOnNextInstruction;
    private bool _paused;
    private List`1<Instruction> _instructions;
    private static Dictionary`2<StackBehaviour, int> s_balance;
    public IXamlTypeSystem TypeSystem { get; }
    public XamlLocalsPool LocalsPool { get; }
    public CheckingILEmitter(IXamlILEmitter inner);
    private static CheckingILEmitter();
    public sealed virtual IXamlTypeSystem get_TypeSystem();
    [NullableContextAttribute("2")]
private static int GetInstructionBalance(OpCode code, object operand);
    private static int Balance(StackBehaviour op);
    [NullableContextAttribute("2")]
private static int GetInstructionPopBalance(OpCode code, object operand);
    [NullableContextAttribute("2")]
private static int GetInstructionPushBalance(OpCode code, object operand);
    public void Pause();
    public void Resume();
    public void ExplicitStack(int change);
    [NullableContextAttribute("2")]
private void Track(OpCode code, object operand);
    public sealed virtual IXamlILEmitter Emit(OpCode code);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlField field);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlMethod method);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlConstructor ctor);
    public sealed virtual IXamlILEmitter Emit(OpCode code, string arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, int arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, long arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, sbyte arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, byte arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlType type);
    public sealed virtual IXamlILEmitter Emit(OpCode code, float arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, double arg);
    public sealed virtual IXamlLocal DefineLocal(IXamlType type);
    public sealed virtual IXamlLabel DefineLabel();
    public sealed virtual IXamlILEmitter MarkLabel(IXamlLabel label);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlLabel label);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlLocal local);
    public sealed virtual void InsertSequencePoint(IFileSource file, int line, int position);
    public sealed virtual XamlLocalsPool get_LocalsPool();
    [NullableContextAttribute("2")]
private string VerifyAndGetBalanceAtExit(int expectedBalance, bool expectReturn);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public string Check(int expectedBalance, bool expectReturn);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.IL.Emitters.DefaultXamlDynamicSetterContainer : object {
    [CompilerGeneratedAttribute]
private IXamlTypeBuilder`1<IXamlILEmitter> <TypeBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlVisibility <GeneratedMethodsVisibility>k__BackingField;
    public IXamlTypeBuilder`1<IXamlILEmitter> TypeBuilder { get; }
    public XamlVisibility GeneratedMethodsVisibility { get; }
    public DefaultXamlDynamicSetterContainer(IXamlTypeBuilder`1<IXamlILEmitter> typeBuilder, XamlVisibility generatedMethodsVisibility);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlTypeBuilder`1<IXamlILEmitter> get_TypeBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual XamlVisibility get_GeneratedMethodsVisibility();
    public sealed virtual string GetDynamicSetterMethodName(int setterIndex);
}
internal class XamlX.IL.Emitters.DefaultXamlDynamicSetterContainerProvider : object {
    [NullableAttribute("2")]
private IXamlDynamicSetterContainer _sharedContainer;
    public DefaultXamlDynamicSetterContainerProvider(IXamlTypeBuilder`1<IXamlILEmitter> sharedContainerType);
    [NullableContextAttribute("1")]
public sealed virtual IXamlDynamicSetterContainer ProvideDynamicSetterContainer(XamlAstClrProperty property, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context);
    [NullableContextAttribute("2")]
private static bool IsTypeEffectivelyPrivate(IXamlType xamlType);
    [NullableContextAttribute("1")]
private static DefaultXamlDynamicSetterContainer GetOrCreatePrivateContainer(XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context);
}
[NullableContextAttribute("1")]
internal interface XamlX.IL.Emitters.IXamlDynamicSetterContainer {
    public IXamlTypeBuilder`1<IXamlILEmitter> TypeBuilder { get; }
    public XamlVisibility GeneratedMethodsVisibility { get; }
    public abstract virtual IXamlTypeBuilder`1<IXamlILEmitter> get_TypeBuilder();
    public abstract virtual XamlVisibility get_GeneratedMethodsVisibility();
    public abstract virtual string GetDynamicSetterMethodName(int setterIndex);
}
[NullableContextAttribute("1")]
internal interface XamlX.IL.Emitters.IXamlDynamicSetterContainerProvider {
    public abstract virtual IXamlDynamicSetterContainer ProvideDynamicSetterContainer(XamlAstClrProperty property, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context);
}
internal class XamlX.IL.Emitters.ManipulationGroupEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
internal class XamlX.IL.Emitters.MarkupExtensionEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter ilgen);
    [CompilerGeneratedAttribute]
internal static void <Emit>g__EmitPropertyDescriptor|0_0(<>c__DisplayClass0_0& );
}
internal class XamlX.IL.Emitters.MethodCallEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
internal class XamlX.IL.Emitters.NewObjectEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
internal class XamlX.IL.Emitters.ObjectInitializationNodeEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.IL.Emitters.PropertyAssignmentEmitter : object {
    private List`1<IXamlPropertySetter> ValidateAndGetSetters(XamlPropertyAssignmentNode an);
    public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
    private static void RemoveRedundantSetters(IXamlType valueType, List`1<IXamlPropertySetter> setters);
    private static bool IsAssignableToWithNullability(IXamlPropertySetter from, IXamlPropertySetter to);
    private static IXamlMethod GetOrCreateDynamicSetterMethod(XamlAstClrProperty property, IReadOnlyList`1<IXamlType> valueTypes, IReadOnlyList`1<IXamlPropertySetter> setters, IXamlLineInfo lineInfo, XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context);
    private static void EmitDynamicSetterMethod(IReadOnlyList`1<IXamlType> valueTypes, IReadOnlyList`1<IXamlPropertySetter> setters, IXamlLineInfo lineInfo, XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context);
    [CompilerGeneratedAttribute]
internal static void <EmitDynamicSetterMethod>g__EmitSetterAfterChecks|5_0(IXamlPropertySetter setter, IXamlType typeOnStack, <>c__DisplayClass5_0& );
}
internal class XamlX.IL.Emitters.PropertyValueManipulationEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
internal class XamlX.IL.Emitters.TextNodeEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
internal class XamlX.IL.Emitters.ValueWithManipulationsEmitter : object {
    [NullableContextAttribute("1")]
public sealed virtual XamlILNodeEmitResult Emit(IXamlAstNode node, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class XamlX.IL.Emitters.XamlNeedsParentStackCache : Dictionary`2<IXamlAstNode, bool> {
    public static void Verify(XamlContextBase ctx, IXamlAstNode node);
    public bool NeedsParentStack(IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class XamlX.IL.ILEmitContext : XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> {
    [CompilerGeneratedAttribute]
private bool <EnableIlVerification>k__BackingField;
    public bool EnableIlVerification { get; }
    public ILEmitContext(IXamlILEmitter emitter, TransformerConfiguration configuration, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult> emitMappings, XamlRuntimeContext`2<IXamlILEmitter, XamlILNodeEmitResult> runtimeContext, IXamlLocal contextLocal, IXamlTypeBuilder`1<IXamlILEmitter> declaringType, IFileSource file, IEnumerable`1<object> emitters);
    [CompilerGeneratedAttribute]
public bool get_EnableIlVerification();
    protected virtual XamlILNodeEmitResult EmitNode(IXamlAstNode value, IXamlILEmitter codeGen);
    protected virtual XamlILNodeEmitResult EmitNodeCore(IXamlAstNode value, IXamlILEmitter codeGen, Boolean& foundEmitter);
    protected virtual void EmitConvert(IXamlAstNode value, IXamlILEmitter codeGen, IXamlType expectedType, IXamlType returnedType);
    public virtual void LoadLocalValue(XamlAstCompilerLocalNode node, IXamlILEmitter codeGen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.IL.ILEmitContextSettings : object {
    [NullableAttribute("2")]
private IXamlDynamicSetterContainerProvider _dynamicSetterContainerProvider;
    [CompilerGeneratedAttribute]
private bool <EnableILVerification>k__BackingField;
    public bool EnableILVerification { get; public set; }
    public IXamlDynamicSetterContainerProvider DynamicSetterContainerProvider { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableILVerification();
    [CompilerGeneratedAttribute]
public void set_EnableILVerification(bool value);
    public IXamlDynamicSetterContainerProvider get_DynamicSetterContainerProvider();
    public void set_DynamicSetterContainerProvider(IXamlDynamicSetterContainerProvider value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.IL.ILEmitHelpers : object {
    public static void EmitFieldLiteral(IXamlField field, IXamlILEmitter codeGen);
    public static void EmitConvert(XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter ilgen, IXamlLineInfo node, IXamlType what, IXamlType to, IXamlLocal local);
    public static void EmitConvert(XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlILEmitter ilgen, IXamlLineInfo node, IXamlType what, IXamlType to);
    public static void EmitConvert(XamlEmitContextWithLocals`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlLineInfo node, IXamlType what, IXamlType to, Func`2<bool, IXamlILEmitter> ld);
}
internal interface XamlX.IL.IXamlAstILEmitableNode {
}
internal interface XamlX.IL.IXamlILAstNodeEmitter {
}
[NullableContextAttribute("2")]
internal interface XamlX.IL.IXamlILContextDefinition`1 {
    [NullableAttribute("1")]
public IXamlTypeBuilder`1<TBackendEmitter> TypeBuilder { get; }
    [NullableAttribute("1")]
public IXamlConstructorBuilder`1<TBackendEmitter> ConstructorBuilder { get; }
    public IXamlField ParentListField { get; }
    [NullableAttribute("1")]
public IXamlField ParentServiceProviderField { get; }
    public IXamlField InnerServiceProviderField { get; }
    public IXamlField TargetObjectField { get; }
    public IXamlField TargetPropertyField { get; }
    [NullableContextAttribute("1")]
public abstract virtual IXamlTypeBuilder`1<TBackendEmitter> get_TypeBuilder();
    [NullableContextAttribute("1")]
public abstract virtual IXamlConstructorBuilder`1<TBackendEmitter> get_ConstructorBuilder();
    public abstract virtual IXamlField get_ParentListField();
    [NullableContextAttribute("1")]
public abstract virtual IXamlField get_ParentServiceProviderField();
    public abstract virtual IXamlField get_InnerServiceProviderField();
    public abstract virtual IXamlField get_TargetObjectField();
    public abstract virtual IXamlField get_TargetPropertyField();
}
[NullableContextAttribute("1")]
internal interface XamlX.IL.IXamlILEmitter {
    public IXamlTypeSystem TypeSystem { get; }
    public abstract virtual IXamlTypeSystem get_TypeSystem();
    public abstract virtual IXamlILEmitter Emit(OpCode code);
    public abstract virtual IXamlILEmitter Emit(OpCode code, IXamlField field);
    public abstract virtual IXamlILEmitter Emit(OpCode code, IXamlMethod method);
    public abstract virtual IXamlILEmitter Emit(OpCode code, IXamlConstructor ctor);
    public abstract virtual IXamlILEmitter Emit(OpCode code, string arg);
    public abstract virtual IXamlILEmitter Emit(OpCode code, int arg);
    public abstract virtual IXamlILEmitter Emit(OpCode code, long arg);
    public abstract virtual IXamlILEmitter Emit(OpCode code, sbyte arg);
    public abstract virtual IXamlILEmitter Emit(OpCode code, byte arg);
    public abstract virtual IXamlILEmitter Emit(OpCode code, IXamlType type);
    public abstract virtual IXamlILEmitter Emit(OpCode code, float arg);
    public abstract virtual IXamlILEmitter Emit(OpCode code, double arg);
    public abstract virtual IXamlLabel DefineLabel();
    public abstract virtual IXamlILEmitter MarkLabel(IXamlLabel label);
    public abstract virtual IXamlILEmitter Emit(OpCode code, IXamlLabel label);
    public abstract virtual IXamlILEmitter Emit(OpCode code, IXamlLocal local);
    public abstract virtual void InsertSequencePoint(IFileSource file, int line, int position);
}
internal interface XamlX.IL.IXamlILLocal {
    public int Index { get; }
    public abstract virtual int get_Index();
}
internal static class XamlX.IL.NamespaceInfoProvider : object {
    [NullableContextAttribute("1")]
public static IXamlField EmitNamespaceInfoProvider(TransformerConfiguration configuration, IXamlTypeBuilder`1<IXamlILEmitter> typeBuilder, XamlDocument document);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static IXamlMethod <EmitNamespaceInfoProvider>g__EmitCreateNamespaceInfoMethod|0_1(<>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static IXamlMethod <EmitNamespaceInfoProvider>g__EmitCreateNamespacesMethod|0_2(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitNamespaceInfoProvider>g__EmitNamespacesProperty|0_3(<>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static IXamlConstructor <EmitNamespaceInfoProvider>g__EmitConstructor|0_4(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitNamespaceInfoProvider>g__EmitStaticConstructor|0_5(<>c__DisplayClass0_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.IL.RecordingIlEmitter : object {
    private IXamlILEmitter _inner;
    [CompilerGeneratedAttribute]
private List`1<RecordedInstruction> <Instructions>k__BackingField;
    private Dictionary`2<IXamlLabel, LabelInfo> _labels;
    private Dictionary`2<IXamlLocal, LocalInfo> _locals;
    public List`1<RecordedInstruction> Instructions { get; }
    public IXamlTypeSystem TypeSystem { get; }
    public XamlLocalsPool LocalsPool { get; }
    public RecordingIlEmitter(IXamlILEmitter inner);
    [CompilerGeneratedAttribute]
public List`1<RecordedInstruction> get_Instructions();
    public sealed virtual IXamlTypeSystem get_TypeSystem();
    public sealed virtual IXamlILEmitter Emit(OpCode code);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlField field);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlMethod method);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlConstructor ctor);
    public sealed virtual IXamlILEmitter Emit(OpCode code, string arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, int arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, long arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, sbyte arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, byte arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlType type);
    public sealed virtual IXamlILEmitter Emit(OpCode code, float arg);
    public sealed virtual IXamlILEmitter Emit(OpCode code, double arg);
    public sealed virtual IXamlLocal DefineLocal(IXamlType type);
    public sealed virtual IXamlLabel DefineLabel();
    public sealed virtual IXamlILEmitter MarkLabel(IXamlLabel label);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlLabel label);
    public sealed virtual IXamlILEmitter Emit(OpCode code, IXamlLocal local);
    public sealed virtual void InsertSequencePoint(IFileSource file, int line, int position);
    public sealed virtual XamlLocalsPool get_LocalsPool();
    [NullableContextAttribute("2")]
private void Record(OpCode code, object operand);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class XamlX.IL.RuntimeContext : XamlRuntimeContext`2<IXamlILEmitter, XamlILNodeEmitResult> {
    public RuntimeContext(IXamlType definition, IXamlType constructedType, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult> mappings, string baseUri, List`1<IXamlField> staticProviders);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class XamlX.IL.XamlILCompiler : XamlImperativeCompiler`2<IXamlILEmitter, XamlILNodeEmitResult> {
    public bool EnableIlVerification { get; public set; }
    public IXamlDynamicSetterContainerProvider DynamicSetterContainerProvider { get; public set; }
    private ILEmitContextSettings Settings { get; }
    public XamlILCompiler(TransformerConfiguration configuration, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult> emitMappings, bool fillWithDefaults);
    public bool get_EnableIlVerification();
    public void set_EnableIlVerification(bool value);
    public IXamlDynamicSetterContainerProvider get_DynamicSetterContainerProvider();
    public void set_DynamicSetterContainerProvider(IXamlDynamicSetterContainerProvider value);
    private ILEmitContextSettings get_Settings();
    public IXamlType CreateContextType(IXamlTypeBuilder`1<IXamlILEmitter> builder);
    protected virtual XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> InitCodeGen(IFileSource file, IXamlTypeBuilder`1<IXamlILEmitter> declaringType, IXamlILEmitter codeGen, XamlRuntimeContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, bool needContextLocal);
    protected virtual void CompileBuild(IFileSource fileSource, IXamlAstValueNode rootInstance, IXamlTypeBuilder`1<IXamlILEmitter> declaringType, IXamlILEmitter codeGen, XamlRuntimeContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, IXamlMethod compiledPopulate);
    protected virtual void CompilePopulate(IFileSource fileSource, IXamlAstManipulationNode manipulation, IXamlTypeBuilder`1<IXamlILEmitter> declaringType, IXamlILEmitter codeGen, XamlRuntimeContext`2<IXamlILEmitter, XamlILNodeEmitResult> context);
    protected virtual XamlRuntimeContext`2<IXamlILEmitter, XamlILNodeEmitResult> CreateRuntimeContext(XamlDocument doc, IXamlType contextType, IXamlTypeBuilder`1<IXamlILEmitter> namespaceInfoBuilder, string baseUri, IXamlType rootType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.IL.XamlILContextDefinition : object {
    [CompilerGeneratedAttribute]
private IXamlTypeBuilder`1<IXamlILEmitter> <TypeBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlConstructorBuilder`1<IXamlILEmitter> <ConstructorBuilder>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlField <ParentListField>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlField <ParentServiceProviderField>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlField <InnerServiceProviderField>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlField <TargetObjectField>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlField <TargetPropertyField>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ContextType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action> <CreateCallbacks>k__BackingField;
    public static int BaseUriArg;
    public static int StaticProvidersArg;
    public IXamlTypeBuilder`1<IXamlILEmitter> TypeBuilder { get; }
    public IXamlConstructorBuilder`1<IXamlILEmitter> ConstructorBuilder { get; }
    [NullableAttribute("2")]
public IXamlField ParentListField { get; }
    public IXamlField ParentServiceProviderField { get; }
    [NullableAttribute("2")]
public IXamlField InnerServiceProviderField { get; }
    [NullableAttribute("2")]
public IXamlField TargetObjectField { get; }
    [NullableAttribute("2")]
public IXamlField TargetPropertyField { get; }
    public IXamlType ContextType { get; }
    public List`1<Action> CreateCallbacks { get; }
    private XamlILContextDefinition(IXamlTypeBuilder`1<IXamlILEmitter> parentBuilder, IXamlTypeSystem typeSystem, XamlLanguageTypeMappings mappings, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult> emitMappings);
    public static IXamlType GenerateContextClass(IXamlTypeBuilder`1<IXamlILEmitter> builder, IXamlTypeSystem typeSystem, XamlLanguageTypeMappings mappings, XamlLanguageEmitMappings`2<IXamlILEmitter, XamlILNodeEmitResult> emitMappings);
    [CompilerGeneratedAttribute]
public sealed virtual IXamlTypeBuilder`1<IXamlILEmitter> get_TypeBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlConstructorBuilder`1<IXamlILEmitter> get_ConstructorBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IXamlField get_ParentListField();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlField get_ParentServiceProviderField();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IXamlField get_InnerServiceProviderField();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IXamlField get_TargetObjectField();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IXamlField get_TargetPropertyField();
    [CompilerGeneratedAttribute]
public IXamlType get_ContextType();
    [CompilerGeneratedAttribute]
public List`1<Action> get_CreateCallbacks();
    public void CreateAllTypes();
    private void EmitPushPopParent(IXamlTypeBuilder`1<IXamlILEmitter> builder, IXamlTypeSystem ts);
    private IXamlMethodBuilder`1<IXamlILEmitter> ImplementInterfacePropertyGetter(IXamlTypeBuilder`1<IXamlILEmitter> builder, IXamlType type, string name);
    private IXamlType EmitTypeDescriptorContextStub(IXamlTypeSystem typeSystem, IXamlTypeBuilder`1<IXamlILEmitter> builder, XamlLanguageTypeMappings mappings);
    private ValueTuple`3<IXamlType, IXamlConstructor, Action> EmitParentEnumerable(IXamlTypeSystem typeSystem, IXamlTypeBuilder`1<IXamlILEmitter> parentBuilder, XamlLanguageTypeMappings mappings);
    [CompilerGeneratedAttribute]
private void <EmitTypeDescriptorContextStub>g__PropertyStub|34_0(string name, <>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
private void <EmitTypeDescriptorContextStub>g__MethodStub|34_1(string name, <>c__DisplayClass34_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class XamlX.IL.XamlIlEmitterExtensions : object {
    [ExtensionAttribute]
public static IXamlILEmitter EmitCall(IXamlILEmitter emitter, IXamlMethod method, bool swallowResult);
    [ExtensionAttribute]
public static IXamlILEmitter EmitCall(IXamlILEmitter emitter, IXamlMethod method, XamlEmitContext`2<IXamlILEmitter, XamlILNodeEmitResult> context, bool swallowResult);
    [ExtensionAttribute]
public static IXamlILEmitter DebugHatch(IXamlILEmitter emitter, string message);
    [ExtensionAttribute]
public static IXamlILEmitter Ldarg(IXamlILEmitter emitter, int arg);
    [ExtensionAttribute]
public static IXamlILEmitter Ldarg_0(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Ldfld(IXamlILEmitter emitter, IXamlField field);
    [ExtensionAttribute]
public static IXamlILEmitter Ldsfld(IXamlILEmitter emitter, IXamlField field);
    [ExtensionAttribute]
public static IXamlILEmitter LdThisFld(IXamlILEmitter emitter, IXamlField field);
    [ExtensionAttribute]
public static IXamlILEmitter Stfld(IXamlILEmitter emitter, IXamlField field);
    [ExtensionAttribute]
public static IXamlILEmitter Stsfld(IXamlILEmitter emitter, IXamlField field);
    [ExtensionAttribute]
public static IXamlILEmitter Ldloc(IXamlILEmitter emitter, IXamlLocal local);
    [ExtensionAttribute]
public static IXamlILEmitter Ldloca(IXamlILEmitter emitter, IXamlLocal local);
    [ExtensionAttribute]
public static IXamlILEmitter Stloc(IXamlILEmitter emitter, IXamlLocal local);
    [ExtensionAttribute]
public static IXamlILEmitter Ldnull(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Ldstr(IXamlILEmitter emitter, string arg);
    [ExtensionAttribute]
public static IXamlILEmitter Throw(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Ldc_I4(IXamlILEmitter emitter, int arg);
    [ExtensionAttribute]
public static IXamlILEmitter Ldc_R8(IXamlILEmitter emitter, double arg);
    [ExtensionAttribute]
public static IXamlILEmitter Beq(IXamlILEmitter emitter, IXamlLabel label);
    [ExtensionAttribute]
public static IXamlILEmitter Blt(IXamlILEmitter emitter, IXamlLabel label);
    [ExtensionAttribute]
public static IXamlILEmitter Ble(IXamlILEmitter emitter, IXamlLabel label);
    [ExtensionAttribute]
public static IXamlILEmitter Bgt(IXamlILEmitter emitter, IXamlLabel label);
    [ExtensionAttribute]
public static IXamlILEmitter Bge(IXamlILEmitter emitter, IXamlLabel label);
    [ExtensionAttribute]
public static IXamlILEmitter Br(IXamlILEmitter emitter, IXamlLabel label);
    [ExtensionAttribute]
public static IXamlILEmitter Brfalse(IXamlILEmitter emitter, IXamlLabel label);
    [ExtensionAttribute]
public static IXamlILEmitter Brtrue(IXamlILEmitter emitter, IXamlLabel label);
    [ExtensionAttribute]
public static IXamlILEmitter Ret(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Dup(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Pop(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Ldtoken(IXamlILEmitter emitter, IXamlType type);
    [ExtensionAttribute]
public static IXamlILEmitter Ldtoken(IXamlILEmitter emitter, IXamlMethod method);
    [ExtensionAttribute]
public static IXamlILEmitter Ldtype(IXamlILEmitter emitter, IXamlType type);
    [ExtensionAttribute]
public static IXamlILEmitter LdMethodInfo(IXamlILEmitter emitter, IXamlMethod method);
    [ExtensionAttribute]
public static IXamlILEmitter Ldftn(IXamlILEmitter emitter, IXamlMethod method);
    [ExtensionAttribute]
public static IXamlILEmitter Isinst(IXamlILEmitter emitter, IXamlType type);
    [ExtensionAttribute]
public static IXamlILEmitter Castclass(IXamlILEmitter emitter, IXamlType type);
    [ExtensionAttribute]
public static IXamlILEmitter Box(IXamlILEmitter emitter, IXamlType type);
    [ExtensionAttribute]
public static IXamlILEmitter Unbox_Any(IXamlILEmitter emitter, IXamlType type);
    [ExtensionAttribute]
public static IXamlILEmitter Unbox(IXamlILEmitter emitter, IXamlType type);
    [ExtensionAttribute]
public static IXamlILEmitter Newobj(IXamlILEmitter emitter, IXamlConstructor ctor);
    [ExtensionAttribute]
public static IXamlILEmitter Newarr(IXamlILEmitter emitter, IXamlType type);
    [ExtensionAttribute]
public static IXamlILEmitter Ldelem_ref(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Stelem_ref(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Ldlen(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter Add(IXamlILEmitter emitter);
    [ExtensionAttribute]
public static IXamlILEmitter EmitDefault(IXamlILEmitter emitter, IXamlType type);
    [CompilerGeneratedAttribute]
internal static IXamlILEmitter <EmitDefault>g__EmitNewStruct|45_0(IXamlILEmitter emitter, IXamlType type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class XamlX.IL.XamlILNodeEmitResult : object {
    [CompilerGeneratedAttribute]
private int <ConsumedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCast>k__BackingField;
    public int ConsumedItems { get; }
    public IXamlType ReturnType { get; public set; }
    public int ProducedItems { get; }
    public bool AllowCast { get; public set; }
    private bool XamlX.Emit.IXamlEmitResult.Valid { get; }
    public XamlILNodeEmitResult(int consumedItems, IXamlType returnType);
    [CompilerGeneratedAttribute]
public int get_ConsumedItems();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlType get_ReturnType();
    [CompilerGeneratedAttribute]
public void set_ReturnType(IXamlType value);
    public int get_ProducedItems();
    [CompilerGeneratedAttribute]
public bool get_AllowCast();
    [CompilerGeneratedAttribute]
public void set_AllowCast(bool value);
    private sealed virtual override bool XamlX.Emit.IXamlEmitResult.get_Valid();
    [NullableContextAttribute("1")]
public static XamlILNodeEmitResult Void(int consumedItems);
    [NullableContextAttribute("1")]
public static XamlILNodeEmitResult Type(int consumedItems, IXamlType type);
}
internal class XamlX.Parsers.CommaSeparatedParenthesesTreeParser : object {
    [NullableContextAttribute("1")]
public static List`1<Node> Parse(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Parsers.CompatibleXmlReader : XmlReader {
    private XmlReader _base;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> _compatible;
    private Dictionary`2<string, string> _nsmap;
    private HashSet`1<string> _knownNamespaces;
    private Stack`1<Scope> _scopeStack;
    private Scope _scope;
    private bool _previousWasEmpty;
    private int _ignoredAttributes;
    private bool _savedPositionWasAttribute;
    [NullableAttribute("2")]
private string _savedPositionAttributeName;
    [NullableAttribute("2")]
private IXmlLineInfo _baseLineInfo;
    [NullableAttribute("2")]
private IXmlNamespaceResolver _baseNamespaceResolver;
    private static Char[] Splitter;
    public int AttributeCount { get; }
    public string NamespaceURI { get; }
    public string Value { get; }
    public string BaseURI { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public ReadState ReadState { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public CompatibleXmlReader(XmlReader baseReader, Dictionary`2<string, string> compatible);
    private static CompatibleXmlReader();
    private void PushScope(string prefixes);
    private void PopScopeIfNeeded();
    private bool ShouldIgnore(string ns);
    private string GetMapped(string ns);
    public virtual bool Read();
    private bool ProcessStartElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    private void SavePosition();
    private void RestorePosition();
    private void MoveTo(int i);
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    [NullableContextAttribute("2")]
public virtual string GetAttribute(string name, string namespaceURI);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual int get_AttributeCount();
    public virtual string get_NamespaceURI();
    public sealed virtual IDictionary`2<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
    public virtual string LookupNamespace(string prefix);
    public sealed virtual string LookupPrefix(string namespaceName);
    public virtual string get_Value();
    public virtual bool ReadAttributeValue();
    public virtual bool MoveToElement();
    public virtual void ResolveEntity();
    public virtual string get_BaseURI();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual ReadState get_ReadState();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class XamlX.Parsers.Extensions : object {
    private static XName SpaceAttributeName;
    private static Extensions();
    [ExtensionAttribute]
public static IXamlLineInfo AsLi(IXmlLineInfo info);
    [ExtensionAttribute]
public static XmlSpace GetDeclaredWhitespaceMode(XNode node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScanner : object {
    public static char Space;
    public static char OpenCurlie;
    public static char CloseCurlie;
    public static char Comma;
    public static char EqualSign;
    public static char Quote1;
    public static char Quote2;
    public static char Backslash;
    public static char NullChar;
    [NullableAttribute("1")]
private MeScannerContext _context;
    [NullableAttribute("1")]
private string _inputText;
    private int _idx;
    private MeTokenType _token;
    private MeScannerTypeName _tokenXamlType;
    private XamlAstNamePropertyReference _tokenProperty;
    private string _tokenNamespace;
    [NullableAttribute("1")]
private string _tokenText;
    private StringState _state;
    private bool _hasTrailingWhitespace;
    private int _lineNumber;
    private int _startPosition;
    private string _currentParameterName;
    private MeScannerSpecialBracketCharacters _currentSpecialBracketCharacters;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Namespace { get; }
    public MeTokenType Token { get; }
    public MeScannerTypeName TokenType { get; }
    public XamlAstNamePropertyReference TokenProperty { get; }
    [NullableAttribute("1")]
public string TokenText { get; }
    public bool IsAtEndOfInput { get; }
    public bool HasTrailingWhitespace { get; }
    private char CurrentChar { get; }
    private char NextChar { get; }
    [NullableContextAttribute("1")]
public MeScanner(MeScannerContext context, string text, int lineNumber, int linePosition);
    public int get_LineNumber();
    public int get_LinePosition();
    public string get_Namespace();
    public MeTokenType get_Token();
    public MeScannerTypeName get_TokenType();
    public XamlAstNamePropertyReference get_TokenProperty();
    [NullableContextAttribute("1")]
public string get_TokenText();
    public bool get_IsAtEndOfInput();
    public bool get_HasTrailingWhitespace();
    public void Read();
    [NullableContextAttribute("1")]
private static string RemoveEscapes(string value);
    [NullableContextAttribute("1")]
private void ResolveTypeName(string longName);
    [NullableContextAttribute("1")]
private void ResolvePropertyName(string longName);
    [NullableContextAttribute("1")]
private string ReadString();
    private char get_CurrentChar();
    private char get_NextChar();
    private bool Advance();
    private static bool IsWhitespaceChar(char ch);
    private void AdvanceOverWhitespace();
    private void PushBack();
    private MeScannerSpecialBracketCharacters GetBracketCharacterForProperty(string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScannerBracketModeParseParameters : object {
    [CompilerGeneratedAttribute]
private bool <IsConstructorParsingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentConstructorParam>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConstructorParams>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBracketEscapeMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<char> <BracketCharacterStack>k__BackingField;
    public bool IsConstructorParsingMode { get; public set; }
    public int CurrentConstructorParam { get; public set; }
    public int MaxConstructorParams { get; public set; }
    public bool IsBracketEscapeMode { get; public set; }
    public Stack`1<char> BracketCharacterStack { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsConstructorParsingMode();
    [CompilerGeneratedAttribute]
public void set_IsConstructorParsingMode(bool value);
    [CompilerGeneratedAttribute]
public int get_CurrentConstructorParam();
    [CompilerGeneratedAttribute]
public void set_CurrentConstructorParam(int value);
    [CompilerGeneratedAttribute]
public int get_MaxConstructorParams();
    [CompilerGeneratedAttribute]
public void set_MaxConstructorParams(int value);
    [CompilerGeneratedAttribute]
public bool get_IsBracketEscapeMode();
    [CompilerGeneratedAttribute]
public void set_IsBracketEscapeMode(bool value);
    [CompilerGeneratedAttribute]
public Stack`1<char> get_BracketCharacterStack();
    [CompilerGeneratedAttribute]
public void set_BracketCharacterStack(Stack`1<char> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScannerContext : object {
    private Func`2<string, XamlAstXmlTypeReference> _typeResolver;
    private IXamlLineInfo _lineInfo;
    [CompilerGeneratedAttribute]
private MeScannerBracketModeParseParameters <CurrentBracketModeParseParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private MeScannerTypeName <CurrentType>k__BackingField;
    public MeScannerBracketModeParseParameters CurrentBracketModeParseParameters { get; }
    public MeScannerTypeName CurrentType { get; public set; }
    public MeScannerContext FindNamespaceByPrefix { get; }
    public Func`2<string, XamlAstXmlTypeReference> TypeResolver { get; }
    public MeScannerContext(Func`2<string, XamlAstXmlTypeReference> typeResolver, IXamlLineInfo lineInfo);
    [CompilerGeneratedAttribute]
public MeScannerBracketModeParseParameters get_CurrentBracketModeParseParameters();
    [CompilerGeneratedAttribute]
public MeScannerTypeName get_CurrentType();
    [CompilerGeneratedAttribute]
public void set_CurrentType(MeScannerTypeName value);
    public MeScannerContext get_FindNamespaceByPrefix();
    public Func`2<string, XamlAstXmlTypeReference> get_TypeResolver();
    public XamlAstNamePropertyReference ResolvePropertyName(string pname);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScannerKnownStrings : object {
    public static string XmlPrefix;
    public static string XmlNsPrefix;
    public static string Preserve;
    public static string Default;
    public static string UriClrNamespace;
    public static string UriAssembly;
    public static string StringType;
    public static string ObjectType;
    public static string Get;
    public static string Set;
    public static string Add;
    public static string Handler;
    public static string Extension;
    public static string IsReadOnly;
    public static string ShouldSerialize;
    public static string FrameworkElement;
    public static string TypeExtension;
    public static char GraveQuote;
    public static char NestedTypeDelimiter;
    public static string GetEnumerator;
    public static string ICollectionOfT;
    public static string IDictionary;
    public static string IDictionaryOfKT;
    public static string NullableOfT;
    public static string KeyValuePairOfTT;
    public static string AmbientPropertyAttribute;
    public static string DependencyPropertySuffix;
    public static string XpsNamespace;
    public static string LocalPrefix;
    public static string DefaultPrefix;
    public static string ReferenceName;
    public static Char[] WhitespaceChars;
    public static char SpaceChar;
    public static char TabChar;
    public static char NewlineChar;
    public static char ReturnChar;
    public static string ClrNamespaceFormat;
    public static string CreateDelegateHelper;
    public static string CreateDelegate;
    public static string InvokeMember;
    public static string GetTypeFromHandle;
    public static string Member;
    public static string Property;
    private static MeScannerKnownStrings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScannerParseException : Exception {
    public MeScannerParseException(MeScanner meScanner, string error);
    public MeScannerParseException(string error);
}
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScannerSpecialBracketCharacters : object {
    public bool StartsEscapeSequence(char ch);
    public bool EndsEscapeSequence(char ch);
    public bool Match(char peek, char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScannerSr : object {
    public static string Get(string error);
    public static string Get(string error, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScannerSRID : object {
    public static string UnexpectedTokenAfterME;
    public static string MalformedBracketCharacters;
    public static string UnclosedQuote;
    public static string QuoteCharactersOutOfPlace;
    public static string InvalidClosingBracketCharacers;
    public static string MalformedPropertyName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.MeScannerTypeName : object {
    [CompilerGeneratedAttribute]
private XamlAstXmlTypeReference <TypeReference>k__BackingField;
    public XamlAstXmlTypeReference TypeReference { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    public bool IsMarkupExtension { get; }
    public MeScannerTypeName(XamlAstXmlTypeReference typeReference);
    [CompilerGeneratedAttribute]
public XamlAstXmlTypeReference get_TypeReference();
    public static MeScannerTypeName ParseInternal(string longName, MeScannerContext context);
    public string get_Name();
    [NullableContextAttribute("2")]
public string get_Namespace();
    public bool get_IsMarkupExtension();
}
internal enum XamlX.Parsers.SystemXamlMarkupExtensionParser.MeTokenType : Enum {
    public int value__;
    public static MeTokenType None;
    public static MeTokenType Open;
    public static MeTokenType Close;
    public static MeTokenType EqualSign;
    public static MeTokenType Comma;
    public static MeTokenType TypeName;
    public static MeTokenType PropertyName;
    public static MeTokenType String;
    public static MeTokenType QuotedMarkupExtension;
}
internal class XamlX.Parsers.SystemXamlMarkupExtensionParser.SystemXamlMarkupExtensionParser : object {
    [NullableContextAttribute("1")]
public static IXamlAstValueNode Parse(IXamlLineInfo li, string ext, Func`2<string, XamlAstXmlTypeReference> typeResolver);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static IXamlAstValueNode <Parse>g__ReadExtension|0_0(<>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static IXamlAstValueNode <Parse>g__Read|0_1(<>c__DisplayClass0_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static IXamlAstValueNode <Parse>g__ReadCurrent|0_2(<>c__DisplayClass0_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Parsers.XDocumentXamlParser : object {
    public static XamlDocument Parse(string s, Dictionary`2<string, string> compatibilityMappings);
    public static XamlDocument Parse(TextReader reader, Dictionary`2<string, string> compatibilityMappings);
}
internal class XamlX.Parsers.XDocumentXamlParserSettings : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, string> <CompatibleNamespaces>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> CompatibleNamespaces { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CompatibleNamespaces();
    [CompilerGeneratedAttribute]
public void set_CompatibleNamespaces(Dictionary`2<string, string> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Transform.AstTransformationContext : XamlContextBase {
    [NullableAttribute("2")]
private IXamlAstValueNode _rootObject;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <NamespaceAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private TransformerConfiguration <Configuration>k__BackingField;
    [NullableAttribute("2")]
public string Document { get; }
    public Dictionary`2<string, string> NamespaceAliases { get; public set; }
    public TransformerConfiguration Configuration { get; }
    public IXamlAstValueNode RootObject { get; public set; }
    public AstTransformationContext(TransformerConfiguration configuration, XamlDocument xamlDocument);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual string get_Document();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_NamespaceAliases();
    [CompilerGeneratedAttribute]
public void set_NamespaceAliases(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public TransformerConfiguration get_Configuration();
    public IXamlAstValueNode get_RootObject();
    public void set_RootObject(IXamlAstValueNode value);
    public XamlDiagnosticSeverity ReportDiagnostic(XamlDiagnostic diagnostic, bool throwOnFatal);
    public IXamlAstNode Visit(IXamlAstNode root, IXamlAstTransformer transformer);
    public void VisitChildren(IXamlAstNode root, IXamlAstTransformer transformer);
    protected bool OnUnhandledTransformError(Exception exception);
}
internal class XamlX.Transform.GuidIdentifierGenerator : object {
    [NullableContextAttribute("1")]
public sealed virtual string GenerateIdentifierPart();
}
[NullableContextAttribute("1")]
internal interface XamlX.Transform.IXamlAstTransformer {
    public abstract virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
internal interface XamlX.Transform.IXamlCustomAttributeResolver {
    public abstract virtual IXamlCustomAttribute GetCustomAttribute(IXamlType type, IXamlType attributeType);
    public abstract virtual IXamlCustomAttribute GetCustomAttribute(IXamlProperty property, IXamlType attributeType);
}
[NullableContextAttribute("1")]
internal interface XamlX.Transform.IXamlIdentifierGenerator {
    public abstract virtual string GenerateIdentifierPart();
}
internal static class XamlX.Transform.NamespaceInfoHelper : object {
    [NullableContextAttribute("1")]
public static List`1<NamespaceResolveResult> TryResolve(TransformerConfiguration config, string xmlns);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Transform.TransformerConfiguration : object {
    private Dictionary`2<Type, object> _extras;
    [CompilerGeneratedAttribute]
private IXamlTypeSystem <TypeSystem>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlAssembly <DefaultAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlLanguageTypeMappings <TypeMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlXmlnsMappings <XmlnsMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlTypeWellKnownTypes <WellKnownTypes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private XamlValueConverter <CustomValueConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlDiagnosticsHandler <DiagnosticsHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlIdentifierGenerator <IdentifierGenerator>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`2<string, string>> <KnownDirectives>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<object, IXamlProperty> _contentPropertyCache;
    private IDictionary`2<object, bool> _whitespaceSignificantCollectionCache;
    private IDictionary`2<object, bool> _trimSurroundingWhitespaceCache;
    public IXamlTypeSystem TypeSystem { get; }
    [NullableAttribute("2")]
public IXamlAssembly DefaultAssembly { get; }
    public XamlLanguageTypeMappings TypeMappings { get; }
    public XamlXmlnsMappings XmlnsMappings { get; }
    public XamlTypeWellKnownTypes WellKnownTypes { get; }
    [NullableAttribute("2")]
public XamlValueConverter CustomValueConverter { get; }
    public XamlDiagnosticsHandler DiagnosticsHandler { get; }
    public IXamlIdentifierGenerator IdentifierGenerator { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<string, string>> KnownDirectives { get; }
    [NullableContextAttribute("2")]
public TransformerConfiguration(IXamlTypeSystem typeSystem, IXamlAssembly defaultAssembly, XamlLanguageTypeMappings typeMappings, XamlXmlnsMappings xmlnsMappings, XamlValueConverter customValueConverter, IXamlIdentifierGenerator identifierGenerator, XamlDiagnosticsHandler diagnosticsHandler);
    public T GetExtra();
    public T GetOrCreateExtra();
    public void AddExtra(T extra);
    [CompilerGeneratedAttribute]
public IXamlTypeSystem get_TypeSystem();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IXamlAssembly get_DefaultAssembly();
    [CompilerGeneratedAttribute]
public XamlLanguageTypeMappings get_TypeMappings();
    [CompilerGeneratedAttribute]
public XamlXmlnsMappings get_XmlnsMappings();
    [CompilerGeneratedAttribute]
public XamlTypeWellKnownTypes get_WellKnownTypes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public XamlValueConverter get_CustomValueConverter();
    [CompilerGeneratedAttribute]
public XamlDiagnosticsHandler get_DiagnosticsHandler();
    [CompilerGeneratedAttribute]
public IXamlIdentifierGenerator get_IdentifierGenerator();
    [CompilerGeneratedAttribute]
public List`1<ValueTuple`2<string, string>> get_KnownDirectives();
    public IXamlProperty FindContentProperty(IXamlType type);
    public bool IsWhitespaceSignificantCollection(IXamlType type);
    public bool IsTrimSurroundingWhitespaceElement(IXamlType type);
    private bool IsAttributePresentInTypeHierarchy(IXamlType type, List`1<IXamlType> attributes, IDictionary`2<object, bool> cache);
    [IteratorStateMachineAttribute("XamlX.Transform.TransformerConfiguration/<GetCustomAttribute>d__40")]
public IEnumerable`1<IXamlCustomAttribute> GetCustomAttribute(IXamlType type, IXamlType attributeType);
    [IteratorStateMachineAttribute("XamlX.Transform.TransformerConfiguration/<GetCustomAttribute>d__41")]
public IEnumerable`1<IXamlCustomAttribute> GetCustomAttribute(IXamlType type, IEnumerable`1<IXamlType> types);
    [IteratorStateMachineAttribute("XamlX.Transform.TransformerConfiguration/<GetCustomAttribute>d__42")]
public IEnumerable`1<IXamlCustomAttribute> GetCustomAttribute(IXamlProperty prop, IXamlType attributeType);
    [IteratorStateMachineAttribute("XamlX.Transform.TransformerConfiguration/<GetCustomAttribute>d__43")]
public IEnumerable`1<IXamlCustomAttribute> GetCustomAttribute(IXamlProperty prop, IEnumerable`1<IXamlType> types);
}
internal class XamlX.Transform.Transformers.ApplyWhitespaceNormalization : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [NullableContextAttribute("1")]
private static bool WantsWhitespaceOnlyElements(TransformerConfiguration config, XamlAstClrProperty property, IList`1<IXamlAstValueNode> childNodes);
}
internal class XamlX.Transform.Transformers.ConstructableObjectTransformer : object {
    [NullableContextAttribute("1")]
private IXamlConstructor TransformArgumentsAndGetConstructor(AstTransformationContext context, XamlAstObjectNode n);
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.ContentConvertTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.ConvertPropertyValuesToAssignmentsTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [NullableContextAttribute("1")]
private static IXamlAstValueNode FindAndRemoveKey(AstTransformationContext context, IXamlAstValueNode value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <Transform>g__CanAssign|0_3(IXamlAstValueNode value, IXamlType type, <>c__DisplayClass0_0& , <>c__DisplayClass0_4& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <FindAndRemoveKey>g__IsKeyDirective|1_0(object node);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <FindAndRemoveKey>g__ProcessDirective|1_1(object d, <>c__DisplayClass1_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <FindAndRemoveKey>g__ProcessDirectiveCandidateList|1_2(IList nodes, <>c__DisplayClass1_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static IXamlAstManipulationNode <FindAndRemoveKey>g__VisitManipulationNode|1_3(IXamlAstManipulationNode man, <>c__DisplayClass1_0& );
}
internal class XamlX.Transform.Transformers.DeferredContentTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.FlattenAstTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.KnownDirectivesTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.MarkupExtensionTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.NewObjectTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.ObsoleteWarningsTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.PropertyReferenceResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.RemoveWhitespaceBetweenPropertyValuesTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.ResolveContentPropertyTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.ResolvePropertyValueAddersTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.StaticIntrinsicsPostProcessTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.TextNodeMerger : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
internal class XamlX.Transform.Transformers.TopDownInitializationTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <Transform>g__UsableDuringInitialization|0_0(IXamlType type, <>c__DisplayClass0_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <Transform>g__TryConvert|0_1(IXamlAstValueNode checkedNode, IXamlAstValueNode& value, IXamlAstManipulationNode& deferred, <>c__DisplayClass0_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Transform.Transformers.TypeReferenceResolver : object {
    public static XamlAstClrTypeReference ResolveType(AstTransformationContext context, string xmlns, string name, bool isMarkupExtension, List`1<XamlAstXmlTypeReference> typeArguments, IXamlLineInfo lineInfo);
    private static XamlAstClrTypeReference ResolveTypeCore(AstTransformationContext context, string xmlns, string name, bool isMarkupExtension, List`1<XamlAstXmlTypeReference> typeArguments, IXamlLineInfo lineInfo);
    public static XamlAstClrTypeReference ResolveType(AstTransformationContext context, string xmlName, bool isMarkupExtension, IXamlLineInfo lineInfo, bool strict);
    public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    public static XamlAstClrTypeReference ResolveType(AstTransformationContext context, XamlAstXmlTypeReference xmlref);
}
internal class XamlX.Transform.Transformers.XamlIntrinsicsTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static XamlAstTextNode <Transform>g__ResolveArgumentOrValue|0_0(string extension, string name, <>c__DisplayClass0_0& );
}
internal class XamlX.Transform.Transformers.XArgumentsTransformer : object {
    [NullableContextAttribute("1")]
public sealed virtual IXamlAstNode Transform(AstTransformationContext context, IXamlAstNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class XamlX.Transform.WhitespaceNormalization : object {
    public static bool IsWhitespace(string text);
    private static bool IsWhitespace(char ch);
    internal static string NormalizeWhitespace(string text, bool trimStart, bool trimEnd);
    public static void Apply(List`1<IXamlAstValueNode> contentNodes, TransformerConfiguration config);
    public static void RemoveWhitespaceNodes(List`1<T> nodes);
    private static bool ShouldRemoveNode(IXamlAstNode node);
    [CompilerGeneratedAttribute]
internal static bool <Apply>g__ShouldTrimWhitespaceAround|3_0(int index, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Transform.XamlContextBase : object {
    private Dictionary`2<Type, object> _items;
    private List`1<IXamlAstNode> _parentNodes;
    public T GetItem();
    public T GetOrCreateItem();
    public bool TryGetItem(T& rv);
    public void SetItem(T item);
    [IteratorStateMachineAttribute("XamlX.Transform.XamlContextBase/<ParentNodes>d__6")]
public IEnumerable`1<IXamlAstNode> ParentNodes();
    protected void PushParent(IXamlAstNode node);
    protected IXamlAstNode PopParent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Transform.XamlDiagnosticsHandler : object {
    [CompilerGeneratedAttribute]
private Func`2<object, string> <CodeMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Exception, string> <ExceptionFormatter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<XamlDiagnostic, XamlDiagnosticSeverity> <HandleDiagnostic>k__BackingField;
    public Func`2<object, string> CodeMappings { get; public set; }
    public Func`2<Exception, string> ExceptionFormatter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<XamlDiagnostic, XamlDiagnosticSeverity> HandleDiagnostic { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<object, string> get_CodeMappings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CodeMappings(Func`2<object, string> value);
    [CompilerGeneratedAttribute]
public Func`2<Exception, string> get_ExceptionFormatter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExceptionFormatter(Func`2<Exception, string> value);
    [CompilerGeneratedAttribute]
public Func`2<XamlDiagnostic, XamlDiagnosticSeverity> get_HandleDiagnostic();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HandleDiagnostic(Func`2<XamlDiagnostic, XamlDiagnosticSeverity> value);
    internal XamlDiagnosticSeverity ReportDiagnostic(XamlDiagnostic diagnostic);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class XamlX.Transform.XamlLanguageTypeMappings : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<IXamlType> <XmlnsAttributes>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<IXamlType> <UsableDuringInitializationAttributes>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<IXamlType> <ContentAttributes>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<IXamlType> <WhitespaceSignificantCollectionAttributes>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<IXamlType> <TrimSurroundingWhitespaceAttributes>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<IXamlType> <TypeConverterAttributes>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IXamlType <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <TypeDescriptorContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <SupportInitialize>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ProvideValueTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <RootObjectProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ParentStackProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <XmlNamespaceInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <UriContextProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IAddChild>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IAddChildOfT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlCustomAttributeResolver <CustomAttributeResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <InnerServiceProviderFactoryMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlMethod <DeferredContentExecutorCustomization>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<IXamlType> <DeferredContentPropertyAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <DeferredContentExecutorCustomizationDefaultTypeParameter>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private List`1<string> <DeferredContentExecutorCustomizationTypeParameterDeferredContentAttributePropertyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootObjectProviderIntermediateRootPropertyName>k__BackingField;
    [NullableAttribute("1")]
public List`1<IXamlType> XmlnsAttributes { get; public set; }
    [NullableAttribute("1")]
public List`1<IXamlType> UsableDuringInitializationAttributes { get; public set; }
    [NullableAttribute("1")]
public List`1<IXamlType> ContentAttributes { get; public set; }
    [NullableAttribute("1")]
public List`1<IXamlType> WhitespaceSignificantCollectionAttributes { get; public set; }
    [NullableAttribute("1")]
public List`1<IXamlType> TrimSurroundingWhitespaceAttributes { get; public set; }
    [NullableAttribute("1")]
public List`1<IXamlType> TypeConverterAttributes { get; public set; }
    [NullableAttribute("1")]
public IXamlType ServiceProvider { get; public set; }
    public IXamlType TypeDescriptorContext { get; public set; }
    public IXamlType SupportInitialize { get; public set; }
    public IXamlType ProvideValueTarget { get; public set; }
    public IXamlType RootObjectProvider { get; public set; }
    public IXamlType ParentStackProvider { get; public set; }
    public IXamlType XmlNamespaceInfoProvider { get; public set; }
    public IXamlType UriContextProvider { get; public set; }
    public IXamlType IAddChild { get; public set; }
    public IXamlType IAddChildOfT { get; public set; }
    public IXamlCustomAttributeResolver CustomAttributeResolver { get; public set; }
    public IXamlMethod InnerServiceProviderFactoryMethod { get; public set; }
    public IXamlMethod DeferredContentExecutorCustomization { get; public set; }
    [NullableAttribute("1")]
public List`1<IXamlType> DeferredContentPropertyAttributes { get; public set; }
    public IXamlType DeferredContentExecutorCustomizationDefaultTypeParameter { get; public set; }
    [NullableAttribute("1")]
public List`1<string> DeferredContentExecutorCustomizationTypeParameterDeferredContentAttributePropertyNames { get; public set; }
    public string RootObjectProviderIntermediateRootPropertyName { get; public set; }
    [NullableContextAttribute("1")]
public XamlLanguageTypeMappings(IXamlTypeSystem typeSystem);
    [NullableContextAttribute("1")]
public XamlLanguageTypeMappings(IXamlTypeSystem typeSystem, bool useDefault);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<IXamlType> get_XmlnsAttributes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_XmlnsAttributes(List`1<IXamlType> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<IXamlType> get_UsableDuringInitializationAttributes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_UsableDuringInitializationAttributes(List`1<IXamlType> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<IXamlType> get_ContentAttributes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_ContentAttributes(List`1<IXamlType> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<IXamlType> get_WhitespaceSignificantCollectionAttributes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_WhitespaceSignificantCollectionAttributes(List`1<IXamlType> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<IXamlType> get_TrimSurroundingWhitespaceAttributes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_TrimSurroundingWhitespaceAttributes(List`1<IXamlType> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<IXamlType> get_TypeConverterAttributes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_TypeConverterAttributes(List`1<IXamlType> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IXamlType get_ServiceProvider();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_ServiceProvider(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_TypeDescriptorContext();
    [CompilerGeneratedAttribute]
public void set_TypeDescriptorContext(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_SupportInitialize();
    [CompilerGeneratedAttribute]
public void set_SupportInitialize(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_ProvideValueTarget();
    [CompilerGeneratedAttribute]
public void set_ProvideValueTarget(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_RootObjectProvider();
    [CompilerGeneratedAttribute]
public void set_RootObjectProvider(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_ParentStackProvider();
    [CompilerGeneratedAttribute]
public void set_ParentStackProvider(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_XmlNamespaceInfoProvider();
    [CompilerGeneratedAttribute]
public void set_XmlNamespaceInfoProvider(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_UriContextProvider();
    [CompilerGeneratedAttribute]
public void set_UriContextProvider(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_IAddChild();
    [CompilerGeneratedAttribute]
public void set_IAddChild(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlType get_IAddChildOfT();
    [CompilerGeneratedAttribute]
public void set_IAddChildOfT(IXamlType value);
    [CompilerGeneratedAttribute]
public IXamlCustomAttributeResolver get_CustomAttributeResolver();
    [CompilerGeneratedAttribute]
public void set_CustomAttributeResolver(IXamlCustomAttributeResolver value);
    [CompilerGeneratedAttribute]
public IXamlMethod get_InnerServiceProviderFactoryMethod();
    [CompilerGeneratedAttribute]
public void set_InnerServiceProviderFactoryMethod(IXamlMethod value);
    [CompilerGeneratedAttribute]
public IXamlMethod get_DeferredContentExecutorCustomization();
    [CompilerGeneratedAttribute]
public void set_DeferredContentExecutorCustomization(IXamlMethod value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<IXamlType> get_DeferredContentPropertyAttributes();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_DeferredContentPropertyAttributes(List`1<IXamlType> value);
    [CompilerGeneratedAttribute]
public IXamlType get_DeferredContentExecutorCustomizationDefaultTypeParameter();
    [CompilerGeneratedAttribute]
public void set_DeferredContentExecutorCustomizationDefaultTypeParameter(IXamlType value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public List`1<string> get_DeferredContentExecutorCustomizationTypeParameterDeferredContentAttributePropertyNames();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_DeferredContentExecutorCustomizationTypeParameterDeferredContentAttributePropertyNames(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_RootObjectProviderIntermediateRootPropertyName();
    [CompilerGeneratedAttribute]
public void set_RootObjectProviderIntermediateRootPropertyName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class XamlX.Transform.XamlTransformHelpers : object {
    public static IReadOnlyList`1<IXamlMethod> FindPossibleAdders(AstTransformationContext context, IXamlType type);
    public static IEnumerable`1<IXamlMethod> GetMarkupExtensionProvideValueAlternatives(AstTransformationContext context, IXamlType type);
    public static bool TryConvertMarkupExtension(AstTransformationContext context, IXamlAstValueNode node, XamlMarkupExtensionNode& o);
    public static bool TryGetCorrectlyTypedValue(AstTransformationContext context, IXamlAstValueNode node, IXamlType xamlType, IXamlAstValueNode& rv);
    public static bool TryGetCorrectlyTypedValue(AstTransformationContext context, IXamlAstValueNode node, IXamlProperty property, IXamlAstValueNode& rv);
    public static bool TryGetCorrectlyTypedValue(AstTransformationContext context, IXamlAstValueNode node, IXamlParameterInfo parameterInfo, IXamlAstValueNode& rv);
    public static bool TryGetCorrectlyTypedValue(AstTransformationContext context, IXamlAstValueNode node, IReadOnlyList`1<IXamlCustomAttribute> customAttributes, IXamlType type, IXamlAstValueNode& rv);
    [NullableContextAttribute("2")]
public static IXamlType TryGetTypeConverterFromCustomAttribute(TransformerConfiguration cfg, IXamlCustomAttribute attribute);
    [ExtensionAttribute]
public static IXamlType GetCommonBaseClass(IXamlType[] types);
    private static IXamlAstValueNode CreateInvariantCulture(TransformerConfiguration cfg, IXamlLineInfo lineInfo);
    public static bool TryConvertValue(AstTransformationContext context, IXamlAstValueNode node, IReadOnlyList`1<IXamlCustomAttribute> customAttributes, IXamlType type, XamlAstClrProperty propertyContext, IXamlAstValueNode& rv);
    private static IXamlAstValueNode ConvertWithConverter(IXamlAstValueNode node, IXamlType converterType, TransformerConfiguration cfg, IXamlType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.Transform.XamlTypeWellKnownTypes : object {
    [CompilerGeneratedAttribute]
private IXamlType <IList>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IEnumerable>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IEnumerableT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IListOfT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <String>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Int32>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Void>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Boolean>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Double>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <NullableT>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <IFormatProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <Delegate>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ObsoleteAttribute>k__BackingField;
    public IXamlType IList { get; }
    public IXamlType IEnumerable { get; }
    public IXamlType IEnumerableT { get; }
    public IXamlType IListOfT { get; }
    public IXamlType Object { get; }
    public IXamlType String { get; }
    public IXamlType Int32 { get; }
    public IXamlType Void { get; }
    public IXamlType Boolean { get; }
    public IXamlType Double { get; }
    public IXamlType NullableT { get; }
    public IXamlType CultureInfo { get; }
    public IXamlType IFormatProvider { get; }
    public IXamlType Delegate { get; }
    public IXamlType ObsoleteAttribute { get; }
    public XamlTypeWellKnownTypes(IXamlTypeSystem typeSystem);
    [CompilerGeneratedAttribute]
public IXamlType get_IList();
    [CompilerGeneratedAttribute]
public IXamlType get_IEnumerable();
    [CompilerGeneratedAttribute]
public IXamlType get_IEnumerableT();
    [CompilerGeneratedAttribute]
public IXamlType get_IListOfT();
    [CompilerGeneratedAttribute]
public IXamlType get_Object();
    [CompilerGeneratedAttribute]
public IXamlType get_String();
    [CompilerGeneratedAttribute]
public IXamlType get_Int32();
    [CompilerGeneratedAttribute]
public IXamlType get_Void();
    [CompilerGeneratedAttribute]
public IXamlType get_Boolean();
    [CompilerGeneratedAttribute]
public IXamlType get_Double();
    [CompilerGeneratedAttribute]
public IXamlType get_NullableT();
    [CompilerGeneratedAttribute]
public IXamlType get_CultureInfo();
    [CompilerGeneratedAttribute]
public IXamlType get_IFormatProvider();
    [CompilerGeneratedAttribute]
public IXamlType get_Delegate();
    [CompilerGeneratedAttribute]
public IXamlType get_ObsoleteAttribute();
}
internal class XamlX.Transform.XamlXmlnsMappings : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<ValueTuple`2<IXamlAssembly, string>>> <Namespaces>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, List`1<ValueTuple`2<IXamlAssembly, string>>> Namespaces { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<ValueTuple`2<IXamlAssembly, string>>> get_Namespaces();
    [CompilerGeneratedAttribute]
public void set_Namespaces(Dictionary`2<string, List`1<ValueTuple`2<IXamlAssembly, string>>> value);
    [NullableContextAttribute("1")]
public static XamlXmlnsMappings Resolve(IXamlTypeSystem typeSystem, XamlLanguageTypeMappings typeMappings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class XamlX.TrimmingMessages : object {
    public static string TrimmedAttributes;
    public static string CanBeSafelyTrimmed;
    public static string TypePreservedElsewhere;
    public static string GeneratedTypes;
    public static string Cecil;
    public static string DynamicXamlReference;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.AnonymousParameterInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ParameterType>k__BackingField;
    public string Name { get; }
    public IXamlType ParameterType { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public AnonymousParameterInfo(IXamlType type, string name);
    public AnonymousParameterInfo(IXamlType type, int index);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IXamlType get_ParameterType();
    public sealed virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.CecilMetadataImporterProvider : object {
    private CecilTypeSystem _typeSystem;
    public CecilMetadataImporterProvider(CecilTypeSystem typeSystem);
    public sealed virtual IMetadataImporter GetMetadataImporter(ModuleDefinition module);
}
internal class XamlX.TypeSystem.CecilReflectionImporterProvider : object {
    [NullableContextAttribute("1")]
public sealed virtual IReflectionImporter GetReflectionImporter(ModuleDefinition module);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.CecilTypeCache : object {
    private Dictionary`2<TypeReference, IXamlType> _typeReferenceCache;
    private Dictionary`2<TypeDefinition, DefinitionEntry> _definitions;
    public IXamlType Resolve(CecilTypeResolveContext resolveContext, TypeReference reference);
    private CecilType SecondLayerCache(CecilTypeResolveContext resolveContext, TypeReference reference, TypeDefinition definition);
}
public enum XamlX.TypeSystem.CecilTypeComparisonMode : Enum {
    public int value__;
    public static CecilTypeComparisonMode Exact;
    public static CecilTypeComparisonMode SignatureOnly;
    public static CecilTypeComparisonMode SignatureOnlyLoose;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.CecilTypeResolveContext : object {
    private GenericTypeResolver _genericTypeResolver;
    private CecilTypeCache _typeCache;
    [CompilerGeneratedAttribute]
private CecilTypeSystem <TypeSystem>k__BackingField;
    public CecilTypeSystem TypeSystem { get; }
    private CecilTypeResolveContext(CecilTypeSystem typeSystem, GenericTypeResolver genericTypeResolver, CecilTypeCache typeCache);
    [CompilerGeneratedAttribute]
public CecilTypeSystem get_TypeSystem();
    public static CecilTypeResolveContext For(CecilTypeSystem typeSystem);
    public CecilTypeResolveContext Nested(TypeReference typeReference);
    public CecilTypeResolveContext Nested(MethodReference methodReference);
    public IXamlType Resolve(TypeReference reference, bool resolveGenerics);
    public IXamlType ResolveReturnType(MethodReference method);
    public IXamlType ResolveParameterType(MethodReference method, ParameterReference parameter);
    public IXamlType ResolveParameterType(PropertyReference property, ParameterReference parameter);
    public IXamlType ResolveFieldType(FieldReference field);
    public IXamlType ResolvePropertyType(PropertyReference property);
    public MethodReference ResolveReference(MethodReference method, bool transformGenerics);
    public TypeReference ResolveReference(TypeReference type);
    public FieldReference ResolveReference(FieldReference field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.CecilTypeSystem : object {
    private List`1<CecilAssembly> _asms;
    private Dictionary`2<string, CecilAssembly> _assemblyCache;
    private Dictionary`2<AssemblyDefinition, CecilAssembly> _assemblyDic;
    private CustomMetadataResolver _resolver;
    private TypeDefinition _compilerGeneratedAttribute;
    private MethodDefinition _compilerGeneratedAttributeConstructor;
    [CompilerGeneratedAttribute]
private CecilTypeResolveContext <RootTypeResolveContext>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IXamlAssembly <TargetAssembly>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AssemblyDefinition <TargetAssemblyDefinition>k__BackingField;
    internal CecilTypeResolveContext RootTypeResolveContext { get; }
    [NullableAttribute("2")]
public IXamlAssembly TargetAssembly { get; private set; }
    [NullableAttribute("2")]
public AssemblyDefinition TargetAssemblyDefinition { get; private set; }
    public IEnumerable`1<IXamlAssembly> Assemblies { get; }
    public CecilTypeSystem(IEnumerable`1<string> paths, string targetPath);
    public sealed virtual void Dispose();
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public AssemblyNameReference CoerceReference(AssemblyNameReference name);
    private CecilAssembly ResolveWrapped(AssemblyNameReference name, bool throwOnNotFound);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    [CompilerGeneratedAttribute]
internal CecilTypeResolveContext get_RootTypeResolveContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IXamlAssembly get_TargetAssembly();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_TargetAssembly(IXamlAssembly value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AssemblyDefinition get_TargetAssemblyDefinition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_TargetAssemblyDefinition(AssemblyDefinition value);
    public sealed virtual IEnumerable`1<IXamlAssembly> get_Assemblies();
    public sealed virtual IXamlAssembly FindAssembly(string name);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2092")]
public sealed virtual IXamlType FindType(string name);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2092")]
public sealed virtual IXamlType FindType(string name, string assembly);
    public TypeReference GetTypeReference(IXamlType t);
    public MethodReference GetMethodReference(IXamlMethod t);
    public MethodReference GetMethodReference(IXamlConstructor t);
    internal CecilAssembly FindAsm(AssemblyDefinition d);
    public IXamlAssembly RegisterAssembly(AssemblyDefinition asm);
    public AssemblyDefinition CreateAndRegisterAssembly(string name, Version version, ModuleKind kind);
    public IXamlTypeBuilder`1<IXamlILEmitter> CreateTypeBuilder(TypeDefinition def, bool compilerGeneratedType);
    public void AddCompilerGeneratedAttribute(MemberReference member);
    private bool IsCompilerGeneratedAttribute(CustomAttribute attribute);
    public AssemblyDefinition GetAssembly(IXamlAssembly asm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.FindMethodMethodSignature : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExactMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeclaringOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IXamlType> <Parameters>k__BackingField;
    public string Name { get; public set; }
    public IXamlType ReturnType { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsExactMatch { get; public set; }
    public bool DeclaringOnly { get; public set; }
    public IReadOnlyList`1<IXamlType> Parameters { get; public set; }
    public FindMethodMethodSignature(string name, IXamlType returnType, IXamlType[] parameters);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IXamlType get_ReturnType();
    [CompilerGeneratedAttribute]
public void set_ReturnType(IXamlType value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExactMatch();
    [CompilerGeneratedAttribute]
public void set_IsExactMatch(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeclaringOnly();
    [CompilerGeneratedAttribute]
public void set_DeclaringOnly(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IXamlType> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IReadOnlyList`1<IXamlType> value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.GenericParameterResolver : object {
    internal static TypeReference ResolveReturnTypeIfNeeded(MethodReference methodReference);
    internal static TypeReference ResolveFieldTypeIfNeeded(FieldReference fieldReference);
    internal static TypeReference ResolvePropertyTypeIfNeeded(PropertyReference propertyReference);
    internal static TypeReference ResolveParameterTypeIfNeeded(MethodReference method, ParameterReference parameter);
    internal static TypeReference ResolveParameterTypeIfNeeded(PropertyReference property, ParameterReference parameter);
    internal static TypeReference ResolveVariableTypeIfNeeded(MethodReference method, VariableReference variable);
    private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance declaringGenericInstanceType, TypeReference parameterType);
    private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericParameter genericParameterElement);
    private static ArrayType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ArrayType arrayType);
    private static ByReferenceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ByReferenceType byReferenceType);
    private static GenericInstanceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericInstanceType genericInstanceType1);
    [NullableContextAttribute("2")]
private static bool ContainsGenericParameters(TypeReference typeReference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.GenericTypeResolver : object {
    [NullableAttribute("2")]
private IGenericInstance _typeDefinitionContext;
    [NullableAttribute("2")]
private IGenericInstance _methodDefinitionContext;
    [NullableContextAttribute("2")]
public GenericTypeResolver(GenericInstanceType typeDefinitionContext);
    [NullableContextAttribute("2")]
public GenericTypeResolver(GenericInstanceType typeDefinitionContext, GenericInstanceMethod methodDefinitionContext);
    public MethodReference Resolve(MethodReference method, bool transformGenerics);
    public FieldReference Resolve(FieldReference field);
    public TypeReference Resolve(TypeReference typeReference);
    public TypeReference Resolve(TypeReference typeReference, bool includeTypeDefinitions);
    [NullableContextAttribute("2")]
internal GenericTypeResolver Nested(TypeReference typeReference, MethodReference methodReference);
    private TypeReference ResolveGenericParameter(GenericParameter genericParameter);
    private TypeReference HandleOwnerlessInvalidILCode(GenericParameter genericParameter);
    private bool IsDummy();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IFileSource {
    public string FilePath { get; }
    public Byte[] FileContents { get; }
    public abstract virtual string get_FilePath();
    public abstract virtual Byte[] get_FileContents();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlAssembly {
    public string Name { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public abstract virtual string get_Name();
    public abstract virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
    public abstract virtual IXamlType FindType(string fullName);
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlConstructor {
    public bool IsPublic { get; }
    public bool IsStatic { get; }
    public IReadOnlyList`1<IXamlType> Parameters { get; }
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsStatic();
    public abstract virtual IReadOnlyList`1<IXamlType> get_Parameters();
    public abstract virtual IXamlParameterInfo GetParameterInfo(int index);
}
internal interface XamlX.TypeSystem.IXamlConstructorBuilder`1 {
    [NullableAttribute("1")]
public TBackendEmitter Generator { get; }
    [NullableContextAttribute("1")]
public abstract virtual TBackendEmitter get_Generator();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlCustomAttribute {
    public IXamlType Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<object> Parameters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, object> Properties { get; }
    public abstract virtual IXamlType get_Type();
    public abstract virtual List`1<object> get_Parameters();
    public abstract virtual Dictionary`2<string, object> get_Properties();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlDelegateTypeBuilder {
    public abstract virtual IXamlType DefineDelegateType(IXamlType returnType, IList`1<IXamlType> argumentTypes);
}
[NullableContextAttribute("2")]
internal interface XamlX.TypeSystem.IXamlEventInfo {
    public IXamlMethod Add { get; }
    public abstract virtual IXamlMethod get_Add();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlField {
    public IXamlType FieldType { get; }
    public bool IsPublic { get; }
    public bool IsStatic { get; }
    public bool IsLiteral { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public abstract virtual IXamlType get_FieldType();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual object GetLiteralValue();
    public abstract virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
}
internal interface XamlX.TypeSystem.IXamlLabel {
}
internal interface XamlX.TypeSystem.IXamlLocal {
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlMember {
    public string Name { get; }
    public IXamlType DeclaringType { get; }
    public abstract virtual string get_Name();
    public abstract virtual IXamlType get_DeclaringType();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlMethod {
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsStatic { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public IXamlType ReturnType { get; }
    public IReadOnlyList`1<IXamlType> Parameters { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public IReadOnlyList`1<IXamlType> GenericParameters { get; }
    public IReadOnlyList`1<IXamlType> GenericArguments { get; }
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_ContainsGenericParameters();
    public abstract virtual bool get_IsGenericMethod();
    public abstract virtual bool get_IsGenericMethodDefinition();
    public abstract virtual IXamlType get_ReturnType();
    public abstract virtual IReadOnlyList`1<IXamlType> get_Parameters();
    public abstract virtual IXamlMethod MakeGenericMethod(IReadOnlyList`1<IXamlType> typeArguments);
    public abstract virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
    public abstract virtual IXamlParameterInfo GetParameterInfo(int index);
    public abstract virtual IReadOnlyList`1<IXamlType> get_GenericParameters();
    public abstract virtual IReadOnlyList`1<IXamlType> get_GenericArguments();
}
internal interface XamlX.TypeSystem.IXamlMethodBuilder`1 {
    [NullableAttribute("1")]
public TBackendEmitter Generator { get; }
    [NullableContextAttribute("1")]
public abstract virtual TBackendEmitter get_Generator();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlParameterInfo {
    public IXamlType ParameterType { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public abstract virtual IXamlType get_ParameterType();
    public abstract virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlProperty {
    public IXamlType PropertyType { get; }
    [NullableAttribute("2")]
public IXamlMethod Setter { get; }
    [NullableAttribute("2")]
public IXamlMethod Getter { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public IReadOnlyList`1<IXamlType> IndexerParameters { get; }
    public abstract virtual IXamlType get_PropertyType();
    [NullableContextAttribute("2")]
public abstract virtual IXamlMethod get_Setter();
    [NullableContextAttribute("2")]
public abstract virtual IXamlMethod get_Getter();
    public abstract virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
    public abstract virtual IReadOnlyList`1<IXamlType> get_IndexerParameters();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlType {
    public object Id { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    public string FullName { get; }
    public bool IsPublic { get; }
    public bool IsNestedPrivate { get; }
    [NullableAttribute("2")]
public IXamlAssembly Assembly { get; }
    public IReadOnlyList`1<IXamlProperty> Properties { get; }
    public IReadOnlyList`1<IXamlEventInfo> Events { get; }
    public IReadOnlyList`1<IXamlField> Fields { get; }
    public IReadOnlyList`1<IXamlMethod> Methods { get; }
    public IReadOnlyList`1<IXamlConstructor> Constructors { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public IReadOnlyList`1<IXamlType> GenericArguments { get; }
    [NullableAttribute("2")]
public IXamlType GenericTypeDefinition { get; }
    public bool IsArray { get; }
    [NullableAttribute("2")]
public IXamlType ArrayElementType { get; }
    [NullableAttribute("2")]
public IXamlType BaseType { get; }
    [NullableAttribute("2")]
public IXamlType DeclaringType { get; }
    public bool IsValueType { get; }
    public bool IsEnum { get; }
    public IReadOnlyList`1<IXamlType> Interfaces { get; }
    public bool IsInterface { get; }
    public IReadOnlyList`1<IXamlType> GenericParameters { get; }
    public bool IsFunctionPointer { get; }
    public abstract virtual object get_Id();
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual string get_Namespace();
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsNestedPrivate();
    [NullableContextAttribute("2")]
public abstract virtual IXamlAssembly get_Assembly();
    public abstract virtual IReadOnlyList`1<IXamlProperty> get_Properties();
    public abstract virtual IReadOnlyList`1<IXamlEventInfo> get_Events();
    public abstract virtual IReadOnlyList`1<IXamlField> get_Fields();
    public abstract virtual IReadOnlyList`1<IXamlMethod> get_Methods();
    public abstract virtual IReadOnlyList`1<IXamlConstructor> get_Constructors();
    public abstract virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
    public abstract virtual IReadOnlyList`1<IXamlType> get_GenericArguments();
    public abstract virtual bool IsAssignableFrom(IXamlType type);
    public abstract virtual IXamlType MakeGenericType(IReadOnlyList`1<IXamlType> typeArguments);
    [NullableContextAttribute("2")]
public abstract virtual IXamlType get_GenericTypeDefinition();
    public abstract virtual bool get_IsArray();
    [NullableContextAttribute("2")]
public abstract virtual IXamlType get_ArrayElementType();
    public abstract virtual IXamlType MakeArrayType(int dimensions);
    [NullableContextAttribute("2")]
public abstract virtual IXamlType get_BaseType();
    [NullableContextAttribute("2")]
public abstract virtual IXamlType get_DeclaringType();
    public abstract virtual bool get_IsValueType();
    public abstract virtual bool get_IsEnum();
    public abstract virtual IReadOnlyList`1<IXamlType> get_Interfaces();
    public abstract virtual bool get_IsInterface();
    public abstract virtual IXamlType GetEnumUnderlyingType();
    public abstract virtual IReadOnlyList`1<IXamlType> get_GenericParameters();
    public abstract virtual bool get_IsFunctionPointer();
    public abstract virtual int GetHashCode();
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlTypeBuilder`1 {
    public abstract virtual IXamlField DefineField(IXamlType type, string name, XamlVisibility visibility, bool isStatic);
    public abstract virtual void AddInterfaceImplementation(IXamlType type);
    public abstract virtual IXamlMethodBuilder`1<TBackendEmitter> DefineMethod(IXamlType returnType, IEnumerable`1<IXamlType> args, string name, XamlVisibility visibility, bool isStatic, bool isInterfaceImpl, IXamlMethod overrideMethod);
    public abstract virtual IXamlProperty DefineProperty(IXamlType propertyType, string name, IXamlMethod setter, IXamlMethod getter);
    public abstract virtual IXamlConstructorBuilder`1<TBackendEmitter> DefineConstructor(bool isStatic, IXamlType[] args);
    public abstract virtual IXamlType CreateType();
    public abstract virtual IXamlTypeBuilder`1<TBackendEmitter> DefineSubType(IXamlType baseType, string name, XamlVisibility visibility);
    public abstract virtual IXamlTypeBuilder`1<TBackendEmitter> DefineDelegateSubType(string name, XamlVisibility visibility, IXamlType returnType, IEnumerable`1<IXamlType> parameterTypes);
    public abstract virtual void DefineGenericParameters(IReadOnlyList`1<KeyValuePair`2<string, XamlGenericParameterConstraint>> names);
}
[NullableContextAttribute("1")]
internal interface XamlX.TypeSystem.IXamlTypeSystem {
    public IEnumerable`1<IXamlAssembly> Assemblies { get; }
    public abstract virtual IEnumerable`1<IXamlAssembly> get_Assemblies();
    public abstract virtual IXamlAssembly FindAssembly(string substring);
    public abstract virtual IXamlType FindType(string name);
    public abstract virtual IXamlType FindType(string name, string assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class XamlX.TypeSystem.MethodReferenceEqualityComparer : EqualityComparer`1<MethodReference> {
    private CecilTypeComparisonMode _comparisonMode;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static List`1<MethodReference> xComparisonStack;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static List`1<MethodReference> yComparisonStack;
    public MethodReferenceEqualityComparer(CecilTypeComparisonMode comparisonMode);
    [NullableContextAttribute("2")]
public virtual bool Equals(MethodReference x, MethodReference y);
    public virtual int GetHashCode(MethodReference obj);
    [NullableContextAttribute("2")]
public static bool AreEqual(MethodReference x, MethodReference y, CecilTypeComparisonMode comparisonMode);
    public static bool AreSignaturesEqual(MethodReference x, MethodReference y, CecilTypeComparisonMode comparisonMode);
    public static int GetHashCodeFor(MethodReference obj, CecilTypeComparisonMode comparisonMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class XamlX.TypeSystem.TypeReferenceEqualityComparer : EqualityComparer`1<TypeReference> {
    private CecilTypeComparisonMode _comparisonMode;
    public TypeReferenceEqualityComparer(CecilTypeComparisonMode comparisonMode);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeReference x, TypeReference y);
    public virtual int GetHashCode(TypeReference obj);
    [NullableContextAttribute("2")]
public static bool AreEqual(TypeReference a, TypeReference b, CecilTypeComparisonMode comparisonMode);
    private static bool AreEqual(GenericParameter a, GenericParameter b, CecilTypeComparisonMode comparisonMode);
    private static bool AreEqual(GenericInstanceType a, GenericInstanceType b, CecilTypeComparisonMode comparisonMode);
    public static int GetHashCodeFor(TypeReference obj, CecilTypeComparisonMode comparisonMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.TypeSystemHelpers : object {
    public static int ConvertLiteralToInt(object literal);
    public static long ConvertLiteralToLong(object literal);
    public static XamlConstantNode GetLiteralFieldConstantNode(IXamlField field, IXamlLineInfo info);
    public static object GetLiteralFieldConstantValue(IXamlField field);
    public static bool TryGetEnumValueNode(IXamlType enumType, string value, IXamlLineInfo lineInfo, bool ignoreCase, XamlConstantNode& rv);
    public static bool TryGetEnumValue(IXamlType enumType, string value, bool ignoreCase, Object& rv);
    private static object Or(object l, object r);
    public static bool ParseConstantIfTypeAllows(string s, IXamlType type, IXamlLineInfo info, XamlConstantNode& rv);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static object <ParseConstantIfTypeAllows>g__Parse|7_0(<>c__DisplayClass7_0& );
}
internal class XamlX.TypeSystem.XamlGenericParameterConstraint : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsClass>k__BackingField;
    public bool IsClass { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsClass();
    [CompilerGeneratedAttribute]
public void set_IsClass(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.XamlLocalsPool : object {
    private Func`2<IXamlType, IXamlLocal> _localFactory;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<IXamlType, IXamlLocal>> _localsPool;
    public XamlLocalsPool(Func`2<IXamlType, IXamlLocal> localFactory);
    public PooledLocal GetLocal(IXamlType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.TypeSystem.XamlPseudoType : object {
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private static XamlPseudoType <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private static XamlPseudoType <Unknown>k__BackingField;
    public object Id { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public bool IsPublic { get; }
    public bool IsNestedPrivate { get; }
    [NullableAttribute("2")]
public IXamlAssembly Assembly { get; }
    public IReadOnlyList`1<IXamlProperty> Properties { get; }
    public IReadOnlyList`1<IXamlEventInfo> Events { get; }
    public IReadOnlyList`1<IXamlField> Fields { get; }
    public IReadOnlyList`1<IXamlMethod> Methods { get; }
    public IReadOnlyList`1<IXamlConstructor> Constructors { get; }
    public IReadOnlyList`1<IXamlCustomAttribute> CustomAttributes { get; }
    public IReadOnlyList`1<IXamlType> GenericArguments { get; }
    [NullableAttribute("2")]
public IXamlType BaseType { get; }
    [NullableAttribute("2")]
public IXamlType DeclaringType { get; }
    public bool IsValueType { get; }
    public bool IsEnum { get; }
    public IReadOnlyList`1<IXamlType> Interfaces { get; }
    public bool IsInterface { get; }
    public IReadOnlyList`1<IXamlType> GenericParameters { get; }
    public bool IsFunctionPointer { get; }
    [NullableAttribute("2")]
public IXamlType GenericTypeDefinition { get; }
    public bool IsArray { get; }
    [NullableAttribute("2")]
public IXamlType ArrayElementType { get; }
    public static XamlPseudoType Null { get; }
    public static XamlPseudoType Unknown { get; }
    public XamlPseudoType(string name);
    private static XamlPseudoType();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IXamlType other);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string get_FullName();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsNestedPrivate();
    [NullableContextAttribute("2")]
public sealed virtual IXamlAssembly get_Assembly();
    public sealed virtual IReadOnlyList`1<IXamlProperty> get_Properties();
    public sealed virtual IReadOnlyList`1<IXamlEventInfo> get_Events();
    public sealed virtual IReadOnlyList`1<IXamlField> get_Fields();
    public sealed virtual IReadOnlyList`1<IXamlMethod> get_Methods();
    public sealed virtual IReadOnlyList`1<IXamlConstructor> get_Constructors();
    public sealed virtual IReadOnlyList`1<IXamlCustomAttribute> get_CustomAttributes();
    public sealed virtual IReadOnlyList`1<IXamlType> get_GenericArguments();
    public sealed virtual IXamlType MakeArrayType(int dimensions);
    [NullableContextAttribute("2")]
public sealed virtual IXamlType get_BaseType();
    [NullableContextAttribute("2")]
public sealed virtual IXamlType get_DeclaringType();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsEnum();
    public sealed virtual IReadOnlyList`1<IXamlType> get_Interfaces();
    public sealed virtual bool get_IsInterface();
    public sealed virtual IXamlType GetEnumUnderlyingType();
    public sealed virtual IReadOnlyList`1<IXamlType> get_GenericParameters();
    public sealed virtual bool get_IsFunctionPointer();
    [NullableContextAttribute("2")]
public sealed virtual bool IsAssignableFrom(IXamlType type);
    public sealed virtual IXamlType MakeGenericType(IReadOnlyList`1<IXamlType> typeArguments);
    [NullableContextAttribute("2")]
public sealed virtual IXamlType get_GenericTypeDefinition();
    public sealed virtual bool get_IsArray();
    [NullableContextAttribute("2")]
public sealed virtual IXamlType get_ArrayElementType();
    [CompilerGeneratedAttribute]
public static XamlPseudoType get_Null();
    [CompilerGeneratedAttribute]
public static XamlPseudoType get_Unknown();
    public static XamlPseudoType Unresolved(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class XamlX.TypeSystem.XamlTypeSystemExtensions : object {
    [ExtensionAttribute]
public static string GetFqn(IXamlType type);
    [ExtensionAttribute]
public static string GetFullName(IXamlType type);
    [ExtensionAttribute]
public static IXamlType GetType(IXamlTypeSystem sys, string type);
    [IteratorStateMachineAttribute("XamlX.TypeSystem.XamlTypeSystemExtensions/<FindMethods>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<IXamlMethod> FindMethods(IXamlType type, Func`2<IXamlMethod, bool> criteria);
    [ExtensionAttribute]
public static IXamlMethod GetMethod(IXamlType type, Func`2<IXamlMethod, bool> criteria);
    [ExtensionAttribute]
public static IXamlMethod FindMethod(IXamlType type, Func`2<IXamlMethod, bool> criteria);
    [ExtensionAttribute]
public static IXamlMethod GetMethod(IXamlType type, string name, IXamlType returnType, bool allowDowncast, IXamlType[] args);
    [ExtensionAttribute]
public static IXamlMethod FindMethod(IXamlType type, string name, IXamlType returnType, bool allowDowncast, IXamlType[] args);
    [ExtensionAttribute]
public static IXamlMethod GetMethod(IXamlType type, FindMethodMethodSignature signature);
    [ExtensionAttribute]
public static IXamlMethod FindMethod(IXamlType type, FindMethodMethodSignature signature);
    [ExtensionAttribute]
public static IXamlConstructor GetConstructor(IXamlType type, List`1<IXamlType> args);
    [ExtensionAttribute]
public static IXamlConstructor FindConstructor(IXamlType type, List`1<IXamlType> args);
    [ExtensionAttribute]
public static bool AcceptsNull(IXamlType type);
    [ExtensionAttribute]
public static bool IsNullable(IXamlType type);
    [ExtensionAttribute]
public static bool IsNullableOf(IXamlType type, IXamlType vtype);
    [ExtensionAttribute]
public static IXamlType MakeGenericType(IXamlType type, IXamlType[] typeArguments);
    [IteratorStateMachineAttribute("XamlX.TypeSystem.XamlTypeSystemExtensions/<GetAllInterfaces>d__16")]
[ExtensionAttribute]
public static IEnumerable`1<IXamlType> GetAllInterfaces(IXamlType type);
    [IteratorStateMachineAttribute("XamlX.TypeSystem.XamlTypeSystemExtensions/<GetAllCustomAttributes>d__17")]
[ExtensionAttribute]
public static IEnumerable`1<IXamlCustomAttribute> GetAllCustomAttributes(IXamlType type);
    [IteratorStateMachineAttribute("XamlX.TypeSystem.XamlTypeSystemExtensions/<GetAllProperties>d__18")]
[ExtensionAttribute]
public static IEnumerable`1<IXamlProperty> GetAllProperties(IXamlType t);
    [IteratorStateMachineAttribute("XamlX.TypeSystem.XamlTypeSystemExtensions/<GetAllFields>d__19")]
[ExtensionAttribute]
public static IEnumerable`1<IXamlField> GetAllFields(IXamlType t);
    [IteratorStateMachineAttribute("XamlX.TypeSystem.XamlTypeSystemExtensions/<GetAllEvents>d__20")]
[ExtensionAttribute]
public static IEnumerable`1<IXamlEventInfo> GetAllEvents(IXamlType t);
    [ExtensionAttribute]
public static bool IsDirectlyAssignableFrom(IXamlType type, IXamlType other);
    [ExtensionAttribute]
public static IXamlType ThisOrFirstParameter(IXamlMethod method);
    [ExtensionAttribute]
public static IReadOnlyList`1<IXamlType> ParametersWithThis(IXamlMethod method);
}
internal enum XamlX.TypeSystem.XamlVisibility : Enum {
    public int value__;
    public static XamlVisibility Public;
    public static XamlVisibility Assembly;
    public static XamlVisibility Private;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.XamlDiagnostic : object {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlDiagnosticSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlDiagnosticSeverity <MinSeverity>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <InnerException>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Code { get; public set; }
    public XamlDiagnosticSeverity Severity { get; public set; }
    public string Title { get; public set; }
    public Nullable`1<int> LineNumber { get; public set; }
    public Nullable`1<int> LinePosition { get; public set; }
    public XamlDiagnosticSeverity MinSeverity { get; public set; }
    [NullableAttribute("2")]
public string Document { get; public set; }
    [NullableAttribute("2")]
internal Exception InnerException { get; internal set; }
    private int XamlX.Ast.IXamlLineInfo.Line { get; private set; }
    private int XamlX.Ast.IXamlLineInfo.Position { get; private set; }
    public XamlDiagnostic(string Code, XamlDiagnosticSeverity Severity, string Title, Nullable`1<int> LineNumber, Nullable`1<int> LinePosition);
    public XamlDiagnostic(string code, XamlDiagnosticSeverity severity, string title, IXamlLineInfo lineInfo);
    [CompilerGeneratedAttribute]
protected XamlDiagnostic(XamlDiagnostic original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Code(string value);
    [CompilerGeneratedAttribute]
public XamlDiagnosticSeverity get_Severity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Severity(XamlDiagnosticSeverity value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Title(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LineNumber();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LinePosition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LinePosition(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public XamlDiagnosticSeverity get_MinSeverity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MinSeverity(XamlDiagnosticSeverity value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Document();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Document(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Exception get_InnerException();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InnerException(Exception value);
    private sealed virtual override int XamlX.Ast.IXamlLineInfo.get_Line();
    private sealed virtual override void XamlX.Ast.IXamlLineInfo.set_Line(int value);
    private sealed virtual override int XamlX.Ast.IXamlLineInfo.get_Position();
    private sealed virtual override void XamlX.Ast.IXamlLineInfo.set_Position(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(XamlDiagnostic left, XamlDiagnostic right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(XamlDiagnostic left, XamlDiagnostic right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(XamlDiagnostic other);
    [CompilerGeneratedAttribute]
public virtual XamlDiagnostic <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Code, XamlDiagnosticSeverity& Severity, String& Title, Nullable`1& LineNumber, Nullable`1& LinePosition);
}
internal enum XamlX.XamlDiagnosticSeverity : Enum {
    public int value__;
    public static XamlDiagnosticSeverity None;
    public static XamlDiagnosticSeverity Warning;
    public static XamlDiagnosticSeverity Error;
    public static XamlDiagnosticSeverity Fatal;
}
internal class XamlX.XamlLoadException : XamlParseException {
    [NullableContextAttribute("2")]
public XamlLoadException(string message, IXamlLineInfo lineInfo, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class XamlX.XamlNamespaces : object {
    public static string Xaml2006;
    public static string Blend2008;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class XamlX.XamlParseException : XmlException {
    [CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    public string Document { get; public set; }
    [NullableContextAttribute("1")]
public XamlParseException(string message, int line, int position, Exception innerException);
    public XamlParseException(string message, IXamlLineInfo lineInfo, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_Document();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Document(string value);
}
internal class XamlX.XamlTransformException : XamlParseException {
    [NullableContextAttribute("2")]
public XamlTransformException(string message, IXamlLineInfo lineInfo, Exception innerException);
}
internal class XamlX.XamlTypeSystemException : Exception {
    [NullableContextAttribute("1")]
public XamlTypeSystemException(string message, Exception innerException);
}
internal enum XamlX.XamlXWellKnownDiagnosticCodes : Enum {
    public int value__;
    public static XamlXWellKnownDiagnosticCodes Obsolete;
}
