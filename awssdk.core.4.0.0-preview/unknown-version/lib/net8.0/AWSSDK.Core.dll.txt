public class Amazon.Arn : object {
    [CompilerGeneratedAttribute]
private string <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    private string _accountId;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    public string Partition { get; public set; }
    public string Service { get; public set; }
    public string Region { get; public set; }
    public string AccountId { get; public set; }
    public string Resource { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Partition();
    [CompilerGeneratedAttribute]
public void set_Partition(string value);
    [CompilerGeneratedAttribute]
public string get_Service();
    [CompilerGeneratedAttribute]
public void set_Service(string value);
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(string value);
    public string get_AccountId();
    public void set_AccountId(string value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    public static bool IsArn(string arn);
    public static bool TryParse(string arnString, Arn& arn);
    public static Arn Parse(string arnString);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Amazon.Auth.AccessControlPolicy.ActionIdentifier : object {
    private string actionName;
    public string ActionName { get; public set; }
    public ActionIdentifier(string actionName);
    public string get_ActionName();
    public void set_ActionName(string value);
    public static ActionIdentifier op_Implicit(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Amazon.Auth.AccessControlPolicy.Condition : object {
    private string type;
    private string conditionKey;
    private String[] values;
    public string Type { get; public set; }
    public string ConditionKey { get; public set; }
    public String[] Values { get; public set; }
    public Condition(string type, string conditionKey, String[] values);
    public string get_Type();
    public void set_Type(string value);
    public string get_ConditionKey();
    public void set_ConditionKey(string value);
    public String[] get_Values();
    public void set_Values(String[] value);
}
public static class Amazon.Auth.AccessControlPolicy.ConditionFactory : object {
    public static string CURRENT_TIME_CONDITION_KEY;
    public static string SECURE_TRANSPORT_CONDITION_KEY;
    public static string SOURCE_IP_CONDITION_KEY;
    public static string USER_AGENT_CONDITION_KEY;
    public static string EPOCH_TIME_CONDITION_KEY;
    public static string REFERRER_CONDITION_KEY;
    public static string SOURCE_ARN_CONDITION_KEY;
    public static string SOURCE_ACCOUNT_KEY;
    public static string S3_CANNED_ACL_CONDITION_KEY;
    public static string S3_LOCATION_CONSTRAINT_CONDITION_KEY;
    public static string S3_PREFIX_CONDITION_KEY;
    public static string S3_DELIMITER_CONDITION_KEY;
    public static string S3_MAX_KEYS_CONDITION_KEY;
    public static string S3_COPY_SOURCE_CONDITION_KEY;
    public static string S3_METADATA_DIRECTIVE_CONDITION_KEY;
    public static string S3_VERSION_ID_CONDITION_KEY;
    public static string SNS_ENDPOINT_CONDITION_KEY;
    public static string SNS_PROTOCOL_CONDITION_KEY;
    public static Condition NewCondition(ArnComparisonType type, string key, string value);
    public static Condition NewCondition(string key, bool value);
    [ObsoleteAttribute("Invoking this method results in non-UTC DateTimes not being marshalled correctly. Use NewConditionUtc instead.", "False")]
public static Condition NewCondition(DateComparisonType type, DateTime date);
    public static Condition NewConditionUtc(DateComparisonType type, DateTime date);
    public static Condition NewIpAddressCondition(string ipAddressRange);
    public static Condition NewCondition(IpAddressComparisonType type, string ipAddressRange);
    public static Condition NewCondition(NumericComparisonType type, string key, string value);
    public static Condition NewCondition(StringComparisonType type, string key, string value);
    public static Condition NewSourceArnCondition(string arnPattern);
    public static Condition NewSecureTransportCondition();
    public static Condition NewCannedACLCondition(string cannedAcl);
    public static Condition NewEndpointCondition(string endpointPattern);
    public static Condition NewProtocolCondition(string protocol);
}
internal static class Amazon.Auth.AccessControlPolicy.Internal.JsonDocumentFields : object {
    internal static string VERSION;
    internal static string POLICY_ID;
    internal static string STATEMENT;
    internal static string STATEMENT_EFFECT;
    internal static string EFFECT_VALUE_ALLOW;
    internal static string STATEMENT_ID;
    internal static string PRINCIPAL;
    internal static string ACTION;
    internal static string RESOURCE;
    internal static string CONDITION;
}
internal static class Amazon.Auth.AccessControlPolicy.Internal.JsonPolicyReader : object {
    public static Policy ReadJsonStringToPolicy(string jsonString);
    private static Statement convertStatement(JsonData jStatement);
    private static void convertPrincipals(Statement statement, JsonData jStatement);
    private static void convertPrincipalRecord(Statement statement, JsonData jPrincipal);
    private static void convertActions(Statement statement, JsonData jStatement);
    private static void convertResources(Statement statement, JsonData jStatement);
    private static void convertCondition(Statement statement, JsonData jStatement);
    private static void convertConditionRecord(Statement statement, JsonData jCondition);
}
internal static class Amazon.Auth.AccessControlPolicy.Internal.JsonPolicyWriter : object {
    public static string WritePolicyToString(bool prettyPrint, Policy policy);
    private static void writePolicy(Policy policy, JsonWriter generator);
    private static void writePrincipals(Statement statement, JsonWriter generator);
    private static void writeActions(Statement statement, JsonWriter generator);
    private static void writeResources(Statement statement, JsonWriter generator);
    private static void writeConditions(Statement statement, JsonWriter generator);
    private static Dictionary`2<string, Dictionary`2<string, List`1<string>>> sortConditionsByTypeAndKey(IList`1<Condition> conditions);
    private static void writePropertyValue(JsonWriter generator, string propertyName, string value);
}
public class Amazon.Auth.AccessControlPolicy.Policy : object {
    private static string DEFAULT_POLICY_VERSION;
    private string id;
    private string version;
    private IList`1<Statement> statements;
    public string Id { get; public set; }
    public string Version { get; public set; }
    public IList`1<Statement> Statements { get; public set; }
    public Policy(string id);
    public Policy(string id, IList`1<Statement> statements);
    public string get_Id();
    public void set_Id(string value);
    public Policy WithId(string id);
    public string get_Version();
    public void set_Version(string value);
    public IList`1<Statement> get_Statements();
    public void set_Statements(IList`1<Statement> value);
    public bool CheckIfStatementExists(Statement statement);
    private static bool StatementContainsResources(Statement statement, IList`1<Resource> resources);
    private static bool StatementContainsActions(Statement statement, IList`1<ActionIdentifier> actions);
    private static bool StatementContainsConditions(Statement statement, IList`1<Condition> conditions);
    private static bool StatementContainsPrincipals(Statement statement, IList`1<Principal> principals);
    public Policy WithStatements(Statement[] statements);
    public string ToJson();
    public string ToJson(bool prettyPrint);
    public static Policy FromJson(string json);
}
public class Amazon.Auth.AccessControlPolicy.Principal : object {
    public static Principal AllUsers;
    public static Principal Anonymous;
    public static string AWS_PROVIDER;
    public static string CANONICAL_USER_PROVIDER;
    public static string FEDERATED_PROVIDER;
    public static string SERVICE_PROVIDER;
    public static string ANONYMOUS_PROVIDER;
    private string id;
    private string provider;
    public string Provider { get; public set; }
    public string Id { get; }
    public Principal(string accountId);
    public Principal(string provider, string id);
    public Principal(string provider, string id, bool stripHyphen);
    private static Principal();
    public string get_Provider();
    public void set_Provider(string value);
    public string get_Id();
}
public class Amazon.Auth.AccessControlPolicy.Resource : object {
    private string resource;
    public string Id { get; }
    public Resource(string resource);
    public string get_Id();
}
public static class Amazon.Auth.AccessControlPolicy.ResourceFactory : object {
    public static Resource NewS3BucketResource(string bucketName);
    public static Resource NewS3ObjectResource(string bucketName, string keyPattern);
    public static Resource NewSQSQueueResource(string accountId, string queueName);
    private static string FormatAccountId(string accountId);
}
public class Amazon.Auth.AccessControlPolicy.Statement : object {
    private string id;
    private StatementEffect effect;
    private IList`1<Principal> principals;
    private IList`1<ActionIdentifier> actions;
    private IList`1<Resource> resources;
    private IList`1<Condition> conditions;
    public string Id { get; public set; }
    public StatementEffect Effect { get; public set; }
    public IList`1<ActionIdentifier> Actions { get; public set; }
    public IList`1<Resource> Resources { get; public set; }
    public IList`1<Condition> Conditions { get; public set; }
    public IList`1<Principal> Principals { get; public set; }
    public Statement(StatementEffect effect);
    public string get_Id();
    public void set_Id(string value);
    public Statement WithId(string id);
    public StatementEffect get_Effect();
    public void set_Effect(StatementEffect value);
    public IList`1<ActionIdentifier> get_Actions();
    public void set_Actions(IList`1<ActionIdentifier> value);
    public Statement WithActionIdentifiers(ActionIdentifier[] actions);
    public IList`1<Resource> get_Resources();
    public void set_Resources(IList`1<Resource> value);
    public Statement WithResources(Resource[] resources);
    public IList`1<Condition> get_Conditions();
    public void set_Conditions(IList`1<Condition> value);
    public Statement WithConditions(Condition[] conditions);
    public IList`1<Principal> get_Principals();
    public void set_Principals(IList`1<Principal> value);
    public Statement WithPrincipals(Principal[] principals);
}
public static class Amazon.AWSConfigs : object {
    private static Char[] validSeparators;
    internal static Func`1<DateTime> utcNowSource;
    internal static string _awsRegion;
    internal static LoggingOptions _logging;
    internal static ResponseLoggingOption _responseLogging;
    internal static bool _logMetrics;
    internal static string _awsProfileName;
    internal static string _awsAccountsLocation;
    internal static bool _useSdkCache;
    internal static bool _initializeCollections;
    private static object _lock;
    private static List`1<string> standardConfigs;
    private static TelemetryProvider _telemetryProvider;
    private static bool configPresent;
    private static RootConfig _rootConfig;
    [CompilerGeneratedAttribute]
private static TimeSpan <ClockOffset>k__BackingField;
    public static string AWSRegionKey;
    public static string AWSProfileNameKey;
    public static string AWSProfilesLocationKey;
    public static string LoggingKey;
    public static string ResponseLoggingKey;
    public static string LogMetricsKey;
    public static string UseSdkCacheKey;
    public static string InitializeCollectionsKey;
    internal static string LoggingDestinationProperty;
    internal static PropertyChangedEventHandler mPropertyChanged;
    internal static object propertyChangedLock;
    [CompilerGeneratedAttribute]
private static HttpClientFactory <HttpClientFactory>k__BackingField;
    private static Dictionary`2<string, List`1<TraceListener>> _traceListeners;
    public static Nullable`1<TimeSpan> ManualClockCorrection { get; public set; }
    public static bool CorrectForClockSkew { get; public set; }
    [ObsoleteAttribute("This value is deprecated in favor of IClientConfig.ClockOffset, use CorrectClockSkew.GetClockCorrectionForEndpoint(string endpoint) instead.")]
public static TimeSpan ClockOffset { get; internal set; }
    public static string AWSRegion { get; public set; }
    public static string AWSProfileName { get; public set; }
    public static string AWSProfilesLocation { get; public set; }
    [ObsoleteAttribute("This property is obsolete. Use LoggingConfig.LogTo instead.")]
public static LoggingOptions Logging { get; public set; }
    [ObsoleteAttribute("This property is obsolete. Use LoggingConfig.LogResponses instead.")]
public static ResponseLoggingOption ResponseLogging { get; public set; }
    [ObsoleteAttribute("This property is obsolete. Use LoggingConfig.LogMetrics instead.")]
public static bool LogMetrics { get; public set; }
    public static bool UseSdkCache { get; public set; }
    public static bool InitializeCollections { get; public set; }
    public static LoggingConfig LoggingConfig { get; }
    public static ProxyConfig ProxyConfig { get; }
    public static bool UseAlternateUserAgentHeader { get; public set; }
    public static TelemetryProvider TelemetryProvider { get; public set; }
    public static RegionEndpoint RegionEndpoint { get; public set; }
    public static CSMConfig CSMConfig { get; public set; }
    public static HttpClientFactory HttpClientFactory { get; public set; }
    private static AWSConfigs();
    public static Nullable`1<TimeSpan> get_ManualClockCorrection();
    public static void set_ManualClockCorrection(Nullable`1<TimeSpan> value);
    public static bool get_CorrectForClockSkew();
    public static void set_CorrectForClockSkew(bool value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_ClockOffset();
    [CompilerGeneratedAttribute]
internal static void set_ClockOffset(TimeSpan value);
    public static string get_AWSRegion();
    public static void set_AWSRegion(string value);
    public static string get_AWSProfileName();
    public static void set_AWSProfileName(string value);
    public static string get_AWSProfilesLocation();
    public static void set_AWSProfilesLocation(string value);
    public static LoggingOptions get_Logging();
    public static void set_Logging(LoggingOptions value);
    private static LoggingOptions GetLoggingSetting();
    public static ResponseLoggingOption get_ResponseLogging();
    public static void set_ResponseLogging(ResponseLoggingOption value);
    public static bool get_LogMetrics();
    public static void set_LogMetrics(bool value);
    public static bool get_UseSdkCache();
    public static void set_UseSdkCache(bool value);
    public static bool get_InitializeCollections();
    public static void set_InitializeCollections(bool value);
    public static LoggingConfig get_LoggingConfig();
    public static ProxyConfig get_ProxyConfig();
    public static bool get_UseAlternateUserAgentHeader();
    public static void set_UseAlternateUserAgentHeader(bool value);
    public static TelemetryProvider get_TelemetryProvider();
    public static void set_TelemetryProvider(TelemetryProvider value);
    public static RegionEndpoint get_RegionEndpoint();
    public static void set_RegionEndpoint(RegionEndpoint value);
    public static CSMConfig get_CSMConfig();
    public static void set_CSMConfig(CSMConfig value);
    internal static void add_PropertyChanged(PropertyChangedEventHandler value);
    internal static void remove_PropertyChanged(PropertyChangedEventHandler value);
    internal static void OnPropertyChanged(string name);
    private static bool GetConfigBool(string name, bool defaultValue);
    private static T GetConfigEnum(string name);
    private static T ParseEnum(string value);
    private static bool TryParseEnum(string value, T& result);
    private static DateTime GetUtcNow();
    public static string GetConfig(string name);
    internal static bool XmlSectionExists(string sectionName);
    [CompilerGeneratedAttribute]
public static HttpClientFactory get_HttpClientFactory();
    [CompilerGeneratedAttribute]
public static void set_HttpClientFactory(HttpClientFactory value);
    public static void AddTraceListener(string source, TraceListener listener);
    public static void RemoveTraceListener(string source, string name);
    internal static TraceListener[] TraceListeners(string source);
}
[ObsoleteAttribute("This class is obsoleted because as of version 3.7.100 endpoint is resolved using a newer system that uses request level parameters to resolve the endpoint, use the service-specific client.DetermineServiceOperationEndPoint method instead.")]
public class Amazon.Internal.GetEndpointForServiceOptions : object {
    [CompilerGeneratedAttribute]
private bool <DualStack>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FIPS>k__BackingField;
    public bool DualStack { get; public set; }
    public bool FIPS { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DualStack();
    [CompilerGeneratedAttribute]
public void set_DualStack(bool value);
    [CompilerGeneratedAttribute]
public bool get_FIPS();
    [CompilerGeneratedAttribute]
public void set_FIPS(bool value);
}
[ExtensionAttribute]
[ObsoleteAttribute("This class is obsoleted because as of version 3.7.100 endpoint is resolved using a newer system that uses request level parameters to resolve the endpoint, use the service-specific client.DetermineServiceOperationEndPoint method instead.")]
public static class Amazon.Internal.GetEndpointForServiceOptionsExtensions : object {
    [ExtensionAttribute]
public static GetEndpointForServiceOptions ToGetEndpointForServiceOptions(IClientConfig config);
    [ExtensionAttribute]
public static Endpoint GetEndpointForService(RegionEndpoint endpoint, IClientConfig config);
}
[FlagsAttribute]
public enum Amazon.LoggingOptions : Enum {
    public int value__;
    public static LoggingOptions None;
    public static LoggingOptions Log4Net;
    public static LoggingOptions SystemDiagnostics;
    public static LoggingOptions Console;
}
public enum Amazon.LogMetricsFormatOption : Enum {
    public int value__;
    public static LogMetricsFormatOption Standard;
    public static LogMetricsFormatOption JSON;
}
public class Amazon.Profile : object {
    private string location;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public string Location { get; public set; }
    public Profile(string name);
    public Profile(string name, string location);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public string get_Location();
    public void set_Location(string value);
    public virtual string ToString();
}
public class Amazon.RegionEndpoint : object {
    private static HashSet`1<string> _sigV2SupportedRegions;
    private static Dictionary`2<string, RegionEndpoint> _hashBySystemName;
    private static ReaderWriterLockSlim _readerWriterLock;
    private static HashSet`1<string> _allPartitionRegionRegex;
    [CompilerGeneratedAttribute]
private string <SystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionDnsSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionRegionRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostnameTemplate>k__BackingField;
    public static RegionEndpoint AFSouth1;
    public static RegionEndpoint APEast1;
    public static RegionEndpoint APNortheast1;
    public static RegionEndpoint APNortheast2;
    public static RegionEndpoint APNortheast3;
    public static RegionEndpoint APSouth1;
    public static RegionEndpoint APSouth2;
    public static RegionEndpoint APSoutheast1;
    public static RegionEndpoint APSoutheast2;
    public static RegionEndpoint APSoutheast3;
    public static RegionEndpoint APSoutheast4;
    public static RegionEndpoint CACentral1;
    public static RegionEndpoint CAWest1;
    public static RegionEndpoint EUCentral1;
    public static RegionEndpoint EUCentral2;
    public static RegionEndpoint EUNorth1;
    public static RegionEndpoint EUSouth1;
    public static RegionEndpoint EUSouth2;
    public static RegionEndpoint EUWest1;
    public static RegionEndpoint EUWest2;
    public static RegionEndpoint EUWest3;
    public static RegionEndpoint ILCentral1;
    public static RegionEndpoint MECentral1;
    public static RegionEndpoint MESouth1;
    public static RegionEndpoint SAEast1;
    private static RegionEndpoint USEast1Regional;
    public static RegionEndpoint USEast1;
    public static RegionEndpoint USEast2;
    public static RegionEndpoint USWest1;
    public static RegionEndpoint USWest2;
    public static RegionEndpoint CNNorth1;
    public static RegionEndpoint CNNorthWest1;
    public static RegionEndpoint USGovCloudEast1;
    public static RegionEndpoint USGovCloudWest1;
    public static RegionEndpoint USIsoEast1;
    public static RegionEndpoint USIsoWest1;
    public static RegionEndpoint USIsobEast1;
    public static RegionEndpoint EUIsoeWest1;
    public static IEnumerable`1<RegionEndpoint> EnumerableAllRegions { get; }
    public static IEnumerable`1<string> AllPartitionRegionRegex { get; }
    public string SystemName { get; private set; }
    public string DisplayName { get; private set; }
    public string PartitionName { get; private set; }
    public string PartitionDnsSuffix { get; private set; }
    public string PartitionRegionRegex { get; private set; }
    public string HostnameTemplate { get; private set; }
    private RegionEndpoint(string systemName, string displayName, string partitionName, string partitionDnsSuffix, string partitionRegionRegex, string hostnameTemplate);
    private static RegionEndpoint();
    public static IEnumerable`1<RegionEndpoint> get_EnumerableAllRegions();
    public static IEnumerable`1<string> get_AllPartitionRegionRegex();
    private static RegionEndpoint GetRegionEndpoint(string systemName, string displayName, string partitionName, string partitionDnsSuffix, string partitionRegionRegex, string hostnameTemplate);
    public static RegionEndpoint GetBySystemName(string systemName);
    private static bool IsRegionInPartition(string regionName, string partitionName, string partitionRegionPattern, String& description);
    private static string GetUnknownRegionDescription(string regionName);
    [ObsoleteAttribute("This operation is obsoleted because as of version 3.7.100 endpoint is resolved using a newer system that uses request level parameters to resolve the endpoint, use the service-specific client.DetermineServiceOperationEndPoint method instead.")]
public static RegionEndpoint GetRegionEndpointOverride(RegionEndpoint regionEndpoint);
    [CompilerGeneratedAttribute]
public string get_SystemName();
    [CompilerGeneratedAttribute]
private void set_SystemName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
private void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionName();
    [CompilerGeneratedAttribute]
private void set_PartitionName(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionDnsSuffix();
    [CompilerGeneratedAttribute]
private void set_PartitionDnsSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionRegionRegex();
    [CompilerGeneratedAttribute]
private void set_PartitionRegionRegex(string value);
    [CompilerGeneratedAttribute]
public string get_HostnameTemplate();
    [CompilerGeneratedAttribute]
private void set_HostnameTemplate(string value);
    [ObsoleteAttribute("This operation is obsoleted because as of version 3.7.100 endpoint is resolved using a newer system that uses request level parameters to resolve the endpoint, use the service-specific client.DetermineServiceOperationEndPoint method instead.")]
public Endpoint GetEndpointForService(string serviceName);
    [ObsoleteAttribute("This operation is obsoleted because as of version 3.7.100 endpoint is resolved using a newer system that uses request level parameters to resolve the endpoint, use the service-specific client.DetermineServiceOperationEndPoint method instead.")]
public Endpoint GetEndpointForService(string serviceName, GetEndpointForServiceOptions options);
    public virtual string ToString();
}
public enum Amazon.ResponseLoggingOption : Enum {
    public int value__;
    public static ResponseLoggingOption Never;
    public static ResponseLoggingOption OnError;
    public static ResponseLoggingOption Always;
}
public class Amazon.Runtime.AmazonAccountIdException : AmazonClientException {
    public AmazonAccountIdException(string message);
    public AmazonAccountIdException(string message, Exception innerException);
}
public class Amazon.Runtime.AmazonClientException : Exception {
    public AmazonClientException(string message);
    public AmazonClientException(string message, Exception innerException);
}
public class Amazon.Runtime.AmazonDateTimeUnmarshallingException : AmazonUnmarshallingException {
    [CompilerGeneratedAttribute]
private string <InvalidDateTimeToken>k__BackingField;
    public string InvalidDateTimeToken { get; private set; }
    public AmazonDateTimeUnmarshallingException(string requestId, string lastKnownLocation, string invalidDateTimeToken, Exception innerException);
    public AmazonDateTimeUnmarshallingException(string requestId, string lastKnownLocation, string responseBody, string invalidDateTimeToken, Exception innerException);
    public AmazonDateTimeUnmarshallingException(string requestId, string lastKnownLocation, string responseBody, string invalidDateTimeToken, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_InvalidDateTimeToken();
    [CompilerGeneratedAttribute]
private void set_InvalidDateTimeToken(string value);
}
public abstract class Amazon.Runtime.AmazonServiceClient : object {
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isProtocolUpdated;
    private object _lock;
    private IDisposable _uptimeMetricMeasurer;
    private bool _disposed;
    private Logger _logger;
    [CompilerGeneratedAttribute]
private EndpointDiscoveryResolverBase <EndpointDiscoveryResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimePipeline <RuntimePipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private AWSCredentials <Credentials>k__BackingField;
    private ClientConfig _config;
    [CompilerGeneratedAttribute]
private IServiceMetadata <ServiceMetadata>k__BackingField;
    private PreRequestEventHandler mBeforeMarshallingEvent;
    private RequestEventHandler mBeforeRequestEvent;
    private ResponseEventHandler mAfterResponseEvent;
    private ExceptionEventHandler mExceptionEvent;
    [CompilerGeneratedAttribute]
private AbstractAWSSigner <Signer>k__BackingField;
    protected EndpointDiscoveryResolverBase EndpointDiscoveryResolver { get; private set; }
    protected RuntimePipeline RuntimePipeline { get; protected set; }
    protected internal AWSCredentials Credentials { get; private set; }
    public IClientConfig Config { get; }
    protected IServiceMetadata ServiceMetadata { get; }
    protected bool SupportResponseLogging { get; }
    protected AbstractAWSSigner Signer { get; private set; }
    protected AmazonServiceClient(AWSCredentials credentials, ClientConfig config);
    protected AmazonServiceClient(string awsAccessKeyId, string awsSecretAccessKey, string awsSessionToken, ClientConfig config);
    protected AmazonServiceClient(string awsAccessKeyId, string awsSecretAccessKey, ClientConfig config);
    [CompilerGeneratedAttribute]
protected EndpointDiscoveryResolverBase get_EndpointDiscoveryResolver();
    [CompilerGeneratedAttribute]
private void set_EndpointDiscoveryResolver(EndpointDiscoveryResolverBase value);
    [CompilerGeneratedAttribute]
protected RuntimePipeline get_RuntimePipeline();
    [CompilerGeneratedAttribute]
protected void set_RuntimePipeline(RuntimePipeline value);
    [CompilerGeneratedAttribute]
protected internal AWSCredentials get_Credentials();
    [CompilerGeneratedAttribute]
private void set_Credentials(AWSCredentials value);
    public IClientConfig get_Config();
    [CompilerGeneratedAttribute]
protected virtual IServiceMetadata get_ServiceMetadata();
    protected virtual bool get_SupportResponseLogging();
    internal void add_BeforeMarshallingEvent(PreRequestEventHandler value);
    internal void remove_BeforeMarshallingEvent(PreRequestEventHandler value);
    public void add_BeforeRequestEvent(RequestEventHandler value);
    public void remove_BeforeRequestEvent(RequestEventHandler value);
    public void add_AfterResponseEvent(ResponseEventHandler value);
    public void remove_AfterResponseEvent(ResponseEventHandler value);
    public void add_ExceptionEvent(ExceptionEventHandler value);
    public void remove_ExceptionEvent(ExceptionEventHandler value);
    [CompilerGeneratedAttribute]
protected AbstractAWSSigner get_Signer();
    [CompilerGeneratedAttribute]
private void set_Signer(AbstractAWSSigner value);
    protected virtual void Initialize();
    [ObsoleteAttribute("Invoke taking marshallers is obsolete. Use Invoke taking InvokeOptionsBase instead.")]
protected TResponse Invoke(TRequest request, IMarshaller`2<IRequest, AmazonWebServiceRequest> marshaller, ResponseUnmarshaller unmarshaller);
    protected TResponse Invoke(AmazonWebServiceRequest request, InvokeOptionsBase options);
    [ObsoleteAttribute("InvokeAsync taking marshallers is obsolete. Use InvokeAsync taking InvokeOptionsBase instead.")]
protected Task`1<TResponse> InvokeAsync(TRequest request, IMarshaller`2<IRequest, AmazonWebServiceRequest> marshaller, ResponseUnmarshaller unmarshaller, CancellationToken cancellationToken);
    protected Task`1<TResponse> InvokeAsync(AmazonWebServiceRequest request, InvokeOptionsBase options, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<DiscoveryEndpointBase> EndpointOperation(EndpointOperationContextBase context);
    protected void ProcessPreRequestHandlers(IExecutionContext executionContext);
    protected void ProcessRequestHandlers(IExecutionContext executionContext);
    protected void ProcessResponseHandlers(IExecutionContext executionContext);
    protected virtual void ProcessExceptionHandlers(IExecutionContext executionContext, Exception exception);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    protected abstract virtual AbstractAWSSigner CreateSigner();
    protected virtual void CustomizeRuntimePipeline(RuntimePipeline pipeline);
    private void BuildRuntimePipeline();
    private void UpdateSecurityProtocol();
    public static Uri ComposeUrl(IRequest iRequest);
    public static Uri ComposeUrl(IRequest internalRequest, bool skipEncodingValidPathChars);
    private static void DontUnescapePathDotsAndSlashes(Uri uri);
    internal C CloneConfig();
    internal void CloneConfig(ClientConfig newConfig);
    private static void SetupCSMHandler(IRequestContext requestContext);
}
public class Amazon.Runtime.AmazonServiceException : Exception {
    private ErrorType errorType;
    private string errorCode;
    private string requestId;
    private HttpStatusCode statusCode;
    public ErrorType ErrorType { get; public set; }
    public string ErrorCode { get; public set; }
    public string RequestId { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public RetryableDetails Retryable { get; }
    public AmazonServiceException(string message);
    public AmazonServiceException(string message, Exception innerException);
    public AmazonServiceException(string message, Exception innerException, HttpStatusCode statusCode);
    public AmazonServiceException(Exception innerException);
    public AmazonServiceException(string message, ErrorType errorType, string errorCode, string requestId, HttpStatusCode statusCode);
    public AmazonServiceException(string message, Exception innerException, ErrorType errorType, string errorCode, string requestId, HttpStatusCode statusCode);
    private static string BuildGenericErrorMessage(string errorCode, HttpStatusCode statusCode);
    public ErrorType get_ErrorType();
    public void set_ErrorType(ErrorType value);
    public string get_ErrorCode();
    public void set_ErrorCode(string value);
    public string get_RequestId();
    public void set_RequestId(string value);
    public HttpStatusCode get_StatusCode();
    public void set_StatusCode(HttpStatusCode value);
    public virtual RetryableDetails get_Retryable();
}
public class Amazon.Runtime.AmazonUnmarshallingException : AmazonServiceException {
    [CompilerGeneratedAttribute]
private string <LastKnownLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseBody>k__BackingField;
    public string LastKnownLocation { get; private set; }
    public string ResponseBody { get; private set; }
    public string Message { get; }
    public AmazonUnmarshallingException(string requestId, string lastKnownLocation, Exception innerException);
    public AmazonUnmarshallingException(string requestId, string lastKnownLocation, string responseBody, Exception innerException);
    public AmazonUnmarshallingException(string requestId, string lastKnownLocation, string responseBody, string message, Exception innerException);
    public AmazonUnmarshallingException(string requestId, string lastKnownLocation, Exception innerException, HttpStatusCode statusCode);
    public AmazonUnmarshallingException(string requestId, string lastKnownLocation, string responseBody, Exception innerException, HttpStatusCode statusCode);
    [CompilerGeneratedAttribute]
public string get_LastKnownLocation();
    [CompilerGeneratedAttribute]
private void set_LastKnownLocation(string value);
    [CompilerGeneratedAttribute]
public string get_ResponseBody();
    [CompilerGeneratedAttribute]
private void set_ResponseBody(string value);
    public virtual string get_Message();
    private static void AppendFormat(StringBuilder sb, string format, string value);
}
public abstract class Amazon.Runtime.AmazonWebServiceRequest : object {
    private object _lock;
    internal RequestEventHandler mBeforeRequestEvent;
    [CompilerGeneratedAttribute]
private string <UserAgentAddition>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamTransferProgressArgs> <Amazon.Runtime.Internal.IAmazonWebServiceRequest.StreamUploadProgressCallback>k__BackingField;
    private Dictionary`2<string, object> requestState;
    [CompilerGeneratedAttribute]
private SignatureVersion <Amazon.Runtime.Internal.IAmazonWebServiceRequest.SignatureVersion>k__BackingField;
    internal string UserAgentAddition { get; internal set; }
    private EventHandler`1<StreamTransferProgressArgs> Amazon.Runtime.Internal.IAmazonWebServiceRequest.StreamUploadProgressCallback { get; private set; }
    private Dictionary`2<string, object> Amazon.Runtime.Internal.IAmazonWebServiceRequest.RequestState { get; }
    [ObsoleteAttribute("UseSigV4 is deprecated. Use SignatureVersion directly instead.")]
private bool Amazon.Runtime.Internal.IAmazonWebServiceRequest.UseSigV4 { get; private set; }
    [ObsoleteAttribute("UseSigV4 is deprecated. Use SignatureVersion directly instead.")]
protected bool UseSigV4 { get; protected set; }
    private SignatureVersion Amazon.Runtime.Internal.IAmazonWebServiceRequest.SignatureVersion { get; private set; }
    protected bool Expect100Continue { get; }
    protected bool IncludeSHA256Header { get; }
    protected internal CoreChecksumResponseBehavior CoreChecksumMode { get; }
    protected internal ReadOnlyCollection`1<CoreChecksumAlgorithm> ChecksumResponseAlgorithms { get; }
    [CompilerGeneratedAttribute]
internal string get_UserAgentAddition();
    [CompilerGeneratedAttribute]
internal void set_UserAgentAddition(string value);
    internal void add_BeforeRequestEvent(RequestEventHandler value);
    internal void remove_BeforeRequestEvent(RequestEventHandler value);
    [CompilerGeneratedAttribute]
private sealed virtual override EventHandler`1<StreamTransferProgressArgs> Amazon.Runtime.Internal.IAmazonWebServiceRequest.get_StreamUploadProgressCallback();
    [CompilerGeneratedAttribute]
private sealed virtual override void Amazon.Runtime.Internal.IAmazonWebServiceRequest.set_StreamUploadProgressCallback(EventHandler`1<StreamTransferProgressArgs> value);
    private sealed virtual override Dictionary`2<string, object> Amazon.Runtime.Internal.IAmazonWebServiceRequest.get_RequestState();
    private sealed virtual override void Amazon.Runtime.Internal.IAmazonWebServiceRequest.AddBeforeRequestHandler(RequestEventHandler handler);
    private sealed virtual override void Amazon.Runtime.Internal.IAmazonWebServiceRequest.RemoveBeforeRequestHandler(RequestEventHandler handler);
    internal void FireBeforeRequestEvent(object sender, RequestEventArgs args);
    private sealed virtual override bool Amazon.Runtime.Internal.IAmazonWebServiceRequest.get_UseSigV4();
    private sealed virtual override void Amazon.Runtime.Internal.IAmazonWebServiceRequest.set_UseSigV4(bool value);
    protected bool get_UseSigV4();
    protected void set_UseSigV4(bool value);
    [CompilerGeneratedAttribute]
private sealed virtual override SignatureVersion Amazon.Runtime.Internal.IAmazonWebServiceRequest.get_SignatureVersion();
    [CompilerGeneratedAttribute]
private sealed virtual override void Amazon.Runtime.Internal.IAmazonWebServiceRequest.set_SignatureVersion(SignatureVersion value);
    protected virtual bool get_Expect100Continue();
    internal bool GetExpect100Continue();
    protected virtual bool get_IncludeSHA256Header();
    internal bool GetIncludeSHA256Header();
    protected virtual AbstractAWSSigner CreateSigner();
    internal AbstractAWSSigner GetSigner();
    protected internal virtual CoreChecksumResponseBehavior get_CoreChecksumMode();
    protected internal virtual ReadOnlyCollection`1<CoreChecksumAlgorithm> get_ChecksumResponseAlgorithms();
}
public class Amazon.Runtime.AmazonWebServiceResponse : object {
    private ResponseMetadata responseMetadataField;
    private long contentLength;
    private HttpStatusCode httpStatusCode;
    public ResponseMetadata ResponseMetadata { get; public set; }
    public long ContentLength { get; public set; }
    public HttpStatusCode HttpStatusCode { get; public set; }
    public ResponseMetadata get_ResponseMetadata();
    public void set_ResponseMetadata(ResponseMetadata value);
    public long get_ContentLength();
    public void set_ContentLength(long value);
    public HttpStatusCode get_HttpStatusCode();
    public void set_HttpStatusCode(HttpStatusCode value);
}
public class Amazon.Runtime.AnonymousAWSCredentials : AWSCredentials {
    public virtual ImmutableCredentials GetCredentials();
}
public class Amazon.Runtime.AppConfigAWSRegion : AWSRegion {
}
public class Amazon.Runtime.AssumeRoleAWSCredentials : RefreshingAWSCredentials {
    private RegionEndpoint DefaultSTSClientRegion;
    private Logger _logger;
    [CompilerGeneratedAttribute]
private AWSCredentials <SourceCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleArn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleSessionName>k__BackingField;
    [CompilerGeneratedAttribute]
private AssumeRoleAWSCredentialsOptions <Options>k__BackingField;
    public AWSCredentials SourceCredentials { get; private set; }
    public string RoleArn { get; private set; }
    public string RoleSessionName { get; private set; }
    public AssumeRoleAWSCredentialsOptions Options { get; private set; }
    public AssumeRoleAWSCredentials(AWSCredentials sourceCredentials, string roleArn, string roleSessionName);
    public AssumeRoleAWSCredentials(AWSCredentials sourceCredentials, string roleArn, string roleSessionName, AssumeRoleAWSCredentialsOptions options);
    [CompilerGeneratedAttribute]
public AWSCredentials get_SourceCredentials();
    [CompilerGeneratedAttribute]
private void set_SourceCredentials(AWSCredentials value);
    [CompilerGeneratedAttribute]
public string get_RoleArn();
    [CompilerGeneratedAttribute]
private void set_RoleArn(string value);
    [CompilerGeneratedAttribute]
public string get_RoleSessionName();
    [CompilerGeneratedAttribute]
private void set_RoleSessionName(string value);
    [CompilerGeneratedAttribute]
public AssumeRoleAWSCredentialsOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(AssumeRoleAWSCredentialsOptions value);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
protected virtual CredentialsRefreshState GenerateNewCredentials();
}
public class Amazon.Runtime.AssumeRoleAWSCredentialsOptions : object {
    [CompilerGeneratedAttribute]
private string <ExternalId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DurationSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <ProxySettings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MfaSerialNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<string> <MfaTokenCodeCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, string>> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <TransitiveTagKeys>k__BackingField;
    public string ExternalId { get; public set; }
    public string Policy { get; public set; }
    public Nullable`1<int> DurationSeconds { get; public set; }
    public IWebProxy ProxySettings { get; public set; }
    public string MfaSerialNumber { get; public set; }
    public string MfaTokenCode { get; }
    public Func`1<string> MfaTokenCodeCallback { get; public set; }
    public string SourceIdentity { get; public set; }
    public List`1<KeyValuePair`2<string, string>> Tags { get; public set; }
    public List`1<string> TransitiveTagKeys { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ExternalId();
    [CompilerGeneratedAttribute]
public void set_ExternalId(string value);
    [CompilerGeneratedAttribute]
public string get_Policy();
    [CompilerGeneratedAttribute]
public void set_Policy(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DurationSeconds();
    [CompilerGeneratedAttribute]
public void set_DurationSeconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IWebProxy get_ProxySettings();
    [CompilerGeneratedAttribute]
public void set_ProxySettings(IWebProxy value);
    [CompilerGeneratedAttribute]
public string get_MfaSerialNumber();
    [CompilerGeneratedAttribute]
public void set_MfaSerialNumber(string value);
    public string get_MfaTokenCode();
    [CompilerGeneratedAttribute]
public Func`1<string> get_MfaTokenCodeCallback();
    [CompilerGeneratedAttribute]
public void set_MfaTokenCodeCallback(Func`1<string> value);
    [CompilerGeneratedAttribute]
public string get_SourceIdentity();
    [CompilerGeneratedAttribute]
public void set_SourceIdentity(string value);
    [CompilerGeneratedAttribute]
public List`1<KeyValuePair`2<string, string>> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(List`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_TransitiveTagKeys();
    [CompilerGeneratedAttribute]
public void set_TransitiveTagKeys(List`1<string> value);
}
public class Amazon.Runtime.AssumeRoleImmutableCredentials : ImmutableCredentials {
    [CompilerGeneratedAttribute]
private DateTime <Expiration>k__BackingField;
    public DateTime Expiration { get; private set; }
    public AssumeRoleImmutableCredentials(string awsAccessKeyId, string awsSecretAccessKey, string token, DateTime expiration);
    [CompilerGeneratedAttribute]
public DateTime get_Expiration();
    [CompilerGeneratedAttribute]
private void set_Expiration(DateTime value);
    public AssumeRoleImmutableCredentials Copy();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Amazon.Runtime.AssumeRoleWithWebIdentityCredentials : RefreshingAWSCredentials {
    private static int PREEMPT_EXPIRY_MINUTES;
    private static RegionEndpoint _defaultSTSClientRegion;
    private static string _roleSessionNameDefault;
    public static string WebIdentityTokenFileEnvVariable;
    public static string RoleArnEnvVariable;
    public static string RoleSessionNameEnvVariable;
    private static string RoleSessionNameRegexPattern;
    private Logger _logger;
    private AssumeRoleWithWebIdentityCredentialsOptions _options;
    [CompilerGeneratedAttribute]
private string <WebIdentityTokenFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleArn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleSessionName>k__BackingField;
    public string WebIdentityTokenFile { get; }
    public string RoleArn { get; }
    public string RoleSessionName { get; }
    public AssumeRoleWithWebIdentityCredentials(string webIdentityTokenFile, string roleArn, string roleSessionName);
    public AssumeRoleWithWebIdentityCredentials(string webIdentityTokenFile, string roleArn, string roleSessionName, AssumeRoleWithWebIdentityCredentialsOptions options);
    private static AssumeRoleWithWebIdentityCredentials();
    [GeneratedRegexAttribute("^[\w+=,.@-]{2,64}$")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
private static Regex RoleSessionNameRegex();
    [CompilerGeneratedAttribute]
public string get_WebIdentityTokenFile();
    [CompilerGeneratedAttribute]
public string get_RoleArn();
    [CompilerGeneratedAttribute]
public string get_RoleSessionName();
    public static AssumeRoleWithWebIdentityCredentials FromEnvironmentVariables();
    protected virtual CredentialsRefreshState GenerateNewCredentials();
    [AsyncStateMachineAttribute("Amazon.Runtime.AssumeRoleWithWebIdentityCredentials/<GenerateNewCredentialsAsync>d__23")]
protected virtual Task`1<CredentialsRefreshState> GenerateNewCredentialsAsync();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
protected virtual ICoreAmazonSTS_WebIdentity CreateClient();
}
public class Amazon.Runtime.AssumeRoleWithWebIdentityCredentialsOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DurationSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <PolicyArns>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <ProxySettings>k__BackingField;
    public Nullable`1<int> DurationSeconds { get; public set; }
    public string ProviderId { get; public set; }
    public string Policy { get; public set; }
    public List`1<string> PolicyArns { get; public set; }
    public IWebProxy ProxySettings { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DurationSeconds();
    [CompilerGeneratedAttribute]
public void set_DurationSeconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_ProviderId();
    [CompilerGeneratedAttribute]
public void set_ProviderId(string value);
    [CompilerGeneratedAttribute]
public string get_Policy();
    [CompilerGeneratedAttribute]
public void set_Policy(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_PolicyArns();
    [CompilerGeneratedAttribute]
public void set_PolicyArns(List`1<string> value);
    [CompilerGeneratedAttribute]
public IWebProxy get_ProxySettings();
    [CompilerGeneratedAttribute]
public void set_ProxySettings(IWebProxy value);
}
public class Amazon.Runtime.AWSCommonRuntimeException : AmazonClientException {
    public AWSCommonRuntimeException(string message);
    public AWSCommonRuntimeException(string message, Exception innerException);
}
public abstract class Amazon.Runtime.AWSCredentials : object {
    public abstract virtual ImmutableCredentials GetCredentials();
    protected virtual void Validate();
    public virtual Task`1<ImmutableCredentials> GetCredentialsAsync();
}
public abstract class Amazon.Runtime.AWSRegion : object {
    [CompilerGeneratedAttribute]
private RegionEndpoint <Region>k__BackingField;
    public RegionEndpoint Region { get; protected set; }
    [CompilerGeneratedAttribute]
public RegionEndpoint get_Region();
    [CompilerGeneratedAttribute]
protected void set_Region(RegionEndpoint value);
    protected void SetRegionFromName(string regionSystemName);
}
[DebuggerDisplayAttribute("{Token}")]
public class Amazon.Runtime.AWSToken : object {
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpiresAt>k__BackingField;
    public string Token { get; public set; }
    public Nullable`1<DateTime> ExpiresAt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpiresAt();
    [CompilerGeneratedAttribute]
public void set_ExpiresAt(Nullable`1<DateTime> value);
    public virtual string ToString();
}
public class Amazon.Runtime.AWSTokenProviderChain : object {
    private IAWSTokenProvider[] _chain;
    public AWSTokenProviderChain(IAWSTokenProvider[] providers);
    [AsyncStateMachineAttribute("Amazon.Runtime.AWSTokenProviderChain/<TryResolveTokenAsync>d__2")]
public sealed virtual Task`1<TryResponse`1<AWSToken>> TryResolveTokenAsync(CancellationToken cancellationToken);
}
public class Amazon.Runtime.BasicAWSCredentials : AWSCredentials {
    private ImmutableCredentials _credentials;
    public BasicAWSCredentials(string accessKey, string secretKey);
    public virtual ImmutableCredentials GetCredentials();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Amazon.Runtime.BearerTokenSigner : AbstractAWSSigner {
    [CompilerGeneratedAttribute]
private bool <RequiresCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientProtocol <Protocol>k__BackingField;
    public bool RequiresCredentials { get; }
    public ClientProtocol Protocol { get; }
    [CompilerGeneratedAttribute]
public virtual bool get_RequiresCredentials();
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    [AsyncStateMachineAttribute("Amazon.Runtime.BearerTokenSigner/<SignAsync>d__4")]
public virtual Task SignAsync(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials, CancellationToken token);
    [CompilerGeneratedAttribute]
public virtual ClientProtocol get_Protocol();
}
public enum Amazon.Runtime.ChecksumValidationStatus : Enum {
    public int value__;
    public static ChecksumValidationStatus NOT_VALIDATED;
    public static ChecksumValidationStatus PENDING_RESPONSE_READ;
    public static ChecksumValidationStatus SUCCESSFUL;
    public static ChecksumValidationStatus INVALID;
}
public abstract class Amazon.Runtime.ClientConfig : object {
    internal static TimeSpan InfiniteTimeout;
    internal static long UpperLimitCompressionSizeBytes;
    public static TimeSpan MaxTimeout;
    private IDefaultConfigurationProvider _defaultConfigurationProvider;
    private string serviceId;
    private Nullable`1<DefaultConfigurationMode> defaultConfigurationMode;
    private RegionEndpoint regionEndpoint;
    private bool probeForRegionEndpoint;
    private bool throttleRetries;
    private bool useHttp;
    private bool useAlternateUserAgentHeader;
    private string serviceURL;
    private string authRegion;
    private string authServiceName;
    private string signatureVersion;
    private string clientAppId;
    private SigningAlgorithm signatureMethod;
    private bool readEntireResponse;
    private bool logResponse;
    private int bufferSize;
    private long progressUpdateInterval;
    private bool resignRetries;
    private ICredentials proxyCredentials;
    private bool logMetrics;
    private bool disableLogging;
    private Nullable`1<TimeSpan> timeout;
    private bool allowAutoRedirect;
    private Nullable`1<bool> useDualstackEndpoint;
    private Nullable`1<bool> useFIPSEndpoint;
    private Nullable`1<bool> disableRequestCompression;
    private Nullable`1<long> requestMinCompressionSizeBytes;
    private Nullable`1<TimeSpan> readWriteTimeout;
    private bool disableHostPrefixInjection;
    private Nullable`1<bool> endpointDiscoveryEnabled;
    private Nullable`1<bool> ignoreConfiguredEndpointUrls;
    private int endpointDiscoveryCacheLimit;
    private Nullable`1<RequestRetryMode> retryMode;
    private Nullable`1<int> maxRetries;
    private static int MaxRetriesDefault;
    private static long DefaultMinCompressionSizeBytes;
    private bool didProcessServiceURL;
    private IAWSTokenProvider _awsTokenProvider;
    private TelemetryProvider telemetryProvider;
    private CredentialProfileStoreChain credentialProfileStoreChain;
    [CompilerGeneratedAttribute]
private Profile <Profile>k__BackingField;
    private IDefaultConfiguration defaultConfigurationBackingField;
    [CompilerGeneratedAttribute]
private bool <FastFailRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheHttpClient>k__BackingField;
    private Nullable`1<int> _httpClientCacheSize;
    [CompilerGeneratedAttribute]
private IEndpointProvider <EndpointProvider>k__BackingField;
    private IWebProxy proxy;
    private string proxyHost;
    private int proxyPort;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxConnectionsPerServer>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpClientFactory <HttpClientFactory>k__BackingField;
    public Profile Profile { get; public set; }
    private CredentialProfileStoreChain CredentialProfileStoreChain { get; private set; }
    public IAWSTokenProvider AWSTokenProvider { get; public set; }
    public string ServiceVersion { get; }
    public SigningAlgorithm SignatureMethod { get; public set; }
    public string SignatureVersion { get; public set; }
    public string UserAgent { get; }
    public bool UseAlternateUserAgentHeader { get; public set; }
    public RegionEndpoint RegionEndpoint { get; public set; }
    public string RegionEndpointServiceName { get; }
    public string ServiceURL { get; public set; }
    public bool UseHttp { get; public set; }
    public string AuthenticationRegion { get; public set; }
    public string AuthenticationServiceName { get; public set; }
    public string ServiceId { get; public set; }
    public int MaxErrorRetry { get; public set; }
    public bool IsMaxErrorRetrySet { get; }
    public bool LogResponse { get; public set; }
    [ObsoleteAttribute("This property does not effect response processing and is deprecated.To enable response logging, the ClientConfig.LogResponse and AWSConfigs.LoggingConfig.LogResponses properties can be used.")]
public bool ReadEntireResponse { get; public set; }
    public int BufferSize { get; public set; }
    public long ProgressUpdateInterval { get; public set; }
    public bool ResignRetries { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public bool LogMetrics { get; public set; }
    public bool DisableLogging { get; public set; }
    public DefaultConfigurationMode DefaultConfigurationMode { get; public set; }
    protected IDefaultConfiguration DefaultConfiguration { get; }
    public ICredentials ProxyCredentials { get; public set; }
    public Nullable`1<TimeSpan> Timeout { get; public set; }
    public bool UseDualstackEndpoint { get; public set; }
    public bool UseFIPSEndpoint { get; public set; }
    public bool IgnoreConfiguredEndpointUrls { get; public set; }
    public bool DisableRequestCompression { get; public set; }
    public long RequestMinCompressionSizeBytes { get; public set; }
    public string ClientAppId { get; public set; }
    public bool ThrottleRetries { get; public set; }
    [ObsoleteAttribute("Please use CorrectClockSkew.GetCorrectedUtcNowForEndpoint(string endpoint) instead.", "False")]
public DateTime CorrectedUtcNow { get; }
    [ObsoleteAttribute("Please use CorrectClockSkew.GetClockCorrectionForEndpoint(string endpoint) instead.", "False")]
public TimeSpan ClockOffset { get; }
    public bool DisableHostPrefixInjection { get; public set; }
    public bool EndpointDiscoveryEnabled { get; public set; }
    public int EndpointDiscoveryCacheLimit { get; public set; }
    public RequestRetryMode RetryMode { get; public set; }
    public bool FastFailRequests { get; public set; }
    public bool CacheHttpClient { get; public set; }
    public int HttpClientCacheSize { get; public set; }
    [ObsoleteAttribute("ReadWriteTimeout is not consumed in asynchronous HTTP requests. Please use a cancellation token to handle stream read/write timeouts.")]
public Nullable`1<TimeSpan> ReadWriteTimeout { get; public set; }
    public IEndpointProvider EndpointProvider { get; public set; }
    public TelemetryProvider TelemetryProvider { get; public set; }
    public string ProxyHost { get; public set; }
    public int ProxyPort { get; public set; }
    public Nullable`1<int> MaxConnectionsPerServer { get; public set; }
    public HttpClientFactory HttpClientFactory { get; public set; }
    protected ClientConfig(IDefaultConfigurationProvider defaultConfigurationProvider);
    private static ClientConfig();
    [CompilerGeneratedAttribute]
public sealed virtual Profile get_Profile();
    [CompilerGeneratedAttribute]
public void set_Profile(Profile value);
    private CredentialProfileStoreChain get_CredentialProfileStoreChain();
    private void set_CredentialProfileStoreChain(CredentialProfileStoreChain value);
    private static WebProxy GetWebProxyWithCredentials(string value);
    public sealed virtual IAWSTokenProvider get_AWSTokenProvider();
    public void set_AWSTokenProvider(IAWSTokenProvider value);
    public abstract virtual string get_ServiceVersion();
    public sealed virtual SigningAlgorithm get_SignatureMethod();
    public void set_SignatureMethod(SigningAlgorithm value);
    public sealed virtual string get_SignatureVersion();
    public void set_SignatureVersion(string value);
    public abstract virtual string get_UserAgent();
    public sealed virtual bool get_UseAlternateUserAgentHeader();
    public void set_UseAlternateUserAgentHeader(bool value);
    public sealed virtual RegionEndpoint get_RegionEndpoint();
    public void set_RegionEndpoint(RegionEndpoint value);
    public abstract virtual string get_RegionEndpointServiceName();
    public sealed virtual string get_ServiceURL();
    public void set_ServiceURL(string value);
    public sealed virtual bool get_UseHttp();
    public void set_UseHttp(bool value);
    [ObsoleteAttribute("This operation is obsoleted because as of version 3.7.100 endpoint is resolved using a newer system that uses request level parameters to resolve the endpoint, use the service-specific client.DetermineServiceOperationEndPoint method instead.")]
public virtual string DetermineDnsSuffix();
    internal static string GetUrl(IClientConfig config, RegionEndpoint regionEndpoint);
    public sealed virtual string get_AuthenticationRegion();
    public void set_AuthenticationRegion(string value);
    public sealed virtual string get_AuthenticationServiceName();
    public void set_AuthenticationServiceName(string value);
    public sealed virtual string get_ServiceId();
    public void set_ServiceId(string value);
    public sealed virtual int get_MaxErrorRetry();
    public void set_MaxErrorRetry(int value);
    public sealed virtual bool get_IsMaxErrorRetrySet();
    public sealed virtual bool get_LogResponse();
    public void set_LogResponse(bool value);
    public sealed virtual bool get_ReadEntireResponse();
    public void set_ReadEntireResponse(bool value);
    public sealed virtual int get_BufferSize();
    public void set_BufferSize(int value);
    public sealed virtual long get_ProgressUpdateInterval();
    public void set_ProgressUpdateInterval(long value);
    public sealed virtual bool get_ResignRetries();
    public void set_ResignRetries(bool value);
    public sealed virtual bool get_AllowAutoRedirect();
    public void set_AllowAutoRedirect(bool value);
    public sealed virtual bool get_LogMetrics();
    public void set_LogMetrics(bool value);
    public sealed virtual bool get_DisableLogging();
    public void set_DisableLogging(bool value);
    public sealed virtual DefaultConfigurationMode get_DefaultConfigurationMode();
    public void set_DefaultConfigurationMode(DefaultConfigurationMode value);
    protected IDefaultConfiguration get_DefaultConfiguration();
    public sealed virtual ICredentials get_ProxyCredentials();
    public void set_ProxyCredentials(ICredentials value);
    public sealed virtual IWebProxy GetHttpProxy();
    public sealed virtual IWebProxy GetHttpsProxy();
    protected virtual void Initialize();
    public sealed virtual Nullable`1<TimeSpan> get_Timeout();
    public void set_Timeout(Nullable`1<TimeSpan> value);
    internal CancellationToken BuildDefaultCancellationToken();
    public sealed virtual bool get_UseDualstackEndpoint();
    public void set_UseDualstackEndpoint(bool value);
    public sealed virtual bool get_UseFIPSEndpoint();
    public void set_UseFIPSEndpoint(bool value);
    public sealed virtual bool get_IgnoreConfiguredEndpointUrls();
    public void set_IgnoreConfiguredEndpointUrls(bool value);
    public sealed virtual bool get_DisableRequestCompression();
    public void set_DisableRequestCompression(bool value);
    public sealed virtual long get_RequestMinCompressionSizeBytes();
    public void set_RequestMinCompressionSizeBytes(long value);
    public sealed virtual string get_ClientAppId();
    public void set_ClientAppId(string value);
    private static void ValidateClientAppId(string clientAppId);
    private static void ValidateMinCompression(long minCompressionSize);
    public sealed virtual bool get_ThrottleRetries();
    public void set_ThrottleRetries(bool value);
    public void SetUseNagleIfAvailable(bool useNagle);
    public virtual void Validate();
    public sealed virtual DateTime get_CorrectedUtcNow();
    public sealed virtual TimeSpan get_ClockOffset();
    public sealed virtual bool get_DisableHostPrefixInjection();
    public void set_DisableHostPrefixInjection(bool value);
    public sealed virtual bool get_EndpointDiscoveryEnabled();
    public void set_EndpointDiscoveryEnabled(bool value);
    public sealed virtual int get_EndpointDiscoveryCacheLimit();
    public void set_EndpointDiscoveryCacheLimit(int value);
    public sealed virtual RequestRetryMode get_RetryMode();
    public void set_RetryMode(RequestRetryMode value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FastFailRequests();
    [CompilerGeneratedAttribute]
public void set_FastFailRequests(bool value);
    public static void ValidateTimeout(Nullable`1<TimeSpan> timeout);
    public static Nullable`1<TimeSpan> GetTimeoutValue(Nullable`1<TimeSpan> clientTimeout, Nullable`1<TimeSpan> requestTimeout);
    public abstract virtual Endpoint DetermineServiceOperationEndpoint(ServiceOperationEndpointParameters parameters);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CacheHttpClient();
    [CompilerGeneratedAttribute]
public void set_CacheHttpClient(bool value);
    public sealed virtual int get_HttpClientCacheSize();
    public void set_HttpClientCacheSize(int value);
    public Nullable`1<TimeSpan> get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEndpointProvider get_EndpointProvider();
    [CompilerGeneratedAttribute]
public void set_EndpointProvider(IEndpointProvider value);
    public sealed virtual TelemetryProvider get_TelemetryProvider();
    public void set_TelemetryProvider(TelemetryProvider value);
    private static RegionEndpoint GetDefaultRegionEndpoint();
    public sealed virtual IWebProxy GetWebProxy();
    public void SetWebProxy(IWebProxy proxy);
    public sealed virtual string get_ProxyHost();
    public void set_ProxyHost(string value);
    public sealed virtual int get_ProxyPort();
    public void set_ProxyPort(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_MaxConnectionsPerServer();
    [CompilerGeneratedAttribute]
public void set_MaxConnectionsPerServer(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual HttpClientFactory get_HttpClientFactory();
    [CompilerGeneratedAttribute]
public void set_HttpClientFactory(HttpClientFactory value);
    internal static bool CacheHttpClients(IClientConfig clientConfig);
    internal static bool DisposeHttpClients(IClientConfig clientConfig);
    internal static string CreateConfigUniqueString(IClientConfig clientConfig);
    internal static bool UseGlobalHttpClientCache(IClientConfig clientConfig);
}
public enum Amazon.Runtime.CompressionEncodingAlgorithm : Enum {
    public int value__;
    public static CompressionEncodingAlgorithm NONE;
    public static CompressionEncodingAlgorithm gzip;
}
public class Amazon.Runtime.ConstantClass : object {
    private static object staticFieldsLock;
    private static Dictionary`2<Type, Dictionary`2<string, ConstantClass>> staticFields;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; private set; }
    protected ConstantClass(string value);
    private static ConstantClass();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public static string op_Implicit(ConstantClass value);
    internal ConstantClass Intern();
    protected static T FindValue(string value);
    private static void LoadFields(Type type);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ConstantClass obj);
    protected virtual bool Equals(string value);
    public static bool op_Equality(ConstantClass a, ConstantClass b);
    public static bool op_Inequality(ConstantClass a, ConstantClass b);
    public static bool op_Equality(ConstantClass a, string b);
    public static bool op_Equality(string a, ConstantClass b);
    public static bool op_Inequality(ConstantClass a, string b);
    public static bool op_Inequality(string a, ConstantClass b);
}
public enum Amazon.Runtime.CoreChecksumAlgorithm : Enum {
    public int value__;
    public static CoreChecksumAlgorithm NONE;
    public static CoreChecksumAlgorithm CRC32C;
    public static CoreChecksumAlgorithm CRC32;
    public static CoreChecksumAlgorithm SHA256;
    public static CoreChecksumAlgorithm SHA1;
}
public enum Amazon.Runtime.CoreChecksumResponseBehavior : Enum {
    public int value__;
    public static CoreChecksumResponseBehavior DISABLED;
    public static CoreChecksumResponseBehavior ENABLED;
}
public static class Amazon.Runtime.CorrectClockSkew : object {
    private static Nullable`1<TimeSpan> manualClockCorrection;
    private static ReaderWriterLockSlim manualClockCorrectionLock;
    private static IDictionary`2<string, TimeSpan> clockCorrectionDictionary;
    private static ReaderWriterLockSlim clockCorrectionDictionaryLock;
    internal static Nullable`1<TimeSpan> GlobalClockCorrection { get; internal set; }
    private static CorrectClockSkew();
    internal static Nullable`1<TimeSpan> get_GlobalClockCorrection();
    internal static void set_GlobalClockCorrection(Nullable`1<TimeSpan> value);
    public static TimeSpan GetClockCorrectionForEndpoint(string endpoint);
    public static DateTime GetCorrectedUtcNowForEndpoint(string endpoint);
    internal static void SetClockCorrectionForEndpoint(string endpoint, TimeSpan correction);
}
public static class Amazon.Runtime.CredentialManagement.AWSCredentialsFactory : object {
    private static HashSet`1<CredentialProfileType> CallbackProfileTypes;
    private static string RoleSessionNamePrefix;
    private static AWSCredentialsFactory();
    public static AWSCredentials GetAWSCredentials(CredentialProfile profile, ICredentialProfileSource profileSource);
    public static AWSCredentials GetAWSCredentials(CredentialProfileOptions options, ICredentialProfileSource profileSource);
    public static AWSCredentials GetAWSCredentials(CredentialProfile profile, ICredentialProfileSource profileSource, bool nonCallbackOnly);
    public static AWSCredentials GetAWSCredentials(CredentialProfileOptions options, ICredentialProfileSource profileSource, bool nonCallbackOnly);
    public static bool TryGetAWSCredentials(CredentialProfile profile, ICredentialProfileSource profileSource, AWSCredentials& credentials);
    public static bool TryGetAWSCredentials(CredentialProfileOptions options, ICredentialProfileSource profileSource, AWSCredentials& credentials);
    internal static bool IsCallbackRequired(Nullable`1<CredentialProfileType> profileType);
    private static AWSCredentials GetAWSCredentials(string profileName, ICredentialProfileSource profileSource, CredentialProfileOptions options, RegionEndpoint stsRegion, bool nonCallbackOnly);
    private static AWSCredentials GetAWSCredentialsInternal(string profileName, Nullable`1<CredentialProfileType> profileType, CredentialProfileOptions options, RegionEndpoint stsRegion, ICredentialProfileSource profileSource, bool throwIfInvalid, HashSet`1<string> profileLoopAvoidance);
    private static AWSCredentials GetCredentialSourceAWSCredentials(string credentialSourceType, bool throwIfInvalid);
    private static AWSCredentials GetSourceAWSCredentials(string sourceProfileName, ICredentialProfileSource profileSource, bool throwIfInvalid, HashSet`1<string> profileLoopAvoidance);
    private static BasicAWSCredentials ThrowInvalidOrReturnNull(string profileName, bool doThrow);
    private static BasicAWSCredentials ThrowOrReturnNull(string message, Exception innerException, bool doThrow);
}
public class Amazon.Runtime.CredentialManagement.CredentialProfile : object {
    private Dictionary`2<string, string> _properties;
    private Dictionary`2<string, Dictionary`2<string, string>> _nestedProperties;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialProfileOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private RegionEndpoint <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <UniqueKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultConfigurationModeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EndpointDiscoveryEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <S3UseArnRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <S3DisableExpressSessionAuth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <S3DisableMultiRegionAccessPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<S3UsEast1RegionalEndpointValue> <S3RegionalEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RequestRetryMode> <RetryMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EC2MetadataServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<EC2MetadataServiceEndpointMode> <EC2MetadataServiceEndpointMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EC2MetadataV1Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseDualstackEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseFIPSEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IgnoreConfiguredEndpointUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DisableRequestCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RequestMinCompressionSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientAppId>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentialProfileStore <CredentialProfileStore>k__BackingField;
    internal Dictionary`2<string, Dictionary`2<string, string>> NestedProperties { get; internal set; }
    public string Name { get; private set; }
    public CredentialProfileOptions Options { get; private set; }
    public RegionEndpoint Region { get; public set; }
    internal Nullable`1<Guid> UniqueKey { get; internal set; }
    public string DefaultConfigurationModeName { get; public set; }
    public Nullable`1<bool> EndpointDiscoveryEnabled { get; public set; }
    public Nullable`1<bool> S3UseArnRegion { get; public set; }
    public Nullable`1<bool> S3DisableExpressSessionAuth { get; public set; }
    public Nullable`1<bool> S3DisableMultiRegionAccessPoints { get; public set; }
    public Nullable`1<S3UsEast1RegionalEndpointValue> S3RegionalEndpoint { get; public set; }
    public Nullable`1<RequestRetryMode> RetryMode { get; public set; }
    public Nullable`1<int> MaxAttempts { get; public set; }
    public string EC2MetadataServiceEndpoint { get; public set; }
    public Nullable`1<EC2MetadataServiceEndpointMode> EC2MetadataServiceEndpointMode { get; public set; }
    public Nullable`1<bool> EC2MetadataV1Disabled { get; public set; }
    public Nullable`1<bool> UseDualstackEndpoint { get; public set; }
    public Nullable`1<bool> UseFIPSEndpoint { get; public set; }
    public Nullable`1<bool> IgnoreConfiguredEndpointUrls { get; public set; }
    public string EndpointUrl { get; public set; }
    public Nullable`1<bool> DisableRequestCompression { get; public set; }
    public Nullable`1<long> RequestMinCompressionSizeBytes { get; public set; }
    public string ClientAppId { get; public set; }
    internal Dictionary`2<string, string> Properties { get; internal set; }
    public bool CanCreateAWSCredentials { get; }
    public ICredentialProfileStore CredentialProfileStore { get; internal set; }
    public string CredentialDescription { get; }
    internal Nullable`1<CredentialProfileType> ProfileType { get; }
    internal bool IsCallbackRequired { get; }
    public CredentialProfile(string name, CredentialProfileOptions profileOptions);
    internal Dictionary`2<string, Dictionary`2<string, string>> get_NestedProperties();
    internal void set_NestedProperties(Dictionary`2<string, Dictionary`2<string, string>> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public CredentialProfileOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(CredentialProfileOptions value);
    [CompilerGeneratedAttribute]
public RegionEndpoint get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(RegionEndpoint value);
    [CompilerGeneratedAttribute]
internal Nullable`1<Guid> get_UniqueKey();
    [CompilerGeneratedAttribute]
internal void set_UniqueKey(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public string get_DefaultConfigurationModeName();
    [CompilerGeneratedAttribute]
public void set_DefaultConfigurationModeName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EndpointDiscoveryEnabled();
    [CompilerGeneratedAttribute]
public void set_EndpointDiscoveryEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_S3UseArnRegion();
    [CompilerGeneratedAttribute]
public void set_S3UseArnRegion(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_S3DisableExpressSessionAuth();
    [CompilerGeneratedAttribute]
public void set_S3DisableExpressSessionAuth(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_S3DisableMultiRegionAccessPoints();
    [CompilerGeneratedAttribute]
public void set_S3DisableMultiRegionAccessPoints(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<S3UsEast1RegionalEndpointValue> get_S3RegionalEndpoint();
    [CompilerGeneratedAttribute]
public void set_S3RegionalEndpoint(Nullable`1<S3UsEast1RegionalEndpointValue> value);
    [CompilerGeneratedAttribute]
public Nullable`1<RequestRetryMode> get_RetryMode();
    [CompilerGeneratedAttribute]
public void set_RetryMode(Nullable`1<RequestRetryMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxAttempts();
    [CompilerGeneratedAttribute]
public void set_MaxAttempts(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_EC2MetadataServiceEndpoint();
    [CompilerGeneratedAttribute]
public void set_EC2MetadataServiceEndpoint(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<EC2MetadataServiceEndpointMode> get_EC2MetadataServiceEndpointMode();
    [CompilerGeneratedAttribute]
public void set_EC2MetadataServiceEndpointMode(Nullable`1<EC2MetadataServiceEndpointMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EC2MetadataV1Disabled();
    [CompilerGeneratedAttribute]
public void set_EC2MetadataV1Disabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseDualstackEndpoint();
    [CompilerGeneratedAttribute]
public void set_UseDualstackEndpoint(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseFIPSEndpoint();
    [CompilerGeneratedAttribute]
public void set_UseFIPSEndpoint(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IgnoreConfiguredEndpointUrls();
    [CompilerGeneratedAttribute]
public void set_IgnoreConfiguredEndpointUrls(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_EndpointUrl();
    [CompilerGeneratedAttribute]
public void set_EndpointUrl(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DisableRequestCompression();
    [CompilerGeneratedAttribute]
public void set_DisableRequestCompression(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RequestMinCompressionSizeBytes();
    [CompilerGeneratedAttribute]
public void set_RequestMinCompressionSizeBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_ClientAppId();
    [CompilerGeneratedAttribute]
public void set_ClientAppId(string value);
    internal Dictionary`2<string, string> get_Properties();
    internal void set_Properties(Dictionary`2<string, string> value);
    public bool get_CanCreateAWSCredentials();
    [CompilerGeneratedAttribute]
public ICredentialProfileStore get_CredentialProfileStore();
    [CompilerGeneratedAttribute]
internal void set_CredentialProfileStore(ICredentialProfileStore value);
    public string get_CredentialDescription();
    internal Nullable`1<CredentialProfileType> get_ProfileType();
    internal bool get_IsCallbackRequired();
    public AWSCredentials GetAWSCredentials(ICredentialProfileSource profileSource);
    internal AWSCredentials GetAWSCredentials(ICredentialProfileSource profileSource, bool nonCallbackOnly);
    private string GetPropertiesString();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Amazon.Runtime.CredentialManagement.CredentialProfileOptions : object {
    [CompilerGeneratedAttribute]
private string <AccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CredentialSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExternalID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MfaSerial>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleArn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleSessionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecretKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CredentialProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebIdentityTokenFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndpointUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SsoAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SsoRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SsoRegistrationScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SsoRoleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SsoSession>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SsoStartUrl>k__BackingField;
    public string AccessKey { get; public set; }
    public string CredentialSource { get; public set; }
    public string EndpointName { get; public set; }
    public string ExternalID { get; public set; }
    public string MfaSerial { get; public set; }
    public string RoleArn { get; public set; }
    public string RoleSessionName { get; public set; }
    public string SecretKey { get; public set; }
    public string SourceProfile { get; public set; }
    public string Token { get; public set; }
    public string UserIdentity { get; public set; }
    public string CredentialProcess { get; public set; }
    public string WebIdentityTokenFile { get; public set; }
    public string Services { get; public set; }
    public string EndpointUrl { get; public set; }
    public string SsoAccountId { get; public set; }
    public string SsoRegion { get; public set; }
    public string SsoRegistrationScopes { get; public set; }
    public string SsoRoleName { get; public set; }
    public string SsoSession { get; public set; }
    public string SsoStartUrl { get; public set; }
    internal bool IsEmpty { get; }
    [CompilerGeneratedAttribute]
public string get_AccessKey();
    [CompilerGeneratedAttribute]
public void set_AccessKey(string value);
    [CompilerGeneratedAttribute]
public string get_CredentialSource();
    [CompilerGeneratedAttribute]
public void set_CredentialSource(string value);
    [CompilerGeneratedAttribute]
public string get_EndpointName();
    [CompilerGeneratedAttribute]
public void set_EndpointName(string value);
    [CompilerGeneratedAttribute]
public string get_ExternalID();
    [CompilerGeneratedAttribute]
public void set_ExternalID(string value);
    [CompilerGeneratedAttribute]
public string get_MfaSerial();
    [CompilerGeneratedAttribute]
public void set_MfaSerial(string value);
    [CompilerGeneratedAttribute]
public string get_RoleArn();
    [CompilerGeneratedAttribute]
public void set_RoleArn(string value);
    [CompilerGeneratedAttribute]
public string get_RoleSessionName();
    [CompilerGeneratedAttribute]
public void set_RoleSessionName(string value);
    [CompilerGeneratedAttribute]
public string get_SecretKey();
    [CompilerGeneratedAttribute]
public void set_SecretKey(string value);
    [CompilerGeneratedAttribute]
public string get_SourceProfile();
    [CompilerGeneratedAttribute]
public void set_SourceProfile(string value);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
    [CompilerGeneratedAttribute]
public string get_UserIdentity();
    [CompilerGeneratedAttribute]
public void set_UserIdentity(string value);
    [CompilerGeneratedAttribute]
public string get_CredentialProcess();
    [CompilerGeneratedAttribute]
public void set_CredentialProcess(string value);
    [CompilerGeneratedAttribute]
public string get_WebIdentityTokenFile();
    [CompilerGeneratedAttribute]
public void set_WebIdentityTokenFile(string value);
    [CompilerGeneratedAttribute]
public string get_Services();
    [CompilerGeneratedAttribute]
public void set_Services(string value);
    [CompilerGeneratedAttribute]
public string get_EndpointUrl();
    [CompilerGeneratedAttribute]
public void set_EndpointUrl(string value);
    [CompilerGeneratedAttribute]
public string get_SsoAccountId();
    [CompilerGeneratedAttribute]
public void set_SsoAccountId(string value);
    [CompilerGeneratedAttribute]
public string get_SsoRegion();
    [CompilerGeneratedAttribute]
public void set_SsoRegion(string value);
    [CompilerGeneratedAttribute]
public string get_SsoRegistrationScopes();
    [CompilerGeneratedAttribute]
public void set_SsoRegistrationScopes(string value);
    [CompilerGeneratedAttribute]
public string get_SsoRoleName();
    [CompilerGeneratedAttribute]
public void set_SsoRoleName(string value);
    [CompilerGeneratedAttribute]
public string get_SsoSession();
    [CompilerGeneratedAttribute]
public void set_SsoSession(string value);
    [CompilerGeneratedAttribute]
public string get_SsoStartUrl();
    [CompilerGeneratedAttribute]
public void set_SsoStartUrl(string value);
    internal bool get_IsEmpty();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Amazon.Runtime.CredentialManagement.CredentialProfileStoreChain : object {
    [CompilerGeneratedAttribute]
private string <ProfilesLocation>k__BackingField;
    public string ProfilesLocation { get; private set; }
    public CredentialProfileStoreChain(string profilesLocation);
    [CompilerGeneratedAttribute]
public string get_ProfilesLocation();
    [CompilerGeneratedAttribute]
private void set_ProfilesLocation(string value);
    public bool TryGetAWSCredentials(string profileName, AWSCredentials& credentials);
    public sealed virtual bool TryGetProfile(string profileName, CredentialProfile& profile);
    public List`1<CredentialProfile> ListProfiles();
    public void RegisterProfile(CredentialProfile profile);
    public void UnregisterProfile(string profileName);
}
public interface Amazon.Runtime.CredentialManagement.ICredentialProfileSource {
    public abstract virtual bool TryGetProfile(string profileName, CredentialProfile& profile);
}
public interface Amazon.Runtime.CredentialManagement.ICredentialProfileStore {
    public abstract virtual void RenameProfile(string oldProfileName, string newProfileName);
    public abstract virtual void RenameProfile(string oldProfileName, string newProfileName, bool force);
    public abstract virtual void CopyProfile(string fromProfileName, string toProfileName);
    public abstract virtual void CopyProfile(string fromProfileName, string toProfileName, bool force);
    public abstract virtual void RegisterProfile(CredentialProfile profile);
    public abstract virtual void UnregisterProfile(string profileName);
    public abstract virtual List`1<string> ListProfileNames();
    public abstract virtual List`1<CredentialProfile> ListProfiles();
}
public class Amazon.Runtime.CredentialManagement.Internal.CredentialProfilePropertyMapping : object {
    private static HashSet`1<string> TypePropertySet;
    private static PropertyInfo[] CredentialProfileReflectionProperties;
    private Dictionary`2<string, string> _nameMapping;
    private HashSet`1<string> _mappedNames;
    public CredentialProfilePropertyMapping(Dictionary`2<string, string> nameMapping);
    private static CredentialProfilePropertyMapping();
    public void ExtractProfileParts(Dictionary`2<string, string> profileDictionary, HashSet`1<string> reservedKeys, CredentialProfileOptions& profileOptions, Dictionary`2& userProperties);
    public void ExtractProfileParts(Dictionary`2<string, string> profileDictionary, HashSet`1<string> reservedKeys, CredentialProfileOptions& profileOptions, Dictionary`2& reservedProperties, Dictionary`2& userProperties);
    public Dictionary`2<string, string> CombineProfileParts(CredentialProfileOptions profileOptions, HashSet`1<string> reservedPropertyNames, Dictionary`2<string, string> reservedProperties, Dictionary`2<string, string> userProperties);
    private static void ValidateNoReservedProperties(HashSet`1<string> reservedPropertyNames, Dictionary`2<string, string> userProperties);
    private void ValidateNoProfileOptionsProperties(Dictionary`2<string, string> userProperties);
    private Dictionary`2<string, string> Convert(CredentialProfileOptions profileOptions);
}
public enum Amazon.Runtime.CredentialManagement.Internal.CredentialProfileType : Enum {
    public int value__;
    public static CredentialProfileType AssumeRole;
    public static CredentialProfileType AssumeRoleCredentialSource;
    public static CredentialProfileType AssumeRoleExternal;
    public static CredentialProfileType AssumeRoleExternalMFA;
    public static CredentialProfileType AssumeRoleMFA;
    public static CredentialProfileType Basic;
    public static CredentialProfileType SAMLRole;
    public static CredentialProfileType SAMLRoleUserIdentity;
    public static CredentialProfileType Session;
    public static CredentialProfileType CredentialProcess;
    public static CredentialProfileType AssumeRoleWithWebIdentity;
    public static CredentialProfileType AssumeRoleWithWebIdentitySessionName;
    public static CredentialProfileType AssumeRoleSessionName;
    public static CredentialProfileType AssumeRoleCredentialSourceSessionName;
    public static CredentialProfileType AssumeRoleExternalSessionName;
    public static CredentialProfileType AssumeRoleExternalMFASessionName;
    public static CredentialProfileType AssumeRoleMFASessionName;
    public static CredentialProfileType SSO;
    public static CredentialProfileType AssumeRoleWithServices;
    public static CredentialProfileType AssumeRoleWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleCredentialSourceWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleCredentialSourceWithServices;
    public static CredentialProfileType AssumeRoleCredentialSourceWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleExternalWithServices;
    public static CredentialProfileType AssumeRoleExternalWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleExternalWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleExternalMFAWithServices;
    public static CredentialProfileType AssumeRoleExternalMFAWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleExternalMFAWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleMFAWithServices;
    public static CredentialProfileType AssumeRoleMFAWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleMFAWithServicesAndGlobalEndpoint;
    public static CredentialProfileType BasicWithServices;
    public static CredentialProfileType BasicWithGlobalEndpoint;
    public static CredentialProfileType BasicWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleWithWebIdentityWithServices;
    public static CredentialProfileType AssumeRoleWithWebIdentityWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleWithWebIdentityWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleWithWebIdentitySessionNameWithServices;
    public static CredentialProfileType AssumeRoleWithWebIdentitySessionNameWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleWithWebIdentitySessionNameWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleSessionNameWithServices;
    public static CredentialProfileType AssumeRoleSessionNameWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleSessionNameWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleCredentialSourceSessionNameWithServices;
    public static CredentialProfileType AssumeRoleCredentialSourceSessionNameWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleCredentialSourceSessionNameWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleExternalSessionNameWithServices;
    public static CredentialProfileType AssumeRoleExternalSessionNameWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleExternalSessionNameWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleExternalMFASessionNameWithServices;
    public static CredentialProfileType AssumeRoleExternalMFASessionNameWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleExternalMFASessionNameWithServicesAndGlobalEndpoint;
    public static CredentialProfileType AssumeRoleMFASessionNameWithServices;
    public static CredentialProfileType AssumeRoleMFASessionNameWithGlobalEndpoint;
    public static CredentialProfileType AssumeRoleMFASessionNameWithServicesAndGlobalEndpoint;
    public static CredentialProfileType SAMLRoleWithServices;
    public static CredentialProfileType SAMLRoleWithGlobalEndpoint;
    public static CredentialProfileType SAMLRoleWithServicesAndGlobalEndpoint;
    public static CredentialProfileType SAMLRoleUserIdentityWithServices;
    public static CredentialProfileType SAMLRoleUserIdentityWithGlobalEndpoint;
    public static CredentialProfileType SAMLRoleUserIdentityWithServicesAndGlobalEndpoint;
    public static CredentialProfileType SessionWithServices;
    public static CredentialProfileType SessionWithGlobalEndpoint;
    public static CredentialProfileType SessionWithServicesAndGlobalEndpoint;
}
public static class Amazon.Runtime.CredentialManagement.Internal.CredentialProfileTypeDetector : object {
    private static string BasicCredentials;
    private static string SessionCredentials;
    private static string AssumeRoleCredentials;
    private static string AssumeRoleWithWebIdentityCredentials;
    private static string SAMLCredentials;
    private static string Services;
    private static string AccessKey;
    private static string CredentialSource;
    private static string EndpointName;
    private static string ExternalID;
    private static string MfaSerial;
    private static string RoleArn;
    private static string RoleSessionName;
    private static string SecretKey;
    private static string SourceProfile;
    private static string Token;
    private static string WebIdentityTokenFile;
    private static string UserIdentity;
    private static string CredentialProcess;
    private static string EndpointUrl;
    private static string SsoAccountId;
    private static string SsoRegion;
    private static string SsoRegistrationScopes;
    private static string SsoRoleName;
    private static string SsoStartUrl;
    private static string SsoSession;
    private static HashSet`1<string> SsoProperties;
    private static Dictionary`2<CredentialProfileType, HashSet`1<string>> TypePropertyDictionary;
    private static Dictionary`2<CredentialProfileType, string> CredentialTypeDictionary;
    private static CredentialProfileTypeDetector();
    public static string GetUserFriendlyCredentialType(Nullable`1<CredentialProfileType> profileType);
    public static Nullable`1<CredentialProfileType> DetectProfileType(CredentialProfileOptions profileOptions);
    public static HashSet`1<string> GetPropertiesForProfileType(CredentialProfileType profileType);
    private static HashSet`1<string> GetPropertyNames(CredentialProfileOptions profileOptions);
}
public static class Amazon.Runtime.CredentialManagement.Internal.CredentialProfileUtils : object {
    public static Dictionary`2<string, string> GetProperties(CredentialProfile profile);
    public static void SetProperty(CredentialProfile profile, string key, string value);
    public static string GetProperty(CredentialProfile profile, string key);
    public static Guid EnsureUniqueKeyAssigned(CredentialProfile profile, ICredentialProfileStore profileStore);
    public static string GetUniqueKey(CredentialProfile profile);
    public static void SetUniqueKey(CredentialProfile profile, Nullable`1<Guid> uniqueKey);
    public static Nullable`1<CredentialProfileType> GetProfileType(CredentialProfile profile);
    public static bool IsCallbackRequired(CredentialProfile profile);
}
public enum Amazon.Runtime.CredentialManagement.Internal.CredentialSourceType : Enum {
    public int value__;
    public static CredentialSourceType Ec2InstanceMetadata;
    public static CredentialSourceType Environment;
    public static CredentialSourceType EcsContainer;
}
public class Amazon.Runtime.CredentialManagement.Internal.SAMLRoleSessionManager : object {
    private SettingsManager settingsManager;
    public static bool IsAvailable { get; }
    public static bool get_IsAvailable();
    public void Clear();
    public bool TryGetRoleSession(string roleSessionName, SAMLImmutableCredentials& credentials);
    public void RegisterRoleSession(string roleSessionName, SAMLImmutableCredentials credentials);
    public void UnregisterRoleSession(string roleSessionName);
}
public class Amazon.Runtime.CredentialManagement.NetSDKCredentialsFile : object {
    public static string DefaultProfileName;
    private static string AWSCredentialsProfileType;
    private static string SAMLRoleProfileType;
    private static string DefaultConfigurationModeNameField;
    private static string RegionField;
    private static string EndpointDiscoveryEnabledField;
    private static string S3UseArnRegionField;
    private static string S3DisableExpressSessionAuthField;
    private static string S3RegionalEndpointField;
    private static string S3DisableMultiRegionAccessPointsField;
    private static string RetryModeField;
    private static string MaxAttemptsField;
    private static string SsoAccountId;
    private static string SsoRegion;
    private static string SsoRegistrationScopes;
    private static string SsoRoleName;
    private static string SsoStartUrl;
    private static string SsoSession;
    private static string EndpointUrlField;
    private static string ServicesField;
    private static string IgnoreConfiguredEndpointUrlsField;
    private static HashSet`1<string> ReservedPropertyNames;
    private static CredentialProfilePropertyMapping PropertyMapping;
    private NamedSettingsManager _settingsManager;
    private static NetSDKCredentialsFile();
    public sealed virtual List`1<string> ListProfileNames();
    public sealed virtual List`1<CredentialProfile> ListProfiles();
    public sealed virtual bool TryGetProfile(string profileName, CredentialProfile& profile);
    public sealed virtual void RegisterProfile(CredentialProfile profile);
    public sealed virtual void UnregisterProfile(string profileName);
    public sealed virtual void RenameProfile(string oldProfileName, string newProfileName);
    public sealed virtual void RenameProfile(string oldProfileName, string newProfileName, bool force);
    public sealed virtual void CopyProfile(string fromProfileName, string toProfileName);
    public sealed virtual void CopyProfile(string fromProfileName, string toProfileName, bool force);
    private static void SetProfileTypeField(IDictionary`2<string, string> properties, CredentialProfileType profileType);
}
public enum Amazon.Runtime.CredentialManagement.SAMLAuthenticationType : Enum {
    public int value__;
    public static SAMLAuthenticationType NTLM;
    public static SAMLAuthenticationType Digest;
    public static SAMLAuthenticationType Kerberos;
    public static SAMLAuthenticationType Negotiate;
}
public class Amazon.Runtime.CredentialManagement.SAMLEndpoint : object {
    private SAMLAuthenticationType DefaultAuthenticationType;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <EndpointUri>k__BackingField;
    [CompilerGeneratedAttribute]
private SAMLAuthenticationType <AuthenticationType>k__BackingField;
    public string Name { get; private set; }
    public Uri EndpointUri { get; private set; }
    public SAMLAuthenticationType AuthenticationType { get; private set; }
    internal SAMLEndpoint(string name, string endpointUri, string authenticationType);
    public SAMLEndpoint(string name, Uri endpointUri);
    public SAMLEndpoint(string name, Uri endpointUri, SAMLAuthenticationType authenticationType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Uri get_EndpointUri();
    [CompilerGeneratedAttribute]
private void set_EndpointUri(Uri value);
    [CompilerGeneratedAttribute]
public SAMLAuthenticationType get_AuthenticationType();
    [CompilerGeneratedAttribute]
private void set_AuthenticationType(SAMLAuthenticationType value);
    private void SetProperties(string name, Uri endpointUri, SAMLAuthenticationType authenticationType);
}
public class Amazon.Runtime.CredentialManagement.SAMLEndpointManager : object {
    private NamedSettingsManager settingsManager;
    public static bool IsAvailable { get; }
    public static bool get_IsAvailable();
    public void RegisterEndpoint(SAMLEndpoint samlEndpoint);
    public bool TryGetEndpoint(string endpointName, SAMLEndpoint& samlEndpoint);
    public SAMLEndpoint GetEndpoint(string endpointName);
    public void UnregisterEndpoint(string endpointName);
    public List`1<string> ListEndpointNames();
    public List`1<SAMLEndpoint> ListEndpoints();
}
public class Amazon.Runtime.CredentialManagement.SharedCredentialsFile : object {
    public static string DefaultProfileName;
    public static string SharedCredentialsFileEnvVar;
    public static string SharedConfigFileEnvVar;
    private static string ToolkitArtifactGuidField;
    private static string RegionField;
    private static string EndpointDiscoveryEnabledField;
    private static string ConfigFileName;
    private static string DefaultDirectoryName;
    private static string DefaultFileName;
    private static string DefaultConfigurationModeField;
    private static string CredentialProcess;
    private static string S3UseArnRegionField;
    private static string S3DisableExpressSessionAuthField;
    private static string S3RegionalEndpointField;
    private static string S3DisableMultiRegionAccessPointsField;
    private static string RetryModeField;
    private static string MaxAttemptsField;
    private static string SsoAccountId;
    private static string SsoRegion;
    private static string SsoRegistrationScopes;
    private static string SsoRoleName;
    private static string SsoStartUrl;
    private static string SsoSession;
    private static string EC2MetadataServiceEndpointField;
    private static string EC2MetadataServiceEndpointModeField;
    private static string EC2MetadataV1DisabledField;
    private static string UseDualstackEndpointField;
    private static string UseFIPSEndpointField;
    private static string EndpointUrlField;
    private static string ServicesField;
    private static string IgnoreConfiguredEndpointUrlsField;
    private static string DisableRequestCompressionField;
    private static string RequestMinCompressionSizeBytesField;
    private static string ClientAppIdField;
    private Logger _logger;
    private static HashSet`1<string> ReservedPropertyNames;
    private static HashSet`1<CredentialProfileType> ProfileTypeWhitelist;
    private static CredentialProfilePropertyMapping PropertyMapping;
    public static string DefaultDirectory;
    [CompilerGeneratedAttribute]
private static string <DefaultFilePath>k__BackingField;
    public static string DefaultConfigDirectory;
    [CompilerGeneratedAttribute]
private static string <DefaultConfigFilePath>k__BackingField;
    private ProfileIniFile _credentialsFile;
    private ProfileIniFile _configFile;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFilePath>k__BackingField;
    public static string DefaultFilePath { get; private set; }
    public static string DefaultConfigFilePath { get; private set; }
    public string FilePath { get; private set; }
    public string ConfigFilePath { get; private set; }
    private static SharedCredentialsFile();
    public SharedCredentialsFile(string filePath);
    [CompilerGeneratedAttribute]
public static string get_DefaultFilePath();
    [CompilerGeneratedAttribute]
private static void set_DefaultFilePath(string value);
    [CompilerGeneratedAttribute]
public static string get_DefaultConfigFilePath();
    [CompilerGeneratedAttribute]
private static void set_DefaultConfigFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigFilePath();
    [CompilerGeneratedAttribute]
private void set_ConfigFilePath(string value);
    private void SetUpFilePath(string filePath);
    public sealed virtual List`1<string> ListProfileNames();
    public sealed virtual List`1<CredentialProfile> ListProfiles();
    public sealed virtual bool TryGetProfile(string profileName, CredentialProfile& profile);
    public sealed virtual void RegisterProfile(CredentialProfile profile);
    private void RegisterProfileInternal(CredentialProfile profile);
    private void UpdateConfigSectionsFromProfile(CredentialProfile profile, Dictionary`2<string, string> profileDictionary);
    public sealed virtual void UnregisterProfile(string profileName);
    public sealed virtual void RenameProfile(string oldProfileName, string newProfileName);
    public sealed virtual void RenameProfile(string oldProfileName, string newProfileName, bool force);
    public sealed virtual void CopyProfile(string fromProfileName, string toProfileName);
    public sealed virtual void CopyProfile(string fromProfileName, string toProfileName, bool force);
    private void Refresh();
    private HashSet`1<string> ListAllProfileNames();
    private bool TryGetProfile(string profileName, bool doRefresh, bool isSsoSession, bool isServicesSection, CredentialProfile& profile);
    private bool TryGetSection(string sectionName, bool isSsoSession, bool isServicesSection, Dictionary`2& iniProperties, Dictionary`2& nestedProperties);
    private static bool IsSupportedProfileType(Nullable`1<CredentialProfileType> profileType);
}
public class Amazon.Runtime.CredentialRequestCallbackArgs : object {
    [CompilerGeneratedAttribute]
private string <ProfileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CustomState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreviousAuthenticationFailed>k__BackingField;
    public string ProfileName { get; internal set; }
    public string UserIdentity { get; internal set; }
    public object CustomState { get; internal set; }
    public bool PreviousAuthenticationFailed { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_ProfileName();
    [CompilerGeneratedAttribute]
internal void set_ProfileName(string value);
    [CompilerGeneratedAttribute]
public string get_UserIdentity();
    [CompilerGeneratedAttribute]
internal void set_UserIdentity(string value);
    [CompilerGeneratedAttribute]
public object get_CustomState();
    [CompilerGeneratedAttribute]
internal void set_CustomState(object value);
    [CompilerGeneratedAttribute]
public bool get_PreviousAuthenticationFailed();
    [CompilerGeneratedAttribute]
internal void set_PreviousAuthenticationFailed(bool value);
}
public interface Amazon.Runtime.Credentials.Internal.ISSOTokenFileCache {
    public abstract virtual bool Exists(CredentialProfileOptions options);
    public abstract virtual bool TryGetSsoToken(SSOTokenManagerGetTokenOptions getSsoTokenOptions, string ssoCacheDirectory, SsoToken& ssoToken);
    public abstract virtual void SaveSsoToken(SsoToken token, string ssoCacheDirectory);
    public abstract virtual void DeleteSsoToken(SSOTokenManagerGetTokenOptions getSsoTokenOptions, string ssoCacheDirectory);
    public abstract virtual void DeleteSsoToken(string filePath);
    public abstract virtual List`1<SSOTokenFile> ScanSsoTokens(string ssoCacheDirectory);
    public abstract virtual Task`1<TryResponse`1<SsoToken>> TryGetSsoTokenAsync(SSOTokenManagerGetTokenOptions getSsoTokenOptions, string ssoCacheDirectory, CancellationToken cancellationToken);
    public abstract virtual Task SaveSsoTokenAsync(SsoToken token, string ssoCacheDirectory, CancellationToken cancellationToken);
    public abstract virtual Task`1<List`1<SSOTokenFile>> ScanSsoTokensAsync(string ssoCacheDirectory, CancellationToken cancellationToken);
}
public interface Amazon.Runtime.Credentials.Internal.ISSOTokenManager {
    public abstract virtual Task`1<SsoToken> GetTokenAsync(SSOTokenManagerGetTokenOptions options, CancellationToken cancellationToken);
    public abstract virtual Task LogoutAsync(string ssoCacheDirectory, CancellationToken cancellationToken);
    public abstract virtual Task LogoutAsync(SSOTokenManagerGetTokenOptions options, CancellationToken cancellationToken);
}
public class Amazon.Runtime.Credentials.Internal.SsoToken : object {
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpiresAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientSecret>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegistrationExpiresAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Session>k__BackingField;
    public string AccessToken { get; public set; }
    public DateTime ExpiresAt { get; public set; }
    public string RefreshToken { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public string RegistrationExpiresAt { get; public set; }
    public string Region { get; public set; }
    public string StartUrl { get; public set; }
    public string Session { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public DateTime get_ExpiresAt();
    [CompilerGeneratedAttribute]
public void set_ExpiresAt(DateTime value);
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
    [CompilerGeneratedAttribute]
public void set_RefreshToken(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_ClientSecret();
    [CompilerGeneratedAttribute]
public void set_ClientSecret(string value);
    [CompilerGeneratedAttribute]
public string get_RegistrationExpiresAt();
    [CompilerGeneratedAttribute]
public void set_RegistrationExpiresAt(string value);
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(string value);
    [CompilerGeneratedAttribute]
public string get_StartUrl();
    [CompilerGeneratedAttribute]
public void set_StartUrl(string value);
    [CompilerGeneratedAttribute]
public string get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(string value);
}
public class Amazon.Runtime.Credentials.Internal.SSOTokenFile : object {
    [CompilerGeneratedAttribute]
private SsoToken <SsoToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SsoTokenFilePath>k__BackingField;
    public SsoToken SsoToken { get; public set; }
    public string SsoTokenFilePath { get; public set; }
    [CompilerGeneratedAttribute]
public SsoToken get_SsoToken();
    [CompilerGeneratedAttribute]
public void set_SsoToken(SsoToken value);
    [CompilerGeneratedAttribute]
public string get_SsoTokenFilePath();
    [CompilerGeneratedAttribute]
public void set_SsoTokenFilePath(string value);
}
public class Amazon.Runtime.Credentials.Internal.SSOTokenFileCache : object {
    private Logger _logger;
    private ICryptoUtil _cryptoUtil;
    private IFile _file;
    private IDirectory _directory;
    private string _defaultSSOCacheDirectory;
    public SSOTokenFileCache(ICryptoUtil cryptoUtil, IFile file, IDirectory directory);
    public sealed virtual bool Exists(CredentialProfileOptions options);
    public sealed virtual bool TryGetSsoToken(SSOTokenManagerGetTokenOptions getSsoTokenOptions, string ssoCacheDirectory, SsoToken& ssoToken);
    [AsyncStateMachineAttribute("Amazon.Runtime.Credentials.Internal.SSOTokenFileCache/<TryGetSsoTokenAsync>d__8")]
public sealed virtual Task`1<TryResponse`1<SsoToken>> TryGetSsoTokenAsync(SSOTokenManagerGetTokenOptions getSsoTokenOptions, string ssoCacheDirectory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Amazon.Runtime.Credentials.Internal.SSOTokenFileCache/<ScanSsoTokensAsync>d__9")]
public sealed virtual Task`1<List`1<SSOTokenFile>> ScanSsoTokensAsync(string ssoCacheDirectory, CancellationToken cancellationToken);
    public sealed virtual void SaveSsoToken(SsoToken token, string ssoCacheDirectory);
    [AsyncStateMachineAttribute("Amazon.Runtime.Credentials.Internal.SSOTokenFileCache/<SaveSsoTokenAsync>d__11")]
public sealed virtual Task SaveSsoTokenAsync(SsoToken token, string ssoCacheDirectory, CancellationToken cancellationToken);
    public sealed virtual void DeleteSsoToken(SSOTokenManagerGetTokenOptions getSsoTokenOptions, string ssoCacheDirectory);
    public sealed virtual void DeleteSsoToken(string filePath);
    private string BuildCacheFileFullPath(SsoToken token, string ssoCacheDirectory);
    private string BuildCacheFileFullPath(SSOTokenManagerGetTokenOptions getSsoTokenOptions, string ssoCacheDirectory);
    private string BuildCacheFileFullPath(string startUrl, string session, string ssoCacheDirectory);
    private string GetCacheFilename(string startUrl, string session);
    private string GenerateSha1Hash(string text);
    public sealed virtual List`1<SSOTokenFile> ScanSsoTokens(string ssoCacheDirectory);
}
public class Amazon.Runtime.Credentials.Internal.SSOTokenManager : object {
    private ILogger _logger;
    private ICoreAmazonSSOOIDC _ssooidcClient;
    private ISSOTokenFileCache _ssoTokenFileCache;
    private InMemoryCache _inMemoryCache;
    public SSOTokenManager(ICoreAmazonSSOOIDC ssooidcClient, ISSOTokenFileCache ssoTokenFileCache);
    protected virtual ICoreAmazonSSO_Logout CreateSSOLogoutClient(string region, IWebProxy proxySettings);
    protected virtual ICoreAmazonSSOOIDC_V2 CreateSSOOIDC_V2Client(string region, IWebProxy proxySettings);
    [AsyncStateMachineAttribute("Amazon.Runtime.Credentials.Internal.SSOTokenManager/<GetTokenAsync>d__10")]
public sealed virtual Task`1<SsoToken> GetTokenAsync(SSOTokenManagerGetTokenOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Amazon.Runtime.Credentials.Internal.SSOTokenManager/<LogoutAsync>d__11")]
public sealed virtual Task LogoutAsync(string ssoCacheDirectory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Amazon.Runtime.Credentials.Internal.SSOTokenManager/<LogoutAsync>d__12")]
public sealed virtual Task LogoutAsync(SSOTokenManagerGetTokenOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Amazon.Runtime.Credentials.Internal.SSOTokenManager/<GenerateNewTokenAsync>d__13")]
private Task`1<SsoToken> GenerateNewTokenAsync(SSOTokenManagerGetTokenOptions options, CancellationToken cancellationToken);
    private static SsoToken MapGetSsoTokenResponseToSsoToken(GetSsoTokenResponse response, string session);
    private static GetSsoTokenResponse MapSsoTokenToGetSsoTokenResponse(SsoToken token);
    private static string GetSsoClientName(string clientName);
}
public class Amazon.Runtime.Credentials.Internal.SSOTokenManagerGetTokenOptions : object {
    private static string SsoClientTypePublic;
    [CompilerGeneratedAttribute]
private string <StartUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFolderLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientType>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<SsoVerificationArguments> <SsoVerificationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private PkceFlowOptions <PkceFlowOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsGettingNewToken>k__BackingField;
    public string StartUrl { get; public set; }
    public string Session { get; public set; }
    public string Region { get; public set; }
    public string CacheFolderLocation { get; public set; }
    public string ClientName { get; public set; }
    public string ClientType { get; public set; }
    public IList`1<string> Scopes { get; public set; }
    public Action`1<SsoVerificationArguments> SsoVerificationCallback { get; public set; }
    public PkceFlowOptions PkceFlowOptions { get; public set; }
    public bool SupportsGettingNewToken { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StartUrl();
    [CompilerGeneratedAttribute]
public void set_StartUrl(string value);
    [CompilerGeneratedAttribute]
public string get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(string value);
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(string value);
    [CompilerGeneratedAttribute]
public string get_CacheFolderLocation();
    [CompilerGeneratedAttribute]
public void set_CacheFolderLocation(string value);
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    [CompilerGeneratedAttribute]
public string get_ClientType();
    [CompilerGeneratedAttribute]
public void set_ClientType(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public void set_Scopes(IList`1<string> value);
    [CompilerGeneratedAttribute]
public Action`1<SsoVerificationArguments> get_SsoVerificationCallback();
    [CompilerGeneratedAttribute]
public void set_SsoVerificationCallback(Action`1<SsoVerificationArguments> value);
    [CompilerGeneratedAttribute]
public PkceFlowOptions get_PkceFlowOptions();
    [CompilerGeneratedAttribute]
public void set_PkceFlowOptions(PkceFlowOptions value);
    [CompilerGeneratedAttribute]
public bool get_SupportsGettingNewToken();
    [CompilerGeneratedAttribute]
public void set_SupportsGettingNewToken(bool value);
}
[ExtensionAttribute]
public static class Amazon.Runtime.Credentials.Internal.SsoTokenUtils : object {
    [ExtensionAttribute]
public static bool IsExpired(SsoToken token);
    [ExtensionAttribute]
public static bool NeedsRefresh(SsoToken token);
    [ExtensionAttribute]
public static bool CanRefresh(SsoToken token);
    [ExtensionAttribute]
public static string AsJson(SsoToken token);
    [ExtensionAttribute]
public static bool RegisteredClientExpired(SsoToken token);
    public static string ToJson(SsoToken token);
    public static SsoToken FromJson(string json, bool throwIfTokenInvalid);
    public static SsoToken FromJson(string json);
    private static DateTime ConvertRFC3339StringToDateTime(string stringFormattedDate);
}
public class Amazon.Runtime.DefaultAWSTokenProviderChain : object {
    private Lazy`1<IAWSTokenProvider> _chain;
    [CompilerGeneratedAttribute]
private string <ProfileName>k__BackingField;
    public string ProfileName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProfileName();
    [CompilerGeneratedAttribute]
public void set_ProfileName(string value);
    [AsyncStateMachineAttribute("Amazon.Runtime.DefaultAWSTokenProviderChain/<TryResolveTokenAsync>d__6")]
public sealed virtual Task`1<TryResponse`1<AWSToken>> TryResolveTokenAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private IAWSTokenProvider <.ctor>b__1_0();
}
[DebuggerDisplayAttribute("{Name}")]
public class Amazon.Runtime.DefaultConfiguration : object {
    [CompilerGeneratedAttribute]
private DefaultConfigurationMode <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestRetryMode <RetryMode>k__BackingField;
    [CompilerGeneratedAttribute]
private S3UsEast1RegionalEndpointValue <S3UsEast1RegionalEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ConnectTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TlsNegotiationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TimeToFirstByteTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <HttpRequestTimeout>k__BackingField;
    public DefaultConfigurationMode Name { get; public set; }
    public RequestRetryMode RetryMode { get; public set; }
    public S3UsEast1RegionalEndpointValue S3UsEast1RegionalEndpoint { get; public set; }
    public Nullable`1<TimeSpan> ConnectTimeout { get; public set; }
    public Nullable`1<TimeSpan> TlsNegotiationTimeout { get; public set; }
    public Nullable`1<TimeSpan> TimeToFirstByteTimeout { get; public set; }
    public Nullable`1<TimeSpan> HttpRequestTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual DefaultConfigurationMode get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(DefaultConfigurationMode value);
    [CompilerGeneratedAttribute]
public sealed virtual RequestRetryMode get_RetryMode();
    [CompilerGeneratedAttribute]
public void set_RetryMode(RequestRetryMode value);
    [CompilerGeneratedAttribute]
public sealed virtual S3UsEast1RegionalEndpointValue get_S3UsEast1RegionalEndpoint();
    [CompilerGeneratedAttribute]
public void set_S3UsEast1RegionalEndpoint(S3UsEast1RegionalEndpointValue value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_ConnectTimeout();
    [CompilerGeneratedAttribute]
public void set_ConnectTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_TlsNegotiationTimeout();
    [CompilerGeneratedAttribute]
public void set_TlsNegotiationTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_TimeToFirstByteTimeout();
    [CompilerGeneratedAttribute]
public void set_TimeToFirstByteTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_HttpRequestTimeout();
    [CompilerGeneratedAttribute]
public void set_HttpRequestTimeout(Nullable`1<TimeSpan> value);
}
public enum Amazon.Runtime.DefaultConfigurationMode : Enum {
    public int value__;
    public static DefaultConfigurationMode Standard;
    public static DefaultConfigurationMode InRegion;
    public static DefaultConfigurationMode CrossRegion;
    public static DefaultConfigurationMode Mobile;
    public static DefaultConfigurationMode Auto;
}
internal class Amazon.Runtime.DefaultInstanceProfileAWSCredentials : AWSCredentials {
    private static object _instanceLock;
    private ReaderWriterLockSlim _credentialsLock;
    private Timer _credentialsRetrieverTimer;
    private CredentialsRefreshState _lastRetrievedCredentials;
    private Logger _logger;
    private static TimeSpan _neverTimespan;
    private static TimeSpan _refreshRate;
    private static string FailedToGetCredentialsMessage;
    private static TimeSpan _credentialsLockTimeout;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _imdsRefreshFailed;
    private static string _usingExpiredCredentialsFromIMDS;
    private static DefaultInstanceProfileAWSCredentials _instance;
    private bool _isDisposed;
    public static DefaultInstanceProfileAWSCredentials Instance { get; }
    private static DefaultInstanceProfileAWSCredentials();
    public static DefaultInstanceProfileAWSCredentials get_Instance();
    public virtual ImmutableCredentials GetCredentials();
    public virtual Task`1<ImmutableCredentials> GetCredentialsAsync();
    private void RenewCredentials(object unused);
    private static CredentialsRefreshState FetchCredentials();
    private static void CheckIsIMDSEnabled();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Amazon.Runtime.Documents.Document : ValueType {
    private bool _dataBool;
    private double _dataDouble;
    private int _dataInt;
    private long _dataLong;
    private string _dataString;
    private List`1<Document> _dataList;
    private Dictionary`2<string, Document> _dataDictionary;
    [CompilerGeneratedAttribute]
private DocumentType <Type>k__BackingField;
    public DocumentType Type { get; private set; }
    public Document(bool value);
    public Document(double value);
    public Document(int value);
    public Document(long value);
    public Document(string value);
    public Document(List`1<Document> values);
    public Document(Document[] values);
    public Document(Dictionary`2<string, Document> values);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DocumentType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(DocumentType value);
    public static Document op_Implicit(bool value);
    public static Document op_Implicit(double value);
    public static Document op_Implicit(int value);
    public static Document op_Implicit(long value);
    public static Document op_Implicit(string value);
    public static Document op_Implicit(Document[] values);
    public static Document op_Implicit(Dictionary`2<string, Document> values);
    public bool IsBool();
    public bool AsBool();
    public bool IsDictionary();
    public Dictionary`2<string, Document> AsDictionary();
    public bool IsDouble();
    public double AsDouble();
    public bool IsInt();
    public int AsInt();
    public bool IsList();
    public List`1<Document> AsList();
    public bool IsLong();
    public long AsLong();
    public bool IsNull();
    public bool IsString();
    public string AsString();
    private void AssertIsType(DocumentType type);
    public sealed virtual bool Equals(Document other);
    public bool Equals(Nullable`1<Document> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Document left, Document right);
    public static bool op_Inequality(Document left, Document right);
    private sealed virtual override IEnumerator`1<Document> System.Collections.Generic.IEnumerable<Amazon.Runtime.Documents.Document>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(Document document);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, Document>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,Amazon.Runtime.Documents.Document>>.GetEnumerator();
    public void Add(string key, Document value);
    public virtual string ToString();
    [RequiresUnreferencedCodeAttribute("FromObject is not currently supported for Native AOT compilation due unbounded reflection required.")]
public static Document FromObject(object o);
    [RequiresUnreferencedCodeAttribute("FromObject is not currently supported for Native AOT compilation due unbounded reflection required.")]
private static Document FromObject(IJsonWrapper jsonData);
    [RequiresUnreferencedCodeAttribute("FromObject is not currently supported for Native AOT compilation due unbounded reflection required.")]
private static void Copy(IDictionary source, Dictionary`2<string, Document> target);
}
public enum Amazon.Runtime.Documents.DocumentType : Enum {
    public int value__;
    public static DocumentType Null;
    public static DocumentType Bool;
    public static DocumentType Dictionary;
    public static DocumentType Double;
    public static DocumentType Int;
    public static DocumentType Long;
    public static DocumentType List;
    public static DocumentType String;
}
public class Amazon.Runtime.Documents.Internal.Transform.DocumentMarshaller : object {
    [CompilerGeneratedAttribute]
private static DocumentMarshaller <Instance>k__BackingField;
    public static DocumentMarshaller Instance { get; }
    private static DocumentMarshaller();
    [CompilerGeneratedAttribute]
public static DocumentMarshaller get_Instance();
    public void Write(JsonWriter writer, Document doc);
}
public class Amazon.Runtime.Documents.Internal.Transform.DocumentUnmarshaller : object {
    [CompilerGeneratedAttribute]
private static DocumentUnmarshaller <Instance>k__BackingField;
    public static DocumentUnmarshaller Instance { get; }
    private static DocumentUnmarshaller();
    [CompilerGeneratedAttribute]
public static DocumentUnmarshaller get_Instance();
    public sealed virtual Document Unmarshall(JsonUnmarshallerContext context);
    private sealed virtual override Document Amazon.Runtime.Internal.Transform.IUnmarshaller<Amazon.Runtime.Documents.Document,Amazon.Runtime.Internal.Transform.XmlUnmarshallerContext>.Unmarshall(XmlUnmarshallerContext input);
}
public class Amazon.Runtime.Documents.InvalidDocumentTypeConversionException : Exception {
    public InvalidDocumentTypeConversionException(DocumentType expected, DocumentType actual);
}
public class Amazon.Runtime.DoubleListParameterValue : ParameterValue {
    [CompilerGeneratedAttribute]
private List`1<double> <Value>k__BackingField;
    public List`1<double> Value { get; public set; }
    public DoubleListParameterValue(List`1<double> values);
    [CompilerGeneratedAttribute]
public List`1<double> get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(List`1<double> value);
}
public enum Amazon.Runtime.EC2MetadataServiceEndpointMode : Enum {
    public int value__;
    public static EC2MetadataServiceEndpointMode IPv4;
    public static EC2MetadataServiceEndpointMode IPv6;
}
[ObsoleteAttribute("ECSTaskCredentials only supports Amazon ECS, newer versions of the SDK use the GenericContainerCredentials provider (which also supports EKS Pod Identities)")]
public class Amazon.Runtime.ECSTaskCredentials : URIBasedRefreshingCredentialHelper {
    public static string ContainerCredentialsURIEnvVariable;
    public static string ContainerCredentialsFullURIEnvVariable;
    public static string ContainerCredentialsAuthorizationTokenEnvVariable;
    public static string EndpointAddress;
    private string Server;
    private static int MaxRetries;
    private IWebProxy Proxy;
    private Uri Uri { get; }
    public ECSTaskCredentials(IWebProxy proxy);
    private static ECSTaskCredentials();
    private Uri get_Uri();
    protected virtual CredentialsRefreshState GenerateNewCredentials();
    private static Dictionary`2<string, string> CreateAuthorizationHeader();
}
public class Amazon.Runtime.Endpoints.Endpoint : object {
    [CompilerGeneratedAttribute]
private string <URL>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertyBag <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IList`1<string>> <Headers>k__BackingField;
    public string URL { get; public set; }
    public IPropertyBag Attributes { get; public set; }
    public IDictionary`2<string, IList`1<string>> Headers { get; public set; }
    public Endpoint(string url);
    public Endpoint(string url, string attributesJson, string headersJson);
    [CompilerGeneratedAttribute]
public string get_URL();
    [CompilerGeneratedAttribute]
public void set_URL(string value);
    [CompilerGeneratedAttribute]
public IPropertyBag get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(IPropertyBag value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IList`1<string>> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(IDictionary`2<string, IList`1<string>> value);
}
public class Amazon.Runtime.Endpoints.EndpointParameters : PropertyBag {
}
public static class Amazon.Runtime.Endpoints.GlobalEndpoints : object {
    [CompilerGeneratedAttribute]
private static IGlobalEndpointProvider <Provider>k__BackingField;
    public static IGlobalEndpointProvider Provider { get; public set; }
    [CompilerGeneratedAttribute]
public static IGlobalEndpointProvider get_Provider();
    [CompilerGeneratedAttribute]
public static void set_Provider(IGlobalEndpointProvider value);
}
public interface Amazon.Runtime.Endpoints.IEndpointProvider {
    public abstract virtual Endpoint ResolveEndpoint(EndpointParameters parameters);
}
public interface Amazon.Runtime.Endpoints.IGlobalEndpointProvider {
    public abstract virtual Endpoint ResolveEndpoint(string serviceId, EndpointParameters parameters);
}
[DefaultMemberAttribute("Item")]
public interface Amazon.Runtime.Endpoints.IPropertyBag {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string propertyName);
    public abstract virtual void set_Item(string propertyName, object value);
}
[DefaultMemberAttribute("Item")]
public class Amazon.Runtime.Endpoints.PropertyBag : object {
    private Dictionary`2<string, object> properties;
    public object Item { get; public set; }
    public sealed virtual object get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, object value);
    internal static PropertyBag FromJsonData(JsonData jsonData);
    private static object NodeToValue(JsonData node);
}
public class Amazon.Runtime.Endpoints.ServiceOperationEndpointParameters : object {
    [CompilerGeneratedAttribute]
private AmazonWebServiceRequest <Request>k__BackingField;
    public AmazonWebServiceRequest Request { get; }
    public ServiceOperationEndpointParameters(AmazonWebServiceRequest request);
    [CompilerGeneratedAttribute]
public AmazonWebServiceRequest get_Request();
}
public class Amazon.Runtime.Endpoints.StaticEndpointProvider : object {
    private string _url;
    public StaticEndpointProvider(string url);
    public sealed virtual Endpoint ResolveEndpoint(EndpointParameters parameters);
}
[ObsoleteAttribute("This class has been deprecated in favor of EnvironmentVariableAWSConfiguration.")]
public class Amazon.Runtime.EnvironmentVariableAWSEndpointDiscoveryEnabled : object {
    public static string ENVIRONMENT_VARIABLE_AWS_ENABLE_ENDPOINT_DISCOVERY;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public bool Enabled { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
private void set_Enabled(bool value);
}
public class Amazon.Runtime.EnvironmentVariableAWSRegion : AWSRegion {
    public static string ENVIRONMENT_VARIABLE_REGION;
    public static string ENVIRONMENT_VARIABLE_DEFAULT_REGION;
}
public class Amazon.Runtime.EnvironmentVariablesAWSCredentials : AWSCredentials {
    public static string ENVIRONMENT_VARIABLE_ACCESSKEY;
    public static string ENVIRONMENT_VARIABLE_SECRETKEY;
    public static string ENVIRONMENT_VARIABLE_SESSION_TOKEN;
    public static string LEGACY_ENVIRONMENT_VARIABLE_SECRETKEY;
    private Logger logger;
    public ImmutableCredentials FetchCredentials();
    public virtual ImmutableCredentials GetCredentials();
}
public enum Amazon.Runtime.ErrorType : Enum {
    public int value__;
    public static ErrorType Sender;
    public static ErrorType Receiver;
    public static ErrorType Unknown;
}
public class Amazon.Runtime.EventStreams.EventStreamChecksumFailureException : Exception {
    public EventStreamChecksumFailureException(string message);
}
public class Amazon.Runtime.EventStreams.EventStreamErrorCodeException : EventStreamException {
    public int ErrorCode { get; private set; }
    public EventStreamErrorCodeException(int errorCode);
    public EventStreamErrorCodeException(int errorCode, string message);
    public int get_ErrorCode();
    private void set_ErrorCode(int value);
}
public class Amazon.Runtime.EventStreams.EventStreamEventReceivedArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private T <EventStreamEvent>k__BackingField;
    public T EventStreamEvent { get; }
    public EventStreamEventReceivedArgs`1(T eventStreamEvent);
    [CompilerGeneratedAttribute]
public T get_EventStreamEvent();
}
public class Amazon.Runtime.EventStreams.EventStreamExceptionReceivedArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private T <EventStreamException>k__BackingField;
    public T EventStreamException { get; }
    public EventStreamExceptionReceivedArgs`1(T eventStreamException);
    [CompilerGeneratedAttribute]
public T get_EventStreamException();
}
public class Amazon.Runtime.EventStreams.EventStreamHeader : object {
    private static DateTime _unixEpoch;
    private static int _sizeOfByte;
    private static int _sizeOfInt16;
    private static int _sizeOfInt32;
    private static int _sizeOfInt64;
    private static int _sizeOfGuid;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventStreamHeaderType <HeaderType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <HeaderValue>k__BackingField;
    public string Name { get; }
    public EventStreamHeaderType HeaderType { get; public set; }
    private object HeaderValue { get; private set; }
    public EventStreamHeader(string name);
    private static EventStreamHeader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual EventStreamHeaderType get_HeaderType();
    [CompilerGeneratedAttribute]
public void set_HeaderType(EventStreamHeaderType value);
    [CompilerGeneratedAttribute]
private object get_HeaderValue();
    [CompilerGeneratedAttribute]
private void set_HeaderValue(object value);
    public static EventStreamHeader FromBuffer(Byte[] buffer, int offset, Int32& newOffset);
    public sealed virtual int WriteToBuffer(Byte[] buffer, int offset);
    public sealed virtual int GetWireSize();
    public sealed virtual bool AsBool();
    public sealed virtual void SetBool(bool value);
    public sealed virtual byte AsByte();
    public sealed virtual void SetByte(byte value);
    public sealed virtual short AsInt16();
    public sealed virtual void SetInt16(short value);
    public sealed virtual int AsInt32();
    public sealed virtual void SetInt32(int value);
    public sealed virtual long AsInt64();
    public sealed virtual void SetInt64(long value);
    public sealed virtual Byte[] AsByteBuf();
    public sealed virtual void SetByteBuf(Byte[] value);
    public sealed virtual string AsString();
    public sealed virtual void SetString(string value);
    public sealed virtual DateTime AsTimestamp();
    public sealed virtual void SetTimestamp(DateTime value);
    public sealed virtual Guid AsUUID();
    public sealed virtual void SetUUID(Guid value);
}
public enum Amazon.Runtime.EventStreams.EventStreamHeaderType : Enum {
    public byte value__;
    public static EventStreamHeaderType BoolTrue;
    public static EventStreamHeaderType BoolFalse;
    public static EventStreamHeaderType Byte;
    public static EventStreamHeaderType Int16;
    public static EventStreamHeaderType Int32;
    public static EventStreamHeaderType Int64;
    public static EventStreamHeaderType ByteBuf;
    public static EventStreamHeaderType String;
    public static EventStreamHeaderType Timestamp;
    public static EventStreamHeaderType UUID;
}
public class Amazon.Runtime.EventStreams.EventStreamMessage : object {
    internal static int SizeOfInt32;
    internal static int PreludeLen;
    internal static int TrailerLen;
    internal static int FramingSize;
    public static string ContentType;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IEventStreamHeader> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Payload>k__BackingField;
    public Dictionary`2<string, IEventStreamHeader> Headers { get; public set; }
    public Byte[] Payload { get; public set; }
    public EventStreamMessage(List`1<IEventStreamHeader> headers, Byte[] payload);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, IEventStreamHeader> get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Headers(Dictionary`2<string, IEventStreamHeader> value);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_Payload();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Payload(Byte[] value);
    public static EventStreamMessage FromBuffer(Byte[] buffer, int offset, int length);
    public sealed virtual Byte[] ToByteArray();
}
public class Amazon.Runtime.EventStreams.EventStreamParseException : Exception {
    public EventStreamParseException(string message);
}
public class Amazon.Runtime.EventStreams.EventStreamValidationException : Exception {
    public EventStreamValidationException(string message);
    public EventStreamValidationException(string message, Exception innerException);
}
public interface Amazon.Runtime.EventStreams.IEventStreamHeader {
    public string Name { get; }
    public EventStreamHeaderType HeaderType { get; }
    public abstract virtual string get_Name();
    public abstract virtual EventStreamHeaderType get_HeaderType();
    public abstract virtual int GetWireSize();
    public abstract virtual int WriteToBuffer(Byte[] buffer, int offset);
    public abstract virtual bool AsBool();
    public abstract virtual void SetBool(bool value);
    public abstract virtual byte AsByte();
    public abstract virtual void SetByte(byte value);
    public abstract virtual short AsInt16();
    public abstract virtual void SetInt16(short value);
    public abstract virtual int AsInt32();
    public abstract virtual void SetInt32(int value);
    public abstract virtual long AsInt64();
    public abstract virtual void SetInt64(long value);
    public abstract virtual Byte[] AsByteBuf();
    public abstract virtual void SetByteBuf(Byte[] value);
    public abstract virtual string AsString();
    public abstract virtual void SetString(string value);
    public abstract virtual DateTime AsTimestamp();
    public abstract virtual void SetTimestamp(DateTime value);
    public abstract virtual Guid AsUUID();
    public abstract virtual void SetUUID(Guid value);
}
public interface Amazon.Runtime.EventStreams.IEventStreamMessage {
    public Dictionary`2<string, IEventStreamHeader> Headers { get; public set; }
    public Byte[] Payload { get; public set; }
    public abstract virtual Dictionary`2<string, IEventStreamHeader> get_Headers();
    public abstract virtual void set_Headers(Dictionary`2<string, IEventStreamHeader> value);
    public abstract virtual Byte[] get_Payload();
    public abstract virtual void set_Payload(Byte[] value);
    public abstract virtual Byte[] ToByteArray();
}
public abstract class Amazon.Runtime.EventStreams.Internal.EnumerableEventStream`2 : EventStream`2<T, TE> {
    private static string MutuallyExclusiveExceptionMessage;
    [CompilerGeneratedAttribute]
private bool <IsEnumerated>k__BackingField;
    protected bool IsEnumerated { get; protected set; }
    protected EnumerableEventStream`2(Stream stream);
    protected EnumerableEventStream`2(Stream stream, IEventStreamDecoder eventStreamDecoder);
    [CompilerGeneratedAttribute]
protected bool get_IsEnumerated();
    [CompilerGeneratedAttribute]
protected void set_IsEnumerated(bool value);
    [IteratorStateMachineAttribute("Amazon.Runtime.EventStreams.Internal.EnumerableEventStream`2/<GetEnumerator>d__7")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void StartProcessing();
    [AsyncStateMachineAttribute("Amazon.Runtime.EventStreams.Internal.EnumerableEventStream`2/<StartProcessingAsync>d__10")]
public virtual Task StartProcessingAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
public abstract class Amazon.Runtime.EventStreams.Internal.EventStream`2 : object {
    protected static string UnknownEventKey;
    private static string HeaderMessageType;
    private static string HeaderEventType;
    private static string HeaderExceptionType;
    private static string HeaderErrorCode;
    private static string HeaderErrorMessage;
    private static string EventHeaderMessageTypeValue;
    private static string ExceptionHeaderMessageTypeValue;
    private static string ErrorHeaderMessageTypeValue;
    private static string WrappedErrorMessage;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <NetworkStream>k__BackingField;
    [CompilerGeneratedAttribute]
private IEventStreamDecoder <Decoder>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventStreamEventReceivedArgs`1<T>> EventReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventStreamExceptionReceivedArgs`1<TE>> ExceptionReceived;
    private bool _disposed;
    public int BufferSize { get; public set; }
    protected Stream NetworkStream { get; }
    protected IEventStreamDecoder Decoder { get; }
    protected IDictionary`2<string, Func`2<IEventStreamMessage, T>> EventMapping { get; }
    protected IDictionary`2<string, Func`2<IEventStreamMessage, TE>> ExceptionMapping { get; }
    protected bool IsProcessing { get; protected set; }
    protected EventStream`2(Stream stream);
    protected EventStream`2(Stream stream, IEventStreamDecoder eventStreamDecoder);
    [CompilerGeneratedAttribute]
public sealed virtual int get_BufferSize();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
protected Stream get_NetworkStream();
    [CompilerGeneratedAttribute]
protected IEventStreamDecoder get_Decoder();
    [CompilerGeneratedAttribute]
public virtual void add_EventReceived(EventHandler`1<EventStreamEventReceivedArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public virtual void remove_EventReceived(EventHandler`1<EventStreamEventReceivedArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public virtual void add_ExceptionReceived(EventHandler`1<EventStreamExceptionReceivedArgs`1<TE>> value);
    [CompilerGeneratedAttribute]
public virtual void remove_ExceptionReceived(EventHandler`1<EventStreamExceptionReceivedArgs`1<TE>> value);
    protected abstract virtual IDictionary`2<string, Func`2<IEventStreamMessage, T>> get_EventMapping();
    protected abstract virtual IDictionary`2<string, Func`2<IEventStreamMessage, TE>> get_ExceptionMapping();
    protected abstract virtual bool get_IsProcessing();
    protected abstract virtual void set_IsProcessing(bool value);
    protected T ConvertMessageToEvent(EventStreamMessage eventStreamMessage);
    protected void Process();
    [AsyncStateMachineAttribute("Amazon.Runtime.EventStreams.Internal.EventStream`2/<ProcessLoopAsync>d__37")]
private Task ProcessLoopAsync();
    private void ProcessLoop(object state);
    protected void ReadFromStream(Byte[] buffer);
    [AsyncStateMachineAttribute("Amazon.Runtime.EventStreams.Internal.EventStream`2/<ReadFromStreamAsync>d__40")]
protected Task ReadFromStreamAsync(Byte[] buffer);
    protected TE WrapException(Exception ex);
    public virtual void StartProcessing();
    [AsyncStateMachineAttribute("Amazon.Runtime.EventStreams.Internal.EventStream`2/<StartProcessingAsync>d__43")]
public virtual Task StartProcessingAsync();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <Process>b__36_0();
}
public class Amazon.Runtime.EventStreams.Internal.EventStreamDecoder : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventStreamMessageReceivedEventArgs> MessageReceived;
    [CompilerGeneratedAttribute]
private object <MessageReceivedContext>k__BackingField;
    private ProcessRead[] _stateFns;
    private DecoderState _state;
    private int _currentMessageLength;
    private int _amountBytesRead;
    private Byte[] _workingMessage;
    private Byte[] _workingBuffer;
    private CrcCalculatorStream _runningChecksumStream;
    private bool disposedValue;
    public object MessageReceivedContext { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageReceived(EventHandler`1<EventStreamMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageReceived(EventHandler`1<EventStreamMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public object get_MessageReceivedContext();
    [CompilerGeneratedAttribute]
public void set_MessageReceivedContext(object value);
    private int Start(Byte[] data, int offset, int length);
    private int ReadPrelude(Byte[] data, int offset, int length);
    private int ProcessPrelude(Byte[] data, int offset, int length);
    private int ReadMessage(Byte[] data, int offset, int length);
    private void ProcessMessage();
    private int Error(Byte[] data, int offset, int length);
    public sealed virtual void ProcessData(Byte[] data, int offset, int length);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Amazon.Runtime.EventStreams.Internal.EventStreamDecoderIllegalStateException : Exception {
    public EventStreamDecoderIllegalStateException(string message);
}
public abstract class Amazon.Runtime.EventStreams.Internal.EventStreamException : Exception {
    protected EventStreamException(string message);
    protected EventStreamException(string message, Exception innerException);
}
public class Amazon.Runtime.EventStreams.Internal.EventStreamMessageReceivedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventStreamMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Context>k__BackingField;
    public EventStreamMessage Message { get; private set; }
    public object Context { get; private set; }
    public EventStreamMessageReceivedEventArgs(EventStreamMessage message);
    public EventStreamMessageReceivedEventArgs(EventStreamMessage message, object context);
    [CompilerGeneratedAttribute]
public EventStreamMessage get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(EventStreamMessage value);
    [CompilerGeneratedAttribute]
public object get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(object value);
}
public interface Amazon.Runtime.EventStreams.Internal.IEnumerableEventStream`2 {
}
public interface Amazon.Runtime.EventStreams.Internal.IEventStream`2 {
    public int BufferSize { get; public set; }
    public abstract virtual int get_BufferSize();
    public abstract virtual void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_EventReceived(EventHandler`1<EventStreamEventReceivedArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EventReceived(EventHandler`1<EventStreamEventReceivedArgs`1<T>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ExceptionReceived(EventHandler`1<EventStreamExceptionReceivedArgs`1<TE>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ExceptionReceived(EventHandler`1<EventStreamExceptionReceivedArgs`1<TE>> value);
    public abstract virtual void StartProcessing();
    public abstract virtual Task StartProcessingAsync();
}
public interface Amazon.Runtime.EventStreams.Internal.IEventStreamDecoder {
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageReceived(EventHandler`1<EventStreamMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageReceived(EventHandler`1<EventStreamMessageReceivedEventArgs> value);
    public abstract virtual void ProcessData(Byte[] data, int offset, int length);
}
public interface Amazon.Runtime.EventStreams.Internal.IEventStreamEvent {
}
public interface Amazon.Runtime.EventStreams.Internal.IEventStreamTerminalEvent {
}
public class Amazon.Runtime.EventStreams.Internal.InitialRequestEvent : object {
    [CompilerGeneratedAttribute]
private MemoryStream <Payload>k__BackingField;
    public MemoryStream Payload { get; public set; }
    public InitialRequestEvent(IEventStreamMessage message);
    [CompilerGeneratedAttribute]
public MemoryStream get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(MemoryStream value);
}
public class Amazon.Runtime.EventStreams.Internal.InitialResponseEvent : object {
    [CompilerGeneratedAttribute]
private MemoryStream <Payload>k__BackingField;
    public MemoryStream Payload { get; public set; }
    public InitialResponseEvent(IEventStreamMessage message);
    [CompilerGeneratedAttribute]
public MemoryStream get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(MemoryStream value);
}
public class Amazon.Runtime.EventStreams.Internal.UnknownEventStreamEvent : object {
    [CompilerGeneratedAttribute]
private IEventStreamMessage <ReceivedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventType>k__BackingField;
    public IEventStreamMessage ReceivedMessage { get; public set; }
    public string EventType { get; public set; }
    public UnknownEventStreamEvent(IEventStreamMessage receivedMessage, string eventType);
    [CompilerGeneratedAttribute]
public IEventStreamMessage get_ReceivedMessage();
    [CompilerGeneratedAttribute]
public void set_ReceivedMessage(IEventStreamMessage value);
    [CompilerGeneratedAttribute]
public string get_EventType();
    [CompilerGeneratedAttribute]
public void set_EventType(string value);
}
public class Amazon.Runtime.EventStreams.UnknownEventStreamException : EventStreamException {
    public string ExceptionType { get; private set; }
    public UnknownEventStreamException(string exceptionType);
    public string get_ExceptionType();
    private void set_ExceptionType(string value);
}
public class Amazon.Runtime.EventStreams.UnknownEventStreamMessageTypeException : Exception {
}
public static class Amazon.Runtime.EventStreams.Utils.EventStreamUtils : object {
    public static XmlUnmarshallerContext ConvertMessageToXmlContext(IEventStreamMessage message);
    public static JsonUnmarshallerContext ConvertMessageToJsonContext(IEventStreamMessage message);
}
public class Amazon.Runtime.ExceptionEventArgs : EventArgs {
}
public class Amazon.Runtime.ExceptionEventHandler : MulticastDelegate {
    public ExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class Amazon.Runtime.FallbackCredentialsFactory : object {
    private static ReaderWriterLockSlim cachedCredentialsLock;
    internal static string AWS_PROFILE_ENVIRONMENT_VARIABLE;
    internal static string DefaultProfileName;
    private static CredentialProfileStoreChain credentialProfileChain;
    [CompilerGeneratedAttribute]
private static List`1<CredentialsGenerator> <CredentialsGenerators>k__BackingField;
    private static AWSCredentials cachedCredentials;
    public static List`1<CredentialsGenerator> CredentialsGenerators { get; public set; }
    private static FallbackCredentialsFactory();
    [CompilerGeneratedAttribute]
public static List`1<CredentialsGenerator> get_CredentialsGenerators();
    [CompilerGeneratedAttribute]
public static void set_CredentialsGenerators(List`1<CredentialsGenerator> value);
    public static void Reset();
    public static void Reset(IWebProxy proxy);
    internal static string GetProfileName();
    private static AWSCredentials GetAWSCredentials(ICredentialProfileSource source);
    private static AWSCredentials ContainerEC2CredentialsWrapper();
    public static AWSCredentials GetCredentials();
    public static AWSCredentials GetCredentials(IClientConfig config, bool fallbackToAnonymous);
    public static AWSCredentials GetCredentials(bool fallbackToAnonymous);
}
[ObsoleteAttribute("This class has been deprecated in favor of FallbackConfigurationFactory.")]
public static class Amazon.Runtime.FallbackEndpointDiscoveryEnabledFactory : object {
    private static CredentialProfileStoreChain credentialProfileChain;
    private static object _lock;
    [CompilerGeneratedAttribute]
private static List`1<ConfigGenerator> <EnabledGenerators>k__BackingField;
    private static Nullable`1<bool> endpointDiscoveryEnabled;
    private static List`1<ConfigGenerator> EnabledGenerators { get; private set; }
    private static FallbackEndpointDiscoveryEnabledFactory();
    [CompilerGeneratedAttribute]
private static List`1<ConfigGenerator> get_EnabledGenerators();
    [CompilerGeneratedAttribute]
private static void set_EnabledGenerators(List`1<ConfigGenerator> value);
    public static void Reset();
    public static Nullable`1<bool> GetEnabled();
}
public static class Amazon.Runtime.FallbackRegionFactory : object {
    private static CredentialProfileStoreChain credentialProfileChain;
    private static object _lock;
    [CompilerGeneratedAttribute]
private static List`1<RegionGenerator> <AllGenerators>k__BackingField;
    [CompilerGeneratedAttribute]
private static List`1<RegionGenerator> <NonMetadataGenerators>k__BackingField;
    private static AWSRegion cachedRegion;
    private static List`1<RegionGenerator> AllGenerators { get; private set; }
    private static List`1<RegionGenerator> NonMetadataGenerators { get; private set; }
    private static FallbackRegionFactory();
    [CompilerGeneratedAttribute]
private static List`1<RegionGenerator> get_AllGenerators();
    [CompilerGeneratedAttribute]
private static void set_AllGenerators(List`1<RegionGenerator> value);
    [CompilerGeneratedAttribute]
private static List`1<RegionGenerator> get_NonMetadataGenerators();
    [CompilerGeneratedAttribute]
private static void set_NonMetadataGenerators(List`1<RegionGenerator> value);
    public static void Reset();
    public static RegionEndpoint GetRegionEndpoint();
    public static RegionEndpoint GetRegionEndpoint(bool includeInstanceMetadata);
}
public class Amazon.Runtime.FederatedAuthenticationCancelledException : Exception {
    public FederatedAuthenticationCancelledException(string msg);
    public FederatedAuthenticationCancelledException(string msg, Exception inner);
}
public class Amazon.Runtime.FederatedAuthenticationFailureException : Exception {
    public FederatedAuthenticationFailureException(string msg);
    public FederatedAuthenticationFailureException(string msg, Exception inner);
}
public class Amazon.Runtime.FederatedAWSCredentials : RefreshingAWSCredentials {
    private static int MaxAuthenticationRetries;
    private static RegionEndpoint DefaultSTSClientRegion;
    private static TimeSpan MaximumCredentialTimespan;
    private static TimeSpan DefaultPreemptExpiryTime;
    private SAMLRoleSessionManager sessionManager;
    [CompilerGeneratedAttribute]
private SAMLEndpoint <SAMLEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleArn>k__BackingField;
    [CompilerGeneratedAttribute]
private FederatedAWSCredentialsOptions <Options>k__BackingField;
    public SAMLEndpoint SAMLEndpoint { get; private set; }
    public string RoleArn { get; private set; }
    public FederatedAWSCredentialsOptions Options { get; private set; }
    public FederatedAWSCredentials(SAMLEndpoint samlEndpoint, string roleArn);
    public FederatedAWSCredentials(SAMLEndpoint samlEndpoint, string roleArn, FederatedAWSCredentialsOptions options);
    private static FederatedAWSCredentials();
    [CompilerGeneratedAttribute]
public SAMLEndpoint get_SAMLEndpoint();
    [CompilerGeneratedAttribute]
private void set_SAMLEndpoint(SAMLEndpoint value);
    [CompilerGeneratedAttribute]
public string get_RoleArn();
    [CompilerGeneratedAttribute]
private void set_RoleArn(string value);
    [CompilerGeneratedAttribute]
public FederatedAWSCredentialsOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(FederatedAWSCredentialsOptions value);
    protected virtual CredentialsRefreshState GenerateNewCredentials();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
private CredentialsRefreshState Authenticate(ICredentials userCredential);
    private string GetRoleSessionName();
    private bool TryGetRoleSession(SAMLImmutableCredentials& sessionCredentials);
    private void RegisterRoleSession(SAMLImmutableCredentials sessionCredentials);
    public virtual void ClearCredentials();
}
public class Amazon.Runtime.FederatedAWSCredentialsOptions : object {
    private object syncLock;
    private Func`2<CredentialRequestCallbackArgs, NetworkCredential> credentialRequestCallback;
    private object customCallbackState;
    private string userIdentity;
    private string profileName;
    private RegionEndpoint stsRegion;
    private WebProxy proxySettings;
    public string UserIdentity { get; public set; }
    public Func`2<CredentialRequestCallbackArgs, NetworkCredential> CredentialRequestCallback { get; public set; }
    public object CustomCallbackState { get; public set; }
    public WebProxy ProxySettings { get; public set; }
    public RegionEndpoint STSRegion { get; public set; }
    public string ProfileName { get; public set; }
    public string get_UserIdentity();
    public void set_UserIdentity(string value);
    public Func`2<CredentialRequestCallbackArgs, NetworkCredential> get_CredentialRequestCallback();
    public void set_CredentialRequestCallback(Func`2<CredentialRequestCallbackArgs, NetworkCredential> value);
    public object get_CustomCallbackState();
    public void set_CustomCallbackState(object value);
    public WebProxy get_ProxySettings();
    public void set_ProxySettings(WebProxy value);
    public RegionEndpoint get_STSRegion();
    public void set_STSRegion(RegionEndpoint value);
    public string get_ProfileName();
    public void set_ProfileName(string value);
}
public class Amazon.Runtime.GenericContainerCredentials : URIBasedRefreshingCredentialHelper {
    private static int MaxRetries;
    internal static string RelativeURIEnvVariable;
    internal static string FullURIEnvVariable;
    internal static string AuthorizationTokenEnvVariable;
    internal static string AuthorizationTokenFileEnvVariable;
    private static string ECSContainerHostAddress;
    private static string EKSContainerHostIPv4Address;
    private static string EKSContainerHostIPv6Address;
    private String[] AllowedHosts;
    private static string MissingEnvErrorMessage;
    private static string InvalidHostErrorMessage;
    [CompilerGeneratedAttribute]
private Uri <ResolvedEndpointUri>k__BackingField;
    internal Uri ResolvedEndpointUri { get; private set; }
    [CompilerGeneratedAttribute]
internal Uri get_ResolvedEndpointUri();
    [CompilerGeneratedAttribute]
private void set_ResolvedEndpointUri(Uri value);
    protected virtual CredentialsRefreshState GenerateNewCredentials();
    internal void DetermineEndpoint();
    internal static Dictionary`2<string, string> CreateAuthorizationHeader();
}
public class Amazon.Runtime.HeadersRequestEventArgs : RequestEventArgs {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    public IDictionary`2<string, string> Headers { get; protected set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
protected void set_Headers(IDictionary`2<string, string> value);
    internal static HeadersRequestEventArgs Create(IDictionary`2<string, string> headers);
}
public class Amazon.Runtime.HttpClientCache : object {
    private HttpClient[] _clients;
    private int count;
    public HttpClientCache(HttpClient[] clients);
    public HttpClient GetNextClient();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public abstract class Amazon.Runtime.HttpClientFactory : object {
    public abstract virtual HttpClient CreateHttpClient(IClientConfig clientConfig);
    public virtual bool UseSDKHttpClientCaching(IClientConfig clientConfig);
    public virtual bool DisposeHttpClientsAfterUse(IClientConfig clientConfig);
    public virtual string GetConfigUniqueString(IClientConfig clientConfig);
}
public class Amazon.Runtime.HttpRequestMessageFactory : object {
    private static ReaderWriterLockSlim _httpClientCacheRWLock;
    private static IDictionary`2<string, HttpClientCache> _httpClientCaches;
    private HttpClientCache _httpClientCache;
    private bool _useGlobalHttpClientCache;
    private IClientConfig _clientConfig;
    public HttpRequestMessageFactory(IClientConfig clientConfig);
    private static HttpRequestMessageFactory();
    public sealed virtual IHttpRequest`1<HttpContent> CreateHttpRequest(Uri requestUri);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static HttpClientCache CreateHttpClientCache(IClientConfig clientConfig);
    private static HttpClient CreateHttpClient(IClientConfig clientConfig);
    private static HttpClient CreateManagedHttpClient(IClientConfig clientConfig);
}
public class Amazon.Runtime.HttpWebRequestMessage : object {
    private static HashSet`1<string> ContentHeaderNames;
    private bool _disposed;
    private HttpRequestMessage _request;
    private HttpClient _httpClient;
    private IClientConfig _clientConfig;
    public HttpClient HttpClient { get; }
    public HttpRequestMessage Request { get; }
    public string Method { get; public set; }
    public Uri RequestUri { get; }
    public HttpWebRequestMessage(HttpClient httpClient, Uri requestUri, IClientConfig config);
    private static HttpWebRequestMessage();
    public HttpClient get_HttpClient();
    public HttpRequestMessage get_Request();
    public sealed virtual string get_Method();
    public sealed virtual void set_Method(string value);
    public sealed virtual Uri get_RequestUri();
    public sealed virtual void ConfigureRequest(IRequestContext requestContext);
    public sealed virtual void SetRequestHeaders(IDictionary`2<string, string> headers);
    public sealed virtual HttpContent GetRequestContent();
    public sealed virtual IWebResponseData GetResponse();
    public sealed virtual void Abort();
    [AsyncStateMachineAttribute("Amazon.Runtime.HttpWebRequestMessage/<GetResponseAsync>d__20")]
public sealed virtual Task`1<IWebResponseData> GetResponseAsync(CancellationToken cancellationToken);
    private HttpClientResponseData ProcessHttpResponseMessage(HttpResponseMessage responseMessage);
    public sealed virtual void WriteToRequestBody(HttpContent requestContent, Stream contentStream, IDictionary`2<string, string> contentHeaders, IRequestContext requestContext);
    public sealed virtual void WriteToRequestBody(HttpContent requestContent, Byte[] content, IDictionary`2<string, string> contentHeaders);
    public sealed virtual Task`1<HttpContent> GetRequestContentAsync();
    private void WriteContentHeaders(IDictionary`2<string, string> contentHeaders);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual Stream SetupProgressListeners(Stream originalStream, long progressUpdateInterval, object sender, EventHandler`1<StreamTransferProgressArgs> callback);
}
public interface Amazon.Runtime.IAmazonService {
    public IClientConfig Config { get; }
    public abstract virtual IClientConfig get_Config();
    public static abstract virtual ClientConfig CreateDefaultClientConfig();
    [UnconditionalSuppressMessageAttribute("AssemblyLoadTrimming", "IL2026:RequiresUnreferencedCode")]
public static abstract virtual IAmazonService CreateDefaultServiceClient(AWSCredentials awsCredentials, ClientConfig clientConfig);
}
public interface Amazon.Runtime.IAsyncExecutionContext {
    public IAsyncResponseContext ResponseContext { get; }
    public IAsyncRequestContext RequestContext { get; }
    public object RuntimeState { get; public set; }
    public abstract virtual IAsyncResponseContext get_ResponseContext();
    public abstract virtual IAsyncRequestContext get_RequestContext();
    public abstract virtual object get_RuntimeState();
    public abstract virtual void set_RuntimeState(object value);
}
public interface Amazon.Runtime.IAsyncRequestContext {
    public AsyncCallback Callback { get; }
    public object State { get; }
    public abstract virtual AsyncCallback get_Callback();
    public abstract virtual object get_State();
}
public interface Amazon.Runtime.IAsyncResponseContext {
}
public interface Amazon.Runtime.IAWSTokenProvider {
    public abstract virtual Task`1<TryResponse`1<AWSToken>> TryResolveTokenAsync(CancellationToken cancellationToken);
}
public interface Amazon.Runtime.IClientConfig {
    public bool IgnoreConfiguredEndpointUrls { get; }
    public string ServiceId { get; }
    public Profile Profile { get; }
    public IAWSTokenProvider AWSTokenProvider { get; }
    public DefaultConfigurationMode DefaultConfigurationMode { get; }
    public RegionEndpoint RegionEndpoint { get; }
    public string RegionEndpointServiceName { get; }
    public string ServiceURL { get; }
    public IEndpointProvider EndpointProvider { get; }
    public bool UseHttp { get; }
    public string ServiceVersion { get; }
    public SigningAlgorithm SignatureMethod { get; }
    public string SignatureVersion { get; }
    public string AuthenticationRegion { get; }
    public string AuthenticationServiceName { get; }
    public string UserAgent { get; }
    public bool DisableLogging { get; }
    public bool LogMetrics { get; }
    public bool LogResponse { get; }
    public bool ReadEntireResponse { get; }
    public bool AllowAutoRedirect { get; }
    public int BufferSize { get; }
    public int MaxErrorRetry { get; }
    public bool IsMaxErrorRetrySet { get; }
    public long ProgressUpdateInterval { get; }
    public bool ResignRetries { get; }
    public ICredentials ProxyCredentials { get; }
    public Nullable`1<TimeSpan> Timeout { get; }
    public bool UseDualstackEndpoint { get; }
    public bool UseFIPSEndpoint { get; }
    public bool DisableRequestCompression { get; }
    public long RequestMinCompressionSizeBytes { get; }
    public string ClientAppId { get; }
    public bool ThrottleRetries { get; }
    public DateTime CorrectedUtcNow { get; }
    public TimeSpan ClockOffset { get; }
    public bool DisableHostPrefixInjection { get; }
    public bool EndpointDiscoveryEnabled { get; }
    public int EndpointDiscoveryCacheLimit { get; }
    public RequestRetryMode RetryMode { get; }
    public bool FastFailRequests { get; }
    public bool UseAlternateUserAgentHeader { get; }
    public TelemetryProvider TelemetryProvider { get; }
    public Nullable`1<int> MaxConnectionsPerServer { get; }
    public bool CacheHttpClient { get; }
    public int HttpClientCacheSize { get; }
    public string ProxyHost { get; }
    public int ProxyPort { get; }
    public HttpClientFactory HttpClientFactory { get; }
    public abstract virtual bool get_IgnoreConfiguredEndpointUrls();
    public abstract virtual string get_ServiceId();
    public abstract virtual Profile get_Profile();
    public abstract virtual IAWSTokenProvider get_AWSTokenProvider();
    public abstract virtual DefaultConfigurationMode get_DefaultConfigurationMode();
    public abstract virtual RegionEndpoint get_RegionEndpoint();
    public abstract virtual string get_RegionEndpointServiceName();
    public abstract virtual string get_ServiceURL();
    public abstract virtual IEndpointProvider get_EndpointProvider();
    public abstract virtual bool get_UseHttp();
    public abstract virtual string get_ServiceVersion();
    public abstract virtual SigningAlgorithm get_SignatureMethod();
    public abstract virtual string get_SignatureVersion();
    public abstract virtual string get_AuthenticationRegion();
    public abstract virtual string get_AuthenticationServiceName();
    public abstract virtual string get_UserAgent();
    public abstract virtual bool get_DisableLogging();
    public abstract virtual bool get_LogMetrics();
    public abstract virtual bool get_LogResponse();
    public abstract virtual bool get_ReadEntireResponse();
    public abstract virtual bool get_AllowAutoRedirect();
    public abstract virtual int get_BufferSize();
    public abstract virtual int get_MaxErrorRetry();
    public abstract virtual bool get_IsMaxErrorRetrySet();
    public abstract virtual long get_ProgressUpdateInterval();
    public abstract virtual bool get_ResignRetries();
    public abstract virtual ICredentials get_ProxyCredentials();
    public abstract virtual Nullable`1<TimeSpan> get_Timeout();
    public abstract virtual bool get_UseDualstackEndpoint();
    public abstract virtual bool get_UseFIPSEndpoint();
    public abstract virtual bool get_DisableRequestCompression();
    public abstract virtual long get_RequestMinCompressionSizeBytes();
    public abstract virtual string get_ClientAppId();
    public abstract virtual bool get_ThrottleRetries();
    public abstract virtual Endpoint DetermineServiceOperationEndpoint(ServiceOperationEndpointParameters parameters);
    [ObsoleteAttribute("This operation is obsoleted because as of version 3.7.100 endpoint is resolved using a newer system that uses request level parameters to resolve the endpoint, use the service-specific client.DetermineServiceOperationEndPoint method instead.")]
public abstract virtual string DetermineDnsSuffix();
    public abstract virtual void Validate();
    public abstract virtual DateTime get_CorrectedUtcNow();
    public abstract virtual TimeSpan get_ClockOffset();
    public abstract virtual bool get_DisableHostPrefixInjection();
    public abstract virtual bool get_EndpointDiscoveryEnabled();
    public abstract virtual int get_EndpointDiscoveryCacheLimit();
    public abstract virtual RequestRetryMode get_RetryMode();
    public abstract virtual bool get_FastFailRequests();
    public abstract virtual bool get_UseAlternateUserAgentHeader();
    public abstract virtual TelemetryProvider get_TelemetryProvider();
    public abstract virtual Nullable`1<int> get_MaxConnectionsPerServer();
    public abstract virtual bool get_CacheHttpClient();
    public abstract virtual int get_HttpClientCacheSize();
    public abstract virtual string get_ProxyHost();
    public abstract virtual int get_ProxyPort();
    public abstract virtual IWebProxy GetWebProxy();
    public abstract virtual IWebProxy GetHttpsProxy();
    public abstract virtual IWebProxy GetHttpProxy();
    public abstract virtual HttpClientFactory get_HttpClientFactory();
}
public interface Amazon.Runtime.IDefaultConfiguration {
    public DefaultConfigurationMode Name { get; }
    public RequestRetryMode RetryMode { get; }
    public S3UsEast1RegionalEndpointValue S3UsEast1RegionalEndpoint { get; }
    public Nullable`1<TimeSpan> ConnectTimeout { get; }
    public Nullable`1<TimeSpan> TlsNegotiationTimeout { get; }
    public Nullable`1<TimeSpan> TimeToFirstByteTimeout { get; }
    public Nullable`1<TimeSpan> HttpRequestTimeout { get; }
    public abstract virtual DefaultConfigurationMode get_Name();
    public abstract virtual RequestRetryMode get_RetryMode();
    public abstract virtual S3UsEast1RegionalEndpointValue get_S3UsEast1RegionalEndpoint();
    public abstract virtual Nullable`1<TimeSpan> get_ConnectTimeout();
    public abstract virtual Nullable`1<TimeSpan> get_TlsNegotiationTimeout();
    public abstract virtual Nullable`1<TimeSpan> get_TimeToFirstByteTimeout();
    public abstract virtual Nullable`1<TimeSpan> get_HttpRequestTimeout();
}
public interface Amazon.Runtime.IExceptionHandler {
    public abstract virtual bool Handle(IExecutionContext executionContext, Exception exception);
    public abstract virtual Task`1<bool> HandleAsync(IExecutionContext executionContext, Exception exception);
}
public interface Amazon.Runtime.IExceptionHandler`1 {
    public abstract virtual bool HandleException(IExecutionContext executionContext, T exception);
}
public interface Amazon.Runtime.IExecutionContext {
    public IResponseContext ResponseContext { get; }
    public IRequestContext RequestContext { get; }
    public abstract virtual IResponseContext get_ResponseContext();
    public abstract virtual IRequestContext get_RequestContext();
}
public interface Amazon.Runtime.IHttpRequest`1 {
    public string Method { get; public set; }
    public Uri RequestUri { get; }
    public abstract virtual string get_Method();
    public abstract virtual void set_Method(string value);
    public abstract virtual Uri get_RequestUri();
    public abstract virtual void ConfigureRequest(IRequestContext requestContext);
    public abstract virtual void SetRequestHeaders(IDictionary`2<string, string> headers);
    public abstract virtual TRequestContent GetRequestContent();
    public abstract virtual IWebResponseData GetResponse();
    public abstract virtual void WriteToRequestBody(TRequestContent requestContent, Stream contentStream, IDictionary`2<string, string> contentHeaders, IRequestContext requestContext);
    public abstract virtual void WriteToRequestBody(TRequestContent requestContent, Byte[] content, IDictionary`2<string, string> contentHeaders);
    public abstract virtual Stream SetupProgressListeners(Stream originalStream, long progressUpdateInterval, object sender, EventHandler`1<StreamTransferProgressArgs> callback);
    public abstract virtual void Abort();
    public abstract virtual Task`1<TRequestContent> GetRequestContentAsync();
    public abstract virtual Task`1<IWebResponseData> GetResponseAsync(CancellationToken cancellationToken);
}
public interface Amazon.Runtime.IHttpRequestFactory`1 {
    public abstract virtual IHttpRequest`1<TRequestContent> CreateHttpRequest(Uri requestUri);
}
public interface Amazon.Runtime.ILogMessage {
    public string Format { get; }
    public Object[] Args { get; }
    public IFormatProvider Provider { get; }
    public abstract virtual string get_Format();
    public abstract virtual Object[] get_Args();
    public abstract virtual IFormatProvider get_Provider();
}
public interface Amazon.Runtime.IMetricsFormatter {
    public abstract virtual string FormatMetrics(IRequestMetrics metrics);
}
public interface Amazon.Runtime.IMetricsTiming {
    public bool IsFinished { get; }
    public long ElapsedTicks { get; }
    public TimeSpan ElapsedTime { get; }
    public abstract virtual bool get_IsFinished();
    public abstract virtual long get_ElapsedTicks();
    public abstract virtual TimeSpan get_ElapsedTime();
}
public class Amazon.Runtime.ImmutableCredentials : object {
    [CompilerGeneratedAttribute]
private string <AccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecretKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    public string AccessKey { get; private set; }
    public string SecretKey { get; private set; }
    public string Token { get; private set; }
    public bool UseToken { get; }
    public ImmutableCredentials(string awsAccessKeyId, string awsSecretAccessKey, string token);
    [CompilerGeneratedAttribute]
public string get_AccessKey();
    [CompilerGeneratedAttribute]
private void set_AccessKey(string value);
    [CompilerGeneratedAttribute]
public string get_SecretKey();
    [CompilerGeneratedAttribute]
private void set_SecretKey(string value);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
private void set_Token(string value);
    public bool get_UseToken();
    public virtual ImmutableCredentials Copy();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Amazon.Runtime.InstanceProfileAWSCredentials : URIBasedRefreshingCredentialHelper {
    private static TimeSpan _preemptExpiryTime;
    private static TimeSpan _refreshAttemptPeriod;
    private CredentialsRefreshState _currentRefreshState;
    private IWebProxy _proxy;
    private static string _receivedExpiredCredentialsFromIMDS;
    private Logger _logger;
    [CompilerGeneratedAttribute]
private string <Role>k__BackingField;
    private static String[] AliasSeparators;
    private static string Server;
    private static string RolesPath;
    private static string InfoPath;
    public string Role { get; public set; }
    private static Uri RolesUri { get; }
    private Uri CurrentRoleUri { get; }
    private static Uri InfoUri { get; }
    public InstanceProfileAWSCredentials(string role);
    public InstanceProfileAWSCredentials(string role, IWebProxy proxy);
    public InstanceProfileAWSCredentials(IWebProxy proxy);
    private static InstanceProfileAWSCredentials();
    [CompilerGeneratedAttribute]
public string get_Role();
    [CompilerGeneratedAttribute]
public void set_Role(string value);
    protected virtual CredentialsRefreshState GenerateNewCredentials();
    public static IEnumerable`1<string> GetAvailableRoles();
    [IteratorStateMachineAttribute("Amazon.Runtime.InstanceProfileAWSCredentials/<GetAvailableRoles>d__16")]
public static IEnumerable`1<string> GetAvailableRoles(IWebProxy proxy);
    private static Uri get_RolesUri();
    private Uri get_CurrentRoleUri();
    private static Uri get_InfoUri();
    private CredentialsRefreshState GetEarlyRefreshState(CredentialsRefreshState state);
    private CredentialsRefreshState GetRefreshState(string token);
    private static SecurityInfo GetServiceInfo(IWebProxy proxy, string token);
    private SecurityCredentials GetRoleCredentials(string token);
    private static void CheckIsIMDSEnabled();
    private static string GetFirstRole();
    private static string GetFirstRole(IWebProxy proxy);
    private static bool IsNullOrWhiteSpace(string s);
    private static Dictionary`2<string, string> CreateMetadataTokenHeaders(string token);
}
public class Amazon.Runtime.InstanceProfileAWSRegion : AWSRegion {
}
public class Amazon.Runtime.Internal.AdaptiveRetryPolicy : StandardRetryPolicy {
    [CompilerGeneratedAttribute]
private TokenBucket <TokenBucket>k__BackingField;
    protected TokenBucket TokenBucket { get; protected set; }
    public AdaptiveRetryPolicy(int maxRetries);
    public AdaptiveRetryPolicy(IClientConfig config);
    [CompilerGeneratedAttribute]
protected TokenBucket get_TokenBucket();
    [CompilerGeneratedAttribute]
protected void set_TokenBucket(TokenBucket value);
    public virtual bool OnRetry(IExecutionContext executionContext, bool bypassAcquireCapacity, bool isThrottlingError);
    public virtual void ObtainSendToken(IExecutionContext executionContext, Exception exception);
    public virtual void NotifySuccess(IExecutionContext executionContext);
    public virtual Task`1<bool> RetryForExceptionAsync(IExecutionContext executionContext, Exception exception);
    public virtual Task WaitBeforeRetryAsync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.AdaptiveRetryPolicy/<ObtainSendTokenAsync>d__11")]
public virtual Task ObtainSendTokenAsync(IExecutionContext executionContext, Exception exception);
}
public class Amazon.Runtime.Internal.AmazonSecurityProtocolManager : object {
    private static SecurityProtocolType Tls11;
    private static SecurityProtocolType Tls12;
    private static SecurityProtocolType SupportedTls;
    private static SecurityProtocolType SystemDefault;
    public sealed virtual bool IsSecurityProtocolSystemDefault();
    public sealed virtual void UpdateProtocolsToSupported();
}
public class Amazon.Runtime.Internal.AppConfigCSMConfigs : object {
    public AppConfigCSMConfigs(CSMFallbackConfigChain cSMFallbackConfigChain);
}
public class Amazon.Runtime.Internal.AsyncExecutionContext : object {
    [CompilerGeneratedAttribute]
private IAsyncResponseContext <ResponseContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IAsyncRequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RuntimeState>k__BackingField;
    public IAsyncResponseContext ResponseContext { get; private set; }
    public IAsyncRequestContext RequestContext { get; private set; }
    public object RuntimeState { get; public set; }
    public AsyncExecutionContext(bool enableMetrics, AbstractAWSSigner clientSigner);
    public AsyncExecutionContext(IAsyncRequestContext requestContext, IAsyncResponseContext responseContext);
    [CompilerGeneratedAttribute]
public sealed virtual IAsyncResponseContext get_ResponseContext();
    [CompilerGeneratedAttribute]
private void set_ResponseContext(IAsyncResponseContext value);
    [CompilerGeneratedAttribute]
public sealed virtual IAsyncRequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
private void set_RequestContext(IAsyncRequestContext value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_RuntimeState();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RuntimeState(object value);
}
public class Amazon.Runtime.Internal.AsyncRequestContext : RequestContext {
    [CompilerGeneratedAttribute]
private AsyncCallback <Callback>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    public AsyncCallback Callback { get; public set; }
    public object State { get; public set; }
    public AsyncRequestContext(bool enableMetrics, AbstractAWSSigner clientSigner);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncCallback get_Callback();
    [CompilerGeneratedAttribute]
public void set_Callback(AsyncCallback value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_State();
    [CompilerGeneratedAttribute]
public void set_State(object value);
}
public class Amazon.Runtime.Internal.AsyncResponseContext : ResponseContext {
}
public static class Amazon.Runtime.Internal.AsyncRunner : object {
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task`1<T> Run(Func`1<T> action, CancellationToken cancellationToken);
}
public abstract class Amazon.Runtime.Internal.Auth.AbstractAWSSigner : object {
    private object _lock;
    private AWS4Signer _aws4Signer;
    private AWS4aSignerCRTWrapper _aws4aSignerCRTWrapper;
    [CompilerGeneratedAttribute]
private bool <RequiresCredentials>k__BackingField;
    private AWS4Signer AWS4SignerInstance { get; }
    private AWS4aSignerCRTWrapper AWS4aSignerCRTWrapperInstance { get; }
    public bool RequiresCredentials { get; }
    public ClientProtocol Protocol { get; }
    private AWS4Signer get_AWS4SignerInstance();
    private AWS4aSignerCRTWrapper get_AWS4aSignerCRTWrapperInstance();
    [CompilerGeneratedAttribute]
public virtual bool get_RequiresCredentials();
    protected static string ComputeHash(string data, string secretkey, SigningAlgorithm algorithm);
    protected static string ComputeHash(Byte[] data, string secretkey, SigningAlgorithm algorithm);
    public abstract virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public virtual Task SignAsync(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials, CancellationToken token);
    public abstract virtual ClientProtocol get_Protocol();
    protected static bool UseV4Signing(bool useSigV4Setting, IRequest request, IClientConfig config);
    protected AbstractAWSSigner SelectSigner(IRequest request, IClientConfig config);
    protected AbstractAWSSigner SelectSigner(AbstractAWSSigner defaultSigner, bool useSigV4Setting, IRequest request, IClientConfig config);
}
public class Amazon.Runtime.Internal.Auth.AWS4aSignerCRTWrapper : AbstractAWSSigner {
    internal static string CRT_WRAPPER_ASSEMBLY_NAME;
    internal static string CRT_WRAPPER_NUGET_PACKGE_NAME;
    internal static string CRT_WRAPPER_CLASS_NAME;
    private static IAWSSigV4aProvider _awsSigV4AProvider;
    private static object _lock;
    public ClientProtocol Protocol { get; }
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075")]
public AWS4aSignerCRTWrapper(bool signPayload);
    private static AWS4aSignerCRTWrapper();
    public virtual ClientProtocol get_Protocol();
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public AWS4aSigningResult SignRequest(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public AWS4aSigningResult Presign4a(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials, string service, string overrideSigningRegion);
    public string SignChunk(Stream chunkBody, string previousSignature, AWS4aSigningResult headerSigningResult);
    public string SignTrailingHeaderChunk(IDictionary`2<string, string> trailingHeaders, string previousSignature, AWS4aSigningResult headerSigningResult);
}
public class Amazon.Runtime.Internal.Auth.AWS4aSigningResult : AWSSigningResultBase {
    private string _regionSet;
    private string _signature;
    private string _service;
    private string _presignedUri;
    private ImmutableCredentials _credentials;
    public string Signature { get; }
    public string ForAuthorizationHeader { get; }
    public string RegionSet { get; }
    public string PresignedUri { get; }
    public string Service { get; }
    public ImmutableCredentials Credentials { get; }
    public AWS4aSigningResult(string awsAccessKeyId, DateTime signedAt, string signedHeaders, string scope, string regionSet, string signature, string service, string presignedUri, ImmutableCredentials credentials);
    public virtual string get_Signature();
    public virtual string get_ForAuthorizationHeader();
    public string get_RegionSet();
    public string get_PresignedUri();
    public string get_Service();
    public ImmutableCredentials get_Credentials();
}
public class Amazon.Runtime.Internal.Auth.AWS4PreSignedUrlSigner : AWS4Signer {
    public static long MaxAWS4PreSignedUrlExpiry;
    public static IEnumerable`1<string> ServicesUsingUnsignedPayload;
    private static AWS4PreSignedUrlSigner();
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public AWS4SigningResult SignRequest(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public static AWS4SigningResult SignRequest(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey, string service, string overrideSigningRegion);
}
public class Amazon.Runtime.Internal.Auth.AWS4Signer : AbstractAWSSigner {
    public static string Scheme;
    public static string Algorithm;
    public static string Sigv4aAlgorithm;
    public static string AWS4AlgorithmTag;
    public static string AWS4aAlgorithmTag;
    public static string Terminator;
    public static Byte[] TerminatorBytes;
    public static string Credential;
    public static string SignedHeaders;
    public static string Signature;
    public static string EmptyBodySha256;
    public static string StreamingBodySha256;
    public static string StreamingBodySha256WithTrailer;
    public static string V4aStreamingBodySha256;
    public static string V4aStreamingBodySha256WithTrailer;
    public static string AWSChunkedEncoding;
    public static string UnsignedPayload;
    public static string UnsignedPayloadWithTrailer;
    private static SigningAlgorithm SignerAlgorithm;
    private static IEnumerable`1<string> _headersToIgnoreWhenSigning;
    [CompilerGeneratedAttribute]
private bool <SignPayload>k__BackingField;
    public bool SignPayload { get; private set; }
    public ClientProtocol Protocol { get; }
    public AWS4Signer(bool signPayload);
    private static AWS4Signer();
    [CompilerGeneratedAttribute]
public bool get_SignPayload();
    [CompilerGeneratedAttribute]
private void set_SignPayload(bool value);
    public virtual ClientProtocol get_Protocol();
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public AWS4SigningResult SignRequest(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public static DateTime InitializeHeaders(IDictionary`2<string, string> headers, Uri requestEndpoint);
    public static DateTime InitializeHeaders(IDictionary`2<string, string> headers, Uri requestEndpoint, DateTime requestDateTime);
    public static void SetXAmzTrailerHeader(IDictionary`2<string, string> headers, IDictionary`2<string, string> trailingHeaders);
    private static void CleanHeaders(IDictionary`2<string, string> headers);
    private static void ValidateRequest(IRequest request);
    public static AWS4SigningResult ComputeSignature(ImmutableCredentials credentials, string region, DateTime signedAt, string service, string signedHeaders, string canonicalRequest);
    public static AWS4SigningResult ComputeSignature(string awsAccessKey, string awsSecretAccessKey, string region, DateTime signedAt, string service, string signedHeaders, string canonicalRequest);
    public static AWS4SigningResult ComputeSignature(string awsAccessKey, string awsSecretAccessKey, string region, DateTime signedAt, string service, string signedHeaders, string canonicalRequest, RequestMetrics metrics);
    public static string FormatDateTime(DateTime dt, string formatString);
    public static Byte[] ComposeSigningKey(string awsSecretAccessKey, string region, string date, string service);
    public static string SetRequestBodyHash(IRequest request, string chunkedBodyHash, int signatureLength);
    public static string SetRequestBodyHash(IRequest request, bool signPayload, string chunkedBodyHash, int signatureLength);
    private static void SetContentEncodingHeader(IRequest request);
    public static Byte[] SignBlob(Byte[] key, string data);
    public static Byte[] SignBlob(Byte[] key, Byte[] data);
    public static Byte[] ComputeKeyedHash(SigningAlgorithm algorithm, Byte[] key, string data);
    public static Byte[] ComputeKeyedHash(SigningAlgorithm algorithm, Byte[] key, Byte[] data);
    public static Byte[] ComputeHash(string data);
    public static Byte[] ComputeHash(Byte[] data);
    private static string SetPayloadSignatureHeader(IRequest request, string payloadHash);
    public static string DetermineSigningRegion(IClientConfig clientConfig, string serviceName, RegionEndpoint alternateEndpoint, IRequest request);
    public static string DetermineService(IClientConfig clientConfig, IRequest request);
    protected static string CanonicalizeRequest(Uri endpoint, string resourcePath, string httpMethod, IDictionary`2<string, string> sortedHeaders, string canonicalQueryString, string precomputedBodyHash);
    protected static string CanonicalizeRequest(Uri endpoint, string resourcePath, string httpMethod, IDictionary`2<string, string> sortedHeaders, string canonicalQueryString, string precomputedBodyHash, IDictionary`2<string, string> pathResources);
    protected static string CanonicalizeRequest(Uri endpoint, string resourcePath, string httpMethod, IDictionary`2<string, string> sortedHeaders, string canonicalQueryString, string precomputedBodyHash, IDictionary`2<string, string> pathResources, bool doubleEncode);
    private static string CanonicalizeRequestHelper(Uri endpoint, string resourcePath, string httpMethod, IDictionary`2<string, string> sortedHeaders, string canonicalQueryString, string precomputedBodyHash, IDictionary`2<string, string> pathResources, bool doubleEncode);
    protected internal static IDictionary`2<string, string> SortAndPruneHeaders(IEnumerable`1<KeyValuePair`2<string, string>> requestHeaders);
    protected internal static string CanonicalizeHeaders(IEnumerable`1<KeyValuePair`2<string, string>> sortedHeaders);
    protected static string CanonicalizeHeaderNames(IEnumerable`1<KeyValuePair`2<string, string>> sortedHeaders);
    protected static List`1<KeyValuePair`2<string, string>> GetParametersToCanonicalize(IRequest request);
    protected static string CanonicalizeQueryParameters(string queryString);
    protected static string CanonicalizeQueryParameters(string queryString, bool uriEncodeParameters);
    protected static string CanonicalizeQueryParameters(IEnumerable`1<KeyValuePair`2<string, string>> parameters);
    protected static string CanonicalizeQueryParameters(IEnumerable`1<KeyValuePair`2<string, string>> parameters, bool uriEncodeParameters);
}
public class Amazon.Runtime.Internal.Auth.AWS4SigningResult : AWSSigningResultBase {
    private Byte[] _signingKey;
    private Byte[] _signature;
    public string Signature { get; }
    public string ForAuthorizationHeader { get; }
    public string ForQueryParameters { get; }
    public AWS4SigningResult(string awsAccessKeyId, DateTime signedAt, string signedHeaders, string scope, Byte[] signingKey, Byte[] signature);
    public Byte[] GetSigningKey();
    public virtual string get_Signature();
    public virtual string get_ForAuthorizationHeader();
    public string get_ForQueryParameters();
}
public abstract class Amazon.Runtime.Internal.Auth.AWSSigningResultBase : object {
    private string _awsAccessKeyId;
    private DateTime _originalDateTime;
    private string _signedHeaders;
    private string _scope;
    public string AccessKeyId { get; }
    public string ISO8601DateTime { get; }
    public string ISO8601Date { get; }
    public DateTime DateTime { get; }
    public string SignedHeaders { get; }
    public string Scope { get; }
    public string Signature { get; }
    public string ForAuthorizationHeader { get; }
    public AWSSigningResultBase(string awsAccessKeyId, DateTime signedAt, string signedHeaders, string scope);
    public string get_AccessKeyId();
    public string get_ISO8601DateTime();
    public string get_ISO8601Date();
    public DateTime get_DateTime();
    public string get_SignedHeaders();
    public string get_Scope();
    public abstract virtual string get_Signature();
    public abstract virtual string get_ForAuthorizationHeader();
}
public enum Amazon.Runtime.Internal.Auth.ClientProtocol : Enum {
    public int value__;
    public static ClientProtocol QueryStringProtocol;
    public static ClientProtocol RestProtocol;
    public static ClientProtocol Unknown;
}
public class Amazon.Runtime.Internal.Auth.CloudFrontSigner : AbstractAWSSigner {
    public ClientProtocol Protocol { get; }
    public virtual ClientProtocol get_Protocol();
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
}
public class Amazon.Runtime.Internal.Auth.EventBridgeSigner : AbstractAWSSigner {
    public ClientProtocol Protocol { get; }
    public virtual ClientProtocol get_Protocol();
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
}
public class Amazon.Runtime.Internal.Auth.NullSigner : AbstractAWSSigner {
    public ClientProtocol Protocol { get; }
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public virtual ClientProtocol get_Protocol();
}
public class Amazon.Runtime.Internal.Auth.QueryStringSigner : AbstractAWSSigner {
    private static string SignatureVersion2;
    public ClientProtocol Protocol { get; }
    public virtual ClientProtocol get_Protocol();
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
}
public class Amazon.Runtime.Internal.Auth.S3Signer : AbstractAWSSigner {
    private bool _useSigV4;
    private RegionDetectionUpdater _regionDetector;
    private static HashSet`1<string> SignableParameters;
    private static HashSet`1<string> SubResourcesSigningExclusion;
    public ClientProtocol Protocol { get; }
    public S3Signer(bool useSigV4, RegionDetectionUpdater regionDetector);
    private static S3Signer();
    public virtual ClientProtocol get_Protocol();
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    public virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public static void SignRequest(IRequest request, RequestMetrics metrics, string awsAccessKeyId, string awsSecretAccessKey);
    private static string BuildStringToSign(IRequest request);
    private static string BuildCanonicalizedHeaders(IDictionary`2<string, string> headers);
    private static string BuildCanonicalizedResource(IRequest request);
}
public class Amazon.Runtime.Internal.Auth.SignatureException : Exception {
    public SignatureException(string message);
    public SignatureException(string message, Exception innerException);
}
public class Amazon.Runtime.Internal.AutoConstructedDictionary`2 : Dictionary`2<K, V> {
}
public class Amazon.Runtime.Internal.AutoConstructedList`1 : List`1<T> {
}
[AttributeUsageAttribute("128")]
public class Amazon.Runtime.Internal.AWSPropertyAttribute : Attribute {
    private long min;
    private long max;
    [CompilerGeneratedAttribute]
private bool <Sensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMinSet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMaxSet>k__BackingField;
    public bool Sensitive { get; public set; }
    public bool Required { get; public set; }
    public bool IsMinSet { get; private set; }
    public long Min { get; public set; }
    public bool IsMaxSet { get; private set; }
    public long Max { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Sensitive();
    [CompilerGeneratedAttribute]
public void set_Sensitive(bool value);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMinSet();
    [CompilerGeneratedAttribute]
private void set_IsMinSet(bool value);
    public long get_Min();
    public void set_Min(long value);
    [CompilerGeneratedAttribute]
public bool get_IsMaxSet();
    [CompilerGeneratedAttribute]
private void set_IsMaxSet(bool value);
    public long get_Max();
    public void set_Max(long value);
}
[AttributeUsageAttribute("4")]
public class Amazon.Runtime.Internal.AWSSignerTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SignerType>k__BackingField;
    public string SignerType { get; }
    public AWSSignerTypeAttribute(string signerType);
    [CompilerGeneratedAttribute]
public string get_SignerType();
}
public class Amazon.Runtime.Internal.BaseEndpointResolver : PipelineHandler {
    private static String[] SupportedAuthSchemas;
    private static BaseEndpointResolver();
    public virtual void InvokeSync(IExecutionContext executionContext);
    public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected virtual void PreInvoke(IExecutionContext executionContext);
    public virtual void ProcessRequestHandlers(IExecutionContext executionContext);
    public virtual Endpoint GetEndpoint(IExecutionContext executionContext);
    private Endpoint GetEndpoint(IExecutionContext executionContext, EndpointParameters parameters);
    protected virtual void ServiceSpecificHandler(IExecutionContext executionContext, EndpointParameters parameters);
    private static void SetAuthenticationAndHeaders(IRequest request, Endpoint endpoint);
    private static void ApplyCommonSchema(IRequest request, PropertyBag schema);
    private static bool IsCrtDependencyAvailable();
    protected static void InjectHostPrefix(IRequestContext requestContext);
    protected virtual EndpointParameters MapEndpointsParameters(IRequestContext requestContext);
}
public class Amazon.Runtime.Internal.CallbackHandler : PipelineHandler {
    [CompilerGeneratedAttribute]
private Action`1<IExecutionContext> <OnPreInvoke>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IExecutionContext> <OnPostInvoke>k__BackingField;
    public Action`1<IExecutionContext> OnPreInvoke { get; public set; }
    public Action`1<IExecutionContext> OnPostInvoke { get; public set; }
    [CompilerGeneratedAttribute]
public Action`1<IExecutionContext> get_OnPreInvoke();
    [CompilerGeneratedAttribute]
public void set_OnPreInvoke(Action`1<IExecutionContext> value);
    [CompilerGeneratedAttribute]
public Action`1<IExecutionContext> get_OnPostInvoke();
    [CompilerGeneratedAttribute]
public void set_OnPostInvoke(Action`1<IExecutionContext> value);
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.CallbackHandler/<InvokeAsync>d__9`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected void PreInvoke(IExecutionContext executionContext);
    protected void PostInvoke(IExecutionContext executionContext);
    private void RaiseOnPreInvoke(IExecutionContext context);
    private void RaiseOnPostInvoke(IExecutionContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.CapacityManager : object {
    private bool _disposed;
    private static Dictionary`2<string, RetryCapacity> _serviceUrlToCapacityMap;
    private static ReaderWriterLockSlim _rwlock;
    private int retryCost;
    private int timeoutRetryCost;
    private int initialRetryTokens;
    private int noRetryIncrement;
    public CapacityManager(int throttleRetryCount, int throttleRetryCost, int throttleCost);
    public CapacityManager(int throttleRetryCount, int throttleRetryCost, int throttleCost, int timeoutRetryCost);
    private static CapacityManager();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool TryAcquireCapacity(RetryCapacity retryCapacity);
    public bool TryAcquireCapacity(RetryCapacity retryCapacity, CapacityType capacityType);
    [ObsoleteAttribute("This method is no longer used in favor of allowing the caller to specify the type of capacity to release.")]
public void TryReleaseCapacity(bool isRetryRequest, RetryCapacity retryCapacity);
    public void ReleaseCapacity(CapacityType capacityType, RetryCapacity retryCapacity);
    public RetryCapacity GetRetryCapacity(string serviceURL);
    private static bool TryGetRetryCapacity(string key, RetryCapacity& value);
    private RetryCapacity AddNewRetryCapacity(string serviceURL);
    private static void ReleaseCapacity(int capacity, RetryCapacity retryCapacity);
}
public class Amazon.Runtime.Internal.ChecksumHandler : PipelineHandler {
    public virtual void InvokeSync(IExecutionContext executionContext);
    public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected virtual void PreInvoke(IExecutionContext executionContext);
}
[RequiresUnreferencedCodeAttribute("ClientContext has not been updated to support producing JSON using source generators. For requests that need client context JSON the JSON must be created manually.")]
public class Amazon.Runtime.Internal.ClientContext : object {
    private static string CLIENT_KEY;
    private static string CLIENT_ID_KEY;
    private static string CLIENT_APP_TITLE_KEY;
    private static string CLIENT_APP_VERSION_NAME_KEY;
    private static string CLIENT_APP_VERSION_CODE_KEY;
    private static string CLIENT_APP_PACKAGE_NAME_KEY;
    private static string CUSTOM_KEY;
    private static string ENV_KEY;
    private static string ENV_PLATFORM_KEY;
    private static string ENV_MODEL_KEY;
    private static string ENV_MAKE_KEY;
    private static string ENV_PLATFORM_VERSION_KEY;
    private static string ENV_LOCALE_KEY;
    private static string SERVICES_KEY;
    private static string SERVICE_MOBILE_ANALYTICS_KEY;
    private static string SERVICE_MOBILE_ANALYTICS_APP_ID_KEY;
    private IDictionary`2<string, string> _client;
    private IDictionary`2<string, string> _custom;
    private IDictionary`2<string, string> _env;
    private IDictionary`2<string, IDictionary> _services;
    private IDictionary _clientContext;
    private static object _lock;
    private static string APP_ID_KEY;
    private static string CLIENT_ID_CACHE_FILENAME;
    [CompilerGeneratedAttribute]
private string <AppID>k__BackingField;
    public string AppID { get; public set; }
    private static ClientContext();
    [CompilerGeneratedAttribute]
public string get_AppID();
    [CompilerGeneratedAttribute]
public void set_AppID(string value);
    public void AddCustomAttributes(string key, string value);
    public string ToJsonString();
}
public static class Amazon.Runtime.Internal.Compression.CompressionFactory : object {
    public static ICompressionAlgorithm GetCompressionAlgorithm(CompressionEncodingAlgorithm type);
}
public class Amazon.Runtime.Internal.Compression.GZipCompression : object {
    public CompressionEncodingAlgorithm AlgorithmId { get; }
    public sealed virtual CompressionEncodingAlgorithm get_AlgorithmId();
    public sealed virtual Byte[] Compress(Byte[] content);
    public sealed virtual Stream GetCompressionStream(Stream inputStream);
}
public interface Amazon.Runtime.Internal.Compression.ICompressionAlgorithm {
    public CompressionEncodingAlgorithm AlgorithmId { get; }
    public abstract virtual CompressionEncodingAlgorithm get_AlgorithmId();
    public abstract virtual Byte[] Compress(Byte[] content);
    public abstract virtual Stream GetCompressionStream(Stream inputStream);
}
public class Amazon.Runtime.Internal.CompressionHandler : PipelineHandler {
    public virtual void InvokeSync(IExecutionContext executionContext);
    public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected virtual void PreInvoke(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.CredentialsRetriever : PipelineHandler {
    [CompilerGeneratedAttribute]
private AWSCredentials <Credentials>k__BackingField;
    protected AWSCredentials Credentials { get; private set; }
    public CredentialsRetriever(AWSCredentials credentials);
    [CompilerGeneratedAttribute]
protected AWSCredentials get_Credentials();
    [CompilerGeneratedAttribute]
private void set_Credentials(AWSCredentials value);
    protected virtual void PreInvoke(IExecutionContext executionContext);
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.CredentialsRetriever/<InvokeAsync>d__7`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.CSMCallAttemptHandler : PipelineHandler {
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.CSMCallAttemptHandler/<InvokeAsync>d__1`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected static void CSMCallAttemptMetricsCapture(IRequestContext requestContext, IResponseContext responseContext);
    protected virtual void PreInvoke(IExecutionContext executionContext);
    private static void CaptureSDKExceptionMessage(MonitoringAPICallAttempt monitoringAPICallAttempt, Exception e);
    private static void CaptureAmazonException(MonitoringAPICallAttempt monitoringAPICallAttempt, AmazonServiceException e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.CSMCallEventHandler : PipelineHandler {
    private Stopwatch stopWatch;
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.CSMCallEventHandler/<InvokeAsync>d__2`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    private void CSMCallEventMetricsCapture(IExecutionContext executionContext);
    private static void CaptureCSMCallEventExceptionData(IRequestContext requestContext, Exception exception);
    protected void PreInvoke(IExecutionContext executionContext);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.CSMConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    public string Host { get; internal set; }
    public int Port { get; internal set; }
    public bool Enabled { get; internal set; }
    public string ClientId { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
internal void set_Host(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
internal void set_Port(int value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
internal void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
internal void set_ClientId(string value);
}
public class Amazon.Runtime.Internal.CSMFallbackConfigChain : object {
    private ILogger LOGGER;
    private static CredentialProfileStoreChain credentialProfileChain;
    [CompilerGeneratedAttribute]
private List`1<ConfigurationSource> <AllGenerators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConfigSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigSource>k__BackingField;
    [CompilerGeneratedAttribute]
private CSMConfiguration <CSMConfiguration>k__BackingField;
    public List`1<ConfigurationSource> AllGenerators { get; public set; }
    internal bool IsConfigSet { get; internal set; }
    public string ConfigSource { get; public set; }
    public CSMConfiguration CSMConfiguration { get; internal set; }
    private static CSMFallbackConfigChain();
    [CompilerGeneratedAttribute]
public List`1<ConfigurationSource> get_AllGenerators();
    [CompilerGeneratedAttribute]
public void set_AllGenerators(List`1<ConfigurationSource> value);
    [CompilerGeneratedAttribute]
internal bool get_IsConfigSet();
    [CompilerGeneratedAttribute]
internal void set_IsConfigSet(bool value);
    [CompilerGeneratedAttribute]
public string get_ConfigSource();
    [CompilerGeneratedAttribute]
public void set_ConfigSource(string value);
    [CompilerGeneratedAttribute]
public CSMConfiguration get_CSMConfiguration();
    [CompilerGeneratedAttribute]
internal void set_CSMConfiguration(CSMConfiguration value);
    public CSMConfiguration GetCSMConfig();
    [CompilerGeneratedAttribute]
private void <.ctor>b__19_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__19_1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__19_2();
}
public static class Amazon.Runtime.Internal.CSMUtilities : object {
    private static string requestKey;
    public static Task SerializetoJsonAndPostOverUDPAsync(MonitoringAPICall monitoringAPICall);
    public static void SerializetoJsonAndPostOverUDP(MonitoringAPICall monitoringAPICall);
    public static string GetApiNameFromRequest(string requestName, IDictionary`2<string, string> serviceApiNameMapping, string serviceName);
    private static bool CreateUDPMessage(MonitoringAPICallAttempt monitoringAPICallAttempt, String& response);
    private static bool CreateUDPMessage(MonitoringAPICallEvent monitoringAPICallEvent, String& response);
    private static JsonWriter CreateUDPMessage(MonitoringAPICall monitoringAPICall, JsonWriter jw);
}
public class Amazon.Runtime.Internal.DefaultConfigurationAutoModeResolver : object {
    private IRuntimeInformationProvider _runtimeInformationProvider;
    private IEnvironmentVariableRetriever _environmentVariableRetriever;
    public DefaultConfigurationAutoModeResolver(IRuntimeInformationProvider runtimeInformationProvider, IEnvironmentVariableRetriever environmentVariableRetriever);
    public sealed virtual DefaultConfigurationMode Resolve(RegionEndpoint clientRegion, Func`1<RegionEndpoint> imdsRegion);
    private DefaultConfigurationMode ResolveInternal(RegionEndpoint clientRegion, Func`1<RegionEndpoint> imdsRegion);
}
public class Amazon.Runtime.Internal.DefaultConfigurationProvider : object {
    private static string AWS_DEFAULTS_MODE_ENVIRONMENT_VARIABLE;
    private IEnvironmentVariableRetriever _environmentVariableRetriever;
    private IDefaultConfigurationAutoModeResolver _defaultConfigurationAutoModeResolver;
    private IDefaultConfiguration[] _availableConfigurations;
    public DefaultConfigurationProvider(IEnumerable`1<IDefaultConfiguration> availableConfigurations);
    public DefaultConfigurationProvider(IEnvironmentVariableRetriever environmentVariableRetriever, IDefaultConfigurationAutoModeResolver defaultConfigurationAutoModeResolver, IEnumerable`1<IDefaultConfiguration> availableConfigurations);
    public DefaultConfigurationProvider(IEnvironmentVariableRetriever environmentVariableRetriever, IDefaultConfigurationAutoModeResolver defaultConfigurationAutoModeResolver, IDefaultConfiguration[] availableConfigurations);
    public sealed virtual IDefaultConfiguration GetDefaultConfiguration(RegionEndpoint clientRegion, Nullable`1<DefaultConfigurationMode> requestedConfigurationMode);
}
public class Amazon.Runtime.Internal.DefaultRequest : object {
    private ParameterCollection parametersCollection;
    private IDictionary`2<string, string> parametersFacade;
    private IDictionary`2<string, string> headers;
    private IDictionary`2<string, string> trailingHeaders;
    private IDictionary`2<string, string> subResources;
    private IDictionary`2<string, string> pathResources;
    private Uri endpoint;
    private string resourcePath;
    private string serviceName;
    private AmazonWebServiceRequest originalRequest;
    private Byte[] content;
    private Stream contentStream;
    private string contentStreamHash;
    private string httpMethod;
    private bool useQueryString;
    private string requestName;
    private string canonicalResource;
    private RegionEndpoint alternateRegion;
    private long originalStreamLength;
    [CompilerGeneratedAttribute]
private bool <SetContentFromParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Suppress404Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AWS4SigningResult <AWS4SignerResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DisablePayloadSigning>k__BackingField;
    [CompilerGeneratedAttribute]
private AWS4aSigningResult <AWS4aSignerResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseChunkEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDoubleEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CanonicalResourcePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVersion <SignatureVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeterminedSigningRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OverrideSigningServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private CoreChecksumAlgorithm <SelectedChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionEncodingAlgorithm <CompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ChecksumData <ChecksumData>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertyBag <EndpointAttributes>k__BackingField;
    public string RequestName { get; }
    public string HttpMethod { get; public set; }
    public bool UseQueryString { get; public set; }
    public AmazonWebServiceRequest OriginalRequest { get; }
    public IDictionary`2<string, string> Headers { get; }
    public IDictionary`2<string, string> Parameters { get; }
    public ParameterCollection ParameterCollection { get; }
    public IDictionary`2<string, string> SubResources { get; }
    public Uri Endpoint { get; public set; }
    public string ResourcePath { get; public set; }
    public IDictionary`2<string, string> PathResources { get; }
    public string CanonicalResource { get; public set; }
    public Byte[] Content { get; public set; }
    public bool SetContentFromParameters { get; public set; }
    public Stream ContentStream { get; public set; }
    public long OriginalStreamPosition { get; public set; }
    public string ServiceName { get; }
    public RegionEndpoint AlternateEndpoint { get; public set; }
    public string HostPrefix { get; public set; }
    public bool Suppress404Exceptions { get; public set; }
    public AWS4SigningResult AWS4SignerResult { get; public set; }
    public Nullable`1<bool> DisablePayloadSigning { get; public set; }
    public AWS4aSigningResult AWS4aSignerResult { get; public set; }
    public bool UseChunkEncoding { get; public set; }
    public bool UseDoubleEncoding { get; public set; }
    public string CanonicalResourcePrefix { get; public set; }
    [ObsoleteAttribute("UseSigV4 is deprecated. Use SignatureVersion directly instead.")]
public bool UseSigV4 { get; public set; }
    public SignatureVersion SignatureVersion { get; public set; }
    public string AuthenticationRegion { get; public set; }
    public string DeterminedSigningRegion { get; public set; }
    public string OverrideSigningServiceName { get; public set; }
    public CoreChecksumAlgorithm SelectedChecksum { get; public set; }
    public IDictionary`2<string, string> TrailingHeaders { get; }
    public CompressionEncodingAlgorithm CompressionAlgorithm { get; public set; }
    public ChecksumData ChecksumData { get; public set; }
    public IPropertyBag EndpointAttributes { get; public set; }
    public DefaultRequest(AmazonWebServiceRequest request, string serviceName);
    public sealed virtual string get_RequestName();
    public sealed virtual string get_HttpMethod();
    public sealed virtual void set_HttpMethod(string value);
    public sealed virtual bool get_UseQueryString();
    public sealed virtual void set_UseQueryString(bool value);
    public sealed virtual AmazonWebServiceRequest get_OriginalRequest();
    public sealed virtual IDictionary`2<string, string> get_Headers();
    public sealed virtual IDictionary`2<string, string> get_Parameters();
    public sealed virtual ParameterCollection get_ParameterCollection();
    public sealed virtual IDictionary`2<string, string> get_SubResources();
    public sealed virtual void AddSubResource(string subResource);
    public sealed virtual void AddSubResource(string subResource, string value);
    public sealed virtual Uri get_Endpoint();
    public sealed virtual void set_Endpoint(Uri value);
    public sealed virtual string get_ResourcePath();
    public sealed virtual void set_ResourcePath(string value);
    public sealed virtual IDictionary`2<string, string> get_PathResources();
    public sealed virtual void AddPathResource(string key, string value);
    public string get_CanonicalResource();
    public void set_CanonicalResource(string value);
    public sealed virtual Byte[] get_Content();
    public sealed virtual void set_Content(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SetContentFromParameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SetContentFromParameters(bool value);
    public sealed virtual Stream get_ContentStream();
    public sealed virtual void set_ContentStream(Stream value);
    public sealed virtual long get_OriginalStreamPosition();
    public sealed virtual void set_OriginalStreamPosition(long value);
    public sealed virtual string ComputeContentStreamHash();
    public sealed virtual string get_ServiceName();
    public sealed virtual RegionEndpoint get_AlternateEndpoint();
    public sealed virtual void set_AlternateEndpoint(RegionEndpoint value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HostPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostPrefix(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Suppress404Exceptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Suppress404Exceptions(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual AWS4SigningResult get_AWS4SignerResult();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AWS4SignerResult(AWS4SigningResult value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_DisablePayloadSigning();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisablePayloadSigning(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual AWS4aSigningResult get_AWS4aSignerResult();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AWS4aSignerResult(AWS4aSigningResult value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseChunkEncoding();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseChunkEncoding(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseDoubleEncoding();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseDoubleEncoding(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CanonicalResourcePrefix();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CanonicalResourcePrefix(string value);
    public sealed virtual bool get_UseSigV4();
    public sealed virtual void set_UseSigV4(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual SignatureVersion get_SignatureVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SignatureVersion(SignatureVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AuthenticationRegion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AuthenticationRegion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeterminedSigningRegion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DeterminedSigningRegion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OverrideSigningServiceName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OverrideSigningServiceName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual CoreChecksumAlgorithm get_SelectedChecksum();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SelectedChecksum(CoreChecksumAlgorithm value);
    public sealed virtual IDictionary`2<string, string> get_TrailingHeaders();
    [CompilerGeneratedAttribute]
public sealed virtual CompressionEncodingAlgorithm get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CompressionAlgorithm(CompressionEncodingAlgorithm value);
    [CompilerGeneratedAttribute]
public sealed virtual ChecksumData get_ChecksumData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ChecksumData(ChecksumData value);
    public sealed virtual bool IsRequestStreamRewindable();
    public sealed virtual bool MayContainRequestBody();
    public sealed virtual bool HasRequestBody();
    public sealed virtual string GetHeaderValue(string headerName);
    [CompilerGeneratedAttribute]
public sealed virtual IPropertyBag get_EndpointAttributes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndpointAttributes(IPropertyBag value);
}
public class Amazon.Runtime.Internal.DefaultRetryPolicy : RetryPolicy {
    private static int INVALID_ENDPOINT_EXCEPTION_STATUSCODE;
    private static CapacityManager _capacityManagerInstance;
    private static HashSet`1<string> _netStandardRetryErrorMessages;
    [CompilerGeneratedAttribute]
private int <MaxBackoffInMilliseconds>k__BackingField;
    public int MaxBackoffInMilliseconds { get; public set; }
    public DefaultRetryPolicy(int maxRetries);
    public DefaultRetryPolicy(IClientConfig config);
    private static DefaultRetryPolicy();
    [CompilerGeneratedAttribute]
public int get_MaxBackoffInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_MaxBackoffInMilliseconds(int value);
    public virtual bool CanRetry(IExecutionContext executionContext);
    public virtual bool RetryForException(IExecutionContext executionContext, Exception exception);
    public virtual bool OnRetry(IExecutionContext executionContext);
    public virtual bool OnRetry(IExecutionContext executionContext, bool bypassAcquireCapacity);
    public virtual bool OnRetry(IExecutionContext executionContext, bool bypassAcquireCapacity, bool isThrottlingError);
    public virtual void NotifySuccess(IExecutionContext executionContext);
    private bool RetryForExceptionSync(Exception exception);
    private bool RetryForExceptionSync(Exception exception, IExecutionContext executionContext);
    public virtual bool RetryLimitReached(IExecutionContext executionContext);
    public virtual void WaitBeforeRetry(IExecutionContext executionContext);
    public static void WaitBeforeRetry(int retries, int maxBackoffInMilliseconds);
    private static int CalculateRetryDelay(int retries, int maxBackoffInMilliseconds);
    [ObsoleteAttribute("This method is no longer used within DefaultRetryPolicy")]
protected static bool ContainErrorMessage(Exception exception);
    [ObsoleteAttribute("This method has been moved to AWSSDK.Runtime.Internal.Util.ExceptionUtils")]
protected static bool IsInnerException(Exception exception);
    [ObsoleteAttribute("This method has been moved to AWSSDK.Runtime.Internal.Util.ExceptionUtils")]
protected static bool IsInnerException(Exception exception, T& inner);
    public virtual Task`1<bool> RetryForExceptionAsync(IExecutionContext executionContext, Exception exception);
    public virtual Task WaitBeforeRetryAsync(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.DeterminedCSMConfiguration : object {
    private static DeterminedCSMConfiguration instance;
    [CompilerGeneratedAttribute]
private CSMConfiguration <CSMConfiguration>k__BackingField;
    public CSMConfiguration CSMConfiguration { get; public set; }
    public static DeterminedCSMConfiguration Instance { get; }
    private static DeterminedCSMConfiguration();
    [CompilerGeneratedAttribute]
public CSMConfiguration get_CSMConfiguration();
    [CompilerGeneratedAttribute]
public void set_CSMConfiguration(CSMConfiguration value);
    public static DeterminedCSMConfiguration get_Instance();
}
public class Amazon.Runtime.Internal.DiscoveryEndpoint : DiscoveryEndpointBase {
    public DiscoveryEndpoint(string address, long cachePeriodInMinutes);
}
public abstract class Amazon.Runtime.Internal.DiscoveryEndpointBase : object {
    private DateTime _createdOn;
    private string _address;
    private long _cachePeriodInMinutes;
    private object objectExtendLock;
    public string Address { get; protected set; }
    public long CachePeriodInMinutes { get; protected set; }
    protected DiscoveryEndpointBase(string address, long cachePeriodInMinutes);
    public string get_Address();
    protected void set_Address(string value);
    public long get_CachePeriodInMinutes();
    protected void set_CachePeriodInMinutes(long value);
    public bool HasExpired();
    public void ExtendExpiration(long minutes);
}
public class Amazon.Runtime.Internal.EndpointDiscoveryData : EndpointDiscoveryDataBase {
    public EndpointDiscoveryData(bool required);
}
public abstract class Amazon.Runtime.Internal.EndpointDiscoveryDataBase : object {
    private bool _required;
    private SortedDictionary`2<string, string> _identifiers;
    public bool Required { get; protected set; }
    public SortedDictionary`2<string, string> Identifiers { get; protected set; }
    protected EndpointDiscoveryDataBase(bool required);
    public virtual bool get_Required();
    protected virtual void set_Required(bool value);
    public virtual SortedDictionary`2<string, string> get_Identifiers();
    protected virtual void set_Identifiers(SortedDictionary`2<string, string> value);
}
public class Amazon.Runtime.Internal.EndpointDiscoveryHandler : PipelineHandler {
    private static int INVALID_ENDPOINT_EXCEPTION_STATUSCODE;
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.EndpointDiscoveryHandler/<InvokeAsync>d__2`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected static void PreInvoke(IExecutionContext executionContext);
    public static void EvictCacheKeyForRequest(IRequestContext requestContext, Uri regionalEndpoint);
    public static void DiscoverEndpoints(IRequestContext requestContext, bool evictCacheKey);
    private static IEnumerable`1<DiscoveryEndpointBase> ProcessEndpointDiscovery(IRequestContext requestContext, bool evictCacheKey, Uri evictUri);
    private static bool IsInvalidEndpointException(Exception exception);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.EndpointDiscoveryResolver : EndpointDiscoveryResolverBase {
    public EndpointDiscoveryResolver(IClientConfig config, Logger logger);
}
public abstract class Amazon.Runtime.Internal.EndpointDiscoveryResolverBase : object {
    private IClientConfig _config;
    private Logger _logger;
    private LruCache`2<string, IList`1<DiscoveryEndpointBase>> _cache;
    private object objectCacheLock;
    private static int _cacheKeyValidityInSeconds;
    private bool _isServiceUrlSet;
    public int CacheCount { get; }
    protected EndpointDiscoveryResolverBase(IClientConfig config, Logger logger);
    public virtual IEnumerable`1<DiscoveryEndpointBase> ResolveEndpoints(EndpointOperationContextBase context, Func`1<IList`1<DiscoveryEndpointBase>> InvokeEndpointOperation);
    private IEnumerable`1<DiscoveryEndpointBase> ProcessInvokeEndpointOperation(string cacheKey, Func`1<IList`1<DiscoveryEndpointBase>> InvokeEndpointOperation, bool endpointRequired);
    public virtual IList`1<DiscoveryEndpointBase> GetDiscoveryEndpointsFromCache(string cacheKey);
    public virtual int get_CacheCount();
    private IEnumerable`1<DiscoveryEndpointBase> ProcessEndpointCache(string cacheKey, bool evictCacheKey, Uri evictUri, Boolean& refreshCache);
    private static string BuildEndpointDiscoveryCacheKey(EndpointOperationContextBase context);
}
public class Amazon.Runtime.Internal.EndpointOperationContext : EndpointOperationContextBase {
    public EndpointOperationContext(string customerCredentials, string operationName, EndpointDiscoveryDataBase endpointDiscoveryData, bool evictCacheKey, Uri evictUri);
}
public abstract class Amazon.Runtime.Internal.EndpointOperationContextBase : object {
    private string _customerCredentials;
    private string _operationName;
    private EndpointDiscoveryDataBase _endpointDiscoveryData;
    private bool _evictCacheKey;
    private Uri _evictUri;
    public string CustomerCredentials { get; protected set; }
    public string OperationName { get; protected set; }
    public EndpointDiscoveryDataBase EndpointDiscoveryData { get; protected set; }
    public bool EvictCacheKey { get; protected set; }
    public Uri EvictUri { get; protected set; }
    protected EndpointOperationContextBase(string customerCredentials, string operationName, EndpointDiscoveryDataBase endpointDiscoveryData, bool evictCacheKey, Uri evictUri);
    public virtual string get_CustomerCredentials();
    protected virtual void set_CustomerCredentials(string value);
    public virtual string get_OperationName();
    protected virtual void set_OperationName(string value);
    public virtual EndpointDiscoveryDataBase get_EndpointDiscoveryData();
    protected virtual void set_EndpointDiscoveryData(EndpointDiscoveryDataBase value);
    public virtual bool get_EvictCacheKey();
    protected virtual void set_EvictCacheKey(bool value);
    public virtual Uri get_EvictUri();
    protected virtual void set_EvictUri(Uri value);
}
public class Amazon.Runtime.Internal.EndpointOperationDelegate : MulticastDelegate {
    public EndpointOperationDelegate(object object, IntPtr method);
    public virtual IEnumerable`1<DiscoveryEndpointBase> Invoke(EndpointOperationContextBase context);
    public virtual IAsyncResult BeginInvoke(EndpointOperationContextBase context, AsyncCallback callback, object object);
    public virtual IEnumerable`1<DiscoveryEndpointBase> EndInvoke(IAsyncResult result);
}
public class Amazon.Runtime.Internal.EndpointResolver : PipelineHandler {
    public virtual void InvokeSync(IExecutionContext executionContext);
    public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected void PreInvoke(IExecutionContext executionContext);
    public virtual Uri DetermineEndpoint(IRequestContext requestContext);
    public static Uri DetermineEndpoint(IClientConfig config, IRequest request);
    private static Uri InjectHostPrefix(IClientConfig config, IRequest request, Uri endpoint);
}
public class Amazon.Runtime.Internal.Endpoints.StandardLibrary.Arn : PropertyBag {
    public string partition { get; public set; }
    public string service { get; public set; }
    public string region { get; public set; }
    public string accountId { get; public set; }
    public List`1<string> resourceId { get; public set; }
    public string get_partition();
    public void set_partition(string value);
    public string get_service();
    public void set_service(string value);
    public string get_region();
    public void set_region(string value);
    public string get_accountId();
    public void set_accountId(string value);
    public List`1<string> get_resourceId();
    public void set_resourceId(List`1<string> value);
    public static bool IsArn(string arn);
    public static bool TryParse(string arnString, Arn& arn);
    public static Arn Parse(string arnString);
}
public static class Amazon.Runtime.Internal.Endpoints.StandardLibrary.Fn : object {
    private static String[] SupportedSchemas;
    private static Fn();
    public static bool IsSet(object value);
    public static object GetAttr(object value, string path);
    public static Partition Partition(string region);
    public static Arn ParseArn(string arn);
    public static bool IsValidHostLabel(string hostLabel, bool allowSubDomains);
    private static bool IsVirtualHostableName(string name);
    public static bool IsVirtualHostableS3Bucket(string hostLabel, bool allowSubDomains);
    private static bool IsVirtualHostableS3Name(string name);
    private static bool IsIpV4Address(string name);
    public static string UriEncode(string value);
    public static URL ParseURL(string url);
    public static string Interpolate(string template, Dictionary`2<string, object> refs);
    public static string InterpolateJson(string json, Dictionary`2<string, object> refs);
    private static void InterpolateJson(JsonData json, Dictionary`2<string, object> refs);
    public static string Substring(string input, int start, int stop, bool reverse);
}
public class Amazon.Runtime.Internal.Endpoints.StandardLibrary.Partition : PropertyBag {
    private static ReaderWriterLockSlim _locker;
    private static Dictionary`2<string, PartitionAttributesShape> _partitionsByRegionName;
    private static Dictionary`2<string, PartitionAttributesShape> _partitionsByRegex;
    private static PartitionAttributesShape _defaultPartition;
    public string name { get; public set; }
    public string dnsSuffix { get; public set; }
    public string dualStackDnsSuffix { get; public set; }
    public bool supportsFIPS { get; public set; }
    public bool supportsDualStack { get; public set; }
    public string implicitGlobalRegion { get; public set; }
    private static Partition();
    public string get_name();
    public void set_name(string value);
    public string get_dnsSuffix();
    public void set_dnsSuffix(string value);
    public string get_dualStackDnsSuffix();
    public void set_dualStackDnsSuffix(string value);
    public bool get_supportsFIPS();
    public void set_supportsFIPS(bool value);
    public bool get_supportsDualStack();
    public void set_supportsDualStack(bool value);
    public string get_implicitGlobalRegion();
    public void set_implicitGlobalRegion(string value);
    internal static Partition FromPartitionData(PartitionAttributesShape data);
    public static void LoadPartitions(string partitionsFile);
    internal static Partition GetPartitionByRegion(string region);
}
public class Amazon.Runtime.Internal.Endpoints.StandardLibrary.PartitionAttributesShape : object {
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <dnsSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <dualStackDnsSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <supportsFIPS>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <supportsDualStack>k__BackingField;
    [CompilerGeneratedAttribute]
private string <implicitGlobalRegion>k__BackingField;
    public string name { get; public set; }
    public string dnsSuffix { get; public set; }
    public string dualStackDnsSuffix { get; public set; }
    public bool supportsFIPS { get; public set; }
    public bool supportsDualStack { get; public set; }
    public string implicitGlobalRegion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    [CompilerGeneratedAttribute]
public string get_dnsSuffix();
    [CompilerGeneratedAttribute]
public void set_dnsSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_dualStackDnsSuffix();
    [CompilerGeneratedAttribute]
public void set_dualStackDnsSuffix(string value);
    [CompilerGeneratedAttribute]
public bool get_supportsFIPS();
    [CompilerGeneratedAttribute]
public void set_supportsFIPS(bool value);
    [CompilerGeneratedAttribute]
public bool get_supportsDualStack();
    [CompilerGeneratedAttribute]
public void set_supportsDualStack(bool value);
    [CompilerGeneratedAttribute]
public string get_implicitGlobalRegion();
    [CompilerGeneratedAttribute]
public void set_implicitGlobalRegion(string value);
}
public class Amazon.Runtime.Internal.Endpoints.StandardLibrary.PartitionFunctionShape : object {
    [CompilerGeneratedAttribute]
private string <version>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PartitionShape> <partitions>k__BackingField;
    public string version { get; public set; }
    public List`1<PartitionShape> partitions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_version();
    [CompilerGeneratedAttribute]
public void set_version(string value);
    [CompilerGeneratedAttribute]
public List`1<PartitionShape> get_partitions();
    [CompilerGeneratedAttribute]
public void set_partitions(List`1<PartitionShape> value);
}
public class Amazon.Runtime.Internal.Endpoints.StandardLibrary.PartitionShape : object {
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <regionRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonData> <regions>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionAttributesShape <outputs>k__BackingField;
    public string id { get; public set; }
    public string regionRegex { get; public set; }
    public Dictionary`2<string, JsonData> regions { get; public set; }
    public PartitionAttributesShape outputs { get; public set; }
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_regionRegex();
    [CompilerGeneratedAttribute]
public void set_regionRegex(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonData> get_regions();
    [CompilerGeneratedAttribute]
public void set_regions(Dictionary`2<string, JsonData> value);
    [CompilerGeneratedAttribute]
public PartitionAttributesShape get_outputs();
    [CompilerGeneratedAttribute]
public void set_outputs(PartitionAttributesShape value);
}
public class Amazon.Runtime.Internal.Endpoints.StandardLibrary.URL : PropertyBag {
    public string scheme { get; public set; }
    public string authority { get; public set; }
    public string path { get; public set; }
    public string normalizedPath { get; public set; }
    public bool isIp { get; public set; }
    public string get_scheme();
    public void set_scheme(string value);
    public string get_authority();
    public void set_authority(string value);
    public string get_path();
    public void set_path(string value);
    public string get_normalizedPath();
    public void set_normalizedPath(string value);
    public bool get_isIp();
    public void set_isIp(bool value);
}
public class Amazon.Runtime.Internal.EnvironmentVariableCSMConfigs : object {
    private static string CSM_ENABLED;
    private static string CSM_CLIENTID;
    private static string CSM_HOST;
    private static string CSM_PORT;
    [CompilerGeneratedAttribute]
private IEnvironmentVariableRetriever <environmentRetriever>k__BackingField;
    private IEnvironmentVariableRetriever environmentRetriever { get; private set; }
    public EnvironmentVariableCSMConfigs(IEnvironmentVariableRetriever environmentRetriever, CSMFallbackConfigChain cSMFallbackConfigChain);
    public EnvironmentVariableCSMConfigs(CSMFallbackConfigChain cSMFallbackConfigChain);
    [CompilerGeneratedAttribute]
private IEnvironmentVariableRetriever get_environmentRetriever();
    [CompilerGeneratedAttribute]
private void set_environmentRetriever(IEnvironmentVariableRetriever value);
    private void SetupConfiguration(CSMFallbackConfigChain cSMFallbackConfigChain);
}
public class Amazon.Runtime.Internal.EnvironmentVariableInternalConfiguration : InternalConfiguration {
    private Logger _logger;
    public static string ENVIRONMENT_VARIABLE_AWS_ENABLE_ENDPOINT_DISCOVERY;
    public static string ENVIRONMENT_VARIABLE_AWS_MAX_ATTEMPTS;
    public static string ENVIRONMENT_VARIABLE_AWS_RETRY_MODE;
    public static string ENVIRONMENT_VARIABLE_AWS_EC2_METADATA_SERVICE_ENDPOINT;
    public static string ENVIRONMENT_VARIABLE_AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE;
    public static string ENVIRONMENT_VARIABLE_AWS_EC2_METADATA_V1_DISABLED;
    public static string ENVIRONMENT_VARIABLE_AWS_USE_DUALSTACK_ENDPOINT;
    public static string ENVIRONMENT_VARIABLE_AWS_USE_FIPS_ENDPOINT;
    public static string ENVIRONMENT_VARIABLE_AWS_IGNORE_CONFIGURED_ENDPOINT_URLS;
    public static string ENVIRONMENT_VARIABLE_AWS_DISABLE_REQUEST_COMPRESSION;
    public static string ENVIRONMENT_VARIABLE_AWS_REQUEST_MIN_COMPRESSION_SIZE_BYTES;
    public static string ENVIRONMENT_VARIABLE_AWS_SDK_UA_APP_ID;
    public static int AWS_SDK_UA_APP_ID_MAX_LENGTH;
    private bool GetEnvironmentVariable(string name, bool defaultValue);
    private bool TryGetEnvironmentVariable(string environmentVariableName, String& value);
    private Nullable`1<T> GetEnvironmentVariable(string name);
    private string GetEC2MetadataEndpointEnvironmentVariable();
    private string GetClientAppIdEnvironmentVariable();
}
public class Amazon.Runtime.Internal.ErrorCallbackHandler : PipelineHandler {
    [CompilerGeneratedAttribute]
private Action`2<IExecutionContext, Exception> <OnError>k__BackingField;
    public Action`2<IExecutionContext, Exception> OnError { get; public set; }
    [CompilerGeneratedAttribute]
public Action`2<IExecutionContext, Exception> get_OnError();
    [CompilerGeneratedAttribute]
public void set_OnError(Action`2<IExecutionContext, Exception> value);
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.ErrorCallbackHandler/<InvokeAsync>d__5`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected void HandleException(IExecutionContext executionContext, Exception exception);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.ErrorHandler : PipelineHandler {
    private IDictionary`2<Type, IExceptionHandler> _exceptionHandlers;
    public IDictionary`2<Type, IExceptionHandler> ExceptionHandlers { get; }
    public ErrorHandler(ILogger logger);
    public IDictionary`2<Type, IExceptionHandler> get_ExceptionHandlers();
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.ErrorHandler/<InvokeAsync>d__5`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    private static void DisposeReponse(IResponseContext responseContext);
    private bool ProcessException(IExecutionContext executionContext, Exception exception);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.ErrorHandler/<ProcessExceptionAsync>d__8")]
private Task`1<bool> ProcessExceptionAsync(IExecutionContext executionContext, Exception exception);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.ErrorResponse : object {
    [CompilerGeneratedAttribute]
private ErrorType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <InnerException>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    public ErrorType Type { get; public set; }
    public string Code { get; public set; }
    public string Message { get; public set; }
    public string RequestId { get; public set; }
    public Exception InnerException { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    [CompilerGeneratedAttribute]
public ErrorType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ErrorType value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(string value);
    [CompilerGeneratedAttribute]
public Exception get_InnerException();
    [CompilerGeneratedAttribute]
public void set_InnerException(Exception value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
}
public abstract class Amazon.Runtime.Internal.ExceptionHandler`1 : object {
    private ILogger _logger;
    protected ILogger Logger { get; }
    protected ExceptionHandler`1(ILogger logger);
    protected ILogger get_Logger();
    public sealed virtual bool Handle(IExecutionContext executionContext, Exception exception);
    public abstract virtual bool HandleException(IExecutionContext executionContext, T exception);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.ExceptionHandler`1/<HandleAsync>d__6")]
public sealed virtual Task`1<bool> HandleAsync(IExecutionContext executionContext, Exception exception);
    public abstract virtual Task`1<bool> HandleExceptionAsync(IExecutionContext executionContext, T exception);
}
public class Amazon.Runtime.Internal.ExecutionContext : object {
    [CompilerGeneratedAttribute]
private IRequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IResponseContext <ResponseContext>k__BackingField;
    public IRequestContext RequestContext { get; private set; }
    public IResponseContext ResponseContext { get; private set; }
    public ExecutionContext(bool enableMetrics, AbstractAWSSigner clientSigner);
    public ExecutionContext(IRequestContext requestContext, IResponseContext responseContext);
    [CompilerGeneratedAttribute]
public sealed virtual IRequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
private void set_RequestContext(IRequestContext value);
    [CompilerGeneratedAttribute]
public sealed virtual IResponseContext get_ResponseContext();
    [CompilerGeneratedAttribute]
private void set_ResponseContext(IResponseContext value);
    public static IExecutionContext CreateFromAsyncContext(IAsyncExecutionContext asyncContext);
}
public static class Amazon.Runtime.Internal.FallbackInternalConfigurationFactory : object {
    private static CredentialProfileStoreChain _credentialProfileChain;
    private static InternalConfiguration _cachedConfiguration;
    public static Nullable`1<bool> EndpointDiscoveryEnabled { get; }
    public static Nullable`1<RequestRetryMode> RetryMode { get; }
    public static Nullable`1<int> MaxAttempts { get; }
    public static string EC2MetadataServiceEndpoint { get; }
    public static Nullable`1<bool> EC2MetadataV1Disabled { get; }
    public static Nullable`1<EC2MetadataServiceEndpointMode> EC2MetadataServiceEndpointMode { get; }
    public static string DefaultConfigurationModeName { get; }
    public static Nullable`1<bool> UseDualStackEndpoint { get; }
    public static Nullable`1<bool> UseFIPSEndpoint { get; }
    public static Nullable`1<bool> IgnoreConfiguredEndpointUrls { get; }
    public static Nullable`1<bool> DisableRequestCompression { get; }
    public static Nullable`1<long> RequestMinCompressionSizeBytes { get; }
    public static string ClientAppId { get; }
    private static FallbackInternalConfigurationFactory();
    public static void Reset();
    private static Nullable`1<T> SeekValue(List`1<ConfigGenerator> generators, Func`2<InternalConfiguration, Nullable`1<T>> getValue);
    private static string SeekString(List`1<ConfigGenerator> generators, Func`2<InternalConfiguration, string> getValue, string defaultValue);
    public static Nullable`1<bool> get_EndpointDiscoveryEnabled();
    public static Nullable`1<RequestRetryMode> get_RetryMode();
    public static Nullable`1<int> get_MaxAttempts();
    public static string get_EC2MetadataServiceEndpoint();
    public static Nullable`1<bool> get_EC2MetadataV1Disabled();
    public static Nullable`1<EC2MetadataServiceEndpointMode> get_EC2MetadataServiceEndpointMode();
    public static string get_DefaultConfigurationModeName();
    public static Nullable`1<bool> get_UseDualStackEndpoint();
    public static Nullable`1<bool> get_UseFIPSEndpoint();
    public static Nullable`1<bool> get_IgnoreConfiguredEndpointUrls();
    public static Nullable`1<bool> get_DisableRequestCompression();
    public static Nullable`1<long> get_RequestMinCompressionSizeBytes();
    public static string get_ClientAppId();
}
public class Amazon.Runtime.Internal.HttpErrorResponseException : Exception {
    [CompilerGeneratedAttribute]
private IWebResponseData <Response>k__BackingField;
    public IWebResponseData Response { get; private set; }
    public HttpErrorResponseException(IWebResponseData response);
    public HttpErrorResponseException(string message, IWebResponseData response);
    public HttpErrorResponseException(string message, Exception innerException, IWebResponseData response);
    [CompilerGeneratedAttribute]
public IWebResponseData get_Response();
    [CompilerGeneratedAttribute]
private void set_Response(IWebResponseData value);
}
public class Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler : ExceptionHandler`1<HttpErrorResponseException> {
    public HttpErrorResponseExceptionHandler(ILogger logger);
    public virtual bool HandleException(IExecutionContext executionContext, HttpErrorResponseException exception);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler/<HandleExceptionAsync>d__2")]
public virtual Task`1<bool> HandleExceptionAsync(IExecutionContext executionContext, HttpErrorResponseException exception);
    private bool HandleExceptionStream(IRequestContext requestContext, IWebResponseData httpErrorResponse, HttpErrorResponseException exception, Stream responseStream);
    private bool HandleSuppressed404(IExecutionContext executionContext, IWebResponseData httpErrorResponse);
}
public class Amazon.Runtime.Internal.HttpHandler`1 : PipelineHandler {
    private bool _disposed;
    private IHttpRequestFactory`1<TRequestContent> _requestFactory;
    [CompilerGeneratedAttribute]
private object <CallbackSender>k__BackingField;
    public object CallbackSender { get; private set; }
    public HttpHandler`1(IHttpRequestFactory`1<TRequestContent> requestFactory, object callbackSender);
    [CompilerGeneratedAttribute]
public object get_CallbackSender();
    [CompilerGeneratedAttribute]
private void set_CallbackSender(object value);
    public virtual void InvokeSync(IExecutionContext executionContext);
    private static void CompleteFailedRequest(IHttpRequest`1<TRequestContent> httpRequest);
    private static void RecordHttpTelemetryData(IExecutionContext executionContext, TraceSpan traceSpan, IRequest request);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.HttpHandler`1/<InvokeAsync>d__10`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.HttpHandler`1/<CompleteFailedRequest>d__11")]
private static Task CompleteFailedRequest(IExecutionContext executionContext, IHttpRequest`1<TRequestContent> httpRequest);
    private static void SetMetrics(IRequestContext requestContext);
    private void WriteContentToRequestBody(TRequestContent requestContent, IHttpRequest`1<TRequestContent> httpRequest, IRequestContext requestContext);
    protected virtual IHttpRequest`1<TRequestContent> CreateWebRequest(IRequestContext requestContext);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static Stream GetInputStream(IRequestContext requestContext, Stream originalStream, IRequest wrappedRequest);
}
public interface Amazon.Runtime.Internal.IAmazonSecurityProtocolManager {
    public abstract virtual bool IsSecurityProtocolSystemDefault();
    public abstract virtual void UpdateProtocolsToSupported();
}
public interface Amazon.Runtime.Internal.IAmazonWebServiceRequest {
    public EventHandler`1<StreamTransferProgressArgs> StreamUploadProgressCallback { get; public set; }
    public Dictionary`2<string, object> RequestState { get; }
    [ObsoleteAttribute("UseSigV4 is deprecated. Use SignatureVersion directly instead.")]
public bool UseSigV4 { get; public set; }
    public SignatureVersion SignatureVersion { get; public set; }
    public abstract virtual EventHandler`1<StreamTransferProgressArgs> get_StreamUploadProgressCallback();
    public abstract virtual void set_StreamUploadProgressCallback(EventHandler`1<StreamTransferProgressArgs> value);
    public abstract virtual void AddBeforeRequestHandler(RequestEventHandler handler);
    public abstract virtual void RemoveBeforeRequestHandler(RequestEventHandler handler);
    public abstract virtual Dictionary`2<string, object> get_RequestState();
    public abstract virtual bool get_UseSigV4();
    public abstract virtual void set_UseSigV4(bool value);
    public abstract virtual SignatureVersion get_SignatureVersion();
    public abstract virtual void set_SignatureVersion(SignatureVersion value);
}
public interface Amazon.Runtime.Internal.IDefaultConfigurationAutoModeResolver {
    public abstract virtual DefaultConfigurationMode Resolve(RegionEndpoint clientRegion, Func`1<RegionEndpoint> imdsRegion);
}
public interface Amazon.Runtime.Internal.IDefaultConfigurationProvider {
    public abstract virtual IDefaultConfiguration GetDefaultConfiguration(RegionEndpoint clientRegion, Nullable`1<DefaultConfigurationMode> requestedConfigurationMode);
}
public class Amazon.Runtime.Internal.InternalConfiguration : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EndpointDiscoveryEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RequestRetryMode> <RetryMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EC2MetadataServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EC2MetadataV1Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<EC2MetadataServiceEndpointMode> <EC2MetadataServiceEndpointMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultConfigurationModeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseDualstackEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseFIPSEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IgnoreConfiguredEndpointUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DisableRequestCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RequestMinCompressionSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientAppId>k__BackingField;
    public Nullable`1<bool> EndpointDiscoveryEnabled { get; public set; }
    public Nullable`1<RequestRetryMode> RetryMode { get; public set; }
    public Nullable`1<int> MaxAttempts { get; public set; }
    public string EC2MetadataServiceEndpoint { get; public set; }
    public Nullable`1<bool> EC2MetadataV1Disabled { get; public set; }
    public Nullable`1<EC2MetadataServiceEndpointMode> EC2MetadataServiceEndpointMode { get; public set; }
    public string DefaultConfigurationModeName { get; public set; }
    public Nullable`1<bool> UseDualstackEndpoint { get; public set; }
    public Nullable`1<bool> UseFIPSEndpoint { get; public set; }
    public Nullable`1<bool> IgnoreConfiguredEndpointUrls { get; public set; }
    public Nullable`1<bool> DisableRequestCompression { get; public set; }
    public Nullable`1<long> RequestMinCompressionSizeBytes { get; public set; }
    public string ClientAppId { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EndpointDiscoveryEnabled();
    [CompilerGeneratedAttribute]
public void set_EndpointDiscoveryEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<RequestRetryMode> get_RetryMode();
    [CompilerGeneratedAttribute]
public void set_RetryMode(Nullable`1<RequestRetryMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxAttempts();
    [CompilerGeneratedAttribute]
public void set_MaxAttempts(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_EC2MetadataServiceEndpoint();
    [CompilerGeneratedAttribute]
public void set_EC2MetadataServiceEndpoint(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EC2MetadataV1Disabled();
    [CompilerGeneratedAttribute]
public void set_EC2MetadataV1Disabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<EC2MetadataServiceEndpointMode> get_EC2MetadataServiceEndpointMode();
    [CompilerGeneratedAttribute]
public void set_EC2MetadataServiceEndpointMode(Nullable`1<EC2MetadataServiceEndpointMode> value);
    [CompilerGeneratedAttribute]
public string get_DefaultConfigurationModeName();
    [CompilerGeneratedAttribute]
public void set_DefaultConfigurationModeName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseDualstackEndpoint();
    [CompilerGeneratedAttribute]
public void set_UseDualstackEndpoint(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseFIPSEndpoint();
    [CompilerGeneratedAttribute]
public void set_UseFIPSEndpoint(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IgnoreConfiguredEndpointUrls();
    [CompilerGeneratedAttribute]
public void set_IgnoreConfiguredEndpointUrls(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DisableRequestCompression();
    [CompilerGeneratedAttribute]
public void set_DisableRequestCompression(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RequestMinCompressionSizeBytes();
    [CompilerGeneratedAttribute]
public void set_RequestMinCompressionSizeBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_ClientAppId();
    [CompilerGeneratedAttribute]
public void set_ClientAppId(string value);
}
public class Amazon.Runtime.Internal.InvokeOptions : InvokeOptionsBase {
}
public abstract class Amazon.Runtime.Internal.InvokeOptionsBase : object {
    private IMarshaller`2<IRequest, AmazonWebServiceRequest> _requestMarshaller;
    private ResponseUnmarshaller _responseUnmarshaller;
    private IMarshaller`2<EndpointDiscoveryDataBase, AmazonWebServiceRequest> _endpointDiscoveryMarshaller;
    private EndpointOperationDelegate _endpointOperation;
    public IMarshaller`2<IRequest, AmazonWebServiceRequest> RequestMarshaller { get; public set; }
    public ResponseUnmarshaller ResponseUnmarshaller { get; public set; }
    public IMarshaller`2<EndpointDiscoveryDataBase, AmazonWebServiceRequest> EndpointDiscoveryMarshaller { get; public set; }
    public EndpointOperationDelegate EndpointOperation { get; public set; }
    public virtual IMarshaller`2<IRequest, AmazonWebServiceRequest> get_RequestMarshaller();
    public virtual void set_RequestMarshaller(IMarshaller`2<IRequest, AmazonWebServiceRequest> value);
    public virtual ResponseUnmarshaller get_ResponseUnmarshaller();
    public virtual void set_ResponseUnmarshaller(ResponseUnmarshaller value);
    public virtual IMarshaller`2<EndpointDiscoveryDataBase, AmazonWebServiceRequest> get_EndpointDiscoveryMarshaller();
    public virtual void set_EndpointDiscoveryMarshaller(IMarshaller`2<EndpointDiscoveryDataBase, AmazonWebServiceRequest> value);
    public virtual EndpointOperationDelegate get_EndpointOperation();
    public virtual void set_EndpointOperation(EndpointOperationDelegate value);
}
public interface Amazon.Runtime.Internal.IRequest {
    public string RequestName { get; }
    public IDictionary`2<string, string> Headers { get; }
    public bool UseQueryString { get; public set; }
    public IDictionary`2<string, string> Parameters { get; }
    public ParameterCollection ParameterCollection { get; }
    public IDictionary`2<string, string> SubResources { get; }
    public string HttpMethod { get; public set; }
    public Uri Endpoint { get; public set; }
    public string ResourcePath { get; public set; }
    public IDictionary`2<string, string> PathResources { get; }
    public Byte[] Content { get; public set; }
    public bool SetContentFromParameters { get; public set; }
    public Stream ContentStream { get; public set; }
    public long OriginalStreamPosition { get; public set; }
    public string OverrideSigningServiceName { get; public set; }
    public string ServiceName { get; }
    public AmazonWebServiceRequest OriginalRequest { get; }
    public RegionEndpoint AlternateEndpoint { get; public set; }
    public string HostPrefix { get; public set; }
    public bool Suppress404Exceptions { get; public set; }
    public AWS4SigningResult AWS4SignerResult { get; public set; }
    public Nullable`1<bool> DisablePayloadSigning { get; public set; }
    public AWS4aSigningResult AWS4aSignerResult { get; public set; }
    public bool UseChunkEncoding { get; public set; }
    public string CanonicalResourcePrefix { get; public set; }
    [ObsoleteAttribute("UseSigV4 is deprecated. Use SignatureVersion directly instead.")]
public bool UseSigV4 { get; public set; }
    public SignatureVersion SignatureVersion { get; public set; }
    public string AuthenticationRegion { get; public set; }
    public string DeterminedSigningRegion { get; public set; }
    public CoreChecksumAlgorithm SelectedChecksum { get; public set; }
    public IDictionary`2<string, string> TrailingHeaders { get; }
    public bool UseDoubleEncoding { get; public set; }
    public IPropertyBag EndpointAttributes { get; public set; }
    public CompressionEncodingAlgorithm CompressionAlgorithm { get; public set; }
    public ChecksumData ChecksumData { get; public set; }
    public abstract virtual string get_RequestName();
    public abstract virtual IDictionary`2<string, string> get_Headers();
    public abstract virtual bool get_UseQueryString();
    public abstract virtual void set_UseQueryString(bool value);
    public abstract virtual IDictionary`2<string, string> get_Parameters();
    public abstract virtual ParameterCollection get_ParameterCollection();
    public abstract virtual IDictionary`2<string, string> get_SubResources();
    public abstract virtual void AddSubResource(string subResource);
    public abstract virtual void AddSubResource(string subResource, string value);
    public abstract virtual string get_HttpMethod();
    public abstract virtual void set_HttpMethod(string value);
    public abstract virtual Uri get_Endpoint();
    public abstract virtual void set_Endpoint(Uri value);
    public abstract virtual string get_ResourcePath();
    public abstract virtual void set_ResourcePath(string value);
    public abstract virtual IDictionary`2<string, string> get_PathResources();
    public abstract virtual void AddPathResource(string key, string value);
    public abstract virtual Byte[] get_Content();
    public abstract virtual void set_Content(Byte[] value);
    public abstract virtual string GetHeaderValue(string headerName);
    public abstract virtual bool get_SetContentFromParameters();
    public abstract virtual void set_SetContentFromParameters(bool value);
    public abstract virtual Stream get_ContentStream();
    public abstract virtual void set_ContentStream(Stream value);
    public abstract virtual long get_OriginalStreamPosition();
    public abstract virtual void set_OriginalStreamPosition(long value);
    public abstract virtual string ComputeContentStreamHash();
    public abstract virtual string get_OverrideSigningServiceName();
    public abstract virtual void set_OverrideSigningServiceName(string value);
    public abstract virtual string get_ServiceName();
    public abstract virtual AmazonWebServiceRequest get_OriginalRequest();
    public abstract virtual RegionEndpoint get_AlternateEndpoint();
    public abstract virtual void set_AlternateEndpoint(RegionEndpoint value);
    public abstract virtual string get_HostPrefix();
    public abstract virtual void set_HostPrefix(string value);
    public abstract virtual bool get_Suppress404Exceptions();
    public abstract virtual void set_Suppress404Exceptions(bool value);
    public abstract virtual AWS4SigningResult get_AWS4SignerResult();
    public abstract virtual void set_AWS4SignerResult(AWS4SigningResult value);
    public abstract virtual Nullable`1<bool> get_DisablePayloadSigning();
    public abstract virtual void set_DisablePayloadSigning(Nullable`1<bool> value);
    public abstract virtual AWS4aSigningResult get_AWS4aSignerResult();
    public abstract virtual void set_AWS4aSignerResult(AWS4aSigningResult value);
    public abstract virtual bool get_UseChunkEncoding();
    public abstract virtual void set_UseChunkEncoding(bool value);
    public abstract virtual string get_CanonicalResourcePrefix();
    public abstract virtual void set_CanonicalResourcePrefix(string value);
    public abstract virtual bool get_UseSigV4();
    public abstract virtual void set_UseSigV4(bool value);
    public abstract virtual SignatureVersion get_SignatureVersion();
    public abstract virtual void set_SignatureVersion(SignatureVersion value);
    public abstract virtual string get_AuthenticationRegion();
    public abstract virtual void set_AuthenticationRegion(string value);
    public abstract virtual string get_DeterminedSigningRegion();
    public abstract virtual void set_DeterminedSigningRegion(string value);
    public abstract virtual bool IsRequestStreamRewindable();
    public abstract virtual bool MayContainRequestBody();
    public abstract virtual bool HasRequestBody();
    public abstract virtual CoreChecksumAlgorithm get_SelectedChecksum();
    public abstract virtual void set_SelectedChecksum(CoreChecksumAlgorithm value);
    public abstract virtual IDictionary`2<string, string> get_TrailingHeaders();
    public abstract virtual bool get_UseDoubleEncoding();
    public abstract virtual void set_UseDoubleEncoding(bool value);
    public abstract virtual IPropertyBag get_EndpointAttributes();
    public abstract virtual void set_EndpointAttributes(IPropertyBag value);
    public abstract virtual CompressionEncodingAlgorithm get_CompressionAlgorithm();
    public abstract virtual void set_CompressionAlgorithm(CompressionEncodingAlgorithm value);
    public abstract virtual ChecksumData get_ChecksumData();
    public abstract virtual void set_ChecksumData(ChecksumData value);
}
public interface Amazon.Runtime.Internal.IRequestData {
    public ResponseUnmarshaller Unmarshaller { get; }
    public RequestMetrics Metrics { get; }
    public IRequest Request { get; }
    public AbstractAWSSigner Signer { get; }
    public int RetriesAttempt { get; }
    public abstract virtual ResponseUnmarshaller get_Unmarshaller();
    public abstract virtual RequestMetrics get_Metrics();
    public abstract virtual IRequest get_Request();
    public abstract virtual AbstractAWSSigner get_Signer();
    public abstract virtual int get_RetriesAttempt();
}
public interface Amazon.Runtime.Internal.IRuntimeInformationProvider {
    public abstract virtual bool IsMobile();
}
public interface Amazon.Runtime.Internal.IRuntimePipelineCustomizer {
    public string UniqueName { get; }
    public abstract virtual string get_UniqueName();
    public abstract virtual void Customize(Type type, RuntimePipeline pipeline);
}
public interface Amazon.Runtime.Internal.IServiceMetadata {
    public string ServiceId { get; }
    public IDictionary`2<string, string> OperationNameMapping { get; }
    public abstract virtual string get_ServiceId();
    public abstract virtual IDictionary`2<string, string> get_OperationNameMapping();
}
public class Amazon.Runtime.Internal.Marshaller : PipelineHandler {
    public virtual void InvokeSync(IExecutionContext executionContext);
    public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected static void PreInvoke(IExecutionContext executionContext);
    private static void SetRecursionDetectionHeader(IDictionary`2<string, string> headers);
    private static void SetUserAgentHeader(IRequestContext requestContext);
}
public class Amazon.Runtime.Internal.MetricsHandler : PipelineHandler {
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.MetricsHandler/<InvokeAsync>d__1`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.MonitoringAPICall : object {
    [CompilerGeneratedAttribute]
private string <Api>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    public string Api { get; internal set; }
    public string Service { get; internal set; }
    public string ClientId { get; internal set; }
    public long Timestamp { get; internal set; }
    public string Type { get; internal set; }
    public int Version { get; internal set; }
    public string Region { get; internal set; }
    public string UserAgent { get; internal set; }
    public MonitoringAPICall(IRequestContext requestContext);
    [CompilerGeneratedAttribute]
public string get_Api();
    [CompilerGeneratedAttribute]
internal void set_Api(string value);
    [CompilerGeneratedAttribute]
public string get_Service();
    [CompilerGeneratedAttribute]
internal void set_Service(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
internal void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
internal void set_Timestamp(long value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(string value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
internal void set_Region(string value);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
internal void set_UserAgent(string value);
}
public class Amazon.Runtime.Internal.MonitoringAPICallAttempt : MonitoringAPICall {
    [CompilerGeneratedAttribute]
private string <Fqdn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <HttpStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AWSException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AWSExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XAmznRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XAmzRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XAmzId2>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AttemptLatency>k__BackingField;
    public string Fqdn { get; internal set; }
    public string SessionToken { get; internal set; }
    public string AccessKey { get; internal set; }
    public Nullable`1<int> HttpStatusCode { get; internal set; }
    public string SdkExceptionMessage { get; internal set; }
    public string SdkException { get; internal set; }
    public string AWSException { get; internal set; }
    public string AWSExceptionMessage { get; internal set; }
    public string XAmznRequestId { get; internal set; }
    public string XAmzRequestId { get; internal set; }
    public string XAmzId2 { get; internal set; }
    public long AttemptLatency { get; internal set; }
    public MonitoringAPICallAttempt(IRequestContext requestContext);
    [CompilerGeneratedAttribute]
public string get_Fqdn();
    [CompilerGeneratedAttribute]
internal void set_Fqdn(string value);
    [CompilerGeneratedAttribute]
public string get_SessionToken();
    [CompilerGeneratedAttribute]
internal void set_SessionToken(string value);
    [CompilerGeneratedAttribute]
public string get_AccessKey();
    [CompilerGeneratedAttribute]
internal void set_AccessKey(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_HttpStatusCode();
    [CompilerGeneratedAttribute]
internal void set_HttpStatusCode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_SdkExceptionMessage();
    [CompilerGeneratedAttribute]
internal void set_SdkExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public string get_SdkException();
    [CompilerGeneratedAttribute]
internal void set_SdkException(string value);
    [CompilerGeneratedAttribute]
public string get_AWSException();
    [CompilerGeneratedAttribute]
internal void set_AWSException(string value);
    [CompilerGeneratedAttribute]
public string get_AWSExceptionMessage();
    [CompilerGeneratedAttribute]
internal void set_AWSExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public string get_XAmznRequestId();
    [CompilerGeneratedAttribute]
internal void set_XAmznRequestId(string value);
    [CompilerGeneratedAttribute]
public string get_XAmzRequestId();
    [CompilerGeneratedAttribute]
internal void set_XAmzRequestId(string value);
    [CompilerGeneratedAttribute]
public string get_XAmzId2();
    [CompilerGeneratedAttribute]
internal void set_XAmzId2(string value);
    [CompilerGeneratedAttribute]
public long get_AttemptLatency();
    [CompilerGeneratedAttribute]
internal void set_AttemptLatency(long value);
}
public class Amazon.Runtime.Internal.MonitoringAPICallEvent : MonitoringAPICall {
    [CompilerGeneratedAttribute]
private int <AttemptCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Latency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastExceptionRetryable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FinalSdkExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FinalSdkException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FinalAWSException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FinalAWSExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FinalHttpStatusCode>k__BackingField;
    public int AttemptCount { get; internal set; }
    public long Latency { get; internal set; }
    public bool IsLastExceptionRetryable { get; internal set; }
    public string FinalSdkExceptionMessage { get; internal set; }
    public string FinalSdkException { get; internal set; }
    public string FinalAWSException { get; internal set; }
    public string FinalAWSExceptionMessage { get; internal set; }
    public Nullable`1<int> FinalHttpStatusCode { get; internal set; }
    public MonitoringAPICallEvent(IRequestContext requestContext);
    [CompilerGeneratedAttribute]
public int get_AttemptCount();
    [CompilerGeneratedAttribute]
internal void set_AttemptCount(int value);
    [CompilerGeneratedAttribute]
public long get_Latency();
    [CompilerGeneratedAttribute]
internal void set_Latency(long value);
    [CompilerGeneratedAttribute]
public bool get_IsLastExceptionRetryable();
    [CompilerGeneratedAttribute]
internal void set_IsLastExceptionRetryable(bool value);
    [CompilerGeneratedAttribute]
public string get_FinalSdkExceptionMessage();
    [CompilerGeneratedAttribute]
internal void set_FinalSdkExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public string get_FinalSdkException();
    [CompilerGeneratedAttribute]
internal void set_FinalSdkException(string value);
    [CompilerGeneratedAttribute]
public string get_FinalAWSException();
    [CompilerGeneratedAttribute]
internal void set_FinalAWSException(string value);
    [CompilerGeneratedAttribute]
public string get_FinalAWSExceptionMessage();
    [CompilerGeneratedAttribute]
internal void set_FinalAWSExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FinalHttpStatusCode();
    [CompilerGeneratedAttribute]
internal void set_FinalHttpStatusCode(Nullable`1<int> value);
}
public class Amazon.Runtime.Internal.ParameterCollection : SortedDictionary`2<string, ParameterValue> {
    public void Add(string key, string value);
    public void Add(string key, List`1<string> values);
    public void Add(string key, List`1<double> values);
    public List`1<KeyValuePair`2<string, string>> GetSortedParametersList();
    [IteratorStateMachineAttribute("Amazon.Runtime.Internal.ParameterCollection/<GetParametersEnumerable>d__5")]
internal IEnumerable`1<KeyValuePair`2<string, string>> GetParametersEnumerable();
}
[DefaultMemberAttribute("Item")]
public class Amazon.Runtime.Internal.ParametersDictionaryFacade : object {
    private ParameterCollection _parameterCollection;
    public int Count { get; }
    public string Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<string> Values { get; }
    public bool IsReadOnly { get; }
    public ParametersDictionaryFacade(ParameterCollection collection);
    private static string ParameterValueToString(ParameterValue pv);
    private static void UpdateParameterValue(ParameterValue pv, string newValue);
    public sealed virtual void Add(string key, string value);
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual bool TryGetValue(string key, String& value);
    public sealed virtual bool Remove(KeyValuePair`2<string, string> item);
    public sealed virtual ICollection`1<string> get_Values();
    public sealed virtual void Add(KeyValuePair`2<string, string> item);
    public sealed virtual bool Contains(KeyValuePair`2<string, string> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    [IteratorStateMachineAttribute("Amazon.Runtime.Internal.ParametersDictionaryFacade/<GetEnumerator>d__23")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Clear();
}
public abstract class Amazon.Runtime.Internal.PipelineHandler : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IPipelineHandler <InnerHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private IPipelineHandler <OuterHandler>k__BackingField;
    public ILogger Logger { get; public set; }
    public IPipelineHandler InnerHandler { get; public set; }
    public IPipelineHandler OuterHandler { get; public set; }
    [CompilerGeneratedAttribute]
public virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public virtual void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public sealed virtual IPipelineHandler get_InnerHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InnerHandler(IPipelineHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual IPipelineHandler get_OuterHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OuterHandler(IPipelineHandler value);
    public virtual void InvokeSync(IExecutionContext executionContext);
    public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected void LogMetrics(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.ProcessCredentialVersion1 : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessKeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecretAccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionToken>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiration>k__BackingField;
    [JsonPropertyAttribute]
public int Version { get; public set; }
    [JsonPropertyAttribute]
public string AccessKeyId { get; public set; }
    [JsonPropertyAttribute]
public string SecretAccessKey { get; public set; }
    public string SessionToken { get; public set; }
    public DateTime Expiration { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_AccessKeyId();
    [CompilerGeneratedAttribute]
public void set_AccessKeyId(string value);
    [CompilerGeneratedAttribute]
public string get_SecretAccessKey();
    [CompilerGeneratedAttribute]
public void set_SecretAccessKey(string value);
    [CompilerGeneratedAttribute]
public string get_SessionToken();
    [CompilerGeneratedAttribute]
public void set_SessionToken(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Expiration();
    [CompilerGeneratedAttribute]
public void set_Expiration(DateTime value);
}
public class Amazon.Runtime.Internal.ProfileCSMConfigs : object {
    private static string CSM_ENABLED;
    private static string CSM_CLIENTID;
    private static string CSM_HOST;
    private static string CSM_PORT;
    private static string CSM_PROFILE_ERROR_MSG;
    [CompilerGeneratedAttribute]
private string <ProfileName>k__BackingField;
    private string ProfileName { get; private set; }
    public ProfileCSMConfigs(CSMFallbackConfigChain cSMFallbackConfigChain, string profileName, IDictionary`2<string, string> profileProperties);
    public ProfileCSMConfigs(ICredentialProfileSource source, CSMFallbackConfigChain cSMFallbackConfigChain);
    [CompilerGeneratedAttribute]
private string get_ProfileName();
    [CompilerGeneratedAttribute]
private void set_ProfileName(string value);
    private void Setup(CSMFallbackConfigChain cSMFallbackConfigChain, IDictionary`2<string, string> profileProperties);
}
public class Amazon.Runtime.Internal.ProfileInternalConfiguration : InternalConfiguration {
    private Logger _logger;
    public ProfileInternalConfiguration(ICredentialProfileSource source);
    public ProfileInternalConfiguration(ICredentialProfileSource source, string profileName);
    private void Setup(ICredentialProfileSource source, string profileName);
}
public class Amazon.Runtime.Internal.RedirectHandler : PipelineHandler {
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.RedirectHandler/<InvokeAsync>d__1`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    private bool HandleRedirect(IExecutionContext executionContext);
    protected virtual void FinalizeForRedirect(IExecutionContext executionContext, string redirectedLocation);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.RequestContext : object {
    private IServiceMetadata _serviceMetadata;
    private AbstractAWSSigner clientSigner;
    private IDictionary`2<string, object> _contextAttributes;
    [CompilerGeneratedAttribute]
private IRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestMetrics <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IClientConfig <ClientConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private CapacityType <LastCapacityType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndpointDiscoveryRetries>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSigned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private AmazonWebServiceRequest <OriginalRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private IMarshaller`2<IRequest, AmazonWebServiceRequest> <Marshaller>k__BackingField;
    [CompilerGeneratedAttribute]
private ResponseUnmarshaller <Unmarshaller>k__BackingField;
    [CompilerGeneratedAttribute]
private InvokeOptionsBase <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableCredentials <ImmutableCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private MonitoringAPICallAttempt <CSMCallAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private MonitoringAPICallEvent <CSMCallEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CSMEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastExceptionRetryable>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InvocationId>k__BackingField;
    public IRequest Request { get; public set; }
    public RequestMetrics Metrics { get; private set; }
    public IClientConfig ClientConfig { get; public set; }
    public int Retries { get; public set; }
    public CapacityType LastCapacityType { get; public set; }
    public int EndpointDiscoveryRetries { get; public set; }
    public bool IsSigned { get; public set; }
    public bool IsAsync { get; public set; }
    public AmazonWebServiceRequest OriginalRequest { get; public set; }
    public IMarshaller`2<IRequest, AmazonWebServiceRequest> Marshaller { get; public set; }
    public ResponseUnmarshaller Unmarshaller { get; public set; }
    public InvokeOptionsBase Options { get; public set; }
    public ImmutableCredentials ImmutableCredentials { get; public set; }
    public AbstractAWSSigner Signer { get; }
    public CancellationToken CancellationToken { get; public set; }
    public string RequestName { get; }
    public MonitoringAPICallAttempt CSMCallAttempt { get; public set; }
    public MonitoringAPICallEvent CSMCallEvent { get; public set; }
    public IServiceMetadata ServiceMetaData { get; internal set; }
    public bool CSMEnabled { get; private set; }
    public bool IsLastExceptionRetryable { get; public set; }
    public Guid InvocationId { get; private set; }
    public IDictionary`2<string, object> ContextAttributes { get; }
    public RequestContext(bool enableMetrics, AbstractAWSSigner clientSigner);
    [CompilerGeneratedAttribute]
public sealed virtual IRequest get_Request();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Request(IRequest value);
    [CompilerGeneratedAttribute]
public sealed virtual RequestMetrics get_Metrics();
    [CompilerGeneratedAttribute]
private void set_Metrics(RequestMetrics value);
    [CompilerGeneratedAttribute]
public sealed virtual IClientConfig get_ClientConfig();
    [CompilerGeneratedAttribute]
public void set_ClientConfig(IClientConfig value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Retries();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Retries(int value);
    [CompilerGeneratedAttribute]
public sealed virtual CapacityType get_LastCapacityType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastCapacityType(CapacityType value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndpointDiscoveryRetries();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndpointDiscoveryRetries(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSigned();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsSigned(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    [CompilerGeneratedAttribute]
public void set_IsAsync(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual AmazonWebServiceRequest get_OriginalRequest();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OriginalRequest(AmazonWebServiceRequest value);
    [CompilerGeneratedAttribute]
public sealed virtual IMarshaller`2<IRequest, AmazonWebServiceRequest> get_Marshaller();
    [CompilerGeneratedAttribute]
public void set_Marshaller(IMarshaller`2<IRequest, AmazonWebServiceRequest> value);
    [CompilerGeneratedAttribute]
public sealed virtual ResponseUnmarshaller get_Unmarshaller();
    [CompilerGeneratedAttribute]
public void set_Unmarshaller(ResponseUnmarshaller value);
    [CompilerGeneratedAttribute]
public sealed virtual InvokeOptionsBase get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(InvokeOptionsBase value);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableCredentials get_ImmutableCredentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ImmutableCredentials(ImmutableCredentials value);
    public sealed virtual AbstractAWSSigner get_Signer();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    public sealed virtual string get_RequestName();
    [CompilerGeneratedAttribute]
public sealed virtual MonitoringAPICallAttempt get_CSMCallAttempt();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CSMCallAttempt(MonitoringAPICallAttempt value);
    [CompilerGeneratedAttribute]
public sealed virtual MonitoringAPICallEvent get_CSMCallEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CSMCallEvent(MonitoringAPICallEvent value);
    public sealed virtual IServiceMetadata get_ServiceMetaData();
    internal void set_ServiceMetaData(IServiceMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CSMEnabled();
    [CompilerGeneratedAttribute]
private void set_CSMEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLastExceptionRetryable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsLastExceptionRetryable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_InvocationId();
    [CompilerGeneratedAttribute]
private void set_InvocationId(Guid value);
    public sealed virtual IDictionary`2<string, object> get_ContextAttributes();
}
public class Amazon.Runtime.Internal.ResponseContext : object {
    [CompilerGeneratedAttribute]
private AmazonWebServiceResponse <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebResponseData <HttpResponse>k__BackingField;
    public AmazonWebServiceResponse Response { get; public set; }
    public IWebResponseData HttpResponse { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual AmazonWebServiceResponse get_Response();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Response(AmazonWebServiceResponse value);
    [CompilerGeneratedAttribute]
public sealed virtual IWebResponseData get_HttpResponse();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HttpResponse(IWebResponseData value);
}
public class Amazon.Runtime.Internal.RetryCapacity : object {
    private int _maxCapacity;
    [CompilerGeneratedAttribute]
private int <AvailableCapacity>k__BackingField;
    public int AvailableCapacity { get; public set; }
    public int MaxCapacity { get; }
    public RetryCapacity(int maxCapacity);
    [CompilerGeneratedAttribute]
public int get_AvailableCapacity();
    [CompilerGeneratedAttribute]
public void set_AvailableCapacity(int value);
    public int get_MaxCapacity();
}
public class Amazon.Runtime.Internal.RetryHandler : PipelineHandler {
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private RetryPolicy <RetryPolicy>k__BackingField;
    public ILogger Logger { get; public set; }
    public RetryPolicy RetryPolicy { get; private set; }
    public RetryHandler(RetryPolicy retryPolicy);
    public virtual ILogger get_Logger();
    public virtual void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public RetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private void set_RetryPolicy(RetryPolicy value);
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.RetryHandler/<InvokeAsync>d__10`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    internal static void PrepareForRetry(IRequestContext requestContext);
    private void LogForRetry(IRequestContext requestContext, Exception exception);
    private void LogForError(IRequestContext requestContext, Exception exception);
    private void SetRetryHeaders(IRequestContext requestContext);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.RuntimeInformationProvider : object {
    public sealed virtual bool IsMobile();
}
public class Amazon.Runtime.Internal.RuntimePipeline : object {
    private bool _disposed;
    private ILogger _logger;
    private IPipelineHandler _handler;
    public IPipelineHandler Handler { get; }
    public List`1<IPipelineHandler> Handlers { get; }
    public RuntimePipeline(IPipelineHandler handler);
    public RuntimePipeline(IList`1<IPipelineHandler> handlers);
    public RuntimePipeline(IList`1<IPipelineHandler> handlers, ILogger logger);
    public RuntimePipeline(IPipelineHandler handler, ILogger logger);
    public IPipelineHandler get_Handler();
    public IResponseContext InvokeSync(IExecutionContext executionContext);
    public Task`1<T> InvokeAsync(IExecutionContext executionContext);
    public void AddHandler(IPipelineHandler handler);
    public void AddHandlerAfter(IPipelineHandler handler);
    public void AddHandlerBefore(IPipelineHandler handler);
    public void RemoveHandler();
    public void ReplaceHandler(IPipelineHandler handler);
    private static void InsertHandler(IPipelineHandler handler, IPipelineHandler current);
    private static IPipelineHandler GetInnermostHandler(IPipelineHandler handler);
    private void SetHandlerProperties(IPipelineHandler handler);
    public List`1<IPipelineHandler> get_Handlers();
    [IteratorStateMachineAttribute("Amazon.Runtime.Internal.RuntimePipeline/<EnumerateHandlers>d__21")]
public IEnumerable`1<IPipelineHandler> EnumerateHandlers();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
}
public class Amazon.Runtime.Internal.RuntimePipelineCustomizerRegistry : object {
    [CompilerGeneratedAttribute]
private static RuntimePipelineCustomizerRegistry <Instance>k__BackingField;
    private Logger _logger;
    private ReaderWriterLockSlim _rwlock;
    private IList`1<IRuntimePipelineCustomizer> _customizers;
    public static RuntimePipelineCustomizerRegistry Instance { get; }
    private static RuntimePipelineCustomizerRegistry();
    [CompilerGeneratedAttribute]
public static RuntimePipelineCustomizerRegistry get_Instance();
    public void Register(IRuntimePipelineCustomizer customizer);
    public void Deregister(IRuntimePipelineCustomizer customizer);
    public void Deregister(string uniqueName);
    internal void ApplyCustomizations(Type type, RuntimePipeline pipeline);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public static class Amazon.Runtime.Internal.ServiceClientHelpers : object {
    public static string S3_ASSEMBLY_NAME;
    public static string S3_SERVICE_CLASS_NAME;
    public static string SSO_ASSEMBLY_NAME;
    public static string SSO_SERVICE_CLASS_NAME;
    public static string SSO_SERVICE_CONFIG_NAME;
    public static string SSO_OIDC_ASSEMBLY_NAME;
    public static string SSO_OIDC_SERVICE_CLASS_NAME;
    public static string SSO_OIDC_SERVICE_CONFIG_NAME;
    public static string STS_ASSEMBLY_NAME;
    public static string STS_SERVICE_CLASS_NAME;
    public static string STS_SERVICE_CONFIG_NAME;
    public static TClient CreateServiceFromAnother(AmazonServiceClient originalServiceClient);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code should use Amazon.RuntimeDependencyRegistry to use explicitly provided runtime dependencies.")]
public static TClient CreateServiceFromAssembly(string assemblyName, string serviceClientClassName, RegionEndpoint region);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code should use Amazon.RuntimeDependencyRegistry to use explicitly provided runtime dependencies.")]
public static TClient CreateServiceFromAssembly(string assemblyName, string serviceClientClassName, AWSCredentials credentials, RegionEndpoint region);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code should use Amazon.RuntimeDependencyRegistry to use explicitly provided runtime dependencies.")]
public static TClient CreateServiceFromAssembly(string assemblyName, string serviceClientClassName, AWSCredentials credentials, ClientConfig config);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code should use Amazon.RuntimeDependencyRegistry to use explicitly provided runtime dependencies.")]
public static TClient CreateServiceFromAssembly(string assemblyName, string serviceClientClassName, AmazonServiceClient originalServiceClient);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code must use Amazon.RuntimeDependencyRegistry to explicitly provide runtime dependencies.")]
public static ClientConfig CreateServiceConfig(string assemblyName, string serviceConfigClassName);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code must use Amazon.RuntimeDependencyRegistry to explicitly provide runtime dependencies.")]
private static Type LoadServiceClientType(string assemblyName, string serviceClientClassName);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code must use Amazon.RuntimeDependencyRegistry to explicitly provide runtime dependencies.")]
private static Type LoadServiceConfigType(string assemblyName, string serviceConfigClassName);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code must use Amazon.RuntimeDependencyRegistry to explicitly provide runtime dependencies.")]
internal static Type LoadTypeFromAssembly(string assemblyName, string className);
    [RequiresUnreferencedCodeAttribute("Using ServiceClientHelper to dynamically load dependency is not supported for Native AOT. SDK calling code must use Amazon.RuntimeDependencyRegistry to explicitly provide runtime dependencies.")]
private static Assembly GetSDKAssembly(string assemblyName);
}
internal class Amazon.Runtime.Internal.ServiceMetadata : object {
    [CompilerGeneratedAttribute]
private string <ServiceId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <OperationNameMapping>k__BackingField;
    public string ServiceId { get; }
    public IDictionary`2<string, string> OperationNameMapping { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceId();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_OperationNameMapping();
}
public class Amazon.Runtime.Internal.Settings.InMemoryPersistenceManager : object {
    private Dictionary`2<string, SettingsCollection> _settingsDictionary;
    public sealed virtual SettingsCollection GetSettings(string type);
    public sealed virtual void SaveSettings(string type, SettingsCollection settings);
}
public interface Amazon.Runtime.Internal.Settings.IPersistenceManager {
    public abstract virtual SettingsCollection GetSettings(string type);
    public abstract virtual void SaveSettings(string type, SettingsCollection settings);
}
public class Amazon.Runtime.Internal.Settings.PersistenceManager : object {
    private static HashSet`1<string> ENCRYPTEDKEYS;
    private static Logger _logger;
    private Dictionary`2<string, SettingsWatcher> _watchers;
    private static string SettingsStoreFolder;
    [CompilerGeneratedAttribute]
private static IPersistenceManager <Instance>k__BackingField;
    public static IPersistenceManager Instance { get; public set; }
    private static PersistenceManager();
    [CompilerGeneratedAttribute]
public static IPersistenceManager get_Instance();
    [CompilerGeneratedAttribute]
public static void set_Instance(IPersistenceManager value);
    public sealed virtual SettingsCollection GetSettings(string type);
    public sealed virtual void SaveSettings(string type, SettingsCollection settings);
    public string GetSetting(string key);
    public void SetSetting(string key, string value);
    public static string GetSettingsStoreFolder();
    public SettingsWatcher Watch(string type);
    private void enableWatcher(string type);
    private void disableWatcher(string type);
    internal static bool IsEncrypted(string key);
    private void saveSettingsType(string type, SettingsCollection settings);
    private SettingsCollection loadSettingsType(string type);
    private static void DecryptAnyEncryptedValues(Dictionary`2<string, Dictionary`2<string, string>> settings);
    private static string getFileFromType(string type);
}
[DefaultMemberAttribute("Item")]
public class Amazon.Runtime.Internal.Settings.SettingsCollection : object {
    private Dictionary`2<string, Dictionary`2<string, string>> _values;
    [CompilerGeneratedAttribute]
private bool <InitializedEmpty>k__BackingField;
    public int Count { get; }
    public bool InitializedEmpty { get; private set; }
    public ObjectSettings Item { get; }
    public SettingsCollection(Dictionary`2<string, Dictionary`2<string, string>> values);
    public int get_Count();
    [CompilerGeneratedAttribute]
public bool get_InitializedEmpty();
    [CompilerGeneratedAttribute]
private void set_InitializedEmpty(bool value);
    internal void Persist(StreamWriter writer);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Amazon.Runtime.Internal.Settings.SettingsCollection/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<ObjectSettings> GetEnumerator();
    public ObjectSettings get_Item(string key);
    public ObjectSettings NewObjectSettings();
    public ObjectSettings NewObjectSettings(string uniqueKey);
    public void Remove(string uniqueKey);
    public void Clear();
}
public static class Amazon.Runtime.Internal.Settings.SettingsConstants : object {
    public static string UserPreferences;
    public static string MiscSettings;
    public static string RegisteredProfiles;
    public static string RegisteredSAMLEndpoints;
    public static string RegisteredRoleSessions;
    public static string RecentUsages;
    public static string ProfileTypeField;
    public static string DisplayNameField;
    public static string AccountNumberField;
    public static string Restrictions;
    public static string AccessKeyField;
    public static string SecretKeyField;
    public static string SessionTokenField;
    public static string ExternalIDField;
    public static string MfaSerialField;
    public static string EndpointNameField;
    public static string RoleArnField;
    public static string RoleSessionName;
    public static string UserIdentityField;
    public static string Region;
    public static string AuthenticationTypeField;
    public static string SourceProfileField;
    public static string CredentialSourceField;
    public static string CredentialProcess;
    public static string WebIdentityTokenFile;
    public static string Services;
    public static string EndpointUrl;
    public static string EndpointField;
    public static string RoleSession;
    public static string SecretKeyRepository;
    public static string LastAcountSelectedKey;
    public static string VersionCheck;
    public static string LastVersionDoNotRemindMe;
    public static string HostedFilesLocation;
    public static string EC2ConnectSettings;
    public static string EC2InstanceUseKeyPair;
    public static string EC2InstanceMapDrives;
    public static string EC2InstanceSaveCredentials;
    public static string EC2InstanceUserName;
    public static string EC2InstancePassword;
    public static string ProxySettings;
    public static string ProxyHost;
    public static string ProxyPort;
    public static string ProxyUsernameObsolete;
    public static string ProxyPasswordObsolete;
    public static string ProxyUsernameEncrypted;
    public static string ProxyPasswordEncrypted;
}
public class Amazon.Runtime.Internal.Settings.SettingsWatcher : object {
    private string type;
    [CompilerGeneratedAttribute]
private bool <Enable>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    public bool Enable { get; public set; }
    internal SettingsWatcher(string filePath, string type);
    public SettingsCollection GetSettings();
    [CompilerGeneratedAttribute]
public bool get_Enable();
    [CompilerGeneratedAttribute]
public void set_Enable(bool value);
    [CompilerGeneratedAttribute]
public void add_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SettingsChanged(EventHandler value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public static class Amazon.Runtime.Internal.Settings.UserCrypto : object {
    private static Nullable`1<bool> _isUserCryptAvailable;
    public static bool IsUserCryptAvailable { get; }
    public static string Decrypt(string encrypted);
    public static string Encrypt(string unencrypted);
    private static DATA_BLOB ConvertData(Byte[] data);
    private static bool CryptProtectData(DATA_BLOB& pDataIn, string szDataDescr, DATA_BLOB& pOptionalEntropy, IntPtr pvReserved, CRYPTPROTECT_PROMPTSTRUCT& pPromptStruct, CryptProtectFlags dwFlags, DATA_BLOB& pDataOut);
    private static bool CryptUnprotectData(DATA_BLOB& pDataIn, string szDataDescr, DATA_BLOB& pOptionalEntropy, IntPtr pvReserved, CRYPTPROTECT_PROMPTSTRUCT& pPromptStruct, CryptProtectFlags dwFlags, DATA_BLOB& pDataOut);
    public static bool get_IsUserCryptAvailable();
}
public class Amazon.Runtime.Internal.Signer : PipelineHandler {
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Signer/<InvokeAsync>d__1`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    protected static void PreInvoke(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Signer/<PreInvokeAsync>d__3")]
protected static Task PreInvokeAsync(IExecutionContext executionContext);
    private static bool ShouldSign(IRequestContext requestContext);
    public static void SignRequest(IRequestContext requestContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Signer/<SignRequestAsync>d__6")]
private static Task SignRequestAsync(IRequestContext requestContext);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public static class Amazon.Runtime.Internal.SSOServiceClientHelpers : object {
    public static ICoreAmazonSSOOIDC BuildSSOIDCClient(RegionEndpoint region, IWebProxy proxySettings);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public static ICoreAmazonSSO BuildSSOClient(RegionEndpoint region, IWebProxy proxySettings);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public static ICoreAmazonSSO_Logout BuildSSOLogoutClient(RegionEndpoint region, IWebProxy proxySettings);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public static ICoreAmazonSSOOIDC_V2 BuildSSOIDC_V2Client(RegionEndpoint region, IWebProxy proxySettings);
    [RequiresUnreferencedCodeAttribute("Using CreateClient to dynamically load dependency is not supported for Native AOT. SDK calling code must use Amazon.RuntimeDependencyRegistry to explicitly provide runtime dependencies.")]
private static T CreateClient(RegionEndpoint region, string serviceClassName, string serviceConfigName, string parentAssemblyName, string runtimeDependencyRegistryMethod, IWebProxy proxySettings);
}
public class Amazon.Runtime.Internal.StandardRetryPolicy : RetryPolicy {
    private static Random _randomJitter;
    private static int INVALID_ENDPOINT_EXCEPTION_STATUSCODE;
    [CompilerGeneratedAttribute]
private static CapacityManager <CapacityManagerInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBackoffInMilliseconds>k__BackingField;
    protected static CapacityManager CapacityManagerInstance { get; protected set; }
    public int MaxBackoffInMilliseconds { get; public set; }
    public StandardRetryPolicy(int maxRetries);
    public StandardRetryPolicy(IClientConfig config);
    private static StandardRetryPolicy();
    [CompilerGeneratedAttribute]
protected static CapacityManager get_CapacityManagerInstance();
    [CompilerGeneratedAttribute]
protected static void set_CapacityManagerInstance(CapacityManager value);
    [CompilerGeneratedAttribute]
public int get_MaxBackoffInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_MaxBackoffInMilliseconds(int value);
    public virtual bool CanRetry(IExecutionContext executionContext);
    public virtual bool RetryForException(IExecutionContext executionContext, Exception exception);
    public virtual bool OnRetry(IExecutionContext executionContext);
    public virtual bool OnRetry(IExecutionContext executionContext, bool bypassAcquireCapacity);
    public virtual bool OnRetry(IExecutionContext executionContext, bool bypassAcquireCapacity, bool isThrottlingError);
    public virtual void NotifySuccess(IExecutionContext executionContext);
    protected bool RetryForExceptionSync(Exception exception);
    protected bool RetryForExceptionSync(Exception exception, IExecutionContext executionContext);
    public virtual bool RetryLimitReached(IExecutionContext executionContext);
    public virtual void WaitBeforeRetry(IExecutionContext executionContext);
    public static void WaitBeforeRetry(int retries, int maxBackoffInMilliseconds);
    protected static int CalculateRetryDelay(int retries, int maxBackoffInMilliseconds);
    public virtual Task`1<bool> RetryForExceptionAsync(IExecutionContext executionContext, Exception exception);
    public virtual Task WaitBeforeRetryAsync(IExecutionContext executionContext);
}
internal class Amazon.Runtime.Internal.StreamReadTracker : object {
    private object sender;
    private EventHandler`1<StreamTransferProgressArgs> callback;
    private long contentLength;
    private long totalBytesRead;
    private long totalIncrementTransferred;
    private long progressUpdateInterval;
    internal StreamReadTracker(object sender, EventHandler`1<StreamTransferProgressArgs> callback, long contentLength, long progressUpdateInterval);
    public void ReadProgress(int bytesRead);
    public void UpdateProgress(float progress);
}
public class Amazon.Runtime.Internal.TokenBucket : object {
    private static int MaxAttempts;
    private object _bucketLock;
    private double _minFillRate;
    private double _minCapacity;
    private double _beta;
    private double _scaleConstant;
    private double _smooth;
    private static DateTime _epoch;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <FillRate>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <MaxCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CurrentCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <LastTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MeasuredTxRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LastTxRateBucket>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RequestCount>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LastMaxRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LastThrottleTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TimeWindow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    protected Nullable`1<double> FillRate { get; protected set; }
    protected Nullable`1<double> MaxCapacity { get; protected set; }
    protected double CurrentCapacity { get; protected set; }
    protected Nullable`1<double> LastTimestamp { get; protected set; }
    protected double MeasuredTxRate { get; protected set; }
    protected double LastTxRateBucket { get; protected set; }
    protected long RequestCount { get; protected set; }
    protected double LastMaxRate { get; protected set; }
    protected double LastThrottleTime { get; protected set; }
    protected double TimeWindow { get; protected set; }
    protected bool Enabled { get; protected set; }
    public TokenBucket(double minFillRate, double minCapacity, double beta, double scaleConstant, double smooth);
    private static TokenBucket();
    [CompilerGeneratedAttribute]
protected Nullable`1<double> get_FillRate();
    [CompilerGeneratedAttribute]
protected void set_FillRate(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
protected Nullable`1<double> get_MaxCapacity();
    [CompilerGeneratedAttribute]
protected void set_MaxCapacity(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
protected double get_CurrentCapacity();
    [CompilerGeneratedAttribute]
protected void set_CurrentCapacity(double value);
    [CompilerGeneratedAttribute]
protected Nullable`1<double> get_LastTimestamp();
    [CompilerGeneratedAttribute]
protected void set_LastTimestamp(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
protected double get_MeasuredTxRate();
    [CompilerGeneratedAttribute]
protected void set_MeasuredTxRate(double value);
    [CompilerGeneratedAttribute]
protected double get_LastTxRateBucket();
    [CompilerGeneratedAttribute]
protected void set_LastTxRateBucket(double value);
    [CompilerGeneratedAttribute]
protected long get_RequestCount();
    [CompilerGeneratedAttribute]
protected void set_RequestCount(long value);
    [CompilerGeneratedAttribute]
protected double get_LastMaxRate();
    [CompilerGeneratedAttribute]
protected void set_LastMaxRate(double value);
    [CompilerGeneratedAttribute]
protected double get_LastThrottleTime();
    [CompilerGeneratedAttribute]
protected void set_LastThrottleTime(double value);
    [CompilerGeneratedAttribute]
protected double get_TimeWindow();
    [CompilerGeneratedAttribute]
protected void set_TimeWindow(double value);
    [CompilerGeneratedAttribute]
protected bool get_Enabled();
    [CompilerGeneratedAttribute]
protected void set_Enabled(bool value);
    public bool TryAcquireToken(double amount, bool failFast);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.TokenBucket/<TryAcquireTokenAsync>d__55")]
public Task`1<bool> TryAcquireTokenAsync(double amount, bool failFast, CancellationToken cancellationToken);
    private Nullable`1<bool> SetupAcquireToken(double amount);
    private int ObtainCapacity(double amount);
    public void UpdateClientSendingRate(bool isThrottlingError);
    protected virtual void TokenBucketRefill();
    protected virtual void TokenBucketUpdateRate(double newRps);
    protected virtual void UpdateMeasuredRate();
    protected virtual void CalculateTimeWindow();
    protected virtual double CUBICSuccess(double timestamp);
    protected virtual double CUBICThrottle(double rateToUse);
    protected virtual int CalculateWait(double amount, double currentCapacity, double fillRate);
    protected virtual void WaitForToken(int delayMs);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.TokenBucket/<WaitForTokenAsync>d__67")]
protected virtual Task WaitForTokenAsync(int delayMs, CancellationToken cancellationToken);
    protected virtual double GetTimestamp();
    private static double GetTimeInSeconds();
}
public class Amazon.Runtime.Internal.Transform.BoolUnmarshaller : object {
    private static BoolUnmarshaller _instance;
    public static BoolUnmarshaller Instance { get; }
    private static BoolUnmarshaller();
    public static BoolUnmarshaller get_Instance();
    public static BoolUnmarshaller GetInstance();
    public sealed virtual bool Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual bool Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.ByteUnmarshaller : object {
    private static ByteUnmarshaller _instance;
    public static ByteUnmarshaller Instance { get; }
    private static ByteUnmarshaller();
    public static ByteUnmarshaller get_Instance();
    public static ByteUnmarshaller GetInstance();
    public sealed virtual byte Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual byte Unmarshall(JsonUnmarshallerContext context);
}
public static class Amazon.Runtime.Internal.Transform.CustomMarshallTransformations : object {
    public static long ConvertDateTimeToEpochMilliseconds(DateTime dateTime);
}
public class Amazon.Runtime.Internal.Transform.DateTimeEpochLongMillisecondsUnmarshaller : object {
    private static DateTimeEpochLongMillisecondsUnmarshaller _instance;
    public static DateTimeEpochLongMillisecondsUnmarshaller Instance { get; }
    private static DateTimeEpochLongMillisecondsUnmarshaller();
    public static DateTimeEpochLongMillisecondsUnmarshaller get_Instance();
    public static DateTimeEpochLongMillisecondsUnmarshaller GetInstance();
    public sealed virtual DateTime Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual DateTime Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.DateTimeUnmarshaller : object {
    private static DateTimeUnmarshaller _instance;
    public static DateTimeUnmarshaller Instance { get; }
    private static DateTimeUnmarshaller();
    public static DateTimeUnmarshaller get_Instance();
    public static DateTimeUnmarshaller GetInstance();
    public sealed virtual DateTime Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual DateTime Unmarshall(JsonUnmarshallerContext context);
    internal static Nullable`1<DateTime> UnmarshallInternal(string text, bool treatAsNullable);
}
public class Amazon.Runtime.Internal.Transform.DecimalUnmarshaller : object {
    private static DecimalUnmarshaller _instance;
    public static DecimalUnmarshaller Instance { get; }
    private static DecimalUnmarshaller();
    public static DecimalUnmarshaller get_Instance();
    public static DecimalUnmarshaller GetInstance();
    public sealed virtual decimal Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual decimal Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.DictionaryUnmarshaller`4 : object {
    private KeyValueUnmarshaller`4<TKey, TValue, TKeyUnmarshaller, TValueUnmarshaller> KVUnmarshaller;
    public DictionaryUnmarshaller`4(TKeyUnmarshaller kUnmarshaller, TValueUnmarshaller vUnmarshaller);
    public sealed virtual Dictionary`2<TKey, TValue> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Dictionary`2<TKey, TValue> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.DoubleUnmarshaller : object {
    private static DoubleUnmarshaller _instance;
    public static DoubleUnmarshaller Instance { get; }
    private static DoubleUnmarshaller();
    public static DoubleUnmarshaller get_Instance();
    public static DoubleUnmarshaller GetInstance();
    public sealed virtual double Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual double Unmarshall(JsonUnmarshallerContext context);
}
public abstract class Amazon.Runtime.Internal.Transform.EC2ResponseUnmarshaller : XmlResponseUnmarshaller {
    public virtual AmazonWebServiceResponse Unmarshall(UnmarshallerContext input);
    protected virtual UnmarshallerContext ConstructUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData response, bool isException);
    protected virtual UnmarshallerContext ConstructUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData response, bool isException, IRequestContext requestContext);
}
public class Amazon.Runtime.Internal.Transform.EC2UnmarshallerContext : XmlUnmarshallerContext {
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    public string RequestId { get; private set; }
    public EC2UnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData responseData, bool isException);
    public EC2UnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData responseData, bool isException, IRequestContext requestContext);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(string value);
    public virtual bool Read();
}
public class Amazon.Runtime.Internal.Transform.ErrorResponseUnmarshaller : object {
    private static ErrorResponseUnmarshaller instance;
    public sealed virtual ErrorResponse Unmarshall(XmlUnmarshallerContext context);
    private static void PopulateErrorResponseFromXmlIfPossible(XmlUnmarshallerContext context, ErrorResponse response);
    private static bool TryReadContext(XmlUnmarshallerContext context);
    public static ErrorResponseUnmarshaller GetInstance();
}
public class Amazon.Runtime.Internal.Transform.FloatUnmarshaller : object {
    private static FloatUnmarshaller _instance;
    public static FloatUnmarshaller Instance { get; }
    private static FloatUnmarshaller();
    public static FloatUnmarshaller get_Instance();
    public static FloatUnmarshaller GetInstance();
    public sealed virtual float Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual float Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.HttpClientResponseData : object {
    private HttpResponseMessageBody _response;
    private String[] _headerNames;
    private Dictionary`2<string, string> _headers;
    private HashSet`1<string> _headerNamesSet;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccessStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    public HttpStatusCode StatusCode { get; private set; }
    public bool IsSuccessStatusCode { get; private set; }
    public string ContentType { get; private set; }
    public long ContentLength { get; private set; }
    public IHttpResponseBody ResponseBody { get; }
    internal HttpClientResponseData(HttpResponseMessage response);
    internal HttpClientResponseData(HttpResponseMessage response, HttpClient httpClient, bool disposeClient);
    [CompilerGeneratedAttribute]
public sealed virtual HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
private void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSuccessStatusCode();
    [CompilerGeneratedAttribute]
private void set_IsSuccessStatusCode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_ContentLength();
    [CompilerGeneratedAttribute]
private void set_ContentLength(long value);
    public sealed virtual string GetHeaderValue(string headerName);
    public sealed virtual bool IsHeaderPresent(string headerName);
    public sealed virtual String[] GetHeaderNames();
    private void CopyHeaderValues(HttpResponseMessage response);
    private string GetFirstHeaderValue(HttpHeaders headers, string key);
    public sealed virtual IHttpResponseBody get_ResponseBody();
}
public class Amazon.Runtime.Internal.Transform.HttpResponseMessageBody : object {
    private HttpClient _httpClient;
    private HttpResponseMessage _response;
    private bool _disposeClient;
    private bool _disposed;
    public HttpResponseMessageBody(HttpResponseMessage response, HttpClient httpClient, bool disposeClient);
    public sealed virtual Stream OpenResponse();
    public sealed virtual Task`1<Stream> OpenResponseAsync();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public interface Amazon.Runtime.Internal.Transform.IErrorResponseUnmarshaller`2 {
    public abstract virtual TUnmarshaller Unmarshall(TUnmarshalleContext input, ErrorResponse errorResponse);
}
public interface Amazon.Runtime.Internal.Transform.IHttpResponseBody {
    public abstract virtual Stream OpenResponse();
    public abstract virtual Task`1<Stream> OpenResponseAsync();
}
public interface Amazon.Runtime.Internal.Transform.IMarshaller`2 {
    public abstract virtual T Marshall(R input);
}
public class Amazon.Runtime.Internal.Transform.IntUnmarshaller : object {
    private static IntUnmarshaller _instance;
    public static IntUnmarshaller Instance { get; }
    private static IntUnmarshaller();
    public static IntUnmarshaller get_Instance();
    public static IntUnmarshaller GetInstance();
    public sealed virtual int Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual int Unmarshall(JsonUnmarshallerContext context);
}
public interface Amazon.Runtime.Internal.Transform.IRequestMarshaller`2 {
    public abstract virtual void Marshall(R requestObject, T context);
}
public interface Amazon.Runtime.Internal.Transform.IResponseUnmarshaller`2 {
    public abstract virtual AmazonServiceException UnmarshallException(R input, Exception innerException, HttpStatusCode statusCode);
}
public interface Amazon.Runtime.Internal.Transform.IUnmarshaller`2 {
    public abstract virtual T Unmarshall(R input);
}
public interface Amazon.Runtime.Internal.Transform.IWebResponseData {
    public long ContentLength { get; }
    public string ContentType { get; }
    public HttpStatusCode StatusCode { get; }
    public bool IsSuccessStatusCode { get; }
    public IHttpResponseBody ResponseBody { get; }
    public abstract virtual long get_ContentLength();
    public abstract virtual string get_ContentType();
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual bool get_IsSuccessStatusCode();
    public abstract virtual String[] GetHeaderNames();
    public abstract virtual bool IsHeaderPresent(string headerName);
    public abstract virtual string GetHeaderValue(string headerName);
    public abstract virtual IHttpResponseBody get_ResponseBody();
}
public class Amazon.Runtime.Internal.Transform.JsonErrorResponseUnmarshaller : object {
    private static JsonErrorResponseUnmarshaller instance;
    public sealed virtual ErrorResponse Unmarshall(JsonUnmarshallerContext context);
    private static string ParseType(string type);
    private static void GetValuesFromJsonIfPossible(JsonUnmarshallerContext context, String& type, String& message, String& code);
    private static bool TryReadContext(JsonUnmarshallerContext context);
    public static JsonErrorResponseUnmarshaller GetInstance();
}
public class Amazon.Runtime.Internal.Transform.JsonMarshallerContext : MarshallerContext {
    [CompilerGeneratedAttribute]
private JsonWriter <Writer>k__BackingField;
    public JsonWriter Writer { get; private set; }
    public JsonMarshallerContext(IRequest request, JsonWriter writer);
    [CompilerGeneratedAttribute]
public JsonWriter get_Writer();
    [CompilerGeneratedAttribute]
private void set_Writer(JsonWriter value);
}
public abstract class Amazon.Runtime.Internal.Transform.JsonResponseUnmarshaller : ResponseUnmarshaller {
    public virtual AmazonWebServiceResponse Unmarshall(UnmarshallerContext input);
    public virtual AmazonServiceException UnmarshallException(UnmarshallerContext input, Exception innerException, HttpStatusCode statusCode);
    public abstract virtual AmazonWebServiceResponse Unmarshall(JsonUnmarshallerContext input);
    public abstract virtual AmazonServiceException UnmarshallException(JsonUnmarshallerContext input, Exception innerException, HttpStatusCode statusCode);
    protected virtual UnmarshallerContext ConstructUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData response, bool isException);
    protected virtual UnmarshallerContext ConstructUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData response, bool isException, IRequestContext requestContext);
    protected virtual bool ShouldReadEntireResponse(IWebResponseData response, bool readEntireResponse);
}
public class Amazon.Runtime.Internal.Transform.JsonUnmarshallerContext : UnmarshallerContext {
    private static string DELIMITER;
    private StreamReader streamReader;
    private JsonReader jsonReader;
    private JsonPathStack stack;
    private Nullable`1<JsonToken> currentToken;
    private bool disposed;
    private bool wasPeeked;
    public bool IsStartOfDocument { get; }
    public bool IsEndElement { get; }
    public bool IsStartElement { get; }
    public int CurrentDepth { get; }
    public string CurrentPath { get; }
    public JsonToken CurrentTokenType { get; }
    public Stream Stream { get; }
    public JsonUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData responseData, bool isException);
    public JsonUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData responseData, bool isException, IRequestContext requestContext);
    public virtual bool get_IsStartOfDocument();
    public virtual bool get_IsEndElement();
    public virtual bool get_IsStartElement();
    public virtual int get_CurrentDepth();
    public virtual string get_CurrentPath();
    public virtual bool Read();
    public bool Peek(JsonToken token);
    public virtual string ReadText();
    public JsonToken get_CurrentTokenType();
    public Stream get_Stream();
    public int Peek();
    private int StreamPeek();
    private void UpdateContext();
    public JsonData ToJsonData();
    protected virtual void Dispose(bool disposing);
}
public class Amazon.Runtime.Internal.Transform.KeyValueUnmarshaller`4 : object {
    private KUnmarshaller keyUnmarshaller;
    private VUnmarshaller valueUnmarshaller;
    public KeyValueUnmarshaller`4(KUnmarshaller keyUnmarshaller, VUnmarshaller valueUnmarshaller);
    public sealed virtual KeyValuePair`2<K, V> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual KeyValuePair`2<K, V> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.ListUnmarshaller`2 : object {
    private IUnmarshaller iUnmarshaller;
    public ListUnmarshaller`2(IUnmarshaller iUnmarshaller);
    public sealed virtual List`1<I> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual List`1<I> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.LongUnmarshaller : object {
    private static LongUnmarshaller _instance;
    public static LongUnmarshaller Instance { get; }
    private static LongUnmarshaller();
    public static LongUnmarshaller get_Instance();
    public static LongUnmarshaller GetInstance();
    public sealed virtual long Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual long Unmarshall(JsonUnmarshallerContext context);
}
public abstract class Amazon.Runtime.Internal.Transform.MarshallerContext : object {
    [CompilerGeneratedAttribute]
private IRequest <Request>k__BackingField;
    public IRequest Request { get; private set; }
    protected MarshallerContext(IRequest request);
    [CompilerGeneratedAttribute]
public IRequest get_Request();
    [CompilerGeneratedAttribute]
private void set_Request(IRequest value);
}
public class Amazon.Runtime.Internal.Transform.MemoryStreamUnmarshaller : object {
    private static MemoryStreamUnmarshaller _instance;
    public static MemoryStreamUnmarshaller Instance { get; }
    private static MemoryStreamUnmarshaller();
    public static MemoryStreamUnmarshaller get_Instance();
    public static MemoryStreamUnmarshaller GetInstance();
    public sealed virtual MemoryStream Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual MemoryStream Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.NullableBoolUnmarshaller : object {
    private static NullableBoolUnmarshaller _instance;
    public static NullableBoolUnmarshaller Instance { get; }
    private static NullableBoolUnmarshaller();
    public static NullableBoolUnmarshaller get_Instance();
    public sealed virtual Nullable`1<bool> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Nullable`1<bool> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.NullableDateTimeEpochLongMillisecondsUnmarshaller : object {
    private static NullableDateTimeEpochLongMillisecondsUnmarshaller _instance;
    public static NullableDateTimeEpochLongMillisecondsUnmarshaller Instance { get; }
    private static NullableDateTimeEpochLongMillisecondsUnmarshaller();
    public static NullableDateTimeEpochLongMillisecondsUnmarshaller get_Instance();
    public sealed virtual Nullable`1<DateTime> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Nullable`1<DateTime> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.NullableDateTimeUnmarshaller : object {
    private static NullableDateTimeUnmarshaller _instance;
    public static NullableDateTimeUnmarshaller Instance { get; }
    private static NullableDateTimeUnmarshaller();
    public static NullableDateTimeUnmarshaller get_Instance();
    public static NullableDateTimeUnmarshaller GetInstance();
    public sealed virtual Nullable`1<DateTime> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Nullable`1<DateTime> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.NullableDecimalUnmarshaller : object {
    private static NullableDecimalUnmarshaller _instance;
    public static NullableDecimalUnmarshaller Instance { get; }
    private static NullableDecimalUnmarshaller();
    public static NullableDecimalUnmarshaller get_Instance();
    public sealed virtual Nullable`1<decimal> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Nullable`1<decimal> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.NullableDoubleUnmarshaller : object {
    private static NullableDoubleUnmarshaller _instance;
    public static NullableDoubleUnmarshaller Instance { get; }
    private static NullableDoubleUnmarshaller();
    public static NullableDoubleUnmarshaller get_Instance();
    public sealed virtual Nullable`1<double> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Nullable`1<double> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.NullableFloatUnmarshaller : object {
    private static NullableFloatUnmarshaller _instance;
    public static NullableFloatUnmarshaller Instance { get; }
    private static NullableFloatUnmarshaller();
    public static NullableFloatUnmarshaller get_Instance();
    public sealed virtual Nullable`1<float> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Nullable`1<float> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.NullableIntUnmarshaller : object {
    private static NullableIntUnmarshaller _instance;
    public static NullableIntUnmarshaller Instance { get; }
    private static NullableIntUnmarshaller();
    public static NullableIntUnmarshaller get_Instance();
    public static NullableIntUnmarshaller GetInstance();
    public sealed virtual Nullable`1<int> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Nullable`1<int> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.NullableLongUnmarshaller : object {
    private static NullableLongUnmarshaller _instance;
    public static NullableLongUnmarshaller Instance { get; }
    private static NullableLongUnmarshaller();
    public static NullableLongUnmarshaller get_Instance();
    public sealed virtual Nullable`1<long> Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual Nullable`1<long> Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.ResponseMetadataUnmarshaller : object {
    private static ResponseMetadataUnmarshaller _instance;
    public static ResponseMetadataUnmarshaller Instance { get; }
    private static ResponseMetadataUnmarshaller();
    public static ResponseMetadataUnmarshaller get_Instance();
    public static ResponseMetadataUnmarshaller GetInstance();
    public sealed virtual ResponseMetadata Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual ResponseMetadata Unmarshall(JsonUnmarshallerContext context);
}
public abstract class Amazon.Runtime.Internal.Transform.ResponseUnmarshaller : object {
    public bool HasStreamingProperty { get; }
    public virtual UnmarshallerContext CreateContext(IWebResponseData response, bool readEntireResponse, Stream stream, RequestMetrics metrics, bool isException);
    public virtual UnmarshallerContext CreateContext(IWebResponseData response, bool readEntireResponse, Stream stream, RequestMetrics metrics, bool isException, IRequestContext requestContext);
    public virtual bool get_HasStreamingProperty();
    public virtual AmazonServiceException UnmarshallException(UnmarshallerContext input, Exception innerException, HttpStatusCode statusCode);
    public AmazonWebServiceResponse UnmarshallResponse(UnmarshallerContext context);
    public abstract virtual AmazonWebServiceResponse Unmarshall(UnmarshallerContext input);
    public static string GetDefaultErrorMessage();
    protected abstract virtual UnmarshallerContext ConstructUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData response, bool isException);
    protected abstract virtual UnmarshallerContext ConstructUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData response, bool isException, IRequestContext requestContext);
    protected virtual bool ShouldReadEntireResponse(IWebResponseData response, bool readEntireResponse);
}
internal static class Amazon.Runtime.Internal.Transform.SimpleTypeUnmarshaller`1 : object {
    public static T Unmarshall(XmlUnmarshallerContext context);
    public static T Unmarshall(JsonUnmarshallerContext context);
}
public class Amazon.Runtime.Internal.Transform.StringUnmarshaller : object {
    private static StringUnmarshaller _instance;
    public static StringUnmarshaller Instance { get; }
    private static StringUnmarshaller();
    public static StringUnmarshaller get_Instance();
    public static StringUnmarshaller GetInstance();
    public sealed virtual string Unmarshall(XmlUnmarshallerContext context);
    public sealed virtual string Unmarshall(JsonUnmarshallerContext context);
}
public abstract class Amazon.Runtime.Internal.Transform.UnmarshallerContext : object {
    private bool disposed;
    [CompilerGeneratedAttribute]
private bool <MaintainResponseBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsException>k__BackingField;
    [CompilerGeneratedAttribute]
private CrcCalculatorStream <CrcStream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Crc32Result>k__BackingField;
    [CompilerGeneratedAttribute]
private CoreChecksumAlgorithm <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashStream <FlexibleChecksumStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpectedFlexibleChecksumResult>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebResponseData <WebResponseData>k__BackingField;
    [CompilerGeneratedAttribute]
private CachingWrapperStream <WrappingStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEmptyResponse>k__BackingField;
    protected bool MaintainResponseBody { get; protected set; }
    protected bool IsException { get; protected set; }
    protected CrcCalculatorStream CrcStream { get; protected set; }
    protected int Crc32Result { get; protected set; }
    protected CoreChecksumAlgorithm ChecksumAlgorithm { get; protected set; }
    protected HashStream FlexibleChecksumStream { get; protected set; }
    protected string ExpectedFlexibleChecksumResult { get; protected set; }
    protected IWebResponseData WebResponseData { get; protected set; }
    protected CachingWrapperStream WrappingStream { get; protected set; }
    public bool IsEmptyResponse { get; protected set; }
    public string ResponseBody { get; }
    public IWebResponseData ResponseData { get; }
    public string CurrentPath { get; }
    public int CurrentDepth { get; }
    public bool IsStartElement { get; }
    public bool IsEndElement { get; }
    public bool IsStartOfDocument { get; }
    [CompilerGeneratedAttribute]
protected bool get_MaintainResponseBody();
    [CompilerGeneratedAttribute]
protected void set_MaintainResponseBody(bool value);
    [CompilerGeneratedAttribute]
protected bool get_IsException();
    [CompilerGeneratedAttribute]
protected void set_IsException(bool value);
    [CompilerGeneratedAttribute]
protected CrcCalculatorStream get_CrcStream();
    [CompilerGeneratedAttribute]
protected void set_CrcStream(CrcCalculatorStream value);
    [CompilerGeneratedAttribute]
protected int get_Crc32Result();
    [CompilerGeneratedAttribute]
protected void set_Crc32Result(int value);
    [CompilerGeneratedAttribute]
protected CoreChecksumAlgorithm get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
protected void set_ChecksumAlgorithm(CoreChecksumAlgorithm value);
    [CompilerGeneratedAttribute]
protected HashStream get_FlexibleChecksumStream();
    [CompilerGeneratedAttribute]
protected void set_FlexibleChecksumStream(HashStream value);
    [CompilerGeneratedAttribute]
protected string get_ExpectedFlexibleChecksumResult();
    [CompilerGeneratedAttribute]
protected void set_ExpectedFlexibleChecksumResult(string value);
    [CompilerGeneratedAttribute]
protected IWebResponseData get_WebResponseData();
    [CompilerGeneratedAttribute]
protected void set_WebResponseData(IWebResponseData value);
    [CompilerGeneratedAttribute]
protected CachingWrapperStream get_WrappingStream();
    [CompilerGeneratedAttribute]
protected void set_WrappingStream(CachingWrapperStream value);
    [CompilerGeneratedAttribute]
public bool get_IsEmptyResponse();
    [CompilerGeneratedAttribute]
protected void set_IsEmptyResponse(bool value);
    public string get_ResponseBody();
    public Byte[] GetResponseBodyBytes();
    public IWebResponseData get_ResponseData();
    internal void ValidateCRC32IfAvailable();
    internal void ValidateFlexibleCheckumsIfAvailable(ResponseMetadata responseMetadata);
    protected void SetupCRCStream(IWebResponseData responseData, Stream responseStream, long contentLength);
    protected void SetupFlexibleChecksumStream(IWebResponseData responseData, Stream responseStream, long contentLength, IRequestContext requestContext);
    public bool TestExpression(string expression);
    public bool TestExpression(string expression, int startingStackDepth);
    public bool ReadAtDepth(int targetDepth);
    private static bool TestExpression(string expression, string currentPath);
    private static bool TestExpression(string expression, int startingStackDepth, string currentPath, int currentDepth);
    public abstract virtual string get_CurrentPath();
    public abstract virtual int get_CurrentDepth();
    public abstract virtual bool Read();
    public abstract virtual string ReadText();
    public abstract virtual bool get_IsStartElement();
    public abstract virtual bool get_IsEndElement();
    public abstract virtual bool get_IsStartOfDocument();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Amazon.Runtime.Internal.Transform.UnmarshallerExtensions : object {
    [ExtensionAttribute]
public static void Add(Dictionary`2<TKey, TValue> dict, KeyValuePair`2<TKey, TValue> item);
}
public class Amazon.Runtime.Internal.Transform.XmlMarshallerContext : MarshallerContext {
    [CompilerGeneratedAttribute]
private XmlWriter <Writer>k__BackingField;
    public XmlWriter Writer { get; private set; }
    public XmlMarshallerContext(IRequest request, XmlWriter writer);
    [CompilerGeneratedAttribute]
public XmlWriter get_Writer();
    [CompilerGeneratedAttribute]
private void set_Writer(XmlWriter value);
}
public abstract class Amazon.Runtime.Internal.Transform.XmlResponseUnmarshaller : ResponseUnmarshaller {
    public virtual AmazonWebServiceResponse Unmarshall(UnmarshallerContext input);
    public virtual AmazonServiceException UnmarshallException(UnmarshallerContext input, Exception innerException, HttpStatusCode statusCode);
    public abstract virtual AmazonWebServiceResponse Unmarshall(XmlUnmarshallerContext input);
    public abstract virtual AmazonServiceException UnmarshallException(XmlUnmarshallerContext input, Exception innerException, HttpStatusCode statusCode);
    protected virtual UnmarshallerContext ConstructUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData response, bool isException);
    protected virtual UnmarshallerContext ConstructUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData response, bool isException, IRequestContext requestContext);
}
public class Amazon.Runtime.Internal.Transform.XmlUnmarshallerContext : UnmarshallerContext {
    private static HashSet`1<XmlNodeType> nodesToSkip;
    private StreamReader streamReader;
    private XmlTextReader _xmlTextReader;
    private Stack`1<string> stack;
    private string stackString;
    private Dictionary`2<string, string> attributeValues;
    private List`1<string> attributeNames;
    private IEnumerator`1<string> attributeEnumerator;
    private XmlNodeType nodeType;
    private string nodeContent;
    private bool disposed;
    private bool currentlyProcessingEmptyElement;
    private bool processEmptyElements;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AllowEmptyElementLookup>k__BackingField;
    public Stream Stream { get; }
    public HashSet`1<string> AllowEmptyElementLookup { get; private set; }
    private XmlTextReader XmlReader { get; }
    public string CurrentPath { get; }
    public int CurrentDepth { get; }
    public bool IsStartElement { get; }
    public bool IsEndElement { get; }
    public bool IsStartOfDocument { get; }
    public bool IsAttribute { get; }
    public XmlUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData responseData, bool isException);
    public XmlUnmarshallerContext(Stream responseStream, bool maintainResponseBody, IWebResponseData responseData, bool isException, IRequestContext requestContext);
    private static XmlUnmarshallerContext();
    public Stream get_Stream();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AllowEmptyElementLookup();
    [CompilerGeneratedAttribute]
private void set_AllowEmptyElementLookup(HashSet`1<string> value);
    private XmlTextReader get_XmlReader();
    public virtual string get_CurrentPath();
    public virtual int get_CurrentDepth();
    public virtual bool Read();
    public virtual string ReadText();
    public virtual bool get_IsStartElement();
    public virtual bool get_IsEndElement();
    public virtual bool get_IsStartOfDocument();
    public bool get_IsAttribute();
    private static string StackToPath(Stack`1<string> stack);
    private void ReadElement();
    protected virtual void Dispose(bool disposing);
}
public class Amazon.Runtime.Internal.Unmarshaller : PipelineHandler {
    private bool _supportsResponseLogging;
    public Unmarshaller(bool supportsResponseLogging);
    public virtual void InvokeSync(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Unmarshaller/<InvokeAsync>d__3`1")]
public virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
    private void Unmarshall(IExecutionContext executionContext);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Unmarshaller/<UnmarshallAsync>d__5")]
private Task UnmarshallAsync(IExecutionContext executionContext);
    private AmazonWebServiceResponse UnmarshallResponse(UnmarshallerContext context, IRequestContext requestContext);
    private static bool ShouldLogResponseBody(bool supportsResponseLogging, IRequestContext requestContext);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<T> <>n__0(IExecutionContext executionContext);
}
public class Amazon.Runtime.Internal.Util.AESDecryptionStream : DecryptStream`1<DecryptionWrapperAES> {
    public AESDecryptionStream(Stream baseStream, Byte[] key, Byte[] IV);
}
public class Amazon.Runtime.Internal.Util.AESEncryptionPutObjectStream : EncryptStream`1<EncryptionWrapperAES> {
    public AESEncryptionPutObjectStream(Stream baseStream, Byte[] key, Byte[] IV);
}
public class Amazon.Runtime.Internal.Util.AESEncryptionUploadPartStream : EncryptUploadPartStream`1<EncryptionWrapperAES> {
    public AESEncryptionUploadPartStream(Stream baseStream, Byte[] key, Byte[] IV);
}
internal class Amazon.Runtime.Internal.Util.AlwaysSendDictionary`2 : Dictionary`2<TKey, TValue> {
    public AlwaysSendDictionary`2(IEqualityComparer`1<TKey> comparer);
    public AlwaysSendDictionary`2(IDictionary`2<TKey, TValue> dictionary);
}
internal class Amazon.Runtime.Internal.Util.AlwaysSendList`1 : List`1<T> {
    public AlwaysSendList`1(IEnumerable`1<T> collection);
}
public static class Amazon.Runtime.Internal.Util.AsyncHelpers : object {
    public static void RunSync(Func`1<Task> workItem);
    public static T RunSync(Func`1<Task`1<T>> workItem);
}
internal class Amazon.Runtime.Internal.Util.BackgroundDispatcher`1 : object {
    private bool isDisposed;
    private Action`1<T> action;
    private Queue`1<T> queue;
    private Thread backgroundThread;
    private AutoResetEvent resetEvent;
    private bool shouldStop;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    private static int MAX_QUEUE_SIZE;
    public bool IsRunning { get; private set; }
    public BackgroundDispatcher`1(Action`1<T> action);
    [CompilerGeneratedAttribute]
public bool get_IsRunning();
    [CompilerGeneratedAttribute]
private void set_IsRunning(bool value);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public void Dispatch(T data);
    public void Stop();
    private void Run();
    private void HandleInvoked();
}
internal class Amazon.Runtime.Internal.Util.BackgroundInvoker : BackgroundDispatcher`1<Action> {
}
internal class Amazon.Runtime.Internal.Util.Cache`2 : object {
    private Dictionary`2<TKey, CacheItem`1<TKey, TValue, TValue>> Contents;
    private object CacheLock;
    public static TimeSpan DefaultMaximumItemLifespan;
    public static TimeSpan DefaultCacheClearPeriod;
    [CompilerGeneratedAttribute]
private DateTime <LastCacheClean>k__BackingField;
    private TimeSpan maximumItemLifespan;
    private TimeSpan cacheClearPeriod;
    public DateTime LastCacheClean { get; private set; }
    public List`1<TKey> Keys { get; }
    public TimeSpan MaximumItemLifespan { get; public set; }
    public TimeSpan CacheClearPeriod { get; public set; }
    public int ItemCount { get; }
    public Cache`2(IEqualityComparer`1<TKey> keyComparer);
    private static Cache`2();
    [CompilerGeneratedAttribute]
public DateTime get_LastCacheClean();
    [CompilerGeneratedAttribute]
private void set_LastCacheClean(DateTime value);
    public sealed virtual TValue GetValue(TKey key, Func`2<TKey, TValue> creator);
    public sealed virtual TValue GetValue(TKey key, Func`2<TKey, TValue> creator, Boolean& isStaleItem);
    public sealed virtual void Clear(TKey key);
    public sealed virtual void Clear();
    public sealed virtual List`1<TKey> get_Keys();
    public sealed virtual TimeSpan get_MaximumItemLifespan();
    public sealed virtual void set_MaximumItemLifespan(TimeSpan value);
    public sealed virtual TimeSpan get_CacheClearPeriod();
    public sealed virtual void set_CacheClearPeriod(TimeSpan value);
    public sealed virtual int get_ItemCount();
    public sealed virtual TOut UseCache(TKey key, Func`1<TOut> operation, Action onError, Predicate`1<Exception> shouldRetryForException);
    private TValue GetValueHelper(TKey key, Boolean& isStaleItem, Func`2<TKey, TValue> creator);
    private bool IsValidItem(CacheItem`1<TKey, TValue, TValue> item);
    private void RemoveOldItems_Locked();
    private static DateTime GetCorrectedLocalTime();
}
public class Amazon.Runtime.Internal.Util.CachingWrapperStream : WrapperStream {
    private Nullable`1<int> _cacheLimit;
    private int _cachedBytes;
    [CompilerGeneratedAttribute]
private List`1<byte> <AllReadBytes>k__BackingField;
    public List`1<byte> AllReadBytes { get; private set; }
    public List`1<byte> LoggableReadBytes { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public CachingWrapperStream(Stream baseStream, Nullable`1<int> cacheLimit);
    [CompilerGeneratedAttribute]
public List`1<byte> get_AllReadBytes();
    [CompilerGeneratedAttribute]
private void set_AllReadBytes(List`1<byte> value);
    public List`1<byte> get_LoggableReadBytes();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.CachingWrapperStream/<ReadAsync>d__10")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private void UpdateCacheAfterReading(Byte[] buffer, int offset, int numberOfBytesRead);
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public class Amazon.Runtime.Internal.Util.ChecksumData : object {
    [CompilerGeneratedAttribute]
private string <SelectedChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMD5Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FallbackToMD5>k__BackingField;
    public string SelectedChecksum { get; public set; }
    public bool IsMD5Checksum { get; public set; }
    public Nullable`1<bool> FallbackToMD5 { get; public set; }
    public ChecksumData(string selectedChecksum, bool MD5Checksum, Nullable`1<bool> fallbackToMD5);
    [CompilerGeneratedAttribute]
public string get_SelectedChecksum();
    [CompilerGeneratedAttribute]
public void set_SelectedChecksum(string value);
    [CompilerGeneratedAttribute]
public bool get_IsMD5Checksum();
    [CompilerGeneratedAttribute]
public void set_IsMD5Checksum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_FallbackToMD5();
    [CompilerGeneratedAttribute]
public void set_FallbackToMD5(Nullable`1<bool> value);
}
public static class Amazon.Runtime.Internal.Util.ChecksumUtils : object {
    internal static string GetChecksumHeaderKey(CoreChecksumAlgorithm checksumAlgorithm);
    public static void SetRequestChecksum(IRequest request, string checksumAlgorithm, bool fallbackToMD5);
    public static void SetRequestChecksumMD5(IRequest request);
    private static string CalculateChecksumForRequest(HashAlgorithm algorithm, IRequest request);
    public static CoreChecksumAlgorithm SelectChecksumForResponseValidation(ICollection`1<CoreChecksumAlgorithm> operationSupportedChecksums, IWebResponseData responseData);
    private static bool IsChecksumValueMultipartGet(string checksumValue);
    private static CoreChecksumAlgorithm ConvertToCoreChecksumAlgorithm(string selectedServiceChecksum);
    public static void SetChecksumData(IRequest request, string checksumAlgorithm, bool fallbackToMD5);
    public static void SetChecksumData(IRequest request);
}
public class Amazon.Runtime.Internal.Util.ChunkedUploadWrapperStream : WrapperStream {
    public static int DefaultChunkSize;
    private static string STREAM_NEWLINE;
    private static int NEWLINE_LENGTH;
    private static int HEADER_ROW_PADDING_LENGTH;
    private static string CHUNK_STRING_TO_SIGN_PREFIX;
    private static string CHUNK_SIGNATURE_HEADER;
    public static int V4_SIGNATURE_LENGTH;
    public static int V4A_SIGNATURE_LENGTH;
    private static string TRAILING_HEADER_SIGNATURE_KEY;
    private static string TRAILING_HEADER_STRING_TO_SIGN_PREFIX;
    private Byte[] _inputBuffer;
    private Byte[] _outputBuffer;
    private int _outputBufferPos;
    private int _outputBufferDataLen;
    private int _wrappedStreamBufferSize;
    private bool _wrappedStreamConsumed;
    private CoreChecksumAlgorithm _trailingChecksum;
    private HashAlgorithm _hashAlgorithm;
    private IDictionary`2<string, string> _trailingHeaders;
    private string _trailingHeaderChunk;
    private int _trailingHeaderPos;
    private bool _trailingHeadersConsumed;
    private bool _outputBufferIsTerminatingChunk;
    private ReadStrategy _readStrategy;
    [CompilerGeneratedAttribute]
private AWSSigningResultBase <HeaderSigningResult>k__BackingField;
    [CompilerGeneratedAttribute]
private AWS4aSignerCRTWrapper <Sigv4aSigner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreviousChunkSignature>k__BackingField;
    private AWSSigningResultBase HeaderSigningResult { get; private set; }
    private AWS4aSignerCRTWrapper Sigv4aSigner { get; private set; }
    private string PreviousChunkSignature { get; private set; }
    public long Length { get; }
    public bool CanSeek { get; }
    internal bool HasLength { get; }
    internal ChunkedUploadWrapperStream(Stream stream, int wrappedStreamBufferSize, AWSSigningResultBase headerSigningResult);
    public ChunkedUploadWrapperStream(Stream stream, int wrappedStreamBufferSize, AWSSigningResultBase headerSigningResult, CoreChecksumAlgorithm trailingChecksum, IDictionary`2<string, string> trailingHeaders);
    private static ChunkedUploadWrapperStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private int AdjustBufferAfterReading(Byte[] buffer, int offset, int count, int bytesRead);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.ChunkedUploadWrapperStream/<ReadAsync>d__29")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.ChunkedUploadWrapperStream/<FillInputBufferAsync>d__30")]
private Task`1<int> FillInputBufferAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private AWSSigningResultBase get_HeaderSigningResult();
    [CompilerGeneratedAttribute]
private void set_HeaderSigningResult(AWSSigningResultBase value);
    [CompilerGeneratedAttribute]
private AWS4aSignerCRTWrapper get_Sigv4aSigner();
    [CompilerGeneratedAttribute]
private void set_Sigv4aSigner(AWS4aSignerCRTWrapper value);
    [CompilerGeneratedAttribute]
private string get_PreviousChunkSignature();
    [CompilerGeneratedAttribute]
private void set_PreviousChunkSignature(string value);
    private void ConstructOutputBufferChunk(int dataLen);
    private string ConstructSignedTrailersChunk();
    private int WriteTrailingHeaders(Byte[] buffer, int offset, int count);
    public virtual long get_Length();
    public virtual bool get_CanSeek();
    public static long ComputeChunkedContentLength(long originalLength, int signatureLength);
    public static long ComputeChunkedContentLength(long originalLength, int signatureLength, IDictionary`2<string, string> trailingHeaders, CoreChecksumAlgorithm trailingChecksum);
    public static string BuildChunkedStringToSign(string prefix, string dateTime, string scope, string previousSignature, int dataLength, Byte[] inputBuffer);
    private static long CalculateChunkHeaderLength(long chunkDataSize, int signatureLength);
    private int FillInputBuffer();
    internal virtual bool get_HasLength();
}
public static class Amazon.Runtime.Internal.Util.CompressionAlgorithmUtils : object {
    public static void SetCompressionAlgorithm(IRequest request, CompressionEncodingAlgorithm compressionAlgorithm);
    public static void SetRequestHeader(IRequest request, CompressionEncodingAlgorithm compressionEncodingAlgorithm);
}
public class Amazon.Runtime.Internal.Util.CompressionWrapperStream : WrapperStream {
    private Stream _compressionStream;
    private ICompressionAlgorithm _compressionAlgorithm;
    private MemoryStream _outputBufferStream;
    private bool _hitEnd;
    private int _defaultChunkSize;
    private Byte[] _inputBuffer;
    internal bool HasLength { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public CompressionWrapperStream(Stream baseStream, ICompressionAlgorithm compressionAlgorithm);
    private void Init();
    public void Reset();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.CompressionWrapperStream/<ReadAsync>d__10")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    internal virtual bool get_HasLength();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Amazon.Runtime.Internal.Util.CrtCrc32 : HashAlgorithm {
    private UInt32 _rollingResult;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public class Amazon.Runtime.Internal.Util.CrtCrc32c : HashAlgorithm {
    private UInt32 _rollingResult;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
public abstract class Amazon.Runtime.Internal.Util.DecryptionWrapper : object {
    private SymmetricAlgorithm algorithm;
    private ICryptoTransform decryptor;
    private static int encryptionKeySize;
    public ICryptoTransform Transformer { get; }
    protected abstract virtual SymmetricAlgorithm CreateAlgorithm();
    public sealed virtual ICryptoTransform get_Transformer();
    public sealed virtual void SetDecryptionData(Byte[] key, Byte[] IV);
    public sealed virtual void CreateDecryptor();
}
public class Amazon.Runtime.Internal.Util.DecryptionWrapperAES : DecryptionWrapper {
    protected virtual SymmetricAlgorithm CreateAlgorithm();
}
public abstract class Amazon.Runtime.Internal.Util.DecryptStream : WrapperStream {
    [CompilerGeneratedAttribute]
private CryptoStream <CryptoStream>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecryptionWrapper <Algorithm>k__BackingField;
    protected CryptoStream CryptoStream { get; protected set; }
    protected IDecryptionWrapper Algorithm { get; protected set; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    protected DecryptStream(Stream baseStream);
    [CompilerGeneratedAttribute]
protected CryptoStream get_CryptoStream();
    [CompilerGeneratedAttribute]
protected void set_CryptoStream(CryptoStream value);
    [CompilerGeneratedAttribute]
protected IDecryptionWrapper get_Algorithm();
    [CompilerGeneratedAttribute]
protected void set_Algorithm(IDecryptionWrapper value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.DecryptStream/<ReadAsync>d__10")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    private void ValidateBaseStream();
}
public class Amazon.Runtime.Internal.Util.DecryptStream`1 : DecryptStream {
    public DecryptStream`1(Stream baseStream, Byte[] envelopeKey, Byte[] IV);
}
public abstract class Amazon.Runtime.Internal.Util.EncryptionWrapper : object {
    private SymmetricAlgorithm algorithm;
    private ICryptoTransform encryptor;
    private static int encryptionKeySize;
    protected abstract virtual SymmetricAlgorithm CreateAlgorithm();
    public sealed virtual int AppendBlock(Byte[] buffer, int offset, int count, Byte[] target, int targetOffset);
    public sealed virtual Byte[] AppendLastBlock(Byte[] buffer, int offset, int count);
    public sealed virtual void CreateEncryptor();
    public sealed virtual void SetEncryptionData(Byte[] key, Byte[] IV);
    public sealed virtual void Reset();
}
public class Amazon.Runtime.Internal.Util.EncryptionWrapperAES : EncryptionWrapper {
    protected virtual SymmetricAlgorithm CreateAlgorithm();
}
public abstract class Amazon.Runtime.Internal.Util.EncryptStream : WrapperStream {
    [CompilerGeneratedAttribute]
private IEncryptionWrapper <Algorithm>k__BackingField;
    private static int internalEncryptionBlockSize;
    private Byte[] internalBuffer;
    private bool performedLastBlockTransform;
    protected IEncryptionWrapper Algorithm { get; protected set; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected EncryptStream(Stream baseStream);
    [CompilerGeneratedAttribute]
protected IEncryptionWrapper get_Algorithm();
    [CompilerGeneratedAttribute]
protected void set_Algorithm(IEncryptionWrapper value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.EncryptStream/<ReadAsync>d__9")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private int Append(Byte[] buffer, int offset, long previousPosition, int readBytes);
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    private void ValidateBaseStream();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public class Amazon.Runtime.Internal.Util.EncryptStream`1 : EncryptStream {
    public EncryptStream`1(Stream baseStream, Byte[] key, Byte[] IV);
}
public abstract class Amazon.Runtime.Internal.Util.EncryptUploadPartStream : WrapperStream {
    [CompilerGeneratedAttribute]
private IEncryptionWrapper <Algorithm>k__BackingField;
    private Byte[] internalBuffer;
    [CompilerGeneratedAttribute]
private Byte[] <InitializationVector>k__BackingField;
    internal static int InternalEncryptionBlockSize;
    protected IEncryptionWrapper Algorithm { get; protected set; }
    public Byte[] InitializationVector { get; protected set; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected EncryptUploadPartStream(Stream baseStream);
    [CompilerGeneratedAttribute]
protected IEncryptionWrapper get_Algorithm();
    [CompilerGeneratedAttribute]
protected void set_Algorithm(IEncryptionWrapper value);
    [CompilerGeneratedAttribute]
public Byte[] get_InitializationVector();
    [CompilerGeneratedAttribute]
protected void set_InitializationVector(Byte[] value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.EncryptUploadPartStream/<ReadAsync>d__12")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private int Append(Byte[] buffer, int offset, int readBytes);
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    private void ValidateBaseStream();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public class Amazon.Runtime.Internal.Util.EncryptUploadPartStream`1 : EncryptUploadPartStream {
    public EncryptUploadPartStream`1(Stream baseStream, Byte[] key, Byte[] IV);
}
internal class Amazon.Runtime.Internal.Util.EventStream : WrapperStream {
    [CompilerGeneratedAttribute]
private ReadProgress OnRead;
    private bool disableClose;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal EventStream(Stream stream, bool disableClose);
    [CompilerGeneratedAttribute]
internal void add_OnRead(ReadProgress value);
    [CompilerGeneratedAttribute]
internal void remove_OnRead(ReadProgress value);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.EventStream/<ReadAsync>d__33")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Amazon.Runtime.Internal.Util.Extensions : object {
    private static long TicksPerSecond;
    private static double TickFrequency;
    private static Extensions();
    [ExtensionAttribute]
public static long GetElapsedDateTimeTicks(Stopwatch self);
    [ExtensionAttribute]
public static bool HasRequestData(IRequest request);
}
public static class Amazon.Runtime.Internal.Util.GuidUtils : object {
    public static bool TryParseNullableGuid(string value, Nullable`1& result);
    public static bool TryParseGuid(string value, Guid& result);
}
public static class Amazon.Runtime.Internal.Util.Hashing : object {
    public static int Hash(Object[] value);
    public static int CombineHashes(Int32[] hashes);
    private static int CombineHashesInternal(int a, int b);
}
public class Amazon.Runtime.Internal.Util.HashingWrapper : object {
    private static string MD5ManagedName;
    private HashAlgorithm _algorithm;
    public HashingWrapper(string algorithmName);
    public HashingWrapper(HashAlgorithm algorithm);
    private static HashingWrapper();
    public sealed virtual void AppendBlock(Byte[] buffer);
    public sealed virtual Byte[] AppendLastBlock(Byte[] buffer);
    public sealed virtual void Dispose();
    private void Init(string algorithmName);
    public sealed virtual void Clear();
    public sealed virtual Byte[] ComputeHash(Byte[] buffer);
    public sealed virtual Byte[] ComputeHash(Stream stream);
    public sealed virtual void AppendBlock(Byte[] buffer, int offset, int count);
    public sealed virtual Byte[] AppendLastBlock(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
public class Amazon.Runtime.Internal.Util.HashingWrapperCRC32 : HashingWrapper {
}
public class Amazon.Runtime.Internal.Util.HashingWrapperCRC32C : HashingWrapper {
}
public class Amazon.Runtime.Internal.Util.HashingWrapperMD5 : HashingWrapper {
}
public class Amazon.Runtime.Internal.Util.HashingWrapperSHA1 : HashingWrapper {
}
public class Amazon.Runtime.Internal.Util.HashingWrapperSHA256 : HashingWrapper {
}
public abstract class Amazon.Runtime.Internal.Util.HashStream : WrapperStream {
    [CompilerGeneratedAttribute]
private IHashingWrapper <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CalculatedHash>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExpectedHash>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpectedLength>k__BackingField;
    protected IHashingWrapper Algorithm { get; protected set; }
    protected bool FinishedHashing { get; }
    protected long CurrentPosition { get; private set; }
    public Byte[] CalculatedHash { get; protected set; }
    public Byte[] ExpectedHash { get; private set; }
    public long ExpectedLength { get; protected set; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public long Length { get; }
    protected HashStream(Stream baseStream, Byte[] expectedHash, long expectedLength);
    [CompilerGeneratedAttribute]
protected IHashingWrapper get_Algorithm();
    [CompilerGeneratedAttribute]
protected void set_Algorithm(IHashingWrapper value);
    protected bool get_FinishedHashing();
    [CompilerGeneratedAttribute]
protected long get_CurrentPosition();
    [CompilerGeneratedAttribute]
private void set_CurrentPosition(long value);
    [CompilerGeneratedAttribute]
public Byte[] get_CalculatedHash();
    [CompilerGeneratedAttribute]
protected void set_CalculatedHash(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ExpectedHash();
    [CompilerGeneratedAttribute]
private void set_ExpectedHash(Byte[] value);
    [CompilerGeneratedAttribute]
public long get_ExpectedLength();
    [CompilerGeneratedAttribute]
protected void set_ExpectedLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.HashStream/<ReadAsync>d__24")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Length();
    public virtual void CalculateHash();
    public void Reset();
    private void ValidateBaseStream();
    protected static bool CompareHashes(Byte[] expected, Byte[] actual);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public class Amazon.Runtime.Internal.Util.HashStream`1 : HashStream {
    public HashStream`1(Stream baseStream, Byte[] expectedHash, long expectedLength);
}
public static class Amazon.Runtime.Internal.Util.HostPrefixUtils : object {
    private static string LabelValidationRegexPattern;
    [GeneratedRegexAttribute("^[A-Za-z0-9\-]+$", "16")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
private static Regex LabelValidationRegex();
    public static bool IsValidLabelValue(string value);
}
public interface Amazon.Runtime.Internal.Util.ICache {
    public TimeSpan MaximumItemLifespan { get; public set; }
    public TimeSpan CacheClearPeriod { get; public set; }
    public int ItemCount { get; }
    public abstract virtual void Clear();
    public abstract virtual TimeSpan get_MaximumItemLifespan();
    public abstract virtual void set_MaximumItemLifespan(TimeSpan value);
    public abstract virtual TimeSpan get_CacheClearPeriod();
    public abstract virtual void set_CacheClearPeriod(TimeSpan value);
    public abstract virtual int get_ItemCount();
}
public interface Amazon.Runtime.Internal.Util.ICache`2 {
    public List`1<TKey> Keys { get; }
    public abstract virtual TValue GetValue(TKey key, Func`2<TKey, TValue> creator);
    public abstract virtual TValue GetValue(TKey key, Func`2<TKey, TValue> creator, Boolean& isStaleItem);
    public abstract virtual void Clear(TKey key);
    public abstract virtual List`1<TKey> get_Keys();
    public abstract virtual TOut UseCache(TKey key, Func`1<TOut> operation, Action onError, Predicate`1<Exception> shouldRetryForException);
}
public interface Amazon.Runtime.Internal.Util.IDecryptionWrapper {
    public ICryptoTransform Transformer { get; }
    public abstract virtual ICryptoTransform get_Transformer();
    public abstract virtual void SetDecryptionData(Byte[] key, Byte[] IV);
    public abstract virtual void CreateDecryptor();
}
public interface Amazon.Runtime.Internal.Util.IEncryptionWrapper {
    public abstract virtual void Reset();
    public abstract virtual int AppendBlock(Byte[] buffer, int offset, int count, Byte[] target, int targetOffset);
    public abstract virtual Byte[] AppendLastBlock(Byte[] buffer, int offset, int count);
    public abstract virtual void SetEncryptionData(Byte[] key, Byte[] IV);
    public abstract virtual void CreateEncryptor();
}
public interface Amazon.Runtime.Internal.Util.IHashingWrapper {
    public abstract virtual void Clear();
    public abstract virtual Byte[] ComputeHash(Byte[] buffer);
    public abstract virtual Byte[] ComputeHash(Stream stream);
    public abstract virtual void AppendBlock(Byte[] buffer);
    public abstract virtual void AppendBlock(Byte[] buffer, int offset, int count);
    public abstract virtual Byte[] AppendLastBlock(Byte[] buffer);
    public abstract virtual Byte[] AppendLastBlock(Byte[] buffer, int offset, int count);
}
public interface Amazon.Runtime.Internal.Util.ILogger {
    public abstract virtual void InfoFormat(string messageFormat, Object[] args);
    public abstract virtual void Debug(Exception exception, string messageFormat, Object[] args);
    public abstract virtual void DebugFormat(string messageFormat, Object[] args);
    public abstract virtual void Error(Exception exception, string messageFormat, Object[] args);
    public abstract virtual void Flush();
}
public class Amazon.Runtime.Internal.Util.IniFile : object {
    private static string sectionNamePrefix;
    private static string sectionNameSuffix;
    private static string keyValueSeparator;
    private static string semiColonComment;
    private static string hashComment;
    private OptimisticLockedTextFile textFile;
    private Logger logger;
    public string FilePath { get; }
    private List`1<string> Lines { get; }
    public IniFile(string filePath);
    public string get_FilePath();
    private List`1<string> get_Lines();
    public void Persist();
    public void RenameSection(string oldSectionName, string newSectionName);
    public void RenameSection(string oldSectionName, string newSectionName, bool force);
    public void CopySection(string fromSectionName, string toSectionName, Dictionary`2<string, string> replaceProperties);
    public void CopySection(string fromSectionName, string toSectionName, Dictionary`2<string, string> replaceProperties, bool force);
    public virtual void EditSection(string sectionName, SortedDictionary`2<string, string> properties);
    public void EnsureSectionExists(string sectionName);
    public void DeleteSection(string sectionName);
    public virtual HashSet`1<string> ListSectionNames();
    public bool SectionExists(string sectionName);
    public bool SectionExists(Regex sectionNameRegex, String& sectionName);
    public virtual bool TryGetSection(string sectionName, Dictionary`2& properties);
    public bool TryGetSection(Regex sectionNameRegex, Dictionary`2& properties);
    public bool TryGetSection(Regex sectionNameRegex, Dictionary`2& properties, Dictionary`2& nestedProperties);
    public bool TryGetSection(Regex sectionNameRegex, String& sectionName, Dictionary`2& properties);
    public bool TryGetSection(Regex sectionNameRegex, String& sectionName, Dictionary`2& properties, Dictionary`2& nestedProperties);
    public virtual string ToString();
    private bool IsDuplicateProperty(Dictionary`2<string, string> properties, string propertyName, string sectionName, int lineNumber);
    private void Validate();
    private bool TrySeekSection(Regex sectionNameRegex, Int32& lineNumber, String& sectionName);
    private bool TrySeekSection(string sectionName, Int32& lineNumber);
    private bool SeekSection(Int32& lineNumber, String& sectionName);
    private bool SeekProperty(Int32& lineNumber, String& propertyName, String& propertyValue, NestedProperty& nestedProperty);
    private bool TryParseSubproperties(Int32& lineNumber, string propertyName, NestedProperty& nestedProperty);
    private string GetErrorMessage(int lineNumber);
    private static bool IsCommentOrBlank(string line);
    private static bool IsSection(string line);
    private static bool TryParseSection(string line, String& sectionName);
    private static bool IsProperty(string line);
    private static bool TryParseProperty(string line, String& propertyName, String& propertyValue);
    private static string GetPropertyLine(string propertyName, string propertyValue);
    private string GetLineMessage(int lineNumber);
    private static bool StartsWithWhitespace(string line);
}
internal class Amazon.Runtime.Internal.Util.InternalConsoleLogger : InternalLogger {
    public static long _sequanceId;
    public InternalConsoleLogger(Type declaringType);
    public virtual void Flush();
    public virtual void Error(Exception exception, string messageFormat, Object[] args);
    public virtual void Debug(Exception exception, string messageFormat, Object[] args);
    public virtual void DebugFormat(string message, Object[] arguments);
    public virtual void InfoFormat(string message, Object[] arguments);
    private void Log(LogLevel logLevel, string message, Exception ex);
}
[RequiresUnreferencedCodeAttribute("SDK logging to Log4net is not supported when trimming is enabled.")]
internal class Amazon.Runtime.Internal.Util.InternalLog4netLogger : InternalLogger {
    private static LoadState loadState;
    private static object LOCK;
    private static Type logMangerType;
    private static MethodInfo getLoggerWithTypeMethod;
    private static Type logType;
    private static MethodInfo logMethod;
    private static Type levelType;
    private static object debugLevelPropertyValue;
    private static object infoLevelPropertyValue;
    private static object errorLevelPropertyValue;
    private static MethodInfo isEnabledForMethod;
    private static Type systemStringFormatType;
    private static Type loggerType;
    private object internalLogger;
    private Nullable`1<bool> isErrorEnabled;
    private Nullable`1<bool> isDebugEnabled;
    private Nullable`1<bool> isInfoEnabled;
    public bool IsErrorEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public InternalLog4netLogger(Type declaringType);
    private static InternalLog4netLogger();
    private static void loadStatics();
    public virtual void Flush();
    public virtual bool get_IsErrorEnabled();
    public virtual void Error(Exception exception, string messageFormat, Object[] args);
    public virtual bool get_IsDebugEnabled();
    public virtual void Debug(Exception exception, string messageFormat, Object[] args);
    public virtual void DebugFormat(string message, Object[] arguments);
    public virtual bool get_IsInfoEnabled();
    public virtual void InfoFormat(string message, Object[] arguments);
}
internal abstract class Amazon.Runtime.Internal.Util.InternalLogger : object {
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public Type DeclaringType { get; private set; }
    public bool IsEnabled { get; public set; }
    public bool IsErrorEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public InternalLogger(Type declaringType);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
private void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    public abstract virtual void Flush();
    public virtual bool get_IsErrorEnabled();
    public virtual bool get_IsDebugEnabled();
    public virtual bool get_IsInfoEnabled();
    public abstract virtual void Error(Exception exception, string messageFormat, Object[] args);
    public abstract virtual void Debug(Exception exception, string messageFormat, Object[] args);
    public abstract virtual void DebugFormat(string message, Object[] arguments);
    public abstract virtual void InfoFormat(string message, Object[] arguments);
}
internal class Amazon.Runtime.Internal.Util.InternalSystemDiagnosticsLogger : InternalLogger {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) eventId;
    private TraceSource trace;
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsInfoEnabled { get; }
    public InternalSystemDiagnosticsLogger(Type declaringType);
    public virtual void Flush();
    public virtual void Error(Exception exception, string messageFormat, Object[] args);
    public virtual void Debug(Exception exception, string messageFormat, Object[] args);
    public virtual void DebugFormat(string messageFormat, Object[] args);
    public virtual void InfoFormat(string message, Object[] arguments);
    public virtual bool get_IsDebugEnabled();
    public virtual bool get_IsErrorEnabled();
    public virtual bool get_IsInfoEnabled();
}
public class Amazon.Runtime.Internal.Util.Logger : object {
    private static IDictionary`2<Type, Logger> cachedLoggers;
    private List`1<InternalLogger> loggers;
    private static Logger emptyLogger;
    public static Logger EmptyLogger { get; }
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
private Logger(Type type);
    private static Logger();
    private void ConfigsChanged(object sender, PropertyChangedEventArgs e);
    private void ConfigureLoggers();
    public static Logger GetLogger(Type type);
    public static void ClearLoggerCache();
    public static Logger get_EmptyLogger();
    public sealed virtual void Flush();
    public sealed virtual void Error(Exception exception, string messageFormat, Object[] args);
    public sealed virtual void Debug(Exception exception, string messageFormat, Object[] args);
    public sealed virtual void DebugFormat(string messageFormat, Object[] args);
    public sealed virtual void InfoFormat(string messageFormat, Object[] args);
}
public class Amazon.Runtime.Internal.Util.LogMessage : object {
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public Object[] Args { get; private set; }
    public IFormatProvider Provider { get; private set; }
    public string Format { get; private set; }
    public LogMessage(string message);
    public LogMessage(string format, Object[] args);
    public LogMessage(IFormatProvider provider, string format, Object[] args);
    [CompilerGeneratedAttribute]
public sealed virtual Object[] get_Args();
    [CompilerGeneratedAttribute]
private void set_Args(Object[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IFormatProvider get_Provider();
    [CompilerGeneratedAttribute]
private void set_Provider(IFormatProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
    public virtual string ToString();
}
public class Amazon.Runtime.Internal.Util.LruCache`2 : object {
    private object cacheLock;
    private Dictionary`2<TKey, LruListItem`2<TKey, TValue>> cache;
    private LruList`2<TKey, TValue> lruList;
    [CompilerGeneratedAttribute]
private int <MaxEntries>k__BackingField;
    public int MaxEntries { get; private set; }
    public int Count { get; }
    public LruCache`2(int maxEntries);
    [CompilerGeneratedAttribute]
public int get_MaxEntries();
    [CompilerGeneratedAttribute]
private void set_MaxEntries(int value);
    public int get_Count();
    public LruListItem`2<TKey, TValue> FindOldestItem();
    public void EvictExpiredLRUListItems(int validityInSeconds);
    public void AddOrUpdate(TKey key, TValue value);
    public void Evict(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> factory);
    public void Clear();
}
public class Amazon.Runtime.Internal.Util.LruList`2 : object {
    [CompilerGeneratedAttribute]
private LruListItem`2<TKey, TValue> <Head>k__BackingField;
    [CompilerGeneratedAttribute]
private LruListItem`2<TKey, TValue> <Tail>k__BackingField;
    public LruListItem`2<TKey, TValue> Head { get; private set; }
    public LruListItem`2<TKey, TValue> Tail { get; private set; }
    [CompilerGeneratedAttribute]
public LruListItem`2<TKey, TValue> get_Head();
    [CompilerGeneratedAttribute]
private void set_Head(LruListItem`2<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public LruListItem`2<TKey, TValue> get_Tail();
    [CompilerGeneratedAttribute]
private void set_Tail(LruListItem`2<TKey, TValue> value);
    public void Add(LruListItem`2<TKey, TValue> item);
    public void Remove(LruListItem`2<TKey, TValue> item);
    public void Touch(LruListItem`2<TKey, TValue> item);
    public TKey EvictOldest();
    internal void Clear();
}
public class Amazon.Runtime.Internal.Util.LruListItem`2 : object {
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastTouchedTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private LruListItem`2<TKey, TValue> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private LruListItem`2<TKey, TValue> <Previous>k__BackingField;
    public TValue Value { get; public set; }
    public TKey Key { get; private set; }
    public DateTime LastTouchedTimestamp { get; public set; }
    public LruListItem`2<TKey, TValue> Next { get; public set; }
    public LruListItem`2<TKey, TValue> Previous { get; public set; }
    public LruListItem`2(TKey key, TValue value);
    [CompilerGeneratedAttribute]
public TValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(TValue value);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(TKey value);
    [CompilerGeneratedAttribute]
public DateTime get_LastTouchedTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastTouchedTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public LruListItem`2<TKey, TValue> get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(LruListItem`2<TKey, TValue> value);
    [CompilerGeneratedAttribute]
public LruListItem`2<TKey, TValue> get_Previous();
    [CompilerGeneratedAttribute]
public void set_Previous(LruListItem`2<TKey, TValue> value);
}
public class Amazon.Runtime.Internal.Util.MD5Stream : HashStream`1<HashingWrapperMD5> {
    private Logger _logger;
    public MD5Stream(Stream baseStream, Byte[] expectedHash, long expectedLength);
}
public class Amazon.Runtime.Internal.Util.MetricError : object {
    [CompilerGeneratedAttribute]
private Metric <Metric>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    public Metric Metric { get; private set; }
    public string Message { get; private set; }
    public Exception Exception { get; private set; }
    public DateTime Time { get; private set; }
    public MetricError(Metric metric, string messageFormat, Object[] args);
    public MetricError(Metric metric, Exception exception, string messageFormat, Object[] args);
    [CompilerGeneratedAttribute]
public Metric get_Metric();
    [CompilerGeneratedAttribute]
private void set_Metric(Metric value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [CompilerGeneratedAttribute]
private void set_Time(DateTime value);
}
public static class Amazon.Runtime.Internal.Util.MultiValueHeaderParser : object {
    private static char Delimiter;
    private static MultiValueHeaderParser();
    public static List`1<string> ToStringList(string header);
    public static List`1<DateTime> ToDateTimeList(string header, string format);
    public static List`1<T> ToValueTypeList(string header);
    private static Tuple`2<string, int> ReadValue(Byte[] input, int startAtIndex);
    private static Tuple`2<string, int> ReadUnquotedValue(Byte[] input, int startIndex);
    private static Tuple`2<string, int> ReadQuotedValue(Byte[] input, int startIndex);
    private static int AdvanceIndexIfComma(Byte[] input, int index);
}
internal class Amazon.Runtime.Internal.Util.NestedProperty : object {
    [CompilerGeneratedAttribute]
private string <ParentKey>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SubpropertyKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SubpropertyValues>k__BackingField;
    public string ParentKey { get; public set; }
    public List`1<string> SubpropertyKeys { get; public set; }
    public List`1<string> SubpropertyValues { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ParentKey();
    [CompilerGeneratedAttribute]
public void set_ParentKey(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_SubpropertyKeys();
    [CompilerGeneratedAttribute]
public void set_SubpropertyKeys(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_SubpropertyValues();
    [CompilerGeneratedAttribute]
public void set_SubpropertyValues(List`1<string> value);
}
public class Amazon.Runtime.Internal.Util.NonDisposingWrapperStream : WrapperStream {
    public NonDisposingWrapperStream(Stream baseStream);
    protected virtual void Dispose(bool disposing);
}
internal class Amazon.Runtime.Internal.Util.NullStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class Amazon.Runtime.Internal.Util.OptimisticLockedTextFile : object {
    [CompilerGeneratedAttribute]
private string <OriginalContents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Lines>k__BackingField;
    private string OriginalContents { get; private set; }
    public string FilePath { get; private set; }
    public List`1<string> Lines { get; private set; }
    public OptimisticLockedTextFile(string filePath);
    [CompilerGeneratedAttribute]
private string get_OriginalContents();
    [CompilerGeneratedAttribute]
private void set_OriginalContents(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(List`1<string> value);
    public void Persist();
    public virtual string ToString();
    private void Read();
    private static bool HasEnding(string line);
    private static List`1<string> ReadLinesWithEndings(string str);
}
public class Amazon.Runtime.Internal.Util.PartialReadOnlyWrapperStream : ReadOnlyWrapperStream {
    private long _currentPosition;
    private long _size;
    private long RemainingSize { get; }
    public long Length { get; }
    public long Position { get; }
    public PartialReadOnlyWrapperStream(Stream baseStream, long size);
    private long get_RemainingSize();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.PartialReadOnlyWrapperStream/<ReadAsync>d__6")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public class Amazon.Runtime.Internal.Util.PartialWrapperStream : WrapperStream {
    private long initialPosition;
    private long partSize;
    private long RemainingPartSize { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PartialWrapperStream(Stream stream, long partSize);
    private long get_RemainingPartSize();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.PartialWrapperStream/<ReadAsync>d__15")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public class Amazon.Runtime.Internal.Util.ProfileIniFile : IniFile {
    private static string ProfileMarker;
    private static string SsoSessionMarker;
    private static string ServicesMarker;
    [CompilerGeneratedAttribute]
private bool <ProfileMarkerRequired>k__BackingField;
    public bool ProfileMarkerRequired { get; public set; }
    public ProfileIniFile(string filePath, bool profileMarkerRequired);
    [CompilerGeneratedAttribute]
public bool get_ProfileMarkerRequired();
    [CompilerGeneratedAttribute]
public void set_ProfileMarkerRequired(bool value);
    public virtual HashSet`1<string> ListSectionNames();
    public bool TryGetSection(string sectionName, bool isSsoSession, bool isServicesSection, Dictionary`2& properties, Dictionary`2& nestedProperties);
    [ObsoleteAttribute("TryGetSection(string sectionName, bool isSsoSession, out Dictionary<string,string> properties is deprecated. Please use the overloadedmethod with nestedProperties instead")]
public virtual bool TryGetSection(string sectionName, Dictionary`2& properties);
    [ObsoleteAttribute("TryGetSection(string sectionName, bool isSsoSession, out Dictionary<string,string> properties is deprecated. Please use the overloadedmethod with nestedProperties instead")]
public bool TryGetSection(string sectionName, bool isSsoSession, Dictionary`2& properties);
    public virtual void EditSection(string sectionName, SortedDictionary`2<string, string> properties);
    public void EditSection(string sectionName, bool isSsoSession, SortedDictionary`2<string, string> properties);
}
public class Amazon.Runtime.Internal.Util.ReadOnlyWrapperStream : WrapperStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyWrapperStream(Stream baseStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public class Amazon.Runtime.Internal.Util.RequestMetrics : object {
    private object metricsLock;
    private Stopwatch stopWatch;
    private Dictionary`2<Metric, Timing> inFlightTimings;
    private List`1<MetricError> errors;
    [CompilerGeneratedAttribute]
private Dictionary`2<Metric, List`1<object>> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Metric, List`1<IMetricsTiming>> <Timings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<Metric, long> <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    private long CurrentTime { get; }
    public Dictionary`2<Metric, List`1<object>> Properties { get; public set; }
    public Dictionary`2<Metric, List`1<IMetricsTiming>> Timings { get; public set; }
    public Dictionary`2<Metric, long> Counters { get; public set; }
    public bool IsEnabled { get; internal set; }
    private long get_CurrentTime();
    private void LogError_Locked(Metric metric, string messageFormat, Object[] args);
    private static void Log(StringBuilder builder, Metric metric, object metricValue);
    private static void Log(StringBuilder builder, Metric metric, List`1<object> metricValues);
    private static void LogHelper(StringBuilder builder, Metric metric, Object[] metricValues);
    private static string ObjectToString(object data);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<Metric, List`1<object>> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<Metric, List`1<object>> value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<Metric, List`1<IMetricsTiming>> get_Timings();
    [CompilerGeneratedAttribute]
public void set_Timings(Dictionary`2<Metric, List`1<IMetricsTiming>> value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<Metric, long> get_Counters();
    [CompilerGeneratedAttribute]
public void set_Counters(Dictionary`2<Metric, long> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsEnabled(bool value);
    public TimingEvent StartEvent(Metric metric);
    public Timing StopEvent(Metric metric);
    public void AddProperty(Metric metric, object property);
    public void SetCounter(Metric metric, long value);
    public void IncrementCounter(Metric metric);
    public string GetErrors();
    public virtual string ToString();
    public sealed virtual string ToJSON();
}
public class Amazon.Runtime.Internal.Util.S3Uri : object {
    private static string S3EndpointPattern;
    private static string S3ControlExlusionPattern;
    [CompilerGeneratedAttribute]
private bool <IsPathStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Bucket>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private RegionEndpoint <Region>k__BackingField;
    public bool IsPathStyle { get; private set; }
    public string Bucket { get; private set; }
    public string Key { get; private set; }
    public RegionEndpoint Region { get; public set; }
    public S3Uri(string uri);
    public S3Uri(Uri uri);
    [GeneratedRegexAttribute("^(.+\.)?s3[.-]([a-z0-9-]+)\.")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
private static Regex S3EndpointRegex();
    [GeneratedRegexAttribute("^(.+\.)?s3-control\.")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
private static Regex S3ControlExlusionRegex();
    [CompilerGeneratedAttribute]
public bool get_IsPathStyle();
    [CompilerGeneratedAttribute]
private void set_IsPathStyle(bool value);
    [CompilerGeneratedAttribute]
public string get_Bucket();
    [CompilerGeneratedAttribute]
private void set_Bucket(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public RegionEndpoint get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(RegionEndpoint value);
    public static bool IsS3Uri(Uri uri);
    private static string Decode(string s);
    private static string Decode(string s, int firstPercent);
    private static void AppendDecoded(StringBuilder builder, string s, int index);
    private static int FromHex(char c);
}
public static class Amazon.Runtime.Internal.Util.SdkCache : object {
    private static object cacheLock;
    private static Cache`2<CacheKey, ICache> cache;
    private static SdkCache();
    public static void Clear();
    public static void Clear(object cacheType);
    public static ICache`2<TKey, TValue> GetCache(object client, object cacheIdentifier, IEqualityComparer`1<TKey> keyComparer);
    public static ICache`2<TKey, TValue> GetCache(AmazonServiceClient client, object cacheIdentifier, IEqualityComparer`1<TKey> keyComparer);
}
public static class Amazon.Runtime.Internal.Util.StringUtils : object {
    private static Encoding UTF_8;
    private static Char[] rfc7230HeaderFieldValueDelimeters;
    private static StringUtils();
    public static string FromString(string value);
    public static string FromStringWithSlashEncoding(string value);
    public static string FromString(ConstantClass value);
    public static string FromMemoryStream(MemoryStream value);
    public static string FromInt(int value);
    public static string FromInt(Nullable`1<int> value);
    public static string FromLong(long value);
    public static string FromLong(Nullable`1<long> value);
    public static string FromFloat(float value);
    public static string FromFloat(Nullable`1<float> value);
    public static string FromSpecialFloatValue(float value);
    public static bool IsSpecialFloatValue(float value);
    public static bool IsSpecialDoubleValue(double value);
    public static string FromSpecialDoubleValue(double value);
    public static string FromBool(Nullable`1<bool> value);
    public static string FromBool(bool value);
    [ObsoleteAttribute("This method doesn't handle correctly non-UTC DateTimes. Use FromDateTimeToISO8601 instead.", "False")]
public static string FromDateTime(DateTime value);
    public static string FromDateTimeToISO8601(DateTime value);
    public static string FromDateTimeToISO8601(Nullable`1<DateTime> value);
    public static string FromDateTimeToISO8601NoMs(DateTime value);
    public static string FromDateTimeToISO8601WithOptionalMs(DateTime value);
    public static string FromDateTimeToISO8601WithOptionalMs(Nullable`1<DateTime> value);
    public static string FromDateTimeToRFC822(DateTime value);
    public static string FromDateTimeToRFC822(Nullable`1<DateTime> value);
    public static string FromDateTimeToUnixTimestamp(DateTime value);
    public static string FromDateTimeToUnixTimestamp(Nullable`1<DateTime> value);
    public static string FromDouble(double value);
    public static string FromDouble(Nullable`1<double> value);
    public static string FromDecimal(decimal value);
    public static string FromDecimal(Nullable`1<decimal> value);
    public static string FromList(IEnumerable`1<Enum> values);
    public static string FromList(List`1<Enum> values);
    public static string FromList(IEnumerable`1<T> values);
    public static string FromList(List`1<T> values);
    public static string FromValueTypeList(IEnumerable`1<T> values);
    public static string FromValueTypeList(List`1<T> values);
    public static string FromList(IEnumerable`1<string> values);
    private static string EscapeHeaderListEntry(string headerListEntry);
    public static long Utf8ByteLength(string value);
}
public class Amazon.Runtime.Internal.Util.Timing : object {
    private long startTime;
    private long endTime;
    [CompilerGeneratedAttribute]
private bool <IsFinished>k__BackingField;
    public bool IsFinished { get; private set; }
    public long ElapsedTicks { get; }
    public TimeSpan ElapsedTime { get; }
    public Timing(long currentTime);
    public void Stop(long currentTime);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFinished();
    [CompilerGeneratedAttribute]
private void set_IsFinished(bool value);
    public sealed virtual long get_ElapsedTicks();
    public sealed virtual TimeSpan get_ElapsedTime();
}
public class Amazon.Runtime.Internal.Util.TimingEvent : object {
    private Metric metric;
    private RequestMetrics metrics;
    private bool disposed;
    internal TimingEvent(RequestMetrics metrics, Metric metric);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal static class Amazon.Runtime.Internal.Util.TraceSourceUtil : object {
    public static TraceSource GetTraceSource(Type targetType);
    public static TraceSource GetTraceSource(Type targetType, SourceLevels sourceLevels);
    private static TraceSource GetTraceSourceWithListeners(string name, SourceLevels sourceLevels);
}
public class Amazon.Runtime.Internal.Util.TrailingHeadersWrapperStream : WrapperStream {
    private static string STREAM_NEWLINE;
    private static string EMPTY_CHUNK;
    private static int NEWLINE_LENGTH;
    private static int EMPTY_CHUNK_LENGTH;
    private static int HEADER_ROW_PADDING_LENGTH;
    private Stream _baseStream;
    private HashAlgorithm _hashAlgorithm;
    private IDictionary`2<string, string> _trailingHeaders;
    private CoreChecksumAlgorithm _checksumAlgorithm;
    private string _prefix;
    private string _suffix;
    private bool _haveFinishedPrefix;
    private bool _haveFinishedStream;
    private bool _haveFinishedSuffix;
    private int _prefixPosition;
    private int _suffixPosition;
    public long Length { get; }
    public bool CanSeek { get; }
    internal bool HasLength { get; }
    public TrailingHeadersWrapperStream(Stream baseStream, IDictionary`2<string, string> trailingHeaders);
    public TrailingHeadersWrapperStream(Stream baseStream, IDictionary`2<string, string> trailingHeaders, CoreChecksumAlgorithm checksumAlgorithm);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.TrailingHeadersWrapperStream/<ReadAsync>d__19")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Amazon.Runtime.Internal.Util.TrailingHeadersWrapperStream/<ReadInternal>d__20")]
private Task`1<int> ReadInternal(Byte[] buffer, int offset, int count, bool useAsyncRead, CancellationToken cancellationToken);
    private string GenerateContentChunkLength();
    private int ReadFromPrefix(Byte[] buffer, int offset, int countRemainingForThisRead);
    private string GenerateTrailingHeaderChunk();
    private int ReadFromSuffix(Byte[] buffer, int offset, int countRemainingForThisRead);
    public virtual long get_Length();
    public static long CalculateLength(IDictionary`2<string, string> trailingHeaders, CoreChecksumAlgorithm checksumAlgorithm, long baseStreamLength);
    public virtual bool get_CanSeek();
    internal virtual bool get_HasLength();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private int <>n__0(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__1(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
public static class Amazon.Runtime.Internal.Util.TransformServiceId : object {
    public static string TransformServiceIdToConfigVariable(string serviceId);
    public static string TransformServiceIdToEnvVariable(string serviceId);
}
public class Amazon.Runtime.Internal.Util.WebProxy : object {
    [CompilerGeneratedAttribute]
private Uri <ProxyUri>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    public Uri ProxyUri { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebProxy(string proxyUri);
    public WebProxy(Uri proxyUri);
    public WebProxy(string proxyHost, int proxyPort);
    [CompilerGeneratedAttribute]
public Uri get_ProxyUri();
    [CompilerGeneratedAttribute]
public void set_ProxyUri(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri host);
}
public class Amazon.Runtime.Internal.Util.WrapperStream : Stream {
    [CompilerGeneratedAttribute]
private Stream <BaseStream>k__BackingField;
    protected Stream BaseStream { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal bool HasLength { get; }
    public WrapperStream(Stream baseStream);
    [CompilerGeneratedAttribute]
protected Stream get_BaseStream();
    [CompilerGeneratedAttribute]
private void set_BaseStream(Stream value);
    public Stream GetNonWrapperBaseStream();
    public Stream GetSeekableBaseStream();
    public static Stream GetNonWrapperBaseStream(Stream stream);
    public Stream SearchWrappedStream(Func`2<Stream, bool> condition);
    public static Stream SearchWrappedStream(Stream stream, Func`2<Stream, bool> condition);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    internal virtual bool get_HasLength();
}
public class Amazon.Runtime.Internal.Util.XMLEncodedStringWriter : StringWriter {
    public XMLEncodedStringWriter(IFormatProvider formatProvider);
    public virtual void Write(Char[] buffer, int index, int count);
}
public interface Amazon.Runtime.IPaginatedEnumerable`1 {
}
public interface Amazon.Runtime.IPaginator`1 {
    public abstract virtual IAsyncEnumerable`1<TResponse> PaginateAsync(CancellationToken cancellationToken);
}
public interface Amazon.Runtime.IPipelineHandler {
    public ILogger Logger { get; public set; }
    public IPipelineHandler InnerHandler { get; public set; }
    public IPipelineHandler OuterHandler { get; public set; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual IPipelineHandler get_InnerHandler();
    public abstract virtual void set_InnerHandler(IPipelineHandler value);
    public abstract virtual IPipelineHandler get_OuterHandler();
    public abstract virtual void set_OuterHandler(IPipelineHandler value);
    public abstract virtual void InvokeSync(IExecutionContext executionContext);
    public abstract virtual Task`1<T> InvokeAsync(IExecutionContext executionContext);
}
public interface Amazon.Runtime.IRequestContext {
    public AmazonWebServiceRequest OriginalRequest { get; public set; }
    public string RequestName { get; }
    public IMarshaller`2<IRequest, AmazonWebServiceRequest> Marshaller { get; }
    public ResponseUnmarshaller Unmarshaller { get; }
    public InvokeOptionsBase Options { get; }
    public RequestMetrics Metrics { get; }
    public AbstractAWSSigner Signer { get; }
    public IClientConfig ClientConfig { get; }
    public ImmutableCredentials ImmutableCredentials { get; public set; }
    public IRequest Request { get; public set; }
    public bool IsSigned { get; public set; }
    public bool IsAsync { get; }
    public int Retries { get; public set; }
    public CapacityType LastCapacityType { get; public set; }
    public int EndpointDiscoveryRetries { get; public set; }
    public CancellationToken CancellationToken { get; }
    public MonitoringAPICallAttempt CSMCallAttempt { get; public set; }
    public MonitoringAPICallEvent CSMCallEvent { get; public set; }
    public IServiceMetadata ServiceMetaData { get; }
    public bool CSMEnabled { get; }
    public bool IsLastExceptionRetryable { get; public set; }
    public Guid InvocationId { get; }
    public IDictionary`2<string, object> ContextAttributes { get; }
    public abstract virtual AmazonWebServiceRequest get_OriginalRequest();
    public abstract virtual void set_OriginalRequest(AmazonWebServiceRequest value);
    public abstract virtual string get_RequestName();
    public abstract virtual IMarshaller`2<IRequest, AmazonWebServiceRequest> get_Marshaller();
    public abstract virtual ResponseUnmarshaller get_Unmarshaller();
    public abstract virtual InvokeOptionsBase get_Options();
    public abstract virtual RequestMetrics get_Metrics();
    public abstract virtual AbstractAWSSigner get_Signer();
    public abstract virtual IClientConfig get_ClientConfig();
    public abstract virtual ImmutableCredentials get_ImmutableCredentials();
    public abstract virtual void set_ImmutableCredentials(ImmutableCredentials value);
    public abstract virtual IRequest get_Request();
    public abstract virtual void set_Request(IRequest value);
    public abstract virtual bool get_IsSigned();
    public abstract virtual void set_IsSigned(bool value);
    public abstract virtual bool get_IsAsync();
    public abstract virtual int get_Retries();
    public abstract virtual void set_Retries(int value);
    public abstract virtual CapacityType get_LastCapacityType();
    public abstract virtual void set_LastCapacityType(CapacityType value);
    public abstract virtual int get_EndpointDiscoveryRetries();
    public abstract virtual void set_EndpointDiscoveryRetries(int value);
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual MonitoringAPICallAttempt get_CSMCallAttempt();
    public abstract virtual void set_CSMCallAttempt(MonitoringAPICallAttempt value);
    public abstract virtual MonitoringAPICallEvent get_CSMCallEvent();
    public abstract virtual void set_CSMCallEvent(MonitoringAPICallEvent value);
    public abstract virtual IServiceMetadata get_ServiceMetaData();
    public abstract virtual bool get_CSMEnabled();
    public abstract virtual bool get_IsLastExceptionRetryable();
    public abstract virtual void set_IsLastExceptionRetryable(bool value);
    public abstract virtual Guid get_InvocationId();
    public abstract virtual IDictionary`2<string, object> get_ContextAttributes();
}
public interface Amazon.Runtime.IRequestMetrics {
    public Dictionary`2<Metric, List`1<object>> Properties { get; }
    public Dictionary`2<Metric, List`1<IMetricsTiming>> Timings { get; }
    public Dictionary`2<Metric, long> Counters { get; }
    public bool IsEnabled { get; }
    public abstract virtual Dictionary`2<Metric, List`1<object>> get_Properties();
    public abstract virtual Dictionary`2<Metric, List`1<IMetricsTiming>> get_Timings();
    public abstract virtual Dictionary`2<Metric, long> get_Counters();
    public abstract virtual bool get_IsEnabled();
    public abstract virtual string ToJSON();
}
public interface Amazon.Runtime.IResponseContext {
    public AmazonWebServiceResponse Response { get; public set; }
    public IWebResponseData HttpResponse { get; public set; }
    public abstract virtual AmazonWebServiceResponse get_Response();
    public abstract virtual void set_Response(AmazonWebServiceResponse value);
    public abstract virtual IWebResponseData get_HttpResponse();
    public abstract virtual void set_HttpResponse(IWebResponseData value);
}
public interface Amazon.Runtime.ISSOTokenProviderFactory {
    public abstract virtual SSOTokenProvider Build(CredentialProfile profile);
}
public enum Amazon.Runtime.Metric : Enum {
    public int value__;
    public static Metric AWSErrorCode;
    public static Metric AWSRequestID;
    public static Metric AmzId2;
    public static Metric BytesProcessed;
    public static Metric Exception;
    public static Metric RedirectLocation;
    public static Metric ResponseProcessingTime;
    public static Metric ResponseUnmarshallTime;
    public static Metric ResponseReadTime;
    public static Metric StatusCode;
    public static Metric AttemptCount;
    public static Metric CredentialsRequestTime;
    public static Metric HttpRequestTime;
    public static Metric ProxyHost;
    public static Metric ProxyPort;
    public static Metric RequestSigningTime;
    public static Metric RetryPauseTime;
    public static Metric StringToSign;
    public static Metric CanonicalRequest;
    public static Metric CSMAttemptLatency;
    public static Metric AsyncCall;
    public static Metric ClientExecuteTime;
    public static Metric MethodName;
    public static Metric ServiceEndpoint;
    public static Metric ServiceName;
    public static Metric RequestSize;
    public static Metric AmzCfId;
    public static Metric RequestCompressionTime;
    public static Metric UncompressedRequestSize;
}
internal class Amazon.Runtime.MonitoringListener : object {
    private static MonitoringListener csmMonitoringListenerInstance;
    private string _host;
    private UdpClient _udpClient;
    private Logger logger;
    private int _port;
    private bool _disposed;
    public static MonitoringListener Instance { get; }
    private static MonitoringListener();
    public static MonitoringListener get_Instance();
    public void PostMessagesOverUDP(string response);
    [AsyncStateMachineAttribute("Amazon.Runtime.MonitoringListener/<PostMessagesOverUDPAsync>d__10")]
public Task PostMessagesOverUDPAsync(string response);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class Amazon.Runtime.PaginatedResponse`1 : object {
    private IPaginator`1<TResponse> _paginator;
    public PaginatedResponse`1(IPaginator`1<TResponse> paginator);
    [AsyncIteratorStateMachineAttribute("Amazon.Runtime.PaginatedResponse`1/<GetAsyncEnumerator>d__2")]
public sealed virtual IAsyncEnumerator`1<TResponse> GetAsyncEnumerator(CancellationToken cancellationToken);
}
public class Amazon.Runtime.PaginatedResultKeyResponse`2 : object {
    private IPaginator`1<TResponse> _paginator;
    private Func`2<TResponse, IEnumerable`1<TResultKey>> _resultKeySelector;
    public PaginatedResultKeyResponse`2(IPaginator`1<TResponse> paginator, Func`2<TResponse, IEnumerable`1<TResultKey>> resultKeySelector);
    [AsyncIteratorStateMachineAttribute("Amazon.Runtime.PaginatedResultKeyResponse`2/<GetAsyncEnumerator>d__3")]
public sealed virtual IAsyncEnumerator`1<TResultKey> GetAsyncEnumerator(CancellationToken cancellationToken);
}
public static class Amazon.Runtime.PaginatorUtils : object {
    public static void SetUserAgentAdditionOnRequest(AmazonWebServiceRequest request);
}
public abstract class Amazon.Runtime.ParameterValue : object {
}
public class Amazon.Runtime.PreRequestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private AmazonWebServiceRequest <Request>k__BackingField;
    public AmazonWebServiceRequest Request { get; protected set; }
    [CompilerGeneratedAttribute]
public AmazonWebServiceRequest get_Request();
    [CompilerGeneratedAttribute]
protected void set_Request(AmazonWebServiceRequest value);
    internal static PreRequestEventArgs Create(AmazonWebServiceRequest request);
}
public class Amazon.Runtime.PreRequestEventHandler : MulticastDelegate {
    public PreRequestEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PreRequestEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PreRequestEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Amazon.Runtime.ProcessAWSCredentialException : Exception {
    public ProcessAWSCredentialException(string message);
    public ProcessAWSCredentialException(string message, Exception inner);
}
public class Amazon.Runtime.ProcessAWSCredentials : RefreshingAWSCredentials {
    private static string _versionString;
    private Logger _logger;
    private ProcessStartInfo _processStartInfo;
    public ProcessAWSCredentials(string processCredentialInfo);
    protected virtual CredentialsRefreshState GenerateNewCredentials();
    protected virtual Task`1<CredentialsRefreshState> GenerateNewCredentialsAsync();
    public CredentialsRefreshState DetermineProcessCredential();
    [AsyncStateMachineAttribute("Amazon.Runtime.ProcessAWSCredentials/<DetermineProcessCredentialAsync>d__7")]
public Task`1<CredentialsRefreshState> DetermineProcessCredentialAsync();
    private CredentialsRefreshState SetCredentialsRefreshState(ProcessExecutionResult processInfo);
}
[ObsoleteAttribute("This class has been deprecated in favor of ProfileAWSConfiguration.")]
public class Amazon.Runtime.ProfileAWSEndpointDiscoveryEnabled : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public bool Enabled { get; private set; }
    public ProfileAWSEndpointDiscoveryEnabled(ICredentialProfileSource source);
    public ProfileAWSEndpointDiscoveryEnabled(ICredentialProfileSource source, string profileName);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
private void set_Enabled(bool value);
    private void Setup(ICredentialProfileSource source, string profileName);
}
public class Amazon.Runtime.ProfileAWSRegion : AWSRegion {
    public ProfileAWSRegion(ICredentialProfileSource source);
    public ProfileAWSRegion(ICredentialProfileSource source, string profileName);
    private void Setup(ICredentialProfileSource source, string profileName);
}
public class Amazon.Runtime.ProfileTokenProvider : object {
    private ISSOTokenProviderFactory _ssoTokenProviderFactory;
    private ICredentialProfileSource _credentialProfileSource;
    private string _profileName;
    public ProfileTokenProvider(ISSOTokenProviderFactory ssoTokenProviderFactory, ICredentialProfileSource credentialProfileSource, string profileName);
    public ProfileTokenProvider(string profileName);
    public sealed virtual Task`1<TryResponse`1<AWSToken>> TryResolveTokenAsync(CancellationToken cancellationToken);
    private bool LoadAndValidateProfile(CredentialProfile& profile);
}
public abstract class Amazon.Runtime.RefreshingAWSCredentials : AWSCredentials {
    private Logger _logger;
    protected CredentialsRefreshState currentState;
    private TimeSpan _preemptExpiryTime;
    private bool _disposed;
    private SemaphoreSlim _updateGeneratedCredentialsSemaphore;
    public TimeSpan PreemptExpiryTime { get; public set; }
    protected bool ShouldUpdate { get; }
    public TimeSpan get_PreemptExpiryTime();
    public void set_PreemptExpiryTime(TimeSpan value);
    public virtual ImmutableCredentials GetCredentials();
    [AsyncStateMachineAttribute("Amazon.Runtime.RefreshingAWSCredentials/<GetCredentialsAsync>d__10")]
public virtual Task`1<ImmutableCredentials> GetCredentialsAsync();
    private static void UpdateToGeneratedCredentials(CredentialsRefreshState state, TimeSpan preemptExpiryTime);
    protected bool get_ShouldUpdate();
    private static bool ShouldUpdateState(CredentialsRefreshState state, TimeSpan preemptExpiryTime);
    protected virtual CredentialsRefreshState GenerateNewCredentials();
    protected virtual Task`1<CredentialsRefreshState> GenerateNewCredentialsAsync();
    protected virtual void Dispose(bool disposing);
    public virtual void ClearCredentials();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private CredentialsRefreshState <GenerateNewCredentialsAsync>b__16_0();
}
public class Amazon.Runtime.RequestEventArgs : EventArgs {
}
public class Amazon.Runtime.RequestEventHandler : MulticastDelegate {
    public RequestEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RequestEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RequestEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Amazon.Runtime.RequestRetryMode : Enum {
    public int value__;
    public static RequestRetryMode Standard;
    public static RequestRetryMode Adaptive;
}
public class Amazon.Runtime.ResponseEventArgs : EventArgs {
}
public class Amazon.Runtime.ResponseEventHandler : MulticastDelegate {
    public ResponseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ResponseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResponseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Amazon.Runtime.ResponseMetadata : object {
    private string requestIdField;
    private IDictionary`2<string, string> _metadata;
    [CompilerGeneratedAttribute]
private CoreChecksumAlgorithm <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ChecksumValidationStatus <ChecksumValidationStatus>k__BackingField;
    public string RequestId { get; public set; }
    public IDictionary`2<string, string> Metadata { get; }
    public CoreChecksumAlgorithm ChecksumAlgorithm { get; public set; }
    public ChecksumValidationStatus ChecksumValidationStatus { get; public set; }
    public string get_RequestId();
    public void set_RequestId(string value);
    public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public CoreChecksumAlgorithm get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
public void set_ChecksumAlgorithm(CoreChecksumAlgorithm value);
    [CompilerGeneratedAttribute]
public ChecksumValidationStatus get_ChecksumValidationStatus();
    [CompilerGeneratedAttribute]
public void set_ChecksumValidationStatus(ChecksumValidationStatus value);
}
public class Amazon.Runtime.RetryableDetails : object {
    [CompilerGeneratedAttribute]
private bool <Throttling>k__BackingField;
    public bool Throttling { get; private set; }
    public RetryableDetails(bool throttling);
    [CompilerGeneratedAttribute]
public bool get_Throttling();
    [CompilerGeneratedAttribute]
private void set_Throttling(bool value);
}
public abstract class Amazon.Runtime.RetryPolicy : object {
    [CompilerGeneratedAttribute]
private int <MaxRetries>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <ThrottlingErrorCodes>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <TimeoutErrorCodesToRetryOn>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <ErrorCodesToRetryOn>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<HttpStatusCode> <HttpStatusCodesToRetryOn>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<WebExceptionStatus> <WebExceptionStatusesToRetryOn>k__BackingField;
    [CompilerGeneratedAttribute]
private RetryCapacity <RetryCapacity>k__BackingField;
    private static string sslErrorZeroReturn;
    private static HashSet`1<string> clockSkewErrorCodes;
    private static string clockSkewMessageFormat;
    private static string clockSkewUpdatedFormat;
    private static string clockSkewMessageParen;
    private static string clockSkewMessagePlusSeparator;
    private static string clockSkewMessageMinusSeparator;
    private static TimeSpan clockSkewMaxThreshold;
    public int MaxRetries { get; protected set; }
    public ILogger Logger { get; public set; }
    public ICollection`1<string> ThrottlingErrorCodes { get; protected set; }
    public ICollection`1<string> TimeoutErrorCodesToRetryOn { get; protected set; }
    public ICollection`1<string> ErrorCodesToRetryOn { get; protected set; }
    public ICollection`1<HttpStatusCode> HttpStatusCodesToRetryOn { get; protected set; }
    public ICollection`1<WebExceptionStatus> WebExceptionStatusesToRetryOn { get; protected set; }
    protected RetryCapacity RetryCapacity { get; protected set; }
    private static RetryPolicy();
    [CompilerGeneratedAttribute]
public int get_MaxRetries();
    [CompilerGeneratedAttribute]
protected void set_MaxRetries(int value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public virtual ICollection`1<string> get_ThrottlingErrorCodes();
    [CompilerGeneratedAttribute]
protected virtual void set_ThrottlingErrorCodes(ICollection`1<string> value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_TimeoutErrorCodesToRetryOn();
    [CompilerGeneratedAttribute]
protected void set_TimeoutErrorCodesToRetryOn(ICollection`1<string> value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_ErrorCodesToRetryOn();
    [CompilerGeneratedAttribute]
protected void set_ErrorCodesToRetryOn(ICollection`1<string> value);
    [CompilerGeneratedAttribute]
public ICollection`1<HttpStatusCode> get_HttpStatusCodesToRetryOn();
    [CompilerGeneratedAttribute]
protected void set_HttpStatusCodesToRetryOn(ICollection`1<HttpStatusCode> value);
    [CompilerGeneratedAttribute]
public ICollection`1<WebExceptionStatus> get_WebExceptionStatusesToRetryOn();
    [CompilerGeneratedAttribute]
protected void set_WebExceptionStatusesToRetryOn(ICollection`1<WebExceptionStatus> value);
    [CompilerGeneratedAttribute]
protected RetryCapacity get_RetryCapacity();
    [CompilerGeneratedAttribute]
protected void set_RetryCapacity(RetryCapacity value);
    public bool Retry(IExecutionContext executionContext, Exception exception);
    public abstract virtual bool CanRetry(IExecutionContext executionContext);
    public abstract virtual bool RetryForException(IExecutionContext executionContext, Exception exception);
    public abstract virtual bool RetryLimitReached(IExecutionContext executionContext);
    public abstract virtual void WaitBeforeRetry(IExecutionContext executionContext);
    public virtual void NotifySuccess(IExecutionContext executionContext);
    public virtual bool OnRetry(IExecutionContext executionContext);
    public virtual bool OnRetry(IExecutionContext executionContext, bool bypassAcquireCapacity);
    public virtual bool OnRetry(IExecutionContext executionContext, bool bypassAcquireCapacity, bool isThrottlingError);
    public virtual void ObtainSendToken(IExecutionContext executionContext, Exception exception);
    public virtual bool IsThrottlingError(Exception exception);
    public virtual bool IsTransientError(IExecutionContext executionContext, Exception exception);
    public static bool IsTransientSslError(Exception exception);
    public virtual bool IsServiceTimeoutError(Exception exception);
    private bool IsClockskew(IExecutionContext executionContext, Exception exception);
    private static bool TryParseDateHeader(AmazonServiceException ase, DateTime& serverTime);
    private static bool TryParseExceptionMessage(AmazonServiceException ase, DateTime& serverTime);
    private static IWebResponseData GetWebData(AmazonServiceException ase);
    protected static bool ContainErrorMessage(Exception exception, HashSet`1<string> errorMessages);
    protected static string GetRetryCapacityKey(IClientConfig config);
    [AsyncStateMachineAttribute("Amazon.Runtime.RetryPolicy/<RetryAsync>d__60")]
public Task`1<bool> RetryAsync(IExecutionContext executionContext, Exception exception);
    public virtual Task ObtainSendTokenAsync(IExecutionContext executionContext, Exception exception);
    public abstract virtual Task`1<bool> RetryForExceptionAsync(IExecutionContext executionContext, Exception exception);
    public abstract virtual Task WaitBeforeRetryAsync(IExecutionContext executionContext);
}
public enum Amazon.Runtime.S3UsEast1RegionalEndpointValue : Enum {
    public int value__;
    public static S3UsEast1RegionalEndpointValue Legacy;
    public static S3UsEast1RegionalEndpointValue Regional;
}
public class Amazon.Runtime.SAMLImmutableCredentials : ImmutableCredentials {
    [CompilerGeneratedAttribute]
private DateTime <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    private static string AccessKeyProperty;
    private static string SecretKeyProperty;
    private static string TokenProperty;
    private static string ExpiresProperty;
    private static string SubjectProperty;
    public DateTime Expires { get; private set; }
    public string Subject { get; private set; }
    public SAMLImmutableCredentials(string awsAccessKeyId, string awsSecretAccessKey, string token, DateTime expires, string subject);
    public SAMLImmutableCredentials(ImmutableCredentials credentials, DateTime expires, string subject);
    [CompilerGeneratedAttribute]
public DateTime get_Expires();
    [CompilerGeneratedAttribute]
private void set_Expires(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual ImmutableCredentials Copy();
    internal string ToJson();
    internal static SAMLImmutableCredentials FromJson(string json);
}
public class Amazon.Runtime.SessionAWSCredentials : AWSCredentials {
    private ImmutableCredentials _lastCredentials;
    public SessionAWSCredentials(string awsAccessKeyId, string awsSecretAccessKey, string token);
    public virtual ImmutableCredentials GetCredentials();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Amazon.Runtime.SharedInterfaces.GetSsoTokenRequest : object {
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<SsoVerificationArguments> <SsoVerificationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private PkceFlowOptions <PkceFlowOptions>k__BackingField;
    public string ClientName { get; public set; }
    public string ClientType { get; public set; }
    public string StartUrl { get; public set; }
    public Action`1<SsoVerificationArguments> SsoVerificationCallback { get; public set; }
    public IDictionary`2<string, object> AdditionalProperties { get; public set; }
    public IList`1<string> Scopes { get; public set; }
    public PkceFlowOptions PkceFlowOptions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    [CompilerGeneratedAttribute]
public string get_ClientType();
    [CompilerGeneratedAttribute]
public void set_ClientType(string value);
    [CompilerGeneratedAttribute]
public string get_StartUrl();
    [CompilerGeneratedAttribute]
public void set_StartUrl(string value);
    [CompilerGeneratedAttribute]
public Action`1<SsoVerificationArguments> get_SsoVerificationCallback();
    [CompilerGeneratedAttribute]
public void set_SsoVerificationCallback(Action`1<SsoVerificationArguments> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public void set_Scopes(IList`1<string> value);
    [CompilerGeneratedAttribute]
public PkceFlowOptions get_PkceFlowOptions();
    [CompilerGeneratedAttribute]
public void set_PkceFlowOptions(PkceFlowOptions value);
}
public class Amazon.Runtime.SharedInterfaces.GetSsoTokenResponse : object {
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpiresAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientSecret>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegistrationExpiresAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeVerifier>k__BackingField;
    public string AccessToken { get; public set; }
    public DateTime ExpiresAt { get; public set; }
    public string RefreshToken { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public string RegistrationExpiresAt { get; public set; }
    public string Region { get; public set; }
    public string StartUrl { get; public set; }
    public string CodeVerifier { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public DateTime get_ExpiresAt();
    [CompilerGeneratedAttribute]
public void set_ExpiresAt(DateTime value);
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
    [CompilerGeneratedAttribute]
public void set_RefreshToken(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_ClientSecret();
    [CompilerGeneratedAttribute]
public void set_ClientSecret(string value);
    [CompilerGeneratedAttribute]
public string get_RegistrationExpiresAt();
    [CompilerGeneratedAttribute]
public void set_RegistrationExpiresAt(string value);
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(string value);
    [CompilerGeneratedAttribute]
public string get_StartUrl();
    [CompilerGeneratedAttribute]
public void set_StartUrl(string value);
    [CompilerGeneratedAttribute]
public string get_CodeVerifier();
    [CompilerGeneratedAttribute]
public void set_CodeVerifier(string value);
}
public interface Amazon.Runtime.SharedInterfaces.IAWSSigV4aProvider {
    public ClientProtocol Protocol { get; }
    public abstract virtual ClientProtocol get_Protocol();
    public abstract virtual void Sign(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public abstract virtual AWS4aSigningResult SignRequest(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials);
    public abstract virtual AWS4aSigningResult Presign4a(IRequest request, IClientConfig clientConfig, RequestMetrics metrics, ImmutableCredentials credentials, string service, string overrideSigningRegion);
    public abstract virtual string SignChunk(Stream chunkBody, string previousSignature, AWS4aSigningResult headerSigningResult);
    public abstract virtual string SignTrailingHeaderChunk(IDictionary`2<string, string> trailingHeaders, string previousSignature, AWS4aSigningResult headerSigningResult);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonS3 {
    public abstract virtual string GeneratePreSignedURL(string bucketName, string objectKey, DateTime expiration, IDictionary`2<string, object> additionalProperties);
    public abstract virtual Task`1<IList`1<string>> GetAllObjectKeysAsync(string bucketName, string prefix, IDictionary`2<string, object> additionalProperties);
    public abstract virtual Task UploadObjectFromStreamAsync(string bucketName, string objectKey, Stream stream, IDictionary`2<string, object> additionalProperties, CancellationToken cancellationToken);
    public abstract virtual Task DeleteAsync(string bucketName, string objectKey, IDictionary`2<string, object> additionalProperties, CancellationToken cancellationToken);
    public abstract virtual Task DeletesAsync(string bucketName, IEnumerable`1<string> objectKeys, IDictionary`2<string, object> additionalProperties, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetObjectStreamAsync(string bucketName, string objectKey, IDictionary`2<string, object> additionalProperties, CancellationToken cancellationToken);
    public abstract virtual Task UploadObjectFromFilePathAsync(string bucketName, string objectKey, string filepath, IDictionary`2<string, object> additionalProperties, CancellationToken cancellationToken);
    public abstract virtual Task DownloadToFilePathAsync(string bucketName, string objectKey, string filepath, IDictionary`2<string, object> additionalProperties, CancellationToken cancellationToken);
    public abstract virtual Task MakeObjectPublicAsync(string bucketName, string objectKey, bool enable);
    public abstract virtual Task EnsureBucketExistsAsync(string bucketName);
    [ObsoleteAttribute("This method is deprecated: its behavior is inconsistent and always uses HTTP. Please use Amazon.S3.Util.AmazonS3Util.DoesS3BucketExistV2Async instead.")]
public abstract virtual Task`1<bool> DoesS3BucketExistAsync(string bucketName);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonSQS {
    public abstract virtual Task`1<Dictionary`2<string, string>> GetAttributesAsync(string queueUrl);
    public abstract virtual Task SetAttributesAsync(string queueUrl, Dictionary`2<string, string> attributes);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonSSO {
    public abstract virtual Task`1<ImmutableCredentials> CredentialsFromSsoAccessTokenAsync(string accountId, string roleName, string accessToken, IDictionary`2<string, object> additionalProperties);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonSSO_Logout {
    public abstract virtual Task LogoutAsync(string accessToken, CancellationToken cancellationToken);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonSSOOIDC {
    public abstract virtual Task`1<GetSsoTokenResponse> GetSsoTokenAsync(GetSsoTokenRequest getSsoTokenRequest);
    public abstract virtual Task`1<GetSsoTokenResponse> RefreshTokenAsync(GetSsoTokenResponse previousResponse);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonSSOOIDC_V2 {
    public abstract virtual Task`1<GetSsoTokenResponse> GetSsoTokenAsync(GetSsoTokenRequest getSsoTokenRequest, CancellationToken cancellationToken);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonSTS {
    public abstract virtual AssumeRoleImmutableCredentials CredentialsFromAssumeRoleAuthentication(string roleArn, string roleSessionName, AssumeRoleAWSCredentialsOptions options);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonSTS_SAML {
    public abstract virtual SAMLImmutableCredentials CredentialsFromSAMLAuthentication(string endpoint, string authenticationType, string roleARN, TimeSpan credentialDuration, ICredentials userCredential);
}
public interface Amazon.Runtime.SharedInterfaces.ICoreAmazonSTS_WebIdentity {
    public abstract virtual AssumeRoleImmutableCredentials CredentialsFromAssumeRoleWithWebIdentityAuthentication(string webIdentityToken, string roleArn, string roleSessionName, AssumeRoleWithWebIdentityCredentialsOptions options);
    public abstract virtual Task`1<AssumeRoleImmutableCredentials> CredentialsFromAssumeRoleWithWebIdentityAuthenticationAsync(string webIdentityToken, string roleArn, string roleSessionName, AssumeRoleWithWebIdentityCredentialsOptions options);
}
public interface Amazon.Runtime.SharedInterfaces.Internal.IChecksumProvider {
    public abstract virtual string Crc32(Byte[] source);
    public abstract virtual UInt32 Crc32(Byte[] source, UInt32 previous);
    public abstract virtual string Crc32C(Byte[] source);
    public abstract virtual UInt32 Crc32C(Byte[] source, UInt32 previous);
}
public class Amazon.Runtime.SharedInterfaces.PkceFlowOptions : object {
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <GrantTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IssuerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<Uri, CancellationToken, Task`1<string>> <RetrieveAuthorizationCodeCallbackAsync>k__BackingField;
    public string RedirectUri { get; public set; }
    public IList`1<string> GrantTypes { get; public set; }
    public string IssuerUrl { get; public set; }
    public Func`3<Uri, CancellationToken, Task`1<string>> RetrieveAuthorizationCodeCallbackAsync { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_GrantTypes();
    [CompilerGeneratedAttribute]
public void set_GrantTypes(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_IssuerUrl();
    [CompilerGeneratedAttribute]
public void set_IssuerUrl(string value);
    [CompilerGeneratedAttribute]
public Func`3<Uri, CancellationToken, Task`1<string>> get_RetrieveAuthorizationCodeCallbackAsync();
    [CompilerGeneratedAttribute]
public void set_RetrieveAuthorizationCodeCallbackAsync(Func`3<Uri, CancellationToken, Task`1<string>> value);
}
public class Amazon.Runtime.SignatureException : SignatureException {
    public SignatureException(string message);
    public SignatureException(string message, Exception innerException);
}
public enum Amazon.Runtime.SignatureVersion : Enum {
    public int value__;
    public static SignatureVersion SigV2;
    public static SignatureVersion SigV4;
    public static SignatureVersion SigV4a;
}
public enum Amazon.Runtime.SigningAlgorithm : Enum {
    public int value__;
    public static SigningAlgorithm HmacSHA1;
    public static SigningAlgorithm HmacSHA256;
}
public class Amazon.Runtime.SSOAWSCredentials : RefreshingAWSCredentials {
    private Logger _logger;
    private ISSOTokenManager _ssoTokenManager;
    [CompilerGeneratedAttribute]
private string <AccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private SSOAWSCredentialsOptions <Options>k__BackingField;
    public string AccountId { get; private set; }
    public string Region { get; private set; }
    public string RoleName { get; private set; }
    public string StartUrl { get; private set; }
    public SSOAWSCredentialsOptions Options { get; private set; }
    public SSOAWSCredentials(string accountId, string region, string roleName, string startUrl);
    public SSOAWSCredentials(string accountId, string region, string roleName, string startUrl, SSOAWSCredentialsOptions options);
    [CompilerGeneratedAttribute]
public string get_AccountId();
    [CompilerGeneratedAttribute]
private void set_AccountId(string value);
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
private void set_Region(string value);
    [CompilerGeneratedAttribute]
public string get_RoleName();
    [CompilerGeneratedAttribute]
private void set_RoleName(string value);
    [CompilerGeneratedAttribute]
public string get_StartUrl();
    [CompilerGeneratedAttribute]
private void set_StartUrl(string value);
    [CompilerGeneratedAttribute]
public SSOAWSCredentialsOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(SSOAWSCredentialsOptions value);
    protected virtual CredentialsRefreshState GenerateNewCredentials();
    [AsyncStateMachineAttribute("Amazon.Runtime.SSOAWSCredentials/<GenerateNewCredentialsAsync>d__25")]
protected virtual Task`1<CredentialsRefreshState> GenerateNewCredentialsAsync();
    private void ValidateCredentialsInputs();
    [AsyncStateMachineAttribute("Amazon.Runtime.SSOAWSCredentials/<GetSsoCredentialsAsync>d__27")]
private Task`1<ImmutableCredentials> GetSsoCredentialsAsync(ICoreAmazonSSO sso);
    [ObsoleteAttribute("This method is no longer used or supported and will be removed in a future version.", "False")]
public static bool HasCachedAccessTokenAvailable(string startUrl);
    [AsyncStateMachineAttribute("Amazon.Runtime.SSOAWSCredentials/<GetSsoRoleCredentialsAsync>d__29")]
private Task`1<ImmutableCredentials> GetSsoRoleCredentialsAsync(ICoreAmazonSSO sso, string accessToken);
}
public class Amazon.Runtime.SSOAWSCredentialsOptions : object {
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<SsoVerificationArguments> <SsoVerificationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private PkceFlowOptions <PkceFlowOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsGettingNewToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <ProxySettings>k__BackingField;
    public string ClientName { get; public set; }
    public string SessionName { get; public set; }
    public IList`1<string> Scopes { get; public set; }
    public Action`1<SsoVerificationArguments> SsoVerificationCallback { get; public set; }
    public PkceFlowOptions PkceFlowOptions { get; public set; }
    public bool SupportsGettingNewToken { get; public set; }
    public IWebProxy ProxySettings { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    [CompilerGeneratedAttribute]
public string get_SessionName();
    [CompilerGeneratedAttribute]
public void set_SessionName(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public void set_Scopes(IList`1<string> value);
    [CompilerGeneratedAttribute]
public Action`1<SsoVerificationArguments> get_SsoVerificationCallback();
    [CompilerGeneratedAttribute]
public void set_SsoVerificationCallback(Action`1<SsoVerificationArguments> value);
    [CompilerGeneratedAttribute]
public PkceFlowOptions get_PkceFlowOptions();
    [CompilerGeneratedAttribute]
public void set_PkceFlowOptions(PkceFlowOptions value);
    [CompilerGeneratedAttribute]
public bool get_SupportsGettingNewToken();
    [CompilerGeneratedAttribute]
public void set_SupportsGettingNewToken(bool value);
    [CompilerGeneratedAttribute]
public IWebProxy get_ProxySettings();
    [CompilerGeneratedAttribute]
public void set_ProxySettings(IWebProxy value);
}
public class Amazon.Runtime.SSOImmutableCredentials : ImmutableCredentials {
    [CompilerGeneratedAttribute]
private DateTime <Expiration>k__BackingField;
    public DateTime Expiration { get; private set; }
    public SSOImmutableCredentials(string awsAccessKeyId, string awsSecretAccessKey, string token, DateTime expiration);
    [CompilerGeneratedAttribute]
public DateTime get_Expiration();
    [CompilerGeneratedAttribute]
private void set_Expiration(DateTime value);
    public SSOImmutableCredentials Copy();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Amazon.Runtime.SSOTokenProvider : object {
    private ILogger _logger;
    private ISSOTokenManager _ssoTokenManager;
    private string _sessionName;
    private string _startUrl;
    private string _region;
    private string _ssoCacheDirectory;
    public SSOTokenProvider(ISSOTokenManager ssoTokenManager, string sessionName, string startUrl, string region, string ssoCacheDirectory);
    [AsyncStateMachineAttribute("Amazon.Runtime.SSOTokenProvider/<TryResolveTokenAsync>d__7")]
public sealed virtual Task`1<TryResponse`1<AWSToken>> TryResolveTokenAsync(CancellationToken cancellationToken);
    private SSOTokenManagerGetTokenOptions BuildSsoTokenManagerGetTokenOptions();
    private AWSToken MapSsoTokenToAwsToken(SsoToken token);
}
public class Amazon.Runtime.SSOTokenProviderFactory : object {
    private ISSOTokenFileCache _ssoTokenFileCache;
    public SSOTokenProviderFactory(ISSOTokenFileCache ssoTokenFileCache);
    public sealed virtual SSOTokenProvider Build(CredentialProfile profile);
}
public class Amazon.Runtime.SsoVerificationArguments : object {
    [CompilerGeneratedAttribute]
private string <UserCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerificationUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerificationUriComplete>k__BackingField;
    public string UserCode { get; public set; }
    public string VerificationUri { get; public set; }
    public string VerificationUriComplete { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UserCode();
    [CompilerGeneratedAttribute]
public void set_UserCode(string value);
    [CompilerGeneratedAttribute]
public string get_VerificationUri();
    [CompilerGeneratedAttribute]
public void set_VerificationUri(string value);
    [CompilerGeneratedAttribute]
public string get_VerificationUriComplete();
    [CompilerGeneratedAttribute]
public void set_VerificationUriComplete(string value);
    public string GetSsoSigninMessage();
}
public class Amazon.Runtime.StaticTokenProvider : object {
    private string _token;
    private Nullable`1<DateTime> _expiration;
    public StaticTokenProvider(string token, Nullable`1<DateTime> expiration);
    public sealed virtual Task`1<TryResponse`1<AWSToken>> TryResolveTokenAsync(CancellationToken cancellationToken);
    private bool IsTokenUnexpired();
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release. Please use Amazon.Runtime.CredentialManagement.NetSDKCredentialsFile or SharedCredentialsFile..  Visit http://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/net-dg-config-creds.html for further details.")]
public class Amazon.Runtime.StoredProfileAWSCredentials : AWSCredentials {
    private AWSCredentials _wrappedCredentials;
    [CompilerGeneratedAttribute]
private string <ProfileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProfilesLocation>k__BackingField;
    public AWSCredentials WrappedCredentials { get; }
    public string ProfileName { get; private set; }
    public string ProfilesLocation { get; private set; }
    public StoredProfileAWSCredentials(string profileName);
    public StoredProfileAWSCredentials(string profileName, string profilesLocation);
    public AWSCredentials get_WrappedCredentials();
    [CompilerGeneratedAttribute]
public string get_ProfileName();
    [CompilerGeneratedAttribute]
private void set_ProfileName(string value);
    [CompilerGeneratedAttribute]
public string get_ProfilesLocation();
    [CompilerGeneratedAttribute]
private void set_ProfilesLocation(string value);
    public static bool IsProfileKnown(string profileName, string profilesLocation);
    public static bool CanCreateFrom(string profileName, string profilesLocation);
    private static bool ValidCredentialsExistInSharedFile(string profilesLocation, string profileName);
    public virtual ImmutableCredentials GetCredentials();
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release. Please use Amazon.Runtime.CredentialManagement.NetSDKCredentialsFile or SharedCredentialsFile.  Visit http://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/net-dg-config-creds.html for further details.")]
public abstract class Amazon.Runtime.StoredProfileCredentials : object {
    public static string DEFAULT_PROFILE_NAME;
    public static string SHARED_CREDENTIALS_FILE_ENVVAR;
    private static String[] PotentialEnvironmentPathsToCredentialsFile;
    public static string DefaultSharedCredentialFilename;
    public static string DefaultSharedCredentialLocation;
    private static StoredProfileCredentials();
    public static AWSCredentials GetProfile(string profileName);
    public static AWSCredentials GetProfile(string profileName, string profileLocation);
    public static string ResolveSharedCredentialFileLocation(string profileLocation);
    private static string TestSharedCredentialFileExists(string pathOrFilename);
}
public class Amazon.Runtime.StreamTransferProgressArgs : EventArgs {
    private long _incrementTransferred;
    private long _total;
    private long _transferred;
    public int PercentDone { get; }
    public long IncrementTransferred { get; }
    public long TransferredBytes { get; }
    public long TotalBytes { get; }
    public StreamTransferProgressArgs(long incrementTransferred, long transferred, long total);
    public int get_PercentDone();
    public long get_IncrementTransferred();
    public long get_TransferredBytes();
    public long get_TotalBytes();
    public virtual string ToString();
}
public class Amazon.Runtime.StringListParameterValue : ParameterValue {
    [CompilerGeneratedAttribute]
private List`1<string> <Value>k__BackingField;
    public List`1<string> Value { get; public set; }
    public StringListParameterValue(List`1<string> values);
    [CompilerGeneratedAttribute]
public List`1<string> get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(List`1<string> value);
}
public class Amazon.Runtime.StringParameterValue : ParameterValue {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; public set; }
    public StringParameterValue(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
}
public class Amazon.Runtime.Telemetry.Attributes : object {
    private Dictionary`2<string, object> _attributes;
    public IEnumerable`1<KeyValuePair`2<string, object>> AllAttributes { get; }
    public Attributes(IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    public void Set(string key, object value);
    public object Get(string key);
    public bool Remove(string key);
    public IEnumerable`1<KeyValuePair`2<string, object>> get_AllAttributes();
}
public class Amazon.Runtime.Telemetry.DefaultTelemetryProvider : TelemetryProvider {
}
public abstract class Amazon.Runtime.Telemetry.Metrics.Histogram`1 : object {
    public abstract virtual void Record(T value, Attributes attributes);
}
public abstract class Amazon.Runtime.Telemetry.Metrics.Meter : object {
    public abstract virtual UpDownCounter`1<T> CreateUpDownCounter(string name, string units, string description);
    public abstract virtual MonotonicCounter`1<T> CreateMonotonicCounter(string name, string units, string description);
    public abstract virtual Histogram`1<T> CreateHistogram(string name, string units, string description);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public abstract class Amazon.Runtime.Telemetry.Metrics.MeterProvider : object {
    public abstract virtual Meter GetMeter(string scope, Attributes attributes);
}
internal static class Amazon.Runtime.Telemetry.Metrics.MetricsUtilities : object {
    public static void RecordError(IRequestContext requestContext, Exception exception);
    public static void AddMonotonicCounterValue(IRequestContext requestContext, string metricName, string unit, long value, Attributes initialAttributes);
    public static IDisposable MeasureDuration(IRequestContext requestContext, string metricName, Attributes initialAttributes);
    public static IDisposable MeasureDuration(IClientConfig config, string metricName, Attributes attributes);
}
public abstract class Amazon.Runtime.Telemetry.Metrics.MonotonicCounter`1 : object {
    public abstract virtual void Add(T value, Attributes attributes);
}
internal class Amazon.Runtime.Telemetry.Metrics.NoOp.NoOpHistogram`1 : Histogram`1<T> {
    public virtual void Record(T value, Attributes attributes);
}
internal class Amazon.Runtime.Telemetry.Metrics.NoOp.NoOpMeter : Meter {
    public virtual UpDownCounter`1<T> CreateUpDownCounter(string name, string units, string description);
    public virtual MonotonicCounter`1<T> CreateMonotonicCounter(string name, string units, string description);
    public virtual Histogram`1<T> CreateHistogram(string name, string units, string description);
}
internal class Amazon.Runtime.Telemetry.Metrics.NoOp.NoOpMeterProvider : MeterProvider {
    public virtual Meter GetMeter(string scope, Attributes attributes);
}
internal class Amazon.Runtime.Telemetry.Metrics.NoOp.NoOpMonotonicCounter`1 : MonotonicCounter`1<T> {
    public virtual void Add(T value, Attributes attributes);
}
internal class Amazon.Runtime.Telemetry.Metrics.NoOp.NoOpUpDownCounter`1 : UpDownCounter`1<T> {
    public virtual void Add(T value, Attributes attributes);
}
public abstract class Amazon.Runtime.Telemetry.Metrics.UpDownCounter`1 : object {
    public abstract virtual void Add(T value, Attributes attributes);
}
public static class Amazon.Runtime.Telemetry.TelemetryConstants : object {
    public static string TelemetryScopePrefix;
    public static string HTTPRequestSpanName;
    public static string RequestCompressionSpanName;
    public static string CredentialsRetrievalSpanName;
    public static string SystemAttributeKey;
    public static string SystemAttributeValue;
    public static string MethodAttributeKey;
    public static string ServiceAttributeKey;
    public static string RequestIdAttributeKey;
    public static string HTTPStatusCodeAttributeKey;
    public static string HTTPRequestContentLengthAttributeKey;
    public static string HTTPResponseContentLengthAttributeKey;
    public static string HTTPMethodAttributeKey;
    public static string ServerAddressAttributeKey;
    public static string ExceptionMessageAttributeKey;
    public static string ExceptionStackTraceAttributeKey;
    public static string ExceptionTypeAttributeKey;
    public static string ErrorAttributeKey;
    public static string AWSErrorCodeAttributeKey;
    public static string CallDurationMetricName;
    public static string ClientUptimeMetricName;
    public static string CallAttemptsMetricName;
    public static string CallErrorsMetricName;
    public static string CallAttemptDurationMetricName;
    public static string ResolveEndpointDurationMetricName;
    public static string SerializationDurationMetricName;
    public static string DeserializationDurationMetricName;
    public static string AuthSigningDurationMetricName;
    public static string ResolveIdentityDurationMetricName;
    public static string HTTPBytesSentMetricName;
    public static string HTTPBytesReceivedMetricName;
    public static string AttemptUnitName;
    public static string ErrorUnitName;
    public static string BytesUnitName;
    public static string SecondsUnitName;
}
public abstract class Amazon.Runtime.Telemetry.TelemetryProvider : object {
    [CompilerGeneratedAttribute]
private MeterProvider <MeterProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private TracerProvider <TracerProvider>k__BackingField;
    public MeterProvider MeterProvider { get; private set; }
    public TracerProvider TracerProvider { get; private set; }
    public TelemetryProvider(MeterProvider meterProvider, TracerProvider tracerProvider);
    [CompilerGeneratedAttribute]
public MeterProvider get_MeterProvider();
    [CompilerGeneratedAttribute]
private void set_MeterProvider(MeterProvider value);
    [CompilerGeneratedAttribute]
public TracerProvider get_TracerProvider();
    [CompilerGeneratedAttribute]
private void set_TracerProvider(TracerProvider value);
    public virtual void RegisterMeterProvider(MeterProvider meterProvider);
    public virtual void RegisterTracerProvider(TracerProvider tracerProvider);
}
internal class Amazon.Runtime.Telemetry.Tracing.NoOp.NoOpSpanContext : SpanContext {
    public string TraceId { get; }
    public string SpanId { get; }
    public bool IsRemote { get; }
    public bool IsValid { get; }
    public virtual string get_TraceId();
    public virtual string get_SpanId();
    public virtual bool get_IsRemote();
    public virtual bool get_IsValid();
}
internal class Amazon.Runtime.Telemetry.Tracing.NoOp.NoOpTracer : Tracer {
    public virtual TraceSpan CreateSpan(string name, Attributes initialAttributes, SpanKind spanKind, SpanContext parentContext);
}
internal class Amazon.Runtime.Telemetry.Tracing.NoOp.NoOpTracerProvider : TracerProvider {
    public virtual Tracer GetTracer(string scope);
}
internal class Amazon.Runtime.Telemetry.Tracing.NoOp.NoOpTraceSpan : TraceSpan {
    public virtual void EmitEvent(string name, Attributes attributes);
    public virtual void SetAttribute(string key, object value);
    public virtual void SetStatus(SpanStatus status);
    public virtual void RecordException(Exception exception, Attributes attributes);
    public virtual void End();
}
public abstract class Amazon.Runtime.Telemetry.Tracing.SpanContext : object {
    public string TraceId { get; }
    public string SpanId { get; }
    public bool IsRemote { get; }
    public bool IsValid { get; }
    public abstract virtual string get_TraceId();
    public abstract virtual string get_SpanId();
    public abstract virtual bool get_IsRemote();
    public abstract virtual bool get_IsValid();
}
public enum Amazon.Runtime.Telemetry.Tracing.SpanKind : Enum {
    public int value__;
    public static SpanKind INTERNAL;
    public static SpanKind CLIENT;
    public static SpanKind SERVER;
    public static SpanKind PRODUCER;
    public static SpanKind CONSUMER;
}
public enum Amazon.Runtime.Telemetry.Tracing.SpanStatus : Enum {
    public int value__;
    public static SpanStatus OK;
    public static SpanStatus ERROR;
    public static SpanStatus UNSET;
}
public abstract class Amazon.Runtime.Telemetry.Tracing.Tracer : object {
    public abstract virtual TraceSpan CreateSpan(string name, Attributes initialAttributes, SpanKind spanKind, SpanContext parentContext);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public abstract class Amazon.Runtime.Telemetry.Tracing.TracerProvider : object {
    public abstract virtual Tracer GetTracer(string scope);
}
public abstract class Amazon.Runtime.Telemetry.Tracing.TraceSpan : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public abstract virtual void EmitEvent(string name, Attributes attributes);
    public abstract virtual void SetAttribute(string key, object value);
    public abstract virtual void SetStatus(SpanStatus status);
    public abstract virtual void RecordException(Exception exception, Attributes attributes);
    public abstract virtual void End();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Amazon.Runtime.Telemetry.Tracing.TracingUtilities : object {
    public static TraceSpan CreateSpan(IRequestContext requestContext, string spanName, Attributes initialAttributes, SpanKind spanKind, SpanContext parentContext);
    [ExtensionAttribute]
public static void CaptureException(TraceSpan span, Exception exception);
}
public class Amazon.Runtime.TryResponse`1 : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public bool Success { get; public set; }
    public T Value { get; public set; }
    public static TryResponse`1<T> Failure { get; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    public static TryResponse`1<T> get_Failure();
}
public class Amazon.Runtime.URIBasedRefreshingCredentialHelper : RefreshingAWSCredentials {
    private static string SuccessCode;
    private static URIBasedRefreshingCredentialHelper();
    protected static string GetContents(Uri uri);
    protected static string GetContents(Uri uri, IWebProxy proxy);
    protected static string GetContents(Uri uri, IWebProxy proxy, Dictionary`2<string, string> headers);
    [ObsoleteAttribute("This method is not compatible with Native AOT builds. The GetObjectFromResponse overload using the generic parameter taking in a JsonSerializerContext should be used instead.")]
[RequiresUnreferencedCodeAttribute("GetObjectFromResponse overload using the generic parameter taking in a JsonSerializerContext should be used instead.")]
protected static T GetObjectFromResponse(Uri uri);
    [ObsoleteAttribute("This method is not compatible with Native AOT builds. The GetObjectFromResponse overload using the generic parameter taking in a JsonSerializerContext should be used instead.")]
[RequiresUnreferencedCodeAttribute("GetObjectFromResponse overload using the generic parameter taking in a JsonSerializerContext should be used instead.")]
protected static T GetObjectFromResponse(Uri uri, IWebProxy proxy);
    [ObsoleteAttribute("This method is not compatible with Native AOT builds. The GetObjectFromResponse overload using the generic parameter taking in a JsonSerializerContext should be used instead.")]
[RequiresUnreferencedCodeAttribute("GetObjectFromResponse overload using the generic parameter taking in a JsonSerializerContext should be used instead.")]
protected static T GetObjectFromResponse(Uri uri, IWebProxy proxy, Dictionary`2<string, string> headers);
    protected static T GetObjectFromResponse(Uri uri, IWebProxy proxy, Dictionary`2<string, string> headers);
    protected static void ValidateResponse(SecurityBase response);
}
public class Amazon.Runtime.WebServiceExceptionEventArgs : ExceptionEventArgs {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private AmazonWebServiceRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public IDictionary`2<string, string> Headers { get; protected set; }
    public IDictionary`2<string, string> Parameters { get; protected set; }
    public string ServiceName { get; protected set; }
    public Uri Endpoint { get; protected set; }
    public AmazonWebServiceRequest Request { get; protected set; }
    public Exception Exception { get; protected set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
protected void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
protected void set_Parameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
protected void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public Uri get_Endpoint();
    [CompilerGeneratedAttribute]
protected void set_Endpoint(Uri value);
    [CompilerGeneratedAttribute]
public AmazonWebServiceRequest get_Request();
    [CompilerGeneratedAttribute]
protected void set_Request(AmazonWebServiceRequest value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
protected void set_Exception(Exception value);
    internal static WebServiceExceptionEventArgs Create(Exception exception, IRequest request);
}
public class Amazon.Runtime.WebServiceRequestEventArgs : RequestEventArgs {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterCollection <ParameterCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private AmazonWebServiceRequest <Request>k__BackingField;
    public IDictionary`2<string, string> Headers { get; protected set; }
    [ObsoleteAttribute("Parameters property has been deprecated in favor of the ParameterCollection property")]
public IDictionary`2<string, string> Parameters { get; protected set; }
    public ParameterCollection ParameterCollection { get; protected set; }
    public string ServiceName { get; protected set; }
    public Uri Endpoint { get; protected set; }
    public AmazonWebServiceRequest Request { get; protected set; }
    [ObsoleteAttribute("OriginalRequest property has been deprecated in favor of the Request property")]
public AmazonWebServiceRequest OriginalRequest { get; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
protected void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
protected void set_Parameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public ParameterCollection get_ParameterCollection();
    [CompilerGeneratedAttribute]
protected void set_ParameterCollection(ParameterCollection value);
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
protected void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public Uri get_Endpoint();
    [CompilerGeneratedAttribute]
protected void set_Endpoint(Uri value);
    [CompilerGeneratedAttribute]
public AmazonWebServiceRequest get_Request();
    [CompilerGeneratedAttribute]
protected void set_Request(AmazonWebServiceRequest value);
    public AmazonWebServiceRequest get_OriginalRequest();
    internal static WebServiceRequestEventArgs Create(IRequest request);
}
public class Amazon.Runtime.WebServiceResponseEventArgs : ResponseEventArgs {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <RequestHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ResponseHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private AmazonWebServiceRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private AmazonWebServiceResponse <Response>k__BackingField;
    public IDictionary`2<string, string> RequestHeaders { get; private set; }
    public IDictionary`2<string, string> ResponseHeaders { get; private set; }
    public IDictionary`2<string, string> Parameters { get; private set; }
    public string ServiceName { get; private set; }
    public Uri Endpoint { get; private set; }
    public AmazonWebServiceRequest Request { get; private set; }
    public AmazonWebServiceResponse Response { get; private set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_RequestHeaders();
    [CompilerGeneratedAttribute]
private void set_RequestHeaders(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ResponseHeaders();
    [CompilerGeneratedAttribute]
private void set_ResponseHeaders(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
private void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public Uri get_Endpoint();
    [CompilerGeneratedAttribute]
private void set_Endpoint(Uri value);
    [CompilerGeneratedAttribute]
public AmazonWebServiceRequest get_Request();
    [CompilerGeneratedAttribute]
private void set_Request(AmazonWebServiceRequest value);
    [CompilerGeneratedAttribute]
public AmazonWebServiceResponse get_Response();
    [CompilerGeneratedAttribute]
private void set_Response(AmazonWebServiceResponse value);
    internal static WebServiceResponseEventArgs Create(AmazonWebServiceResponse response, IRequest request, IWebResponseData webResponseData);
}
public abstract class Amazon.RuntimeDependencies.BaseRuntimeDependencyRegistry : object {
    private ReaderWriterLockSlim _rwlock;
    private IDictionary`2<string, RuntimeDependencyFactory> _runtimeDependency;
    private bool _disposedValue;
    protected void RegisterInstance(string assemblyName, string className, object instance);
    protected void RegisterInstance(string assemblyName, string className, RuntimeDependencyFactory factory);
    public virtual T GetInstance(string assemblyName, string className, CreateInstanceContext context);
    private static string FormatKey(string assemblyName, string className);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Amazon.RuntimeDependencies.CheckSumProviderContext : object {
}
public class Amazon.RuntimeDependencies.CreateInstanceContext : object {
    [CompilerGeneratedAttribute]
private ContextType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityTokenServiceClientContext <SecurityTokenServiceClientContextData>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyManagementServiceClientContext <KeyManagementServiceClientContextData>k__BackingField;
    [CompilerGeneratedAttribute]
private SigV4aCrtSignerContext <SigV4aCrtSignerContextData>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckSumProviderContext <CheckSumProviderContextData>k__BackingField;
    [CompilerGeneratedAttribute]
private SSOClientContext <SSOClientContextData>k__BackingField;
    [CompilerGeneratedAttribute]
private SSOOIDCClientContext <SSOOIDCClientContextData>k__BackingField;
    public ContextType Type { get; }
    public SecurityTokenServiceClientContext SecurityTokenServiceClientContextData { get; }
    public KeyManagementServiceClientContext KeyManagementServiceClientContextData { get; }
    public SigV4aCrtSignerContext SigV4aCrtSignerContextData { get; }
    public CheckSumProviderContext CheckSumProviderContextData { get; }
    public SSOClientContext SSOClientContextData { get; }
    public SSOOIDCClientContext SSOOIDCClientContextData { get; }
    public CreateInstanceContext(SecurityTokenServiceClientContext context);
    public CreateInstanceContext(KeyManagementServiceClientContext context);
    public CreateInstanceContext(SigV4aCrtSignerContext context);
    public CreateInstanceContext(CheckSumProviderContext context);
    public CreateInstanceContext(SSOClientContext context);
    public CreateInstanceContext(SSOOIDCClientContext context);
    [CompilerGeneratedAttribute]
public ContextType get_Type();
    [CompilerGeneratedAttribute]
public SecurityTokenServiceClientContext get_SecurityTokenServiceClientContextData();
    [CompilerGeneratedAttribute]
public KeyManagementServiceClientContext get_KeyManagementServiceClientContextData();
    [CompilerGeneratedAttribute]
public SigV4aCrtSignerContext get_SigV4aCrtSignerContextData();
    [CompilerGeneratedAttribute]
public CheckSumProviderContext get_CheckSumProviderContextData();
    [CompilerGeneratedAttribute]
public SSOClientContext get_SSOClientContextData();
    [CompilerGeneratedAttribute]
public SSOOIDCClientContext get_SSOOIDCClientContextData();
}
public class Amazon.RuntimeDependencies.GlobalRuntimeDependencyRegistry : BaseRuntimeDependencyRegistry {
    private static GlobalRuntimeDependencyRegistry _instance;
    public static GlobalRuntimeDependencyRegistry Instance { get; }
    private static GlobalRuntimeDependencyRegistry();
    public static GlobalRuntimeDependencyRegistry get_Instance();
    public void RegisterChecksumProvider(object instance);
    public void RegisterSigV4aProvider(RuntimeDependencyFactory factory);
    public void RegisterSecurityTokenServiceClient(object instance);
    public void RegisterSecurityTokenServiceClient(RuntimeDependencyFactory factory);
    public void RegisterSSOClient(object instance);
    public void RegisterSSOClient(RuntimeDependencyFactory factory);
    public void RegisterSSOOIDCClient(object instance);
    public void RegisterSSOOIDCClient(RuntimeDependencyFactory factory);
}
public class Amazon.RuntimeDependencies.KeyManagementServiceClientContext : object {
    [CompilerGeneratedAttribute]
private AmazonServiceClient <ParentServiceClient>k__BackingField;
    public AmazonServiceClient ParentServiceClient { get; public set; }
    [CompilerGeneratedAttribute]
public AmazonServiceClient get_ParentServiceClient();
    [CompilerGeneratedAttribute]
public void set_ParentServiceClient(AmazonServiceClient value);
}
public class Amazon.RuntimeDependencies.MissingRuntimeDependencyException : AmazonClientException {
    [CompilerGeneratedAttribute]
private string <PackageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegisterMethod>k__BackingField;
    public string PackageName { get; public set; }
    public string ClassName { get; public set; }
    public string RegisterMethod { get; public set; }
    public MissingRuntimeDependencyException(string packageName, string className, string registerMethod);
    [CompilerGeneratedAttribute]
public string get_PackageName();
    [CompilerGeneratedAttribute]
public void set_PackageName(string value);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public string get_RegisterMethod();
    [CompilerGeneratedAttribute]
public void set_RegisterMethod(string value);
}
public class Amazon.RuntimeDependencies.RuntimeDependencyFactory : MulticastDelegate {
    public RuntimeDependencyFactory(object object, IntPtr method);
    public virtual object Invoke(CreateInstanceContext context);
    public virtual IAsyncResult BeginInvoke(CreateInstanceContext context, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class Amazon.RuntimeDependencies.SecurityTokenServiceClientContext : object {
    [CompilerGeneratedAttribute]
private ActionContext <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private RegionEndpoint <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <ProxySettings>k__BackingField;
    public ActionContext Action { get; public set; }
    public RegionEndpoint Region { get; public set; }
    public IWebProxy ProxySettings { get; public set; }
    [CompilerGeneratedAttribute]
public ActionContext get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(ActionContext value);
    [CompilerGeneratedAttribute]
public RegionEndpoint get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(RegionEndpoint value);
    [CompilerGeneratedAttribute]
public IWebProxy get_ProxySettings();
    [CompilerGeneratedAttribute]
public void set_ProxySettings(IWebProxy value);
}
public class Amazon.RuntimeDependencies.SigV4aCrtSignerContext : object {
    [CompilerGeneratedAttribute]
private bool <SignPayload>k__BackingField;
    public bool SignPayload { get; public set; }
    public SigV4aCrtSignerContext(bool signPayload);
    [CompilerGeneratedAttribute]
public bool get_SignPayload();
    [CompilerGeneratedAttribute]
public void set_SignPayload(bool value);
}
public class Amazon.RuntimeDependencies.SSOClientContext : object {
    [CompilerGeneratedAttribute]
private RegionEndpoint <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <ProxySettings>k__BackingField;
    public RegionEndpoint Region { get; public set; }
    public IWebProxy ProxySettings { get; public set; }
    [CompilerGeneratedAttribute]
public RegionEndpoint get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(RegionEndpoint value);
    [CompilerGeneratedAttribute]
public IWebProxy get_ProxySettings();
    [CompilerGeneratedAttribute]
public void set_ProxySettings(IWebProxy value);
}
public class Amazon.RuntimeDependencies.SSOOIDCClientContext : object {
    [CompilerGeneratedAttribute]
private RegionEndpoint <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <ProxySettings>k__BackingField;
    public RegionEndpoint Region { get; public set; }
    public IWebProxy ProxySettings { get; public set; }
    [CompilerGeneratedAttribute]
public RegionEndpoint get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(RegionEndpoint value);
    [CompilerGeneratedAttribute]
public IWebProxy get_ProxySettings();
    [CompilerGeneratedAttribute]
public void set_ProxySettings(IWebProxy value);
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release. Please use Amazon.Runtime.CredentialManagement.CredentialProfile.  Visit http://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/net-dg-config-creds.html for further details.")]
public class Amazon.Util.AWSCredentialsProfile : ProfileSettingsBase {
    [CompilerGeneratedAttribute]
private BasicAWSCredentials <Credentials>k__BackingField;
    public BasicAWSCredentials Credentials { get; private set; }
    private AWSCredentialsProfile(string profileName, string accessKeyId, string secretKey);
    [CompilerGeneratedAttribute]
public BasicAWSCredentials get_Credentials();
    [CompilerGeneratedAttribute]
private void set_Credentials(BasicAWSCredentials value);
    public static bool CanCreateFrom(string profileName);
    public static bool CanCreateFrom(ObjectSettings os);
    public static AWSCredentialsProfile LoadFrom(string profileName);
    public static AWSCredentialsProfile LoadFrom(ObjectSettings os);
    public static void Validate(string profileName);
    private static void Validate(ObjectSettings os);
    public virtual string Persist();
    public static string Persist(string profileName, string accessKeyId, string secretKey);
}
public class Amazon.Util.AWSHttpClient : object {
    private HttpClient _httpClient;
    private bool disposed;
    public Uri BaseAddress { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public long MaxResponseContentBufferSize { get; public set; }
    internal AWSHttpClient(IWebProxy proxy, bool useProxy);
    internal AWSHttpClient(HttpMessageHandler handler);
    internal AWSHttpClient(HttpMessageHandler handler, bool disposeHandler);
    public Uri get_BaseAddress();
    public void set_BaseAddress(Uri value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
    public long get_MaxResponseContentBufferSize();
    public void set_MaxResponseContentBufferSize(long value);
    public Task`1<Stream> GetStreamAsync(string requestUri);
    public Task PutRequestUriAsync(string requestUri, AWSStreamContent content, IDictionary`2<string, string> requestHeaders);
    [AsyncStateMachineAttribute("Amazon.Util.AWSHttpClient/<GetResponseHeadersAsync>d__17")]
public Task`1<List`1<Tuple`3<string, IEnumerable`1<string>, HttpStatusCode>>> GetResponseHeadersAsync(string httpMethodValue, string url);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static bool IsHttpInnerException(Exception exception);
}
public class Amazon.Util.AWSPublicIpAddressRange : object {
    [CompilerGeneratedAttribute]
private string <IpPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private AddressFormat <IpAddressFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NetworkBorderGroup>k__BackingField;
    public string IpPrefix { get; internal set; }
    public AddressFormat IpAddressFormat { get; internal set; }
    public string Region { get; internal set; }
    public string Service { get; internal set; }
    public string NetworkBorderGroup { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_IpPrefix();
    [CompilerGeneratedAttribute]
internal void set_IpPrefix(string value);
    [CompilerGeneratedAttribute]
public AddressFormat get_IpAddressFormat();
    [CompilerGeneratedAttribute]
internal void set_IpAddressFormat(AddressFormat value);
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
internal void set_Region(string value);
    [CompilerGeneratedAttribute]
public string get_Service();
    [CompilerGeneratedAttribute]
internal void set_Service(string value);
    [CompilerGeneratedAttribute]
public string get_NetworkBorderGroup();
    [CompilerGeneratedAttribute]
internal void set_NetworkBorderGroup(string value);
}
public class Amazon.Util.AWSPublicIpAddressRanges : object {
    public static string AmazonServiceKey;
    public static string EC2ServiceKey;
    public static string CloudFrontServiceKey;
    public static string Route53ServiceKey;
    public static string Route53HealthChecksServiceKey;
    public static string GlobalRegionIdentifier;
    private static string createDateKey;
    private static string ipv4PrefixesKey;
    private static string ipv4PrefixKey;
    private static string ipv6PrefixesKey;
    private static string ipv6PrefixKey;
    private static string regionKey;
    private static string serviceKey;
    private static string networkBorderGroupKey;
    private static string createDateFormatString;
    [CompilerGeneratedAttribute]
private DateTime <CreateDate>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<AWSPublicIpAddressRange> <AllAddressRanges>k__BackingField;
    private static Uri IpAddressRangeEndpoint;
    public IEnumerable`1<string> ServiceKeys { get; }
    public DateTime CreateDate { get; private set; }
    public IEnumerable`1<AWSPublicIpAddressRange> AllAddressRanges { get; private set; }
    private static AWSPublicIpAddressRanges();
    public IEnumerable`1<string> get_ServiceKeys();
    [CompilerGeneratedAttribute]
public DateTime get_CreateDate();
    [CompilerGeneratedAttribute]
private void set_CreateDate(DateTime value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<AWSPublicIpAddressRange> get_AllAddressRanges();
    [CompilerGeneratedAttribute]
private void set_AllAddressRanges(IEnumerable`1<AWSPublicIpAddressRange> value);
    public IEnumerable`1<AWSPublicIpAddressRange> AddressRangesByServiceKey(string serviceKey);
    public IEnumerable`1<AWSPublicIpAddressRange> AddressRangesByRegion(string regionIdentifier);
    public IEnumerable`1<AWSPublicIpAddressRange> AddressRangesByNetworkBorderGroup(string networkBorderGroup);
    public static AWSPublicIpAddressRanges Load();
    public static AWSPublicIpAddressRanges Load(IWebProxy proxy);
    private static AWSPublicIpAddressRanges Parse(string fileContent);
    private static IEnumerable`1<AWSPublicIpAddressRange> ParseRange(JsonData ranges, AddressFormat addressFormat);
}
public static class Amazon.Util.AWSSDKUtils : object {
    internal static string DefaultRegion;
    internal static string DefaultGovRegion;
    private static char WindowsDirectorySeparatorChar;
    private static char WindowsAltDirectorySeparatorChar;
    private static char WindowsVolumeSeparatorChar;
    private static char SlashChar;
    private static string Slash;
    private static string EncodedSlash;
    internal static int DefaultMaxRetry;
    private static int DefaultConnectionLimit;
    private static int DefaultMaxIdleTime;
    private static int MaxIsSetMethodsCacheSize;
    public static DateTime EPOCH_START;
    public static int DefaultBufferSize;
    public static long DefaultProgressUpdateInterval;
    internal static string S3Accelerate;
    internal static string S3Control;
    private static string _userAgent;
    public static string UserAgentHeader;
    public static string ValidUrlCharacters;
    public static string ValidUrlCharactersRFC1738;
    private static string ValidPathCharacters;
    public static string ValidTraceIdHeaderValueCharacters;
    public static string UrlEncodedContent;
    public static string GMTDateFormat;
    public static string ISO8601DateFormat;
    public static string ISO8601DateFormatNoMS;
    public static string ISO8601BasicDateTimeFormat;
    public static string ISO8601BasicDateFormat;
    public static string RFC822DateFormat;
    public static string ISO8601WithUTCOffset;
    private static BackgroundInvoker _dispatcher;
    private static LruCache`2<IsSetMethodsCacheKey, MethodInfo> IsSetMethodsCache;
    private static ReadOnlySpan`1<char> DoubleSlash { get; }
    private static ReadOnlySpan`1<char> Queue { get; }
    private static BackgroundInvoker Dispatcher { get; }
    public static string FormattedCurrentTimestampGMT { get; }
    public static string FormattedCurrentTimestampISO8601 { get; }
    public static string FormattedCurrentTimestampRFC822 { get; }
    public static DateTime CorrectedUtcNow { get; }
    private static AWSSDKUtils();
    private static string DetermineValidPathCharacters();
    public static string GetExtension(string path);
    internal static string CalculateStringToSignV2(ParameterCollection parameterCollection, string serviceUrl);
    internal static string GetParametersAsString(IRequest request);
    public static Byte[] GetRequestPayloadBytes(IRequest request, Nullable`1<bool> usesQueryString);
    internal static string GetParametersAsString(ParameterCollection parameterCollection);
    public static string CanonicalizeResourcePathV2(Uri endpoint, string resourcePath, bool encode, IDictionary`2<string, string> pathResources);
    public static IEnumerable`1<string> SplitResourcePathIntoSegments(string resourcePath, IDictionary`2<string, string> pathResources);
    public static IEnumerable`1<UriComponent> SplitResourcePathIntoSegmentsV2(string resourcePath, IDictionary`2<string, string> pathResources);
    [ObsoleteAttribute("This method has been deprecated due to an issue with not encoding special characters. Use JoinResourcePathSegmentsV2 instead.")]
public static string JoinResourcePathSegments(IEnumerable`1<string> pathSegments, bool path);
    public static string JoinResourcePathSegmentsV2(IEnumerable`1<string> pathSegments);
    public static string JoinResourcePathSegmentsV2(IEnumerable`1<UriComponent> pathSegments);
    [ObsoleteAttribute("ResolveResourcePath has been deprecated in favor of ResolveResourcePathV2 due to an encoding issue. Use ResolveResourcePathV2 instead.")]
public static string ResolveResourcePath(string resourcePath, IDictionary`2<string, string> pathResources);
    [ObsoleteAttribute("This method has been deprecated in favor of ResolveResourcePathV2 due to an encoding issue with special characters. Please use ResolveResourcePathV2.")]
public static string ResolveResourcePath(string resourcePath, IDictionary`2<string, string> pathResources, bool skipEncodingValidPathChars);
    public static string ResolveResourcePathV2(string resourcePath, IDictionary`2<string, string> pathResources);
    public static string Join(List`1<string> strings);
    public static string DetermineRegion(string url);
    public static string DetermineService(string url);
    private static ReadOnlySpan`1<char> get_DoubleSlash();
    private static ReadOnlySpan`1<char> get_Queue();
    public static DateTime ConvertFromUnixEpochSeconds(int seconds);
    public static DateTime ConvertFromUnixEpochMilliseconds(long milliseconds);
    public static int ConvertToUnixEpochSeconds(DateTime dateTime);
    public static string ConvertToUnixEpochSecondsString(DateTime dateTime);
    [ObsoleteAttribute("This method isn't named correctly: it returns seconds instead of milliseconds. Use ConvertToUnixEpochSecondsDouble instead.", "False")]
public static double ConvertToUnixEpochMilliSeconds(DateTime dateTime);
    public static double ConvertToUnixEpochSecondsDouble(DateTime dateTime);
    public static TimeSpan GetTimeSpanInTicks(DateTime dateTime);
    public static long ConvertDateTimetoMilliseconds(DateTime dateTime);
    public static long ConvertTimeSpanToMilliseconds(TimeSpan timeSpan);
    public static string ToHex(Byte[] data, bool lowercase);
    public static void InvokeInBackground(EventHandler`1<T> handler, T args, object sender);
    private static BackgroundInvoker get_Dispatcher();
    public static Dictionary`2<string, string> ParseQueryParameters(string url);
    internal static bool AreEqual(Object[] itemsA, Object[] itemsB);
    internal static bool AreEqual(object a, object b);
    internal static bool DictionariesAreEqual(Dictionary`2<K, V> a, Dictionary`2<K, V> b);
    public static MemoryStream GenerateMemoryStreamFromString(string s);
    public static void CopyStream(Stream source, Stream destination);
    public static void CopyStream(Stream source, Stream destination, int bufferSize);
    public static string get_FormattedCurrentTimestampGMT();
    public static string get_FormattedCurrentTimestampISO8601();
    public static string GetFormattedTimestampISO8601(int minutesFromNow);
    internal static string GetFormattedTimestampISO8601(IClientConfig config, AmazonWebServiceRequest request);
    private static string GetFormattedTimestampISO8601(DateTime dateTime);
    public static string get_FormattedCurrentTimestampRFC822();
    public static string GetFormattedTimestampRFC822(int minutesFromNow);
    public static bool IsAbsolutePath(string path);
    private static bool IsWindows();
    private static bool IsPartiallyQualifiedForWindows(string path);
    private static bool IsWindowsDirectorySeparator(char c);
    private static bool IsValidWindowsDriveChar(char value);
    public static string UrlEncode(string data, bool path);
    [SkipLocalsInitAttribute]
public static string UrlEncode(int rfcNumber, string data, bool path);
    internal static bool TryGetRFCEncodingSchemes(int rfcNumber, String& encodingScheme);
    private static void ToHexString(Span`1<byte> source, Span`1<char> destination, bool lowercase);
    private static char ToUpperHex(int value);
    private static char ToLowerHex(int value);
    internal static string UrlEncodeSlash(string data);
    internal static string EncodeTraceIdHeaderValue(string value);
    [ObsoleteAttribute("This method is not supported in AWSSDK 3.5")]
public static string ProtectEncodedSlashUrlEncode(string data, bool path);
    public static string GenerateMD5ChecksumForStream(Stream input);
    public static string GenerateChecksumForContent(string content, bool fBase64Encode);
    public static string GenerateChecksumForBytes(Byte[] content, bool fBase64Encode);
    public static void Sleep(TimeSpan ts);
    public static Byte[] HexStringToBytes(string hex);
    public static DateTime get_CorrectedUtcNow();
    public static bool HasBidiControlCharacters(string input);
    private static bool IsBidiControlChar(char c);
    public static string DownloadStringContent(Uri uri);
    public static string DownloadStringContent(Uri uri, TimeSpan timeout);
    public static string DownloadStringContent(Uri uri, IWebProxy proxy);
    public static string DownloadStringContent(Uri uri, TimeSpan timeout, IWebProxy proxy);
    public static string ExecuteHttpRequest(Uri uri, string requestType, string content, TimeSpan timeout, IWebProxy proxy, IDictionary`2<string, string> headers);
    private static HttpClient CreateClient(Uri uri, TimeSpan timeout, IWebProxy proxy, IDictionary`2<string, string> headers);
    public static Stream OpenStream(Uri uri);
    public static Stream OpenStream(Uri uri, IWebProxy proxy);
    public static string CompressSpaces(string data);
    internal static string ExtractOperationName(string requestName);
    public static ProcessExecutionResult RunProcess(ProcessStartInfo processStartInfo);
    [AsyncStateMachineAttribute("Amazon.Util.AWSSDKUtils/<RunProcessAsync>d__118")]
public static Task`1<ProcessExecutionResult> RunProcessAsync(ProcessStartInfo processStartInfo);
    public static bool IsPropertySet(object awsServiceObject, string propertyName);
    public static void ForceCanonicalPathAndQuery(Uri uri);
    public static void PreserveStackTrace(Exception exception);
    internal static int GetConnectionLimit(Nullable`1<int> clientConfigValue);
    public static void Sleep(int ms);
}
public class Amazon.Util.AWSStreamContent : object {
    private bool disposed;
    [CompilerGeneratedAttribute]
private StreamContent <StreamContent>k__BackingField;
    internal StreamContent StreamContent { get; internal set; }
    public AWSStreamContent(Stream content);
    public AWSStreamContent(Stream content, int bufferSize);
    [CompilerGeneratedAttribute]
internal StreamContent get_StreamContent();
    [CompilerGeneratedAttribute]
internal void set_StreamContent(StreamContent value);
    public bool RemoveHttpContentHeader(string name);
    public void AddHttpContentHeader(string name, string value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Amazon.Util.CircularReferenceTracking : object {
    private object referenceTrackersLock;
    private Stack`1<Tracker> referenceTrackers;
    public IDisposable Track(object target);
    private void PopTracker(Tracker tracker);
    private bool TrackerExists(object target);
}
public static class Amazon.Util.CryptoUtilFactory : object {
    private static int SHA1_BASE64_LENGTH;
    private static int SHA56_BASE64_LENGTH;
    private static int CRC32_BASE64_LENGTH;
    private static CryptoUtil util;
    public static ICryptoUtil CryptoInstance { get; }
    private static CryptoUtilFactory();
    public static ICryptoUtil get_CryptoInstance();
    public static HashAlgorithm GetChecksumInstance(CoreChecksumAlgorithm algorithm);
    public static int GetChecksumBase64Length(CoreChecksumAlgorithm algorithm);
}
public class Amazon.Util.CSMConfig : object {
    internal static string DEFAULT_HOST;
    internal static int DEFAULT_PORT;
    [CompilerGeneratedAttribute]
private string <CSMHost>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CSMPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CSMClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CSMEnabled>k__BackingField;
    public string CSMHost { get; public set; }
    public int CSMPort { get; public set; }
    public string CSMClientId { get; public set; }
    public Nullable`1<bool> CSMEnabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CSMHost();
    [CompilerGeneratedAttribute]
public void set_CSMHost(string value);
    [CompilerGeneratedAttribute]
public int get_CSMPort();
    [CompilerGeneratedAttribute]
public void set_CSMPort(int value);
    [CompilerGeneratedAttribute]
public string get_CSMClientId();
    [CompilerGeneratedAttribute]
public void set_CSMClientId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CSMEnabled();
    [CompilerGeneratedAttribute]
public void set_CSMEnabled(Nullable`1<bool> value);
}
public static class Amazon.Util.EC2InstanceMetadata : object {
    [ObsoleteAttribute("EC2_METADATA_SVC is obsolete, refer to ServiceEndpoint instead to respect environment and profile overrides.")]
public static string EC2_METADATA_SVC;
    [ObsoleteAttribute("EC2_METADATA_ROOT is obsolete, refer to EC2MetadataRoot instead to respect environment and profile overrides.")]
public static string EC2_METADATA_ROOT;
    [ObsoleteAttribute("EC2_USERDATA_ROOT is obsolete, refer to EC2UserDataRoot instead to respect environment and profile overrides.")]
public static string EC2_USERDATA_ROOT;
    [ObsoleteAttribute("EC2_DYNAMICDATA_ROOT is obsolete, refer to EC2DynamicDataRoot instead to respect environment and profile overrides.")]
public static string EC2_DYNAMICDATA_ROOT;
    [ObsoleteAttribute("EC2_APITOKEN_URL is obsolete, refer to EC2ApiTokenUrl instead to respect environment and profile overrides.")]
public static string EC2_APITOKEN_URL;
    public static string LATEST;
    public static string AWS_EC2_METADATA_DISABLED;
    private static int DEFAULT_RETRIES;
    private static int MIN_PAUSE_MS;
    private static int DEFAULT_APITOKEN_TTL;
    private static Dictionary`2<string, string> _cache;
    private static bool useNullToken;
    private static ReaderWriterLockSlim metadataLock;
    private static TimeSpan metadataLockTimeout;
    private static string _userAgent;
    private static Nullable`1<bool> _ec2MetadataV1Disabled;
    [CompilerGeneratedAttribute]
private static IWebProxy <Proxy>k__BackingField;
    public static string ServiceEndpoint { get; }
    public static string EC2MetadataRoot { get; }
    public static string EC2UserDataRoot { get; }
    public static string EC2DynamicDataRoot { get; }
    public static string EC2ApiTokenUrl { get; }
    public static bool IsIMDSEnabled { get; }
    public static bool EC2MetadataV1Disabled { get; public set; }
    public static IWebProxy Proxy { get; public set; }
    public static string AmiId { get; }
    public static string AmiLaunchIndex { get; }
    public static string AmiManifestPath { get; }
    public static IEnumerable`1<string> AncestorAmiIds { get; }
    public static string Hostname { get; }
    public static string InstanceAction { get; }
    public static string InstanceId { get; }
    public static string InstanceType { get; }
    public static string KernelId { get; }
    public static string LocalHostname { get; }
    public static string MacAddress { get; }
    public static string PrivateIpAddress { get; }
    public static string AvailabilityZone { get; }
    public static IEnumerable`1<string> ProductCodes { get; }
    public static string PublicKey { get; }
    public static string RamdiskId { get; }
    public static RegionEndpoint Region { get; }
    public static string ReservationId { get; }
    public static IEnumerable`1<string> SecurityGroups { get; }
    public static IAMInstanceProfileMetadata IAMInstanceProfileInfo { get; }
    public static IDictionary`2<string, IAMSecurityCredentialMetadata> IAMSecurityCredentials { get; }
    public static IDictionary`2<string, string> BlockDeviceMapping { get; }
    public static IEnumerable`1<NetworkInterfaceMetadata> NetworkInterfaces { get; }
    public static string UserData { get; }
    public static string InstanceMonitoring { get; }
    public static string IdentityDocument { get; }
    public static string IdentitySignature { get; }
    public static string IdentityPkcs7 { get; }
    private static EC2InstanceMetadata();
    public static string get_ServiceEndpoint();
    public static string get_EC2MetadataRoot();
    public static string get_EC2UserDataRoot();
    public static string get_EC2DynamicDataRoot();
    public static string get_EC2ApiTokenUrl();
    public static bool get_IsIMDSEnabled();
    public static bool get_EC2MetadataV1Disabled();
    public static void set_EC2MetadataV1Disabled(bool value);
    [CompilerGeneratedAttribute]
public static IWebProxy get_Proxy();
    [CompilerGeneratedAttribute]
public static void set_Proxy(IWebProxy value);
    public static string get_AmiId();
    public static string get_AmiLaunchIndex();
    public static string get_AmiManifestPath();
    public static IEnumerable`1<string> get_AncestorAmiIds();
    public static string get_Hostname();
    public static string get_InstanceAction();
    public static string get_InstanceId();
    public static string get_InstanceType();
    public static string get_KernelId();
    public static string get_LocalHostname();
    public static string get_MacAddress();
    public static string get_PrivateIpAddress();
    public static string get_AvailabilityZone();
    public static IEnumerable`1<string> get_ProductCodes();
    public static string get_PublicKey();
    public static string get_RamdiskId();
    public static RegionEndpoint get_Region();
    public static string get_ReservationId();
    public static IEnumerable`1<string> get_SecurityGroups();
    public static IAMInstanceProfileMetadata get_IAMInstanceProfileInfo();
    public static IDictionary`2<string, IAMSecurityCredentialMetadata> get_IAMSecurityCredentials();
    public static IDictionary`2<string, string> get_BlockDeviceMapping();
    public static IEnumerable`1<NetworkInterfaceMetadata> get_NetworkInterfaces();
    public static string get_UserData();
    public static string get_InstanceMonitoring();
    public static string get_IdentityDocument();
    public static string get_IdentitySignature();
    public static string get_IdentityPkcs7();
    public static IEnumerable`1<string> GetItems(string path);
    public static string GetData(string path);
    public static string GetData(string path, int tries);
    public static IEnumerable`1<string> GetItems(string path, int tries);
    private static string FetchData(string path);
    private static string FetchData(string path, bool force);
    public static string FetchApiToken();
    private static string FetchApiToken(int tries);
    public static void ClearTokenFlag();
    private static List`1<string> GetItems(string relativeOrAbsolutePath, int tries, bool slurp);
    private static List`1<string> GetItems(string relativeOrAbsolutePath, int tries, bool slurp, string token);
    private static void PauseExponentially(int retry);
}
public abstract class Amazon.Util.EnvironmentVariables : object {
    public static string AWS_LAMBDA_FUNCTION_NAME;
    public static string _X_AMZN_TRACE_ID;
    public static string SERVICE_SPECIFIC_ENDPOINT_ENVIRONMENT_VARIABLE_PREFIX;
    public static string GLOBAL_ENDPOINT_ENVIRONMENT_VARIABLE;
}
[ExtensionAttribute]
internal static class Amazon.Util.Extensions : object {
    [ExtensionAttribute]
internal static string ToUpper(string str, CultureInfo culture);
    [ExtensionAttribute]
public static int GetBytes(Encoding encoding, ReadOnlySpan`1<char> src, Span`1<byte> dest);
    [ExtensionAttribute]
public static string GetString(Encoding encoding, ReadOnlySpan`1<byte> bytes);
}
public abstract class Amazon.Util.HeaderKeys : object {
    public static string IfModifiedSinceHeader;
    public static string IfMatchHeader;
    public static string IfNoneMatchHeader;
    public static string IfUnmodifiedSinceHeader;
    public static string ConfirmSelfBucketAccess;
    public static string ContentRangeHeader;
    public static string ContentTypeHeader;
    public static string ContentLengthHeader;
    public static string ContentMD5Header;
    public static string ContentEncodingHeader;
    public static string ContentDispositionHeader;
    public static string ETagHeader;
    public static string Expires;
    public static string AuthorizationHeader;
    public static string HostHeader;
    public static string UserAgentHeader;
    public static string LocationHeader;
    public static string DateHeader;
    public static string RangeHeader;
    public static string ExpectHeader;
    public static string AcceptHeader;
    public static string ConnectionHeader;
    public static string StatusHeader;
    public static string XHttpMethodOverrideHeader;
    public static string TransferEncodingHeader;
    public static string RequestIdHeader;
    public static string XAmzId2Header;
    public static string XAmzCloudFrontIdHeader;
    public static string XAmzRequestIdHeader;
    public static string XAmzDateHeader;
    public static string XAmzErrorType;
    public static string XAmznErrorMessage;
    public static string XAmzSignedHeadersHeader;
    public static string XAmzContentSha256Header;
    public static string XAmzDecodedContentLengthHeader;
    public static string XAmzSecurityTokenHeader;
    public static string XAmzAuthorizationHeader;
    public static string XAmzRegionSetHeader;
    public static string XAmzNonceHeader;
    public static string XAmzServerSideEncryptionHeader;
    public static string XAmzServerSideEncryptionAwsKmsKeyIdHeader;
    public static string XAmzBucketRegion;
    public static string XAmzAccountId;
    public static string XAmzOutpostId;
    public static string XAmzApiVersion;
    public static string XAmzExpires;
    public static string XAmzSignature;
    public static string XAmzAlgorithm;
    public static string XAmzCredential;
    public static string XAmzTrailerHeader;
    public static string XAmzCrc32;
    public static string XAmzSSECustomerAlgorithmHeader;
    public static string XAmzSSECustomerKeyHeader;
    public static string XAmzSSECustomerKeyMD5Header;
    public static string XAmzCopySourceSSECustomerAlgorithmHeader;
    public static string XAmzCopySourceSSECustomerKeyHeader;
    public static string XAmzCopySourceSSECustomerKeyMD5Header;
    public static string XAmzStorageClassHeader;
    public static string XAmzWebsiteRedirectLocationHeader;
    public static string XAmzContentLengthHeader;
    public static string XAmzAclHeader;
    public static string XAmzCopySourceHeader;
    public static string XAmzCopySourceRangeHeader;
    public static string XAmzCopySourceIfMatchHeader;
    public static string XAmzCopySourceIfModifiedSinceHeader;
    public static string XAmzCopySourceIfNoneMatchHeader;
    public static string XAmzCopySourceIfUnmodifiedSinceHeader;
    public static string XAmzMetadataDirectiveHeader;
    public static string XAmzMfaHeader;
    public static string XAmzVersionIdHeader;
    public static string XAmzUserAgentHeader;
    public static string XAmzAbortDateHeader;
    public static string XAmzAbortRuleIdHeader;
    public static string XAmznTraceIdHeader;
    public static string XAwsEc2MetadataTokenTtlSeconds;
    public static string XAwsEc2MetadataToken;
    public static string AmzSdkInvocationId;
    public static string AmzSdkRequest;
    public static string XAmzQueryError;
    public static string XAmzS3ExpressSessionTokenQueryParam;
}
public class Amazon.Util.IAMInstanceProfileMetadata : object {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceProfileArn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceProfileId>k__BackingField;
    public string Code { get; public set; }
    public string Message { get; public set; }
    public DateTime LastUpdated { get; public set; }
    public string InstanceProfileArn { get; public set; }
    public string InstanceProfileId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastUpdated();
    [CompilerGeneratedAttribute]
public void set_LastUpdated(DateTime value);
    [CompilerGeneratedAttribute]
public string get_InstanceProfileArn();
    [CompilerGeneratedAttribute]
public void set_InstanceProfileArn(string value);
    [CompilerGeneratedAttribute]
public string get_InstanceProfileId();
    [CompilerGeneratedAttribute]
public void set_InstanceProfileId(string value);
}
public class Amazon.Util.IAMSecurityCredentialMetadata : object {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessKeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecretAccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiration>k__BackingField;
    public string Code { get; public set; }
    public string Message { get; public set; }
    public DateTime LastUpdated { get; public set; }
    public string Type { get; public set; }
    public string AccessKeyId { get; public set; }
    public string SecretAccessKey { get; public set; }
    public string Token { get; public set; }
    public DateTime Expiration { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastUpdated();
    [CompilerGeneratedAttribute]
public void set_LastUpdated(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_AccessKeyId();
    [CompilerGeneratedAttribute]
public void set_AccessKeyId(string value);
    [CompilerGeneratedAttribute]
public string get_SecretAccessKey();
    [CompilerGeneratedAttribute]
public void set_SecretAccessKey(string value);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Expiration();
    [CompilerGeneratedAttribute]
public void set_Expiration(DateTime value);
}
public interface Amazon.Util.ICryptoUtil {
    public abstract virtual string HMACSign(string data, string key, SigningAlgorithm algorithmName);
    public abstract virtual string HMACSign(Byte[] data, string key, SigningAlgorithm algorithmName);
    public abstract virtual Byte[] ComputeSHA1Hash(Byte[] data);
    public abstract virtual Byte[] ComputeSHA256Hash(Byte[] data);
    public abstract virtual Byte[] ComputeSHA256Hash(Stream steam);
    public abstract virtual Byte[] ComputeMD5Hash(Byte[] data);
    public abstract virtual Byte[] ComputeMD5Hash(Stream steam);
    public abstract virtual Byte[] HMACSignBinary(Byte[] data, Byte[] key, SigningAlgorithm algorithmName);
    public abstract virtual string ComputeCRC32Hash(Byte[] data);
    public abstract virtual string ComputeCRC32CHash(Byte[] data);
}
internal static class Amazon.Util.Internal.ArrayEx : object {
    public static T[] Empty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("System.Collections.Generic.Dictionary`2<System.String,System.Collections.Generic.Dictionary`2<System.String,System.String>>")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.31311")]
public class Amazon.Util.Internal.DictionaryStringDictionaryStringJsonSerializerContexts : JsonSerializerContext {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Dictionary`2<string, Dictionary`2<string, string>>> _DictionaryStringDictionaryStringString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Dictionary`2<string, string>> _DictionaryStringString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static DictionaryStringDictionaryStringJsonSerializerContexts <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    public JsonTypeInfo`1<Dictionary`2<string, Dictionary`2<string, string>>> DictionaryStringDictionaryStringString { get; }
    public JsonTypeInfo`1<Dictionary`2<string, string>> DictionaryStringString { get; }
    public JsonTypeInfo`1<string> String { get; }
    public static DictionaryStringDictionaryStringJsonSerializerContexts Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public DictionaryStringDictionaryStringJsonSerializerContexts(JsonSerializerOptions options);
    private static DictionaryStringDictionaryStringJsonSerializerContexts();
    public JsonTypeInfo`1<Dictionary`2<string, Dictionary`2<string, string>>> get_DictionaryStringDictionaryStringString();
    private JsonTypeInfo`1<Dictionary`2<string, Dictionary`2<string, string>>> Create_DictionaryStringDictionaryStringString(JsonSerializerOptions options);
    private void DictionaryStringDictionaryStringStringSerializeHandler(Utf8JsonWriter writer, Dictionary`2<string, Dictionary`2<string, string>> value);
    public JsonTypeInfo`1<Dictionary`2<string, string>> get_DictionaryStringString();
    private JsonTypeInfo`1<Dictionary`2<string, string>> Create_DictionaryStringString(JsonSerializerOptions options);
    private void DictionaryStringStringSerializeHandler(Utf8JsonWriter writer, Dictionary`2<string, string> value);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static DictionaryStringDictionaryStringJsonSerializerContexts get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("System.Collections.Generic.Dictionary`2<System.String,System.String>")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.31311")]
public class Amazon.Util.Internal.DictionaryStringStringJsonSerializerContexts : JsonSerializerContext {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Dictionary`2<string, string>> _DictionaryStringString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static DictionaryStringStringJsonSerializerContexts <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    public JsonTypeInfo`1<Dictionary`2<string, string>> DictionaryStringString { get; }
    public JsonTypeInfo`1<string> String { get; }
    public static DictionaryStringStringJsonSerializerContexts Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public DictionaryStringStringJsonSerializerContexts(JsonSerializerOptions options);
    private static DictionaryStringStringJsonSerializerContexts();
    public JsonTypeInfo`1<Dictionary`2<string, string>> get_DictionaryStringString();
    private JsonTypeInfo`1<Dictionary`2<string, string>> Create_DictionaryStringString(JsonSerializerOptions options);
    private void DictionaryStringStringSerializeHandler(Utf8JsonWriter writer, Dictionary`2<string, string> value);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static DictionaryStringStringJsonSerializerContexts get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
public class Amazon.Util.Internal.DirectoryRetriever : object {
    public sealed virtual DirectoryInfo CreateDirectory(string path);
    public sealed virtual String[] GetFiles(string path, string searchPattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("Amazon.Util.IAMInstanceProfileMetadata")]
[JsonSerializableAttribute("Amazon.Util.IAMSecurityCredentialMetadata")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.31311")]
public class Amazon.Util.Internal.EC2InstanceMetadataJsonSerializerContexts : JsonSerializerContext {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<IAMInstanceProfileMetadata> _IAMInstanceProfileMetadata;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<IAMSecurityCredentialMetadata> _IAMSecurityCredentialMetadata;
    [NullableAttribute("2")]
private JsonTypeInfo`1<DateTime> _DateTime;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static EC2InstanceMetadataJsonSerializerContexts <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    private static JsonEncodedText PropName_Code;
    private static JsonEncodedText PropName_Message;
    private static JsonEncodedText PropName_LastUpdated;
    private static JsonEncodedText PropName_InstanceProfileArn;
    private static JsonEncodedText PropName_InstanceProfileId;
    private static JsonEncodedText PropName_Type;
    private static JsonEncodedText PropName_AccessKeyId;
    private static JsonEncodedText PropName_SecretAccessKey;
    private static JsonEncodedText PropName_Token;
    private static JsonEncodedText PropName_Expiration;
    public JsonTypeInfo`1<IAMInstanceProfileMetadata> IAMInstanceProfileMetadata { get; }
    public JsonTypeInfo`1<IAMSecurityCredentialMetadata> IAMSecurityCredentialMetadata { get; }
    public JsonTypeInfo`1<DateTime> DateTime { get; }
    public JsonTypeInfo`1<string> String { get; }
    public static EC2InstanceMetadataJsonSerializerContexts Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public EC2InstanceMetadataJsonSerializerContexts(JsonSerializerOptions options);
    private static EC2InstanceMetadataJsonSerializerContexts();
    public JsonTypeInfo`1<IAMInstanceProfileMetadata> get_IAMInstanceProfileMetadata();
    private JsonTypeInfo`1<IAMInstanceProfileMetadata> Create_IAMInstanceProfileMetadata(JsonSerializerOptions options);
    private static JsonPropertyInfo[] IAMInstanceProfileMetadataPropInit(JsonSerializerOptions options);
    private void IAMInstanceProfileMetadataSerializeHandler(Utf8JsonWriter writer, IAMInstanceProfileMetadata value);
    public JsonTypeInfo`1<IAMSecurityCredentialMetadata> get_IAMSecurityCredentialMetadata();
    private JsonTypeInfo`1<IAMSecurityCredentialMetadata> Create_IAMSecurityCredentialMetadata(JsonSerializerOptions options);
    private static JsonPropertyInfo[] IAMSecurityCredentialMetadataPropInit(JsonSerializerOptions options);
    private void IAMSecurityCredentialMetadataSerializeHandler(Utf8JsonWriter writer, IAMSecurityCredentialMetadata value);
    public JsonTypeInfo`1<DateTime> get_DateTime();
    private JsonTypeInfo`1<DateTime> Create_DateTime(JsonSerializerOptions options);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static EC2InstanceMetadataJsonSerializerContexts get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
public class Amazon.Util.Internal.EnvironmentVariableRetriever : object {
    public sealed virtual string GetEnvironmentVariable(string key);
}
public class Amazon.Util.Internal.EnvironmentVariableSource : object {
    private static EnvironmentVariableSource instance;
    [CompilerGeneratedAttribute]
private IEnvironmentVariableRetriever <EnvironmentVariableRetriever>k__BackingField;
    public IEnvironmentVariableRetriever EnvironmentVariableRetriever { get; public set; }
    public static EnvironmentVariableSource Instance { get; }
    private static EnvironmentVariableSource();
    [CompilerGeneratedAttribute]
public IEnvironmentVariableRetriever get_EnvironmentVariableRetriever();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariableRetriever(IEnvironmentVariableRetriever value);
    public static EnvironmentVariableSource get_Instance();
}
public class Amazon.Util.Internal.FileRetriever : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual string ReadAllText(string path);
    public sealed virtual void WriteAllText(string path, string contents);
    public sealed virtual void Delete(string path);
    [AsyncStateMachineAttribute("Amazon.Util.Internal.FileRetriever/<ReadAllTextAsync>d__4")]
public sealed virtual Task`1<string> ReadAllTextAsync(string path, CancellationToken token);
    [AsyncStateMachineAttribute("Amazon.Util.Internal.FileRetriever/<WriteAllTextAsync>d__5")]
public sealed virtual Task WriteAllTextAsync(string path, string contents, CancellationToken token);
}
public interface Amazon.Util.Internal.IDirectory {
    public abstract virtual DirectoryInfo CreateDirectory(string path);
    public abstract virtual String[] GetFiles(string path, string searchPattern);
}
public interface Amazon.Util.Internal.IEnvironmentVariableRetriever {
    public abstract virtual string GetEnvironmentVariable(string key);
}
public interface Amazon.Util.Internal.IFile {
    public abstract virtual bool Exists(string path);
    public abstract virtual string ReadAllText(string path);
    public abstract virtual void WriteAllText(string path, string contents);
    public abstract virtual void Delete(string path);
    public abstract virtual Task`1<string> ReadAllTextAsync(string path, CancellationToken token);
    public abstract virtual Task WriteAllTextAsync(string path, string contents, CancellationToken token);
}
public static class Amazon.Util.Internal.InternalSDKUtils : object {
    private static string _overrideVersionNumber;
    private static string _customData;
    private static string USER_AGENT_VERSION;
    private static string DisallowedCharactersRegexPattern;
    internal static string EXECUTION_ENVIRONMENT_ENVVAR;
    internal static string INTERNAL_ENVIRONMENT_ENVVAR;
    internal static string CoreVersionNumber;
    private static string UnknownPlaceholder;
    private static string UnknownPlatform;
    private static string _userAgentBaseName;
    private static IRuntimeInformationWrapper _runtimeInformationWrapper;
    private static InternalSDKUtils();
    [GeneratedRegexAttribute("[^ /!#$%&'*+-.^_`|~\w\d]")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
private static Regex DisallowedCharactersRegex();
    public static void SetUserAgent(string productName, string versionNumber);
    public static void SetUserAgent(string productName, string versionNumber, string customData);
    internal static string ReplaceInvalidUserAgentCharacters(string userAgent);
    public static string BuildUserAgentString(string serviceSdkVersion);
    public static string BuildUserAgentString(string serviceId, string serviceSdkVersion);
    public static void ApplyValues(object target, IDictionary`2<string, object> propertyValues);
    public static bool AreTypesEqual(Type type1, Type type2);
    public static void AddToDictionary(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    public static void FillDictionary(IEnumerable`1<T> items, Func`2<T, TKey> keyGenerator, Func`2<T, TValue> valueGenerator, Dictionary`2<TKey, TValue> targetDictionary);
    public static Dictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<T> items, Func`2<T, TKey> keyGenerator, Func`2<T, TValue> valueGenerator);
    public static Dictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<T> items, Func`2<T, TKey> keyGenerator, Func`2<T, TValue> valueGenerator, IEqualityComparer`1<TKey> comparer);
    public static bool TryFindByValue(IDictionary`2<TKey, TValue> dictionary, TValue value, IEqualityComparer`1<TValue> valueComparer, TKey& key);
    internal static string GetExecutionEnvironment();
    internal static string GetInternalEnvironment();
    private static string GetExecutionEnvironmentUserAgentString();
    private static string GetInternalUserAgentString();
    public static bool IsFilePathRootedWithDirectoryPath(string filePath, string directoryPath);
    public static bool IsRunningNativeAot();
    [IteratorStateMachineAttribute("Amazon.Util.Internal.InternalSDKUtils/<Zip>d__25`3")]
internal static IEnumerable`1<TResult> Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    public static void SetIsSet(bool isSet, Nullable`1& field);
    public static void SetIsSet(bool isSet, List`1& field);
    public static void SetIsSet(bool isSet, Dictionary`2& field);
    public static bool GetIsSet(Nullable`1<T> field);
    public static bool GetIsSet(List`1<T> field);
    public static bool GetIsSet(Dictionary`2<TKey, TVvalue> field);
    private static string GetValidSubstringOrUnknown(string str, int start, int end);
    public static string DetermineFramework();
    public static string DetermineOS();
    public static string PlatformUserAgent();
    internal static void SetRuntimeInformationWrapper(IRuntimeInformationWrapper wrapper);
    internal static void ResetRuntimeInformationWrapper();
}
internal interface Amazon.Util.Internal.IRuntimeInformationWrapper {
    public string FrameworkDescription { get; }
    public abstract virtual string get_FrameworkDescription();
}
[ObsoleteAttribute("The TypeFactory abstraction should not be used. This was needed when the SDK targeted .NET Standard 1.3 which was removed as part of version 3.7. Type information should be accessed directly from the System.Type class.")]
public interface Amazon.Util.Internal.ITypeInfo {
    public Type BaseType { get; }
    public Type Type { get; }
    public Assembly Assembly { get; }
    public bool IsArray { get; }
    public bool IsEnum { get; }
    public bool IsClass { get; }
    public bool IsValueType { get; }
    public bool IsInterface { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public string FullName { get; }
    public string Name { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool ContainsGenericParameters { get; }
    public abstract virtual Type get_BaseType();
    public abstract virtual Type get_Type();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual bool get_IsArray();
    public abstract virtual Array ArrayCreateInstance(int length);
    public abstract virtual Type GetInterface(string name);
    public abstract virtual Type[] GetInterfaces();
    public abstract virtual IEnumerable`1<PropertyInfo> GetProperties();
    public abstract virtual IEnumerable`1<FieldInfo> GetFields();
    public abstract virtual FieldInfo GetField(string name);
    public abstract virtual MethodInfo GetMethod(string name);
    public abstract virtual MethodInfo GetMethod(string name, ITypeInfo[] paramTypes);
    public abstract virtual MemberInfo[] GetMembers();
    public abstract virtual ConstructorInfo GetConstructor(ITypeInfo[] paramTypes);
    public abstract virtual PropertyInfo GetProperty(string name);
    public abstract virtual bool IsAssignableFrom(ITypeInfo typeInfo);
    public abstract virtual bool get_IsEnum();
    public abstract virtual bool get_IsClass();
    public abstract virtual bool get_IsValueType();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual object EnumToObject(object value);
    public abstract virtual object CreateInstance();
    public abstract virtual bool IsType(Type type);
    public abstract virtual string get_FullName();
    public abstract virtual string get_Name();
    public abstract virtual bool get_IsGenericTypeDefinition();
    public abstract virtual bool get_IsGenericType();
    public abstract virtual bool get_ContainsGenericParameters();
    public abstract virtual Type GetGenericTypeDefinition();
    public abstract virtual Type[] GetGenericArguments();
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(ITypeInfo attributeType, bool inherit);
}
public static class Amazon.Util.Internal.JsonSerializerHelper : object {
    public static T Deserialize(string json, JsonSerializerContext context);
    public static string Serialize(object obj, JsonSerializerContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("System.Collections.Generic.List`1<System.String>")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.31311")]
public class Amazon.Util.Internal.ListStringJsonSerializerContexts : JsonSerializerContext {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<List`1<string>> _ListString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static ListStringJsonSerializerContexts <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    public JsonTypeInfo`1<List`1<string>> ListString { get; }
    public JsonTypeInfo`1<string> String { get; }
    public static ListStringJsonSerializerContexts Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public ListStringJsonSerializerContexts(JsonSerializerOptions options);
    private static ListStringJsonSerializerContexts();
    public JsonTypeInfo`1<List`1<string>> get_ListString();
    private JsonTypeInfo`1<List`1<string>> Create_ListString(JsonSerializerOptions options);
    private void ListStringSerializeHandler(Utf8JsonWriter writer, List`1<string> value);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static ListStringJsonSerializerContexts get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
public class Amazon.Util.Internal.NamedSettingsManager : object {
    private SettingsManager settingsManager;
    public static bool IsAvailable { get; }
    public NamedSettingsManager(string settingsType);
    public static bool get_IsAvailable();
    public string RegisterObject(string displayName, Dictionary`2<string, string> properties);
    public bool TryGetObject(string displayName, Dictionary`2& properties);
    public bool TryGetObject(string displayName, String& uniqueKey, Dictionary`2& properties);
    public void UnregisterObject(string displayName);
    public void RenameObject(string oldDisplayName, string newDisplayName, bool force);
    public void CopyObject(string fromDisplayName, string toDisplayName, bool force);
    public List`1<string> ListObjectNames();
}
public class Amazon.Util.Internal.NoProxyFilter : object {
    public static NoProxyFilter Instance;
    private static NoProxyFilter();
    public bool Match(Uri uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("Amazon.Runtime.Internal.Endpoints.StandardLibrary.PartitionFunctionShape")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.31311")]
public class Amazon.Util.Internal.PartitionFunctionShapeJsonSerializerContexts : JsonSerializerContext {
    [NullableAttribute("2")]
private JsonTypeInfo`1<bool> _Boolean;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PartitionAttributesShape> _PartitionAttributesShape;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PartitionFunctionShape> _PartitionFunctionShape;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PartitionShape> _PartitionShape;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Dictionary`2<string, JsonData>> _DictionaryStringJsonData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<List`1<PartitionShape>> _ListPartitionShape;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<JsonData> _JsonData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<object> _Object;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static PartitionFunctionShapeJsonSerializerContexts <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    private static JsonEncodedText PropName_name;
    private static JsonEncodedText PropName_dnsSuffix;
    private static JsonEncodedText PropName_dualStackDnsSuffix;
    private static JsonEncodedText PropName_supportsFIPS;
    private static JsonEncodedText PropName_supportsDualStack;
    private static JsonEncodedText PropName_implicitGlobalRegion;
    private static JsonEncodedText PropName_version;
    private static JsonEncodedText PropName_partitions;
    private static JsonEncodedText PropName_id;
    private static JsonEncodedText PropName_regionRegex;
    private static JsonEncodedText PropName_regions;
    private static JsonEncodedText PropName_outputs;
    public JsonTypeInfo`1<bool> Boolean { get; }
    public JsonTypeInfo`1<PartitionAttributesShape> PartitionAttributesShape { get; }
    public JsonTypeInfo`1<PartitionFunctionShape> PartitionFunctionShape { get; }
    public JsonTypeInfo`1<PartitionShape> PartitionShape { get; }
    public JsonTypeInfo`1<Dictionary`2<string, JsonData>> DictionaryStringJsonData { get; }
    public JsonTypeInfo`1<List`1<PartitionShape>> ListPartitionShape { get; }
    public JsonTypeInfo`1<JsonData> JsonData { get; }
    public JsonTypeInfo`1<object> Object { get; }
    public JsonTypeInfo`1<string> String { get; }
    public static PartitionFunctionShapeJsonSerializerContexts Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public PartitionFunctionShapeJsonSerializerContexts(JsonSerializerOptions options);
    private static PartitionFunctionShapeJsonSerializerContexts();
    public JsonTypeInfo`1<bool> get_Boolean();
    private JsonTypeInfo`1<bool> Create_Boolean(JsonSerializerOptions options);
    public JsonTypeInfo`1<PartitionAttributesShape> get_PartitionAttributesShape();
    private JsonTypeInfo`1<PartitionAttributesShape> Create_PartitionAttributesShape(JsonSerializerOptions options);
    private static JsonPropertyInfo[] PartitionAttributesShapePropInit(JsonSerializerOptions options);
    private void PartitionAttributesShapeSerializeHandler(Utf8JsonWriter writer, PartitionAttributesShape value);
    public JsonTypeInfo`1<PartitionFunctionShape> get_PartitionFunctionShape();
    private JsonTypeInfo`1<PartitionFunctionShape> Create_PartitionFunctionShape(JsonSerializerOptions options);
    private static JsonPropertyInfo[] PartitionFunctionShapePropInit(JsonSerializerOptions options);
    private void PartitionFunctionShapeSerializeHandler(Utf8JsonWriter writer, PartitionFunctionShape value);
    public JsonTypeInfo`1<PartitionShape> get_PartitionShape();
    private JsonTypeInfo`1<PartitionShape> Create_PartitionShape(JsonSerializerOptions options);
    private static JsonPropertyInfo[] PartitionShapePropInit(JsonSerializerOptions options);
    private void PartitionShapeSerializeHandler(Utf8JsonWriter writer, PartitionShape value);
    public JsonTypeInfo`1<Dictionary`2<string, JsonData>> get_DictionaryStringJsonData();
    private JsonTypeInfo`1<Dictionary`2<string, JsonData>> Create_DictionaryStringJsonData(JsonSerializerOptions options);
    private void DictionaryStringJsonDataSerializeHandler(Utf8JsonWriter writer, Dictionary`2<string, JsonData> value);
    public JsonTypeInfo`1<List`1<PartitionShape>> get_ListPartitionShape();
    private JsonTypeInfo`1<List`1<PartitionShape>> Create_ListPartitionShape(JsonSerializerOptions options);
    private void ListPartitionShapeSerializeHandler(Utf8JsonWriter writer, List`1<PartitionShape> value);
    public JsonTypeInfo`1<JsonData> get_JsonData();
    private JsonTypeInfo`1<JsonData> Create_JsonData(JsonSerializerOptions options);
    public JsonTypeInfo`1<object> get_Object();
    private JsonTypeInfo`1<object> Create_Object(JsonSerializerOptions options);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static PartitionFunctionShapeJsonSerializerContexts get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
public class Amazon.Util.Internal.PlatformServices.ApplicationInfo : object {
    public string AppTitle { get; }
    public string AppVersionName { get; }
    public string AppVersionCode { get; }
    public string PackageName { get; }
    public sealed virtual string get_AppTitle();
    public sealed virtual string get_AppVersionName();
    public sealed virtual string get_AppVersionCode();
    public sealed virtual string get_PackageName();
}
public class Amazon.Util.Internal.PlatformServices.ApplicationSettings : object {
    public sealed virtual void SetValue(string key, string value, ApplicationSettingsMode mode);
    public sealed virtual string GetValue(string key, ApplicationSettingsMode mode);
    public sealed virtual void RemoveValue(string key, ApplicationSettingsMode mode);
}
public enum Amazon.Util.Internal.PlatformServices.ApplicationSettingsMode : Enum {
    public int value__;
    public static ApplicationSettingsMode None;
    public static ApplicationSettingsMode Local;
    public static ApplicationSettingsMode Roaming;
}
public class Amazon.Util.Internal.PlatformServices.EnvironmentInfo : object {
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformUserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkUserAgent>k__BackingField;
    public string Platform { get; }
    public string PlatformUserAgent { get; }
    public string FrameworkUserAgent { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Platform();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PlatformUserAgent();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FrameworkUserAgent();
}
public interface Amazon.Util.Internal.PlatformServices.IApplicationInfo {
    public string AppTitle { get; }
    public string AppVersionName { get; }
    public string AppVersionCode { get; }
    public string PackageName { get; }
    public abstract virtual string get_AppTitle();
    public abstract virtual string get_AppVersionName();
    public abstract virtual string get_AppVersionCode();
    public abstract virtual string get_PackageName();
}
public interface Amazon.Util.Internal.PlatformServices.IApplicationSettings {
    public abstract virtual void SetValue(string key, string value, ApplicationSettingsMode mode);
    public abstract virtual string GetValue(string key, ApplicationSettingsMode mode);
    public abstract virtual void RemoveValue(string key, ApplicationSettingsMode mode);
}
public interface Amazon.Util.Internal.PlatformServices.IEnvironmentInfo {
    public string Platform { get; }
    public string PlatformUserAgent { get; }
    public string FrameworkUserAgent { get; }
    public abstract virtual string get_Platform();
    public abstract virtual string get_PlatformUserAgent();
    public abstract virtual string get_FrameworkUserAgent();
}
public interface Amazon.Util.Internal.PlatformServices.INetworkReachability {
    public NetworkStatus NetworkStatus { get; }
    public abstract virtual NetworkStatus get_NetworkStatus();
    [CompilerGeneratedAttribute]
public abstract virtual void add_NetworkReachabilityChanged(EventHandler`1<NetworkStatusEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NetworkReachabilityChanged(EventHandler`1<NetworkStatusEventArgs> value);
}
public class Amazon.Util.Internal.PlatformServices.NetworkReachability : object {
    public NetworkStatus NetworkStatus { get; }
    public sealed virtual NetworkStatus get_NetworkStatus();
    public sealed virtual void add_NetworkReachabilityChanged(EventHandler`1<NetworkStatusEventArgs> value);
    public sealed virtual void remove_NetworkReachabilityChanged(EventHandler`1<NetworkStatusEventArgs> value);
}
public enum Amazon.Util.Internal.PlatformServices.NetworkStatus : Enum {
    public int value__;
    public static NetworkStatus NotReachable;
    public static NetworkStatus ReachableViaCarrierDataNetwork;
    public static NetworkStatus ReachableViaWiFiNetwork;
}
public class Amazon.Util.Internal.PlatformServices.NetworkStatusEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NetworkStatus <Status>k__BackingField;
    public NetworkStatus Status { get; private set; }
    public NetworkStatusEventArgs(NetworkStatus status);
    [CompilerGeneratedAttribute]
public NetworkStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(NetworkStatus value);
}
public class Amazon.Util.Internal.PlatformServices.ServiceFactory : object {
    internal static string NotImplementedErrorMessage;
    private static object _lock;
    private static bool _factoryInitialized;
    private static IDictionary`2<Type, Type> _mappings;
    private IDictionary`2<Type, InstantiationModel> _instantationMappings;
    private IDictionary`2<Type, object> _singletonServices;
    public static ServiceFactory Instance;
    private static ServiceFactory();
    public static void RegisterService(Type serviceType);
    public T GetService();
    private static Type GetServiceType();
    private static object CreateInstance(Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("Amazon.Runtime.Internal.ProcessCredentialVersion1")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.31311")]
public class Amazon.Util.Internal.ProcessCredentialVersion1JsonSerializerContexts : JsonSerializerContext {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ProcessCredentialVersion1> _ProcessCredentialVersion1;
    [NullableAttribute("2")]
private JsonTypeInfo`1<DateTime> _DateTime;
    [NullableAttribute("2")]
private JsonTypeInfo`1<int> _Int32;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static ProcessCredentialVersion1JsonSerializerContexts <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    private static JsonEncodedText PropName_Version;
    private static JsonEncodedText PropName_AccessKeyId;
    private static JsonEncodedText PropName_SecretAccessKey;
    private static JsonEncodedText PropName_SessionToken;
    private static JsonEncodedText PropName_Expiration;
    public JsonTypeInfo`1<ProcessCredentialVersion1> ProcessCredentialVersion1 { get; }
    public JsonTypeInfo`1<DateTime> DateTime { get; }
    public JsonTypeInfo`1<int> Int32 { get; }
    public JsonTypeInfo`1<string> String { get; }
    public static ProcessCredentialVersion1JsonSerializerContexts Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public ProcessCredentialVersion1JsonSerializerContexts(JsonSerializerOptions options);
    private static ProcessCredentialVersion1JsonSerializerContexts();
    public JsonTypeInfo`1<ProcessCredentialVersion1> get_ProcessCredentialVersion1();
    private JsonTypeInfo`1<ProcessCredentialVersion1> Create_ProcessCredentialVersion1(JsonSerializerOptions options);
    private static JsonPropertyInfo[] ProcessCredentialVersion1PropInit(JsonSerializerOptions options);
    private void ProcessCredentialVersion1SerializeHandler(Utf8JsonWriter writer, ProcessCredentialVersion1 value);
    public JsonTypeInfo`1<DateTime> get_DateTime();
    private JsonTypeInfo`1<DateTime> Create_DateTime(JsonSerializerOptions options);
    public JsonTypeInfo`1<int> get_Int32();
    private JsonTypeInfo`1<int> Create_Int32(JsonSerializerOptions options);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static ProcessCredentialVersion1JsonSerializerContexts get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
public class Amazon.Util.Internal.RegionFinder : object {
    private static string DefaultRegion;
    private static string DefaultGovRegion;
    private EndpointSegment _root;
    private Logger _logger;
    private Dictionary`2<string, RegionEndpoint> _regionEndpoints;
    private static RegionFinder _instance;
    public static RegionFinder Instance { get; }
    private static RegionFinder();
    public RegionEndpoint FindRegion(string endpoint);
    public static string GetAuthority(string url);
    public static RegionEndpoint FindFuzzyRegion(string endpoint);
    internal EndpointSegment FindExactRegion(string endpoint);
    private Dictionary`2<string, RegionEndpoint> BuildRegionEndpoints();
    private EndpointSegment BuildRoot();
    private EndpointSegment FindExactRegion(IList`1<string> segments, int segmentIndex, EndpointSegment currentEndpointSegment);
    public static RegionFinder get_Instance();
}
public class Amazon.Util.Internal.RootConfig : object {
    [CompilerGeneratedAttribute]
private CSMConfig <CSMConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingConfig <Logging>k__BackingField;
    [CompilerGeneratedAttribute]
private ProxyConfig <Proxy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProfileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProfilesLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSdkCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InitializeCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CorrectForClockSkew>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAlternateUserAgentHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CSMEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CSMClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CSMPort>k__BackingField;
    private static string _rootAwsSectionName;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, XElement> <ServiceSections>k__BackingField;
    public CSMConfig CSMConfig { get; public set; }
    public LoggingConfig Logging { get; private set; }
    public ProxyConfig Proxy { get; private set; }
    public string Region { get; public set; }
    public string ProfileName { get; public set; }
    public string ProfilesLocation { get; public set; }
    public RegionEndpoint RegionEndpoint { get; public set; }
    public bool UseSdkCache { get; public set; }
    public bool InitializeCollections { get; public set; }
    public bool CorrectForClockSkew { get; public set; }
    public bool UseAlternateUserAgentHeader { get; public set; }
    public string ApplicationName { get; public set; }
    public Nullable`1<bool> CSMEnabled { get; public set; }
    public string CSMClientId { get; public set; }
    public Nullable`1<int> CSMPort { get; public set; }
    private IDictionary`2<string, XElement> ServiceSections { get; private set; }
    [CompilerGeneratedAttribute]
public CSMConfig get_CSMConfig();
    [CompilerGeneratedAttribute]
public void set_CSMConfig(CSMConfig value);
    [CompilerGeneratedAttribute]
public LoggingConfig get_Logging();
    [CompilerGeneratedAttribute]
private void set_Logging(LoggingConfig value);
    [CompilerGeneratedAttribute]
public ProxyConfig get_Proxy();
    [CompilerGeneratedAttribute]
private void set_Proxy(ProxyConfig value);
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
public void set_Region(string value);
    [CompilerGeneratedAttribute]
public string get_ProfileName();
    [CompilerGeneratedAttribute]
public void set_ProfileName(string value);
    [CompilerGeneratedAttribute]
public string get_ProfilesLocation();
    [CompilerGeneratedAttribute]
public void set_ProfilesLocation(string value);
    public RegionEndpoint get_RegionEndpoint();
    public void set_RegionEndpoint(RegionEndpoint value);
    [CompilerGeneratedAttribute]
public bool get_UseSdkCache();
    [CompilerGeneratedAttribute]
public void set_UseSdkCache(bool value);
    [CompilerGeneratedAttribute]
public bool get_InitializeCollections();
    [CompilerGeneratedAttribute]
public void set_InitializeCollections(bool value);
    [CompilerGeneratedAttribute]
public bool get_CorrectForClockSkew();
    [CompilerGeneratedAttribute]
public void set_CorrectForClockSkew(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseAlternateUserAgentHeader();
    [CompilerGeneratedAttribute]
public void set_UseAlternateUserAgentHeader(bool value);
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
public void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CSMEnabled();
    [CompilerGeneratedAttribute]
public void set_CSMEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_CSMClientId();
    [CompilerGeneratedAttribute]
public void set_CSMClientId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CSMPort();
    [CompilerGeneratedAttribute]
public void set_CSMPort(Nullable`1<int> value);
    private static string Choose(string a, string b);
    [CompilerGeneratedAttribute]
private IDictionary`2<string, XElement> get_ServiceSections();
    [CompilerGeneratedAttribute]
private void set_ServiceSections(IDictionary`2<string, XElement> value);
    public XElement GetServiceSection(string service);
}
internal class Amazon.Util.Internal.RuntimeInformationWrapper : object {
    public string FrameworkDescription { get; }
    public sealed virtual string get_FrameworkDescription();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("Amazon.Runtime.URIBasedRefreshingCredentialHelper/SecurityCredentials")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.31311")]
public class Amazon.Util.Internal.SecurityCredentialsJsonSerializerContexts : JsonSerializerContext {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<SecurityCredentials> _SecurityCredentials;
    [NullableAttribute("2")]
private JsonTypeInfo`1<DateTime> _DateTime;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static SecurityCredentialsJsonSerializerContexts <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    private static JsonEncodedText PropName_Type;
    private static JsonEncodedText PropName_AccessKeyId;
    private static JsonEncodedText PropName_SecretAccessKey;
    private static JsonEncodedText PropName_Token;
    private static JsonEncodedText PropName_Expiration;
    private static JsonEncodedText PropName_RoleArn;
    private static JsonEncodedText PropName_AccountId;
    private static JsonEncodedText PropName_Code;
    private static JsonEncodedText PropName_Message;
    private static JsonEncodedText PropName_LastUpdated;
    public JsonTypeInfo`1<SecurityCredentials> SecurityCredentials { get; }
    public JsonTypeInfo`1<DateTime> DateTime { get; }
    public JsonTypeInfo`1<string> String { get; }
    public static SecurityCredentialsJsonSerializerContexts Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public SecurityCredentialsJsonSerializerContexts(JsonSerializerOptions options);
    private static SecurityCredentialsJsonSerializerContexts();
    public JsonTypeInfo`1<SecurityCredentials> get_SecurityCredentials();
    private JsonTypeInfo`1<SecurityCredentials> Create_SecurityCredentials(JsonSerializerOptions options);
    private static JsonPropertyInfo[] SecurityCredentialsPropInit(JsonSerializerOptions options);
    private void SecurityCredentialsSerializeHandler(Utf8JsonWriter writer, SecurityCredentials value);
    public JsonTypeInfo`1<DateTime> get_DateTime();
    private JsonTypeInfo`1<DateTime> Create_DateTime(JsonSerializerOptions options);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static SecurityCredentialsJsonSerializerContexts get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("Amazon.Runtime.URIBasedRefreshingCredentialHelper/SecurityInfo")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.31311")]
public class Amazon.Util.Internal.SecurityInfoJsonSerializerContexts : JsonSerializerContext {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<SecurityInfo> _SecurityInfo;
    [NullableAttribute("2")]
private JsonTypeInfo`1<DateTime> _DateTime;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static SecurityInfoJsonSerializerContexts <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    private static JsonEncodedText PropName_InstanceProfileArn;
    private static JsonEncodedText PropName_InstanceProfileId;
    private static JsonEncodedText PropName_Code;
    private static JsonEncodedText PropName_Message;
    private static JsonEncodedText PropName_LastUpdated;
    public JsonTypeInfo`1<SecurityInfo> SecurityInfo { get; }
    public JsonTypeInfo`1<DateTime> DateTime { get; }
    public JsonTypeInfo`1<string> String { get; }
    public static SecurityInfoJsonSerializerContexts Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public SecurityInfoJsonSerializerContexts(JsonSerializerOptions options);
    private static SecurityInfoJsonSerializerContexts();
    public JsonTypeInfo`1<SecurityInfo> get_SecurityInfo();
    private JsonTypeInfo`1<SecurityInfo> Create_SecurityInfo(JsonSerializerOptions options);
    private static JsonPropertyInfo[] SecurityInfoPropInit(JsonSerializerOptions options);
    private void SecurityInfoSerializeHandler(Utf8JsonWriter writer, SecurityInfo value);
    public JsonTypeInfo`1<DateTime> get_DateTime();
    private JsonTypeInfo`1<DateTime> Create_DateTime(JsonSerializerOptions options);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static SecurityInfoJsonSerializerContexts get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
public class Amazon.Util.Internal.SettingsManager : object {
    [CompilerGeneratedAttribute]
private string <SettingsType>k__BackingField;
    public static bool IsAvailable { get; }
    public string SettingsType { get; private set; }
    public SettingsManager(string settingsType);
    public static bool get_IsAvailable();
    [CompilerGeneratedAttribute]
public string get_SettingsType();
    [CompilerGeneratedAttribute]
private void set_SettingsType(string value);
    public string RegisterObject(Dictionary`2<string, string> properties);
    public string RegisterObject(string uniqueKey, Dictionary`2<string, string> properties);
    public bool TryGetObject(string uniqueKey, Dictionary`2& properties);
    public bool TryGetObjectByProperty(string propertyName, string value, String& uniqueKey, Dictionary`2& properties);
    public List`1<string> ListUniqueKeys();
    public List`1<string> SelectProperty(string propertyName);
    public void UnregisterObject(string uniqueKey);
    private SettingsCollection GetSettings();
    private void SaveSettings(SettingsCollection settings);
    private static bool TryGetObjectSettings(string propertyName, string value, SettingsCollection settings, ObjectSettings& objectSettings);
    private static bool TryGetObjectSettings(string uniqueKey, SettingsCollection settings, ObjectSettings& objectSettings);
    private static void EnsureAvailable();
}
[ObsoleteAttribute("The TypeFactory abstraction should not be used. This was needed when the SDK targeted .NET Standard 1.3 which was removed as part of version 3.7. Type information should be accessed directly from the System.Type class.")]
public static class Amazon.Util.Internal.TypeFactory : object {
    public static ITypeInfo[] EmptyTypes;
    private static TypeFactory();
    public static ITypeInfo GetTypeInfo(Type type);
}
public class Amazon.Util.JitteredDelay : object {
    private TimeSpan _maxDelay;
    private TimeSpan _variance;
    private TimeSpan _baseIncrement;
    private Random _rand;
    private int _count;
    public JitteredDelay(TimeSpan baseIncrement, TimeSpan variance);
    public JitteredDelay(TimeSpan baseIncrement, TimeSpan variance, TimeSpan maxDelay);
    public TimeSpan GetRetryDelay(int attemptCount);
    public TimeSpan Next();
    public void Reset();
}
public class Amazon.Util.LoggingConfig : object {
    public static int DefaultLogResponsesSizeLimit;
    private LoggingOptions _logTo;
    [CompilerGeneratedAttribute]
private ResponseLoggingOption <LogResponses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LogResponsesSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private LogMetricsFormatOption <LogMetricsFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetricsFormatter <LogMetricsCustomFormatter>k__BackingField;
    public LoggingOptions LogTo { get; public set; }
    public ResponseLoggingOption LogResponses { get; public set; }
    public int LogResponsesSizeLimit { get; public set; }
    public bool LogMetrics { get; public set; }
    public LogMetricsFormatOption LogMetricsFormat { get; public set; }
    public IMetricsFormatter LogMetricsCustomFormatter { get; public set; }
    private static LoggingConfig();
    public LoggingOptions get_LogTo();
    public void set_LogTo(LoggingOptions value);
    [CompilerGeneratedAttribute]
public ResponseLoggingOption get_LogResponses();
    [CompilerGeneratedAttribute]
public void set_LogResponses(ResponseLoggingOption value);
    [CompilerGeneratedAttribute]
public int get_LogResponsesSizeLimit();
    [CompilerGeneratedAttribute]
public void set_LogResponsesSizeLimit(int value);
    [CompilerGeneratedAttribute]
public bool get_LogMetrics();
    [CompilerGeneratedAttribute]
public void set_LogMetrics(bool value);
    [CompilerGeneratedAttribute]
public LogMetricsFormatOption get_LogMetricsFormat();
    [CompilerGeneratedAttribute]
public void set_LogMetricsFormat(LogMetricsFormatOption value);
    [CompilerGeneratedAttribute]
public IMetricsFormatter get_LogMetricsCustomFormatter();
    [CompilerGeneratedAttribute]
public void set_LogMetricsCustomFormatter(IMetricsFormatter value);
}
internal class Amazon.Util.Marker`1 : object {
    private List`1<U> data;
    private string nextToken;
    internal List`1<U> Data { get; }
    internal string NextToken { get; }
    internal Marker`1(List`1<U> data, string nextToken);
    internal List`1<U> get_Data();
    internal string get_NextToken();
}
public class Amazon.Util.NetworkInterfaceMetadata : object {
    private string _path;
    private string _mac;
    private IEnumerable`1<string> _availableKeys;
    private Dictionary`2<string, string> _data;
    public string MacAddress { get; }
    public string OwnerId { get; }
    public string Profile { get; }
    public string LocalHostname { get; }
    public IEnumerable`1<string> LocalIPv4s { get; }
    public string PublicHostname { get; }
    public IEnumerable`1<string> PublicIPv4s { get; }
    public IEnumerable`1<string> SecurityGroups { get; }
    public IEnumerable`1<string> SecurityGroupIds { get; }
    public string SubnetId { get; }
    public string SubnetIPv4CidrBlock { get; }
    public string VpcId { get; }
    public NetworkInterfaceMetadata(string macAddress);
    public string get_MacAddress();
    public string get_OwnerId();
    public string get_Profile();
    public string get_LocalHostname();
    public IEnumerable`1<string> get_LocalIPv4s();
    public string get_PublicHostname();
    public IEnumerable`1<string> get_PublicIPv4s();
    public IEnumerable`1<string> get_SecurityGroups();
    public IEnumerable`1<string> get_SecurityGroupIds();
    public string get_SubnetId();
    public string get_SubnetIPv4CidrBlock();
    public string get_VpcId();
    public IEnumerable`1<string> GetIpV4Association(string publicIp);
    private string GetData(string key);
    private IEnumerable`1<string> GetItems(string key);
}
internal class Amazon.Util.PaginatedResource`1 : object {
    internal Func`2<string, Marker`1<U>> fetcher;
    internal PaginatedResource`1(Func`2<string, Marker`1<U>> fetcher);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<U> GetEnumerator();
}
internal class Amazon.Util.PaginationEnumerator`1 : object {
    private PaginatedResource`1<U> paginatedResource;
    private int position;
    private static Marker`1<U> blankSpot;
    private Marker`1<U> currentSpot;
    private bool started;
    private object System.Collections.IEnumerator.Current { get; }
    public U Current { get; }
    internal PaginationEnumerator`1(PaginatedResource`1<U> paginatedResource);
    private static PaginationEnumerator`1();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual U get_Current();
    public sealed virtual void Dispose();
}
public class Amazon.Util.ProcessExecutionResult : object {
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardError>k__BackingField;
    public int ExitCode { get; public set; }
    public string StandardOutput { get; public set; }
    public string StandardError { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
public void set_ExitCode(int value);
    [CompilerGeneratedAttribute]
public string get_StandardOutput();
    [CompilerGeneratedAttribute]
public void set_StandardOutput(string value);
    [CompilerGeneratedAttribute]
public string get_StandardError();
    [CompilerGeneratedAttribute]
public void set_StandardError(string value);
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release. Please use Amazon.Runtime.CredentialManagement.NetSDKCredentialsFile, SharedCredentialsFile, or SAMLEndpointManager.  Visit http://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/net-dg-config-creds.html for further details.")]
public static class Amazon.Util.ProfileManager : object {
    public static string AWSCredentialsProfileType;
    public static string SAMLRoleProfileType;
    public static bool IsAvailable { get; }
    public static bool get_IsAvailable();
    public static void RegisterProfile(string profileName, string accessKeyId, string secretKey);
    public static void RegisterSAMLRoleProfile(string profileName, string endpointName, string roleArn, string userIdentity);
    public static void RegisterSAMLRoleProfile(string profileName, string endpointName, string roleArn, string userIdentity, string stsRegion);
    public static string RegisterSAMLEndpoint(string endpointName, Uri endpoint, string authenticationType);
    public static void UnregisterProfile(string profileName);
    public static IEnumerable`1<string> ListProfileNames();
    public static IEnumerable`1<ProfileSettingsBase> ListProfiles();
    public static bool IsProfileKnown(string profileName);
    public static string CopyProfileSettings(string sourceProfileName, string destinationProfileName);
    public static string CopyProfileSettings(ObjectSettings source, string destinationProfileName);
    public static bool TryGetAWSCredentials(string profileName, AWSCredentials& credentials);
    public static AWSCredentials GetAWSCredentials(string profileName);
    public static ProfileSettingsBase GetProfile(string profileName);
    public static T GetProfile(string profileName);
    public static bool TryGetProfile(string profileName, T& profile);
    public static bool TryGetSAMLEndpoint(string endpointName, SAMLEndpointSettings& endpointSettings);
    public static SAMLEndpointSettings GetSAMLEndpoint(string endpointName);
    internal static ObjectSettings ReadProfileSettings(string profileName);
    internal static ObjectSettings ReadProfileSettings(SettingsCollection settings, string profileName);
    internal static ObjectSettings ReadSettings(SettingsCollection settings, string settingsKey);
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release. Please use Amazon.Runtime.CredentialManagement.CredentialProfile.  Visit http://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/net-dg-config-creds.html for further details.")]
public abstract class Amazon.Util.ProfileSettingsBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    public string Name { get; protected set; }
    public string UniqueId { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
protected void set_UniqueId(string value);
    public abstract virtual string Persist();
    protected static ObjectSettings LoadCredentialsProfile(string profileName);
}
public class Amazon.Util.ProxyConfig : object {
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <BypassList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BypassOnLocal>k__BackingField;
    public string Host { get; public set; }
    public Nullable`1<int> Port { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public List`1<string> BypassList { get; public set; }
    public bool BypassOnLocal { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_BypassList();
    [CompilerGeneratedAttribute]
public void set_BypassList(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_BypassOnLocal();
    [CompilerGeneratedAttribute]
public void set_BypassOnLocal(bool value);
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release. Please use Amazon.Runtime.CredentialManagement.SAMLEndpoint.  Visit http://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/net-dg-config-creds.html for further details.")]
public class Amazon.Util.SAMLEndpointSettings : ProfileSettingsBase {
    public static string DefaultAuthenticationType;
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    private string _authenticationType;
    public Uri Endpoint { get; private set; }
    public string AuthenticationType { get; }
    private SAMLEndpointSettings(string settingsName, Uri endpoint, string authenticationType);
    private static SAMLEndpointSettings();
    [CompilerGeneratedAttribute]
public Uri get_Endpoint();
    [CompilerGeneratedAttribute]
private void set_Endpoint(Uri value);
    public string get_AuthenticationType();
    public static bool CanCreateFrom(string endpointName);
    public static bool CanCreateFrom(ObjectSettings os);
    public static SAMLEndpointSettings LoadFrom(string endpointName);
    public static SAMLEndpointSettings LoadFrom(ObjectSettings os);
    public static void Validate(string endpointName);
    private static void Validate(ObjectSettings os);
    public virtual string Persist();
    public static string Persist(string settingsName, Uri endpoint, string authenticationType);
    private static ObjectSettings LoadSettings(string endpointName);
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release. Please use Amazon.Runtime.CredentialProfile.  Visit http://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/net-dg-config-creds.html for further details.")]
public class Amazon.Util.SAMLRoleProfile : ProfileSettingsBase {
    private object _synclock;
    [CompilerGeneratedAttribute]
private string <RoleArn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Region>k__BackingField;
    private SAMLImmutableCredentials _session;
    [CompilerGeneratedAttribute]
private SAMLEndpointSettings <EndpointSettings>k__BackingField;
    public string RoleArn { get; internal set; }
    public string UserIdentity { get; internal set; }
    public bool UseDefaultUserIdentity { get; }
    public string Region { get; private set; }
    public SAMLEndpointSettings EndpointSettings { get; internal set; }
    private SAMLRoleProfile(string profileName, SAMLEndpointSettings endpointSettings, string roleArn, string userIdentity, SAMLImmutableCredentials currentSession, string region);
    [CompilerGeneratedAttribute]
public string get_RoleArn();
    [CompilerGeneratedAttribute]
internal void set_RoleArn(string value);
    [CompilerGeneratedAttribute]
public string get_UserIdentity();
    [CompilerGeneratedAttribute]
internal void set_UserIdentity(string value);
    public bool get_UseDefaultUserIdentity();
    [CompilerGeneratedAttribute]
public string get_Region();
    [CompilerGeneratedAttribute]
private void set_Region(string value);
    public SAMLImmutableCredentials GetCurrentSession();
    public void PersistSession(SAMLImmutableCredentials credentials);
    private void UpdateProfileSessionData(SAMLImmutableCredentials credentials);
    [CompilerGeneratedAttribute]
public SAMLEndpointSettings get_EndpointSettings();
    [CompilerGeneratedAttribute]
internal void set_EndpointSettings(SAMLEndpointSettings value);
    public static bool CanCreateFrom(string profileName);
    public static bool CanCreateFrom(ObjectSettings os);
    public static SAMLRoleProfile LoadFrom(string profileName);
    public static SAMLRoleProfile LoadFrom(ObjectSettings os);
    public static void Validate(string profileName);
    private static void Validate(ObjectSettings os);
    public virtual string Persist();
    private string Persist(string session);
    public static string Persist(string profileName, string endpointSettingsName, string roleArn, string userIdentity, string session, string region);
    private static SAMLImmutableCredentials LoadActiveSessionCredentials(string profileName);
    private static void PersistActiveSessionCredentials(string profileName, string session);
}
public enum Amazon.Util.SegmentType : Enum {
    public int value__;
    public static SegmentType Literal;
    public static SegmentType Label;
}
public class Amazon.Util.UriComponent : object {
    [CompilerGeneratedAttribute]
private SegmentType <SegmentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public SegmentType SegmentType { get; public set; }
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public SegmentType get_SegmentType();
    [CompilerGeneratedAttribute]
public void set_SegmentType(SegmentType value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
}
public static class AWSSDK.Runtime.Internal.Util.ChecksumCRTWrapper : object {
    internal static string CRT_WRAPPER_ASSEMBLY_NAME;
    private static string CRT_WRAPPER_NUGET_PACKAGE_NAME;
    internal static string CRT_WRAPPER_CLASS_NAME;
    private static object _lock;
    private static IChecksumProvider modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075")]
private static IChecksumProvider Instance { get; }
    private static ChecksumCRTWrapper();
    private static IChecksumProvider get_Instance();
    public static string Crc32(Byte[] source);
    public static UInt32 Crc32(Byte[] source, UInt32 previous);
    public static string Crc32C(Byte[] source);
    public static UInt32 Crc32C(Byte[] source, UInt32 previous);
}
internal static class AWSSDK.Runtime.Internal.Util.ExceptionUtils : object {
    internal static Nullable`1<HttpStatusCode> DetermineHttpStatusCode(Exception e);
    internal static bool IsInnerException(Exception exception);
    internal static bool IsInnerException(Exception exception, T& inner);
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
[SkipLocalsInitAttribute]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__DisallowedCharactersRegex_4 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__DisallowedCharactersRegex_4 Instance;
    private static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__DisallowedCharactersRegex_4();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
[SkipLocalsInitAttribute]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__LabelValidationRegex_1 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__LabelValidationRegex_1 Instance;
    private static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__LabelValidationRegex_1();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
[SkipLocalsInitAttribute]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__RoleSessionNameRegex_0 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__RoleSessionNameRegex_0 Instance;
    private static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__RoleSessionNameRegex_0();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
[SkipLocalsInitAttribute]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__S3ControlExlusionRegex_3 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__S3ControlExlusionRegex_3 Instance;
    private static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__S3ControlExlusionRegex_3();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
[SkipLocalsInitAttribute]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__S3EndpointRegex_2 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__S3EndpointRegex_2 Instance;
    private static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__S3EndpointRegex_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
internal static class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__Utilities : object {
    internal static TimeSpan s_defaultTimeout;
    internal static bool s_hasTimeout;
    internal static SearchValues`1<char> s_ascii_20FF0300000000FEFFFF07;
    internal static SearchValues`1<char> s_ascii_20FF03FEFFFF07FEFFFF07;
    internal static SearchValues`1<char> s_ascii_FBFCFF03FEFFFFC7FFFFFF57;
    private static <RegexGenerator_g>F64A9C3F31A3D2247F1AAB6D169C27204463B520E970FBD77DD26A53260AA90EC__Utilities();
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static int IndexOfNonAsciiOrAny_A4D822EA9EDC7612B6CE2E61A9F22A6AEF68BBEA8F803C3E2C9B34E2B191A304(ReadOnlySpan`1<char> span);
    internal static void StackPop(Int32[] stack, Int32& pos, Int32& arg0, Int32& arg1);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0, int arg1);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0, int arg1, int arg2);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|4_0(Int32[]& stack, Int32& pos, int arg0);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|5_0(Int32[]& stack, Int32& pos, int arg0, int arg1);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|6_0(Int32[]& stack, Int32& pos, int arg0, int arg1, int arg2);
}
public abstract class ThirdParty.BouncyCastle.Asn1.Asn1Encodable : object {
    public abstract virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public class ThirdParty.BouncyCastle.Asn1.Asn1EncodableVector : object {
    private IList v;
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public Asn1EncodableVector(Asn1Encodable[] v);
    public static Asn1EncodableVector FromEnumerable(IEnumerable e);
    public void Add(Asn1Encodable[] objs);
    public void AddOptional(Asn1Encodable[] objs);
    public Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable Get(int index);
    public int get_Size();
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
}
public class ThirdParty.BouncyCastle.Asn1.Asn1InputStream : FilterStream {
    public static int Constructed;
    public static int Integer;
    private int limit;
    public Asn1InputStream(Stream inputStream);
    public Asn1InputStream(Stream inputStream, int limit);
    public Asn1InputStream(Byte[] input);
    internal static int FindLimit(Stream input);
    private Asn1Object BuildObject(int tag, int tagNo, int length);
    internal Asn1EncodableVector BuildEncodableVector();
    internal virtual Asn1EncodableVector BuildDerEncodableVector(Stream dIn);
    internal virtual DerSequence CreateDerSequence(Stream dIn);
    public Asn1Object ReadObject();
    internal static int ReadTagNumber(Stream s, int tag);
    internal static int ReadLength(Stream s, int limit);
    internal static Asn1Object CreatePrimitiveDerObject(int tagNo, Byte[] bytes);
}
public abstract class ThirdParty.BouncyCastle.Asn1.Asn1Object : Asn1Encodable {
    public static Asn1Object FromByteArray(Byte[] data);
    public static Asn1Object FromStream(Stream inStr);
    public sealed virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
public abstract class ThirdParty.BouncyCastle.Asn1.Asn1Sequence : Asn1Object {
    private IList seq;
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    protected internal Asn1Sequence(int capacity);
    public virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    public virtual Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetObjectAt(int index);
    public int get_Size();
    public virtual int get_Count();
    private Asn1Encodable GetCurrent(IEnumerator e);
    protected internal void AddObject(Asn1Encodable obj);
}
public class ThirdParty.BouncyCastle.Asn1.DerInteger : Asn1Object {
    private Byte[] bytes;
    public Byte[] Bytes { get; }
    public BigInteger Value { get; }
    public DerInteger(int value);
    public DerInteger(BigInteger value);
    public DerInteger(Byte[] bytes);
    public Byte[] get_Bytes();
    public BigInteger get_Value();
    public virtual string ToString();
}
public class ThirdParty.BouncyCastle.Asn1.DerSequence : Asn1Sequence {
    public static DerSequence Empty;
    public DerSequence(Asn1Encodable obj);
    public DerSequence(Asn1Encodable[] v);
    public DerSequence(Asn1EncodableVector v);
    private static DerSequence();
    public static DerSequence FromVector(Asn1EncodableVector v);
}
public class ThirdParty.BouncyCastle.Asn1.Utilities.FilterStream : Stream {
    protected Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class ThirdParty.BouncyCastle.Math.BigInteger : object {
    private static long IMASK;
    private static Int32[] ZeroMagnitude;
    private static Byte[] ZeroEncoding;
    public static BigInteger Zero;
    public static BigInteger One;
    public static BigInteger Two;
    public static BigInteger Three;
    public static BigInteger Ten;
    private static Random RandomSource;
    private static int BitsPerByte;
    private static int BitsPerInt;
    private static int BytesPerInt;
    private int sign;
    private Int32[] magnitude;
    private int nBitLength;
    private static Byte[] rndMask;
    public int BitLength { get; }
    private BigInteger(int signum, Int32[] mag, bool checkMag);
    public BigInteger(Byte[] bytes);
    public BigInteger(Byte[] bytes, int offset, int length);
    private static BigInteger();
    private static int GetByteLength(int nBits);
    private static Int32[] MakeMagnitude(Byte[] bytes, int offset, int length);
    private static Int32[] AddMagnitudes(Int32[] a, Int32[] b);
    private BigInteger AddToMagnitude(Int32[] magToAdd);
    private int calcBitLength(int indx, Int32[] mag);
    public int get_BitLength();
    private static int BitLen(int w);
    public int CompareTo(object obj);
    private static int CompareTo(int xIndx, Int32[] x, int yIndx, Int32[] y);
    private static int CompareNoLeadingZeroes(int xIndx, Int32[] x, int yIndx, Int32[] y);
    public int CompareTo(BigInteger value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private BigInteger Inc();
    public BigInteger Negate();
    public BigInteger Not();
    private static Int32[] Subtract(int xStart, Int32[] x, int yStart, Int32[] y);
    private static Int32[] doSubBigLil(Int32[] bigMag, Int32[] lilMag);
    public Byte[] ToByteArray();
    public Byte[] ToByteArrayUnsigned();
    private Byte[] ToByteArray(bool unsigned);
    private static BigInteger createUValueOf(ulong value);
    private static BigInteger createValueOf(long value);
    public static BigInteger ValueOf(long value);
}
public class ThirdParty.BouncyCastle.OpenSsl.PemReader : PemReader {
    public PemReader(TextReader reader);
    public RSAParameters ReadPrivatekey();
    private RSAParameters convertSequenceToRSAParameters(Asn1Sequence seq);
    private int GetAlignmentValue(Byte[] modules);
    public static Byte[] FixAlignment(Byte[] inputBytes, int alignment);
}
public class ThirdParty.BouncyCastle.Utilities.IO.Pem.PemGenerationException : Exception {
    public PemGenerationException(string message);
    public PemGenerationException(string message, Exception exception);
}
public class ThirdParty.BouncyCastle.Utilities.IO.Pem.PemHeader : object {
    private string name;
    private string val;
    public string Name { get; }
    public string Value { get; }
    public PemHeader(string name, string val);
    public virtual string get_Name();
    public virtual string get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private int GetHashCode(string s);
}
public class ThirdParty.BouncyCastle.Utilities.IO.Pem.PemObject : object {
    private string type;
    private IList headers;
    private Byte[] content;
    public string Type { get; }
    public IList Headers { get; }
    public Byte[] Content { get; }
    public PemObject(string type, Byte[] content);
    public PemObject(string type, IList headers, Byte[] content);
    public string get_Type();
    public IList get_Headers();
    public Byte[] get_Content();
    public sealed virtual PemObject Generate();
}
public interface ThirdParty.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator {
    public abstract virtual PemObject Generate();
}
public interface ThirdParty.BouncyCastle.Utilities.IO.Pem.PemObjectParser {
    public abstract virtual object ParseObject(PemObject obj);
}
public class ThirdParty.BouncyCastle.Utilities.IO.Pem.PemReader : object {
    private static string BeginString;
    private static string EndString;
    private TextReader reader;
    public TextReader Reader { get; }
    public PemReader(TextReader reader);
    public TextReader get_Reader();
    public PemObject ReadPemObject();
    private PemObject LoadObject(string type);
}
internal abstract class ThirdParty.BouncyCastle.Utilities.Platform : object {
    internal static IList CreateArrayList();
    internal static IList CreateArrayList(int capacity);
    internal static IList CreateArrayList(ICollection collection);
    internal static IList CreateArrayList(IEnumerable collection);
}
internal class ThirdParty.Ionic.Zlib.CRC32 : object {
    private long _TotalBytesRead;
    private static UInt32[] crc32Table;
    private static int BUFFER_SIZE;
    private UInt32 _RunningCrc32Result;
    public long TotalBytesRead { get; }
    public int Crc32Result { get; }
    private static CRC32();
    public long get_TotalBytesRead();
    public int get_Crc32Result();
    public int GetCrc32(Stream input);
    public int GetCrc32AndCopy(Stream input, Stream output);
    public int ComputeCrc32(int W, byte B);
    internal int _InternalComputeCrc32(UInt32 W, byte B);
    public void SlurpBlock(Byte[] block, int offset, int count);
}
public class ThirdParty.Ionic.Zlib.CrcCalculatorStream : Stream {
    private Stream _InnerStream;
    private CRC32 _Crc32;
    private long _length;
    public long TotalBytesSlurped { get; }
    public int Crc32 { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcCalculatorStream(Stream stream);
    public CrcCalculatorStream(Stream stream, long length);
    public long get_TotalBytesSlurped();
    public int get_Crc32();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class ThirdParty.Json.LitJson.ArrayMetadata : ValueType {
    private Type element_type;
    private bool is_array;
    private bool is_list;
    public Type ElementType { get; public set; }
    public bool IsArray { get; public set; }
    public bool IsList { get; public set; }
    public Type get_ElementType();
    public void set_ElementType(Type value);
    public bool get_IsArray();
    public void set_IsArray(bool value);
    public bool get_IsList();
    public void set_IsList(bool value);
}
internal enum ThirdParty.Json.LitJson.Condition : Enum {
    public int value__;
    public static Condition InArray;
    public static Condition InObject;
    public static Condition NotAProperty;
    public static Condition Property;
    public static Condition Value;
}
internal class ThirdParty.Json.LitJson.ExporterFunc : MulticastDelegate {
    public ExporterFunc(object object, IntPtr method);
    public virtual void Invoke(object obj, JsonWriter writer);
    public virtual IAsyncResult BeginInvoke(object obj, JsonWriter writer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ThirdParty.Json.LitJson.ExporterFunc`1 : MulticastDelegate {
    public ExporterFunc`1(object object, IntPtr method);
    public virtual void Invoke(T obj, JsonWriter writer);
    public virtual IAsyncResult BeginInvoke(T obj, JsonWriter writer, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class ThirdParty.Json.LitJson.FsmContext : object {
    public bool Return;
    public int NextState;
    public Lexer L;
    public int StateStack;
}
public interface ThirdParty.Json.LitJson.IJsonWrapper {
    public bool IsArray { get; }
    public bool IsBoolean { get; }
    public bool IsDouble { get; }
    public bool IsInt { get; }
    public bool IsUInt { get; }
    public bool IsLong { get; }
    public bool IsULong { get; }
    public bool IsObject { get; }
    public bool IsString { get; }
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsBoolean();
    public abstract virtual bool get_IsDouble();
    public abstract virtual bool get_IsInt();
    public abstract virtual bool get_IsUInt();
    public abstract virtual bool get_IsLong();
    public abstract virtual bool get_IsULong();
    public abstract virtual bool get_IsObject();
    public abstract virtual bool get_IsString();
    public abstract virtual bool GetBoolean();
    public abstract virtual double GetDouble();
    public abstract virtual int GetInt();
    public abstract virtual UInt32 GetUInt();
    public abstract virtual JsonType GetJsonType();
    public abstract virtual long GetLong();
    public abstract virtual ulong GetULong();
    public abstract virtual string GetString();
    public abstract virtual void SetBoolean(bool val);
    public abstract virtual void SetDouble(double val);
    public abstract virtual void SetInt(int val);
    public abstract virtual void SetUInt(UInt32 val);
    public abstract virtual void SetJsonType(JsonType type);
    public abstract virtual void SetLong(long val);
    public abstract virtual void SetULong(ulong val);
    public abstract virtual void SetString(string val);
    public abstract virtual string ToJson();
    public abstract virtual void ToJson(JsonWriter writer);
}
internal class ThirdParty.Json.LitJson.ImporterFunc : MulticastDelegate {
    public ImporterFunc(object object, IntPtr method);
    public virtual object Invoke(object input);
    public virtual IAsyncResult BeginInvoke(object input, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class ThirdParty.Json.LitJson.ImporterFunc`2 : MulticastDelegate {
    public ImporterFunc`2(object object, IntPtr method);
    public virtual TValue Invoke(TJson input);
    public virtual IAsyncResult BeginInvoke(TJson input, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class ThirdParty.Json.LitJson.JsonData : object {
    private IList`1<JsonData> inst_array;
    private bool inst_boolean;
    private double inst_double;
    private ulong inst_number;
    private IDictionary`2<string, JsonData> inst_object;
    private string inst_string;
    private string json;
    private JsonType type;
    private IList`1<KeyValuePair`2<string, JsonData>> object_list;
    public int Count { get; }
    public bool IsArray { get; }
    public bool IsBoolean { get; }
    public bool IsDouble { get; }
    public bool IsInt { get; }
    public bool IsUInt { get; }
    public bool IsLong { get; }
    public bool IsULong { get; }
    public bool IsObject { get; }
    public bool IsString { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool ThirdParty.Json.LitJson.IJsonWrapper.IsArray { get; }
    private bool ThirdParty.Json.LitJson.IJsonWrapper.IsBoolean { get; }
    private bool ThirdParty.Json.LitJson.IJsonWrapper.IsDouble { get; }
    private bool ThirdParty.Json.LitJson.IJsonWrapper.IsInt { get; }
    private bool ThirdParty.Json.LitJson.IJsonWrapper.IsLong { get; }
    private bool ThirdParty.Json.LitJson.IJsonWrapper.IsObject { get; }
    private bool ThirdParty.Json.LitJson.IJsonWrapper.IsString { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private object System.Collections.Specialized.IOrderedDictionary.Item { get; private set; }
    private object System.Collections.IList.Item { get; private set; }
    public IEnumerable`1<string> PropertyNames { get; }
    public JsonData Item { get; public set; }
    public JsonData Item { get; public set; }
    public JsonData(bool boolean);
    public JsonData(double number);
    public JsonData(int number);
    public JsonData(UInt32 number);
    public JsonData(long number);
    public JsonData(ulong number);
    public JsonData(object obj);
    public JsonData(string str);
    public int get_Count();
    public bool get_IsArray();
    public bool get_IsBoolean();
    public bool get_IsDouble();
    public bool get_IsInt();
    public sealed virtual bool get_IsUInt();
    public bool get_IsLong();
    public sealed virtual bool get_IsULong();
    public bool get_IsObject();
    public bool get_IsString();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool ThirdParty.Json.LitJson.IJsonWrapper.get_IsArray();
    private sealed virtual override bool ThirdParty.Json.LitJson.IJsonWrapper.get_IsBoolean();
    private sealed virtual override bool ThirdParty.Json.LitJson.IJsonWrapper.get_IsDouble();
    private sealed virtual override bool ThirdParty.Json.LitJson.IJsonWrapper.get_IsInt();
    private sealed virtual override bool ThirdParty.Json.LitJson.IJsonWrapper.get_IsLong();
    private sealed virtual override bool ThirdParty.Json.LitJson.IJsonWrapper.get_IsObject();
    private sealed virtual override bool ThirdParty.Json.LitJson.IJsonWrapper.get_IsString();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override object System.Collections.Specialized.IOrderedDictionary.get_Item(int idx);
    private sealed virtual override void System.Collections.Specialized.IOrderedDictionary.set_Item(int idx, object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public IEnumerable`1<string> get_PropertyNames();
    public JsonData get_Item(string prop_name);
    public void set_Item(string prop_name, JsonData value);
    public JsonData get_Item(int index);
    public void set_Item(int index, JsonData value);
    public static JsonData op_Implicit(bool data);
    public static JsonData op_Implicit(double data);
    public static JsonData op_Implicit(int data);
    public static JsonData op_Implicit(long data);
    public static JsonData op_Implicit(string data);
    public static bool op_Explicit(JsonData data);
    public static double op_Explicit(JsonData data);
    public static int op_Explicit(JsonData data);
    public static UInt32 op_Explicit(JsonData data);
    public static long op_Explicit(JsonData data);
    public static ulong op_Explicit(JsonData data);
    public static string op_Explicit(JsonData data);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool ThirdParty.Json.LitJson.IJsonWrapper.GetBoolean();
    private sealed virtual override double ThirdParty.Json.LitJson.IJsonWrapper.GetDouble();
    private sealed virtual override int ThirdParty.Json.LitJson.IJsonWrapper.GetInt();
    private sealed virtual override UInt32 ThirdParty.Json.LitJson.IJsonWrapper.GetUInt();
    private sealed virtual override long ThirdParty.Json.LitJson.IJsonWrapper.GetLong();
    private sealed virtual override ulong ThirdParty.Json.LitJson.IJsonWrapper.GetULong();
    private sealed virtual override string ThirdParty.Json.LitJson.IJsonWrapper.GetString();
    private sealed virtual override void ThirdParty.Json.LitJson.IJsonWrapper.SetBoolean(bool val);
    private sealed virtual override void ThirdParty.Json.LitJson.IJsonWrapper.SetDouble(double val);
    private sealed virtual override void ThirdParty.Json.LitJson.IJsonWrapper.SetInt(int val);
    private sealed virtual override void ThirdParty.Json.LitJson.IJsonWrapper.SetUInt(UInt32 val);
    private sealed virtual override void ThirdParty.Json.LitJson.IJsonWrapper.SetLong(long val);
    private sealed virtual override void ThirdParty.Json.LitJson.IJsonWrapper.SetULong(ulong val);
    private sealed virtual override void ThirdParty.Json.LitJson.IJsonWrapper.SetString(string val);
    private sealed virtual override string ThirdParty.Json.LitJson.IJsonWrapper.ToJson();
    private sealed virtual override void ThirdParty.Json.LitJson.IJsonWrapper.ToJson(JsonWriter writer);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override IDictionaryEnumerator System.Collections.Specialized.IOrderedDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.Specialized.IOrderedDictionary.Insert(int idx, object key, object value);
    private sealed virtual override void System.Collections.Specialized.IOrderedDictionary.RemoveAt(int idx);
    private ICollection EnsureCollection();
    private IDictionary EnsureDictionary();
    private IList EnsureList();
    private JsonData ToJsonData(object obj);
    private static void WriteJson(IJsonWrapper obj, JsonWriter writer);
    public int Add(object value);
    public void Clear();
    public sealed virtual bool Equals(JsonData x);
    public sealed virtual JsonType GetJsonType();
    public sealed virtual void SetJsonType(JsonType type);
    public string ToJson();
    public void ToJson(JsonWriter writer);
    public virtual string ToString();
}
public class ThirdParty.Json.LitJson.JsonException : Exception {
    internal JsonException(ParserToken token);
    internal JsonException(ParserToken token, Exception inner_exception);
    internal JsonException(int c);
    internal JsonException(int c, Exception inner_exception);
    public JsonException(string message);
    public JsonException(string message, Exception inner_exception);
}
public class ThirdParty.Json.LitJson.JsonMapper : object {
    private static int max_nesting_depth;
    private static IFormatProvider datetime_format;
    private static IDictionary`2<Type, ExporterFunc> base_exporters_table;
    private static IDictionary`2<Type, ExporterFunc> custom_exporters_table;
    private static IDictionary`2<Type, IDictionary`2<Type, ImporterFunc>> base_importers_table;
    private static IDictionary`2<Type, IDictionary`2<Type, ImporterFunc>> custom_importers_table;
    private static IDictionary`2<Type, ArrayMetadata> array_metadata;
    private static object array_metadata_lock;
    private static IDictionary`2<Type, IDictionary`2<Type, MethodInfo>> conv_ops;
    private static object conv_ops_lock;
    private static IDictionary`2<Type, ObjectMetadata> object_metadata;
    private static object object_metadata_lock;
    private static IDictionary`2<Type, IList`1<PropertyMetadata>> type_properties;
    private static object type_properties_lock;
    private static JsonWriter static_writer;
    private static object static_writer_lock;
    private static HashSet`1<string> dictionary_properties_to_ignore;
    private static JsonMapper();
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
private static void AddArrayMetadata(Type type);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
private static void AddObjectMetadata(Type type);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
private static void AddTypeProperties(Type type);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
private static MethodInfo GetConvOp(Type t1, Type t2);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
private static object ReadValue(Type inst_type, JsonReader reader);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
private static void ValidateRequiredFields(object instance, Type inst_type);
    private static IJsonWrapper ReadValue(WrapperFactory factory, JsonReader reader);
    private static void RegisterBaseExporters();
    private static void RegisterBaseImporters();
    private static void RegisterImporter(IDictionary`2<Type, IDictionary`2<Type, ImporterFunc>> table, Type json_type, Type value_type, ImporterFunc importer);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
private static void WriteValue(object obj, JsonWriter writer, bool writer_is_private, int depth);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
public static string ToJson(object obj);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
public static void ToJson(object obj, JsonWriter writer);
    public static JsonData ToObject(JsonReader reader);
    public static JsonData ToObject(TextReader reader);
    public static JsonData ToObject(string json);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
public static T ToObject(JsonReader reader);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
public static T ToObject(TextReader reader);
    [RequiresUnreferencedCodeAttribute("JsonMapper requires reflection of unknown types. System.Text.Json should be used instead.")]
public static T ToObject(string json);
    public static IJsonWrapper ToWrapper(WrapperFactory factory, JsonReader reader);
    public static IJsonWrapper ToWrapper(WrapperFactory factory, string json);
    public static void RegisterExporter(ExporterFunc`1<T> exporter);
    public static void RegisterImporter(ImporterFunc`2<TJson, TValue> importer);
    public static void UnregisterExporters();
    public static void UnregisterImporters();
}
[AttributeUsageAttribute("128")]
public class ThirdParty.Json.LitJson.JsonPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
}
public class ThirdParty.Json.LitJson.JsonReader : object {
    private Stack`1<JsonToken> depth;
    private int current_input;
    private int current_symbol;
    private bool end_of_json;
    private bool end_of_input;
    private Lexer lexer;
    private bool parser_in_string;
    private bool parser_return;
    private bool read_started;
    private TextReader reader;
    private bool reader_is_owned;
    private object token_value;
    private JsonToken token;
    public bool AllowComments { get; public set; }
    public bool AllowSingleQuotedStrings { get; public set; }
    public bool EndOfInput { get; }
    public bool EndOfJson { get; }
    public JsonToken Token { get; }
    public object Value { get; }
    public JsonReader(string json_text);
    public JsonReader(TextReader reader);
    private JsonReader(TextReader reader, bool owned);
    public bool get_AllowComments();
    public void set_AllowComments(bool value);
    public bool get_AllowSingleQuotedStrings();
    public void set_AllowSingleQuotedStrings(bool value);
    public bool get_EndOfInput();
    public bool get_EndOfJson();
    public JsonToken get_Token();
    public object get_Value();
    private void ProcessNumber(string number);
    private void ProcessSymbol();
    private bool ReadToken();
    public void Close();
    public bool Read();
}
public enum ThirdParty.Json.LitJson.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken ObjectStart;
    public static JsonToken PropertyName;
    public static JsonToken ObjectEnd;
    public static JsonToken ArrayStart;
    public static JsonToken ArrayEnd;
    public static JsonToken Int;
    public static JsonToken UInt;
    public static JsonToken Long;
    public static JsonToken ULong;
    public static JsonToken Double;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
}
public enum ThirdParty.Json.LitJson.JsonType : Enum {
    public int value__;
    public static JsonType None;
    public static JsonType Object;
    public static JsonType Array;
    public static JsonType String;
    public static JsonType Int;
    public static JsonType UInt;
    public static JsonType Long;
    public static JsonType ULong;
    public static JsonType Double;
    public static JsonType Boolean;
}
public class ThirdParty.Json.LitJson.JsonWriter : object {
    private static NumberFormatInfo number_format;
    private WriterContext context;
    private Stack`1<WriterContext> ctx_stack;
    private bool has_reached_end;
    private Char[] hex_seq;
    private int indentation;
    private int indent_value;
    private StringBuilder inst_string_builder;
    private bool pretty_print;
    private bool validate;
    private TextWriter writer;
    public int IndentValue { get; public set; }
    public bool PrettyPrint { get; public set; }
    public TextWriter TextWriter { get; }
    public bool Validate { get; public set; }
    private static JsonWriter();
    public JsonWriter(StringBuilder sb);
    public JsonWriter(TextWriter writer);
    public int get_IndentValue();
    public void set_IndentValue(int value);
    public bool get_PrettyPrint();
    public void set_PrettyPrint(bool value);
    public TextWriter get_TextWriter();
    public bool get_Validate();
    public void set_Validate(bool value);
    private void DoValidation(Condition cond);
    private void Init();
    private static void IntToHex(int n, Char[] hex);
    private void Indent();
    private void Put(string str);
    private void PutNewline();
    private void PutNewline(bool add_comma);
    private void PutString(string str);
    private void Unindent();
    public virtual string ToString();
    public void Reset();
    public void Write(bool boolean);
    public void Write(Nullable`1<bool> boolean);
    public void Write(decimal number);
    public void Write(double number);
    public void Write(int number);
    public void Write(Nullable`1<int> number);
    public void Write(UInt32 number);
    public void Write(long number);
    public void Write(string str);
    public void WriteRaw(string str);
    public void Write(ulong number);
    public void Write(DateTime date);
    public void WriteArrayEnd();
    public void WriteArrayStart();
    public void WriteObjectEnd();
    public void WriteObjectStart();
    public void WritePropertyName(string property_name);
}
internal class ThirdParty.Json.LitJson.Lexer : object {
    private static Int32[] fsm_return_table;
    private static StateHandler[] fsm_handler_table;
    private bool allow_comments;
    private bool allow_single_quoted_strings;
    private bool end_of_input;
    private FsmContext fsm_context;
    private int input_buffer;
    private int input_char;
    private TextReader reader;
    private int state;
    private StringBuilder string_buffer;
    private string string_value;
    private int token;
    private int unichar;
    public bool AllowComments { get; public set; }
    public bool AllowSingleQuotedStrings { get; public set; }
    public bool EndOfInput { get; }
    public int Token { get; }
    public string StringValue { get; }
    private static Lexer();
    public Lexer(TextReader reader);
    public bool get_AllowComments();
    public void set_AllowComments(bool value);
    public bool get_AllowSingleQuotedStrings();
    public void set_AllowSingleQuotedStrings(bool value);
    public bool get_EndOfInput();
    public int get_Token();
    public string get_StringValue();
    private static int HexValue(int digit);
    private static void PopulateFsmTables();
    private static char ProcessEscChar(int esc_char);
    private static bool State1(FsmContext ctx);
    private static bool State2(FsmContext ctx);
    private static bool State3(FsmContext ctx);
    private static bool State4(FsmContext ctx);
    private static bool State5(FsmContext ctx);
    private static bool State6(FsmContext ctx);
    private static bool State7(FsmContext ctx);
    private static bool State8(FsmContext ctx);
    private static bool State9(FsmContext ctx);
    private static bool State10(FsmContext ctx);
    private static bool State11(FsmContext ctx);
    private static bool State12(FsmContext ctx);
    private static bool State13(FsmContext ctx);
    private static bool State14(FsmContext ctx);
    private static bool State15(FsmContext ctx);
    private static bool State16(FsmContext ctx);
    private static bool State17(FsmContext ctx);
    private static bool State18(FsmContext ctx);
    private static bool State19(FsmContext ctx);
    private static bool State20(FsmContext ctx);
    private static bool State21(FsmContext ctx);
    private static bool State22(FsmContext ctx);
    private static bool State23(FsmContext ctx);
    private static bool State24(FsmContext ctx);
    private static bool State25(FsmContext ctx);
    private static bool State26(FsmContext ctx);
    private static bool State27(FsmContext ctx);
    private static bool State28(FsmContext ctx);
    private bool GetChar();
    private int NextChar();
    public bool NextToken();
    private void UngetChar();
}
internal class ThirdParty.Json.LitJson.ObjectMetadata : ValueType {
    private Type element_type;
    private bool is_dictionary;
    private IDictionary`2<string, PropertyMetadata> properties;
    public Type ElementType { get; public set; }
    public bool IsDictionary { get; public set; }
    public IDictionary`2<string, PropertyMetadata> Properties { get; public set; }
    public Type get_ElementType();
    public void set_ElementType(Type value);
    public bool get_IsDictionary();
    public void set_IsDictionary(bool value);
    public IDictionary`2<string, PropertyMetadata> get_Properties();
    public void set_Properties(IDictionary`2<string, PropertyMetadata> value);
}
internal class ThirdParty.Json.LitJson.OrderedDictionaryEnumerator : object {
    private IEnumerator`1<KeyValuePair`2<string, JsonData>> list_enumerator;
    public object Current { get; }
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    public OrderedDictionaryEnumerator(IEnumerator`1<KeyValuePair`2<string, JsonData>> enumerator);
    public sealed virtual object get_Current();
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal enum ThirdParty.Json.LitJson.ParserToken : Enum {
    public int value__;
    public static ParserToken None;
    public static ParserToken Number;
    public static ParserToken True;
    public static ParserToken False;
    public static ParserToken Null;
    public static ParserToken CharSeq;
    public static ParserToken Char;
    public static ParserToken Text;
    public static ParserToken Object;
    public static ParserToken ObjectPrime;
    public static ParserToken Pair;
    public static ParserToken PairRest;
    public static ParserToken Array;
    public static ParserToken ArrayPrime;
    public static ParserToken Value;
    public static ParserToken ValueRest;
    public static ParserToken String;
    public static ParserToken End;
    public static ParserToken Epsilon;
}
internal class ThirdParty.Json.LitJson.PropertyMetadata : ValueType {
    public MemberInfo Info;
    public bool IsField;
    public Type Type;
}
public class ThirdParty.Json.LitJson.WrapperFactory : MulticastDelegate {
    public WrapperFactory(object object, IntPtr method);
    public virtual IJsonWrapper Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IJsonWrapper EndInvoke(IAsyncResult result);
}
internal class ThirdParty.Json.LitJson.WriterContext : object {
    public int Count;
    public bool InArray;
    public bool InObject;
    public bool ExpectingValue;
    public int Padding;
}
internal class ThirdParty.MD5.ABCDStruct : ValueType {
    public UInt32 A;
    public UInt32 B;
    public UInt32 C;
    public UInt32 D;
}
internal class ThirdParty.MD5.MD5Core : object {
    public static Byte[] GetHash(string input, Encoding encoding);
    public static Byte[] GetHash(string input);
    public static string GetHashString(Byte[] input);
    public static string GetHashString(string input, Encoding encoding);
    public static string GetHashString(string input);
    public static Byte[] GetHash(Byte[] input);
    internal static Byte[] GetHashFinalBlock(Byte[] input, int ibStart, int cbSize, ABCDStruct ABCD, long len);
    internal static void GetHashBlock(Byte[] input, ABCDStruct& ABCDValue, int ibStart);
    private static UInt32 r1(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r2(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r3(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r4(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 LSR(UInt32 i, int s);
    private static UInt32[] Converter(Byte[] input, int ibStart);
}
public class ThirdParty.MD5.MD5Managed : HashAlgorithm {
    private Byte[] _data;
    private ABCDStruct _abcd;
    private long _totalLength;
    private int _dataSize;
    public virtual void Initialize();
    public void TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class ThirdParty.RuntimeBackports.ValueStringBuilder : ValueType {
    [NullableAttribute("2")]
private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(int start, int length);
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    [NullableContextAttribute("2")]
public void Insert(int index, string s);
    public void Append(char c);
    [NullableContextAttribute("2")]
public void Append(string s);
    [NullableContextAttribute("1")]
private void AppendSlow(string s);
    public void Append(char c, int count);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
