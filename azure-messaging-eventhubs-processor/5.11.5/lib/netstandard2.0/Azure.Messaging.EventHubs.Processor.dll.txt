internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
internal static class Azure.Core.Argument : object {
    public static void AssertNotEmptyOrWhiteSpace(string argumentValue, string argumentName);
    public static void AssertNotTooLong(string argumentValue, int maximumLength, string argumentName);
    public static void AssertNotNegative(TimeSpan argumentValue, string argumentName);
    public static void AssertAtLeast(long argumentValue, long minimumValue, string argumentName);
    public static void AssertAtLeast(int argumentValue, int minimumValue, string argumentName);
    public static void AssertNotDisposed(bool wasDisposed, string targetName);
    public static void AssertNotClosed(bool wasClosed, string targetName);
    public static void AssertWellFormedEventHubsNamespace(string argumentValue, string argumentName);
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    [NullableContextAttribute("1")]
public static void AssertNull(T value, string name, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.Diagnostics.AzureEventSource : EventSource {
    private static string SharedDataKey;
    private static HashSet`1<string> NamesInUse;
    private static String[] MainEventSourceTraits;
    private static AzureEventSource();
    protected AzureEventSource(string eventSourceName);
    private static string DeduplicateName(string eventSourceName);
}
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    [RequiresUnreferencedCodeAttribute("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddLongAttribute(string name, long value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, object> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(Exception exception);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Shared.MessagingClientDiagnostics : object {
    private string _fullyQualifiedNamespace;
    private string _entityPath;
    private string _messagingSystem;
    private DiagnosticScopeFactory _scopeFactory;
    public static string MessagingSystem;
    public static string DestinationName;
    public static string MessagingOperation;
    public static string ServerAddress;
    public static string BatchCount;
    public static string TraceParent;
    public static string TraceState;
    public static string MessageBusDestination;
    public static string PeerAddress;
    public static string Component;
    public static string DiagnosticIdAttribute;
    public MessagingClientDiagnostics(string clientNamespace, string resourceProviderNamespace, string messagingSystem, string fullyQualifiedNamespace, string entityPath);
    public DiagnosticScope CreateScope(string activityName, ActivityKind kind, MessagingDiagnosticOperation operation);
    [NullableContextAttribute("2")]
public static bool TryExtractTraceContext(IReadOnlyDictionary`2<string, object> properties, String& traceparent, String& tracestate);
    [NullableContextAttribute("2")]
public static bool TryExtractTraceContext(IDictionary`2<string, object> properties, String& traceparent, String& tracestate);
    [NullableContextAttribute("2")]
public void InstrumentMessage(IDictionary`2<string, object> properties, string activityName, String& traceparent, String& tracestate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Shared.MessagingDiagnosticOperation : ValueType {
    private string _operation;
    public static MessagingDiagnosticOperation Publish;
    public static MessagingDiagnosticOperation Receive;
    public static MessagingDiagnosticOperation Process;
    private MessagingDiagnosticOperation(string operation);
    private static MessagingDiagnosticOperation();
    public virtual string ToString();
    public static bool op_Equality(MessagingDiagnosticOperation left, MessagingDiagnosticOperation right);
    public static bool op_Inequality(MessagingDiagnosticOperation left, MessagingDiagnosticOperation right);
    public static MessagingDiagnosticOperation op_Implicit(string value);
    public sealed virtual bool Equals(MessagingDiagnosticOperation other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Azure.Messaging.EventHubs.Authorization.EventHubTokenCredential : TokenCredential {
    private static string DefaultScope;
    private TokenCredential _credential;
    [CompilerGeneratedAttribute]
private bool <IsSharedAccessCredential>k__BackingField;
    public bool IsSharedAccessCredential { get; }
    public EventHubTokenCredential(TokenCredential tokenCredential);
    [CompilerGeneratedAttribute]
public bool get_IsSharedAccessCredential();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public ValueTask`1<AccessToken> GetTokenUsingDefaultScopeAsync(CancellationToken cancellationToken);
}
internal class Azure.Messaging.EventHubs.Authorization.SharedAccessCredential : TokenCredential {
    private static TimeSpan SignatureRefreshBuffer;
    private static TimeSpan SignatureExtensionDuration;
    private AzureNamedKeyCredential _sourceKeyCredential;
    private AzureSasCredential _sourceSasCredential;
    private SharedAccessSignature _sharedAccessSignature;
    public SharedAccessCredential(SharedAccessSignature signature);
    public SharedAccessCredential(AzureSasCredential sourceCredential);
    public SharedAccessCredential(AzureNamedKeyCredential sourceCredential, string signatureResource);
    private static SharedAccessCredential();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    private SharedAccessSignature SafeUpdateSharedAccessSignature(SharedAccessSignature cachedSignature, SharedAccessSignature updatedSignature);
}
internal class Azure.Messaging.EventHubs.Authorization.SharedAccessSignature : object {
    private static int MaximumKeyNameLength;
    private static int MaximumKeyLength;
    private static string AuthenticationTypeToken;
    private static string SignedResourceToken;
    private static string SignatureToken;
    private static string SignedKeyNameToken;
    private static string SignedExpiryToken;
    private static string SignedResourceFullIdentifierToken;
    private static char TokenValueSeparator;
    private static char TokenValuePairDelimiter;
    private static TimeSpan DefaultSignatureValidityDuration;
    private static DateTimeOffset Epoch;
    [CompilerGeneratedAttribute]
private string <SharedAccessKeyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedAccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignatureExpiration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string SharedAccessKeyName { get; private set; }
    public string SharedAccessKey { get; private set; }
    public DateTimeOffset SignatureExpiration { get; private set; }
    public string Resource { get; private set; }
    public string Value { get; private set; }
    public SharedAccessSignature(string eventHubResource, string sharedAccessKeyName, string sharedAccessKey, Nullable`1<TimeSpan> signatureValidityDuration);
    public SharedAccessSignature(string sharedAccessSignature, string sharedAccessKey);
    public SharedAccessSignature(string sharedAccessSignature);
    public SharedAccessSignature(string eventHubResource, string sharedAccessKeyName, string sharedAccessKey, string value, DateTimeOffset signatureExpiration);
    private static SharedAccessSignature();
    [CompilerGeneratedAttribute]
public string get_SharedAccessKeyName();
    [CompilerGeneratedAttribute]
private void set_SharedAccessKeyName(string value);
    [CompilerGeneratedAttribute]
public string get_SharedAccessKey();
    [CompilerGeneratedAttribute]
private void set_SharedAccessKey(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignatureExpiration();
    [CompilerGeneratedAttribute]
private void set_SignatureExpiration(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
private void set_Resource(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    public SharedAccessSignature CloneWithNewExpiration(TimeSpan signatureValidityDuration);
    public virtual string ToString();
    private static ValueTuple`3<string, string, DateTimeOffset> ParseSignature(string sharedAccessSignature);
    private static string BuildSignature(string audience, string sharedAccessKeyName, string sharedAccessKey, DateTimeOffset expirationTime);
    private static DateTimeOffset ConvertFromUnixTime(long unixTime);
    private static long ConvertToUnixTime(DateTimeOffset dateTimeOffset);
}
internal class Azure.Messaging.EventHubs.Core.BasicRetryPolicy : EventHubsRetryPolicy {
    private static int s_randomSeed;
    private static ThreadLocal`1<Random> RandomNumberGenerator;
    private static double MaximumTimeSpanSeconds;
    [CompilerGeneratedAttribute]
private EventHubsRetryOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private double <JitterFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumThrottleSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumThrottleSeconds>k__BackingField;
    public EventHubsRetryOptions Options { get; }
    public double JitterFactor { get; }
    public int MinimumThrottleSeconds { get; }
    public int MaximumThrottleSeconds { get; }
    public BasicRetryPolicy(EventHubsRetryOptions retryOptions);
    private static BasicRetryPolicy();
    [CompilerGeneratedAttribute]
public EventHubsRetryOptions get_Options();
    [CompilerGeneratedAttribute]
public double get_JitterFactor();
    [CompilerGeneratedAttribute]
public int get_MinimumThrottleSeconds();
    [CompilerGeneratedAttribute]
public int get_MaximumThrottleSeconds();
    public virtual TimeSpan CalculateTryTimeout(int attemptCount);
    public virtual Nullable`1<TimeSpan> CalculateRetryDelay(Exception lastException, int attemptCount);
    private static bool ShouldRetryException(Exception exception);
    private static bool IsThrottleException(Exception exception);
    private static TimeSpan CalculateExponentialDelay(int attemptCount, double baseDelaySeconds, double baseJitterSeconds, Random random);
    private static TimeSpan CalculateFixedDelay(double baseDelaySeconds, double baseJitterSeconds, Random random);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.CancellationTokenExtensions : object {
    [ExtensionAttribute]
public static void ThrowIfCancellationRequested(CancellationToken instance);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.EventHubConnectionOptionsExtensions : object {
    [ExtensionAttribute]
public static EventHubConnectionOptions Clone(EventHubConnectionOptions instance);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.EventHubsExceptionExtensions : object {
    private static string FailureDataKey;
    private static string FailureOperationKey;
    [ExtensionAttribute]
public static T GetFailureData(EventHubsException instance);
    [ExtensionAttribute]
public static string GetFailureOperation(EventHubsException instance);
    [ExtensionAttribute]
public static void SetFailureData(EventHubsException instance, T data);
    [ExtensionAttribute]
public static void SetFailureOperation(EventHubsException instance, string operationName);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.EventHubsRetryOptionsExtensions : object {
    [ExtensionAttribute]
public static EventHubsRetryOptions Clone(EventHubsRetryOptions instance);
    [ExtensionAttribute]
public static EventHubsRetryPolicy ToRetryPolicy(EventHubsRetryOptions instance);
    [ExtensionAttribute]
public static bool IsEquivalentTo(EventHubsRetryOptions instance, EventHubsRetryOptions other);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.TimeSpanExtensions : object {
    [ExtensionAttribute]
public static TimeSpan CalculateRemaining(TimeSpan instance, TimeSpan elapsed);
}
internal static class Azure.Messaging.EventHubs.Diagnostics.DiagnosticProperty : object {
    public static string DiagnosticNamespace;
    public static string ResourceProviderNamespace;
    public static string EnqueuedTimeAttribute;
    public static string EventHubsServiceContext;
    public static string KindAttribute;
    public static string ProducerKind;
    public static string ClientKind;
    public static string ConsumerKind;
    [CompilerGeneratedAttribute]
private static string <EventActivityName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProducerActivityName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <EventProcessorProcessingActivityName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <EventProcessorCheckpointActivityName>k__BackingField;
    public static string EventActivityName { get; }
    public static string ProducerActivityName { get; }
    public static string EventProcessorProcessingActivityName { get; }
    public static string EventProcessorCheckpointActivityName { get; }
    private static DiagnosticProperty();
    [CompilerGeneratedAttribute]
public static string get_EventActivityName();
    [CompilerGeneratedAttribute]
public static string get_ProducerActivityName();
    [CompilerGeneratedAttribute]
public static string get_EventProcessorProcessingActivityName();
    [CompilerGeneratedAttribute]
public static string get_EventProcessorCheckpointActivityName();
}
[EventSourceAttribute]
internal class Azure.Messaging.EventHubs.Diagnostics.PartitionLoadBalancerEventSource : AzureEventSource {
    private static string EventSourceName;
    [CompilerGeneratedAttribute]
private static PartitionLoadBalancerEventSource <Log>k__BackingField;
    public static PartitionLoadBalancerEventSource Log { get; }
    private static PartitionLoadBalancerEventSource();
    [CompilerGeneratedAttribute]
public static PartitionLoadBalancerEventSource get_Log();
    [EventAttribute("1")]
public virtual void MinimumPartitionsPerEventProcessor(int count);
    [EventAttribute("2")]
public virtual void CurrentOwnershipCount(int count, string identifier);
    [EventAttribute("3")]
public virtual void UnclaimedPartitions(HashSet`1<string> unclaimedPartitions);
    [EventAttribute("4")]
public virtual void ClaimOwnershipStart(string partitionId);
    [EventAttribute("5")]
public virtual void ClaimOwnershipError(string partitionId, string errorMessage);
    [EventAttribute("6")]
public virtual void ShouldStealPartition(string identifier);
    [EventAttribute("7")]
public virtual void StealPartition(string partitionId, string stolenFrom, string identifier);
    [EventAttribute("8")]
public virtual void RenewOwnershipStart(string identifier);
    [EventAttribute("9")]
public virtual void RenewOwnershipError(string identifier, string errorMessage);
    [EventAttribute("10")]
public virtual void RenewOwnershipComplete(string identifier);
}
public class Azure.Messaging.EventHubs.EventProcessorClient : EventProcessor`1<EventProcessorPartition> {
    private static Func`2<CancellationToken, Task> EmptyEventUpdateCheckpoint;
    private static EventProcessorClientOptions DefaultClientOptions;
    private EventPosition DefaultStartingPosition;
    private ConcurrentDictionary`2<string, EventPosition> PartitionStartingPositionDefaults;
    private SemaphoreSlim ProcessorStatusGuard;
    private BlobContainerClient _containerClient;
    private Func`2<PartitionInitializingEventArgs, Task> _partitionInitializingAsync;
    private Func`2<PartitionClosingEventArgs, Task> _partitionClosingAsync;
    private Func`2<ProcessEventArgs, Task> _processEventAsync;
    private Func`2<ProcessErrorEventArgs, Task> _processErrorAsync;
    [CompilerGeneratedAttribute]
private EventProcessorClientEventSource <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagingClientDiagnostics <ClientDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckpointStore <CheckpointStore>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string ConsumerGroup { get; }
    public bool IsRunning { get; protected set; }
    public string Identifier { get; }
    internal EventProcessorClientEventSource Logger { get; internal set; }
    internal MessagingClientDiagnostics ClientDiagnostics { get; }
    private CheckpointStore CheckpointStore { get; }
    public EventProcessorClient(BlobContainerClient checkpointStore, string consumerGroup, string connectionString);
    public EventProcessorClient(BlobContainerClient checkpointStore, string consumerGroup, string connectionString, EventProcessorClientOptions clientOptions);
    public EventProcessorClient(BlobContainerClient checkpointStore, string consumerGroup, string connectionString, string eventHubName);
    public EventProcessorClient(BlobContainerClient checkpointStore, string consumerGroup, string connectionString, string eventHubName, EventProcessorClientOptions clientOptions);
    public EventProcessorClient(BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, AzureNamedKeyCredential credential, EventProcessorClientOptions clientOptions);
    public EventProcessorClient(BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, AzureSasCredential credential, EventProcessorClientOptions clientOptions);
    public EventProcessorClient(BlobContainerClient checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventProcessorClientOptions clientOptions);
    internal EventProcessorClient(CheckpointStore checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, int cacheEventCount, TokenCredential credential, EventProcessorOptions clientOptions);
    internal EventProcessorClient(CheckpointStore checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, int cacheEventCount, AzureNamedKeyCredential credential, EventProcessorOptions clientOptions);
    internal EventProcessorClient(CheckpointStore checkpointStore, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, int cacheEventCount, AzureSasCredential credential, EventProcessorOptions clientOptions);
    private static EventProcessorClient();
    public void add_PartitionInitializingAsync(Func`2<PartitionInitializingEventArgs, Task> value);
    public void remove_PartitionInitializingAsync(Func`2<PartitionInitializingEventArgs, Task> value);
    public void add_PartitionClosingAsync(Func`2<PartitionClosingEventArgs, Task> value);
    public void remove_PartitionClosingAsync(Func`2<PartitionClosingEventArgs, Task> value);
    public void add_ProcessEventAsync(Func`2<ProcessEventArgs, Task> value);
    public void remove_ProcessEventAsync(Func`2<ProcessEventArgs, Task> value);
    public void add_ProcessErrorAsync(Func`2<ProcessErrorEventArgs, Task> value);
    public void remove_ProcessErrorAsync(Func`2<ProcessErrorEventArgs, Task> value);
    public string get_FullyQualifiedNamespace();
    public string get_EventHubName();
    public string get_ConsumerGroup();
    public bool get_IsRunning();
    protected void set_IsRunning(bool value);
    public string get_Identifier();
    [CompilerGeneratedAttribute]
internal EventProcessorClientEventSource get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(EventProcessorClientEventSource value);
    [CompilerGeneratedAttribute]
internal MessagingClientDiagnostics get_ClientDiagnostics();
    [CompilerGeneratedAttribute]
private CheckpointStore get_CheckpointStore();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<StartProcessingAsync>d__54")]
public virtual Task StartProcessingAsync(CancellationToken cancellationToken);
    public virtual void StartProcessing(CancellationToken cancellationToken);
    public virtual Task StopProcessingAsync(CancellationToken cancellationToken);
    public virtual void StopProcessing(CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<ValidateStoragePermissionsAsync>d__61")]
internal Task ValidateStoragePermissionsAsync(BlobContainerClient containerClient, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<ValidateProcessingPreconditions>d__62")]
protected virtual Task ValidateProcessingPreconditions(CancellationToken cancellationToken);
    protected virtual Task UpdateCheckpointAsync(string partitionId, long offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    protected virtual Task UpdateCheckpointAsync(string partitionId, CheckpointPosition startingPosition, CancellationToken cancellationToken);
    protected virtual EventHubConnection CreateConnection();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<GetCheckpointAsync>d__66")]
protected virtual Task`1<EventProcessorCheckpoint> GetCheckpointAsync(string partitionId, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ListOwnershipAsync(CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<OnProcessingEventBatchAsync>d__69")]
protected virtual Task OnProcessingEventBatchAsync(IEnumerable`1<EventData> events, EventProcessorPartition partition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<OnProcessingErrorAsync>d__70")]
protected virtual Task OnProcessingErrorAsync(Exception exception, EventProcessorPartition partition, string operationDescription, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<OnInitializingPartitionAsync>d__71")]
protected virtual Task OnInitializingPartitionAsync(EventProcessorPartition partition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<OnPartitionProcessingStoppedAsync>d__72")]
protected virtual Task OnPartitionProcessingStoppedAsync(EventProcessorPartition partition, ProcessingStoppedReason reason, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventProcessorClient/<StartProcessingInternalAsync>d__73")]
private Task StartProcessingInternalAsync(bool async, CancellationToken cancellationToken);
    private EventProcessorCheckpoint CreateCheckpointWithDefaultStartingPosition(string partitionId);
    private void EnsureNotRunningAndInvoke(Action action);
    private DiagnosticScope StartProcessorScope(EventData eventData);
    private static EventProcessorOptions CreateOptions(EventProcessorClientOptions clientOptions);
    [CompilerGeneratedAttribute]
private void <remove_PartitionInitializingAsync>b__12_0();
    [CompilerGeneratedAttribute]
private void <remove_PartitionClosingAsync>b__15_0();
    [CompilerGeneratedAttribute]
private void <remove_ProcessEventAsync>b__18_0();
    [CompilerGeneratedAttribute]
private void <remove_ProcessErrorAsync>b__21_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__2(CancellationToken cancellationToken);
}
public class Azure.Messaging.EventHubs.EventProcessorClientOptions : object {
    private Nullable`1<TimeSpan> _maximumWaitTime;
    private int _cacheEventCount;
    private int _prefetchCount;
    private Nullable`1<long> _prefetchSizeInBytes;
    private TimeSpan _loadBalancingUpdateInterval;
    private TimeSpan _partitionOwnershipExpirationInterval;
    private EventHubConnectionOptions _connectionOptions;
    private EventHubsRetryOptions _retryOptions;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackLastEnqueuedEventProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadBalancingStrategy <LoadBalancingStrategy>k__BackingField;
    public string Identifier { get; public set; }
    public bool TrackLastEnqueuedEventProperties { get; public set; }
    public LoadBalancingStrategy LoadBalancingStrategy { get; public set; }
    public Nullable`1<TimeSpan> MaximumWaitTime { get; public set; }
    public int CacheEventCount { get; public set; }
    public int PrefetchCount { get; public set; }
    public Nullable`1<long> PrefetchSizeInBytes { get; public set; }
    public TimeSpan LoadBalancingUpdateInterval { get; public set; }
    public TimeSpan PartitionOwnershipExpirationInterval { get; public set; }
    public EventHubConnectionOptions ConnectionOptions { get; public set; }
    public EventHubsRetryOptions RetryOptions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public bool get_TrackLastEnqueuedEventProperties();
    [CompilerGeneratedAttribute]
public void set_TrackLastEnqueuedEventProperties(bool value);
    [CompilerGeneratedAttribute]
public LoadBalancingStrategy get_LoadBalancingStrategy();
    [CompilerGeneratedAttribute]
public void set_LoadBalancingStrategy(LoadBalancingStrategy value);
    public Nullable`1<TimeSpan> get_MaximumWaitTime();
    public void set_MaximumWaitTime(Nullable`1<TimeSpan> value);
    public int get_CacheEventCount();
    public void set_CacheEventCount(int value);
    public int get_PrefetchCount();
    public void set_PrefetchCount(int value);
    public Nullable`1<long> get_PrefetchSizeInBytes();
    public void set_PrefetchSizeInBytes(Nullable`1<long> value);
    public TimeSpan get_LoadBalancingUpdateInterval();
    public void set_LoadBalancingUpdateInterval(TimeSpan value);
    public TimeSpan get_PartitionOwnershipExpirationInterval();
    public void set_PartitionOwnershipExpirationInterval(TimeSpan value);
    public EventHubConnectionOptions get_ConnectionOptions();
    public void set_ConnectionOptions(EventHubConnectionOptions value);
    public EventHubsRetryOptions get_RetryOptions();
    public void set_RetryOptions(EventHubsRetryOptions value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal EventProcessorClientOptions Clone();
}
public class Azure.Messaging.EventHubs.Primitives.BlobCheckpointStore : CheckpointStore {
    private CheckpointStore _checkpointStoreImplementation;
    public BlobCheckpointStore(BlobContainerClient blobContainerClient);
    internal BlobCheckpointStore(CheckpointStore checkpointStore);
    public virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ListOwnershipAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken);
    public virtual Task`1<EventProcessorCheckpoint> GetCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, CancellationToken cancellationToken);
    public virtual Task UpdateCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, long offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    public virtual Task UpdateCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string clientIdentifier, CheckpointPosition startingPosition, CancellationToken cancellationToken);
}
internal class Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal : CheckpointStore {
    [CompilerGeneratedAttribute]
private BlobEventStoreEventSource <Logger>k__BackingField;
    private static string BlobsResourceDoesNotExist;
    private static ETag IfNoneMatchAllTag;
    private static string CheckpointPrefix;
    private static string FunctionsLegacyCheckpointPrefix;
    private static string OwnershipPrefix;
    [CompilerGeneratedAttribute]
private BlobContainerClient <ContainerClient>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InitializeWithLegacyCheckpoints>k__BackingField;
    internal BlobEventStoreEventSource Logger { get; internal set; }
    private BlobContainerClient ContainerClient { get; }
    private bool InitializeWithLegacyCheckpoints { get; }
    private static BlobCheckpointStoreInternal();
    public BlobCheckpointStoreInternal(BlobContainerClient blobContainerClient);
    internal BlobCheckpointStoreInternal(BlobContainerClient blobContainerClient, bool initializeWithLegacyCheckpoints);
    [CompilerGeneratedAttribute]
internal BlobEventStoreEventSource get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(BlobEventStoreEventSource value);
    [CompilerGeneratedAttribute]
private BlobContainerClient get_ContainerClient();
    [CompilerGeneratedAttribute]
private bool get_InitializeWithLegacyCheckpoints();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<ListOwnershipAsync>d__18")]
public virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ListOwnershipAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<ClaimOwnershipAsync>d__19")]
public virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<GetCheckpointAsync>d__20")]
public virtual Task`1<EventProcessorCheckpoint> GetCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<UpdateCheckpointAsync>d__21")]
public virtual Task UpdateCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, long offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<UpdateCheckpointAsync>d__22")]
public virtual Task UpdateCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string clientIdentifier, CheckpointPosition startingPosition, CancellationToken cancellationToken);
    internal string GetCheckpointBlobName(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<UpdateCheckpointInternalAsync>d__24")]
private Task UpdateCheckpointInternalAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string clientIdentifier, Nullable`1<long> offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    private EventProcessorCheckpoint CreateCheckpoint(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, IDictionary`2<string, string> metadata, DateTimeOffset modifiedDate);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.BlobCheckpointStoreInternal/<CreateLegacyCheckpoint>d__26")]
private Task`1<EventProcessorCheckpoint> CreateLegacyCheckpoint(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string blobName, string partitionId, CancellationToken cancellationToken);
    private static bool TryReadLegacyCheckpoint(Span`1<byte> data, Nullable`1& offset, Nullable`1& sequenceNumber);
    private void ListOwnershipComplete(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, int ownershipCount);
    private void ListOwnershipError(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, Exception exception);
    private void ListOwnershipStart(string fullyQualifiedNamespace, string eventHubName, string consumerGroup);
    private void GetCheckpointStart(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId);
    private void GetCheckpointComplete(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string clientIdentifier, DateTimeOffset lastModified);
    private void GetCheckpointError(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, Exception exception);
    private void InvalidCheckpointFound(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup);
    private void UpdateCheckpointError(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string clientIdentifier, string sequenceNumber, string replicationSegment, string offset, Exception exception);
    private void UpdateCheckpointComplete(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string clientIdentifier, string sequenceNumber, string replicationSegment, string offset);
    private void UpdateCheckpointStart(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string clientIdentifier, string sequenceNumber, string replicationSegment, string offset);
    private void ClaimOwnershipComplete(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier);
    private void ClaimOwnershipError(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier, Exception exception);
    private void OwnershipNotClaimable(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier, string message);
    private void OwnershipClaimed(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier);
    private void ClaimOwnershipStart(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier);
    private void BlobsCheckpointStoreCreated(string typeName, string accountName, string containerName);
}
internal static class Azure.Messaging.EventHubs.Primitives.BlobMetadataKey : object {
    public static string OwnerIdentifier;
    public static string Offset;
    public static string SequenceNumber;
    public static string ClientIdentifier;
}
internal class Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer : object {
    private static ThreadLocal`1<Random> RandomNumberGenerator;
    private static int s_randomSeed;
    private CheckpointStore CheckpointStore;
    private Dictionary`2<string, List`1<EventProcessorPartitionOwnership>> ActiveOwnershipWithDistribution;
    [CompilerGeneratedAttribute]
private string <FullyQualifiedNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <OwnershipExpirationInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LoadBalanceInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBalanced>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionLoadBalancerEventSource <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, EventProcessorPartitionOwnership> <InstanceOwnership>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string ConsumerGroup { get; }
    public string OwnerIdentifier { get; }
    public TimeSpan OwnershipExpirationInterval { get; }
    public TimeSpan LoadBalanceInterval { get; internal set; }
    public bool IsBalanced { get; private set; }
    public IEnumerable`1<string> OwnedPartitionIds { get; }
    public int OwnedPartitionCount { get; }
    internal PartitionLoadBalancerEventSource Logger { get; internal set; }
    private ConcurrentDictionary`2<string, EventProcessorPartitionOwnership> InstanceOwnership { get; private set; }
    public PartitionLoadBalancer(CheckpointStore checkpointStore, string identifier, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, TimeSpan ownershipExpirationInterval, TimeSpan loadBalancingInterval);
    private static PartitionLoadBalancer();
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public string get_OwnerIdentifier();
    [CompilerGeneratedAttribute]
public TimeSpan get_OwnershipExpirationInterval();
    [CompilerGeneratedAttribute]
public TimeSpan get_LoadBalanceInterval();
    [CompilerGeneratedAttribute]
internal void set_LoadBalanceInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsBalanced();
    [CompilerGeneratedAttribute]
private void set_IsBalanced(bool value);
    public virtual IEnumerable`1<string> get_OwnedPartitionIds();
    public virtual int get_OwnedPartitionCount();
    [CompilerGeneratedAttribute]
internal PartitionLoadBalancerEventSource get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(PartitionLoadBalancerEventSource value);
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, EventProcessorPartitionOwnership> get_InstanceOwnership();
    [CompilerGeneratedAttribute]
private void set_InstanceOwnership(ConcurrentDictionary`2<string, EventProcessorPartitionOwnership> value);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer/<RunLoadBalancingAsync>d__41")]
public virtual ValueTask`1<EventProcessorPartitionOwnership> RunLoadBalancingAsync(String[] partitionIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer/<RelinquishOwnershipAsync>d__42")]
public virtual Task RelinquishOwnershipAsync(CancellationToken cancellationToken);
    public virtual void ReportPartitionStolen(string partitionId);
    public virtual bool IsPartitionOwned(string partitionId);
    private ValueTask`1<ValueTuple`2<bool, EventProcessorPartitionOwnership>> FindAndClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> completeOwnershipEnumerable, HashSet`1<string> unclaimedPartitions, int partitionCount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer/<RenewOwnershipAsync>d__46")]
private Task RenewOwnershipAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer/<ClaimOwnershipAsync>d__47")]
private Task`1<ValueTuple`2<bool, EventProcessorPartitionOwnership>> ClaimOwnershipAsync(string partitionId, IEnumerable`1<EventProcessorPartitionOwnership> completeOwnershipEnumerable, CancellationToken cancellationToken);
    internal virtual DateTimeOffset GetDateTimeOffsetNow();
}
[EventSourceAttribute]
internal class Azure.Messaging.EventHubs.Processor.Diagnostics.BlobEventStoreEventSource : AzureEventSource {
    private static string EventSourceName;
    [CompilerGeneratedAttribute]
private static BlobEventStoreEventSource <Log>k__BackingField;
    public static BlobEventStoreEventSource Log { get; }
    private static BlobEventStoreEventSource();
    [CompilerGeneratedAttribute]
public static BlobEventStoreEventSource get_Log();
    [EventAttribute("20")]
public virtual void BlobsCheckpointStoreCreated(string typeName, string accountName, string containerName);
    [EventAttribute("21")]
public virtual void ListOwnershipStart(string fullyQualifiedNamespace, string eventHubName, string consumerGroup);
    [EventAttribute("22")]
public virtual void ListOwnershipComplete(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, int ownershipCount);
    [EventAttribute("23")]
public virtual void ListOwnershipError(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("24")]
public virtual void ClaimOwnershipStart(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier);
    [EventAttribute("25")]
public virtual void ClaimOwnershipComplete(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier);
    [EventAttribute("26")]
public virtual void ClaimOwnershipError(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier, string errorMessage);
    [EventAttribute("27")]
public virtual void OwnershipNotClaimable(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier, string message);
    [EventAttribute("28")]
public virtual void OwnershipClaimed(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string ownerIdentifier);
    [EventAttribute("32")]
public virtual void UpdateCheckpointStart(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string clientIdentifier, string sequenceNumber, string replicationSegment, string offset);
    [EventAttribute("33")]
public virtual void UpdateCheckpointComplete(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string clientIdentifier, string sequenceNumber, string replicationSegment, string offset);
    [EventAttribute("34")]
public virtual void UpdateCheckpointError(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string clientIdentifier, string errorMessage, string sequenceNumber, string replicationSegment, string offset);
    [EventAttribute("35")]
public virtual void InvalidCheckpointFound(string partitionId, string fullyQualifiedNamespace, string eventHubName, string consumerGroup);
    [EventAttribute("36")]
public virtual void GetCheckpointStart(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId);
    [EventAttribute("37")]
public virtual void GetCheckpointComplete(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string clientIdentifier, DateTimeOffset lastModified);
    [EventAttribute("38")]
public virtual void GetCheckpointError(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string errorMessage);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, TValue1 arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, TValue1 arg6);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6, string arg7, string arg8);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6, string arg7, string arg8, string arg9);
}
[EventSourceAttribute]
internal class Azure.Messaging.EventHubs.Processor.Diagnostics.EventProcessorClientEventSource : AzureEventSource {
    private static string EventSourceName;
    [CompilerGeneratedAttribute]
private static EventProcessorClientEventSource <Log>k__BackingField;
    public static EventProcessorClientEventSource Log { get; }
    private static EventProcessorClientEventSource();
    [CompilerGeneratedAttribute]
public static EventProcessorClientEventSource get_Log();
    [EventAttribute("20")]
public virtual void EventBatchProcessingStart(string partitionId, string identifier, string eventHubName, string consumerGroup, string operationId);
    [EventAttribute("21")]
public virtual void EventBatchProcessingComplete(string partitionId, string identifier, string eventHubName, string consumerGroup, string operationId);
    [EventAttribute("22")]
public virtual void EventBatchProcessingError(string partitionId, string identifier, string eventHubName, string consumerGroup, string errorMessage, string operationId);
    [EventAttribute("23")]
public virtual void UpdateCheckpointStart(string partitionId, string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("24")]
public virtual void UpdateCheckpointComplete(string partitionId, string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("25")]
public virtual void UpdateCheckpointError(string partitionId, string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("26")]
public virtual void ValidationCleanupError(string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("27")]
public virtual void EventBatchProcessingHandlerCall(string sequenceNumber, string partitionId, string identifier, string eventHubName, string consumerGroup, string operationId);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Azure.Messaging.EventHubs.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotParseIntegerType { get; }
    internal static string CannotSendWithPartitionIdAndPartitionKey { get; }
    internal static string CannotStartEventProcessorWithoutHandler { get; }
    internal static string ClientNeededForThisInformationNotAvailable { get; }
    internal static string ClosedConnectionCannotPerformOperation { get; }
    internal static string ClosedInstanceCannotPerformOperation { get; }
    internal static string ConsumerIdentifierOverMaxValue { get; }
    internal static string CouldNotAcquireAccessToken { get; }
    internal static string CouldNotCreateLink { get; }
    internal static string DeveloperCodeEventProcessingError { get; }
    internal static string DeveloperCodeError { get; }
    internal static string DeveloperCodeExceptionMessageMask { get; }
    internal static string EventBatchIsLocked { get; }
    internal static string FailedToCreateReader { get; }
    internal static string FailedToSerializeUnsupportedType { get; }
    internal static string InvalidConnectionString { get; }
    internal static string InvalidEncoding { get; }
    internal static string InvalidEventPositionForFilter { get; }
    internal static string InvalidFullyQualifiedNamespace { get; }
    internal static string InvalidMessageBody { get; }
    internal static string InvalidSharedAccessSignature { get; }
    internal static string InvalidEndpointAddress { get; }
    internal static string InvalidTimePeriod { get; }
    internal static string InvalidTransportType { get; }
    internal static string MessageSizeExceeded { get; }
    internal static string MissingConnectionInformation { get; }
    internal static string OnlyOneEventHubNameMayBeSpecified { get; }
    internal static string ProxyMustUseWebSockets { get; }
    internal static string ResourceMustMatchSharedAccessSignature { get; }
    internal static string RetryOptionsMustBeSet { get; }
    internal static string RunningEventProcessorCannotPerformOperation { get; }
    internal static string SharedAccessKeyIsRequired { get; }
    internal static string SharedKeyCredentialCannotGenerateTokens { get; }
    internal static string TimeoutMustBePositive { get; }
    internal static string TimeSpanMustBeNonNegative { get; }
    internal static string TrackLastEnqueuedEventPropertiesNotSet { get; }
    internal static string UnknownCommunicationException { get; }
    internal static string UnknownConnectionType { get; }
    internal static string UnknownRetryMode { get; }
    internal static string UnrecoverableException { get; }
    internal static string UnsupportedCredential { get; }
    internal static string UnsupportedTransportEventType { get; }
    internal static string ValueMustBeAtLeast { get; }
    internal static string ValueOutOfRange { get; }
    internal static string BlobsResourceDoesNotExist { get; }
    internal static string CannotCreateCheckpointForEmptyEvent { get; }
    internal static string HandlerHasAlreadyBeenAssigned { get; }
    internal static string HandlerHasNotBeenAssigned { get; }
    internal static string OperationEventProcessingDeveloperCode { get; }
    internal static string OperationListOwnership { get; }
    internal static string OperationGetPartitionIds { get; }
    internal static string OperationListCheckpoints { get; }
    internal static string OperationLoadBalancing { get; }
    internal static string OperationClaimOwnership { get; }
    internal static string OperationRenewOwnership { get; }
    internal static string OperationReadEvents { get; }
    internal static string OperationEventProcessingLoop { get; }
    internal static string OperationSurrenderOwnership { get; }
    internal static string CannotReadLastEnqueuedEventPropertiesWithoutEvent { get; }
    internal static string AggregateEventProcessingExceptionMessage { get; }
    internal static string OnlyOneSharedAccessAuthorizationMayBeSpecified { get; }
    internal static string CannotPublishToGateway { get; }
    internal static string IdempotentAlreadyPublished { get; }
    internal static string ListCheckpointsAsyncObsolete { get; }
    internal static string UnknownAmqpBodyType { get; }
    internal static string RawAmqpBodyTypeMask { get; }
    internal static string DictionaryKeyNotFoundMask { get; }
    internal static string InvalidAmqpMessageValueBodyMask { get; }
    internal static string InvalidAmqpMessageDictionaryTypeMask { get; }
    internal static string CannotChangeHandlersWhenPublishing { get; }
    internal static string ProcessorLoadBalancingCycleSlowMask { get; }
    internal static string ProcessorLoadBalancingIntervalsTooCloseMask { get; }
    internal static string ProcessorLoadBalancingFatalErrorMask { get; }
    internal static string CannotEnqueueEventWithoutHandler { get; }
    internal static string CannotSendToUknownPartition { get; }
    internal static string EventTooLargeMask { get; }
    internal static string TroubleshootingGuideLink { get; }
    internal static string BufferedProducerStartupTimeout { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotParseIntegerType();
    internal static string get_CannotSendWithPartitionIdAndPartitionKey();
    internal static string get_CannotStartEventProcessorWithoutHandler();
    internal static string get_ClientNeededForThisInformationNotAvailable();
    internal static string get_ClosedConnectionCannotPerformOperation();
    internal static string get_ClosedInstanceCannotPerformOperation();
    internal static string get_ConsumerIdentifierOverMaxValue();
    internal static string get_CouldNotAcquireAccessToken();
    internal static string get_CouldNotCreateLink();
    internal static string get_DeveloperCodeEventProcessingError();
    internal static string get_DeveloperCodeError();
    internal static string get_DeveloperCodeExceptionMessageMask();
    internal static string get_EventBatchIsLocked();
    internal static string get_FailedToCreateReader();
    internal static string get_FailedToSerializeUnsupportedType();
    internal static string get_InvalidConnectionString();
    internal static string get_InvalidEncoding();
    internal static string get_InvalidEventPositionForFilter();
    internal static string get_InvalidFullyQualifiedNamespace();
    internal static string get_InvalidMessageBody();
    internal static string get_InvalidSharedAccessSignature();
    internal static string get_InvalidEndpointAddress();
    internal static string get_InvalidTimePeriod();
    internal static string get_InvalidTransportType();
    internal static string get_MessageSizeExceeded();
    internal static string get_MissingConnectionInformation();
    internal static string get_OnlyOneEventHubNameMayBeSpecified();
    internal static string get_ProxyMustUseWebSockets();
    internal static string get_ResourceMustMatchSharedAccessSignature();
    internal static string get_RetryOptionsMustBeSet();
    internal static string get_RunningEventProcessorCannotPerformOperation();
    internal static string get_SharedAccessKeyIsRequired();
    internal static string get_SharedKeyCredentialCannotGenerateTokens();
    internal static string get_TimeoutMustBePositive();
    internal static string get_TimeSpanMustBeNonNegative();
    internal static string get_TrackLastEnqueuedEventPropertiesNotSet();
    internal static string get_UnknownCommunicationException();
    internal static string get_UnknownConnectionType();
    internal static string get_UnknownRetryMode();
    internal static string get_UnrecoverableException();
    internal static string get_UnsupportedCredential();
    internal static string get_UnsupportedTransportEventType();
    internal static string get_ValueMustBeAtLeast();
    internal static string get_ValueOutOfRange();
    internal static string get_BlobsResourceDoesNotExist();
    internal static string get_CannotCreateCheckpointForEmptyEvent();
    internal static string get_HandlerHasAlreadyBeenAssigned();
    internal static string get_HandlerHasNotBeenAssigned();
    internal static string get_OperationEventProcessingDeveloperCode();
    internal static string get_OperationListOwnership();
    internal static string get_OperationGetPartitionIds();
    internal static string get_OperationListCheckpoints();
    internal static string get_OperationLoadBalancing();
    internal static string get_OperationClaimOwnership();
    internal static string get_OperationRenewOwnership();
    internal static string get_OperationReadEvents();
    internal static string get_OperationEventProcessingLoop();
    internal static string get_OperationSurrenderOwnership();
    internal static string get_CannotReadLastEnqueuedEventPropertiesWithoutEvent();
    internal static string get_AggregateEventProcessingExceptionMessage();
    internal static string get_OnlyOneSharedAccessAuthorizationMayBeSpecified();
    internal static string get_CannotPublishToGateway();
    internal static string get_IdempotentAlreadyPublished();
    internal static string get_ListCheckpointsAsyncObsolete();
    internal static string get_UnknownAmqpBodyType();
    internal static string get_RawAmqpBodyTypeMask();
    internal static string get_DictionaryKeyNotFoundMask();
    internal static string get_InvalidAmqpMessageValueBodyMask();
    internal static string get_InvalidAmqpMessageDictionaryTypeMask();
    internal static string get_CannotChangeHandlersWhenPublishing();
    internal static string get_ProcessorLoadBalancingCycleSlowMask();
    internal static string get_ProcessorLoadBalancingIntervalsTooCloseMask();
    internal static string get_ProcessorLoadBalancingFatalErrorMask();
    internal static string get_CannotEnqueueEventWithoutHandler();
    internal static string get_CannotSendToUknownPartition();
    internal static string get_EventTooLargeMask();
    internal static string get_TroubleshootingGuideLink();
    internal static string get_BufferedProducerStartupTimeout();
}
internal static class Azure.Messaging.EventHubs.ResourcesNamespace : object {
    public static string Current;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
