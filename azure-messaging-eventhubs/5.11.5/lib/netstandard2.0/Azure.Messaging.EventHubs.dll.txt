internal abstract class Azure.Core.Amqp.MessageBody : object {
    protected ReadOnlyMemory`1<byte> WrittenMemory { get; }
    [NullableContextAttribute("1")]
public static MessageBody FromReadOnlyMemorySegments(IEnumerable`1<ReadOnlyMemory`1<byte>> segments);
    public static MessageBody FromReadOnlyMemorySegment(ReadOnlyMemory`1<byte> segment);
    [NullableContextAttribute("1")]
public static MessageBody FromDataSegments(IEnumerable`1<Data> segments);
    protected abstract virtual ReadOnlyMemory`1<byte> get_WrittenMemory();
    public abstract virtual IEnumerator`1<ReadOnlyMemory`1<byte>> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static ReadOnlyMemory`1<byte> op_Implicit(MessageBody memory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.Amqp.Shared.AmqpAnnotatedMessageConverter : object {
    private static int StreamBufferSizeInBytes;
    private static IReadOnlyDictionary`2<Type, AmqpType> AmqpPropertyTypeMap;
    private static AmqpAnnotatedMessageConverter();
    public static AmqpMessage ToAmqpMessage(AmqpAnnotatedMessage sourceMessage);
    public static AmqpAnnotatedMessage FromAmqpMessage(AmqpMessage source);
    [NullableContextAttribute("2")]
public static bool TryCreateAmqpPropertyValueFromNetProperty(object propertyValue, Object& amqpPropertyValue, bool allowBodyTypes);
    [NullableContextAttribute("2")]
public static bool TryCreateNetPropertyFromAmqpProperty(object amqpPropertyValue, Object& convertedPropertyValue, bool allowBodyTypes);
    [IteratorStateMachineAttribute("Azure.Core.Amqp.Shared.AmqpAnnotatedMessageConverter/<TranslateDataBody>d__6")]
private static IEnumerable`1<Data> TranslateDataBody(IEnumerable`1<ReadOnlyMemory`1<byte>> dataBody);
    [IteratorStateMachineAttribute("Azure.Core.Amqp.Shared.AmqpAnnotatedMessageConverter/<TranslateSequenceBody>d__7")]
private static IEnumerable`1<AmqpSequence> TranslateSequenceBody(IEnumerable`1<IList`1<object>> sequenceBody);
    private static AmqpValue TranslateValueBody(object valueBody);
    private static bool TryGetDataBody(AmqpMessage source, AmqpMessageBody& dataBody);
    private static bool TryGetSequenceBody(AmqpMessage source, AmqpMessageBody& sequenceBody);
    private static bool TryGetValueBody(AmqpMessage source, AmqpMessageBody& valueBody);
    private static void ThrowSerializationFailed(string propertyName, KeyValuePair`2<string, object> pair);
    [NullableContextAttribute("2")]
private static AmqpType GetTypeIdentifier(object value);
    private static object TranslateSymbol(AmqpSymbol symbol, object value);
    [NullableContextAttribute("0")]
private static ArraySegment`1<byte> ReadStreamToArraySegment(Stream stream);
    [NullableContextAttribute("2")]
public static AmqpType ToAmqpPropertyType(Type type);
}
internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
internal static class Azure.Core.Argument : object {
    public static void AssertNotEmptyOrWhiteSpace(string argumentValue, string argumentName);
    public static void AssertNotTooLong(string argumentValue, int maximumLength, string argumentName);
    public static void AssertNotNegative(TimeSpan argumentValue, string argumentName);
    public static void AssertAtLeast(long argumentValue, long minimumValue, string argumentName);
    public static void AssertAtLeast(int argumentValue, int minimumValue, string argumentName);
    public static void AssertNotDisposed(bool wasDisposed, string targetName);
    public static void AssertNotClosed(bool wasClosed, string targetName);
    public static void AssertWellFormedEventHubsNamespace(string argumentValue, string argumentName);
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    [NullableContextAttribute("1")]
public static void AssertNull(T value, string name, string message);
}
internal class Azure.Core.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private static int DefaultInitialBufferSize;
    [CompilerGeneratedAttribute]
private int <WrittenCount>k__BackingField;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; private set; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    [CompilerGeneratedAttribute]
public int get_WrittenCount();
    [CompilerGeneratedAttribute]
private void set_WrittenCount(int value);
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.Diagnostics.AzureEventSource : EventSource {
    private static string SharedDataKey;
    private static HashSet`1<string> NamesInUse;
    private static String[] MainEventSourceTraits;
    private static AzureEventSource();
    protected AzureEventSource(string eventSourceName);
    private static string DeduplicateName(string eventSourceName);
}
internal class Azure.Core.Diagnostics.ValueStopwatch : ValueType {
    private static double TimestampToTicks;
    private long _startTimestamp;
    public bool IsActive { get; }
    private ValueStopwatch(long startTimestamp);
    private static ValueStopwatch();
    public bool get_IsActive();
    public static ValueStopwatch StartNew();
    public TimeSpan GetElapsedTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.HashCodeBuilder : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCodeBuilder();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    public static UInt32 RotateLeft(UInt32 value, int offset);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    [RequiresUnreferencedCodeAttribute("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddLongAttribute(string name, long value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, object> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(Exception exception);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Shared.MessagingClientDiagnostics : object {
    private string _fullyQualifiedNamespace;
    private string _entityPath;
    private string _messagingSystem;
    private DiagnosticScopeFactory _scopeFactory;
    public static string MessagingSystem;
    public static string DestinationName;
    public static string MessagingOperation;
    public static string ServerAddress;
    public static string BatchCount;
    public static string TraceParent;
    public static string TraceState;
    public static string MessageBusDestination;
    public static string PeerAddress;
    public static string Component;
    public static string DiagnosticIdAttribute;
    public MessagingClientDiagnostics(string clientNamespace, string resourceProviderNamespace, string messagingSystem, string fullyQualifiedNamespace, string entityPath);
    public DiagnosticScope CreateScope(string activityName, ActivityKind kind, MessagingDiagnosticOperation operation);
    [NullableContextAttribute("2")]
public static bool TryExtractTraceContext(IReadOnlyDictionary`2<string, object> properties, String& traceparent, String& tracestate);
    [NullableContextAttribute("2")]
public static bool TryExtractTraceContext(IDictionary`2<string, object> properties, String& traceparent, String& tracestate);
    [NullableContextAttribute("2")]
public void InstrumentMessage(IDictionary`2<string, object> properties, string activityName, String& traceparent, String& tracestate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Shared.MessagingDiagnosticOperation : ValueType {
    private string _operation;
    public static MessagingDiagnosticOperation Publish;
    public static MessagingDiagnosticOperation Receive;
    public static MessagingDiagnosticOperation Process;
    private MessagingDiagnosticOperation(string operation);
    private static MessagingDiagnosticOperation();
    public virtual string ToString();
    public static bool op_Equality(MessagingDiagnosticOperation left, MessagingDiagnosticOperation right);
    public static bool op_Inequality(MessagingDiagnosticOperation left, MessagingDiagnosticOperation right);
    public static MessagingDiagnosticOperation op_Implicit(string value);
    public sealed virtual bool Equals(MessagingDiagnosticOperation other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Amqp.AmqpAnnotatedMessageExtensions : object {
    [ExtensionAttribute]
public static void PopulateFromEventProperties(AmqpAnnotatedMessage instance, IDictionary`2<string, object> properties, Nullable`1<long> sequenceNumber, Nullable`1<long> offset, Nullable`1<DateTimeOffset> enqueuedTime, string partitionKey, Nullable`1<long> lastPartitionSequenceNumber, Nullable`1<long> lastPartitionOffset, Nullable`1<DateTimeOffset> lastPartitionEnqueuedTime, Nullable`1<DateTimeOffset> lastPartitionPropertiesRetrievalTime);
    [ExtensionAttribute]
public static AmqpAnnotatedMessage Clone(AmqpAnnotatedMessage instance);
    [ExtensionAttribute]
public static BinaryData GetEventBody(AmqpAnnotatedMessage instance);
    [ExtensionAttribute]
public static long GetSequenceNumber(AmqpAnnotatedMessage instance, long defaultValue);
    [ExtensionAttribute]
public static long GetOffset(AmqpAnnotatedMessage instance, long defaultValue);
    [ExtensionAttribute]
public static DateTimeOffset GetEnqueuedTime(AmqpAnnotatedMessage instance, DateTimeOffset defaultValue);
    [ExtensionAttribute]
public static void SetEnqueuedTime(AmqpAnnotatedMessage instance, DateTimeOffset enqueueTime);
    [ExtensionAttribute]
public static string GetPartitionKey(AmqpAnnotatedMessage instance, string defaultValue);
    [ExtensionAttribute]
public static void SetPartitionKey(AmqpAnnotatedMessage instance, string partitionKey);
    [ExtensionAttribute]
public static Nullable`1<long> GetLastPartitionSequenceNumber(AmqpAnnotatedMessage instance, Nullable`1<long> defaultValue);
    [ExtensionAttribute]
public static Nullable`1<long> GetLastPartitionOffset(AmqpAnnotatedMessage instance, Nullable`1<long> defaultValue);
    [ExtensionAttribute]
public static Nullable`1<DateTimeOffset> GetLastPartitionEnqueuedTime(AmqpAnnotatedMessage instance, Nullable`1<DateTimeOffset> defaultValue);
    [ExtensionAttribute]
public static Nullable`1<DateTimeOffset> GetLastPartitionPropertiesRetrievalTime(AmqpAnnotatedMessage instance, Nullable`1<DateTimeOffset> defaultValue);
    private static AmqpMessageBody CloneBody(AmqpMessageBody amqpBody);
    private static void CopyHeaderSection(AmqpMessageHeader source, AmqpMessageHeader destination);
    private static void CopyPropertiesSection(AmqpMessageProperties source, AmqpMessageProperties destination);
    private static void CopyDictionary(IDictionary`2<TKey, TValue> source, IDictionary`2<TKey, TValue> destination);
}
internal class Azure.Messaging.EventHubs.Amqp.AmqpClient : TransportClient {
    [CompilerGeneratedAttribute]
private static TimeSpan <CredentialRefreshBuffer>k__BackingField;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closed;
    private AccessToken _accessToken;
    [CompilerGeneratedAttribute]
private Uri <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ConnectionEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubTokenCredential <Credential>k__BackingField;
    [CompilerGeneratedAttribute]
private AmqpMessageConverter <MessageConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private AmqpConnectionScope <ConnectionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultTolerantAmqpObject`1<RequestResponseAmqpLink> <ManagementLink>k__BackingField;
    private static TimeSpan CredentialRefreshBuffer { get; }
    public bool IsClosed { get; }
    public Uri ServiceEndpoint { get; }
    public Uri ConnectionEndpoint { get; }
    private string EventHubName { get; }
    private EventHubTokenCredential Credential { get; }
    private AmqpMessageConverter MessageConverter { get; }
    private AmqpConnectionScope ConnectionScope { get; }
    private FaultTolerantAmqpObject`1<RequestResponseAmqpLink> ManagementLink { get; }
    public AmqpClient(string host, string eventHubName, TimeSpan operationTimeout, EventHubTokenCredential credential, EventHubConnectionOptions clientOptions, bool useTls);
    protected AmqpClient(string host, string eventHubName, bool useTls, TimeSpan operationTimeout, EventHubTokenCredential credential, EventHubConnectionOptions clientOptions, AmqpConnectionScope connectionScope, AmqpMessageConverter messageConverter);
    private static AmqpClient();
    [CompilerGeneratedAttribute]
private static TimeSpan get_CredentialRefreshBuffer();
    public virtual bool get_IsClosed();
    [CompilerGeneratedAttribute]
public virtual Uri get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
public Uri get_ConnectionEndpoint();
    [CompilerGeneratedAttribute]
private string get_EventHubName();
    [CompilerGeneratedAttribute]
private EventHubTokenCredential get_Credential();
    [CompilerGeneratedAttribute]
private AmqpMessageConverter get_MessageConverter();
    [CompilerGeneratedAttribute]
private AmqpConnectionScope get_ConnectionScope();
    [CompilerGeneratedAttribute]
private FaultTolerantAmqpObject`1<RequestResponseAmqpLink> get_ManagementLink();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpClient/<GetPropertiesAsync>d__30")]
public virtual Task`1<EventHubProperties> GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpClient/<GetPartitionPropertiesAsync>d__31")]
public virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(string partitionId, EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken);
    public virtual TransportProducer CreateProducer(string partitionId, string producerIdentifier, TransportProducerFeatures requestedFeatures, PartitionPublishingOptions partitionOptions, EventHubsRetryPolicy retryPolicy);
    public virtual TransportConsumer CreateConsumer(string consumerGroup, string partitionId, string consumerIdentifier, EventPosition eventPosition, EventHubsRetryPolicy retryPolicy, bool trackLastEnqueuedEventProperties, bool invalidateConsumerWhenPartitionStolen, Nullable`1<long> ownerLevel, Nullable`1<UInt32> prefetchCount, Nullable`1<long> prefetchSizeInBytes);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpClient/<CloseAsync>d__34")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpClient/<AcquireAccessTokenAsync>d__35")]
private Task`1<string> AcquireAccessTokenAsync(CancellationToken cancellationToken);
}
internal class Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope : object {
    private static string CbsSaslHandlerName;
    private static string WebSocketsPathSuffix;
    private static string WebSocketsSecureUriScheme;
    private static string WebSocketsInsecureUriScheme;
    private static string ConsumerPathSuffixMask;
    private static string PartitionProducerPathSuffixMask;
    private static int s_randomSeed;
    private static ThreadLocal`1<Random> RandomNumberGenerator;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    [CompilerGeneratedAttribute]
private static Version <AmqpVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <AuthorizationRefreshBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <AuthorizationBaseJitterSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <MinimumAuthorizationRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <MaximumAuthorizationRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <AuthorizationRefreshTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <AuthorizationTokenExpirationBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ConnectionIdleTimeoutMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationTokenSource <OperationCancellationSource>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<AmqpObject, Timer> <ActiveLinks>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ServiceEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ConnectionEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private CbsTokenProvider <TokenProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsTransportType <Transport>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <Proxy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendBufferSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceiveBufferSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <CertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultTolerantAmqpObject`1<AmqpConnection> <ActiveConnection>k__BackingField;
    private static Version AmqpVersion { get; }
    private static TimeSpan AuthorizationRefreshBuffer { get; }
    private static int AuthorizationBaseJitterSeconds { get; }
    private static TimeSpan MinimumAuthorizationRefresh { get; }
    private static TimeSpan MaximumAuthorizationRefresh { get; }
    private static TimeSpan AuthorizationRefreshTimeout { get; }
    private static TimeSpan AuthorizationTokenExpirationBuffer { get; }
    public UInt32 ConnectionIdleTimeoutMilliseconds { get; }
    public bool IsDisposed { get; private set; }
    private CancellationTokenSource OperationCancellationSource { get; }
    private ConcurrentDictionary`2<AmqpObject, Timer> ActiveLinks { get; }
    private string Id { get; }
    private Uri ServiceEndpoint { get; }
    private Uri ConnectionEndpoint { get; }
    private string EventHubName { get; }
    private CbsTokenProvider TokenProvider { get; }
    private EventHubsTransportType Transport { get; }
    private IWebProxy Proxy { get; }
    private int SendBufferSizeInBytes { get; }
    private int ReceiveBufferSizeInBytes { get; }
    private RemoteCertificateValidationCallback CertificateValidationCallback { get; }
    private FaultTolerantAmqpObject`1<AmqpConnection> ActiveConnection { get; }
    public AmqpConnectionScope(Uri serviceEndpoint, Uri connectionEndpoint, string eventHubName, EventHubTokenCredential credential, EventHubsTransportType transport, IWebProxy proxy, TimeSpan idleTimeout, string identifier, int sendBufferSizeBytes, int receiveBufferSizeBytes, RemoteCertificateValidationCallback certificateValidationCallback);
    private static AmqpConnectionScope();
    [CompilerGeneratedAttribute]
private static Version get_AmqpVersion();
    [CompilerGeneratedAttribute]
private static TimeSpan get_AuthorizationRefreshBuffer();
    [CompilerGeneratedAttribute]
private static int get_AuthorizationBaseJitterSeconds();
    [CompilerGeneratedAttribute]
private static TimeSpan get_MinimumAuthorizationRefresh();
    [CompilerGeneratedAttribute]
private static TimeSpan get_MaximumAuthorizationRefresh();
    [CompilerGeneratedAttribute]
private static TimeSpan get_AuthorizationRefreshTimeout();
    [CompilerGeneratedAttribute]
private static TimeSpan get_AuthorizationTokenExpirationBuffer();
    [CompilerGeneratedAttribute]
public UInt32 get_ConnectionIdleTimeoutMilliseconds();
    public bool get_IsDisposed();
    private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
private CancellationTokenSource get_OperationCancellationSource();
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<AmqpObject, Timer> get_ActiveLinks();
    [CompilerGeneratedAttribute]
private string get_Id();
    [CompilerGeneratedAttribute]
private Uri get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
private Uri get_ConnectionEndpoint();
    [CompilerGeneratedAttribute]
private string get_EventHubName();
    [CompilerGeneratedAttribute]
private CbsTokenProvider get_TokenProvider();
    [CompilerGeneratedAttribute]
private EventHubsTransportType get_Transport();
    [CompilerGeneratedAttribute]
private IWebProxy get_Proxy();
    [CompilerGeneratedAttribute]
private int get_SendBufferSizeInBytes();
    [CompilerGeneratedAttribute]
private int get_ReceiveBufferSizeInBytes();
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback get_CertificateValidationCallback();
    [CompilerGeneratedAttribute]
private FaultTolerantAmqpObject`1<AmqpConnection> get_ActiveConnection();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<OpenManagementLinkAsync>d__77")]
public virtual Task`1<RequestResponseAmqpLink> OpenManagementLinkAsync(TimeSpan operationTimeout, TimeSpan linkTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<OpenConsumerLinkAsync>d__78")]
public virtual Task`1<ReceivingAmqpLink> OpenConsumerLinkAsync(string consumerGroup, string partitionId, EventPosition eventPosition, TimeSpan operationTimeout, TimeSpan linkTimeout, UInt32 prefetchCount, Nullable`1<long> prefetchSizeInBytes, Nullable`1<long> ownerLevel, bool trackLastEnqueuedEventProperties, string linkIdentifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<OpenProducerLinkAsync>d__79")]
public virtual Task`1<SendingAmqpLink> OpenProducerLinkAsync(string partitionId, TransportProducerFeatures features, PartitionPublishingOptions options, TimeSpan operationTimeout, TimeSpan linkTimeout, string linkIdentifier, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<CreateAndOpenConnectionAsync>d__81")]
protected virtual Task`1<AmqpConnection> CreateAndOpenConnectionAsync(Version amqpVersion, Uri serviceEndpoint, Uri connectionEndpoint, EventHubsTransportType transportType, IWebProxy proxy, int sendBufferSizeBytes, int receiveBufferSizeBytes, RemoteCertificateValidationCallback certificateValidationCallback, string scopeIdentifier, TimeSpan timeout);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<CreateManagementLinkAsync>d__82")]
protected virtual Task`1<RequestResponseAmqpLink> CreateManagementLinkAsync(AmqpConnection connection, TimeSpan operationTimeout, TimeSpan linkTimeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<CreateReceivingLinkAsync>d__83")]
protected virtual Task`1<ReceivingAmqpLink> CreateReceivingLinkAsync(AmqpConnection connection, Uri endpoint, EventPosition eventPosition, TimeSpan operationTimeout, TimeSpan linkTimeout, UInt32 prefetchCount, Nullable`1<long> prefetchSizeInBytes, Nullable`1<long> ownerLevel, bool trackLastEnqueuedEventProperties, string linkIdentifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<CreateSendingLinkAsync>d__84")]
protected virtual Task`1<SendingAmqpLink> CreateSendingLinkAsync(AmqpConnection connection, Uri endpoint, TransportProducerFeatures features, PartitionPublishingOptions options, TimeSpan operationTimeout, TimeSpan linkTimeout, string linkIdentifier, CancellationToken cancellationToken);
    protected virtual void StartTrackingLinkAsActive(AmqpObject link, Timer authorizationRefreshTimer);
    protected virtual void StopTrackingLinkAsActive(AmqpObject link, Timer authorizationRefreshTimer);
    protected virtual void CloseConnection(AmqpConnection connection);
    protected virtual TimeSpan CalculateLinkAuthorizationRefreshInterval(DateTime expirationTimeUtc, Nullable`1<DateTime> currentTimeUtc);
    protected virtual TimerCallback CreateAuthorizationRefreshHandler(AmqpConnection connection, AmqpObject amqpLink, CbsTokenProvider tokenProvider, Uri endpoint, string audience, string resource, String[] requiredClaims, TimeSpan refreshTimeout, Func`1<Timer> refreshTimerFactory);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<RequestAuthorizationUsingCbsAsync>d__90")]
protected virtual Task`1<DateTime> RequestAuthorizationUsingCbsAsync(AmqpConnection connection, CbsTokenProvider tokenProvider, Uri endpoint, string audience, string resource, String[] requiredClaims, TimeSpan timeout);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConnectionScope/<OpenAmqpObjectAsync>d__91")]
protected virtual Task OpenAmqpObjectAsync(AmqpObject target, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    private static AmqpSettings CreateAmpqSettings(Version amqpVersion);
    private static TransportSettings CreateTransportSettingsforTcp(Uri connectionEndpoint, int sendBufferSizeBytes, int receiveBufferSizeBytes, RemoteCertificateValidationCallback certificateValidationCallback);
    private static TransportSettings CreateTransportSettingsForWebSockets(Uri connectionEndpoint, IWebProxy proxy, int sendBufferSizeBytes, int receiveBufferSizeBytes);
    private static AmqpConnectionSettings CreateAmqpConnectionSettings(string hostName, string identifier, UInt32 idleTimeoutMilliseconds);
    private static void ValidateTransport(EventHubsTransportType transport);
    private static bool ShouldUseTls(string urlScheme);
    [CompilerGeneratedAttribute]
private Task`1<AmqpConnection> <.ctor>g__connectionFactory|75_0(TimeSpan timeout);
}
internal class Azure.Messaging.EventHubs.Amqp.AmqpConsumer : TransportConsumer {
    private static UInt32 DefaultPrefetchCount;
    private static IReadOnlyList`1<EventData> EmptyEventSet;
    private static TimeSpan ReceiveBuildBatchInterval;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _activePartitionStolenException;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closed;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private EventPosition <CurrentEventPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackLastEnqueuedEventProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvalidateConsumerWhenPartitionStolen>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private AmqpMessageConverter <MessageConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private AmqpConnectionScope <ConnectionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultTolerantAmqpObject`1<ReceivingAmqpLink> <ReceiveLink>k__BackingField;
    public bool IsClosed { get; }
    private string EventHubName { get; }
    private string ConsumerGroup { get; }
    private string PartitionId { get; }
    public string Identifier { get; }
    private EventPosition CurrentEventPosition { get; private set; }
    private bool TrackLastEnqueuedEventProperties { get; }
    private bool InvalidateConsumerWhenPartitionStolen { get; }
    private EventHubsRetryPolicy RetryPolicy { get; }
    private AmqpMessageConverter MessageConverter { get; }
    private AmqpConnectionScope ConnectionScope { get; }
    private FaultTolerantAmqpObject`1<ReceivingAmqpLink> ReceiveLink { get; }
    public AmqpConsumer(string eventHubName, string consumerGroup, string partitionId, string consumerIdentifier, EventPosition eventPosition, bool trackLastEnqueuedEventProperties, bool invalidateConsumerWhenPartitionStolen, Nullable`1<long> ownerLevel, Nullable`1<UInt32> prefetchCount, Nullable`1<long> prefetchSizeInBytes, AmqpConnectionScope connectionScope, AmqpMessageConverter messageConverter, EventHubsRetryPolicy retryPolicy);
    private static AmqpConsumer();
    public virtual bool get_IsClosed();
    [CompilerGeneratedAttribute]
private string get_EventHubName();
    [CompilerGeneratedAttribute]
private string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
private string get_PartitionId();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
private EventPosition get_CurrentEventPosition();
    [CompilerGeneratedAttribute]
private void set_CurrentEventPosition(EventPosition value);
    [CompilerGeneratedAttribute]
private bool get_TrackLastEnqueuedEventProperties();
    [CompilerGeneratedAttribute]
private bool get_InvalidateConsumerWhenPartitionStolen();
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private AmqpMessageConverter get_MessageConverter();
    [CompilerGeneratedAttribute]
private AmqpConnectionScope get_ConnectionScope();
    [CompilerGeneratedAttribute]
private FaultTolerantAmqpObject`1<ReceivingAmqpLink> get_ReceiveLink();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConsumer/<ReceiveAsync>d__42")]
public virtual Task`1<IReadOnlyList`1<EventData>> ReceiveAsync(int maximumEventCount, Nullable`1<TimeSpan> maximumWaitTime, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConsumer/<CloseAsync>d__43")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpConsumer/<CreateConsumerLinkAsync>d__44")]
protected Task`1<ReceivingAmqpLink> CreateConsumerLinkAsync(string consumerGroup, string partitionId, string consumerIdentifier, EventPosition eventStartingPosition, UInt32 prefetchCount, Nullable`1<long> prefetchSizeInBytes, Nullable`1<long> ownerLevel, bool trackLastEnqueuedEventProperties, TimeSpan timeout, CancellationToken cancellationToken);
    protected void CloseConsumerLink(ReceivingAmqpLink link);
    protected virtual Exception GetTerminalException(ReceivingAmqpLink link);
}
internal class Azure.Messaging.EventHubs.Amqp.AmqpEventBatch : TransportEventBatch {
    private static byte OverheadBytesSmallMessage;
    private static byte OverheadBytesLargeMessage;
    private static byte MaximumBytesSmallMessage;
    private long _reservedOverheadBytes;
    private AmqpMessageConverter _messageConverter;
    private CreateBatchOptions _options;
    private List`1<AmqpMessage> _batchMessages;
    private Nullable`1<int> _startingSequenceNumber;
    private long _sizeBytes;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    [CompilerGeneratedAttribute]
private long <MaximumSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportProducerFeatures <ActiveFeatures>k__BackingField;
    public long MaximumSizeInBytes { get; }
    public TransportProducerFeatures ActiveFeatures { get; }
    public long SizeInBytes { get; }
    public int Count { get; }
    public Nullable`1<int> StartingSequenceNumber { get; }
    public AmqpEventBatch(AmqpMessageConverter messageConverter, CreateBatchOptions options, TransportProducerFeatures activeFeatures);
    [CompilerGeneratedAttribute]
public virtual long get_MaximumSizeInBytes();
    [CompilerGeneratedAttribute]
public virtual TransportProducerFeatures get_ActiveFeatures();
    public virtual long get_SizeInBytes();
    public virtual int get_Count();
    public virtual Nullable`1<int> get_StartingSequenceNumber();
    public virtual bool TryAdd(EventData eventData);
    public virtual void Clear();
    public virtual IReadOnlyCollection`1<T> AsReadOnlyCollection();
    public virtual int ApplyBatchSequencing(int lastSequenceNumber, Nullable`1<long> producerGroupId, Nullable`1<short> ownerLevel);
    public virtual void ResetBatchSequencing();
    public virtual void Dispose();
    private static int NextSequence(int currentSequence);
}
internal class Azure.Messaging.EventHubs.Amqp.AmqpMessageConverter : object {
    private static int StreamBufferSizeInBytes;
    private static HashSet`1<string> SystemPropertyDateTimeKeys;
    private static HashSet`1<string> SystemPropertyLongKeys;
    private static AmqpMessageConverter();
    public virtual AmqpMessage CreateMessageFromEvent(EventData source, string partitionKey);
    public virtual AmqpMessage CreateBatchFromEvents(IReadOnlyCollection`1<EventData> source, string partitionKey);
    public virtual AmqpMessage CreateBatchFromMessages(IReadOnlyCollection`1<AmqpMessage> source, string partitionKey);
    public virtual EventData CreateEventFromMessage(AmqpMessage source);
    public virtual AmqpMessage CreateEventHubPropertiesRequest(string eventHubName, string managementAuthorizationToken);
    public virtual EventHubProperties CreateEventHubPropertiesFromResponse(AmqpMessage response);
    public virtual AmqpMessage CreatePartitionPropertiesRequest(string eventHubName, string partitionIdentifier, string managementAuthorizationToken);
    public virtual PartitionProperties CreatePartitionPropertiesFromResponse(AmqpMessage response);
    public virtual void ApplyPublisherPropertiesToAmqpMessage(AmqpMessage message, Nullable`1<int> sequenceNumber, Nullable`1<long> groupId, Nullable`1<short> ownerLevel);
    public virtual void RemovePublishingPropertiesFromAmqpMessage(AmqpMessage message);
    private static AmqpMessage BuildAmqpBatchFromEvents(IReadOnlyCollection`1<EventData> source, string partitionKey);
    private static AmqpMessage BuildAmqpBatchFromMessages(IReadOnlyCollection`1<AmqpMessage> source, string partitionKey);
    private static AmqpMessage BuildAmqpMessageFromEvent(EventData source, string partitionKey);
    private static EventData BuildEventFromAmqpMessage(AmqpMessage source);
    private static void NormalizeBrokerProperties(IDictionary`2<string, object> properties, Annotations sourceProperties);
    private static void SetPublisherProperties(AmqpMessage message, Nullable`1<int> sequenceNumber, Nullable`1<long> groupId, Nullable`1<short> ownerLevel);
    private static ArraySegment`1<byte> ReadStreamToArraySegment(Stream stream);
}
internal class Azure.Messaging.EventHubs.Amqp.AmqpProducer : TransportProducer {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closed;
    private int _deliveryCount;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportProducerFeatures <ActiveFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionPublishingOptions <ActiveOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private AmqpMessageConverter <MessageConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private AmqpConnectionScope <ConnectionScope>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultTolerantAmqpObject`1<SendingAmqpLink> <SendLink>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionPublishingProperties <InitializedPartitionProperties>k__BackingField;
    public bool IsClosed { get; }
    private string EventHubName { get; }
    private string PartitionId { get; }
    public string Identifier { get; }
    private TransportProducerFeatures ActiveFeatures { get; }
    private PartitionPublishingOptions ActiveOptions { get; }
    private EventHubsRetryPolicy RetryPolicy { get; }
    private AmqpMessageConverter MessageConverter { get; }
    private AmqpConnectionScope ConnectionScope { get; }
    private FaultTolerantAmqpObject`1<SendingAmqpLink> SendLink { get; }
    private Nullable`1<long> MaximumMessageSize { get; private set; }
    private PartitionPublishingProperties InitializedPartitionProperties { get; private set; }
    public AmqpProducer(string eventHubName, string partitionId, string producerIdentifier, AmqpConnectionScope connectionScope, AmqpMessageConverter messageConverter, EventHubsRetryPolicy retryPolicy, TransportProducerFeatures requestedFeatures, PartitionPublishingOptions partitionOptions);
    public virtual bool get_IsClosed();
    [CompilerGeneratedAttribute]
private string get_EventHubName();
    [CompilerGeneratedAttribute]
private string get_PartitionId();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
private TransportProducerFeatures get_ActiveFeatures();
    [CompilerGeneratedAttribute]
private PartitionPublishingOptions get_ActiveOptions();
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private AmqpMessageConverter get_MessageConverter();
    [CompilerGeneratedAttribute]
private AmqpConnectionScope get_ConnectionScope();
    [CompilerGeneratedAttribute]
private FaultTolerantAmqpObject`1<SendingAmqpLink> get_SendLink();
    [CompilerGeneratedAttribute]
private Nullable`1<long> get_MaximumMessageSize();
    [CompilerGeneratedAttribute]
private void set_MaximumMessageSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
private PartitionPublishingProperties get_InitializedPartitionProperties();
    [CompilerGeneratedAttribute]
private void set_InitializedPartitionProperties(PartitionPublishingProperties value);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpProducer/<SendAsync>d__40")]
public virtual Task SendAsync(IReadOnlyCollection`1<EventData> events, SendEventOptions sendOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpProducer/<SendAsync>d__41")]
public virtual Task SendAsync(EventDataBatch eventBatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpProducer/<CreateBatchAsync>d__42")]
public virtual ValueTask`1<TransportEventBatch> CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpProducer/<ReadInitializationPublishingPropertiesAsync>d__43")]
public virtual ValueTask`1<PartitionPublishingProperties> ReadInitializationPublishingPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpProducer/<CloseAsync>d__44")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpProducer/<SendAsync>d__45")]
protected virtual Task SendAsync(IReadOnlyCollection`1<AmqpMessage> messages, string partitionKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpProducer/<CreateLinkAndEnsureProducerStateAsync>d__46")]
protected virtual Task`1<SendingAmqpLink> CreateLinkAndEnsureProducerStateAsync(string partitionId, string producerIdentifier, PartitionPublishingOptions partitionOptions, TimeSpan timeout, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
internal class Azure.Messaging.EventHubs.Amqp.AmqpSystemProperties : object {
    private static String[] PropertySectionNames;
    private AmqpAnnotatedMessage _amqpMessage;
    public object Item { get; }
    public IEnumerable`1<string> Keys { get; }
    public IEnumerable`1<object> Values { get; }
    public int Count { get; }
    public AmqpSystemProperties(AmqpAnnotatedMessage amqpMessage);
    private static AmqpSystemProperties();
    public sealed virtual object get_Item(string key);
    [IteratorStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpSystemProperties/<get_Keys>d__5")]
public sealed virtual IEnumerable`1<string> get_Keys();
    [IteratorStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpSystemProperties/<get_Values>d__7")]
public sealed virtual IEnumerable`1<object> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    [IteratorStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.AmqpSystemProperties/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Azure.Messaging.EventHubs.Amqp.CbsTokenProvider : object {
    private static string SharedAccessTokenType;
    private static string JsonWebTokenType;
    private string TokenType;
    private EventHubTokenCredential Credential;
    private SemaphoreSlim TokenAcquireGuard;
    private TimeSpan TokenExpirationBuffer;
    private CancellationToken CancellationToken;
    private CbsToken _cachedJwtToken;
    public CbsTokenProvider(EventHubTokenCredential credential, TimeSpan tokenExpirationBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.CbsTokenProvider/<GetTokenAsync>d__9")]
public sealed virtual Task`1<CbsToken> GetTokenAsync(Uri namespaceAddress, string appliesTo, String[] requiredClaims);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.CbsTokenProvider/<AcquireJwtTokenAsync>d__11")]
private Task`1<CbsToken> AcquireJwtTokenAsync();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Amqp.CbsTokenProvider/<AcquireSharedAccessTokenAsync>d__12")]
private Task`1<CbsToken> AcquireSharedAccessTokenAsync();
    private bool IsNearingExpiration(CbsToken token);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Amqp.ExceptionExtensions : object {
    [ExtensionAttribute]
public static Exception TranslateServiceException(Exception instance, string eventHubName);
    [ExtensionAttribute]
public static Exception TranslateConnectionCloseDuringLinkCreationException(Exception instance, string eventHubName);
    [ExtensionAttribute]
public static bool IsConsumerPartitionStolenException(Exception instance);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Amqp.TypeExtensions : object {
    private static IReadOnlyDictionary`2<Type, Type> AmqpPropertyTypeMap;
    private static TypeExtensions();
    [ExtensionAttribute]
public static Type ToAmqpPropertyType(Type instance);
}
internal static class Azure.Messaging.EventHubs.AmqpError : object {
    private static string NotFoundStatusText;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <TimeoutError>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <DisabledError>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ServerBusyError>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ArgumentError>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ArgumentOutOfRangeError>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <SequenceOutOfOrderError>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ProducerStolenError>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <NotFoundExpression>k__BackingField;
    private static IReadOnlyDictionary`2<AmqpResponseStatusCode, AmqpSymbol> StatusCodeMap;
    public static AmqpSymbol TimeoutError { get; }
    public static AmqpSymbol DisabledError { get; }
    public static AmqpSymbol ServerBusyError { get; }
    public static AmqpSymbol ArgumentError { get; }
    public static AmqpSymbol ArgumentOutOfRangeError { get; }
    public static AmqpSymbol SequenceOutOfOrderError { get; }
    public static AmqpSymbol ProducerStolenError { get; }
    private static Regex NotFoundExpression { get; }
    private static AmqpError();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_TimeoutError();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_DisabledError();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ServerBusyError();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ArgumentError();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ArgumentOutOfRangeError();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_SequenceOutOfOrderError();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ProducerStolenError();
    [CompilerGeneratedAttribute]
private static Regex get_NotFoundExpression();
    public static Exception CreateExceptionForResponse(AmqpMessage response, string eventHubsResource, Exception innerException);
    public static Exception CreateExceptionForError(Error error, string eventHubsResource, Exception innerException);
    public static void ThrowIfErrorResponse(AmqpMessage response, string eventHubName);
    private static Exception CreateException(string condition, string description, string eventHubsResource, Exception innerException);
    private static AmqpSymbol DetermineErrorCondition(AmqpMessage response);
    private static string IncludeTroubleshootingGuideLink(string message);
}
internal static class Azure.Messaging.EventHubs.AmqpFilter : object {
    public static string SequenceNumberName;
    public static string OffsetName;
    public static string EnqueuedTimeName;
    public static string ConsumerFilterName;
    public static ulong ConsumerFilterCode;
    public static AmqpDescribed CreateConsumerFilter(string filterExpression);
    public static string BuildFilterExpression(EventPosition eventPosition);
}
internal static class Azure.Messaging.EventHubs.AmqpManagement : object {
    public static string Address;
    public static string LinkType;
    public static string ResourceNameKey;
    public static string PartitionNameKey;
    public static string OperationKey;
    public static string ResourceTypeKey;
    public static string SecurityTokenKey;
    public static string ReadOperationValue;
    public static string EventHubResourceTypeValue;
    public static string PartitionResourceTypeValue;
}
internal static class Azure.Messaging.EventHubs.AmqpProperty : object {
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ConsumerOwnerLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ConsumerIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ProducerOwnerLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <EntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <TrackLastEnqueuedEventProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <EnableIdempotentPublishing>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ProducerGroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <ProducerSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <EnqueuedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <PartitionLastEnqueuedSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <PartitionLastEnqueuedOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <PartitionLastEnqueuedTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmqpSymbol <LastPartitionPropertiesRetrievalTimeUtc>k__BackingField;
    public static AmqpSymbol ConsumerOwnerLevel { get; }
    public static AmqpSymbol ConsumerIdentifier { get; }
    public static AmqpSymbol ProducerOwnerLevel { get; }
    public static AmqpSymbol EntityType { get; }
    public static AmqpSymbol TrackLastEnqueuedEventProperties { get; }
    public static AmqpSymbol EnableIdempotentPublishing { get; }
    public static AmqpSymbol ProducerGroupId { get; }
    public static AmqpSymbol ProducerSequenceNumber { get; }
    public static AmqpSymbol Timeout { get; }
    public static AmqpSymbol EnqueuedTime { get; }
    public static AmqpSymbol SequenceNumber { get; }
    public static AmqpSymbol Offset { get; }
    public static AmqpSymbol PartitionKey { get; }
    public static AmqpSymbol PartitionLastEnqueuedSequenceNumber { get; }
    public static AmqpSymbol PartitionLastEnqueuedOffset { get; }
    public static AmqpSymbol PartitionLastEnqueuedTimeUtc { get; }
    public static AmqpSymbol LastPartitionPropertiesRetrievalTimeUtc { get; }
    private static AmqpProperty();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ConsumerOwnerLevel();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ConsumerIdentifier();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ProducerOwnerLevel();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_EntityType();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_TrackLastEnqueuedEventProperties();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_EnableIdempotentPublishing();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ProducerGroupId();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_ProducerSequenceNumber();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_Timeout();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_EnqueuedTime();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_SequenceNumber();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_Offset();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_PartitionKey();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_PartitionLastEnqueuedSequenceNumber();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_PartitionLastEnqueuedOffset();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_PartitionLastEnqueuedTimeUtc();
    [CompilerGeneratedAttribute]
public static AmqpSymbol get_LastPartitionPropertiesRetrievalTimeUtc();
}
internal static class Azure.Messaging.EventHubs.AmqpResponse : object {
    public static string StatusCode;
    public static string StatusDescription;
    public static string ErrorCondition;
    public static bool IsSuccessStatus(AmqpResponseStatusCode statusCode);
}
internal static class Azure.Messaging.EventHubs.Authorization.EventHubsClaim : object {
    public static string Manage;
    public static string Send;
    public static string Listen;
}
internal class Azure.Messaging.EventHubs.Authorization.EventHubTokenCredential : TokenCredential {
    private static string DefaultScope;
    private TokenCredential _credential;
    [CompilerGeneratedAttribute]
private bool <IsSharedAccessCredential>k__BackingField;
    public bool IsSharedAccessCredential { get; }
    public EventHubTokenCredential(TokenCredential tokenCredential);
    [CompilerGeneratedAttribute]
public bool get_IsSharedAccessCredential();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public ValueTask`1<AccessToken> GetTokenUsingDefaultScopeAsync(CancellationToken cancellationToken);
}
internal class Azure.Messaging.EventHubs.Authorization.SharedAccessCredential : TokenCredential {
    private static TimeSpan SignatureRefreshBuffer;
    private static TimeSpan SignatureExtensionDuration;
    private AzureNamedKeyCredential _sourceKeyCredential;
    private AzureSasCredential _sourceSasCredential;
    private SharedAccessSignature _sharedAccessSignature;
    public SharedAccessCredential(SharedAccessSignature signature);
    public SharedAccessCredential(AzureSasCredential sourceCredential);
    public SharedAccessCredential(AzureNamedKeyCredential sourceCredential, string signatureResource);
    private static SharedAccessCredential();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
    private SharedAccessSignature SafeUpdateSharedAccessSignature(SharedAccessSignature cachedSignature, SharedAccessSignature updatedSignature);
}
internal class Azure.Messaging.EventHubs.Authorization.SharedAccessSignature : object {
    private static int MaximumKeyNameLength;
    private static int MaximumKeyLength;
    private static string AuthenticationTypeToken;
    private static string SignedResourceToken;
    private static string SignatureToken;
    private static string SignedKeyNameToken;
    private static string SignedExpiryToken;
    private static string SignedResourceFullIdentifierToken;
    private static char TokenValueSeparator;
    private static char TokenValuePairDelimiter;
    private static TimeSpan DefaultSignatureValidityDuration;
    private static DateTimeOffset Epoch;
    [CompilerGeneratedAttribute]
private string <SharedAccessKeyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedAccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignatureExpiration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string SharedAccessKeyName { get; private set; }
    public string SharedAccessKey { get; private set; }
    public DateTimeOffset SignatureExpiration { get; private set; }
    public string Resource { get; private set; }
    public string Value { get; private set; }
    public SharedAccessSignature(string eventHubResource, string sharedAccessKeyName, string sharedAccessKey, Nullable`1<TimeSpan> signatureValidityDuration);
    public SharedAccessSignature(string sharedAccessSignature, string sharedAccessKey);
    public SharedAccessSignature(string sharedAccessSignature);
    public SharedAccessSignature(string eventHubResource, string sharedAccessKeyName, string sharedAccessKey, string value, DateTimeOffset signatureExpiration);
    private static SharedAccessSignature();
    [CompilerGeneratedAttribute]
public string get_SharedAccessKeyName();
    [CompilerGeneratedAttribute]
private void set_SharedAccessKeyName(string value);
    [CompilerGeneratedAttribute]
public string get_SharedAccessKey();
    [CompilerGeneratedAttribute]
private void set_SharedAccessKey(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignatureExpiration();
    [CompilerGeneratedAttribute]
private void set_SignatureExpiration(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
private void set_Resource(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    public SharedAccessSignature CloneWithNewExpiration(TimeSpan signatureValidityDuration);
    public virtual string ToString();
    private static ValueTuple`3<string, string, DateTimeOffset> ParseSignature(string sharedAccessSignature);
    private static string BuildSignature(string audience, string sharedAccessKeyName, string sharedAccessKey, DateTimeOffset expirationTime);
    private static DateTimeOffset ConvertFromUnixTime(long unixTime);
    private static long ConvertToUnixTime(DateTimeOffset dateTimeOffset);
}
public class Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient : object {
    public static string DefaultConsumerGroupName;
    private static bool InvalidateConsumerWhenPartitionIsStolen;
    private TimeSpan BackgroundPublishingWaitTime;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closed;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OwnsConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, TransportConsumer> <ActiveConsumers>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string ConsumerGroup { get; }
    public string Identifier { get; }
    public bool IsClosed { get; protected set; }
    private bool OwnsConnection { get; }
    private EventHubsRetryPolicy RetryPolicy { get; }
    private EventHubConnection Connection { get; }
    private ConcurrentDictionary`2<string, TransportConsumer> ActiveConsumers { get; }
    public EventHubConsumerClient(string consumerGroup, string connectionString);
    public EventHubConsumerClient(string consumerGroup, string connectionString, EventHubConsumerClientOptions clientOptions);
    public EventHubConsumerClient(string consumerGroup, string connectionString, string eventHubName);
    public EventHubConsumerClient(string consumerGroup, string connectionString, string eventHubName, EventHubConsumerClientOptions clientOptions);
    public EventHubConsumerClient(string consumerGroup, string fullyQualifiedNamespace, string eventHubName, AzureNamedKeyCredential credential, EventHubConsumerClientOptions clientOptions);
    public EventHubConsumerClient(string consumerGroup, string fullyQualifiedNamespace, string eventHubName, AzureSasCredential credential, EventHubConsumerClientOptions clientOptions);
    public EventHubConsumerClient(string consumerGroup, string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventHubConsumerClientOptions clientOptions);
    public EventHubConsumerClient(string consumerGroup, EventHubConnection connection, EventHubConsumerClientOptions clientOptions);
    private EventHubConsumerClient(string consumerGroup, string fullyQualifiedNamespace, string eventHubName, object credential, EventHubConsumerClientOptions clientOptions);
    public string get_FullyQualifiedNamespace();
    public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    public bool get_IsClosed();
    protected void set_IsClosed(bool value);
    [CompilerGeneratedAttribute]
private bool get_OwnsConnection();
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private EventHubConnection get_Connection();
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, TransportConsumer> get_ActiveConsumers();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient/<GetEventHubPropertiesAsync>d__39")]
public virtual Task`1<EventHubProperties> GetEventHubPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient/<GetPartitionIdsAsync>d__40")]
public virtual Task`1<String[]> GetPartitionIdsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient/<GetPartitionPropertiesAsync>d__41")]
public virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(string partitionId, CancellationToken cancellationToken);
    public virtual IAsyncEnumerable`1<PartitionEvent> ReadEventsFromPartitionAsync(string partitionId, EventPosition startingPosition, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient/<ReadEventsFromPartitionAsync>d__43")]
public virtual IAsyncEnumerable`1<PartitionEvent> ReadEventsFromPartitionAsync(string partitionId, EventPosition startingPosition, ReadEventOptions readOptions, CancellationToken cancellationToken);
    public virtual IAsyncEnumerable`1<PartitionEvent> ReadEventsAsync(CancellationToken cancellationToken);
    public virtual IAsyncEnumerable`1<PartitionEvent> ReadEventsAsync(ReadEventOptions readOptions, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient/<ReadEventsAsync>d__46")]
public virtual IAsyncEnumerable`1<PartitionEvent> ReadEventsAsync(bool startReadingAtEarliestEvent, ReadEventOptions readOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient/<CloseAsync>d__47")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient/<DisposeAsync>d__48")]
public virtual ValueTask DisposeAsync();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Consumer.EventHubConsumerClient/<PublishPartitionEventsToChannelAsync>d__52")]
private Task`1<Func`1<Task>> PublishPartitionEventsToChannelAsync(string partitionId, EventPosition startingPosition, bool trackLastEnqueuedEventProperties, int receiveBatchSize, Nullable`1<long> ownerLevel, UInt32 prefetchCount, Channel`1<PartitionEvent> channel, CancellationTokenSource publishingCancellationSource);
    private Task StartBackgroundChannelPublishingAsync(TransportConsumer transportConsumer, Channel`1<PartitionEvent> channel, PartitionContext partitionContext, int receiveBatchSize, Action`1<Exception> notifyException, CancellationToken cancellationToken);
    private static Channel`1<PartitionEvent> CreateEventChannel(int capacity);
}
public class Azure.Messaging.EventHubs.Consumer.EventHubConsumerClientOptions : object {
    private EventHubConnectionOptions _connectionOptions;
    private EventHubsRetryOptions _retryOptions;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; public set; }
    public EventHubConnectionOptions ConnectionOptions { get; public set; }
    public EventHubsRetryOptions RetryOptions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    public EventHubConnectionOptions get_ConnectionOptions();
    public void set_ConnectionOptions(EventHubConnectionOptions value);
    public EventHubsRetryOptions get_RetryOptions();
    public void set_RetryOptions(EventHubsRetryOptions value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal EventHubConsumerClientOptions Clone();
}
public class Azure.Messaging.EventHubs.Consumer.EventPosition : ValueType {
    private static string StartOfStream;
    private static string EndOfStream;
    [CompilerGeneratedAttribute]
private static EventPosition <Earliest>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventPosition <Latest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <EnqueuedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SequenceNumber>k__BackingField;
    public static EventPosition Earliest { get; }
    public static EventPosition Latest { get; }
    internal string Offset { get; internal set; }
    internal bool IsInclusive { get; internal set; }
    internal Nullable`1<DateTimeOffset> EnqueuedTime { get; internal set; }
    internal string SequenceNumber { get; internal set; }
    private static EventPosition();
    [CompilerGeneratedAttribute]
public static EventPosition get_Earliest();
    [CompilerGeneratedAttribute]
public static EventPosition get_Latest();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_IsInclusive();
    [CompilerGeneratedAttribute]
internal void set_IsInclusive(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Nullable`1<DateTimeOffset> get_EnqueuedTime();
    [CompilerGeneratedAttribute]
internal void set_EnqueuedTime(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_SequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_SequenceNumber(string value);
    public static EventPosition FromOffset(long offset, bool isInclusive);
    public static EventPosition FromSequenceNumber(long sequenceNumber, bool isInclusive);
    public static EventPosition FromEnqueuedTime(DateTimeOffset enqueuedTime);
    public sealed virtual bool Equals(EventPosition other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(EventPosition left, EventPosition right);
    public static bool op_Inequality(EventPosition left, EventPosition right);
}
public class Azure.Messaging.EventHubs.Consumer.LastEnqueuedEventProperties : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <EnqueuedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastReceivedTime>k__BackingField;
    public Nullable`1<long> SequenceNumber { get; }
    public Nullable`1<long> Offset { get; }
    public Nullable`1<DateTimeOffset> EnqueuedTime { get; }
    public Nullable`1<DateTimeOffset> LastReceivedTime { get; }
    public LastEnqueuedEventProperties(Nullable`1<long> lastSequenceNumber, Nullable`1<long> lastOffset, Nullable`1<DateTimeOffset> lastEnqueuedTime, Nullable`1<DateTimeOffset> lastReceivedTime);
    internal LastEnqueuedEventProperties(EventData sourceEvent);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<long> get_SequenceNumber();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<long> get_Offset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_EnqueuedTime();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastReceivedTime();
    public sealed virtual bool Equals(LastEnqueuedEventProperties other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(LastEnqueuedEventProperties left, LastEnqueuedEventProperties right);
    public static bool op_Inequality(LastEnqueuedEventProperties left, LastEnqueuedEventProperties right);
}
public class Azure.Messaging.EventHubs.Consumer.PartitionContext : object {
    [CompilerGeneratedAttribute]
private string <FullyQualifiedNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private WeakReference`1<TransportConsumer> <SourceConsumer>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string ConsumerGroup { get; }
    public string PartitionId { get; }
    private WeakReference`1<TransportConsumer> SourceConsumer { get; }
    internal PartitionContext(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, TransportConsumer consumer);
    protected internal PartitionContext(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId);
    [EditorBrowsableAttribute("1")]
protected PartitionContext(string partitionId);
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
private WeakReference`1<TransportConsumer> get_SourceConsumer();
    public virtual LastEnqueuedEventProperties ReadLastEnqueuedEventProperties();
}
public class Azure.Messaging.EventHubs.Consumer.PartitionEvent : ValueType {
    [CompilerGeneratedAttribute]
private PartitionContext <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private EventData <Data>k__BackingField;
    public PartitionContext Partition { get; }
    public EventData Data { get; }
    public PartitionEvent(PartitionContext partition, EventData data);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PartitionContext get_Partition();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public EventData get_Data();
}
public class Azure.Messaging.EventHubs.Consumer.ReadEventOptions : object {
    private Nullable`1<TimeSpan> _maximumWaitTime;
    private int _cacheEventCount;
    private int _prefetchCount;
    private Nullable`1<long> _prefetchSizeInBytes;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <OwnerLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackLastEnqueuedEventProperties>k__BackingField;
    public Nullable`1<long> OwnerLevel { get; public set; }
    public bool TrackLastEnqueuedEventProperties { get; public set; }
    public Nullable`1<TimeSpan> MaximumWaitTime { get; public set; }
    public int CacheEventCount { get; public set; }
    public int PrefetchCount { get; public set; }
    public Nullable`1<long> PrefetchSizeInBytes { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_OwnerLevel();
    [CompilerGeneratedAttribute]
public void set_OwnerLevel(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_TrackLastEnqueuedEventProperties();
    [CompilerGeneratedAttribute]
public void set_TrackLastEnqueuedEventProperties(bool value);
    public Nullable`1<TimeSpan> get_MaximumWaitTime();
    public void set_MaximumWaitTime(Nullable`1<TimeSpan> value);
    public int get_CacheEventCount();
    public void set_CacheEventCount(int value);
    public int get_PrefetchCount();
    public void set_PrefetchCount(int value);
    public Nullable`1<long> get_PrefetchSizeInBytes();
    public void set_PrefetchSizeInBytes(Nullable`1<long> value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal ReadEventOptions Clone();
}
internal class Azure.Messaging.EventHubs.Core.BasicRetryPolicy : EventHubsRetryPolicy {
    private static int s_randomSeed;
    private static ThreadLocal`1<Random> RandomNumberGenerator;
    private static double MaximumTimeSpanSeconds;
    [CompilerGeneratedAttribute]
private EventHubsRetryOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private double <JitterFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumThrottleSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumThrottleSeconds>k__BackingField;
    public EventHubsRetryOptions Options { get; }
    public double JitterFactor { get; }
    public int MinimumThrottleSeconds { get; }
    public int MaximumThrottleSeconds { get; }
    public BasicRetryPolicy(EventHubsRetryOptions retryOptions);
    private static BasicRetryPolicy();
    [CompilerGeneratedAttribute]
public EventHubsRetryOptions get_Options();
    [CompilerGeneratedAttribute]
public double get_JitterFactor();
    [CompilerGeneratedAttribute]
public int get_MinimumThrottleSeconds();
    [CompilerGeneratedAttribute]
public int get_MaximumThrottleSeconds();
    public virtual TimeSpan CalculateTryTimeout(int attemptCount);
    public virtual Nullable`1<TimeSpan> CalculateRetryDelay(Exception lastException, int attemptCount);
    private static bool ShouldRetryException(Exception exception);
    private static bool IsThrottleException(Exception exception);
    private static TimeSpan CalculateExponentialDelay(int attemptCount, double baseDelaySeconds, double baseJitterSeconds, Random random);
    private static TimeSpan CalculateFixedDelay(double baseDelaySeconds, double baseJitterSeconds, Random random);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.CancellationTokenExtensions : object {
    [ExtensionAttribute]
public static void ThrowIfCancellationRequested(CancellationToken instance);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.ChannelReaderExtensions : object {
    [AsyncIteratorStateMachineAttribute("Azure.Messaging.EventHubs.Core.ChannelReaderExtensions/<EnumerateChannel>d__0`1")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<T> EnumerateChannel(ChannelReader`1<T> reader, Nullable`1<TimeSpan> maximumWaitTime, CancellationToken cancellationToken);
}
internal class Azure.Messaging.EventHubs.Core.ClientLibraryInformation : object {
    [CompilerGeneratedAttribute]
private static ClientLibraryInformation <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2[] <SerializedProperties>k__BackingField;
    public static ClientLibraryInformation Current { get; }
    public string Product { get; }
    public string Version { get; }
    public string Framework { get; }
    public string Platform { get; }
    [DescriptionAttribute("user-agent")]
public string UserAgent { get; }
    public KeyValuePair`2[] SerializedProperties { get; }
    private static ClientLibraryInformation();
    [CompilerGeneratedAttribute]
public static ClientLibraryInformation get_Current();
    [CompilerGeneratedAttribute]
public string get_Product();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_Framework();
    [CompilerGeneratedAttribute]
public string get_Platform();
    public string get_UserAgent();
    [CompilerGeneratedAttribute]
public KeyValuePair`2[] get_SerializedProperties();
    private static KeyValuePair`2[] SerializeProperties(ClientLibraryInformation self);
    private static string GetTelemetryName(MemberInfo property);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.EncodingExtensions : object {
    [ExtensionAttribute]
public static int GetBytes(Encoding encoding, ReadOnlySpan`1<char> src, Span`1<byte> dest);
    [ExtensionAttribute]
public static int GetByteCount(Encoding encoding, ReadOnlySpan`1<char> src);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.EventHubConnectionOptionsExtensions : object {
    [ExtensionAttribute]
public static EventHubConnectionOptions Clone(EventHubConnectionOptions instance);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.EventHubsExceptionExtensions : object {
    private static string FailureDataKey;
    private static string FailureOperationKey;
    [ExtensionAttribute]
public static T GetFailureData(EventHubsException instance);
    [ExtensionAttribute]
public static string GetFailureOperation(EventHubsException instance);
    [ExtensionAttribute]
public static void SetFailureData(EventHubsException instance, T data);
    [ExtensionAttribute]
public static void SetFailureOperation(EventHubsException instance, string operationName);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.EventHubsRetryOptionsExtensions : object {
    [ExtensionAttribute]
public static EventHubsRetryOptions Clone(EventHubsRetryOptions instance);
    [ExtensionAttribute]
public static EventHubsRetryPolicy ToRetryPolicy(EventHubsRetryOptions instance);
    [ExtensionAttribute]
public static bool IsEquivalentTo(EventHubsRetryOptions instance, EventHubsRetryOptions other);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.ExceptionExtensions : object {
    [ExtensionAttribute]
public static bool IsNotType(Exception instance);
    [ExtensionAttribute]
public static bool IsFatalException(Exception instance);
}
internal class Azure.Messaging.EventHubs.Core.PartitionResolver : object {
    private int _partitionAssignmentIndex;
    public virtual string AssignRoundRobin(String[] partitions);
    public virtual string AssignForPartitionKey(string partitionKey, String[] partitions);
    [SkipLocalsInitAttribute]
private static short GenerateHashCode(string partitionKey);
    private static void ComputeHash(ReadOnlySpan`1<byte> data, UInt32 seed1, UInt32 seed2, UInt32& hash1, UInt32& hash2);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.TimeSpanExtensions : object {
    [ExtensionAttribute]
public static TimeSpan CalculateRemaining(TimeSpan instance, TimeSpan elapsed);
}
internal abstract class Azure.Messaging.EventHubs.Core.TransportClient : object {
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ServiceEndpoint>k__BackingField;
    public bool IsClosed { get; }
    public Uri ServiceEndpoint { get; }
    [CompilerGeneratedAttribute]
public virtual bool get_IsClosed();
    [CompilerGeneratedAttribute]
public virtual Uri get_ServiceEndpoint();
    public abstract virtual Task`1<EventHubProperties> GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken);
    public abstract virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(string partitionId, EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken);
    public abstract virtual TransportProducer CreateProducer(string partitionId, string producerIdentifier, TransportProducerFeatures requestedFeatures, PartitionPublishingOptions partitionOptions, EventHubsRetryPolicy retryPolicy);
    public abstract virtual TransportConsumer CreateConsumer(string consumerGroup, string partitionId, string consumerIdentifier, EventPosition eventPosition, EventHubsRetryPolicy retryPolicy, bool trackLastEnqueuedEventProperties, bool invalidateConsumerWhenPartitionStolen, Nullable`1<long> ownerLevel, Nullable`1<UInt32> prefetchCount, Nullable`1<long> prefetchSizeInBytes);
    public abstract virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Core.TransportClient/<DisposeAsync>d__11")]
public virtual ValueTask DisposeAsync();
}
internal abstract class Azure.Messaging.EventHubs.Core.TransportConsumer : object {
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private EventData <LastReceivedEvent>k__BackingField;
    public bool IsClosed { get; }
    public EventData LastReceivedEvent { get; protected set; }
    [CompilerGeneratedAttribute]
public virtual bool get_IsClosed();
    [CompilerGeneratedAttribute]
public EventData get_LastReceivedEvent();
    [CompilerGeneratedAttribute]
protected void set_LastReceivedEvent(EventData value);
    public abstract virtual Task`1<IReadOnlyList`1<EventData>> ReceiveAsync(int maximumEventCount, Nullable`1<TimeSpan> maximumWaitTime, CancellationToken cancellationToken);
    public abstract virtual Task CloseAsync(CancellationToken cancellationToken);
}
internal abstract class Azure.Messaging.EventHubs.Core.TransportEventBatch : object {
    public long MaximumSizeInBytes { get; }
    public long SizeInBytes { get; }
    public TransportProducerFeatures ActiveFeatures { get; }
    public int Count { get; }
    public Nullable`1<int> StartingSequenceNumber { get; }
    public abstract virtual long get_MaximumSizeInBytes();
    public abstract virtual long get_SizeInBytes();
    public abstract virtual TransportProducerFeatures get_ActiveFeatures();
    public abstract virtual int get_Count();
    public abstract virtual Nullable`1<int> get_StartingSequenceNumber();
    public abstract virtual bool TryAdd(EventData eventData);
    public abstract virtual void Clear();
    public abstract virtual IReadOnlyCollection`1<T> AsReadOnlyCollection();
    public abstract virtual int ApplyBatchSequencing(int lastSequenceNumber, Nullable`1<long> producerGroupId, Nullable`1<short> ownerLevel);
    public abstract virtual void ResetBatchSequencing();
    public abstract virtual void Dispose();
}
internal abstract class Azure.Messaging.EventHubs.Core.TransportProducer : object {
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    public bool IsClosed { get; }
    [CompilerGeneratedAttribute]
public virtual bool get_IsClosed();
    public abstract virtual Task SendAsync(IReadOnlyCollection`1<EventData> events, SendEventOptions sendOptions, CancellationToken cancellationToken);
    public abstract virtual Task SendAsync(EventDataBatch eventBatch, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<TransportEventBatch> CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<PartitionPublishingProperties> ReadInitializationPublishingPropertiesAsync(CancellationToken cancellationToken);
    public abstract virtual Task CloseAsync(CancellationToken cancellationToken);
}
[FlagsAttribute]
internal enum Azure.Messaging.EventHubs.Core.TransportProducerFeatures : Enum {
    public byte value__;
    public static TransportProducerFeatures None;
    public static TransportProducerFeatures IdempotentPublishing;
}
internal class Azure.Messaging.EventHubs.Core.TransportProducerPool : object {
    private static TimeSpan DefaultPerformExpirationPeriod;
    [CompilerGeneratedAttribute]
private TransportProducer <EventHubProducer>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, PoolItem> <Pool>k__BackingField;
    [CompilerGeneratedAttribute]
private Timer <ExpirationTimer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, TransportProducer> <TransportProducerFactory>k__BackingField;
    public TransportProducer EventHubProducer { get; }
    private ConcurrentDictionary`2<string, PoolItem> Pool { get; }
    private Timer ExpirationTimer { get; }
    private Func`2<string, TransportProducer> TransportProducerFactory { get; }
    public TransportProducerPool(Func`2<string, TransportProducer> transportProducerFactory, ConcurrentDictionary`2<string, PoolItem> pool, Nullable`1<TimeSpan> performExpirationPeriod, TransportProducer eventHubProducer);
    private static TransportProducerPool();
    [CompilerGeneratedAttribute]
public TransportProducer get_EventHubProducer();
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, PoolItem> get_Pool();
    [CompilerGeneratedAttribute]
private Timer get_ExpirationTimer();
    [CompilerGeneratedAttribute]
private Func`2<string, TransportProducer> get_TransportProducerFactory();
    public virtual PooledProducer GetPooledProducer(string partitionId, Nullable`1<TimeSpan> removeAfterDuration);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Core.TransportProducerPool/<ExpirePooledProducerAsync>d__16")]
public virtual Task ExpirePooledProducerAsync(string partitionId, bool forceClose);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Core.TransportProducerPool/<CloseAsync>d__17")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    private TimerCallback CreateExpirationTimerCallback();
    [CompilerGeneratedAttribute]
private void <CreateExpirationTimerCallback>b__18_0(object _);
}
[ExtensionAttribute]
internal static class Azure.Messaging.EventHubs.Core.TransportTypeExtensions : object {
    private static string AmqpTlsUriScheme;
    private static string AmqpInsecureUriScheme;
    [ExtensionAttribute]
public static string GetUriScheme(EventHubsTransportType instance, bool useTls);
    [ExtensionAttribute]
public static bool IsWebSocketTransport(EventHubsTransportType instance);
}
internal class Azure.Messaging.EventHubs.DeveloperCodeException : Exception {
    public DeveloperCodeException(Exception innerException);
}
internal static class Azure.Messaging.EventHubs.Diagnostics.DiagnosticProperty : object {
    public static string DiagnosticNamespace;
    public static string ResourceProviderNamespace;
    public static string EnqueuedTimeAttribute;
    public static string EventHubsServiceContext;
    public static string KindAttribute;
    public static string ProducerKind;
    public static string ClientKind;
    public static string ConsumerKind;
    [CompilerGeneratedAttribute]
private static string <EventActivityName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProducerActivityName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <EventProcessorProcessingActivityName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <EventProcessorCheckpointActivityName>k__BackingField;
    public static string EventActivityName { get; }
    public static string ProducerActivityName { get; }
    public static string EventProcessorProcessingActivityName { get; }
    public static string EventProcessorCheckpointActivityName { get; }
    private static DiagnosticProperty();
    [CompilerGeneratedAttribute]
public static string get_EventActivityName();
    [CompilerGeneratedAttribute]
public static string get_ProducerActivityName();
    [CompilerGeneratedAttribute]
public static string get_EventProcessorProcessingActivityName();
    [CompilerGeneratedAttribute]
public static string get_EventProcessorCheckpointActivityName();
}
[EventSourceAttribute]
internal class Azure.Messaging.EventHubs.Diagnostics.EventHubsEventSource : AzureEventSource {
    private static string EventSourceName;
    [CompilerGeneratedAttribute]
private static EventHubsEventSource <Log>k__BackingField;
    public static EventHubsEventSource Log { get; }
    private static EventHubsEventSource();
    [CompilerGeneratedAttribute]
public static EventHubsEventSource get_Log();
    [EventAttribute("1")]
public virtual void EventHubClientCreateStart(string eventHubsNamespace, string eventHubName);
    [EventAttribute("2")]
public virtual void EventHubClientCreateComplete(string eventHubsNamespace, string eventHubName);
    [EventAttribute("3")]
public virtual void EventPublishStart(string eventHubName, string partitionIdOrKey, string operationId);
    [EventAttribute("4")]
public virtual void EventPublishComplete(string eventHubName, string partitionIdOrKey, string operationId, int retryCount, double durationSeconds);
    [EventAttribute("5")]
public virtual void EventPublishError(string eventHubName, string partitionIdOrKey, string operationId, string errorMessage);
    [EventAttribute("6")]
public virtual void EventReceiveStart(string eventHubName, string consumerGroup, string partitionId, string operationId);
    [EventAttribute("7")]
public virtual void EventReceiveComplete(string eventHubName, string consumerGroup, string partitionId, string operationId, int retryCount, int eventCount, double durationSeconds, string startingSequenceNumber, string endingSequenceNumber, int maximumBatchSize, double maximumWaitTime);
    [EventAttribute("8")]
public virtual void EventReceiveError(string eventHubName, string consumerGroup, string partitionId, string operationId, string errorMessage);
    [EventAttribute("9")]
public virtual void ClientCloseStart(string clientTypeName, string eventHubName, string clientId);
    [EventAttribute("10")]
public virtual void ClientCloseComplete(string clientTypeName, string eventHubName, string clientId);
    [EventAttribute("11")]
public virtual void ClientCloseError(string clientTypeName, string eventHubName, string clientId, string errorMessage);
    [EventAttribute("12")]
public virtual void GetPropertiesStart(string eventHubName);
    [EventAttribute("13")]
public virtual void GetPropertiesComplete(string eventHubName);
    [EventAttribute("14")]
public virtual void GetPropertiesError(string eventHubName, string errorMessage);
    [EventAttribute("15")]
public virtual void GetPartitionPropertiesStart(string eventHubName, string partitionId);
    [EventAttribute("16")]
public virtual void GetPartitionPropertiesComplete(string eventHubName, string partitionId);
    [EventAttribute("17")]
public virtual void GetPartitionPropertiesError(string eventHubName, string partitionId, string errorMessage);
    [EventAttribute("18")]
public virtual void PublishPartitionEventsToChannelStart(string eventHubName, string partitionId);
    [EventAttribute("19")]
public virtual void PublishPartitionEventsToChannelComplete(string eventHubName, string partitionId);
    [EventAttribute("20")]
public virtual void PublishPartitionEventsToChannelError(string eventHubName, string partitionId, string errorMessage);
    [EventAttribute("21")]
public virtual void ReadEventsFromPartitionStart(string eventHubName, string partitionId);
    [EventAttribute("22")]
public virtual void ReadEventsFromPartitionComplete(string eventHubName, string partitionId);
    [EventAttribute("23")]
public virtual void ReadEventsFromPartitionError(string eventHubName, string partitionId, string errorMessage);
    [EventAttribute("24")]
public virtual void ReadAllEventsStart(string eventHubName);
    [EventAttribute("25")]
public virtual void ReadAllEventsComplete(string eventHubName);
    [EventAttribute("26")]
public virtual void ReadAllEventsError(string eventHubName, string errorMessage);
    [EventAttribute("27")]
public virtual void AmqpLinkAuthorizationRefreshStart(string eventHubName, string endpoint);
    [EventAttribute("28")]
public virtual void AmqpLinkAuthorizationRefreshComplete(string eventHubName, string endpoint);
    [EventAttribute("29")]
public virtual void AmqpLinkAuthorizationRefreshError(string eventHubName, string endpoint, string errorMessage);
    [EventAttribute("30")]
public virtual void EventProcessorStart(string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("31")]
public virtual void EventProcessorStartComplete(string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("32")]
public virtual void EventProcessorStartError(string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("33")]
public virtual void EventProcessorStop(string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("34")]
public virtual void EventProcessorStopComplete(string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("35")]
public virtual void EventProcessorStopError(string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("36")]
public virtual void EventProcessorTaskError(string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("37")]
public virtual void EventProcessorPartitionProcessingStart(string partitionId, string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("38")]
public virtual void EventProcessorPartitionProcessingStartError(string partitionId, string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("39")]
public virtual void EventProcessorPartitionProcessingStartComplete(string partitionId, string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("40")]
public virtual void EventProcessorPartitionProcessingStop(string partitionId, string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("41")]
public virtual void EventProcessorPartitionProcessingStopError(string partitionId, string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("42")]
public virtual void EventProcessorPartitionProcessingStopComplete(string partitionId, string identifier, string eventHubName, string consumerGroup, double durationSeconds);
    [EventAttribute("43")]
public virtual void EventProcessorPartitionProcessingError(string partitionId, string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("44")]
public virtual void EventProcessorLoadBalancingError(string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("45")]
public virtual void EventProcessorClaimOwnershipError(string identifier, string eventHubName, string consumerGroup, string partitionId, string errorMessage);
    [EventAttribute("46")]
public virtual void IdempotentPublishStart(string eventHubName, string partitionId);
    [EventAttribute("47")]
public virtual void IdempotentSynchronizationAcquire(string eventHubName, string partitionId);
    [EventAttribute("48")]
public virtual void IdempotentSynchronizationRelease(string eventHubName, string partitionId);
    [EventAttribute("49")]
public virtual void IdempotentSequencePublish(string eventHubName, string partitionId, long startSequenceNumber, long endSequenceNumber);
    [EventAttribute("50")]
public virtual void IdempotentSequenceUpdate(string eventHubName, string partitionId, long oldSequenceNumber, long newSequenceNumber);
    [EventAttribute("51")]
public virtual void IdempotentPublishComplete(string eventHubName, string partitionId);
    [EventAttribute("52")]
public virtual void IdempotentPublishError(string eventHubName, string partitionId, string errorMessage);
    [EventAttribute("53")]
public virtual void IdempotentPublishInitializeState(string eventHubName, string partitionId, long producerGroupId, short ownerLevel, long lastPublishedSequence);
    [EventAttribute("54")]
public virtual void EventProcessorPartitionProcessingStopConsumerClose(string partitionId, string identifier, string eventHubName, string consumerGroup);
    [EventAttribute("55")]
public virtual void FaultTolerantAmqpObjectClose(string objectTypeName, string identifier, string eventHubName, string consumerGroup, string partitionId, string errorMessage);
    [EventAttribute("56")]
public virtual void AmqpConnectionCreateStart(string endpoint, string transportType);
    [EventAttribute("57")]
public virtual void AmqpConnectionCreateComplete(string endpoint, string transportType);
    [EventAttribute("58")]
public virtual void AmqpConnectionCreateStartError(string endpoint, string transportType, string errorMessage);
    [EventAttribute("59")]
public virtual void AmqpManagementLinkCreateStart(string eventHubName);
    [EventAttribute("60")]
public virtual void AmqpManagementLinkCreateComplete(string eventHubName);
    [EventAttribute("61")]
public virtual void AmqpManagementLinkCreateError(string eventHubName, string errorMessage);
    [EventAttribute("62")]
public virtual void AmqpConsumerLinkCreateStart(string eventHubName, string consumerGroup, string partitionId, string ownerLevel, string eventPosition, string identifier);
    [EventAttribute("63")]
public virtual void AmqpConsumerLinkCreateComplete(string eventHubName, string consumerGroup, string partitionId, string ownerLevel, string eventPosition, string identifier);
    [EventAttribute("64")]
public virtual void AmqpConsumerLinkCreateError(string eventHubName, string consumerGroup, string partitionId, string ownerLevel, string eventPosition, string errorMessage, string identifier);
    [EventAttribute("65")]
public virtual void AmqpProducerLinkCreateStart(string eventHubName, string partitionId, string featureSet, string identifier);
    [EventAttribute("66")]
public virtual void AmqpProducerLinkCreateComplete(string eventHubName, string partitionId, string featureSet, string identifier);
    [EventAttribute("67")]
public virtual void AmqpProducerLinkCreateError(string eventHubName, string partitionId, string featureSet, string errorMessage, string identifier);
    [EventAttribute("68")]
public virtual void AmqpConsumerLinkCreateCapturedErrorThrow(string eventHubName, string consumerGroup, string partitionId, string ownerLevel, string eventPosition, string errorMessage, string identifier);
    [EventAttribute("69")]
public virtual void AmqpConsumerLinkFaultCapture(string eventHubName, string consumerGroup, string partitionId, string errorMessage);
    [EventAttribute("70")]
public virtual void BufferedProducerBackgroundProcessingStart(string identifier, string eventHubName);
    [EventAttribute("71")]
public virtual void BufferedProducerBackgroundProcessingStartComplete(string identifier, string eventHubName);
    [EventAttribute("72")]
public virtual void BufferedProducerBackgroundProcessingStartError(string identifier, string eventHubName, string errorMessage);
    [EventAttribute("73")]
public virtual void BufferedProducerBackgroundProcessingStop(string identifier, string eventHubName);
    [EventAttribute("74")]
public virtual void BufferedProducerBackgroundProcessingStopComplete(string identifier, string eventHubName);
    [EventAttribute("75")]
public virtual void BufferedProducerBackgroundProcessingStopError(string identifier, string eventHubName, string errorMessage);
    [EventAttribute("76")]
public virtual void BufferedProducerManagementTaskError(string identifier, string eventHubName, string errorMessage);
    [EventAttribute("77")]
public virtual void BufferedProducerEventEnqueueStart(string identifier, string eventHubName, string partitionIdOrKey, string operationId);
    [EventAttribute("78")]
public virtual void BufferedProducerEventEnqueueComplete(string identifier, string eventHubName, string partitionIdOrKey, string operationId);
    [EventAttribute("79")]
public virtual void BufferedProducerEventEnqueueError(string identifier, string eventHubName, string partitionIdOrKey, string operationId, string errorMessage);
    [EventAttribute("80")]
public virtual void BufferedProducerEventEnqueued(string identifier, string eventHubName, string requestedPartitionIdOrKey, string assignedPartitionId, string operationId, int totalBufferedEventCount);
    [EventAttribute("81")]
public virtual void BufferedProducerPublishingTaskInitialStart(string identifier, string eventHubName);
    [EventAttribute("82")]
public virtual void BufferedProducerPublishingTaskRestart(string identifier, string eventHubName);
    [EventAttribute("83")]
public virtual void BufferedProducerPublishingTaskError(string identifier, string eventHubName, string errorMessage);
    [EventAttribute("84")]
public virtual void BufferedProducerManagementCycleStart(string identifier, string eventHubName);
    [EventAttribute("85")]
public virtual void BufferedProducerManagementCycleComplete(string identifier, string eventHubName, int totalPartitionCount, double durationSeconds, double delaySeconds);
    [EventAttribute("86")]
public virtual void BufferedProducerPublishingAwaitStart(string identifier, string eventHubName, int totalActiveTasks, string operationId);
    [EventAttribute("87")]
public virtual void BufferedProducerPublishingAwaitComplete(string identifier, string eventHubName, int totalActiveTasks, string operationId, double durationSeconds);
    [EventAttribute("88")]
public virtual void BufferedProducerEventBatchPublishStart(string identifier, string eventHubName, string partitionId, string operationId);
    [EventAttribute("89")]
public virtual void BufferedProducerEventBatchPublishComplete(string identifier, string eventHubName, string partitionId, string operationId, int eventCount, double durationSeconds);
    [EventAttribute("90")]
public virtual void BufferedProducerEventBatchPublishError(string identifier, string eventHubName, string partitionId, string operationId, string errorMessage);
    [EventAttribute("91")]
public virtual void BufferedProducerEventBatchPublishEventAdded(string identifier, string eventHubName, string partitionId, string operationId, int eventCount, double durationSeconds);
    [EventAttribute("92")]
public virtual void BufferedProducerEventBatchPublishNoEventRead(string identifier, string eventHubName, string partitionId, string operationId, double delayDurationSeconds, double totalDurationSeconds);
    [EventAttribute("93")]
public virtual void BufferedProducerNoPublishEventHandler(string identifier, string eventHubName, string partitionId, string handlerCallerName);
    [EventAttribute("94")]
public virtual void BufferedProducerOnSendSucceededStart(string identifier, string eventHubName, string partitionId, string operationId);
    [EventAttribute("95")]
public virtual void BufferedProducerOnSendSucceededError(string identifier, string eventHubName, string partitionId, string operationId, string errorMessage);
    [EventAttribute("96")]
public virtual void BufferedProducerOnSendSucceededComplete(string identifier, string eventHubName, string partitionId, string operationId);
    [EventAttribute("97")]
public virtual void BufferedProducerOnSendFailedStart(string identifier, string eventHubName, string partitionId, string operationId);
    [EventAttribute("98")]
public virtual void BufferedProducerOnSendFailedError(string identifier, string eventHubName, string partitionId, string operationId, string errorMessage);
    [EventAttribute("99")]
public virtual void BufferedProducerOnSendFailedComplete(string identifier, string eventHubName, string partitionId, string operationId);
    [EventAttribute("100")]
public void UnexpectedException(string errorMessage);
    [EventAttribute("101")]
public virtual void EventProcessorLoadBalancingCycleStart(string identifier, string eventHubName, int totalPartitionCount, int ownedPartitionCount);
    [EventAttribute("102")]
public virtual void EventProcessorLoadBalancingCycleComplete(string identifier, string eventHubName, int totalPartitionCount, int ownedPartitionCount, double durationSeconds, double delaySeconds);
    [NonEventAttribute]
public virtual void EventProcessorLoadBalancingCycleSlowWarning(string identifier, string eventHubName, double durationSeconds, double loadBalancingIntervalSeconds);
    [NonEventAttribute]
public virtual void EventProcessorHighPartitionOwnershipWarning(string identifier, string eventHubName, int totalPartitionCount, int ownedPartitionCount, int maximumAdvisedCount);
    [NonEventAttribute]
public virtual void EventProcessorPartitionProcessingEventPositionDetermined(string identifier, string eventHubName, string consumerGroup, string partitionId, string startingPosition, bool checkpointUsed, string authorIdentifier, Nullable`1<DateTimeOffset> lastModified);
    [EventAttribute("106")]
public virtual void BufferedProducerPublishingManagementStart(string identifier, string eventHubName, string operationId);
    [EventAttribute("107")]
public virtual void BufferedProducerPublishingManagementError(string identifier, string eventHubName, string operationId, string errorMessage);
    [EventAttribute("108")]
public virtual void BufferedProducerPublishingManagementComplete(string identifier, string eventHubName, string operationId);
    [EventAttribute("109")]
public virtual void BufferedProducerPublishingAwaitAllStart(string identifier, string eventHubName, int totalActiveTasks, string operationId);
    [EventAttribute("110")]
public virtual void BufferedProducerPublishingAwaitAllComplete(string identifier, string eventHubName, int totalActiveTasks, string operationId, double durationSeconds);
    [EventAttribute("111")]
public virtual void BufferedProducerFlushStart(string identifier, string eventHubName, string operationId);
    [EventAttribute("112")]
public virtual void BufferedProducerFlushError(string identifier, string eventHubName, string operationId, string errorMessage);
    [EventAttribute("113")]
public virtual void BufferedProducerFlushComplete(string identifier, string eventHubName, string operationId);
    [EventAttribute("114")]
public virtual void BufferedProducerClearStart(string identifier, string eventHubName, string operationId);
    [EventAttribute("115")]
public virtual void BufferedProducerClearError(string identifier, string eventHubName, string operationId, string errorMessage);
    [EventAttribute("116")]
public virtual void BufferedProducerClearComplete(string identifier, string eventHubName, string operationId);
    [EventAttribute("117")]
public virtual void BufferedProducerDrainStart(string identifier, string eventHubName, string partitionId, string operationId);
    [EventAttribute("118")]
public virtual void BufferedProducerDrainError(string identifier, string eventHubName, string partitionId, string operationId, string errorMessage);
    [EventAttribute("119")]
public virtual void BufferedProducerDrainComplete(string identifier, string eventHubName, string partitionId, string operationId);
    [EventAttribute("120")]
public virtual void ProcessorStoppingCancellationWarning(string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("121")]
public virtual void PartitionProcessorStoppingCancellationWarning(string partitionId, string identifier, string eventHubName, string consumerGroup, string errorMessage);
    [EventAttribute("122")]
public virtual void BufferedProducerThrottleDelay(string identifier, string eventHubName, string partitionId, string operationId, double backOffSeconds, int backOffCount);
    [EventAttribute("123")]
public virtual void EventProcessorProcessingHandlerStart(string partitionId, string identifier, string eventHubName, string consumerGroup, string operationId, int eventCount, string startingSequenceNumber, string endingSequenceNumber);
    [EventAttribute("124")]
public virtual void EventProcessorProcessingHandlerComplete(string partitionId, string identifier, string eventHubName, string consumerGroup, string operationId, double durationSeconds, int eventCount);
    [EventAttribute("125")]
public virtual void EventProcessorProcessingHandlerError(string partitionId, string identifier, string eventHubName, string consumerGroup, string operationId, string errorMessage);
    [EventAttribute("126")]
public virtual void BufferedProducerIdleStart(string identifier, string eventHubName, string operationId);
    [EventAttribute("127")]
public virtual void BufferedProducerIdleComplete(string identifier, string eventHubName, string operationId, double durationSeconds);
    [NonEventAttribute]
public virtual void ProcessorLoadBalancingIntervalsTooCloseWarning(string identifier, string eventHubName, double loadBalancingIntervalSeconds, double ownershipIntervalSeconds);
    [EventAttribute("129")]
public virtual void EventProcessorPartitionProcessingCycleComplete(string partitionId, string identifier, string eventHubName, string consumerGroup, int eventCount, string startingSequenceNumber, string endingSequenceNumber, string formattedCycleStartTime, string formattedCycleEndTime, double durationSeconds);
    [EventAttribute("130")]
public virtual void EventProcessorFatalTaskError(string identifier, string eventHubName, string consumerGroup, string errorMessage);
    public virtual string GetLogFormattedUtcNow();
    [EventAttribute("103")]
private void EventProcessorLoadBalancingCycleSlowWarningCore(string identifier, string eventHubName, double durationSeconds, double loadBalancingIntervalSeconds, string troubleshootingGuideLink);
    [EventAttribute("104")]
private void EventProcessorHighPartitionOwnershipWarningCore(string identifier, string eventHubName, int totalPartitionCount, int ownedPartitionCount, int maximumAdvisedCount, string troubleshootingGuideLink);
    [EventAttribute("105")]
private void EventProcessorPartitionProcessingEventPositionDeterminedCore(string identifier, string eventHubName, string consumerGroup, string partitionId, string startingPosition, string positionBasedOn, string authorIdentifier, string lastModified);
    [EventAttribute("128")]
private void ProcessorLoadBalancingIntervalsTooCloseWarningCore(string identifier, string eventHubName, double loadBalancingIntervalSeconds, double ownershipIntervalSeconds, string troubleshootingGuideLink);
    [NonEventAttribute]
private void EventReceiveCompleteCore(int eventId, string eventHubName, string consumerGroup, string partitionId, string operationId, int retryCount, int eventCount, double durationSeconds, string startingSequenceNumber, string endingSequenceNumber, int maximumBatchSize, double maximumWaitTime);
    [NonEventAttribute]
private void EventPublishCompleteCore(int eventId, string eventHubName, string partitionIdOrKey, string operationId, int retryCount, double durationSeconds);
    [NonEventAttribute]
private void EventProcessorLoadBalancingCycleCompleteCore(int eventId, string identifier, string eventHubName, int totalPartitionCount, int ownedPartitionCount, double durationSeconds, double delaySeconds);
    [NonEventAttribute]
private void BufferedProducerPublishingAwaitAllStartCore(int eventId, string identifier, string eventHubName, int totalActiveTasks, string operationId);
    [NonEventAttribute]
private void BufferedProducerPublishingAwaitCompleteCore(int eventId, string identifier, string eventHubName, int totalActiveTasks, string operationId, double durationSeconds);
    [NonEventAttribute]
private void BufferedProducerPublishingAwaitStartCore(int eventId, string identifier, string eventHubName, int totalActiveTasks, string operationId);
    [NonEventAttribute]
private void BufferedProducerPublishingAwaitAllCompleteCore(int eventId, string identifier, string eventHubName, int totalActiveTasks, string operationId, double durationSeconds);
    [NonEventAttribute]
private void BufferedProducerEventEnqueuedCore(int eventId, string identifier, string eventHubName, string requestedPartitionIdOrKey, string assignedPartitionId, string operationId, int totalBufferedEventCount);
    [NonEventAttribute]
private void EventProcessorProcessingHandlerStartCore(int eventId, string partitionId, string identifier, string eventHubName, string consumerGroup, string operationId, int eventCount, string startingSequenceNumber, string endingSequenceNumber);
    [NonEventAttribute]
private void EventProcessorProcessingHandlerCompleteCore(int eventId, string partitionId, string identifier, string eventHubName, string consumerGroup, string operationId, double durationSeconds, int eventCount);
    [NonEventAttribute]
private void BufferedProducerIdleCompleteCore(int eventId, string identifier, string eventHubName, string operationId, double durationSeconds);
    [NonEventAttribute]
private void EventProcessorPartitionProcessingCycleCompleteCore(int eventId, string partitionId, string identifier, string eventHubName, string consumerGroup, int eventCount, string startingSequenceNumber, string endingSequenceNumber, string formattedCycleStartTime, string formattedCycleEndTime, double durationSeconds);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, TValue1 arg3, TValue2 arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, TValue1 arg3, TValue2 arg4, TValue3 arg5);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, TValue1 arg3, TValue2 arg4, TValue3 arg5, string arg6);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, TValue1 arg5);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, TValue1 arg5, TValue2 arg6);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, TValue1 arg5, TValue2 arg6, TValue3 arg7);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, TValue1 arg3, TValue2 arg4, string arg5);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6, string arg7);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6, string arg7, string arg8);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6, string arg7, TValue1 arg8);
}
[EventSourceAttribute]
internal class Azure.Messaging.EventHubs.Diagnostics.PartitionLoadBalancerEventSource : AzureEventSource {
    private static string EventSourceName;
    [CompilerGeneratedAttribute]
private static PartitionLoadBalancerEventSource <Log>k__BackingField;
    public static PartitionLoadBalancerEventSource Log { get; }
    private static PartitionLoadBalancerEventSource();
    [CompilerGeneratedAttribute]
public static PartitionLoadBalancerEventSource get_Log();
    [EventAttribute("1")]
public virtual void MinimumPartitionsPerEventProcessor(int count);
    [EventAttribute("2")]
public virtual void CurrentOwnershipCount(int count, string identifier);
    [EventAttribute("3")]
public virtual void UnclaimedPartitions(HashSet`1<string> unclaimedPartitions);
    [EventAttribute("4")]
public virtual void ClaimOwnershipStart(string partitionId);
    [EventAttribute("5")]
public virtual void ClaimOwnershipError(string partitionId, string errorMessage);
    [EventAttribute("6")]
public virtual void ShouldStealPartition(string identifier);
    [EventAttribute("7")]
public virtual void StealPartition(string partitionId, string stolenFrom, string identifier);
    [EventAttribute("8")]
public virtual void RenewOwnershipStart(string identifier);
    [EventAttribute("9")]
public virtual void RenewOwnershipError(string identifier, string errorMessage);
    [EventAttribute("10")]
public virtual void RenewOwnershipComplete(string identifier);
}
public class Azure.Messaging.EventHubs.EventData : MessageContent {
    private AmqpAnnotatedMessage _amqpMessage;
    private IReadOnlyDictionary`2<string, object> _systemProperties;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PublishedSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PendingPublishSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <PendingProducerGroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<short> <PendingProducerOwnerLevel>k__BackingField;
    public BinaryData EventBody { get; public set; }
    public string ContentType { get; public set; }
    [EditorBrowsableAttribute("1")]
protected Nullable`1<ContentType> ContentTypeCore { get; protected set; }
    [EditorBrowsableAttribute("1")]
public BinaryData Data { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsReadOnly { get; }
    public string MessageId { get; public set; }
    public string CorrelationId { get; public set; }
    public IDictionary`2<string, object> Properties { get; }
    public IReadOnlyDictionary`2<string, object> SystemProperties { get; }
    public long SequenceNumber { get; }
    public long Offset { get; }
    public DateTimeOffset EnqueuedTime { get; }
    public string PartitionKey { get; }
    [EditorBrowsableAttribute("1")]
public ReadOnlyMemory`1<byte> Body { get; }
    [EditorBrowsableAttribute("1")]
public Stream BodyAsStream { get; }
    internal Nullable`1<long> LastPartitionSequenceNumber { get; }
    internal Nullable`1<long> LastPartitionOffset { get; }
    internal Nullable`1<DateTimeOffset> LastPartitionEnqueuedTime { get; }
    internal Nullable`1<DateTimeOffset> LastPartitionPropertiesRetrievalTime { get; }
    internal Nullable`1<int> PublishedSequenceNumber { get; private set; }
    internal Nullable`1<int> PendingPublishSequenceNumber { get; internal set; }
    internal Nullable`1<long> PendingProducerGroupId { get; internal set; }
    internal Nullable`1<short> PendingProducerOwnerLevel { get; internal set; }
    public EventData(BinaryData eventBody);
    public EventData(ReadOnlyMemory`1<byte> eventBody);
    public EventData(string eventBody);
    public EventData(AmqpAnnotatedMessage amqpMessage);
    internal EventData(BinaryData eventBody, IDictionary`2<string, object> properties, IReadOnlyDictionary`2<string, object> systemProperties, Nullable`1<long> sequenceNumber, Nullable`1<long> offset, Nullable`1<DateTimeOffset> enqueuedTime, string partitionKey, Nullable`1<long> lastPartitionSequenceNumber, Nullable`1<long> lastPartitionOffset, Nullable`1<DateTimeOffset> lastPartitionEnqueuedTime, Nullable`1<DateTimeOffset> lastPartitionPropertiesRetrievalTime, Nullable`1<int> publishedSequenceNumber, Nullable`1<int> pendingPublishSequenceNumber, Nullable`1<long> pendingProducerGroupId, Nullable`1<short> pendingOwnerLevel);
    [EditorBrowsableAttribute("1")]
protected EventData(BinaryData eventBody, IDictionary`2<string, object> properties, IReadOnlyDictionary`2<string, object> systemProperties, long sequenceNumber, long offset, DateTimeOffset enqueuedTime, string partitionKey);
    [EditorBrowsableAttribute("1")]
protected EventData(ReadOnlyMemory`1<byte> eventBody, IDictionary`2<string, object> properties, IReadOnlyDictionary`2<string, object> systemProperties, long sequenceNumber, long offset, DateTimeOffset enqueuedTime, string partitionKey);
    public BinaryData get_EventBody();
    public void set_EventBody(BinaryData value);
    public string get_ContentType();
    public void set_ContentType(string value);
    protected virtual Nullable`1<ContentType> get_ContentTypeCore();
    protected virtual void set_ContentTypeCore(Nullable`1<ContentType> value);
    public virtual BinaryData get_Data();
    public virtual void set_Data(BinaryData value);
    public virtual bool get_IsReadOnly();
    public string get_MessageId();
    public void set_MessageId(string value);
    public string get_CorrelationId();
    public void set_CorrelationId(string value);
    public IDictionary`2<string, object> get_Properties();
    public IReadOnlyDictionary`2<string, object> get_SystemProperties();
    public long get_SequenceNumber();
    public long get_Offset();
    public DateTimeOffset get_EnqueuedTime();
    public string get_PartitionKey();
    public ReadOnlyMemory`1<byte> get_Body();
    public Stream get_BodyAsStream();
    internal Nullable`1<long> get_LastPartitionSequenceNumber();
    internal Nullable`1<long> get_LastPartitionOffset();
    internal Nullable`1<DateTimeOffset> get_LastPartitionEnqueuedTime();
    internal Nullable`1<DateTimeOffset> get_LastPartitionPropertiesRetrievalTime();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_PublishedSequenceNumber();
    [CompilerGeneratedAttribute]
private void set_PublishedSequenceNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_PendingPublishSequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_PendingPublishSequenceNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_PendingProducerGroupId();
    [CompilerGeneratedAttribute]
internal void set_PendingProducerGroupId(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<short> get_PendingProducerOwnerLevel();
    [CompilerGeneratedAttribute]
internal void set_PendingProducerOwnerLevel(Nullable`1<short> value);
    public AmqpAnnotatedMessage GetRawAmqpMessage();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal void CommitPublishingState();
    internal void ClearPublishingState();
    internal EventData Clone();
}
public class Azure.Messaging.EventHubs.EventHubConnection : object {
    [CompilerGeneratedAttribute]
private static EventHubsTransportType <DefaultCredentialTransportType>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventHubsRetryPolicy <DefaultRetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullyQualifiedNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubConnectionOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportClient <InnerClient>k__BackingField;
    private static EventHubsTransportType DefaultCredentialTransportType { get; }
    private static EventHubsRetryPolicy DefaultRetryPolicy { get; }
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public bool IsClosed { get; }
    internal Uri ServiceEndpoint { get; }
    private EventHubConnectionOptions Options { get; private set; }
    private TransportClient InnerClient { get; private set; }
    public EventHubConnection(string connectionString);
    public EventHubConnection(string connectionString, EventHubConnectionOptions connectionOptions);
    public EventHubConnection(string connectionString, string eventHubName);
    public EventHubConnection(string connectionString, string eventHubName, EventHubConnectionOptions connectionOptions);
    public EventHubConnection(string fullyQualifiedNamespace, string eventHubName, AzureNamedKeyCredential credential, EventHubConnectionOptions connectionOptions);
    public EventHubConnection(string fullyQualifiedNamespace, string eventHubName, AzureSasCredential credential, EventHubConnectionOptions connectionOptions);
    public EventHubConnection(string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventHubConnectionOptions connectionOptions);
    private static EventHubConnection();
    [CompilerGeneratedAttribute]
private static EventHubsTransportType get_DefaultCredentialTransportType();
    [CompilerGeneratedAttribute]
private static EventHubsRetryPolicy get_DefaultRetryPolicy();
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    public bool get_IsClosed();
    internal Uri get_ServiceEndpoint();
    [CompilerGeneratedAttribute]
private EventHubConnectionOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(EventHubConnectionOptions value);
    [CompilerGeneratedAttribute]
private TransportClient get_InnerClient();
    [CompilerGeneratedAttribute]
private void set_InnerClient(TransportClient value);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventHubConnection/<CloseAsync>d__32")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventHubConnection/<DisposeAsync>d__33")]
public virtual ValueTask DisposeAsync();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventHubConnection/<GetPropertiesAsync>d__37")]
internal virtual Task`1<EventHubProperties> GetPropertiesAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventHubConnection/<GetPartitionIdsAsync>d__38")]
internal virtual Task`1<String[]> GetPartitionIdsAsync(EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.EventHubConnection/<GetPartitionPropertiesAsync>d__39")]
internal virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(string partitionId, EventHubsRetryPolicy retryPolicy, CancellationToken cancellationToken);
    internal virtual TransportProducer CreateTransportProducer(string partitionId, string producerIdentifier, TransportProducerFeatures requestedFeatures, PartitionPublishingOptions partitionOptions, EventHubsRetryPolicy retryPolicy);
    internal virtual TransportConsumer CreateTransportConsumer(string consumerGroup, string partitionId, string consumerIdentifier, EventPosition eventPosition, EventHubsRetryPolicy retryPolicy, bool trackLastEnqueuedEventProperties, bool invalidateConsumerWhenPartitionStolen, Nullable`1<long> ownerLevel, Nullable`1<UInt32> prefetchCount, Nullable`1<long> prefetchSizeInBytes);
    internal virtual TransportClient CreateTransportClient(string fullyQualifiedNamespace, string eventHubName, TimeSpan operationTimeout, EventHubTokenCredential credential, EventHubConnectionOptions options, bool useTls);
    internal static EventHubConnection CreateWithCredential(string fullyQualifiedNamespace, string eventHubName, TCredential credential, EventHubConnectionOptions options);
    internal static string BuildConnectionSignatureAuthorizationResource(EventHubsTransportType transportType, string fullyQualifiedNamespace, string eventHubName);
    private static SharedAccessCredential TranslateNamedKeyCredential(AzureNamedKeyCredential credential, string fullyQualifiedNamespace, string eventHubName, Nullable`1<EventHubsTransportType> transportType);
    private static void ValidateConnectionOptions(EventHubConnectionOptions connectionOptions);
}
public class Azure.Messaging.EventHubs.EventHubConnectionOptions : object {
    private TimeSpan _connectionIdleTimeout;
    [CompilerGeneratedAttribute]
private EventHubsTransportType <TransportType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendBufferSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceiveBufferSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <Proxy>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CustomEndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <CertificateValidationCallback>k__BackingField;
    public EventHubsTransportType TransportType { get; public set; }
    public TimeSpan ConnectionIdleTimeout { get; public set; }
    public int SendBufferSizeInBytes { get; public set; }
    public int ReceiveBufferSizeInBytes { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public Uri CustomEndpointAddress { get; public set; }
    public RemoteCertificateValidationCallback CertificateValidationCallback { get; public set; }
    [CompilerGeneratedAttribute]
public EventHubsTransportType get_TransportType();
    [CompilerGeneratedAttribute]
public void set_TransportType(EventHubsTransportType value);
    public TimeSpan get_ConnectionIdleTimeout();
    public void set_ConnectionIdleTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_SendBufferSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_SendBufferSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public int get_ReceiveBufferSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_ReceiveBufferSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public IWebProxy get_Proxy();
    [CompilerGeneratedAttribute]
public void set_Proxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public Uri get_CustomEndpointAddress();
    [CompilerGeneratedAttribute]
public void set_CustomEndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_CertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_CertificateValidationCallback(RemoteCertificateValidationCallback value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
public class Azure.Messaging.EventHubs.EventHubProperties : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PartitionIds>k__BackingField;
    public string Name { get; }
    public DateTimeOffset CreatedOn { get; }
    public String[] PartitionIds { get; }
    protected internal EventHubProperties(string name, DateTimeOffset createdOn, String[] partitionIds);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreatedOn();
    [CompilerGeneratedAttribute]
public String[] get_PartitionIds();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
public class Azure.Messaging.EventHubs.EventHubsConnectionStringProperties : object {
    private static string EndpointToken;
    private static string EventHubNameToken;
    private static string SharedAccessKeyNameToken;
    private static string SharedAccessKeyValueToken;
    private static string SharedAccessSignatureToken;
    private static string DevelopmentEmulatorToken;
    private static char TokenValueSeparator;
    private static char TokenValuePairDelimiter;
    private static string EventHubsEndpointSchemeName;
    private static string EventHubsEndpointScheme;
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedAccessKeyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedAccessKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedAccessSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDevelopmentEmulator>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public Uri Endpoint { get; internal set; }
    public string EventHubName { get; internal set; }
    public string SharedAccessKeyName { get; internal set; }
    public string SharedAccessKey { get; internal set; }
    public string SharedAccessSignature { get; internal set; }
    internal bool UseDevelopmentEmulator { get; internal set; }
    private static EventHubsConnectionStringProperties();
    public string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
public Uri get_Endpoint();
    [CompilerGeneratedAttribute]
internal void set_Endpoint(Uri value);
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
internal void set_EventHubName(string value);
    [CompilerGeneratedAttribute]
public string get_SharedAccessKeyName();
    [CompilerGeneratedAttribute]
internal void set_SharedAccessKeyName(string value);
    [CompilerGeneratedAttribute]
public string get_SharedAccessKey();
    [CompilerGeneratedAttribute]
internal void set_SharedAccessKey(string value);
    [CompilerGeneratedAttribute]
public string get_SharedAccessSignature();
    [CompilerGeneratedAttribute]
internal void set_SharedAccessSignature(string value);
    [CompilerGeneratedAttribute]
internal bool get_UseDevelopmentEmulator();
    [CompilerGeneratedAttribute]
internal void set_UseDevelopmentEmulator(bool value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal string ToConnectionString();
    internal void Validate(string explicitEventHubName, string connectionStringArgumentName);
    public static EventHubsConnectionStringProperties Parse(string connectionString);
    private static int CountChar(char value, ReadOnlySpan`1<char> span);
}
public class Azure.Messaging.EventHubs.EventHubsException : Exception {
    [CompilerGeneratedAttribute]
private bool <IsTransient>k__BackingField;
    [CompilerGeneratedAttribute]
private FailureReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    public bool IsTransient { get; }
    public FailureReason Reason { get; }
    public string EventHubName { get; }
    public string Message { get; }
    public EventHubsException(bool isTransient, string eventHubName);
    public EventHubsException(bool isTransient, string eventHubName, FailureReason reason);
    public EventHubsException(bool isTransient, string eventHubName, string message);
    public EventHubsException(bool isTransient, string eventHubName, string message, FailureReason reason);
    public EventHubsException(bool isTransient, string eventHubName, string message, Exception innerException);
    public EventHubsException(bool isTransient, string eventHubName, string message, FailureReason reason, Exception innerException);
    public EventHubsException(string eventHubName, string message, FailureReason reason);
    internal EventHubsException(string eventHubName, string message, FailureReason reason, Exception innerException);
    [CompilerGeneratedAttribute]
public bool get_IsTransient();
    [CompilerGeneratedAttribute]
public FailureReason get_Reason();
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    public virtual string get_Message();
    public virtual string ToString();
    private string FormatInnerException();
}
public static class Azure.Messaging.EventHubs.EventHubsModelFactory : object {
    public static EventHubProperties EventHubProperties(string name, DateTimeOffset createdOn, String[] partitionIds);
    public static PartitionProperties PartitionProperties(string eventHubName, string partitionId, bool isEmpty, long beginningSequenceNumber, long lastSequenceNumber, long lastOffset, DateTimeOffset lastEnqueuedTime);
    [EditorBrowsableAttribute("1")]
public static PartitionPublishingProperties PartitionPublishingProperties(bool isIdempotentPublishingEnabled, Nullable`1<long> producerGroupId, Nullable`1<short> ownerLevel, Nullable`1<int> lastPublishedSequenceNumber);
    public static LastEnqueuedEventProperties LastEnqueuedEventProperties(Nullable`1<long> lastSequenceNumber, Nullable`1<long> lastOffset, Nullable`1<DateTimeOffset> lastEnqueuedTime, Nullable`1<DateTimeOffset> lastReceivedTime);
    public static PartitionContext PartitionContext(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, LastEnqueuedEventProperties lastEnqueuedEventProperties);
    [EditorBrowsableAttribute("1")]
public static PartitionContext PartitionContext(string partitionId, LastEnqueuedEventProperties lastEnqueuedEventProperties);
    public static EventData EventData(BinaryData eventBody, IDictionary`2<string, object> properties, IReadOnlyDictionary`2<string, object> systemProperties, string partitionKey, long sequenceNumber, long offset, DateTimeOffset enqueuedTime);
    public static EventDataBatch EventDataBatch(long batchSizeBytes, IList`1<EventData> batchEventStore, CreateBatchOptions batchOptions, Func`2<EventData, bool> tryAddCallback);
}
public enum Azure.Messaging.EventHubs.EventHubsRetryMode : Enum {
    public int value__;
    public static EventHubsRetryMode Fixed;
    public static EventHubsRetryMode Exponential;
}
public class Azure.Messaging.EventHubs.EventHubsRetryOptions : object {
    private int _maximumRetries;
    private TimeSpan _delay;
    private TimeSpan _maximumDelay;
    private TimeSpan _tryTimeout;
    [CompilerGeneratedAttribute]
private EventHubsRetryMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy <CustomRetryPolicy>k__BackingField;
    public EventHubsRetryMode Mode { get; public set; }
    public int MaximumRetries { get; public set; }
    public TimeSpan Delay { get; public set; }
    public TimeSpan MaximumDelay { get; public set; }
    public TimeSpan TryTimeout { get; public set; }
    public EventHubsRetryPolicy CustomRetryPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public EventHubsRetryMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(EventHubsRetryMode value);
    public int get_MaximumRetries();
    public void set_MaximumRetries(int value);
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public TimeSpan get_MaximumDelay();
    public void set_MaximumDelay(TimeSpan value);
    public TimeSpan get_TryTimeout();
    public void set_TryTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public EventHubsRetryPolicy get_CustomRetryPolicy();
    [CompilerGeneratedAttribute]
public void set_CustomRetryPolicy(EventHubsRetryPolicy value);
}
public abstract class Azure.Messaging.EventHubs.EventHubsRetryPolicy : object {
    public abstract virtual TimeSpan CalculateTryTimeout(int attemptCount);
    public abstract virtual Nullable`1<TimeSpan> CalculateRetryDelay(Exception lastException, int attemptCount);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
public enum Azure.Messaging.EventHubs.EventHubsTransportType : Enum {
    public int value__;
    public static EventHubsTransportType AmqpTcp;
    public static EventHubsTransportType AmqpWebSockets;
}
public class Azure.Messaging.EventHubs.PartitionProperties : object {
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BeginningSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastEnqueuedSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastEnqueuedOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastEnqueuedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEmpty>k__BackingField;
    public string EventHubName { get; }
    public string Id { get; }
    public long BeginningSequenceNumber { get; }
    public long LastEnqueuedSequenceNumber { get; }
    public long LastEnqueuedOffset { get; }
    public DateTimeOffset LastEnqueuedTime { get; }
    public bool IsEmpty { get; }
    protected internal PartitionProperties(string eventHubName, string partitionId, bool isEmpty, long beginningSequenceNumber, long lastSequenceNumber, long lastOffset, DateTimeOffset lastEnqueuedTime);
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public long get_BeginningSequenceNumber();
    [CompilerGeneratedAttribute]
public long get_LastEnqueuedSequenceNumber();
    [CompilerGeneratedAttribute]
public long get_LastEnqueuedOffset();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastEnqueuedTime();
    [CompilerGeneratedAttribute]
public bool get_IsEmpty();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
public abstract class Azure.Messaging.EventHubs.Primitives.CheckpointStore : object {
    public abstract virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ListOwnershipAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken);
    public abstract virtual Task`1<EventProcessorCheckpoint> GetCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, CancellationToken cancellationToken);
    public virtual Task UpdateCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, long offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    public virtual Task UpdateCheckpointAsync(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, string partitionId, string clientIdentifier, CheckpointPosition startingPosition, CancellationToken cancellationToken);
}
public abstract class Azure.Messaging.EventHubs.Primitives.EventProcessor`1 : object {
    private static int MaximumFailedConsumerCount;
    private static bool InvalidateConsumerWhenPartitionIsStolen;
    private static TimeSpan MinimumLoadBalancingDelay;
    private static double LoadBalancingDurationWarnThreshold;
    private SemaphoreSlim ProcessorRunningGuard;
    private double LoadBalancingCycleMaximumExecutionSeconds;
    private int MaximumAdvisedOwnedPartitions;
    private Nullable`1<bool> _isRunningOverride;
    private Nullable`1<EventProcessorStatus> _statusOverride;
    private Task _runningProcessorTask;
    private CancellationTokenSource _runningProcessorCancellationSource;
    [CompilerGeneratedAttribute]
private string <FullyQualifiedNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsEventSource <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableBatchTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, PartitionProcessor<TPartition>> <ActivePartitionProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<EventHubConnection> <ConnectionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionLoadBalancer <LoadBalancer>k__BackingField;
    [CompilerGeneratedAttribute]
private EventProcessorOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventBatchMaximumCount>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagingClientDiagnostics <ClientDiagnostics>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string ConsumerGroup { get; }
    public string Identifier { get; }
    public bool IsRunning { get; protected set; }
    internal EventProcessorStatus Status { get; }
    internal EventHubsEventSource Logger { get; internal set; }
    protected EventHubsRetryPolicy RetryPolicy { get; }
    protected bool EnableBatchTracing { get; protected set; }
    private ConcurrentDictionary`2<string, PartitionProcessor<TPartition>> ActivePartitionProcessors { get; }
    private Func`1<EventHubConnection> ConnectionFactory { get; }
    private PartitionLoadBalancer LoadBalancer { get; }
    private EventProcessorOptions Options { get; }
    private int EventBatchMaximumCount { get; }
    private MessagingClientDiagnostics ClientDiagnostics { get; }
    internal EventProcessor`1(int eventBatchMaximumCount, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventProcessorOptions options, PartitionLoadBalancer loadBalancer);
    protected EventProcessor`1(int eventBatchMaximumCount, string consumerGroup, string connectionString, EventProcessorOptions options);
    protected EventProcessor`1(int eventBatchMaximumCount, string consumerGroup, string connectionString, string eventHubName, EventProcessorOptions options);
    protected EventProcessor`1(int eventBatchMaximumCount, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, AzureNamedKeyCredential credential, EventProcessorOptions options);
    protected EventProcessor`1(int eventBatchMaximumCount, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, AzureSasCredential credential, EventProcessorOptions options);
    protected EventProcessor`1(int eventBatchMaximumCount, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventProcessorOptions options);
    private EventProcessor`1(int eventBatchMaximumCount, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, object credential, EventProcessorOptions options, PartitionLoadBalancer loadBalancer);
    private static EventProcessor`1();
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    public bool get_IsRunning();
    protected void set_IsRunning(bool value);
    internal EventProcessorStatus get_Status();
    [CompilerGeneratedAttribute]
internal EventHubsEventSource get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(EventHubsEventSource value);
    [CompilerGeneratedAttribute]
protected EventHubsRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
protected bool get_EnableBatchTracing();
    [CompilerGeneratedAttribute]
protected void set_EnableBatchTracing(bool value);
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, PartitionProcessor<TPartition>> get_ActivePartitionProcessors();
    [CompilerGeneratedAttribute]
private Func`1<EventHubConnection> get_ConnectionFactory();
    [CompilerGeneratedAttribute]
private PartitionLoadBalancer get_LoadBalancer();
    [CompilerGeneratedAttribute]
private EventProcessorOptions get_Options();
    [CompilerGeneratedAttribute]
private int get_EventBatchMaximumCount();
    [CompilerGeneratedAttribute]
private MessagingClientDiagnostics get_ClientDiagnostics();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<StartProcessingAsync>d__65")]
public virtual Task StartProcessingAsync(CancellationToken cancellationToken);
    public virtual void StartProcessing(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<StopProcessingAsync>d__67")]
public virtual Task StopProcessingAsync(CancellationToken cancellationToken);
    public virtual void StopProcessing(CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal virtual DiagnosticScope StartUpdateCheckpointDiagnosticScope();
    internal virtual TransportConsumer CreateConsumer(string consumerGroup, string partitionId, string consumerIdentifier, EventPosition eventPosition, EventHubConnection connection, EventProcessorOptions options, bool exclusive);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<ProcessEventBatchAsync>d__74")]
internal virtual Task ProcessEventBatchAsync(TPartition partition, IReadOnlyList`1<EventData> eventBatch, bool dispatchEmptyBatches, CancellationToken cancellationToken);
    internal virtual PartitionProcessor<TPartition> CreatePartitionProcessor(TPartition partition, CancellationTokenSource cancellationSource, Nullable`1<EventPosition> startingPositionOverride);
    protected internal virtual EventHubConnection CreateConnection();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<ValidateProcessingPreconditions>d__77")]
protected internal virtual Task ValidateProcessingPreconditions(CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
protected virtual Task`1<IEnumerable`1<EventProcessorCheckpoint>> ListCheckpointsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<GetCheckpointAsync>d__79")]
protected virtual Task`1<EventProcessorCheckpoint> GetCheckpointAsync(string partitionId, CancellationToken cancellationToken);
    protected virtual Task UpdateCheckpointAsync(string partitionId, long offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    protected virtual Task UpdateCheckpointAsync(string partitionId, CheckpointPosition startingPosition, CancellationToken cancellationToken);
    protected abstract virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ListOwnershipAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken);
    protected abstract virtual Task OnProcessingEventBatchAsync(IEnumerable`1<EventData> events, TPartition partition, CancellationToken cancellationToken);
    protected abstract virtual Task OnProcessingErrorAsync(Exception exception, TPartition partition, string operationDescription, CancellationToken cancellationToken);
    protected virtual Task OnInitializingPartitionAsync(TPartition partition, CancellationToken cancellationToken);
    protected virtual Task OnPartitionProcessingStoppedAsync(TPartition partition, ProcessingStoppedReason reason, CancellationToken cancellationToken);
    protected virtual LastEnqueuedEventProperties ReadLastEnqueuedEventProperties(string partitionId);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<ListPartitionIdsAsync>d__89")]
protected virtual Task`1<String[]> ListPartitionIdsAsync(EventHubConnection connection, CancellationToken cancellationToken);
    private void ReportPartitionStolen(string partitionId);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<StartProcessingInternalAsync>d__91")]
private Task StartProcessingInternalAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<StopProcessingInternalAsync>d__92")]
private Task StopProcessingInternalAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<RunProcessingAsync>d__93")]
private Task RunProcessingAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<PerformLoadBalancingAsync>d__94")]
private Task`1<TimeSpan> PerformLoadBalancingAsync(ValueStopwatch cycleDuration, String[] partitionIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<InitializePartitionForProcessingAsync>d__95")]
private Task`1<ValueTuple`2<EventPosition, EventProcessorCheckpoint>> InitializePartitionForProcessingAsync(TPartition partition, CancellationToken cancellationToken);
    private bool TryStartProcessingPartition(string partitionId, CancellationToken cancellationToken);
    private Task StopProcessingPartitionAsync(string partitionId, ProcessingStoppedReason reason, CancellationToken cancellationToken);
    private Task InvokeOnProcessingErrorAsync(Exception exception, TPartition partition, string operationDescription, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<ValidateEventHubsConnectionAsync>d__99")]
private Task ValidateEventHubsConnectionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.EventProcessor`1/<ValidateStorageConnectionAsync>d__100")]
private Task ValidateStorageConnectionAsync(CancellationToken cancellationToken);
    private Nullable`1<DiagnosticScope> StartProcessorScope(IReadOnlyList`1<EventData> eventBatch);
    internal static CheckpointStore CreateCheckpointStore(EventProcessor`1<TPartition> instance);
    private static int CalculateMaximumAdvisedOwnedPartitions();
    [CompilerGeneratedAttribute]
private Task <StartProcessingInternalAsync>b__91_0();
    [CompilerGeneratedAttribute]
private void <RunProcessingAsync>b__93_0();
    [CompilerGeneratedAttribute]
private void <RunProcessingAsync>b__93_1(Task stopTask);
}
public class Azure.Messaging.EventHubs.Primitives.EventProcessorCheckpoint : object {
    [CompilerGeneratedAttribute]
private string <FullyQualifiedNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private EventPosition <StartingPosition>k__BackingField;
    public string FullyQualifiedNamespace { get; public set; }
    public string EventHubName { get; public set; }
    public string ClientIdentifier { get; public set; }
    public string ConsumerGroup { get; public set; }
    public string PartitionId { get; public set; }
    public Nullable`1<DateTimeOffset> LastModified { get; public set; }
    public EventPosition StartingPosition { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
public void set_FullyQualifiedNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public void set_EventHubName(string value);
    [CompilerGeneratedAttribute]
public string get_ClientIdentifier();
    [CompilerGeneratedAttribute]
public void set_ClientIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public void set_ConsumerGroup(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public void set_PartitionId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public EventPosition get_StartingPosition();
    [CompilerGeneratedAttribute]
public void set_StartingPosition(EventPosition value);
}
public class Azure.Messaging.EventHubs.Primitives.EventProcessorOptions : object {
    private EventHubConnectionOptions _connectionOptions;
    private EventHubsRetryOptions _retryOptions;
    private Nullable`1<TimeSpan> _maximumWaitTime;
    private int _prefetchCount;
    private Nullable`1<long> _prefetchSizeInBytes;
    private TimeSpan _loadBalancingUpdateInterval;
    private TimeSpan _partitionOwnershipExpirationInterval;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackLastEnqueuedEventProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private EventPosition <DefaultStartingPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadBalancingStrategy <LoadBalancingStrategy>k__BackingField;
    public EventHubConnectionOptions ConnectionOptions { get; public set; }
    public EventHubsRetryOptions RetryOptions { get; public set; }
    public Nullable`1<TimeSpan> MaximumWaitTime { get; public set; }
    public int PrefetchCount { get; public set; }
    public Nullable`1<long> PrefetchSizeInBytes { get; public set; }
    public TimeSpan LoadBalancingUpdateInterval { get; public set; }
    public TimeSpan PartitionOwnershipExpirationInterval { get; public set; }
    public string Identifier { get; public set; }
    public bool TrackLastEnqueuedEventProperties { get; public set; }
    public EventPosition DefaultStartingPosition { get; public set; }
    public LoadBalancingStrategy LoadBalancingStrategy { get; public set; }
    public EventHubConnectionOptions get_ConnectionOptions();
    public void set_ConnectionOptions(EventHubConnectionOptions value);
    public EventHubsRetryOptions get_RetryOptions();
    public void set_RetryOptions(EventHubsRetryOptions value);
    public Nullable`1<TimeSpan> get_MaximumWaitTime();
    public void set_MaximumWaitTime(Nullable`1<TimeSpan> value);
    public int get_PrefetchCount();
    public void set_PrefetchCount(int value);
    public Nullable`1<long> get_PrefetchSizeInBytes();
    public void set_PrefetchSizeInBytes(Nullable`1<long> value);
    public TimeSpan get_LoadBalancingUpdateInterval();
    public void set_LoadBalancingUpdateInterval(TimeSpan value);
    public TimeSpan get_PartitionOwnershipExpirationInterval();
    public void set_PartitionOwnershipExpirationInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public bool get_TrackLastEnqueuedEventProperties();
    [CompilerGeneratedAttribute]
public void set_TrackLastEnqueuedEventProperties(bool value);
    [CompilerGeneratedAttribute]
public EventPosition get_DefaultStartingPosition();
    [CompilerGeneratedAttribute]
public void set_DefaultStartingPosition(EventPosition value);
    [CompilerGeneratedAttribute]
public LoadBalancingStrategy get_LoadBalancingStrategy();
    [CompilerGeneratedAttribute]
public void set_LoadBalancingStrategy(LoadBalancingStrategy value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal EventProcessorOptions Clone();
}
public class Azure.Messaging.EventHubs.Primitives.EventProcessorPartition : object {
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    public string PartitionId { get; protected internal set; }
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
protected internal void set_PartitionId(string value);
}
public class Azure.Messaging.EventHubs.Primitives.EventProcessorPartitionOwnership : object {
    [CompilerGeneratedAttribute]
private string <FullyQualifiedNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModifiedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string FullyQualifiedNamespace { get; public set; }
    public string EventHubName { get; public set; }
    public string ConsumerGroup { get; public set; }
    public string OwnerIdentifier { get; public set; }
    public string PartitionId { get; public set; }
    public DateTimeOffset LastModifiedTime { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
public void set_FullyQualifiedNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public void set_EventHubName(string value);
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public void set_ConsumerGroup(string value);
    [CompilerGeneratedAttribute]
public string get_OwnerIdentifier();
    [CompilerGeneratedAttribute]
public void set_OwnerIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public void set_PartitionId(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModifiedTime();
    [CompilerGeneratedAttribute]
public void set_LastModifiedTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
}
internal enum Azure.Messaging.EventHubs.Primitives.EventProcessorStatus : Enum {
    public int value__;
    public static EventProcessorStatus NotRunning;
    public static EventProcessorStatus Running;
    public static EventProcessorStatus Starting;
    public static EventProcessorStatus Stopping;
    public static EventProcessorStatus Faulted;
}
internal class Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer : object {
    private static ThreadLocal`1<Random> RandomNumberGenerator;
    private static int s_randomSeed;
    private CheckpointStore CheckpointStore;
    private Dictionary`2<string, List`1<EventProcessorPartitionOwnership>> ActiveOwnershipWithDistribution;
    [CompilerGeneratedAttribute]
private string <FullyQualifiedNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <OwnershipExpirationInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <LoadBalanceInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBalanced>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionLoadBalancerEventSource <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, EventProcessorPartitionOwnership> <InstanceOwnership>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string ConsumerGroup { get; }
    public string OwnerIdentifier { get; }
    public TimeSpan OwnershipExpirationInterval { get; }
    public TimeSpan LoadBalanceInterval { get; internal set; }
    public bool IsBalanced { get; private set; }
    public IEnumerable`1<string> OwnedPartitionIds { get; }
    public int OwnedPartitionCount { get; }
    internal PartitionLoadBalancerEventSource Logger { get; internal set; }
    private ConcurrentDictionary`2<string, EventProcessorPartitionOwnership> InstanceOwnership { get; private set; }
    public PartitionLoadBalancer(CheckpointStore checkpointStore, string identifier, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, TimeSpan ownershipExpirationInterval, TimeSpan loadBalancingInterval);
    private static PartitionLoadBalancer();
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public string get_OwnerIdentifier();
    [CompilerGeneratedAttribute]
public TimeSpan get_OwnershipExpirationInterval();
    [CompilerGeneratedAttribute]
public TimeSpan get_LoadBalanceInterval();
    [CompilerGeneratedAttribute]
internal void set_LoadBalanceInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsBalanced();
    [CompilerGeneratedAttribute]
private void set_IsBalanced(bool value);
    public virtual IEnumerable`1<string> get_OwnedPartitionIds();
    public virtual int get_OwnedPartitionCount();
    [CompilerGeneratedAttribute]
internal PartitionLoadBalancerEventSource get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(PartitionLoadBalancerEventSource value);
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, EventProcessorPartitionOwnership> get_InstanceOwnership();
    [CompilerGeneratedAttribute]
private void set_InstanceOwnership(ConcurrentDictionary`2<string, EventProcessorPartitionOwnership> value);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer/<RunLoadBalancingAsync>d__41")]
public virtual ValueTask`1<EventProcessorPartitionOwnership> RunLoadBalancingAsync(String[] partitionIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer/<RelinquishOwnershipAsync>d__42")]
public virtual Task RelinquishOwnershipAsync(CancellationToken cancellationToken);
    public virtual void ReportPartitionStolen(string partitionId);
    public virtual bool IsPartitionOwned(string partitionId);
    private ValueTask`1<ValueTuple`2<bool, EventProcessorPartitionOwnership>> FindAndClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> completeOwnershipEnumerable, HashSet`1<string> unclaimedPartitions, int partitionCount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer/<RenewOwnershipAsync>d__46")]
private Task RenewOwnershipAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionLoadBalancer/<ClaimOwnershipAsync>d__47")]
private Task`1<ValueTuple`2<bool, EventProcessorPartitionOwnership>> ClaimOwnershipAsync(string partitionId, IEnumerable`1<EventProcessorPartitionOwnership> completeOwnershipEnumerable, CancellationToken cancellationToken);
    internal virtual DateTimeOffset GetDateTimeOffsetNow();
}
public class Azure.Messaging.EventHubs.Primitives.PartitionReceiver : object {
    private static bool InvalidateConsumerWhenPartitionIsStolen;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closed;
    [CompilerGeneratedAttribute]
private string <ConsumerGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private EventPosition <InitialPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsEventSource <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OwnsConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <DefaultMaximumWaitTime>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportConsumer <InnerConsumer>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string ConsumerGroup { get; }
    public string PartitionId { get; }
    public string Identifier { get; }
    public EventPosition InitialPosition { get; }
    public bool IsClosed { get; protected set; }
    internal EventHubsEventSource Logger { get; internal set; }
    private bool OwnsConnection { get; }
    private Nullable`1<TimeSpan> DefaultMaximumWaitTime { get; }
    private EventHubsRetryPolicy RetryPolicy { get; }
    private EventHubConnection Connection { get; }
    private TransportConsumer InnerConsumer { get; }
    public PartitionReceiver(string consumerGroup, string partitionId, EventPosition eventPosition, string connectionString, PartitionReceiverOptions options);
    public PartitionReceiver(string consumerGroup, string partitionId, EventPosition eventPosition, string connectionString, string eventHubName, PartitionReceiverOptions options);
    public PartitionReceiver(string consumerGroup, string partitionId, EventPosition eventPosition, string fullyQualifiedNamespace, string eventHubName, AzureNamedKeyCredential credential, PartitionReceiverOptions options);
    public PartitionReceiver(string consumerGroup, string partitionId, EventPosition eventPosition, string fullyQualifiedNamespace, string eventHubName, AzureSasCredential credential, PartitionReceiverOptions options);
    public PartitionReceiver(string consumerGroup, string partitionId, EventPosition eventPosition, string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, PartitionReceiverOptions options);
    public PartitionReceiver(string consumerGroup, string partitionId, EventPosition eventPosition, EventHubConnection connection, PartitionReceiverOptions options);
    private PartitionReceiver(string consumerGroup, string partitionId, EventPosition eventPosition, string fullyQualifiedNamespace, string eventHubName, object credential, PartitionReceiverOptions options);
    public string get_FullyQualifiedNamespace();
    public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_ConsumerGroup();
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public EventPosition get_InitialPosition();
    public bool get_IsClosed();
    protected void set_IsClosed(bool value);
    [CompilerGeneratedAttribute]
internal EventHubsEventSource get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(EventHubsEventSource value);
    [CompilerGeneratedAttribute]
private bool get_OwnsConnection();
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> get_DefaultMaximumWaitTime();
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private EventHubConnection get_Connection();
    [CompilerGeneratedAttribute]
private TransportConsumer get_InnerConsumer();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionReceiver/<GetPartitionPropertiesAsync>d__48")]
public virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(CancellationToken cancellationToken);
    public virtual LastEnqueuedEventProperties ReadLastEnqueuedEventProperties();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionReceiver/<ReceiveBatchAsync>d__50")]
public virtual Task`1<IEnumerable`1<EventData>> ReceiveBatchAsync(int maximumEventCount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionReceiver/<ReceiveBatchAsync>d__51")]
public virtual Task`1<IEnumerable`1<EventData>> ReceiveBatchAsync(int maximumEventCount, TimeSpan maximumWaitTime, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionReceiver/<CloseAsync>d__52")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Primitives.PartitionReceiver/<DisposeAsync>d__53")]
public virtual ValueTask DisposeAsync();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    private Task`1<IReadOnlyList`1<EventData>> ReceiveBatchInternalAsync(int maximumEventCount, Nullable`1<TimeSpan> maximumWaitTime, CancellationToken cancellationToken);
}
public class Azure.Messaging.EventHubs.Primitives.PartitionReceiverOptions : object {
    private EventHubConnectionOptions _connectionOptions;
    private EventHubsRetryOptions _retryOptions;
    private Nullable`1<TimeSpan> _defaultMaximumReceiveWaitTime;
    private int _prefetchCount;
    private Nullable`1<long> _prefetchSizeInBytes;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <OwnerLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackLastEnqueuedEventProperties>k__BackingField;
    public EventHubConnectionOptions ConnectionOptions { get; public set; }
    public EventHubsRetryOptions RetryOptions { get; public set; }
    public Nullable`1<TimeSpan> DefaultMaximumReceiveWaitTime { get; public set; }
    public string Identifier { get; public set; }
    public Nullable`1<long> OwnerLevel { get; public set; }
    public int PrefetchCount { get; public set; }
    public Nullable`1<long> PrefetchSizeInBytes { get; public set; }
    public bool TrackLastEnqueuedEventProperties { get; public set; }
    public EventHubConnectionOptions get_ConnectionOptions();
    public void set_ConnectionOptions(EventHubConnectionOptions value);
    public EventHubsRetryOptions get_RetryOptions();
    public void set_RetryOptions(EventHubsRetryOptions value);
    public Nullable`1<TimeSpan> get_DefaultMaximumReceiveWaitTime();
    public void set_DefaultMaximumReceiveWaitTime(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_OwnerLevel();
    [CompilerGeneratedAttribute]
public void set_OwnerLevel(Nullable`1<long> value);
    public int get_PrefetchCount();
    public void set_PrefetchCount(int value);
    public Nullable`1<long> get_PrefetchSizeInBytes();
    public void set_PrefetchSizeInBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_TrackLastEnqueuedEventProperties();
    [CompilerGeneratedAttribute]
public void set_TrackLastEnqueuedEventProperties(bool value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal PartitionReceiverOptions Clone();
}
public abstract class Azure.Messaging.EventHubs.Primitives.PluggableCheckpointStoreEventProcessor`1 : EventProcessor`1<TPartition> {
    private CheckpointStore _checkpointStore;
    protected PluggableCheckpointStoreEventProcessor`1(CheckpointStore checkpointStore, int eventBatchMaximumCount, string consumerGroup, string connectionString, EventProcessorOptions options);
    protected PluggableCheckpointStoreEventProcessor`1(CheckpointStore checkpointStore, int eventBatchMaximumCount, string consumerGroup, string connectionString, string eventHubName, EventProcessorOptions options);
    protected PluggableCheckpointStoreEventProcessor`1(CheckpointStore checkpointStore, int eventBatchMaximumCount, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, AzureNamedKeyCredential credential, EventProcessorOptions options);
    protected PluggableCheckpointStoreEventProcessor`1(CheckpointStore checkpointStore, int eventBatchMaximumCount, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, AzureSasCredential credential, EventProcessorOptions options);
    protected PluggableCheckpointStoreEventProcessor`1(CheckpointStore checkpointStore, int eventBatchMaximumCount, string consumerGroup, string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventProcessorOptions options);
    protected virtual Task`1<EventProcessorCheckpoint> GetCheckpointAsync(string partitionId, CancellationToken cancellationToken);
    protected virtual Task UpdateCheckpointAsync(string partitionId, long offset, Nullable`1<long> sequenceNumber, CancellationToken cancellationToken);
    protected virtual Task UpdateCheckpointAsync(string partitionId, CheckpointPosition startingPosition, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ListOwnershipAsync(CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<EventProcessorPartitionOwnership>> ClaimOwnershipAsync(IEnumerable`1<EventProcessorPartitionOwnership> desiredOwnership, CancellationToken cancellationToken);
}
public class Azure.Messaging.EventHubs.Processor.CheckpointPosition : ValueType {
    [CompilerGeneratedAttribute]
private long <SequenceNumber>k__BackingField;
    public long SequenceNumber { get; }
    public CheckpointPosition(long sequenceNumber);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_SequenceNumber();
    public static CheckpointPosition FromEvent(EventData eventData);
    public sealed virtual bool Equals(CheckpointPosition other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(CheckpointPosition left, CheckpointPosition right);
    public static bool op_Inequality(CheckpointPosition left, CheckpointPosition right);
}
public enum Azure.Messaging.EventHubs.Processor.LoadBalancingStrategy : Enum {
    public int value__;
    public static LoadBalancingStrategy Balanced;
    public static LoadBalancingStrategy Greedy;
}
public class Azure.Messaging.EventHubs.Processor.PartitionClosingEventArgs : object {
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessingStoppedReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public string PartitionId { get; }
    public ProcessingStoppedReason Reason { get; }
    public CancellationToken CancellationToken { get; }
    public PartitionClosingEventArgs(string partitionId, ProcessingStoppedReason reason, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public ProcessingStoppedReason get_Reason();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Azure.Messaging.EventHubs.Processor.PartitionInitializingEventArgs : object {
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventPosition <DefaultStartingPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public string PartitionId { get; }
    public EventPosition DefaultStartingPosition { get; public set; }
    public CancellationToken CancellationToken { get; }
    public PartitionInitializingEventArgs(string partitionId, EventPosition defaultStartingPosition, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public EventPosition get_DefaultStartingPosition();
    [CompilerGeneratedAttribute]
public void set_DefaultStartingPosition(EventPosition value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Azure.Messaging.EventHubs.Processor.ProcessErrorEventArgs : ValueType {
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public string PartitionId { get; }
    public string Operation { get; }
    public Exception Exception { get; }
    public CancellationToken CancellationToken { get; }
    public ProcessErrorEventArgs(string partitionId, string operation, Exception exception, CancellationToken cancellationToken);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PartitionId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Operation();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Exception get_Exception();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Azure.Messaging.EventHubs.Processor.ProcessEventArgs : ValueType {
    [CompilerGeneratedAttribute]
private PartitionContext <Partition>k__BackingField;
    [CompilerGeneratedAttribute]
private EventData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task> <UpdateCheckpointAsyncImplementation>k__BackingField;
    public bool HasEvent { get; }
    public PartitionContext Partition { get; }
    public EventData Data { get; }
    public CancellationToken CancellationToken { get; }
    private Func`2<CancellationToken, Task> UpdateCheckpointAsyncImplementation { get; }
    public ProcessEventArgs(PartitionContext partition, EventData data, Func`2<CancellationToken, Task> updateCheckpointImplementation, CancellationToken cancellationToken);
    public bool get_HasEvent();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PartitionContext get_Partition();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public EventData get_Data();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task> get_UpdateCheckpointAsyncImplementation();
    public Task UpdateCheckpointAsync(CancellationToken cancellationToken);
}
public enum Azure.Messaging.EventHubs.Processor.ProcessingStoppedReason : Enum {
    public int value__;
    public static ProcessingStoppedReason Shutdown;
    public static ProcessingStoppedReason OwnershipLost;
}
public class Azure.Messaging.EventHubs.Producer.CreateBatchOptions : SendEventOptions {
    private Nullable`1<long> _maximumSizeInBytes;
    public Nullable`1<long> MaximumSizeInBytes { get; public set; }
    public Nullable`1<long> get_MaximumSizeInBytes();
    public void set_MaximumSizeInBytes(Nullable`1<long> value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal CreateBatchOptions Clone();
}
public class Azure.Messaging.EventHubs.Producer.EnqueueEventOptions : SendEventOptions {
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal void Deconstruct(String& partitionId, String& partitionKey);
    internal static ValueTuple`2<string, string> DeconstructOrUseDefaultAttributes(EnqueueEventOptions options);
}
public class Azure.Messaging.EventHubs.Producer.EventDataBatch : object {
    private object SyncGuard;
    private bool _locked;
    [CompilerGeneratedAttribute]
private SendEventOptions <SendOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportEventBatch <InnerBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullyQualifiedNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventHubName>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`2<string, string>> <EventDiagnosticIdentifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagingClientDiagnostics <ClientDiagnostics>k__BackingField;
    public long MaximumSizeInBytes { get; }
    public long SizeInBytes { get; }
    public int Count { get; }
    internal Nullable`1<int> StartingPublishedSequenceNumber { get; }
    internal SendEventOptions SendOptions { get; }
    private TransportEventBatch InnerBatch { get; }
    private string FullyQualifiedNamespace { get; }
    private string EventHubName { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<string, string>> EventDiagnosticIdentifiers { get; }
    private MessagingClientDiagnostics ClientDiagnostics { get; }
    internal EventDataBatch(TransportEventBatch transportBatch, string fullyQualifiedNamespace, string eventHubName, SendEventOptions sendOptions, MessagingClientDiagnostics clientDiagnostics);
    public long get_MaximumSizeInBytes();
    public long get_SizeInBytes();
    public int get_Count();
    internal Nullable`1<int> get_StartingPublishedSequenceNumber();
    [CompilerGeneratedAttribute]
internal SendEventOptions get_SendOptions();
    [CompilerGeneratedAttribute]
private TransportEventBatch get_InnerBatch();
    [CompilerGeneratedAttribute]
private string get_FullyQualifiedNamespace();
    [CompilerGeneratedAttribute]
private string get_EventHubName();
    [CompilerGeneratedAttribute]
private List`1<ValueTuple`2<string, string>> get_EventDiagnosticIdentifiers();
    [CompilerGeneratedAttribute]
private MessagingClientDiagnostics get_ClientDiagnostics();
    public bool TryAdd(EventData eventData);
    public sealed virtual void Dispose();
    internal void Clear();
    internal IReadOnlyCollection`1<T> AsReadOnlyCollection();
    internal IReadOnlyList`1<ValueTuple`2<string, string>> GetTraceContext();
    internal int ApplyBatchSequencing(int lastSequenceNumber, Nullable`1<long> producerGroupId, Nullable`1<short> ownerLevel);
    internal void ResetBatchSequencing();
    internal void Lock();
    internal void Unlock();
    private void AssertNotLocked();
}
public class Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient : object {
    private static int PartitionPublishingGuardAcquireLimitMilliseconds;
    private static TimeSpan ThrottleBackoffInterval;
    private static TimeSpan MinimumPublishingWaitInterval;
    private static TimeSpan PublishingDelayInterval;
    private static EventHubBufferedProducerClientOptions DefaultOptions;
    private static ThreadLocal`1<Random> RandomNumberGenerator;
    private static int s_randomSeed;
    private ConcurrentDictionary`2<string, PartitionPublishingState> _activePartitionStateMap;
    private EventHubBufferedProducerClientOptions _options;
    private SemaphoreSlim _stateGuard;
    private EventHubProducerClient _producer;
    private CancellationTokenSource _backgroundTasksCancellationSource;
    private CancellationTokenSource _activeSendOperationsCancellationSource;
    private TaskCompletionSource`1<bool> _eventEnqueuedCompletionSource;
    private Task _producerManagementTask;
    private Task _publishingTask;
    private String[] _partitions;
    private HashSet`1<string> _partitionHash;
    private int _totalBufferedEventCount;
    private Func`2<SendEventBatchSucceededEventArgs, Task> _sendSucceededHandler;
    private Func`2<SendEventBatchFailedEventArgs, Task> _sendFailedHandler;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _areHandlersLocked;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isClosed;
    private MessagingClientDiagnostics _clientDiagnostics;
    [CompilerGeneratedAttribute]
private EventHubsEventSource <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private PartitionResolver <PartitionResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BackgroundManagementInterval>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string Identifier { get; }
    public bool IsPublishing { get; }
    public bool IsClosed { get; internal set; }
    public int TotalBufferedEventCount { get; }
    internal EventHubsEventSource Logger { get; internal set; }
    internal PartitionResolver PartitionResolver { get; internal set; }
    internal TimeSpan BackgroundManagementInterval { get; internal set; }
    internal ConcurrentDictionary`2<string, PartitionPublishingState> ActivePartitionStateMap { get; }
    public EventHubBufferedProducerClient(string connectionString);
    public EventHubBufferedProducerClient(string connectionString, EventHubBufferedProducerClientOptions clientOptions);
    public EventHubBufferedProducerClient(string connectionString, string eventHubName);
    public EventHubBufferedProducerClient(string connectionString, string eventHubName, EventHubBufferedProducerClientOptions clientOptions);
    public EventHubBufferedProducerClient(string fullyQualifiedNamespace, string eventHubName, AzureNamedKeyCredential credential, EventHubBufferedProducerClientOptions clientOptions);
    public EventHubBufferedProducerClient(string fullyQualifiedNamespace, string eventHubName, AzureSasCredential credential, EventHubBufferedProducerClientOptions clientOptions);
    public EventHubBufferedProducerClient(string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventHubBufferedProducerClientOptions clientOptions);
    public EventHubBufferedProducerClient(EventHubConnection connection, EventHubBufferedProducerClientOptions clientOptions);
    internal EventHubBufferedProducerClient(EventHubProducerClient producer, EventHubBufferedProducerClientOptions clientOptions);
    private EventHubBufferedProducerClient(string fullyQualifiedNamespace, string eventHubName, object credential, EventHubBufferedProducerClientOptions clientOptions);
    private EventHubBufferedProducerClient(EventHubBufferedProducerClientOptions options);
    private static EventHubBufferedProducerClient();
    public string get_FullyQualifiedNamespace();
    public string get_EventHubName();
    public string get_Identifier();
    public virtual bool get_IsPublishing();
    public virtual bool get_IsClosed();
    internal virtual void set_IsClosed(bool value);
    public virtual int get_TotalBufferedEventCount();
    [CompilerGeneratedAttribute]
internal EventHubsEventSource get_Logger();
    [CompilerGeneratedAttribute]
internal void set_Logger(EventHubsEventSource value);
    [CompilerGeneratedAttribute]
internal PartitionResolver get_PartitionResolver();
    [CompilerGeneratedAttribute]
internal void set_PartitionResolver(PartitionResolver value);
    [CompilerGeneratedAttribute]
internal TimeSpan get_BackgroundManagementInterval();
    [CompilerGeneratedAttribute]
internal void set_BackgroundManagementInterval(TimeSpan value);
    internal ConcurrentDictionary`2<string, PartitionPublishingState> get_ActivePartitionStateMap();
    public void add_SendEventBatchSucceededAsync(Func`2<SendEventBatchSucceededEventArgs, Task> value);
    public void remove_SendEventBatchSucceededAsync(Func`2<SendEventBatchSucceededEventArgs, Task> value);
    public void add_SendEventBatchFailedAsync(Func`2<SendEventBatchFailedEventArgs, Task> value);
    public void remove_SendEventBatchFailedAsync(Func`2<SendEventBatchFailedEventArgs, Task> value);
    public virtual int GetBufferedEventCount(string partitionId);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<GetEventHubPropertiesAsync>d__70")]
public virtual Task`1<EventHubProperties> GetEventHubPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<GetPartitionIdsAsync>d__71")]
public virtual Task`1<String[]> GetPartitionIdsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<GetPartitionPropertiesAsync>d__72")]
public virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(string partitionId, CancellationToken cancellationToken);
    public virtual Task`1<int> EnqueueEventAsync(EventData eventData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<EnqueueEventAsync>d__74")]
public virtual Task`1<int> EnqueueEventAsync(EventData eventData, EnqueueEventOptions options, CancellationToken cancellationToken);
    public virtual Task`1<int> EnqueueEventsAsync(IEnumerable`1<EventData> events, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<EnqueueEventsAsync>d__76")]
public virtual Task`1<int> EnqueueEventsAsync(IEnumerable`1<EventData> events, EnqueueEventOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<FlushAsync>d__77")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<CloseAsync>d__78")]
public virtual Task CloseAsync(bool flush, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<DisposeAsync>d__79")]
public virtual ValueTask DisposeAsync();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal virtual void ClearInternal(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<FlushInternalAsync>d__84")]
internal virtual Task FlushInternalAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<PublishBatchToPartition>d__85")]
internal virtual Task PublishBatchToPartition(PartitionPublishingState partitionState, bool releaseGuard, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<DrainAndPublishPartitionEvents>d__86")]
internal virtual Task DrainAndPublishPartitionEvents(PartitionPublishingState partitionState, string operationId, CancellationToken cancellationToken);
    internal virtual DateTimeOffset GetCurrentTime();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<OnSendSucceededAsync>d__88")]
protected virtual Task OnSendSucceededAsync(IReadOnlyList`1<EventData> events, string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<OnSendFailedAsync>d__89")]
protected virtual Task OnSendFailedAsync(IReadOnlyList`1<EventData> events, Exception exception, string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<ListPartitionIdsAsync>d__90")]
protected virtual Task`1<String[]> ListPartitionIdsAsync(EventHubProducerClient producer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<StartPublishingAsync>d__91")]
private Task StartPublishingAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<StopPublishingAsync>d__92")]
private Task StopPublishingAsync(bool cancelActiveSendOperations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<SendBatchAsync>d__93")]
private Task SendBatchAsync(EventDataBatch batch, string partitionId, string operationId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<SafeInvokeOnSendSucceededAsync>d__94")]
private Task SafeInvokeOnSendSucceededAsync(IReadOnlyList`1<EventData> events, string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<SafeInvokeOnSendFailedAsync>d__95")]
private Task SafeInvokeOnSendFailedAsync(IReadOnlyList`1<EventData> events, Exception exception, string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<RunProducerManagementAsync>d__96")]
private Task RunProducerManagementAsync(CancellationToken cancellationToken);
    private Task RunPublishingAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClient/<UpdatePartitionInformation>d__98")]
private Task UpdatePartitionInformation(CancellationToken cancellationToken);
    private static void AssertSinglePartitionReference(string partitionId, string partitionKey);
    private static void AssertValidPartition(string partitionId, HashSet`1<string> validPartitions);
    private static void AssertRequiredHandlerSetForEnqueue(object handler, string handlerName);
    private static Channel`1<EventData> CreatePendingEventChannel(int capacity);
    private static string GenerateOperationId();
    private static bool ShouldWait(TimeSpan waitTime, TimeSpan minimumAllowedWaitTime);
    private static TimeSpan CalculateBatchingDelay(TimeSpan remainingTime, TimeSpan delayInterval);
    [CompilerGeneratedAttribute]
private PartitionPublishingState <EnqueueEventAsync>b__74_0(string partitionId);
    [CompilerGeneratedAttribute]
private PartitionPublishingState <EnqueueEventsAsync>b__76_0(string partitionId);
}
public class Azure.Messaging.EventHubs.Producer.EventHubBufferedProducerClientOptions : object {
    private int _maximumConcurrentSends;
    private int _maximumConcurrentSendsPerPartition;
    private int _maximumEventBufferLengthPerPartition;
    private Nullable`1<TimeSpan> _maximumWaitTime;
    private EventHubConnectionOptions _connectionOptions;
    private EventHubsRetryOptions _retryOptions;
    [CompilerGeneratedAttribute]
private bool <EnableIdempotentRetries>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public bool EnableIdempotentRetries { get; public set; }
    public Nullable`1<TimeSpan> MaximumWaitTime { get; public set; }
    public int MaximumEventBufferLengthPerPartition { get; public set; }
    public int MaximumConcurrentSends { get; public set; }
    public int MaximumConcurrentSendsPerPartition { get; public set; }
    public string Identifier { get; public set; }
    public EventHubConnectionOptions ConnectionOptions { get; public set; }
    public EventHubsRetryOptions RetryOptions { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableIdempotentRetries();
    [CompilerGeneratedAttribute]
public void set_EnableIdempotentRetries(bool value);
    public Nullable`1<TimeSpan> get_MaximumWaitTime();
    public void set_MaximumWaitTime(Nullable`1<TimeSpan> value);
    public int get_MaximumEventBufferLengthPerPartition();
    public void set_MaximumEventBufferLengthPerPartition(int value);
    public int get_MaximumConcurrentSends();
    public void set_MaximumConcurrentSends(int value);
    public int get_MaximumConcurrentSendsPerPartition();
    public void set_MaximumConcurrentSendsPerPartition(int value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    public EventHubConnectionOptions get_ConnectionOptions();
    public void set_ConnectionOptions(EventHubConnectionOptions value);
    public EventHubsRetryOptions get_RetryOptions();
    public void set_RetryOptions(EventHubsRetryOptions value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal EventHubBufferedProducerClientOptions Clone();
    internal EventHubProducerClientOptions ToEventHubProducerClientOptions();
}
public class Azure.Messaging.EventHubs.Producer.EventHubProducerClient : object {
    internal static int MaximumCreateProducerAttempts;
    internal static int MinimumBatchSizeLimit;
    private static SendEventOptions DefaultSendOptions;
    private static TimeSpan PartitionProducerLifespan;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closed;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OwnsConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy <RetryPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubProducerClientOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHubConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportProducerPool <PartitionProducerPool>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, PartitionPublishingState> <PartitionState>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagingClientDiagnostics <ClientDiagnostics>k__BackingField;
    public string FullyQualifiedNamespace { get; }
    public string EventHubName { get; }
    public string Identifier { get; }
    public bool IsClosed { get; protected set; }
    private bool OwnsConnection { get; }
    private EventHubsRetryPolicy RetryPolicy { get; }
    private EventHubProducerClientOptions Options { get; }
    private EventHubConnection Connection { get; }
    private TransportProducerPool PartitionProducerPool { get; }
    private ConcurrentDictionary`2<string, PartitionPublishingState> PartitionState { get; }
    private MessagingClientDiagnostics ClientDiagnostics { get; }
    public EventHubProducerClient(string connectionString);
    public EventHubProducerClient(string connectionString, EventHubProducerClientOptions clientOptions);
    public EventHubProducerClient(string connectionString, string eventHubName);
    public EventHubProducerClient(string connectionString, string eventHubName, EventHubProducerClientOptions clientOptions);
    public EventHubProducerClient(string fullyQualifiedNamespace, string eventHubName, AzureNamedKeyCredential credential, EventHubProducerClientOptions clientOptions);
    public EventHubProducerClient(string fullyQualifiedNamespace, string eventHubName, AzureSasCredential credential, EventHubProducerClientOptions clientOptions);
    public EventHubProducerClient(string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventHubProducerClientOptions clientOptions);
    public EventHubProducerClient(EventHubConnection connection, EventHubProducerClientOptions clientOptions);
    internal EventHubProducerClient(EventHubConnection connection, TransportProducer transportProducer, TransportProducerPool partitionProducerPool, EventHubProducerClientOptions clientOptions);
    private EventHubProducerClient(string fullyQualifiedNamespace, string eventHubName, object credential, EventHubProducerClientOptions clientOptions);
    private static EventHubProducerClient();
    public string get_FullyQualifiedNamespace();
    public string get_EventHubName();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    public bool get_IsClosed();
    protected void set_IsClosed(bool value);
    [CompilerGeneratedAttribute]
private bool get_OwnsConnection();
    [CompilerGeneratedAttribute]
private EventHubsRetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
private EventHubProducerClientOptions get_Options();
    [CompilerGeneratedAttribute]
private EventHubConnection get_Connection();
    [CompilerGeneratedAttribute]
private TransportProducerPool get_PartitionProducerPool();
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, PartitionPublishingState> get_PartitionState();
    [CompilerGeneratedAttribute]
private MessagingClientDiagnostics get_ClientDiagnostics();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<GetEventHubPropertiesAsync>d__47")]
public virtual Task`1<EventHubProperties> GetEventHubPropertiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<GetPartitionIdsAsync>d__48")]
public virtual Task`1<String[]> GetPartitionIdsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<GetPartitionPropertiesAsync>d__49")]
public virtual Task`1<PartitionProperties> GetPartitionPropertiesAsync(string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<SendAsync>d__50")]
public virtual Task SendAsync(IEnumerable`1<EventData> eventBatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<SendAsync>d__51")]
public virtual Task SendAsync(IEnumerable`1<EventData> eventBatch, SendEventOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<SendAsync>d__52")]
public virtual Task SendAsync(EventDataBatch eventBatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<CreateBatchAsync>d__53")]
public virtual ValueTask`1<EventDataBatch> CreateBatchAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<CreateBatchAsync>d__54")]
public virtual ValueTask`1<EventDataBatch> CreateBatchAsync(CreateBatchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<CloseAsync>d__55")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<DisposeAsync>d__56")]
public virtual ValueTask DisposeAsync();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<GetPartitionPublishingPropertiesAsync>d__60")]
[EditorBrowsableAttribute("1")]
protected internal virtual Task`1<PartitionPublishingProperties> GetPartitionPublishingPropertiesAsync(string partitionId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<SendInternalAsync>d__61")]
private Task SendInternalAsync(IReadOnlyCollection`1<EventData> events, SendEventOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<SendInternalAsync>d__62")]
private Task SendInternalAsync(EventDataBatch eventBatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<SendIdempotentAsync>d__63")]
private Task SendIdempotentAsync(IReadOnlyCollection`1<EventData> eventSet, SendEventOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<SendIdempotentAsync>d__64")]
private Task SendIdempotentAsync(EventDataBatch eventBatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Messaging.EventHubs.Producer.EventHubProducerClient/<InitializePartitionStateAsync>d__65")]
private Task InitializePartitionStateAsync(PartitionPublishingState partitionState, CancellationToken cancellationToken);
    private DiagnosticScope CreateDiagnosticScope(IEnumerable`1<ValueTuple`2<string, string>> traceContexts, int eventCount);
    private bool ShouldRecreateProducer(TransportProducer producer, string partitionId);
    private static void AssertSinglePartitionReference(string partitionId, string partitionKey);
    private static void AssertPartitionIsReferenced(string partitionId);
    private static void AssertIdempotentBatchNotPublished(EventDataBatch batch);
    private static void AssertIdempotentEventsNotPublished(IEnumerable`1<EventData> eventSet);
    private static int NextSequence(int currentSequence);
    private static bool RequiresStatefulPartitions(EventHubProducerClientOptions options);
    private static PartitionPublishingProperties CreatePublishingPropertiesFromPartitionState(EventHubProducerClientOptions options, PartitionPublishingState state);
}
public class Azure.Messaging.EventHubs.Producer.EventHubProducerClientOptions : object {
    private EventHubConnectionOptions _connectionOptions;
    private EventHubsRetryOptions _retryOptions;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableIdempotentPartitions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, PartitionPublishingOptions> <PartitionOptions>k__BackingField;
    public string Identifier { get; public set; }
    public EventHubConnectionOptions ConnectionOptions { get; public set; }
    public EventHubsRetryOptions RetryOptions { get; public set; }
    [EditorBrowsableAttribute("1")]
protected internal bool EnableIdempotentPartitions { get; protected internal set; }
    [EditorBrowsableAttribute("1")]
protected internal Dictionary`2<string, PartitionPublishingOptions> PartitionOptions { get; }
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    public EventHubConnectionOptions get_ConnectionOptions();
    public void set_ConnectionOptions(EventHubConnectionOptions value);
    public EventHubsRetryOptions get_RetryOptions();
    public void set_RetryOptions(EventHubsRetryOptions value);
    [CompilerGeneratedAttribute]
protected internal bool get_EnableIdempotentPartitions();
    [CompilerGeneratedAttribute]
protected internal void set_EnableIdempotentPartitions(bool value);
    [CompilerGeneratedAttribute]
protected internal Dictionary`2<string, PartitionPublishingOptions> get_PartitionOptions();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal EventHubProducerClientOptions Clone();
    internal TransportProducerFeatures CreateFeatureFlags();
    internal PartitionPublishingOptions GetPublishingOptionsOrDefaultForPartition(string partitionId);
}
[EditorBrowsableAttribute("1")]
public class Azure.Messaging.EventHubs.Producer.PartitionPublishingOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ProducerGroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<short> <OwnerLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <StartingSequenceNumber>k__BackingField;
    public Nullable`1<long> ProducerGroupId { get; public set; }
    public Nullable`1<short> OwnerLevel { get; public set; }
    public Nullable`1<int> StartingSequenceNumber { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ProducerGroupId();
    [CompilerGeneratedAttribute]
public void set_ProducerGroupId(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<short> get_OwnerLevel();
    [CompilerGeneratedAttribute]
public void set_OwnerLevel(Nullable`1<short> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_StartingSequenceNumber();
    [CompilerGeneratedAttribute]
public void set_StartingSequenceNumber(Nullable`1<int> value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal PartitionPublishingOptions Clone();
}
[EditorBrowsableAttribute("1")]
public class Azure.Messaging.EventHubs.Producer.PartitionPublishingProperties : object {
    private static PartitionPublishingProperties s_emptyInstance;
    [CompilerGeneratedAttribute]
private bool <IsIdempotentPublishingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ProducerGroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<short> <OwnerLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LastPublishedSequenceNumber>k__BackingField;
    internal static PartitionPublishingProperties Empty { get; }
    public bool IsIdempotentPublishingEnabled { get; }
    public Nullable`1<long> ProducerGroupId { get; }
    public Nullable`1<short> OwnerLevel { get; }
    public Nullable`1<int> LastPublishedSequenceNumber { get; }
    internal PartitionPublishingProperties(bool isIdempotentPublishingEnabled, Nullable`1<long> producerGroupId, Nullable`1<short> ownerLevel, Nullable`1<int> lastPublishedSequenceNumber);
    internal static PartitionPublishingProperties get_Empty();
    [CompilerGeneratedAttribute]
public bool get_IsIdempotentPublishingEnabled();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ProducerGroupId();
    [CompilerGeneratedAttribute]
public Nullable`1<short> get_OwnerLevel();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LastPublishedSequenceNumber();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
internal class Azure.Messaging.EventHubs.Producer.PartitionPublishingState : object {
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private SemaphoreSlim <PublishingGuard>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ProducerGroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<short> <OwnerLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LastPublishedSequenceNumber>k__BackingField;
    public string PartitionId { get; }
    public bool IsInitialized { get; }
    public SemaphoreSlim PublishingGuard { get; }
    public Nullable`1<long> ProducerGroupId { get; public set; }
    public Nullable`1<short> OwnerLevel { get; public set; }
    public Nullable`1<int> LastPublishedSequenceNumber { get; public set; }
    public PartitionPublishingState(string partitionId);
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
public SemaphoreSlim get_PublishingGuard();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ProducerGroupId();
    [CompilerGeneratedAttribute]
public void set_ProducerGroupId(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<short> get_OwnerLevel();
    [CompilerGeneratedAttribute]
public void set_OwnerLevel(Nullable`1<short> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LastPublishedSequenceNumber();
    [CompilerGeneratedAttribute]
public void set_LastPublishedSequenceNumber(Nullable`1<int> value);
}
public class Azure.Messaging.EventHubs.Producer.SendEventBatchFailedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EventData> <EventBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public IReadOnlyList`1<EventData> EventBatch { get; }
    public Exception Exception { get; }
    public string PartitionId { get; }
    public CancellationToken CancellationToken { get; }
    public SendEventBatchFailedEventArgs(IReadOnlyList`1<EventData> eventBatch, Exception exception, string partitionId, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EventData> get_EventBatch();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Azure.Messaging.EventHubs.Producer.SendEventBatchSucceededEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EventData> <EventBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public IReadOnlyList`1<EventData> EventBatch { get; }
    public string PartitionId { get; }
    public CancellationToken CancellationToken { get; }
    public SendEventBatchSucceededEventArgs(IReadOnlyList`1<EventData> eventBatch, string partitionId, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EventData> get_EventBatch();
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Azure.Messaging.EventHubs.Producer.SendEventOptions : object {
    [CompilerGeneratedAttribute]
private string <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionId>k__BackingField;
    public string PartitionKey { get; public set; }
    public string PartitionId { get; public set; }
    internal SendEventOptions(string partitionId, string partitionKey);
    [CompilerGeneratedAttribute]
public string get_PartitionKey();
    [CompilerGeneratedAttribute]
public void set_PartitionKey(string value);
    [CompilerGeneratedAttribute]
public string get_PartitionId();
    [CompilerGeneratedAttribute]
public void set_PartitionId(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal SendEventOptions Clone();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Azure.Messaging.EventHubs.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotParseIntegerType { get; }
    internal static string CannotSendWithPartitionIdAndPartitionKey { get; }
    internal static string CannotStartEventProcessorWithoutHandler { get; }
    internal static string ClientNeededForThisInformationNotAvailable { get; }
    internal static string ClosedConnectionCannotPerformOperation { get; }
    internal static string ClosedInstanceCannotPerformOperation { get; }
    internal static string ConsumerIdentifierOverMaxValue { get; }
    internal static string CouldNotAcquireAccessToken { get; }
    internal static string CouldNotCreateLink { get; }
    internal static string DeveloperCodeEventProcessingError { get; }
    internal static string DeveloperCodeError { get; }
    internal static string DeveloperCodeExceptionMessageMask { get; }
    internal static string EventBatchIsLocked { get; }
    internal static string FailedToCreateReader { get; }
    internal static string FailedToSerializeUnsupportedType { get; }
    internal static string InvalidConnectionString { get; }
    internal static string InvalidEncoding { get; }
    internal static string InvalidEventPositionForFilter { get; }
    internal static string InvalidFullyQualifiedNamespace { get; }
    internal static string InvalidMessageBody { get; }
    internal static string InvalidSharedAccessSignature { get; }
    internal static string InvalidEndpointAddress { get; }
    internal static string InvalidTimePeriod { get; }
    internal static string InvalidTransportType { get; }
    internal static string MessageSizeExceeded { get; }
    internal static string MissingConnectionInformation { get; }
    internal static string OnlyOneEventHubNameMayBeSpecified { get; }
    internal static string ProxyMustUseWebSockets { get; }
    internal static string ResourceMustMatchSharedAccessSignature { get; }
    internal static string RetryOptionsMustBeSet { get; }
    internal static string RunningEventProcessorCannotPerformOperation { get; }
    internal static string SharedAccessKeyIsRequired { get; }
    internal static string SharedKeyCredentialCannotGenerateTokens { get; }
    internal static string TimeoutMustBePositive { get; }
    internal static string TimeSpanMustBeNonNegative { get; }
    internal static string TrackLastEnqueuedEventPropertiesNotSet { get; }
    internal static string UnknownCommunicationException { get; }
    internal static string UnknownConnectionType { get; }
    internal static string UnknownRetryMode { get; }
    internal static string UnrecoverableException { get; }
    internal static string UnsupportedCredential { get; }
    internal static string UnsupportedTransportEventType { get; }
    internal static string ValueMustBeAtLeast { get; }
    internal static string ValueOutOfRange { get; }
    internal static string BlobsResourceDoesNotExist { get; }
    internal static string CannotCreateCheckpointForEmptyEvent { get; }
    internal static string HandlerHasAlreadyBeenAssigned { get; }
    internal static string HandlerHasNotBeenAssigned { get; }
    internal static string OperationEventProcessingDeveloperCode { get; }
    internal static string OperationListOwnership { get; }
    internal static string OperationGetPartitionIds { get; }
    internal static string OperationListCheckpoints { get; }
    internal static string OperationLoadBalancing { get; }
    internal static string OperationClaimOwnership { get; }
    internal static string OperationRenewOwnership { get; }
    internal static string OperationReadEvents { get; }
    internal static string OperationEventProcessingLoop { get; }
    internal static string OperationSurrenderOwnership { get; }
    internal static string CannotReadLastEnqueuedEventPropertiesWithoutEvent { get; }
    internal static string AggregateEventProcessingExceptionMessage { get; }
    internal static string OnlyOneSharedAccessAuthorizationMayBeSpecified { get; }
    internal static string CannotPublishToGateway { get; }
    internal static string IdempotentAlreadyPublished { get; }
    internal static string ListCheckpointsAsyncObsolete { get; }
    internal static string UnknownAmqpBodyType { get; }
    internal static string RawAmqpBodyTypeMask { get; }
    internal static string DictionaryKeyNotFoundMask { get; }
    internal static string InvalidAmqpMessageValueBodyMask { get; }
    internal static string InvalidAmqpMessageDictionaryTypeMask { get; }
    internal static string CannotChangeHandlersWhenPublishing { get; }
    internal static string ProcessorLoadBalancingCycleSlowMask { get; }
    internal static string ProcessorLoadBalancingIntervalsTooCloseMask { get; }
    internal static string ProcessorLoadBalancingFatalErrorMask { get; }
    internal static string CannotEnqueueEventWithoutHandler { get; }
    internal static string CannotSendToUknownPartition { get; }
    internal static string EventTooLargeMask { get; }
    internal static string TroubleshootingGuideLink { get; }
    internal static string BufferedProducerStartupTimeout { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotParseIntegerType();
    internal static string get_CannotSendWithPartitionIdAndPartitionKey();
    internal static string get_CannotStartEventProcessorWithoutHandler();
    internal static string get_ClientNeededForThisInformationNotAvailable();
    internal static string get_ClosedConnectionCannotPerformOperation();
    internal static string get_ClosedInstanceCannotPerformOperation();
    internal static string get_ConsumerIdentifierOverMaxValue();
    internal static string get_CouldNotAcquireAccessToken();
    internal static string get_CouldNotCreateLink();
    internal static string get_DeveloperCodeEventProcessingError();
    internal static string get_DeveloperCodeError();
    internal static string get_DeveloperCodeExceptionMessageMask();
    internal static string get_EventBatchIsLocked();
    internal static string get_FailedToCreateReader();
    internal static string get_FailedToSerializeUnsupportedType();
    internal static string get_InvalidConnectionString();
    internal static string get_InvalidEncoding();
    internal static string get_InvalidEventPositionForFilter();
    internal static string get_InvalidFullyQualifiedNamespace();
    internal static string get_InvalidMessageBody();
    internal static string get_InvalidSharedAccessSignature();
    internal static string get_InvalidEndpointAddress();
    internal static string get_InvalidTimePeriod();
    internal static string get_InvalidTransportType();
    internal static string get_MessageSizeExceeded();
    internal static string get_MissingConnectionInformation();
    internal static string get_OnlyOneEventHubNameMayBeSpecified();
    internal static string get_ProxyMustUseWebSockets();
    internal static string get_ResourceMustMatchSharedAccessSignature();
    internal static string get_RetryOptionsMustBeSet();
    internal static string get_RunningEventProcessorCannotPerformOperation();
    internal static string get_SharedAccessKeyIsRequired();
    internal static string get_SharedKeyCredentialCannotGenerateTokens();
    internal static string get_TimeoutMustBePositive();
    internal static string get_TimeSpanMustBeNonNegative();
    internal static string get_TrackLastEnqueuedEventPropertiesNotSet();
    internal static string get_UnknownCommunicationException();
    internal static string get_UnknownConnectionType();
    internal static string get_UnknownRetryMode();
    internal static string get_UnrecoverableException();
    internal static string get_UnsupportedCredential();
    internal static string get_UnsupportedTransportEventType();
    internal static string get_ValueMustBeAtLeast();
    internal static string get_ValueOutOfRange();
    internal static string get_BlobsResourceDoesNotExist();
    internal static string get_CannotCreateCheckpointForEmptyEvent();
    internal static string get_HandlerHasAlreadyBeenAssigned();
    internal static string get_HandlerHasNotBeenAssigned();
    internal static string get_OperationEventProcessingDeveloperCode();
    internal static string get_OperationListOwnership();
    internal static string get_OperationGetPartitionIds();
    internal static string get_OperationListCheckpoints();
    internal static string get_OperationLoadBalancing();
    internal static string get_OperationClaimOwnership();
    internal static string get_OperationRenewOwnership();
    internal static string get_OperationReadEvents();
    internal static string get_OperationEventProcessingLoop();
    internal static string get_OperationSurrenderOwnership();
    internal static string get_CannotReadLastEnqueuedEventPropertiesWithoutEvent();
    internal static string get_AggregateEventProcessingExceptionMessage();
    internal static string get_OnlyOneSharedAccessAuthorizationMayBeSpecified();
    internal static string get_CannotPublishToGateway();
    internal static string get_IdempotentAlreadyPublished();
    internal static string get_ListCheckpointsAsyncObsolete();
    internal static string get_UnknownAmqpBodyType();
    internal static string get_RawAmqpBodyTypeMask();
    internal static string get_DictionaryKeyNotFoundMask();
    internal static string get_InvalidAmqpMessageValueBodyMask();
    internal static string get_InvalidAmqpMessageDictionaryTypeMask();
    internal static string get_CannotChangeHandlersWhenPublishing();
    internal static string get_ProcessorLoadBalancingCycleSlowMask();
    internal static string get_ProcessorLoadBalancingIntervalsTooCloseMask();
    internal static string get_ProcessorLoadBalancingFatalErrorMask();
    internal static string get_CannotEnqueueEventWithoutHandler();
    internal static string get_CannotSendToUknownPartition();
    internal static string get_EventTooLargeMask();
    internal static string get_TroubleshootingGuideLink();
    internal static string get_BufferedProducerStartupTimeout();
}
internal static class Azure.Messaging.EventHubs.ResourcesNamespace : object {
    public static string Current;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Azure.EventHubClientBuilderExtensions : object {
    [ExtensionAttribute]
public static IAzureClientBuilder`2<EventHubProducerClient, EventHubProducerClientOptions> AddEventHubProducerClient(TBuilder builder, string connectionString);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<EventHubProducerClient, EventHubProducerClientOptions> AddEventHubProducerClient(TBuilder builder, string connectionString, string eventHubName);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<EventHubProducerClient, EventHubProducerClientOptions> AddEventHubProducerClientWithNamespace(TBuilder builder, string fullyQualifiedNamespace, string eventHubName);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<EventHubProducerClient, EventHubProducerClientOptions> AddEventHubProducerClient(TBuilder builder, TConfiguration configuration);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<EventHubConsumerClient, EventHubConsumerClientOptions> AddEventHubConsumerClient(TBuilder builder, string consumerGroup, string connectionString);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<EventHubConsumerClient, EventHubConsumerClientOptions> AddEventHubConsumerClient(TBuilder builder, string consumerGroup, string connectionString, string eventHubName);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<EventHubConsumerClient, EventHubConsumerClientOptions> AddEventHubConsumerClientWithNamespace(TBuilder builder, string consumerGroup, string fullyQualifiedNamespace, string eventHubName);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<EventHubConsumerClient, EventHubConsumerClientOptions> AddEventHubConsumerClient(TBuilder builder, TConfiguration configuration);
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("1774")]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
