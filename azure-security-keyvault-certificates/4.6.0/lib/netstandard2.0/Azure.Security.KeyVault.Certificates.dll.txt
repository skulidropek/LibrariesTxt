internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
internal static class Azure.Core.Argument : object {
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    [NullableContextAttribute("1")]
public static void AssertNull(T value, string name, string message);
}
internal class Azure.Core.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private static int DefaultInitialBufferSize;
    [CompilerGeneratedAttribute]
private int <WrittenCount>k__BackingField;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; private set; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    [CompilerGeneratedAttribute]
public int get_WrittenCount();
    [CompilerGeneratedAttribute]
private void set_WrittenCount(int value);
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AsyncLockWithValue`1 : object {
    private object _syncObj;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters;
    private bool _isLocked;
    private bool _hasValue;
    private long _index;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public AsyncLockWithValue`1(T value);
    public bool get_HasValue();
    [NullableContextAttribute("2")]
public bool TryGetValue(T& value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.AsyncLockWithValue`1/<GetLockOrValueAsync>d__11")]
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken);
    private void SetValue(T value, Int64& lockIndex);
    private void Reset(Int64& lockIndex);
    private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter);
}
internal static class Azure.Core.AuthorizationChallengeParser : object {
    [NullableContextAttribute("1")]
public static string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter);
    internal static bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey);
    internal static bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator);
}
[AttributeUsageAttribute("1")]
internal class Azure.Core.AzureResourceProviderNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ResourceProviderNamespace>k__BackingField;
    public string ResourceProviderNamespace { get; }
    public AzureResourceProviderNamespaceAttribute(string resourceProviderNamespace);
    [CompilerGeneratedAttribute]
public string get_ResourceProviderNamespace();
}
internal static class Azure.Core.Base64Url : object {
    public static Byte[] Decode(string encoded);
    public static string Encode(Byte[] bytes);
    internal static string DecodeString(string encoded);
    internal static string EncodeString(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("68")]
internal class Azure.Core.CallerShouldAuditAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; public set; }
    public CallerShouldAuditAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Azure.Core.ChangeTrackingDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TKey, TValue> _innerDictionary;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public ChangeTrackingDictionary`2(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optionalDictionary);
    public ChangeTrackingDictionary`2(Optional`1<IDictionary`2<TKey, TValue>> optionalDictionary);
    private ChangeTrackingDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    private ChangeTrackingDictionary`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    public bool get_IsUndefined();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private IDictionary`2<TKey, TValue> EnsureDictionary();
    [IteratorStateMachineAttribute("Azure.Core.ChangeTrackingDictionary`2/<<GetEnumerator>g__GetEmptyEnumerator|8_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__GetEmptyEnumerator|8_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Azure.Core.ChangeTrackingList`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<T> _innerList;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ChangeTrackingList`1(Optional`1<IList`1<T>> optionalList);
    public ChangeTrackingList`1(Optional`1<IReadOnlyList`1<T>> optionalList);
    private ChangeTrackingList`1(IEnumerable`1<T> innerList);
    private ChangeTrackingList`1(IList`1<T> innerList);
    public bool get_IsUndefined();
    public void Reset();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private IList`1<T> EnsureList();
    [IteratorStateMachineAttribute("Azure.Core.ChangeTrackingList`1/<<GetEnumerator>g__EnumerateEmpty|9_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<T> <GetEnumerator>g__EnumerateEmpty|9_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.Diagnostics.AzureEventSource : EventSource {
    private static string SharedDataKey;
    private static HashSet`1<string> NamesInUse;
    private static String[] MainEventSourceTraits;
    private static AzureEventSource();
    protected AzureEventSource(string eventSourceName);
    private static string DeduplicateName(string eventSourceName);
}
internal class Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
    private static TimeSpan DefaultDelay;
    private TimeSpan _delay;
    public FixedDelayWithNoJitterStrategy(Nullable`1<TimeSpan> suggestedDelay);
    private static FixedDelayWithNoJitterStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.FormUrlEncodedContent : RequestContent {
    private List`1<KeyValuePair`2<string, string>> _values;
    private Encoding Latin1;
    private Byte[] _bytes;
    public void Add(string parameter, string value);
    private void BuildIfNeeded();
    [AsyncStateMachineAttribute("Azure.Core.FormUrlEncodedContent/<WriteToAsync>d__5")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
    private Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static string Encode(string data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.HashCodeBuilder : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCodeBuilder();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    public static UInt32 RotateLeft(UInt32 value, int offset);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
internal class Azure.Core.HttpMessageSanitizer : object {
    private static string LogAllValue;
    private bool _logAllHeaders;
    private bool _logFullQueries;
    private String[] _allowedQueryParameters;
    private string _redactedPlaceholder;
    private HashSet`1<string> _allowedHeaders;
    internal static HttpMessageSanitizer Default;
    public HttpMessageSanitizer(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder);
    private static HttpMessageSanitizer();
    public string SanitizeHeader(string name, string value);
    public string SanitizeUrl(string url);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.HttpPipelineExtensions : object {
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessMessageAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<Response> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response ProcessMessage(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessHeadAsBoolMessageAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<bool>> ProcessHeadAsBoolMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [ExtensionAttribute]
public static Response`1<bool> ProcessHeadAsBoolMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [NullableContextAttribute("0")]
private static ValueTuple`2<CancellationToken, ErrorOptions> ApplyRequestContext(RequestContext requestContext);
}
internal interface Azure.Core.IOperation {
    public abstract virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Azure.Core.IOperation`1 {
    public abstract virtual ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
internal interface Azure.Core.IOperationSource`1 {
    public abstract virtual T CreateResult(Response response, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<T> CreateResultAsync(Response response, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IUtf8JsonSerializable {
    public abstract virtual void Write(Utf8JsonWriter writer);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IXmlSerializable {
    public abstract virtual void Write(XmlWriter writer, string nameHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.JsonElementExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object GetObject(JsonElement& element);
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64(JsonElement& element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffset(JsonElement& element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpan(JsonElement& element, string format);
    [ExtensionAttribute]
public static char GetChar(JsonElement& element);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ThrowNonNullablePropertyIsNull(JsonProperty property);
    [ExtensionAttribute]
public static string GetRequiredString(JsonElement& element);
}
internal static class Azure.Core.LightweightPkcs8Decoder : object {
    private static Byte[] s_derIntegerOne;
    private static Object[] s_argsFalse;
    private static Byte[] s_ecAlgorithmId;
    private static Byte[] s_derIntegerZero;
    private static Byte[] s_rsaAlgorithmId;
    private static LightweightPkcs8Decoder();
    public static ECDsa DecodeECDsaPkcs8(Byte[] pkcs8Bytes, ECDsa publicKey);
    internal static Byte[] ReadBitString(Byte[] data, Int32& offset);
    internal static string ReadObjectIdentifier(Byte[] data, Int32& offset);
    internal static Byte[] ReadOctetString(Byte[] data, Int32& offset);
    private static int ReadLength(Byte[] data, Int32& offset);
    private static Byte[] ReadUnsignedInteger(Byte[] data, Int32& offset, int targetSize);
    private static int ReadPayloadTagLength(Byte[] data, Int32& offset, byte tagValue);
    private static void ConsumeFullPayloadTag(Byte[] data, Int32& offset, byte tagValue);
    private static void ConsumeMatch(Byte[] data, Int32& offset, Byte[] toMatch);
    public static RSA DecodeRSAPkcs8(Byte[] pkcs8Bytes);
    public static string DecodePrivateKeyOid(Byte[] pkcs8Bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.NextLinkOperationImplementation : object {
    private static string ApiVersionParam;
    private static String[] FailureStates;
    private static String[] SuccessStates;
    private HeaderSource _headerSource;
    private Uri _startRequestUri;
    private OperationFinalStateVia _finalStateVia;
    private RequestMethod _requestMethod;
    private HttpPipeline _pipeline;
    [NullableAttribute("2")]
private string _apiVersion;
    [NullableAttribute("2")]
private string _lastKnownLocation;
    private string _nextRequestUri;
    private NextLinkOperationImplementation(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, string lastKnownLocation, OperationFinalStateVia finalStateVia, string apiVersion);
    private static NextLinkOperationImplementation();
    public static IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    public static IOperation`1<T> Create(IOperationSource`1<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<UpdateStateAsync>d__14")]
public sealed virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
    private static OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response);
    private void UpdateNextRequestUri(ResponseHeaders headers);
    internal static string AppendOrReplaceApiVersion(string uri, string apiVersion);
    [NullableContextAttribute("0")]
internal static bool TryGetApiVersion(Uri startRequestUri, ReadOnlySpan`1& apiVersion);
    [NullableContextAttribute("2")]
private string GetFinalUri(string resourceLocation);
    [AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<GetResponseAsync>d__20")]
private ValueTask`1<Response> GetResponseAsync(bool async, string uri, CancellationToken cancellationToken);
    private HttpMessage CreateRequest(string uri);
    private static bool IsFinalState(Response response, HeaderSource headerSource, Nullable`1& failureState, String& resourceLocation);
    private static bool ShouldIgnoreHeader(RequestMethod method, Response response);
    private static HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string apiVersion, String& nextRequestUri);
}
internal enum Azure.Core.OperationFinalStateVia : Enum {
    public int value__;
    public static OperationFinalStateVia AzureAsyncOperation;
    public static OperationFinalStateVia Location;
    public static OperationFinalStateVia OriginalUri;
    public static OperationFinalStateVia OperationLocation;
    public static OperationFinalStateVia LocationOverride;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.OperationHelpers : object {
    public static T GetValue(T& value);
    [NullableContextAttribute("0")]
public static T GetValue(Nullable`1& value);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__2`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__3`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__6")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal : OperationInternalBase {
    private OperationInternal`1<VoidValue> _internalOperation;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public OperationInternal(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    private OperationInternal(OperationState finalState);
    public static OperationInternal Succeeded(Response rawResponse);
    public static OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal/<UpdateStatusAsync>d__9")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal`1 : OperationInternalBase {
    private IOperation`1<T> _operation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock;
    private Response _rawResponse;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    public T Value { get; }
    public OperationInternal`1(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    private OperationInternal`1(OperationState`1<T> finalState);
    public static OperationInternal`1<T> Succeeded(Response rawResponse, T value);
    public static OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    public bool get_HasValue();
    public T get_Value();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__15")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__16")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__19")]
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<UpdateStatusAsync>d__20")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    private static Response GetResponseFromState(OperationState`1<T> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.OperationInternalBase : object {
    private ClientDiagnostics _diagnostics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> _scopeAttributes;
    [NullableAttribute("2")]
private DelayStrategy _fallbackStrategy;
    private AsyncLockWithValue`1<Response> _responseLock;
    private string _waitForCompletionResponseScopeName;
    protected string _updateStatusScopeName;
    protected string _waitForCompletionScopeName;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    protected OperationInternalBase(Response rawResponse);
    protected OperationInternalBase(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    public abstract virtual Response get_RawResponse();
    public abstract virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<UpdateStatusAsync>d__13")]
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__15")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__16")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__19")]
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken);
    protected abstract virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    protected DiagnosticScope CreateScope(string scopeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationPoller : object {
    private DelayStrategy _delayStrategy;
    [NullableContextAttribute("2")]
public OperationPoller(DelayStrategy strategy);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__6`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__8`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__10")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__11")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<Delay>d__12")]
private static ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState : ValueType {
    [CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    [NullableAttribute("2")]
public RequestFailedException OperationFailedException { get; }
    private OperationState(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException);
    [CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    public static OperationState Success(Response rawResponse);
    public static OperationState Failure(Response rawResponse, RequestFailedException operationFailedException);
    public static OperationState Pending(Response rawResponse);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    [NullableAttribute("1")]
public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    public T Value { get; }
    public RequestFailedException OperationFailedException { get; }
    private OperationState`1(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    [NullableContextAttribute("1")]
public static OperationState`1<T> Success(Response rawResponse, T value);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Pending(Response rawResponse);
}
internal static class Azure.Core.Optional : object {
    public static bool IsCollectionDefined(IEnumerable`1<T> collection);
    public static bool IsCollectionDefined(IReadOnlyDictionary`2<TKey, TValue> collection);
    public static bool IsCollectionDefined(IDictionary`2<TKey, TValue> collection);
    public static bool IsDefined(Nullable`1<T> value);
    public static bool IsDefined(object value);
    public static bool IsDefined(string value);
    public static bool IsDefined(JsonElement value);
    public static IReadOnlyDictionary`2<TKey, TValue> ToDictionary(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optional);
    public static IDictionary`2<TKey, TValue> ToDictionary(Optional`1<IDictionary`2<TKey, TValue>> optional);
    public static IReadOnlyList`1<T> ToList(Optional`1<IReadOnlyList`1<T>> optional);
    public static IList`1<T> ToList(Optional`1<IList`1<T>> optional);
    public static Nullable`1<T> ToNullable(Optional`1<T> optional);
    public static Nullable`1<T> ToNullable(Optional`1<Nullable`1<T>> optional);
}
[IsReadOnlyAttribute]
internal class Azure.Core.Optional`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public T Value { get; }
    public bool HasValue { get; }
    public Optional`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public static Optional`1<T> op_Implicit(T value);
    public static T op_Implicit(Optional`1<T> optional);
}
internal static class Azure.Core.Page : object {
    [NullableContextAttribute("1")]
public static Page`1<T> FromValues(IEnumerable`1<T> values, string continuationToken, Response response);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.PageableHelpers : object {
    private static Byte[] DefaultItemPropertyName;
    private static Byte[] DefaultNextLinkPropertyName;
    private static PageableHelpers();
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.PageableHelpers/<CreateAsyncPageable>d__10`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
    private static ValueTuple`2<List`1<T>, string> ParseResponseForBinaryData(Response response, Byte[] itemPropertyName, Byte[] nextLinkPropertyName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static object <ParseResponseForBinaryData>g__ReadBinaryData|19_0(Utf8JsonReader& r, ReadOnlyMemory`1& content);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.PageResponseEnumerator : object {
    public static FuncPageable`1<T> CreateEnumerable(Func`2<string, Page`1<T>> pageFunc);
    public static FuncPageable`1<T> CreateEnumerable(Func`3<string, Nullable`1<int>, Page`1<T>> pageFunc);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<string, Task`1<Page`1<T>>> pageFunc);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> pageFunc);
}
internal static class Azure.Core.PemReader : object {
    private static bool s_ecInitializedImportPkcs8PrivateKeyMethod;
    private static MethodInfo s_ecImportPkcs8PrivateKeyMethod;
    private static MethodInfo s_ecCopyWithPrivateKeyMethod;
    private static string Prolog;
    private static string Epilog;
    private static string LabelEnd;
    private static string RSAAlgorithmId;
    private static string ECDsaAlgorithmId;
    private static bool s_rsaInitializedImportPkcs8PrivateKeyMethod;
    private static MethodInfo s_rsaImportPkcs8PrivateKeyMethod;
    private static MethodInfo s_rsaCopyWithPrivateKeyMethod;
    public static X509Certificate2 LoadCertificate(ReadOnlySpan`1<char> data, Byte[] cer, KeyType keyType, bool allowCertificateOnly, X509KeyStorageFlags keyStorageFlags);
    private static void CreateECDsaCertificate(Byte[] cer, Byte[] key, X509KeyStorageFlags keyStorageFlags, X509Certificate2& certificate);
    private static X509Certificate2 CreateRsaCertificate(Byte[] cer, Byte[] key, X509KeyStorageFlags keyStorageFlags);
    public static bool TryRead(ReadOnlySpan`1<char> data, PemField& field);
}
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
    public ClientDiagnostics(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities);
    public ClientDiagnostics(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities);
    internal static HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics);
    internal static string GetResourceProviderNamespace(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    [RequiresUnreferencedCodeAttribute("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(Exception exception);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ProtocolOperation`1 : Operation`1<T> {
    private Func`2<Response, T> _resultSelector;
    private OperationInternal`1<T> _operation;
    private IOperation _nextLinkOperation;
    public string Id { get; }
    public T Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal ProtocolOperation`1(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, string scopeName, Func`2<Response, T> resultSelector);
    public virtual string get_Id();
    public virtual T get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperation`1/<Azure-Core-IOperation<T>-UpdateStateAsync>d__17")]
private sealed virtual override ValueTask`1<OperationState`1<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ProtocolOperationHelpers : object {
    public static Operation`1<TTo> Convert(Operation`1<TFrom> operation, Func`2<Response, TTo> convertFunc, ClientDiagnostics diagnostics, string scopeName);
    public static ValueTask`1<Operation`1<VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static ValueTask`1<Operation`1<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperationHelpers/<ProcessMessageAsync>d__5`1")]
public static ValueTask`1<Operation`1<T>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
    public static Operation`1<T> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
}
internal class Azure.Core.RawRequestUriBuilder : RequestUriBuilder {
    [NullableAttribute("1")]
private static string SchemeSeparator;
    private static char HostSeparator;
    private static char PortSeparator;
    [NullableAttribute("1")]
private static Char[] HostOrPort;
    private static char QueryBeginSeparator;
    private static char QueryContinueSeparator;
    private static char QueryValueSeparator;
    private Nullable`1<RawWritingPosition> _position;
    private static RawRequestUriBuilder();
    private static void GetQueryParts(ReadOnlySpan`1<char> queryUnparsed, ReadOnlySpan`1& name, ReadOnlySpan`1& value);
    [NullableContextAttribute("1")]
public void AppendRaw(string value, bool escape);
    private void AppendRaw(ReadOnlySpan`1<char> value, bool escape);
    [NullableContextAttribute("1")]
public void AppendRawNextLink(string nextLink, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.RequestContentHelper : object {
    public static RequestContent FromEnumerable(IEnumerable`1<T> enumerable);
    public static RequestContent FromEnumerable(IEnumerable`1<BinaryData> enumerable);
    public static RequestContent FromDictionary(IDictionary`2<string, T> dictionary);
    public static RequestContent FromDictionary(IDictionary`2<string, BinaryData> dictionary);
    public static RequestContent FromObject(object value);
    public static RequestContent FromObject(BinaryData value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestHeaderExtensions : object {
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, bool value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, float value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, double value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, int value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, long value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, TimeSpan value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Guid value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Byte[] value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, BinaryData value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string prefix, IDictionary`2<string, string> headersToAdd);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, ETag value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, MatchConditions conditions);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, RequestConditions conditions, string format);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestUriBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, float value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, double value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, int value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, IEnumerable`1<string> value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, float value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, double value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, decimal value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, int value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, string format, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.ResponseHeadersExtensions : object {
    private static String[] KnownFormats;
    private static ResponseHeadersExtensions();
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Byte[]& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, T& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string prefix, IDictionary`2& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ResponseWithHeaders : object {
    public static ResponseWithHeaders`2<T, THeaders> FromValue(T value, THeaders headers, Response rawResponse);
    public static ResponseWithHeaders`1<THeaders> FromValue(THeaders headers, Response rawResponse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.ResponseWithHeaders`1 : object {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public THeaders Headers { get; }
    public ResponseWithHeaders`1(THeaders headers, Response rawResponse);
    public Response GetRawResponse();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`1<THeaders> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ResponseWithHeaders`2 : Response`1<T> {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public T Value { get; }
    public THeaders Headers { get; }
    public ResponseWithHeaders`2(T value, THeaders headers, Response rawResponse);
    public virtual Response GetRawResponse();
    [CompilerGeneratedAttribute]
public virtual T get_Value();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`2<T, THeaders> self);
}
internal class Azure.Core.SequentialDelayStrategy : DelayStrategy {
    [NullableAttribute("1")]
private static TimeSpan[] _pollingSequence;
    private static TimeSpan _maxDelay;
    private static SequentialDelayStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.StringRequestContent : RequestContent {
    private Byte[] _bytes;
    public StringRequestContent(string value);
    [AsyncStateMachineAttribute("Azure.Core.StringRequestContent/<WriteToAsync>d__2")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.TypeFormatters : object {
    private static string RoundtripZFormat;
    [CompilerGeneratedAttribute]
private static string <DefaultNumberFormat>k__BackingField;
    public static string DefaultNumberFormat { get; }
    private static TypeFormatters();
    [CompilerGeneratedAttribute]
public static string get_DefaultNumberFormat();
    public static string ToString(bool value);
    public static string ToString(DateTime value, string format);
    public static string ToString(DateTimeOffset value, string format);
    public static string ToString(TimeSpan value, string format);
    public static string ToString(Byte[] value, string format);
    public static string ToBase64UrlString(Byte[] value);
    public static Byte[] FromBase64UrlString(string value);
    private static int GetNumBase64PaddingCharsToAddForDecode(int inputLength);
    public static DateTimeOffset ParseDateTimeOffset(string value, string format);
    public static TimeSpan ParseTimeSpan(string value, string format);
    [NullableContextAttribute("2")]
public static string ConvertToString(object value, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Utf8JsonRequestContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private Utf8JsonWriter <JsonWriter>k__BackingField;
    public Utf8JsonWriter JsonWriter { get; }
    [CompilerGeneratedAttribute]
public Utf8JsonWriter get_JsonWriter();
    [AsyncStateMachineAttribute("Azure.Core.Utf8JsonRequestContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.Utf8JsonWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTime value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, char value);
    [ExtensionAttribute]
public static void WriteNonEmptyArray(Utf8JsonWriter writer, string name, IReadOnlyList`1<string> values);
    [ExtensionAttribute]
public static void WriteBase64StringValue(Utf8JsonWriter writer, Byte[] value, string format);
    [ExtensionAttribute]
public static void WriteNumberValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteObjectValue(Utf8JsonWriter writer, object value);
}
[IsReadOnlyAttribute]
internal class Azure.Core.VoidValue : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XElementExtensions : object {
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64Value(XElement element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffsetValue(XElement element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpanValue(XElement element, string format);
    [ExtensionAttribute]
public static object GetObjectValue(XElement element, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.XmlWriterContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private XmlWriter <XmlWriter>k__BackingField;
    public XmlWriter XmlWriter { get; }
    [CompilerGeneratedAttribute]
public XmlWriter get_XmlWriter();
    [AsyncStateMachineAttribute("Azure.Core.XmlWriterContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XmlWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteObjectValue(XmlWriter writer, object value, string nameHint);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, Byte[] value, string format);
}
public class Azure.Security.KeyVault.Certificates.AdministratorContact : object {
    [CompilerGeneratedAttribute]
private string <Email>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FirstName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Phone>k__BackingField;
    private static string FirstNamePropertyName;
    private static string LastNamePropertyName;
    private static string EmailPropertyName;
    private static string PhonePropertyName;
    private static JsonEncodedText s_firstNamePropertyNameBytes;
    private static JsonEncodedText s_lastNamePropertyNameBytes;
    private static JsonEncodedText s_emailPropertyNameBytes;
    private static JsonEncodedText s_phonePropertyNameBytes;
    public string Email { get; public set; }
    public string FirstName { get; public set; }
    public string LastName { get; public set; }
    public string Phone { get; public set; }
    private static AdministratorContact();
    [CompilerGeneratedAttribute]
public string get_Email();
    [CompilerGeneratedAttribute]
public void set_Email(string value);
    [CompilerGeneratedAttribute]
public string get_FirstName();
    [CompilerGeneratedAttribute]
public void set_FirstName(string value);
    [CompilerGeneratedAttribute]
public string get_LastName();
    [CompilerGeneratedAttribute]
public void set_LastName(string value);
    [CompilerGeneratedAttribute]
public string get_Phone();
    [CompilerGeneratedAttribute]
public void set_Phone(string value);
    internal void ReadProperties(JsonElement json);
    internal void WriteProperties(Utf8JsonWriter json);
}
internal class Azure.Security.KeyVault.Certificates.CertificateAttributes : ValueType {
    private static string EnabledPropertyName;
    private static string NotBeforePropertyName;
    private static string ExpiresPropertyName;
    private static string CreatedPropertyName;
    private static string UpdatedPropertyName;
    private static string RecoverableDaysPropertyName;
    private static string RecoveryLevelPropertyName;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <UpdatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RecoverableDays>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RecoveryLevel>k__BackingField;
    public Nullable`1<bool> Enabled { get; public set; }
    public Nullable`1<DateTimeOffset> NotBefore { get; public set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; public set; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> UpdatedOn { get; internal set; }
    public Nullable`1<int> RecoverableDays { get; internal set; }
    public string RecoveryLevel { get; internal set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(Nullable`1<bool> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_UpdatedOn();
    [CompilerGeneratedAttribute]
internal void set_UpdatedOn(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_RecoverableDays();
    [CompilerGeneratedAttribute]
internal void set_RecoverableDays(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_RecoveryLevel();
    [CompilerGeneratedAttribute]
internal void set_RecoveryLevel(string value);
    internal void ReadProperties(JsonElement json);
}
internal class Azure.Security.KeyVault.Certificates.CertificateBackup : object {
    private static string ValuePropertyName;
    private static JsonEncodedText s_valuePropertyNameBytes;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; public set; }
    private static CertificateBackup();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Byte[] value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Certificates.CertificateClient : object {
    internal static string CertificatesPath;
    internal static string DeletedCertificatesPath;
    private static string CallerShouldAuditReason;
    private static string OTelCertificateNameKey;
    private static string OTelCertificateVersionKey;
    private static string OTelCertificateIssuerNameKey;
    private static string IssuersPath;
    private static string ContactsPath;
    private KeyVaultPipeline _pipeline;
    public Uri VaultUri { get; }
    public CertificateClient(Uri vaultUri, TokenCredential credential);
    public CertificateClient(Uri vaultUri, TokenCredential credential, CertificateClientOptions options);
    public virtual Uri get_VaultUri();
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual CertificateOperation StartCreateCertificate(string certificateName, CertificatePolicy policy, Nullable`1<bool> enabled, IDictionary`2<string, string> tags, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<StartCreateCertificateAsync>d__15")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<CertificateOperation> StartCreateCertificateAsync(string certificateName, CertificatePolicy policy, Nullable`1<bool> enabled, IDictionary`2<string, string> tags, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<X509Certificate2> DownloadCertificate(string certificateName, string version, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<X509Certificate2> DownloadCertificate(DownloadCertificateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<DownloadCertificateAsync>d__18")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<X509Certificate2>> DownloadCertificateAsync(string certificateName, string version, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<DownloadCertificateAsync>d__19")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<X509Certificate2>> DownloadCertificateAsync(DownloadCertificateOptions options, CancellationToken cancellationToken);
    public virtual Response`1<KeyVaultCertificateWithPolicy> GetCertificate(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<GetCertificateAsync>d__21")]
public virtual Task`1<Response`1<KeyVaultCertificateWithPolicy>> GetCertificateAsync(string certificateName, CancellationToken cancellationToken);
    public virtual Response`1<KeyVaultCertificate> GetCertificateVersion(string certificateName, string version, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<GetCertificateVersionAsync>d__23")]
public virtual Task`1<Response`1<KeyVaultCertificate>> GetCertificateVersionAsync(string certificateName, string version, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<KeyVaultCertificate> UpdateCertificateProperties(CertificateProperties properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<UpdateCertificatePropertiesAsync>d__25")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<KeyVaultCertificate>> UpdateCertificatePropertiesAsync(CertificateProperties properties, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual DeleteCertificateOperation StartDeleteCertificate(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<StartDeleteCertificateAsync>d__27")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<DeleteCertificateOperation> StartDeleteCertificateAsync(string certificateName, CancellationToken cancellationToken);
    public virtual Response`1<DeletedCertificate> GetDeletedCertificate(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<GetDeletedCertificateAsync>d__29")]
public virtual Task`1<Response`1<DeletedCertificate>> GetDeletedCertificateAsync(string certificateName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual RecoverDeletedCertificateOperation StartRecoverDeletedCertificate(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<StartRecoverDeletedCertificateAsync>d__31")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<RecoverDeletedCertificateOperation> StartRecoverDeletedCertificateAsync(string certificateName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response PurgeDeletedCertificate(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<PurgeDeletedCertificateAsync>d__33")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response> PurgeDeletedCertificateAsync(string certificateName, CancellationToken cancellationToken);
    public virtual Response`1<Byte[]> BackupCertificate(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<BackupCertificateAsync>d__35")]
public virtual Task`1<Response`1<Byte[]>> BackupCertificateAsync(string certificateName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<KeyVaultCertificateWithPolicy> RestoreCertificateBackup(Byte[] backup, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<RestoreCertificateBackupAsync>d__37")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<KeyVaultCertificateWithPolicy>> RestoreCertificateBackupAsync(Byte[] backup, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<KeyVaultCertificateWithPolicy> ImportCertificate(ImportCertificateOptions importCertificateOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<ImportCertificateAsync>d__39")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<KeyVaultCertificateWithPolicy>> ImportCertificateAsync(ImportCertificateOptions importCertificateOptions, CancellationToken cancellationToken);
    public virtual Pageable`1<CertificateProperties> GetPropertiesOfCertificates(bool includePending, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<CertificateProperties> GetPropertiesOfCertificatesAsync(bool includePending, CancellationToken cancellationToken);
    public virtual Pageable`1<CertificateProperties> GetPropertiesOfCertificateVersions(string certificateName, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<CertificateProperties> GetPropertiesOfCertificateVersionsAsync(string certificateName, CancellationToken cancellationToken);
    public virtual Pageable`1<DeletedCertificate> GetDeletedCertificates(bool includePending, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<DeletedCertificate> GetDeletedCertificatesAsync(bool includePending, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<CertificatePolicy> GetCertificatePolicy(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<GetCertificatePolicyAsync>d__47")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<CertificatePolicy>> GetCertificatePolicyAsync(string certificateName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<CertificatePolicy> UpdateCertificatePolicy(string certificateName, CertificatePolicy policy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<UpdateCertificatePolicyAsync>d__49")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<CertificatePolicy>> UpdateCertificatePolicyAsync(string certificateName, CertificatePolicy policy, CancellationToken cancellationToken);
    public virtual Response`1<CertificateIssuer> CreateIssuer(CertificateIssuer issuer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<CreateIssuerAsync>d__51")]
public virtual Task`1<Response`1<CertificateIssuer>> CreateIssuerAsync(CertificateIssuer issuer, CancellationToken cancellationToken);
    public virtual Response`1<CertificateIssuer> GetIssuer(string issuerName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<GetIssuerAsync>d__53")]
public virtual Task`1<Response`1<CertificateIssuer>> GetIssuerAsync(string issuerName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<CertificateIssuer> UpdateIssuer(CertificateIssuer issuer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<UpdateIssuerAsync>d__55")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<CertificateIssuer>> UpdateIssuerAsync(CertificateIssuer issuer, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<CertificateIssuer> DeleteIssuer(string issuerName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<DeleteIssuerAsync>d__57")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<CertificateIssuer>> DeleteIssuerAsync(string issuerName, CancellationToken cancellationToken);
    public virtual Pageable`1<IssuerProperties> GetPropertiesOfIssuers(CancellationToken cancellationToken);
    public virtual AsyncPageable`1<IssuerProperties> GetPropertiesOfIssuersAsync(CancellationToken cancellationToken);
    public virtual CertificateOperation GetCertificateOperation(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<GetCertificateOperationAsync>d__61")]
public virtual Task`1<CertificateOperation> GetCertificateOperationAsync(string certificateName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<IList`1<CertificateContact>> SetContacts(IEnumerable`1<CertificateContact> contacts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<SetContactsAsync>d__63")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<IList`1<CertificateContact>>> SetContactsAsync(IEnumerable`1<CertificateContact> contacts, CancellationToken cancellationToken);
    public virtual Response`1<IList`1<CertificateContact>> GetContacts(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<GetContactsAsync>d__65")]
public virtual Task`1<Response`1<IList`1<CertificateContact>>> GetContactsAsync(CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<IList`1<CertificateContact>> DeleteContacts(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<DeleteContactsAsync>d__67")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<IList`1<CertificateContact>>> DeleteContactsAsync(CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Response`1<KeyVaultCertificateWithPolicy> MergeCertificate(MergeCertificateOptions mergeCertificateOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<MergeCertificateAsync>d__69")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-certificates")]
public virtual Task`1<Response`1<KeyVaultCertificateWithPolicy>> MergeCertificateAsync(MergeCertificateOptions mergeCertificateOptions, CancellationToken cancellationToken);
    internal virtual Response`1<CertificateOperationProperties> GetPendingCertificate(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<GetPendingCertificateAsync>d__71")]
internal virtual Task`1<Response`1<CertificateOperationProperties>> GetPendingCertificateAsync(string certificateName, CancellationToken cancellationToken);
    internal virtual Response`1<CertificateOperationProperties> CancelCertificateOperation(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<CancelCertificateOperationAsync>d__73")]
internal virtual Task`1<Response`1<CertificateOperationProperties>> CancelCertificateOperationAsync(string certificateName, CancellationToken cancellationToken);
    internal virtual Response`1<CertificateOperationProperties> DeleteCertificateOperation(string certificateName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateClient/<DeleteCertificateOperationAsync>d__75")]
internal virtual Task`1<Response`1<CertificateOperationProperties>> DeleteCertificateOperationAsync(string certificateName, CancellationToken cancellationToken);
}
public class Azure.Security.KeyVault.Certificates.CertificateClientOptions : ClientOptions {
    internal static ServiceVersion LatestVersion;
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableChallengeResourceVerification>k__BackingField;
    public ServiceVersion Version { get; }
    public bool DisableChallengeResourceVerification { get; public set; }
    public CertificateClientOptions(ServiceVersion version);
    [CompilerGeneratedAttribute]
public ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
public bool get_DisableChallengeResourceVerification();
    [CompilerGeneratedAttribute]
public void set_DisableChallengeResourceVerification(bool value);
    internal string GetVersionString();
}
public class Azure.Security.KeyVault.Certificates.CertificateContact : object {
    private static string NamePropertyName;
    private static string EmailPropertyName;
    private static string PhonePropertyName;
    private static JsonEncodedText s_namePropertyNameBytes;
    private static JsonEncodedText s_emailPropertyNameBytes;
    private static JsonEncodedText s_phonePropertyNameBytes;
    [CompilerGeneratedAttribute]
private string <Email>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Phone>k__BackingField;
    public string Email { get; public set; }
    public string Name { get; public set; }
    public string Phone { get; public set; }
    private static CertificateContact();
    [CompilerGeneratedAttribute]
public string get_Email();
    [CompilerGeneratedAttribute]
public void set_Email(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Phone();
    [CompilerGeneratedAttribute]
public void set_Phone(string value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Certificates.CertificateContentType : ValueType {
    private string _value;
    [CompilerGeneratedAttribute]
private static CertificateContentType <Pkcs12>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateContentType <Pem>k__BackingField;
    public static CertificateContentType Pkcs12 { get; }
    public static CertificateContentType Pem { get; }
    public CertificateContentType(string value);
    private static CertificateContentType();
    [CompilerGeneratedAttribute]
public static CertificateContentType get_Pkcs12();
    [CompilerGeneratedAttribute]
public static CertificateContentType get_Pem();
    public static bool op_Equality(CertificateContentType left, CertificateContentType right);
    public static bool op_Inequality(CertificateContentType left, CertificateContentType right);
    public static CertificateContentType op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CertificateContentType other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Azure.Security.KeyVault.Certificates.CertificateCreateParameters : object {
    private static string PolicyPropertyName;
    private static string AttributesPropertyName;
    private static string EnabledPropertyName;
    private static string TagsPropertyName;
    private static JsonEncodedText s_policyPropertyNameBytes;
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_enabledPropertyNameBytes;
    private static JsonEncodedText s_tagsPropertyNameBytes;
    [CompilerGeneratedAttribute]
private CertificatePolicy <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    public CertificatePolicy Policy { get; }
    public Nullable`1<bool> Enabled { get; }
    public IDictionary`2<string, string> Tags { get; }
    public CertificateCreateParameters(CertificatePolicy policy, Nullable`1<bool> enabled, IDictionary`2<string, string> tags);
    private static CertificateCreateParameters();
    [CompilerGeneratedAttribute]
public CertificatePolicy get_Policy();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Certificates.CertificateIssuer : object {
    private static string CredentialsPropertyName;
    private static string OrgDetailsPropertyName;
    private static string AttributesPropertyName;
    private static string AccountIdPropertyName;
    private static string PasswordPropertyName;
    private static string OrganizationIdPropertyName;
    private static string AdminDetailsPropertyName;
    private static string CreatedPropertyName;
    private static string UpdatedPropertyName;
    private static string EnabledPropertyName;
    private static JsonEncodedText s_credentialsPropertyNameBytes;
    private static JsonEncodedText s_orgDetailsPropertyNameBytes;
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_enabledPropertyNameBytes;
    private static JsonEncodedText s_accountIdPropertyNameBytes;
    private static JsonEncodedText s_passwordPropertyNameBytes;
    private static JsonEncodedText s_organizationIdPropertyNameBytes;
    private static JsonEncodedText s_adminDetailsPropertyNameBytes;
    private List`1<AdministratorContact> _administratorContacts;
    private IssuerProperties _properties;
    [CompilerGeneratedAttribute]
private string <AccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OrganizationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <UpdatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    public Uri Id { get; }
    public string Name { get; }
    public string Provider { get; }
    public string AccountId { get; public set; }
    public string Password { get; public set; }
    public string OrganizationId { get; public set; }
    public IList`1<AdministratorContact> AdministratorContacts { get; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> UpdatedOn { get; internal set; }
    public Nullable`1<bool> Enabled { get; public set; }
    internal CertificateIssuer(IssuerProperties properties);
    public CertificateIssuer(string name);
    public CertificateIssuer(string name, string provider);
    private static CertificateIssuer();
    public Uri get_Id();
    public string get_Name();
    public string get_Provider();
    [CompilerGeneratedAttribute]
public string get_AccountId();
    [CompilerGeneratedAttribute]
public void set_AccountId(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_OrganizationId();
    [CompilerGeneratedAttribute]
public void set_OrganizationId(string value);
    public IList`1<AdministratorContact> get_AdministratorContacts();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_UpdatedOn();
    [CompilerGeneratedAttribute]
internal void set_UpdatedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(Nullable`1<bool> value);
    internal virtual void ReadProperty(JsonProperty prop);
    private void ReadCredentialsProperties(JsonElement json);
    private void ReadOrgDetailsProperties(JsonElement json);
    private void ReadAttributeProperties(JsonElement json);
    internal virtual void WriteProperties(Utf8JsonWriter json);
    private void WriteCredentialsProperties(Utf8JsonWriter json);
    private void WriteOrgDetailsProperties(Utf8JsonWriter json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Certificates.CertificateKeyCurveName : ValueType {
    private string _value;
    [CompilerGeneratedAttribute]
private static CertificateKeyCurveName <P256>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyCurveName <P384>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyCurveName <P521>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyCurveName <P256K>k__BackingField;
    public static CertificateKeyCurveName P256 { get; }
    public static CertificateKeyCurveName P384 { get; }
    public static CertificateKeyCurveName P521 { get; }
    public static CertificateKeyCurveName P256K { get; }
    public CertificateKeyCurveName(string value);
    private static CertificateKeyCurveName();
    [CompilerGeneratedAttribute]
public static CertificateKeyCurveName get_P256();
    [CompilerGeneratedAttribute]
public static CertificateKeyCurveName get_P384();
    [CompilerGeneratedAttribute]
public static CertificateKeyCurveName get_P521();
    [CompilerGeneratedAttribute]
public static CertificateKeyCurveName get_P256K();
    public static bool op_Equality(CertificateKeyCurveName left, CertificateKeyCurveName right);
    public static bool op_Inequality(CertificateKeyCurveName left, CertificateKeyCurveName right);
    public static CertificateKeyCurveName op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CertificateKeyCurveName other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Certificates.CertificateKeyType : ValueType {
    internal static string EcValue;
    internal static string EcHsmValue;
    internal static string RsaValue;
    internal static string RsaHsmValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static CertificateKeyType <Ec>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyType <EcHsm>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyType <Rsa>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyType <RsaHsm>k__BackingField;
    public static CertificateKeyType Ec { get; }
    public static CertificateKeyType EcHsm { get; }
    public static CertificateKeyType Rsa { get; }
    public static CertificateKeyType RsaHsm { get; }
    public CertificateKeyType(string value);
    private static CertificateKeyType();
    [CompilerGeneratedAttribute]
public static CertificateKeyType get_Ec();
    [CompilerGeneratedAttribute]
public static CertificateKeyType get_EcHsm();
    [CompilerGeneratedAttribute]
public static CertificateKeyType get_Rsa();
    [CompilerGeneratedAttribute]
public static CertificateKeyType get_RsaHsm();
    public static bool op_Equality(CertificateKeyType left, CertificateKeyType right);
    public static bool op_Inequality(CertificateKeyType left, CertificateKeyType right);
    public static CertificateKeyType op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CertificateKeyType other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Certificates.CertificateKeyUsage : ValueType {
    internal static string DigitalSignatureValue;
    internal static string NonRepudiationValue;
    internal static string KeyEnciphermentValue;
    internal static string DataEnciphermentValue;
    internal static string KeyAgreementValue;
    internal static string KeyCertSignValue;
    internal static string CrlSignValue;
    internal static string EncipherOnlyValue;
    internal static string DecipherOnlyValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <DigitalSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <NonRepudiation>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <KeyEncipherment>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <DataEncipherment>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <KeyAgreement>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <KeyCertSign>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <CrlSign>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <EncipherOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificateKeyUsage <DecipherOnly>k__BackingField;
    public static CertificateKeyUsage DigitalSignature { get; }
    public static CertificateKeyUsage NonRepudiation { get; }
    public static CertificateKeyUsage KeyEncipherment { get; }
    public static CertificateKeyUsage DataEncipherment { get; }
    public static CertificateKeyUsage KeyAgreement { get; }
    public static CertificateKeyUsage KeyCertSign { get; }
    public static CertificateKeyUsage CrlSign { get; }
    public static CertificateKeyUsage EncipherOnly { get; }
    public static CertificateKeyUsage DecipherOnly { get; }
    public CertificateKeyUsage(string value);
    private static CertificateKeyUsage();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_DigitalSignature();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_NonRepudiation();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_KeyEncipherment();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_DataEncipherment();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_KeyAgreement();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_KeyCertSign();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_CrlSign();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_EncipherOnly();
    [CompilerGeneratedAttribute]
public static CertificateKeyUsage get_DecipherOnly();
    public static bool op_Equality(CertificateKeyUsage left, CertificateKeyUsage right);
    public static bool op_Inequality(CertificateKeyUsage left, CertificateKeyUsage right);
    public static CertificateKeyUsage op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CertificateKeyUsage other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
public static class Azure.Security.KeyVault.Certificates.CertificateModelFactory : object {
    public static IssuerProperties IssuerProperties(Uri id, string name);
    public static CertificateIssuer CertificateIssuer(IssuerProperties properties, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> updatedOn);
    public static CertificateOperationError CertificateOperationError(string code, string message, CertificateOperationError innerError);
    public static CertificateOperationProperties CertificateOperationProperties(Uri id, string name, Uri vaultUri, string issuerName, string certificateType, Nullable`1<bool> certificateTransparency, Byte[] csr, bool cancellationRequested, string requestId, string status, string statusDetails, string target, CertificateOperationError error);
    public static CertificatePolicy CertificatePolicy(string subject, SubjectAlternativeNames subjectAlternativeNames, string issuerName, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> updatedOn);
    [EditorBrowsableAttribute("1")]
public static CertificateProperties CertificateProperties(Uri id, string name, Uri vaultUri, string version, Byte[] x509thumbprint, Nullable`1<DateTimeOffset> notBefore, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> updatedOn, string recoveryLevel);
    public static CertificateProperties CertificateProperties(Uri id, string name, Uri vaultUri, string version, Byte[] x509thumbprint, Nullable`1<DateTimeOffset> notBefore, Nullable`1<DateTimeOffset> expiresOn, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> updatedOn, string recoveryLevel, Nullable`1<int> recoverableDays);
    public static DeletedCertificate DeletedCertificate(CertificateProperties properties, Uri keyId, Uri secretId, Byte[] cer, CertificatePolicy policy, Uri recoveryId, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> scheduledPurgeDate);
    public static KeyVaultCertificate KeyVaultCertificate(CertificateProperties properties, Uri keyId, Uri secretId, Byte[] cer);
    public static KeyVaultCertificateWithPolicy KeyVaultCertificateWithPolicy(CertificateProperties properties, Uri keyId, Uri secretId, Byte[] cer, CertificatePolicy policy);
}
public class Azure.Security.KeyVault.Certificates.CertificateOperation : Operation`1<KeyVaultCertificateWithPolicy> {
    private static string CancelledStatus;
    private static string CompletedStatus;
    private CertificateClient _client;
    private bool _completed;
    private Response _response;
    private KeyVaultCertificateWithPolicy _value;
    [CompilerGeneratedAttribute]
private CertificateOperationProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public CertificateOperationProperties Properties { get; private set; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    public string Id { get; }
    public KeyVaultCertificateWithPolicy Value { get; }
    public CertificateOperation(CertificateClient client, string name);
    internal CertificateOperation(Response`1<CertificateOperationProperties> properties, CertificateClient client);
    [CompilerGeneratedAttribute]
public virtual CertificateOperationProperties get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(CertificateOperationProperties value);
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public virtual string get_Id();
    public virtual KeyVaultCertificateWithPolicy get_Value();
    public virtual Response GetRawResponse();
    public virtual ValueTask`1<Response`1<KeyVaultCertificateWithPolicy>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<KeyVaultCertificateWithPolicy>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateOperation/<UpdateStatusAsync>d__26")]
public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual void Cancel(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateOperation/<CancelAsync>d__28")]
public virtual Task CancelAsync(CancellationToken cancellationToken);
    public virtual void Delete(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.CertificateOperation/<DeleteAsync>d__30")]
public virtual Task DeleteAsync(CancellationToken cancellationToken);
}
public class Azure.Security.KeyVault.Certificates.CertificateOperationError : object {
    private static string CodePropertyName;
    private static string MessagePropertyName;
    private static string InnerErrorPropertyName;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateOperationError <InnerError>k__BackingField;
    public string Code { get; internal set; }
    public string Message { get; internal set; }
    public CertificateOperationError InnerError { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
internal void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
internal void set_Message(string value);
    [CompilerGeneratedAttribute]
public CertificateOperationError get_InnerError();
    [CompilerGeneratedAttribute]
internal void set_InnerError(CertificateOperationError value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
public class Azure.Security.KeyVault.Certificates.CertificateOperationProperties : object {
    private static string IdPropertyName;
    private static string IssuerProperyName;
    private static string CsrPropertyName;
    private static string CancellationRequestedPropertyName;
    private static string RequestIdPropertyName;
    private static string StatusPropertyName;
    private static string StatusDetailsPropertyName;
    private static string TargetPropertyName;
    private static string ErrorPropertyName;
    private static string Collection;
    private IssuerParameters _issuer;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Csr>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CancellationRequested>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatusDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateOperationError <Error>k__BackingField;
    public Uri Id { get; internal set; }
    public string Name { get; internal set; }
    public Uri VaultUri { get; internal set; }
    public string IssuerName { get; internal set; }
    public string CertificateType { get; internal set; }
    public Nullable`1<bool> CertificateTransparency { get; internal set; }
    public Byte[] Csr { get; internal set; }
    public bool CancellationRequested { get; internal set; }
    public string RequestId { get; internal set; }
    public string Status { get; internal set; }
    public string StatusDetails { get; internal set; }
    public string Target { get; internal set; }
    public CertificateOperationError Error { get; internal set; }
    internal CertificateOperationProperties(Uri vaultUri, string name);
    [CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Uri value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public Uri get_VaultUri();
    [CompilerGeneratedAttribute]
internal void set_VaultUri(Uri value);
    public string get_IssuerName();
    internal void set_IssuerName(string value);
    public string get_CertificateType();
    internal void set_CertificateType(string value);
    public Nullable`1<bool> get_CertificateTransparency();
    internal void set_CertificateTransparency(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Byte[] get_Csr();
    [CompilerGeneratedAttribute]
internal void set_Csr(Byte[] value);
    [CompilerGeneratedAttribute]
public bool get_CancellationRequested();
    [CompilerGeneratedAttribute]
internal void set_CancellationRequested(bool value);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
internal void set_RequestId(string value);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
internal void set_Status(string value);
    [CompilerGeneratedAttribute]
public string get_StatusDetails();
    [CompilerGeneratedAttribute]
internal void set_StatusDetails(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
internal void set_Target(string value);
    [CompilerGeneratedAttribute]
public CertificateOperationError get_Error();
    [CompilerGeneratedAttribute]
internal void set_Error(CertificateOperationError value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private void ParseId(Uri idToParse);
}
internal class Azure.Security.KeyVault.Certificates.CertificateOperationUpdateParameters : object {
    private static string CancellationRequestedPropertyName;
    private static JsonEncodedText s_cancellationRequestedPropertyNameBytes;
    private bool _cancellationRequested;
    public CertificateOperationUpdateParameters(bool cancellationRequested);
    private static CertificateOperationUpdateParameters();
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Certificates.CertificatePolicy : object {
    private static string DefaultSubject;
    private static string DefaultIssuerName;
    private static string KeyTypePropertyName;
    private static string ReuseKeyPropertyName;
    private static string ExportablePropertyName;
    private static string CurveNamePropertyName;
    private static string KeySizePropertyName;
    private static string KeyPropsPropertyName;
    private static string SecretPropsPropertyName;
    private static string X509PropsPropertyName;
    private static string LifetimeActionsPropertyName;
    private static string IssuerPropertyName;
    private static string AttributesPropertyName;
    private static string ContentTypePropertyName;
    private static string SubjectPropertyName;
    private static string SansPropertyName;
    private static string KeyUsagePropertyName;
    private static string EkusPropertyName;
    private static string ValidityMonthsPropertyName;
    private static string EnabledPropertyName;
    private static string CreatedPropertyName;
    private static string UpdatedPropertyName;
    private static JsonEncodedText s_keyTypePropertyNameBytes;
    private static JsonEncodedText s_reuseKeyPropertyNameBytes;
    private static JsonEncodedText s_exportablePropertyNameBytes;
    private static JsonEncodedText s_curveNamePropertyNameBytes;
    private static JsonEncodedText s_keySizePropertyNameBytes;
    private static JsonEncodedText s_lifetimeActionsPropertyNameBytes;
    private static JsonEncodedText s_issuerPropertyNameBytes;
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_keyPropsPropertyNameBytes;
    private static JsonEncodedText s_secretPropsPropertyNameBytes;
    private static JsonEncodedText s_x509PropsPropertyNameBytes;
    private static JsonEncodedText s_contentTypePropertyNameBytes;
    private static JsonEncodedText s_subjectPropertyNameBytes;
    private static JsonEncodedText s_sansPropertyNameBytes;
    private static JsonEncodedText s_keyUsagePropertyNameBytes;
    private static JsonEncodedText s_ekusPropertyNameBytes;
    private static JsonEncodedText s_validityMonthsPropertyNameBytes;
    private static JsonEncodedText s_enabledPropertyNameBytes;
    private IssuerParameters _issuer;
    [CompilerGeneratedAttribute]
private Nullable`1<CertificateKeyType> <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReuseKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Exportable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CertificateKeyCurveName> <KeyCurveName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <KeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectAlternativeNames <SubjectAlternativeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CertificateContentType> <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ValidityInMonths>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <UpdatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CertificateKeyUsage> <KeyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <EnhancedKeyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LifetimeAction> <LifetimeActions>k__BackingField;
    public static CertificatePolicy Default { get; }
    public Nullable`1<CertificateKeyType> KeyType { get; public set; }
    public Nullable`1<bool> ReuseKey { get; public set; }
    public Nullable`1<bool> Exportable { get; public set; }
    public Nullable`1<CertificateKeyCurveName> KeyCurveName { get; public set; }
    public Nullable`1<int> KeySize { get; public set; }
    public string Subject { get; internal set; }
    public SubjectAlternativeNames SubjectAlternativeNames { get; internal set; }
    public string IssuerName { get; internal set; }
    public Nullable`1<CertificateContentType> ContentType { get; public set; }
    public string CertificateType { get; public set; }
    public Nullable`1<bool> CertificateTransparency { get; public set; }
    public Nullable`1<int> ValidityInMonths { get; public set; }
    public Nullable`1<bool> Enabled { get; public set; }
    public Nullable`1<DateTimeOffset> UpdatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public IList`1<CertificateKeyUsage> KeyUsage { get; }
    public IList`1<string> EnhancedKeyUsage { get; }
    public IList`1<LifetimeAction> LifetimeActions { get; }
    public CertificatePolicy(string issuerName, string subject);
    public CertificatePolicy(string issuerName, SubjectAlternativeNames subjectAlternativeNames);
    public CertificatePolicy(string issuerName, string subject, SubjectAlternativeNames subjectAlternativeNames);
    private static CertificatePolicy();
    public static CertificatePolicy get_Default();
    [CompilerGeneratedAttribute]
public Nullable`1<CertificateKeyType> get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(Nullable`1<CertificateKeyType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReuseKey();
    [CompilerGeneratedAttribute]
public void set_ReuseKey(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Exportable();
    [CompilerGeneratedAttribute]
public void set_Exportable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<CertificateKeyCurveName> get_KeyCurveName();
    [CompilerGeneratedAttribute]
public void set_KeyCurveName(Nullable`1<CertificateKeyCurveName> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_KeySize();
    [CompilerGeneratedAttribute]
public void set_KeySize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
internal void set_Subject(string value);
    [CompilerGeneratedAttribute]
public SubjectAlternativeNames get_SubjectAlternativeNames();
    [CompilerGeneratedAttribute]
internal void set_SubjectAlternativeNames(SubjectAlternativeNames value);
    public string get_IssuerName();
    internal void set_IssuerName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<CertificateContentType> get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(Nullable`1<CertificateContentType> value);
    public string get_CertificateType();
    public void set_CertificateType(string value);
    public Nullable`1<bool> get_CertificateTransparency();
    public void set_CertificateTransparency(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ValidityInMonths();
    [CompilerGeneratedAttribute]
public void set_ValidityInMonths(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_UpdatedOn();
    [CompilerGeneratedAttribute]
internal void set_UpdatedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public IList`1<CertificateKeyUsage> get_KeyUsage();
    [CompilerGeneratedAttribute]
public IList`1<string> get_EnhancedKeyUsage();
    [CompilerGeneratedAttribute]
public IList`1<LifetimeAction> get_LifetimeActions();
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
    private void ReadKeyProperties(JsonElement json);
    private void WriteKeyProperties(Utf8JsonWriter json);
    private void ReadSecretProperties(JsonElement json);
    private void WriteSecretProperties(Utf8JsonWriter json);
    private void ReadX509CertificateProperties(JsonElement json);
    private void WriteX509CertificateProperties(Utf8JsonWriter json);
    private void ReadAttributesProperties(JsonElement json);
    private void WriteAttributesProperties(Utf8JsonWriter json);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Certificates.CertificatePolicyAction : ValueType {
    internal static string AutoRenewValue;
    internal static string EmailContactsValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static CertificatePolicyAction <AutoRenew>k__BackingField;
    [CompilerGeneratedAttribute]
private static CertificatePolicyAction <EmailContacts>k__BackingField;
    public static CertificatePolicyAction AutoRenew { get; }
    public static CertificatePolicyAction EmailContacts { get; }
    public CertificatePolicyAction(string value);
    private static CertificatePolicyAction();
    [CompilerGeneratedAttribute]
public static CertificatePolicyAction get_AutoRenew();
    [CompilerGeneratedAttribute]
public static CertificatePolicyAction get_EmailContacts();
    public static bool op_Equality(CertificatePolicyAction left, CertificatePolicyAction right);
    public static bool op_Inequality(CertificatePolicyAction left, CertificatePolicyAction right);
    public static CertificatePolicyAction op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CertificatePolicyAction other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
public class Azure.Security.KeyVault.Certificates.CertificateProperties : object {
    private static string IdPropertyName;
    private static string X509ThumprintPropertyName;
    private static string TagsPropertyName;
    private static string AttributesPropertyName;
    private CertificateAttributes _attributes;
    private Dictionary`2<string, string> _tags;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <X509Thumbprint>k__BackingField;
    public Uri Id { get; internal set; }
    public string Name { get; internal set; }
    public Uri VaultUri { get; internal set; }
    public string Version { get; internal set; }
    [EditorBrowsableAttribute("1")]
public Byte[] X509Thumbprint { get; internal set; }
    public string X509ThumbprintString { get; }
    public IDictionary`2<string, string> Tags { get; }
    public Nullable`1<bool> Enabled { get; public set; }
    public Nullable`1<DateTimeOffset> NotBefore { get; internal set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; internal set; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> UpdatedOn { get; internal set; }
    public Nullable`1<int> RecoverableDays { get; internal set; }
    public string RecoveryLevel { get; internal set; }
    internal bool HasTags { get; }
    public CertificateProperties(string name);
    public CertificateProperties(Uri id);
    [CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Uri value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public Uri get_VaultUri();
    [CompilerGeneratedAttribute]
internal void set_VaultUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_X509Thumbprint();
    [CompilerGeneratedAttribute]
internal void set_X509Thumbprint(Byte[] value);
    public string get_X509ThumbprintString();
    public IDictionary`2<string, string> get_Tags();
    public Nullable`1<bool> get_Enabled();
    public void set_Enabled(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_NotBefore();
    internal void set_NotBefore(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ExpiresOn();
    internal void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_CreatedOn();
    internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_UpdatedOn();
    internal void set_UpdatedOn(Nullable`1<DateTimeOffset> value);
    public Nullable`1<int> get_RecoverableDays();
    internal void set_RecoverableDays(Nullable`1<int> value);
    public string get_RecoveryLevel();
    internal void set_RecoveryLevel(string value);
    internal bool get_HasTags();
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    internal void ReadProperty(JsonProperty prop);
    private void ParseId(Uri id);
}
[EventSourceAttribute]
internal class Azure.Security.KeyVault.Certificates.CertificatesEventSource : AzureEventSource {
    internal static int BeginUpdateStatusEvent;
    internal static int EndUpdateStatusEvent;
    private static string EventSourceName;
    private static string Deleted;
    private static string NoError;
    [CompilerGeneratedAttribute]
private static CertificatesEventSource <Singleton>k__BackingField;
    public static CertificatesEventSource Singleton { get; }
    private static CertificatesEventSource();
    [CompilerGeneratedAttribute]
public static CertificatesEventSource get_Singleton();
    [NonEventAttribute]
public void BeginUpdateStatus(CertificateOperationProperties properties);
    [EventAttribute("1")]
public void BeginUpdateStatus(string id, string status, string error);
    [NonEventAttribute]
public void EndUpdateStatus(CertificateOperationProperties properties);
    [EventAttribute("2")]
public void EndUpdateStatus(string id, string status, string error);
}
internal class Azure.Security.KeyVault.Certificates.CertificateUpdateParameters : object {
    private static string AttributesPropertyName;
    private static string EnabledPropertyName;
    private static string TagsPropertyName;
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_enabledPropertyNameBytes;
    private static JsonEncodedText s_tagsPropertyNameBytes;
    [CompilerGeneratedAttribute]
private CertificateProperties <Properties>k__BackingField;
    public CertificateProperties Properties { get; }
    public CertificateUpdateParameters(CertificateProperties properties);
    private static CertificateUpdateParameters();
    [CompilerGeneratedAttribute]
public CertificateProperties get_Properties();
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
internal class Azure.Security.KeyVault.Certificates.ContactList : object {
    private static string ContactsPropertyName;
    private static JsonEncodedText s_contactsPropertyNameBytes;
    private IEnumerable`1<CertificateContact> _contacts;
    public ContactList(IEnumerable`1<CertificateContact> contacts);
    private static ContactList();
    public IList`1<CertificateContact> ToList();
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Certificates.DeleteCertificateOperation : Operation`1<DeletedCertificate> {
    private static TimeSpan s_defaultPollingInterval;
    private KeyVaultPipeline _pipeline;
    private OperationInternal _operationInternal;
    private DeletedCertificate _value;
    public string Id { get; }
    public DeletedCertificate Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal DeleteCertificateOperation(KeyVaultPipeline pipeline, Response`1<DeletedCertificate> response);
    private static DeleteCertificateOperation();
    public virtual string get_Id();
    public virtual DeletedCertificate get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.DeleteCertificateOperation/<UpdateStatusAsync>d__16")]
public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<DeletedCertificate>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<DeletedCertificate>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.DeleteCertificateOperation/<Azure-Core-IOperation-UpdateStateAsync>d__19")]
private sealed virtual override ValueTask`1<OperationState> Azure.Core.IOperation.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
public class Azure.Security.KeyVault.Certificates.DeletedCertificate : KeyVaultCertificateWithPolicy {
    private static string RecoveryIdPropertyName;
    private static string ScheduledPurgeDatePropertyName;
    private static string DeletedOnPropertyName;
    private string _recoveryId;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ScheduledPurgeDate>k__BackingField;
    public Uri RecoveryId { get; internal set; }
    public Nullable`1<DateTimeOffset> DeletedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> ScheduledPurgeDate { get; internal set; }
    internal DeletedCertificate(CertificateProperties properties);
    public Uri get_RecoveryId();
    internal void set_RecoveryId(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedOn();
    [CompilerGeneratedAttribute]
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ScheduledPurgeDate();
    [CompilerGeneratedAttribute]
internal void set_ScheduledPurgeDate(Nullable`1<DateTimeOffset> value);
    internal virtual void ReadProperty(JsonProperty prop);
}
public class Azure.Security.KeyVault.Certificates.DownloadCertificateOptions : object {
    [CompilerGeneratedAttribute]
private string <CertificateName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private X509KeyStorageFlags <KeyStorageFlags>k__BackingField;
    public string CertificateName { get; }
    public string Version { get; public set; }
    public X509KeyStorageFlags KeyStorageFlags { get; public set; }
    public DownloadCertificateOptions(string certificateName);
    [CompilerGeneratedAttribute]
public string get_CertificateName();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public X509KeyStorageFlags get_KeyStorageFlags();
    [CompilerGeneratedAttribute]
public void set_KeyStorageFlags(X509KeyStorageFlags value);
}
public class Azure.Security.KeyVault.Certificates.ImportCertificateOptions : object {
    private static JsonEncodedText s_valuePropertyNameBytes;
    private static JsonEncodedText s_policyPropertyNameBytes;
    private static JsonEncodedText s_passwordPropertyNameBytes;
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_enabledPropertyNameBytes;
    private static JsonEncodedText s_tagsPropertyNameBytes;
    private Dictionary`2<string, string> _tags;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificatePolicy <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    public string Name { get; }
    public Byte[] Certificate { get; }
    public CertificatePolicy Policy { get; public set; }
    public string Password { get; public set; }
    public Nullable`1<bool> Enabled { get; public set; }
    public IDictionary`2<string, string> Tags { get; }
    public ImportCertificateOptions(string name, Byte[] certificate);
    private static ImportCertificateOptions();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Byte[] get_Certificate();
    [CompilerGeneratedAttribute]
public CertificatePolicy get_Policy();
    [CompilerGeneratedAttribute]
public void set_Policy(CertificatePolicy value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(Nullable`1<bool> value);
    public IDictionary`2<string, string> get_Tags();
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
internal class Azure.Security.KeyVault.Certificates.IssuerParameters : ValueType {
    private static string IssuerNamePropertyName;
    private static string CertificateTypePropertyName;
    private static string CertificateTransparencyPropertyName;
    private static JsonEncodedText s_issuerNamePropertyNameBytes;
    private static JsonEncodedText s_certificateTypePropertyNameBytes;
    private static JsonEncodedText s_certificateTransparencyPropertyNameNameBytes;
    [CompilerGeneratedAttribute]
private string <IssuerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CertificateTransparency>k__BackingField;
    internal string IssuerName { get; internal set; }
    internal string CertificateType { get; internal set; }
    internal Nullable`1<bool> CertificateTransparency { get; internal set; }
    private static IssuerParameters();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_IssuerName();
    [CompilerGeneratedAttribute]
internal void set_IssuerName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_CertificateType();
    [CompilerGeneratedAttribute]
internal void set_CertificateType(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Nullable`1<bool> get_CertificateTransparency();
    [CompilerGeneratedAttribute]
internal void set_CertificateTransparency(Nullable`1<bool> value);
    internal void ReadProperties(JsonElement json);
    internal void WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Certificates.IssuerProperties : object {
    private static string IdPropertyName;
    private static string ProviderPropertyName;
    private static JsonEncodedText s_providerPropertyNameBytes;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Provider>k__BackingField;
    public Uri Id { get; internal set; }
    public string Name { get; internal set; }
    public string Provider { get; public set; }
    internal IssuerProperties(string name);
    private static IssuerProperties();
    [CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Uri value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Provider();
    [CompilerGeneratedAttribute]
public void set_Provider(string value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    internal void ReadProperty(JsonProperty prop);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
    internal void WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Certificates.KeyVaultCertificate : object {
    private static string KeyIdPropertyName;
    private static string SecretIdPropertyName;
    private static string CERPropertyName;
    private string _keyId;
    private string _secretId;
    [CompilerGeneratedAttribute]
private CertificateProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Cer>k__BackingField;
    public Uri Id { get; }
    public string Name { get; }
    public Uri KeyId { get; internal set; }
    public Uri SecretId { get; internal set; }
    public CertificateProperties Properties { get; }
    public Byte[] Cer { get; internal set; }
    internal KeyVaultCertificate(CertificateProperties properties);
    public Uri get_Id();
    public string get_Name();
    public Uri get_KeyId();
    internal void set_KeyId(Uri value);
    public Uri get_SecretId();
    internal void set_SecretId(Uri value);
    [CompilerGeneratedAttribute]
public CertificateProperties get_Properties();
    [CompilerGeneratedAttribute]
public Byte[] get_Cer();
    [CompilerGeneratedAttribute]
internal void set_Cer(Byte[] value);
    internal virtual void ReadProperty(JsonProperty prop);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Certificates.KeyVaultCertificateIdentifier : ValueType {
    [CompilerGeneratedAttribute]
private Uri <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public Uri SourceId { get; }
    public Uri VaultUri { get; }
    public string Name { get; }
    public string Version { get; }
    public KeyVaultCertificateIdentifier(Uri id);
    private KeyVaultCertificateIdentifier(Uri sourceId, Uri vaultUri, string name, string version);
    [CompilerGeneratedAttribute]
public Uri get_SourceId();
    [CompilerGeneratedAttribute]
public Uri get_VaultUri();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    public static bool TryCreate(Uri id, KeyVaultCertificateIdentifier& identifier);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(KeyVaultCertificateIdentifier other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
public class Azure.Security.KeyVault.Certificates.KeyVaultCertificateWithPolicy : KeyVaultCertificate {
    private static string PolicyPropertyName;
    [CompilerGeneratedAttribute]
private CertificatePolicy <Policy>k__BackingField;
    public CertificatePolicy Policy { get; internal set; }
    internal KeyVaultCertificateWithPolicy(CertificateProperties properties);
    [CompilerGeneratedAttribute]
public CertificatePolicy get_Policy();
    [CompilerGeneratedAttribute]
internal void set_Policy(CertificatePolicy value);
    internal virtual void ReadProperty(JsonProperty prop);
}
internal class Azure.Security.KeyVault.Certificates.KeyVaultSecret : object {
    private static string ContentTypePropertyName;
    private static string ValuePropertyName;
    [CompilerGeneratedAttribute]
private Nullable`1<CertificateContentType> <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public Nullable`1<CertificateContentType> ContentType { get; internal set; }
    public string Value { get; internal set; }
    [CompilerGeneratedAttribute]
public Nullable`1<CertificateContentType> get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(Nullable`1<CertificateContentType> value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(string value);
    internal virtual void ReadProperty(JsonProperty prop);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
public class Azure.Security.KeyVault.Certificates.LifetimeAction : object {
    private static string TriggerPropertyName;
    private static string ActionPropertyName;
    private static string LifetimePercentagePropertyName;
    private static string DaysBeforeExpiryPropertyName;
    private static string ActionTypePropertyName;
    private static JsonEncodedText s_triggerPropertyNameBytes;
    private static JsonEncodedText s_actionPropertyNameBytes;
    private static JsonEncodedText s_lifetimePercentagePropertyNameBytes;
    private static JsonEncodedText s_daysBeforeExpiryPropertyNameBytes;
    private static JsonEncodedText s_actionTypePropertyNameBytes;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DaysBeforeExpiry>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LifetimePercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificatePolicyAction <Action>k__BackingField;
    public Nullable`1<int> DaysBeforeExpiry { get; public set; }
    public Nullable`1<int> LifetimePercentage { get; public set; }
    public CertificatePolicyAction Action { get; private set; }
    public LifetimeAction(CertificatePolicyAction action);
    private static LifetimeAction();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DaysBeforeExpiry();
    [CompilerGeneratedAttribute]
public void set_DaysBeforeExpiry(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LifetimePercentage();
    [CompilerGeneratedAttribute]
public void set_LifetimePercentage(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public CertificatePolicyAction get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(CertificatePolicyAction value);
    internal static LifetimeAction FromJsonObject(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Certificates.MergeCertificateOptions : object {
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_enabledPropertyNameBytes;
    private static JsonEncodedText s_tagsPropertyNameBytes;
    private static JsonEncodedText s_x5cPropertyNameBytes;
    private Dictionary`2<string, string> _tags;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Byte[]> <X509Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    public string Name { get; }
    public IEnumerable`1<Byte[]> X509Certificates { get; }
    public Nullable`1<bool> Enabled { get; public set; }
    public IDictionary`2<string, string> Tags { get; }
    public MergeCertificateOptions(string name, IEnumerable`1<Byte[]> x509Certificates);
    private static MergeCertificateOptions();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Byte[]> get_X509Certificates();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(Nullable`1<bool> value);
    public IDictionary`2<string, string> get_Tags();
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Certificates.RecoverDeletedCertificateOperation : Operation`1<KeyVaultCertificateWithPolicy> {
    private static TimeSpan s_defaultPollingInterval;
    private KeyVaultPipeline _pipeline;
    private OperationInternal _operationInternal;
    private KeyVaultCertificateWithPolicy _value;
    public string Id { get; }
    public KeyVaultCertificateWithPolicy Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal RecoverDeletedCertificateOperation(KeyVaultPipeline pipeline, Response`1<KeyVaultCertificateWithPolicy> response);
    private static RecoverDeletedCertificateOperation();
    public virtual string get_Id();
    public virtual KeyVaultCertificateWithPolicy get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.RecoverDeletedCertificateOperation/<UpdateStatusAsync>d__16")]
public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<KeyVaultCertificateWithPolicy>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<KeyVaultCertificateWithPolicy>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Certificates.RecoverDeletedCertificateOperation/<Azure-Core-IOperation-UpdateStateAsync>d__19")]
private sealed virtual override ValueTask`1<OperationState> Azure.Core.IOperation.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
public class Azure.Security.KeyVault.Certificates.SubjectAlternativeNames : object {
    private static string DnsPropertyName;
    private static string EmailsPropertyName;
    private static string UpnsPropertyName;
    private static JsonEncodedText s_dnsPropertyNameBytes;
    private static JsonEncodedText s_emailsPropertyNameBytes;
    private static JsonEncodedText s_upnsPropertyNameBytes;
    private Collection`1<string> _dnsNames;
    private Collection`1<string> _emails;
    private Collection`1<string> _userPrincipalNames;
    public IList`1<string> DnsNames { get; }
    public IList`1<string> Emails { get; }
    public IList`1<string> UserPrincipalNames { get; }
    internal bool IsEmpty { get; }
    private static SubjectAlternativeNames();
    public IList`1<string> get_DnsNames();
    public IList`1<string> get_Emails();
    public IList`1<string> get_UserPrincipalNames();
    internal bool get_IsEmpty();
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public static class Azure.Security.KeyVault.Certificates.WellKnownIssuerNames : object {
    public static string Self;
    public static string Unknown;
}
internal class Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy : BearerTokenAuthenticationPolicy {
    private static string KeyVaultStashedContentKey;
    private bool _verifyChallengeResource;
    private static ConcurrentDictionary`2<string, ChallengeParameters> s_challengeCache;
    private ChallengeParameters _challenge;
    public ChallengeBasedAuthenticationPolicy(TokenCredential credential, bool disableChallengeResourceVerification);
    private static ChallengeBasedAuthenticationPolicy();
    protected virtual ValueTask AuthorizeRequestAsync(HttpMessage message);
    protected virtual void AuthorizeRequest(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy/<AuthorizeRequestInternal>d__7")]
private ValueTask AuthorizeRequestInternal(HttpMessage message, bool async);
    protected virtual ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message);
    protected virtual bool AuthorizeRequestOnChallenge(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy/<AuthorizeRequestOnChallengeAsyncInternal>d__10")]
private ValueTask`1<bool> AuthorizeRequestOnChallengeAsyncInternal(HttpMessage message, bool async);
    internal static void ClearCache();
    private static string GetRequestAuthority(Request request);
}
[ExtensionAttribute]
internal static class Azure.Security.KeyVault.ClientOptionsExtensions : object {
    [ExtensionAttribute]
public static void ConfigureLogging(ClientOptions clientOptions);
}
[ExtensionAttribute]
internal static class Azure.Security.KeyVault.Extensions : object {
    [ExtensionAttribute]
public static string ToHexString(Byte[] source);
    [ExtensionAttribute]
public static T[] Clone(T[] source);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(ICollection`1<T> source);
}
internal interface Azure.Security.KeyVault.IJsonDeserializable {
    public abstract virtual void ReadProperties(JsonElement json);
}
internal interface Azure.Security.KeyVault.IJsonSerializable {
    public abstract virtual void WriteProperties(Utf8JsonWriter json);
}
internal class Azure.Security.KeyVault.KeyVaultIdentifier : ValueType {
    public static string SecretsCollection;
    public static string KeysCollection;
    public static string CertificatesCollection;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public Uri Id { get; private set; }
    public Uri VaultUri { get; public set; }
    public string Name { get; public set; }
    public string Collection { get; public set; }
    public string Version { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Uri value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Uri get_VaultUri();
    [CompilerGeneratedAttribute]
public void set_VaultUri(Uri value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public static KeyVaultIdentifier Parse(Uri id);
    public static KeyVaultIdentifier ParseWithCollection(Uri id, string collection);
    public static bool TryParse(Uri id, KeyVaultIdentifier& identifier);
}
internal class Azure.Security.KeyVault.KeyVaultPage`1 : object {
    private T[] _items;
    private Func`1<T> _itemFactory;
    [CompilerGeneratedAttribute]
private Uri <NextLink>k__BackingField;
    public ReadOnlySpan`1<T> Items { get; }
    public Uri NextLink { get; private set; }
    internal KeyVaultPage`1(Func`1<T> itemFactory);
    public ReadOnlySpan`1<T> get_Items();
    [CompilerGeneratedAttribute]
public Uri get_NextLink();
    [CompilerGeneratedAttribute]
private void set_NextLink(Uri value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
internal class Azure.Security.KeyVault.KeyVaultPipeline : object {
    private HttpPipeline _pipeline;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    public ClientDiagnostics Diagnostics { get; }
    public string ApiVersion { get; }
    public Uri VaultUri { get; }
    public KeyVaultPipeline(Uri vaultUri, string apiVersion, HttpPipeline pipeline, ClientDiagnostics clientDiagnostics);
    [CompilerGeneratedAttribute]
public ClientDiagnostics get_Diagnostics();
    [CompilerGeneratedAttribute]
public string get_ApiVersion();
    [CompilerGeneratedAttribute]
public Uri get_VaultUri();
    public Uri CreateFirstPageUri(string path);
    public Uri CreateFirstPageUri(string path, ValueTuple`2[] queryParams);
    public Request CreateRequest(RequestMethod method, Uri uri, bool appendApiVersion);
    public Request CreateRequest(RequestMethod method, String[] path);
    public Response`1<T> CreateResponse(Response response, T result);
    public DiagnosticScope CreateScope(string name);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<GetPageAsync>d__17`1")]
public Task`1<Page`1<T>> GetPageAsync(Uri firstPageUri, string nextLink, Func`1<T> itemFactory, string operationName, CancellationToken cancellationToken);
    public Page`1<T> GetPage(Uri firstPageUri, string nextLink, Func`1<T> itemFactory, string operationName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__19`2")]
public Task`1<Response`1<TResult>> SendRequestAsync(RequestMethod method, TContent content, Func`1<TResult> resultFactory, CancellationToken cancellationToken, String[] path);
    public Response`1<TResult> SendRequest(RequestMethod method, TContent content, Func`1<TResult> resultFactory, CancellationToken cancellationToken, String[] path);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__21`1")]
public Task`1<Response`1<TResult>> SendRequestAsync(RequestMethod method, Func`1<TResult> resultFactory, CancellationToken cancellationToken, String[] path);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__22`1")]
public Task`1<Response`1<TResult>> SendRequestAsync(RequestMethod method, Func`1<TResult> resultFactory, Uri uri, CancellationToken cancellationToken);
    public Response`1<TResult> SendRequest(RequestMethod method, Func`1<TResult> resultFactory, CancellationToken cancellationToken, String[] path);
    public Response`1<TResult> SendRequest(RequestMethod method, Func`1<TResult> resultFactory, Uri uri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__25")]
public Task`1<Response> SendRequestAsync(RequestMethod method, CancellationToken cancellationToken, String[] path);
    public Response SendRequest(RequestMethod method, CancellationToken cancellationToken, String[] path);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<GetResponseAsync>d__27")]
public Task`1<Response> GetResponseAsync(RequestMethod method, CancellationToken cancellationToken, String[] path);
    public Response GetResponse(RequestMethod method, CancellationToken cancellationToken, String[] path);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__29")]
private Task`1<Response> SendRequestAsync(Request request, CancellationToken cancellationToken);
    private Response SendRequest(Request request, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Security.KeyVault.SerializationExtensions : object {
    [ExtensionAttribute]
public static void Deserialize(IJsonDeserializable obj, Stream content);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> Serialize(IJsonSerializable obj);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Azure.CertificateClientBuilderExtensions : object {
    [ExtensionAttribute]
public static IAzureClientBuilder`2<CertificateClient, CertificateClientOptions> AddCertificateClient(TBuilder builder, Uri vaultUri);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<CertificateClient, CertificateClientOptions> AddCertificateClient(TBuilder builder, TConfiguration configuration);
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
