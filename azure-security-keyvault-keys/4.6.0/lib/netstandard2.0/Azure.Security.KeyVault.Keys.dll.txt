internal static class Azure.Core.AppContextSwitchHelper : object {
    [NullableContextAttribute("1")]
public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName);
}
internal static class Azure.Core.Argument : object {
    public static void AssertNotNull(T value, string name);
    public static void AssertNotNull(Nullable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(IEnumerable`1<T> value, string name);
    public static void AssertNotNullOrEmpty(string value, string name);
    public static void AssertNotNullOrWhiteSpace(string value, string name);
    public static void AssertNotDefault(T& value, string name);
    public static void AssertInRange(T value, T minimum, T maximum, string name);
    public static void AssertEnumDefined(Type enumType, object value, string name);
    public static T CheckNotNull(T value, string name);
    public static string CheckNotNullOrEmpty(string value, string name);
    [NullableContextAttribute("1")]
public static void AssertNull(T value, string name, string message);
}
internal class Azure.Core.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private static int DefaultInitialBufferSize;
    [CompilerGeneratedAttribute]
private int <WrittenCount>k__BackingField;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; private set; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    [CompilerGeneratedAttribute]
public int get_WrittenCount();
    [CompilerGeneratedAttribute]
private void set_WrittenCount(int value);
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.AsyncLockWithValue`1 : object {
    private object _syncObj;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<TaskCompletionSource`1<LockOrValue<T>>> _waiters;
    private bool _isLocked;
    private bool _hasValue;
    private long _index;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public AsyncLockWithValue`1(T value);
    public bool get_HasValue();
    [NullableContextAttribute("2")]
public bool TryGetValue(T& value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.AsyncLockWithValue`1/<GetLockOrValueAsync>d__11")]
public ValueTask`1<LockOrValue<T>> GetLockOrValueAsync(bool async, CancellationToken cancellationToken);
    private void SetValue(T value, Int64& lockIndex);
    private void Reset(Int64& lockIndex);
    private void UnlockOrGetNextWaiter(Int64& lockIndex, TaskCompletionSource`1& nextWaiter);
}
internal static class Azure.Core.AuthorizationChallengeParser : object {
    [NullableContextAttribute("1")]
public static string GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter);
    internal static bool TryGetNextChallenge(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& challengeKey);
    internal static bool TryGetNextParameter(ReadOnlySpan`1& headerValue, ReadOnlySpan`1& paramKey, ReadOnlySpan`1& paramValue, char separator);
}
[AttributeUsageAttribute("1")]
internal class Azure.Core.AzureResourceProviderNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ResourceProviderNamespace>k__BackingField;
    public string ResourceProviderNamespace { get; }
    public AzureResourceProviderNamespaceAttribute(string resourceProviderNamespace);
    [CompilerGeneratedAttribute]
public string get_ResourceProviderNamespace();
}
internal static class Azure.Core.Base64Url : object {
    public static Byte[] Decode(string encoded);
    public static string Encode(Byte[] bytes);
    internal static string DecodeString(string encoded);
    internal static string EncodeString(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("68")]
internal class Azure.Core.CallerShouldAuditAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; public set; }
    public CallerShouldAuditAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Azure.Core.ChangeTrackingDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TKey, TValue> _innerDictionary;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public ChangeTrackingDictionary`2(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optionalDictionary);
    public ChangeTrackingDictionary`2(Optional`1<IDictionary`2<TKey, TValue>> optionalDictionary);
    private ChangeTrackingDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    private ChangeTrackingDictionary`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    public bool get_IsUndefined();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private IDictionary`2<TKey, TValue> EnsureDictionary();
    [IteratorStateMachineAttribute("Azure.Core.ChangeTrackingDictionary`2/<<GetEnumerator>g__GetEmptyEnumerator|8_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<KeyValuePair`2<TKey, TValue>> <GetEnumerator>g__GetEmptyEnumerator|8_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Azure.Core.ChangeTrackingList`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<T> _innerList;
    public bool IsUndefined { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ChangeTrackingList`1(Optional`1<IList`1<T>> optionalList);
    public ChangeTrackingList`1(Optional`1<IReadOnlyList`1<T>> optionalList);
    private ChangeTrackingList`1(IEnumerable`1<T> innerList);
    private ChangeTrackingList`1(IList`1<T> innerList);
    public bool get_IsUndefined();
    public void Reset();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private IList`1<T> EnsureList();
    [IteratorStateMachineAttribute("Azure.Core.ChangeTrackingList`1/<<GetEnumerator>g__EnumerateEmpty|9_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<T> <GetEnumerator>g__EnumerateEmpty|9_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.Diagnostics.AzureEventSource : EventSource {
    private static string SharedDataKey;
    private static HashSet`1<string> NamesInUse;
    private static String[] MainEventSourceTraits;
    private static AzureEventSource();
    protected AzureEventSource(string eventSourceName);
    private static string DeduplicateName(string eventSourceName);
}
internal class Azure.Core.FixedDelayWithNoJitterStrategy : DelayStrategy {
    private static TimeSpan DefaultDelay;
    private TimeSpan _delay;
    public FixedDelayWithNoJitterStrategy(Nullable`1<TimeSpan> suggestedDelay);
    private static FixedDelayWithNoJitterStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.FormUrlEncodedContent : RequestContent {
    private List`1<KeyValuePair`2<string, string>> _values;
    private Encoding Latin1;
    private Byte[] _bytes;
    public void Add(string parameter, string value);
    private void BuildIfNeeded();
    [AsyncStateMachineAttribute("Azure.Core.FormUrlEncodedContent/<WriteToAsync>d__5")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
    private Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static string Encode(string data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.HashCodeBuilder : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCodeBuilder();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    public static UInt32 RotateLeft(UInt32 value, int offset);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
internal class Azure.Core.HttpMessageSanitizer : object {
    private static string LogAllValue;
    private bool _logAllHeaders;
    private bool _logFullQueries;
    private String[] _allowedQueryParameters;
    private string _redactedPlaceholder;
    private HashSet`1<string> _allowedHeaders;
    internal static HttpMessageSanitizer Default;
    public HttpMessageSanitizer(String[] allowedQueryParameters, String[] allowedHeaders, string redactedPlaceholder);
    private static HttpMessageSanitizer();
    public string SanitizeHeader(string name, string value);
    public string SanitizeUrl(string url);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.HttpPipelineExtensions : object {
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessMessageAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<Response> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response ProcessMessage(HttpPipeline pipeline, HttpMessage message, RequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.HttpPipelineExtensions/<ProcessHeadAsBoolMessageAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<bool>> ProcessHeadAsBoolMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [ExtensionAttribute]
public static Response`1<bool> ProcessHeadAsBoolMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, RequestContext requestContext);
    [NullableContextAttribute("0")]
private static ValueTuple`2<CancellationToken, ErrorOptions> ApplyRequestContext(RequestContext requestContext);
}
internal interface Azure.Core.IOperation {
    public abstract virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Azure.Core.IOperation`1 {
    public abstract virtual ValueTask`1<OperationState`1<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
internal interface Azure.Core.IOperationSource`1 {
    public abstract virtual T CreateResult(Response response, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<T> CreateResultAsync(Response response, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IUtf8JsonSerializable {
    public abstract virtual void Write(Utf8JsonWriter writer);
}
[NullableContextAttribute("1")]
internal interface Azure.Core.IXmlSerializable {
    public abstract virtual void Write(XmlWriter writer, string nameHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.JsonElementExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static object GetObject(JsonElement& element);
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64(JsonElement& element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffset(JsonElement& element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpan(JsonElement& element, string format);
    [ExtensionAttribute]
public static char GetChar(JsonElement& element);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void ThrowNonNullablePropertyIsNull(JsonProperty property);
    [ExtensionAttribute]
public static string GetRequiredString(JsonElement& element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.NextLinkOperationImplementation : object {
    private static string ApiVersionParam;
    private static String[] FailureStates;
    private static String[] SuccessStates;
    private HeaderSource _headerSource;
    private Uri _startRequestUri;
    private OperationFinalStateVia _finalStateVia;
    private RequestMethod _requestMethod;
    private HttpPipeline _pipeline;
    [NullableAttribute("2")]
private string _apiVersion;
    [NullableAttribute("2")]
private string _lastKnownLocation;
    private string _nextRequestUri;
    private NextLinkOperationImplementation(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, string lastKnownLocation, OperationFinalStateVia finalStateVia, string apiVersion);
    private static NextLinkOperationImplementation();
    public static IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    public static IOperation`1<T> Create(IOperationSource`1<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride, string apiVersionOverrideValue);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<UpdateStateAsync>d__14")]
public sealed virtual ValueTask`1<OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
    private static OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response);
    private void UpdateNextRequestUri(ResponseHeaders headers);
    internal static string AppendOrReplaceApiVersion(string uri, string apiVersion);
    [NullableContextAttribute("0")]
internal static bool TryGetApiVersion(Uri startRequestUri, ReadOnlySpan`1& apiVersion);
    [NullableContextAttribute("2")]
private string GetFinalUri(string resourceLocation);
    [AsyncStateMachineAttribute("Azure.Core.NextLinkOperationImplementation/<GetResponseAsync>d__20")]
private ValueTask`1<Response> GetResponseAsync(bool async, string uri, CancellationToken cancellationToken);
    private HttpMessage CreateRequest(string uri);
    private static bool IsFinalState(Response response, HeaderSource headerSource, Nullable`1& failureState, String& resourceLocation);
    private static bool ShouldIgnoreHeader(RequestMethod method, Response response);
    private static HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string apiVersion, String& nextRequestUri);
}
internal enum Azure.Core.OperationFinalStateVia : Enum {
    public int value__;
    public static OperationFinalStateVia AzureAsyncOperation;
    public static OperationFinalStateVia Location;
    public static OperationFinalStateVia OriginalUri;
    public static OperationFinalStateVia OperationLocation;
    public static OperationFinalStateVia LocationOverride;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.OperationHelpers : object {
    public static T GetValue(T& value);
    [NullableContextAttribute("0")]
public static T GetValue(Nullable`1& value);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__2`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionAsync>d__3`1")]
[ExtensionAttribute]
public static ValueTask`1<Response`1<TResult>> DefaultWaitForCompletionAsync(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response`1<TResult> DefaultWaitForCompletion(Operation`1<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__6")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationHelpers/<DefaultWaitForCompletionResponseAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<Response> DefaultWaitForCompletionResponseAsync(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Response DefaultWaitForCompletionResponse(Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal : OperationInternalBase {
    private OperationInternal`1<VoidValue> _internalOperation;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public OperationInternal(IOperation operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    private OperationInternal(OperationState finalState);
    public static OperationInternal Succeeded(Response rawResponse);
    public static OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal/<UpdateStatusAsync>d__9")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationInternal`1 : OperationInternalBase {
    private IOperation`1<T> _operation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLockWithValue`1<OperationState`1<T>> _stateLock;
    private Response _rawResponse;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    public T Value { get; }
    public OperationInternal`1(IOperation`1<T> operation, ClientDiagnostics clientDiagnostics, Response rawResponse, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    private OperationInternal`1(OperationState`1<T> finalState);
    public static OperationInternal`1<T> Succeeded(Response rawResponse, T value);
    public static OperationInternal`1<T> Failed(Response rawResponse, RequestFailedException operationFailedException);
    public virtual Response get_RawResponse();
    public virtual bool get_HasCompleted();
    public bool get_HasValue();
    public T get_Value();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__15")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__16")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<WaitForCompletionAsync>d__19")]
private ValueTask`1<Response`1<T>> WaitForCompletionAsync(bool async, Nullable`1<TimeSpan> pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternal`1/<UpdateStatusAsync>d__20")]
protected virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    private static Response GetResponseFromState(OperationState`1<T> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Azure.Core.OperationInternalBase : object {
    private ClientDiagnostics _diagnostics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> _scopeAttributes;
    [NullableAttribute("2")]
private DelayStrategy _fallbackStrategy;
    private AsyncLockWithValue`1<Response> _responseLock;
    private string _waitForCompletionResponseScopeName;
    protected string _updateStatusScopeName;
    protected string _waitForCompletionScopeName;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    protected OperationInternalBase(Response rawResponse);
    protected OperationInternalBase(ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable`1<KeyValuePair`2<string, string>> scopeAttributes, DelayStrategy fallbackStrategy);
    public abstract virtual Response get_RawResponse();
    public abstract virtual bool get_HasCompleted();
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<UpdateStatusAsync>d__13")]
public ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__15")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__16")]
public ValueTask`1<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationInternalBase/<WaitForCompletionResponseAsync>d__19")]
protected ValueTask`1<Response> WaitForCompletionResponseAsync(bool async, Nullable`1<TimeSpan> pollingInterval, string scopeName, CancellationToken cancellationToken);
    protected abstract virtual ValueTask`1<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);
    protected DiagnosticScope CreateScope(string scopeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.OperationPoller : object {
    private DelayStrategy _delayStrategy;
    [NullableContextAttribute("2")]
public OperationPoller(DelayStrategy strategy);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public ValueTask`1<Response> WaitForCompletionResponseAsync(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response WaitForCompletionResponse(OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__6`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(Operation`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__8`1")]
public ValueTask`1<Response`1<T>> WaitForCompletionAsync(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    public Response`1<T> WaitForCompletion(OperationInternal`1<T> operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__10")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, Operation operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<WaitForCompletionAsync>d__11")]
private ValueTask`1<Response> WaitForCompletionAsync(bool async, OperationInternalBase operation, Nullable`1<TimeSpan> delayHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.OperationPoller/<Delay>d__12")]
private static ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState : ValueType {
    [CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    [NullableAttribute("2")]
public RequestFailedException OperationFailedException { get; }
    private OperationState(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException operationFailedException);
    [CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    public static OperationState Success(Response rawResponse);
    public static OperationState Failure(Response rawResponse, RequestFailedException operationFailedException);
    public static OperationState Pending(Response rawResponse);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.OperationState`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Response <RawResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestFailedException <OperationFailedException>k__BackingField;
    [NullableAttribute("1")]
public Response RawResponse { get; }
    public bool HasCompleted { get; }
    public bool HasSucceeded { get; }
    public T Value { get; }
    public RequestFailedException OperationFailedException { get; }
    private OperationState`1(Response rawResponse, bool hasCompleted, bool hasSucceeded, T value, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Response get_RawResponse();
    [CompilerGeneratedAttribute]
public bool get_HasCompleted();
    [CompilerGeneratedAttribute]
public bool get_HasSucceeded();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public RequestFailedException get_OperationFailedException();
    [NullableContextAttribute("1")]
public static OperationState`1<T> Success(Response rawResponse, T value);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Failure(Response rawResponse, RequestFailedException operationFailedException);
    [NullableContextAttribute("1")]
public static OperationState`1<T> Pending(Response rawResponse);
}
internal static class Azure.Core.Optional : object {
    public static bool IsCollectionDefined(IEnumerable`1<T> collection);
    public static bool IsCollectionDefined(IReadOnlyDictionary`2<TKey, TValue> collection);
    public static bool IsCollectionDefined(IDictionary`2<TKey, TValue> collection);
    public static bool IsDefined(Nullable`1<T> value);
    public static bool IsDefined(object value);
    public static bool IsDefined(string value);
    public static bool IsDefined(JsonElement value);
    public static IReadOnlyDictionary`2<TKey, TValue> ToDictionary(Optional`1<IReadOnlyDictionary`2<TKey, TValue>> optional);
    public static IDictionary`2<TKey, TValue> ToDictionary(Optional`1<IDictionary`2<TKey, TValue>> optional);
    public static IReadOnlyList`1<T> ToList(Optional`1<IReadOnlyList`1<T>> optional);
    public static IList`1<T> ToList(Optional`1<IList`1<T>> optional);
    public static Nullable`1<T> ToNullable(Optional`1<T> optional);
    public static Nullable`1<T> ToNullable(Optional`1<Nullable`1<T>> optional);
}
[IsReadOnlyAttribute]
internal class Azure.Core.Optional`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    public T Value { get; }
    public bool HasValue { get; }
    public Optional`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public static Optional`1<T> op_Implicit(T value);
    public static T op_Implicit(Optional`1<T> optional);
}
internal static class Azure.Core.Page : object {
    [NullableContextAttribute("1")]
public static Page`1<T> FromValues(IEnumerable`1<T> values, string continuationToken, Response response);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.PageableHelpers : object {
    private static Byte[] DefaultItemPropertyName;
    private static Byte[] DefaultNextLinkPropertyName;
    private static PageableHelpers();
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static AsyncPageable`1<T> CreateAsyncPageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static AsyncPageable`1<T> CreateAsyncPageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<Response, ValueTuple`2<List`1<T>, string>> responseParser, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    public static Pageable`1<T> CreatePageable(Func`2<Nullable`1<int>, HttpMessage> createFirstPageRequest, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreatePageable(Response initialResponse, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageRequest, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string itemPropertyName, string nextLinkPropertyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.PageableHelpers/<CreateAsyncPageable>d__10`1")]
public static ValueTask`1<Operation`1<AsyncPageable`1<T>>> CreateAsyncPageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Operation`1<Pageable`1<T>> CreatePageable(WaitUntil waitUntil, HttpMessage message, Func`3<Nullable`1<int>, string, HttpMessage> createNextPageMethod, Func`2<JsonElement, T> valueFactory, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, OperationFinalStateVia finalStateVia, string scopeName, string itemPropertyName, string nextLinkPropertyName, RequestContext requestContext);
    public static Pageable`1<T> CreateEnumerable(Func`2<Nullable`1<int>, Page`1<T>> firstPageFunc, Func`3<string, Nullable`1<int>, Page`1<T>> nextPageFunc, Nullable`1<int> pageSize);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<Nullable`1<int>, Task`1<Page`1<T>>> firstPageFunc, Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> nextPageFunc, Nullable`1<int> pageSize);
    private static ValueTuple`2<List`1<T>, string> ParseResponseForBinaryData(Response response, Byte[] itemPropertyName, Byte[] nextLinkPropertyName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static object <ParseResponseForBinaryData>g__ReadBinaryData|19_0(Utf8JsonReader& r, ReadOnlyMemory`1& content);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.PageResponseEnumerator : object {
    public static FuncPageable`1<T> CreateEnumerable(Func`2<string, Page`1<T>> pageFunc);
    public static FuncPageable`1<T> CreateEnumerable(Func`3<string, Nullable`1<int>, Page`1<T>> pageFunc);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`2<string, Task`1<Page`1<T>>> pageFunc);
    public static AsyncPageable`1<T> CreateAsyncEnumerable(Func`3<string, Nullable`1<int>, Task`1<Page`1<T>>> pageFunc);
}
internal static class Azure.Core.Pipeline.ActivityExtensions : object {
    [CompilerGeneratedAttribute]
private static bool <SupportsActivitySource>k__BackingField;
    public static bool SupportsActivitySource { get; private set; }
    private static ActivityExtensions();
    [CompilerGeneratedAttribute]
public static bool get_SupportsActivitySource();
    [CompilerGeneratedAttribute]
private static void set_SupportsActivitySource(bool value);
    public static void ResetFeatureSwitch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.ClientDiagnostics : DiagnosticScopeFactory {
    public ClientDiagnostics(ClientOptions options, Nullable`1<bool> suppressNestedClientActivities);
    public ClientDiagnostics(string optionsNamespace, string providerNamespace, DiagnosticsOptions diagnosticsOptions, Nullable`1<bool> suppressNestedClientActivities);
    internal static HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics);
    internal static string GetResourceProviderNamespace(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Azure.Core.Pipeline.DiagnosticScope : ValueType {
    private static string AzureSdkScopeLabel;
    internal static string OpenTelemetrySchemaAttribute;
    internal static string OpenTelemetrySchemaVersion;
    private static object AzureSdkScopeValue;
    [NullableAttribute("2")]
private ActivityAdapter _activityAdapter;
    private bool _suppressNestedClientActivities;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    [RequiresUnreferencedCodeAttribute("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
internal DiagnosticScope(string scopeName, DiagnosticListener source, object diagnosticSourceArgs, ActivitySource activitySource, ActivityKind kind, bool suppressNestedClientActivities);
    private static DiagnosticScope();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public void AddAttribute(string name, string value);
    public void AddIntegerAttribute(string name, int value);
    public void AddAttribute(string name, T value, Func`2<T, string> format);
    public void AddLink(string traceparent, string tracestate, IDictionary`2<string, string> attributes);
    public void Start();
    public void SetDisplayName(string displayName);
    public void SetStartTime(DateTime dateTime);
    public void SetTraceContext(string traceparent, string tracestate);
    public sealed virtual void Dispose();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(Exception exception);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026")]
public void Failed(string errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Pipeline.DiagnosticScopeFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, DiagnosticListener> _listeners;
    [NullableAttribute("2")]
private string _resourceProviderNamespace;
    [NullableAttribute("2")]
private DiagnosticListener _source;
    private bool _suppressNestedClientActivities;
    private bool _isStable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ActivitySource> ActivitySources;
    [CompilerGeneratedAttribute]
private bool <IsActivityEnabled>k__BackingField;
    public bool IsActivityEnabled { get; }
    public DiagnosticScopeFactory(string clientNamespace, string resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities, bool isStable);
    private static DiagnosticScopeFactory();
    [CompilerGeneratedAttribute]
public bool get_IsActivityEnabled();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public DiagnosticScope CreateScope(string name, ActivityKind kind);
    private ActivitySource GetActivitySource(string ns, string name);
}
[ExtensionAttribute]
internal static class Azure.Core.Pipeline.TaskExtensions : object {
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable AwaitWithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationTaskAwaitable`1<T> AwaitWithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static WithCancellationValueTaskAwaitable`1<T> AwaitWithCancellation(ValueTask`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T EnsureCompleted(Task`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(Task task);
    [ExtensionAttribute]
public static T EnsureCompleted(ValueTask`1<T> task);
    [ExtensionAttribute]
public static void EnsureCompleted(ValueTask task);
    [ExtensionAttribute]
public static Enumerable`1<T> EnsureSyncEnumerable(IAsyncEnumerable`1<T> asyncEnumerable);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> EnsureCompleted(ConfiguredValueTaskAwaitable`1<T> awaitable, bool async);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable EnsureCompleted(ConfiguredValueTaskAwaitable awaitable, bool async);
    [ConditionalAttribute("DEBUG")]
private static void VerifyTaskCompleted(bool isCompleted);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ProtocolOperation`1 : Operation`1<T> {
    private Func`2<Response, T> _resultSelector;
    private OperationInternal`1<T> _operation;
    private IOperation _nextLinkOperation;
    public string Id { get; }
    public T Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal ProtocolOperation`1(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, string scopeName, Func`2<Response, T> resultSelector);
    public virtual string get_Id();
    public virtual T get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperation`1/<Azure-Core-IOperation<T>-UpdateStateAsync>d__17")]
private sealed virtual override ValueTask`1<OperationState`1<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ProtocolOperationHelpers : object {
    public static Operation`1<TTo> Convert(Operation`1<TFrom> operation, Func`2<Response, TTo> convertFunc, ClientDiagnostics diagnostics, string scopeName);
    public static ValueTask`1<Operation`1<VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static ValueTask`1<Operation`1<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    public static Operation`1<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil);
    [AsyncStateMachineAttribute("Azure.Core.ProtocolOperationHelpers/<ProcessMessageAsync>d__5`1")]
public static ValueTask`1<Operation`1<T>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
    public static Operation`1<T> ProcessMessage(HttpPipeline pipeline, HttpMessage message, ClientDiagnostics clientDiagnostics, string scopeName, OperationFinalStateVia finalStateVia, RequestContext requestContext, WaitUntil waitUntil, Func`2<Response, T> resultSelector);
}
internal class Azure.Core.RawRequestUriBuilder : RequestUriBuilder {
    [NullableAttribute("1")]
private static string SchemeSeparator;
    private static char HostSeparator;
    private static char PortSeparator;
    [NullableAttribute("1")]
private static Char[] HostOrPort;
    private static char QueryBeginSeparator;
    private static char QueryContinueSeparator;
    private static char QueryValueSeparator;
    private Nullable`1<RawWritingPosition> _position;
    private static RawRequestUriBuilder();
    private static void GetQueryParts(ReadOnlySpan`1<char> queryUnparsed, ReadOnlySpan`1& name, ReadOnlySpan`1& value);
    [NullableContextAttribute("1")]
public void AppendRaw(string value, bool escape);
    private void AppendRaw(ReadOnlySpan`1<char> value, bool escape);
    [NullableContextAttribute("1")]
public void AppendRawNextLink(string nextLink, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.RequestContentHelper : object {
    public static RequestContent FromEnumerable(IEnumerable`1<T> enumerable);
    public static RequestContent FromEnumerable(IEnumerable`1<BinaryData> enumerable);
    public static RequestContent FromDictionary(IDictionary`2<string, T> dictionary);
    public static RequestContent FromDictionary(IDictionary`2<string, BinaryData> dictionary);
    public static RequestContent FromObject(object value);
    public static RequestContent FromObject(BinaryData value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestHeaderExtensions : object {
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, bool value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, float value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, double value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, int value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, long value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, TimeSpan value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Guid value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, Byte[] value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, BinaryData value, string format);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string prefix, IDictionary`2<string, string> headersToAdd);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, string name, ETag value);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, MatchConditions conditions);
    [ExtensionAttribute]
public static void Add(RequestHeaders headers, RequestConditions conditions, string format);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter);
    [ExtensionAttribute]
public static void AddDelimited(RequestHeaders headers, string name, IEnumerable`1<T> value, string delimiter, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.RequestUriBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, float value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, double value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, int value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, IEnumerable`1<string> value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendPath(RequestUriBuilder builder, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, bool value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, float value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, double value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, decimal value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, int value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, long value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, TimeSpan value, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Byte[] value, string format, bool escape);
    [ExtensionAttribute]
public static void AppendQuery(RequestUriBuilder builder, string name, Guid value, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, bool escape);
    [ExtensionAttribute]
public static void AppendQueryDelimited(RequestUriBuilder builder, string name, IEnumerable`1<T> value, string delimiter, string format, bool escape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.ResponseHeadersExtensions : object {
    private static String[] KnownFormats;
    private static ResponseHeadersExtensions();
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Byte[]& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, Nullable`1& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string name, T& value);
    [ExtensionAttribute]
public static bool TryGetValue(ResponseHeaders headers, string prefix, IDictionary`2& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Azure.Core.ResponseWithHeaders : object {
    public static ResponseWithHeaders`2<T, THeaders> FromValue(T value, THeaders headers, Response rawResponse);
    public static ResponseWithHeaders`1<THeaders> FromValue(THeaders headers, Response rawResponse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.ResponseWithHeaders`1 : object {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public THeaders Headers { get; }
    public ResponseWithHeaders`1(THeaders headers, Response rawResponse);
    public Response GetRawResponse();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`1<THeaders> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Azure.Core.ResponseWithHeaders`2 : Response`1<T> {
    private Response _rawResponse;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private THeaders <Headers>k__BackingField;
    public T Value { get; }
    public THeaders Headers { get; }
    public ResponseWithHeaders`2(T value, THeaders headers, Response rawResponse);
    public virtual Response GetRawResponse();
    [CompilerGeneratedAttribute]
public virtual T get_Value();
    [CompilerGeneratedAttribute]
public THeaders get_Headers();
    public static Response op_Implicit(ResponseWithHeaders`2<T, THeaders> self);
}
internal class Azure.Core.SequentialDelayStrategy : DelayStrategy {
    [NullableAttribute("1")]
private static TimeSpan[] _pollingSequence;
    private static TimeSpan _maxDelay;
    private static SequentialDelayStrategy();
    [NullableContextAttribute("2")]
protected virtual TimeSpan GetNextDelayCore(Response response, int retryNumber);
}
internal class Azure.Core.StringRequestContent : RequestContent {
    private Byte[] _bytes;
    public StringRequestContent(string value);
    [AsyncStateMachineAttribute("Azure.Core.StringRequestContent/<WriteToAsync>d__2")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.TypeFormatters : object {
    private static string RoundtripZFormat;
    [CompilerGeneratedAttribute]
private static string <DefaultNumberFormat>k__BackingField;
    public static string DefaultNumberFormat { get; }
    private static TypeFormatters();
    [CompilerGeneratedAttribute]
public static string get_DefaultNumberFormat();
    public static string ToString(bool value);
    public static string ToString(DateTime value, string format);
    public static string ToString(DateTimeOffset value, string format);
    public static string ToString(TimeSpan value, string format);
    public static string ToString(Byte[] value, string format);
    public static string ToBase64UrlString(Byte[] value);
    public static Byte[] FromBase64UrlString(string value);
    private static int GetNumBase64PaddingCharsToAddForDecode(int inputLength);
    public static DateTimeOffset ParseDateTimeOffset(string value, string format);
    public static TimeSpan ParseTimeSpan(string value, string format);
    [NullableContextAttribute("2")]
public static string ConvertToString(object value, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.Utf8JsonRequestContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private Utf8JsonWriter <JsonWriter>k__BackingField;
    public Utf8JsonWriter JsonWriter { get; }
    [CompilerGeneratedAttribute]
public Utf8JsonWriter get_JsonWriter();
    [AsyncStateMachineAttribute("Azure.Core.Utf8JsonRequestContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.Utf8JsonWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, DateTime value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteStringValue(Utf8JsonWriter writer, char value);
    [ExtensionAttribute]
public static void WriteNonEmptyArray(Utf8JsonWriter writer, string name, IReadOnlyList`1<string> values);
    [ExtensionAttribute]
public static void WriteBase64StringValue(Utf8JsonWriter writer, Byte[] value, string format);
    [ExtensionAttribute]
public static void WriteNumberValue(Utf8JsonWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteObjectValue(Utf8JsonWriter writer, object value);
}
[IsReadOnlyAttribute]
internal class Azure.Core.VoidValue : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XElementExtensions : object {
    [ExtensionAttribute]
public static Byte[] GetBytesFromBase64Value(XElement element, string format);
    [ExtensionAttribute]
public static DateTimeOffset GetDateTimeOffsetValue(XElement element, string format);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpanValue(XElement element, string format);
    [ExtensionAttribute]
public static object GetObjectValue(XElement element, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Azure.Core.XmlWriterContent : RequestContent {
    private MemoryStream _stream;
    private RequestContent _content;
    [CompilerGeneratedAttribute]
private XmlWriter <XmlWriter>k__BackingField;
    public XmlWriter XmlWriter { get; }
    [CompilerGeneratedAttribute]
public XmlWriter get_XmlWriter();
    [AsyncStateMachineAttribute("Azure.Core.XmlWriterContent/<WriteToAsync>d__6")]
public virtual Task WriteToAsync(Stream stream, CancellationToken cancellation);
    public virtual void WriteTo(Stream stream, CancellationToken cancellation);
    public virtual bool TryComputeLength(Int64& length);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Azure.Core.XmlWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteObjectValue(XmlWriter writer, object value, string nameHint);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, DateTimeOffset value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, TimeSpan value, string format);
    [ExtensionAttribute]
public static void WriteValue(XmlWriter writer, Byte[] value, string format);
}
internal class Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy : BearerTokenAuthenticationPolicy {
    private static string KeyVaultStashedContentKey;
    private bool _verifyChallengeResource;
    private static ConcurrentDictionary`2<string, ChallengeParameters> s_challengeCache;
    private ChallengeParameters _challenge;
    public ChallengeBasedAuthenticationPolicy(TokenCredential credential, bool disableChallengeResourceVerification);
    private static ChallengeBasedAuthenticationPolicy();
    protected virtual ValueTask AuthorizeRequestAsync(HttpMessage message);
    protected virtual void AuthorizeRequest(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy/<AuthorizeRequestInternal>d__7")]
private ValueTask AuthorizeRequestInternal(HttpMessage message, bool async);
    protected virtual ValueTask`1<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message);
    protected virtual bool AuthorizeRequestOnChallenge(HttpMessage message);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.ChallengeBasedAuthenticationPolicy/<AuthorizeRequestOnChallengeAsyncInternal>d__10")]
private ValueTask`1<bool> AuthorizeRequestOnChallengeAsyncInternal(HttpMessage message, bool async);
    internal static void ClearCache();
    private static string GetRequestAuthority(Request request);
}
[ExtensionAttribute]
internal static class Azure.Security.KeyVault.ClientOptionsExtensions : object {
    [ExtensionAttribute]
public static void ConfigureLogging(ClientOptions clientOptions);
}
[ExtensionAttribute]
internal static class Azure.Security.KeyVault.Extensions : object {
    [ExtensionAttribute]
public static T[] Clone(T[] source);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(ICollection`1<T> source);
}
internal interface Azure.Security.KeyVault.IJsonDeserializable {
    public abstract virtual void ReadProperties(JsonElement json);
}
internal interface Azure.Security.KeyVault.IJsonSerializable {
    public abstract virtual void WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.CreateEcKeyOptions : CreateKeyOptions {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyCurveName> <CurveName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HardwareProtected>k__BackingField;
    public string Name { get; }
    public KeyType KeyType { get; }
    public Nullable`1<KeyCurveName> CurveName { get; public set; }
    public bool HardwareProtected { get; }
    public CreateEcKeyOptions(string name, bool hardwareProtected);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public KeyType get_KeyType();
    [CompilerGeneratedAttribute]
public Nullable`1<KeyCurveName> get_CurveName();
    [CompilerGeneratedAttribute]
public void set_CurveName(Nullable`1<KeyCurveName> value);
    [CompilerGeneratedAttribute]
public bool get_HardwareProtected();
}
public class Azure.Security.KeyVault.Keys.CreateKeyOptions : object {
    [CompilerGeneratedAttribute]
private IList`1<KeyOperation> <KeyOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Exportable>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyReleasePolicy <ReleasePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    public IList`1<KeyOperation> KeyOperations { get; }
    public Nullable`1<DateTimeOffset> NotBefore { get; public set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; public set; }
    public Nullable`1<bool> Enabled { get; public set; }
    public Nullable`1<bool> Exportable { get; public set; }
    public KeyReleasePolicy ReleasePolicy { get; public set; }
    public IDictionary`2<string, string> Tags { get; }
    [CompilerGeneratedAttribute]
public IList`1<KeyOperation> get_KeyOperations();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Exportable();
    [CompilerGeneratedAttribute]
public void set_Exportable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public KeyReleasePolicy get_ReleasePolicy();
    [CompilerGeneratedAttribute]
public void set_ReleasePolicy(KeyReleasePolicy value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
}
public class Azure.Security.KeyVault.Keys.CreateOctKeyOptions : CreateKeyOptions {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <KeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HardwareProtected>k__BackingField;
    public string Name { get; }
    public KeyType KeyType { get; }
    public Nullable`1<int> KeySize { get; public set; }
    public bool HardwareProtected { get; }
    public CreateOctKeyOptions(string name, bool hardwareProtected);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public KeyType get_KeyType();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_KeySize();
    [CompilerGeneratedAttribute]
public void set_KeySize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_HardwareProtected();
}
public class Azure.Security.KeyVault.Keys.CreateRsaKeyOptions : CreateKeyOptions {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <KeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PublicExponent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HardwareProtected>k__BackingField;
    public string Name { get; }
    public KeyType KeyType { get; }
    public Nullable`1<int> KeySize { get; public set; }
    public Nullable`1<int> PublicExponent { get; public set; }
    public bool HardwareProtected { get; }
    public CreateRsaKeyOptions(string name, bool hardwareProtected);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public KeyType get_KeyType();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_KeySize();
    [CompilerGeneratedAttribute]
public void set_KeySize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PublicExponent();
    [CompilerGeneratedAttribute]
public void set_PublicExponent(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_HardwareProtected();
}
internal class Azure.Security.KeyVault.Keys.Cryptography.AesCbc : object {
    public static int BlockByteSize;
    public static AesCbc Aes128Cbc;
    public static AesCbc Aes192Cbc;
    public static AesCbc Aes256Cbc;
    public static AesCbc Aes128CbcPad;
    public static AesCbc Aes192CbcPad;
    public static AesCbc Aes256CbcPad;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeySizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private PaddingMode <Padding>k__BackingField;
    public string Name { get; }
    public int KeySizeInBytes { get; }
    public PaddingMode Padding { get; }
    private AesCbc(string name, int keySize, PaddingMode padding);
    private static AesCbc();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_KeySizeInBytes();
    [CompilerGeneratedAttribute]
public PaddingMode get_Padding();
    private static Aes Create(Byte[] key, Byte[] iv, PaddingMode padding);
    public ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    public ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
}
internal class Azure.Security.KeyVault.Keys.Cryptography.AesCryptographyProvider : LocalCryptographyProvider {
    internal AesCryptographyProvider(JsonWebKey keyMaterial, KeyProperties keyProperties, bool localOnly);
    public virtual bool SupportsOperation(KeyOperation operation);
    public virtual DecryptResult Decrypt(DecryptParameters parameters, CancellationToken cancellationToken);
    public virtual EncryptResult Encrypt(EncryptParameters parameters, CancellationToken cancellationToken);
    public virtual UnwrapResult UnwrapKey(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    public virtual WrapResult WrapKey(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    private int GetKeySizeInBytes();
}
internal class Azure.Security.KeyVault.Keys.Cryptography.AesKw : object {
    private static int BlockSizeInBits;
    private static int BlockSizeInBytes;
    public static AesKw Aes128Kw;
    public static AesKw Aes192Kw;
    public static AesKw Aes256Kw;
    private static Byte[] s_defaultIv;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeySizeInBytes>k__BackingField;
    public string Name { get; }
    public int KeySizeInBytes { get; }
    private static Byte[] DefaultIv { get; }
    private AesKw(string name, int keySize);
    private static AesKw();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_KeySizeInBytes();
    private static Aes Create(Byte[] key);
    public ICryptoTransform CreateEncryptor(Byte[] key);
    public ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv);
    public ICryptoTransform CreateDecryptor(Byte[] key);
    public ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
    private static Byte[] get_DefaultIv();
    private static Byte[] GetBytes(ulong i);
}
[ExtensionAttribute]
internal static class Azure.Security.KeyVault.Keys.Cryptography.ByteExtensions : object {
    [ExtensionAttribute]
internal static bool SequenceEqualConstantTime(Byte[] self, Byte[] other);
    [ExtensionAttribute]
internal static Byte[] Or(Byte[] self, Byte[] other);
    [ExtensionAttribute]
internal static Byte[] Or(Byte[] self, Byte[] other, int offset);
    [ExtensionAttribute]
internal static Byte[] Xor(Byte[] self, Byte[] other, bool inPlace);
    [ExtensionAttribute]
internal static Byte[] Xor(Byte[] self, Byte[] other, int offset, bool inPlace);
    [ExtensionAttribute]
internal static Byte[] Take(Byte[] self, int count);
    [ExtensionAttribute]
internal static Byte[] Take(Byte[] self, int offset, int count);
    [ExtensionAttribute]
internal static void Zero(Byte[] self);
}
internal static class Azure.Security.KeyVault.Keys.Cryptography.Crypto : object {
    private static RandomNumberGenerator s_rng;
    private static Crypto();
    public static Byte[] GenerateIv(int byteSize);
}
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public class Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient : object {
    private static string CallerShouldAuditReason;
    private static string GetOperation;
    private static string OTelKeyIdKey;
    private string _keyId;
    private KeyVaultPipeline _pipeline;
    private RemoteCryptographyClient _remoteProvider;
    private ICryptographyProvider _provider;
    internal ICryptographyProvider RemoteClient { get; }
    public string KeyId { get; }
    private bool LocalOnly { get; }
    private JsonWebKey KeyMaterial { get; }
    public CryptographyClient(Uri keyId, TokenCredential credential);
    public CryptographyClient(Uri keyId, TokenCredential credential, CryptographyClientOptions options);
    public CryptographyClient(JsonWebKey key);
    public CryptographyClient(JsonWebKey key, LocalCryptographyClientOptions options);
    internal CryptographyClient(Uri keyId, TokenCredential credential, CryptographyClientOptions options, bool forceRemote);
    internal CryptographyClient(KeyVaultKey key, TokenCredential credential, CryptographyClientOptions options, ICryptographyProvider provider);
    internal CryptographyClient(KeyVaultKey key, KeyVaultPipeline pipeline);
    internal CryptographyClient(Uri keyId, KeyVaultPipeline pipeline, bool forceRemote);
    internal ICryptographyProvider get_RemoteClient();
    public virtual string get_KeyId();
    private bool get_LocalOnly();
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<EncryptAsync>d__22")]
public virtual Task`1<EncryptResult> EncryptAsync(EncryptionAlgorithm algorithm, Byte[] plaintext, CancellationToken cancellationToken);
    public virtual EncryptResult Encrypt(EncryptionAlgorithm algorithm, Byte[] plaintext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<EncryptAsync>d__24")]
public virtual Task`1<EncryptResult> EncryptAsync(EncryptParameters encryptParameters, CancellationToken cancellationToken);
    public virtual EncryptResult Encrypt(EncryptParameters encryptParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<DecryptAsync>d__26")]
public virtual Task`1<DecryptResult> DecryptAsync(EncryptionAlgorithm algorithm, Byte[] ciphertext, CancellationToken cancellationToken);
    public virtual DecryptResult Decrypt(EncryptionAlgorithm algorithm, Byte[] ciphertext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<DecryptAsync>d__28")]
public virtual Task`1<DecryptResult> DecryptAsync(DecryptParameters decryptParameters, CancellationToken cancellationToken);
    public virtual DecryptResult Decrypt(DecryptParameters decryptParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<WrapKeyAsync>d__30")]
public virtual Task`1<WrapResult> WrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    public virtual WrapResult WrapKey(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<UnwrapKeyAsync>d__32")]
public virtual Task`1<UnwrapResult> UnwrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    public virtual UnwrapResult UnwrapKey(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<SignAsync>d__34")]
public virtual Task`1<SignResult> SignAsync(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    public virtual SignResult Sign(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<VerifyAsync>d__36")]
public virtual Task`1<VerifyResult> VerifyAsync(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    public virtual VerifyResult Verify(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<SignDataAsync>d__38")]
public virtual Task`1<SignResult> SignDataAsync(SignatureAlgorithm algorithm, Byte[] data, CancellationToken cancellationToken);
    public virtual SignResult SignData(SignatureAlgorithm algorithm, Byte[] data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<SignDataAsync>d__40")]
public virtual Task`1<SignResult> SignDataAsync(SignatureAlgorithm algorithm, Stream data, CancellationToken cancellationToken);
    public virtual SignResult SignData(SignatureAlgorithm algorithm, Stream data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<VerifyDataAsync>d__42")]
public virtual Task`1<VerifyResult> VerifyDataAsync(SignatureAlgorithm algorithm, Byte[] data, Byte[] signature, CancellationToken cancellationToken);
    public virtual VerifyResult VerifyData(SignatureAlgorithm algorithm, Byte[] data, Byte[] signature, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<VerifyDataAsync>d__44")]
public virtual Task`1<VerifyResult> VerifyDataAsync(SignatureAlgorithm algorithm, Stream data, Byte[] signature, CancellationToken cancellationToken);
    public virtual VerifyResult VerifyData(SignatureAlgorithm algorithm, Stream data, Byte[] signature, CancellationToken cancellationToken);
    public virtual RSAKeyVault CreateRSA(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<CreateRSAAsync>d__47")]
public virtual Task`1<RSAKeyVault> CreateRSAAsync(CancellationToken cancellationToken);
    private JsonWebKey get_KeyMaterial();
    private void ThrowIfLocalOnly(string name);
    private sealed virtual override Byte[] Azure.Core.Cryptography.IKeyEncryptionKey.WrapKey(string algorithm, ReadOnlyMemory`1<byte> key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<Azure-Core-Cryptography-IKeyEncryptionKey-WrapKeyAsync>d__52")]
private sealed virtual override Task`1<Byte[]> Azure.Core.Cryptography.IKeyEncryptionKey.WrapKeyAsync(string algorithm, ReadOnlyMemory`1<byte> key, CancellationToken cancellationToken);
    private sealed virtual override Byte[] Azure.Core.Cryptography.IKeyEncryptionKey.UnwrapKey(string algorithm, ReadOnlyMemory`1<byte> encryptedKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<Azure-Core-Cryptography-IKeyEncryptionKey-UnwrapKeyAsync>d__54")]
private sealed virtual override Task`1<Byte[]> Azure.Core.Cryptography.IKeyEncryptionKey.UnwrapKeyAsync(string algorithm, ReadOnlyMemory`1<byte> encryptedKey, CancellationToken cancellationToken);
    internal Byte[] CreateDigest(SignatureAlgorithm algorithm, Byte[] data, string name);
    internal Byte[] CreateDigest(SignatureAlgorithm algorithm, Stream data, string name);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.CryptographyClient/<InitializeAsync>d__57")]
private Task InitializeAsync(string operation, CancellationToken cancellationToken);
    private void Initialize(string operation, CancellationToken cancellationToken);
}
public class Azure.Security.KeyVault.Keys.Cryptography.CryptographyClientOptions : ClientOptions {
    internal static ServiceVersion LatestVersion;
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableChallengeResourceVerification>k__BackingField;
    public ServiceVersion Version { get; }
    public bool DisableChallengeResourceVerification { get; public set; }
    public CryptographyClientOptions(ServiceVersion version);
    [CompilerGeneratedAttribute]
public ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
public bool get_DisableChallengeResourceVerification();
    [CompilerGeneratedAttribute]
public void set_DisableChallengeResourceVerification(bool value);
    internal string GetVersionString();
}
public class Azure.Security.KeyVault.Keys.Cryptography.DecryptParameters : object {
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Ciphertext>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Iv>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AuthenticationTag>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AdditionalAuthenticatedData>k__BackingField;
    public EncryptionAlgorithm Algorithm { get; }
    public Byte[] Ciphertext { get; }
    public Byte[] Iv { get; internal set; }
    public Byte[] AuthenticationTag { get; internal set; }
    public Byte[] AdditionalAuthenticatedData { get; internal set; }
    internal DecryptParameters(EncryptionAlgorithm algorithm, Byte[] ciphertext);
    internal DecryptParameters(EncryptionAlgorithm algorithm, Byte[] ciphertext, Byte[] iv);
    internal DecryptParameters(EncryptionAlgorithm algorithm, Byte[] ciphertext, Byte[] iv, Byte[] authenticationTag, Byte[] additionalAuthenticatedData);
    public static DecryptParameters Rsa15Parameters(Byte[] ciphertext);
    public static DecryptParameters RsaOaepParameters(Byte[] ciphertext);
    public static DecryptParameters RsaOaep256Parameters(Byte[] ciphertext);
    public static DecryptParameters A128GcmParameters(Byte[] ciphertext, Byte[] iv, Byte[] authenticationTag, Byte[] additionalAuthenticatedData);
    public static DecryptParameters A192GcmParameters(Byte[] ciphertext, Byte[] iv, Byte[] authenticationTag, Byte[] additionalAuthenticatedData);
    public static DecryptParameters A256GcmParameters(Byte[] ciphertext, Byte[] iv, Byte[] authenticationTag, Byte[] additionalAuthenticatedData);
    public static DecryptParameters A128CbcParameters(Byte[] ciphertext, Byte[] iv);
    public static DecryptParameters A192CbcParameters(Byte[] ciphertext, Byte[] iv);
    public static DecryptParameters A256CbcParameters(Byte[] ciphertext, Byte[] iv);
    public static DecryptParameters A128CbcPadParameters(Byte[] ciphertext, Byte[] iv);
    public static DecryptParameters A192CbcPadParameters(Byte[] ciphertext, Byte[] iv);
    public static DecryptParameters A256CbcPadParameters(Byte[] ciphertext, Byte[] iv);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_Ciphertext();
    [CompilerGeneratedAttribute]
public Byte[] get_Iv();
    [CompilerGeneratedAttribute]
internal void set_Iv(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AuthenticationTag();
    [CompilerGeneratedAttribute]
internal void set_AuthenticationTag(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AdditionalAuthenticatedData();
    [CompilerGeneratedAttribute]
internal void set_AdditionalAuthenticatedData(Byte[] value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.Cryptography.DecryptResult : object {
    private static string KeyIdPropertyName;
    private static string PlaintextPropertyName;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Plaintext>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <Algorithm>k__BackingField;
    public string KeyId { get; internal set; }
    public Byte[] Plaintext { get; internal set; }
    public EncryptionAlgorithm Algorithm { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
internal void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Plaintext();
    [CompilerGeneratedAttribute]
internal void set_Plaintext(Byte[] value);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
internal void set_Algorithm(EncryptionAlgorithm value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
internal class Azure.Security.KeyVault.Keys.Cryptography.EcCryptographyProvider : LocalCryptographyProvider {
    private KeyCurveName _curve;
    private JsonWebKey _keyMaterial;
    internal EcCryptographyProvider(JsonWebKey keyMaterial, KeyProperties keyProperties, bool localOnly);
    public virtual bool SupportsOperation(KeyOperation operation);
    public virtual SignResult Sign(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    public virtual VerifyResult Verify(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.Cryptography.EncryptionAlgorithm : ValueType {
    internal static string Rsa15Value;
    internal static string RsaOaepValue;
    internal static string RsaOaep256Value;
    internal static string A128GcmValue;
    internal static string A192GcmValue;
    internal static string A256GcmValue;
    internal static string A128CbcValue;
    internal static string A192CbcValue;
    internal static string A256CbcValue;
    internal static string A128CbcPadValue;
    internal static string A192CbcPadValue;
    internal static string A256CbcPadValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <Rsa15>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <RsaOaep>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <RsaOaep256>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A128Gcm>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A192Gcm>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A256Gcm>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A128Cbc>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A192Cbc>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A256Cbc>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A128CbcPad>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A192CbcPad>k__BackingField;
    [CompilerGeneratedAttribute]
private static EncryptionAlgorithm <A256CbcPad>k__BackingField;
    public static EncryptionAlgorithm Rsa15 { get; }
    public static EncryptionAlgorithm RsaOaep { get; }
    public static EncryptionAlgorithm RsaOaep256 { get; }
    public static EncryptionAlgorithm A128Gcm { get; }
    public static EncryptionAlgorithm A192Gcm { get; }
    public static EncryptionAlgorithm A256Gcm { get; }
    public static EncryptionAlgorithm A128Cbc { get; }
    public static EncryptionAlgorithm A192Cbc { get; }
    public static EncryptionAlgorithm A256Cbc { get; }
    public static EncryptionAlgorithm A128CbcPad { get; }
    public static EncryptionAlgorithm A192CbcPad { get; }
    public static EncryptionAlgorithm A256CbcPad { get; }
    public EncryptionAlgorithm(string value);
    private static EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_Rsa15();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_RsaOaep();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_RsaOaep256();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A128Gcm();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A192Gcm();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A256Gcm();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A128Cbc();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A192Cbc();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A256Cbc();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A128CbcPad();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A192CbcPad();
    [CompilerGeneratedAttribute]
public static EncryptionAlgorithm get_A256CbcPad();
    public static bool op_Equality(EncryptionAlgorithm left, EncryptionAlgorithm right);
    public static bool op_Inequality(EncryptionAlgorithm left, EncryptionAlgorithm right);
    public static EncryptionAlgorithm op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EncryptionAlgorithm other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    internal static EncryptionAlgorithm FromRsaEncryptionPadding(RSAEncryptionPadding padding);
    internal RSAEncryptionPadding GetRsaEncryptionPadding();
    internal AesCbc GetAesCbcEncryptionAlgorithm();
}
public class Azure.Security.KeyVault.Keys.Cryptography.EncryptParameters : object {
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Plaintext>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Iv>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AdditionalAuthenticatedData>k__BackingField;
    public EncryptionAlgorithm Algorithm { get; }
    public Byte[] Plaintext { get; }
    public Byte[] Iv { get; private set; }
    public Byte[] AdditionalAuthenticatedData { get; }
    internal EncryptParameters(EncryptionAlgorithm algorithm, Byte[] plaintext);
    internal EncryptParameters(EncryptionAlgorithm algorithm, Byte[] plaintext, Byte[] iv, Byte[] additionalAuthenticatedData);
    public static EncryptParameters Rsa15Parameters(Byte[] plaintext);
    public static EncryptParameters RsaOaepParameters(Byte[] plaintext);
    public static EncryptParameters RsaOaep256Parameters(Byte[] plaintext);
    public static EncryptParameters A128GcmParameters(Byte[] plaintext, Byte[] additionalAuthenticatedData);
    public static EncryptParameters A192GcmParameters(Byte[] plaintext, Byte[] additionalAuthenticatedData);
    public static EncryptParameters A256GcmParameters(Byte[] plaintext, Byte[] additionalAuthenticatedData);
    public static EncryptParameters A128CbcParameters(Byte[] plaintext, Byte[] iv);
    public static EncryptParameters A192CbcParameters(Byte[] plaintext, Byte[] iv);
    public static EncryptParameters A256CbcParameters(Byte[] plaintext, Byte[] iv);
    public static EncryptParameters A128CbcPadParameters(Byte[] plaintext, Byte[] iv);
    public static EncryptParameters A192CbcPadParameters(Byte[] plaintext, Byte[] iv);
    public static EncryptParameters A256CbcPadParameters(Byte[] plaintext, Byte[] iv);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_Plaintext();
    [CompilerGeneratedAttribute]
public Byte[] get_Iv();
    [CompilerGeneratedAttribute]
private void set_Iv(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AdditionalAuthenticatedData();
    internal void Initialize();
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.Cryptography.EncryptResult : object {
    private static string KeyIdPropertyName;
    private static string CiphertextPropertyName;
    private static string IvPropertyName;
    private static string AuthenticationTagPropertyName;
    private static string AdditionalAuthenticatedDataPropertyName;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Ciphertext>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Iv>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AuthenticationTag>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AdditionalAuthenticatedData>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <Algorithm>k__BackingField;
    public string KeyId { get; internal set; }
    public Byte[] Ciphertext { get; internal set; }
    public Byte[] Iv { get; internal set; }
    public Byte[] AuthenticationTag { get; internal set; }
    public Byte[] AdditionalAuthenticatedData { get; internal set; }
    public EncryptionAlgorithm Algorithm { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
internal void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Ciphertext();
    [CompilerGeneratedAttribute]
internal void set_Ciphertext(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Iv();
    [CompilerGeneratedAttribute]
internal void set_Iv(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AuthenticationTag();
    [CompilerGeneratedAttribute]
internal void set_AuthenticationTag(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AdditionalAuthenticatedData();
    [CompilerGeneratedAttribute]
internal void set_AdditionalAuthenticatedData(Byte[] value);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
internal void set_Algorithm(EncryptionAlgorithm value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
internal interface Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider {
    public bool CanRemote { get; }
    public abstract virtual bool get_CanRemote();
    public abstract virtual bool SupportsOperation(KeyOperation operation);
    public abstract virtual Task`1<EncryptResult> EncryptAsync(EncryptParameters parameters, CancellationToken cancellationToken);
    public abstract virtual EncryptResult Encrypt(EncryptParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<DecryptResult> DecryptAsync(DecryptParameters parameters, CancellationToken cancellationToken);
    public abstract virtual DecryptResult Decrypt(DecryptParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<WrapResult> WrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    public abstract virtual WrapResult WrapKey(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    public abstract virtual Task`1<UnwrapResult> UnwrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    public abstract virtual UnwrapResult UnwrapKey(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    public abstract virtual Task`1<SignResult> SignAsync(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    public abstract virtual SignResult Sign(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    public abstract virtual Task`1<VerifyResult> VerifyAsync(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    public abstract virtual VerifyResult Verify(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
}
public class Azure.Security.KeyVault.Keys.Cryptography.KeyResolver : object {
    private static string OTelKeyIdKey;
    private HttpPipeline _pipeline;
    private string _apiVersion;
    private ClientDiagnostics _clientDiagnostics;
    public KeyResolver(TokenCredential credential);
    public KeyResolver(TokenCredential credential, CryptographyClientOptions options);
    public virtual CryptographyClient Resolve(Uri keyId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.KeyResolver/<ResolveAsync>d__8")]
public virtual Task`1<CryptographyClient> ResolveAsync(Uri keyId, CancellationToken cancellationToken);
    private sealed virtual override IKeyEncryptionKey Azure.Core.Cryptography.IKeyEncryptionKeyResolver.Resolve(string keyId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.KeyResolver/<Azure-Core-Cryptography-IKeyEncryptionKeyResolver-ResolveAsync>d__10")]
private sealed virtual override Task`1<IKeyEncryptionKey> Azure.Core.Cryptography.IKeyEncryptionKeyResolver.ResolveAsync(string keyId, CancellationToken cancellationToken);
    private KeyVaultKey GetKey(Uri keyId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.KeyResolver/<GetKeyAsync>d__12")]
private Task`1<KeyVaultKey> GetKeyAsync(Uri keyId, CancellationToken cancellationToken);
    private Response`1<T> ParseResponse(Response response, T result);
    private Request CreateGetRequest(Uri uri);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.Cryptography.KeyWrapAlgorithm : ValueType {
    internal static string RsaOaepValue;
    internal static string Rsa15Value;
    internal static string RsaOaep256Value;
    internal static string A128KWValue;
    internal static string A192KWValue;
    internal static string A256KWValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static KeyWrapAlgorithm <RsaOaep>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyWrapAlgorithm <Rsa15>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyWrapAlgorithm <RsaOaep256>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyWrapAlgorithm <A128KW>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyWrapAlgorithm <A192KW>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyWrapAlgorithm <A256KW>k__BackingField;
    public static KeyWrapAlgorithm RsaOaep { get; }
    public static KeyWrapAlgorithm Rsa15 { get; }
    public static KeyWrapAlgorithm RsaOaep256 { get; }
    public static KeyWrapAlgorithm A128KW { get; }
    public static KeyWrapAlgorithm A192KW { get; }
    public static KeyWrapAlgorithm A256KW { get; }
    public KeyWrapAlgorithm(string value);
    private static KeyWrapAlgorithm();
    [CompilerGeneratedAttribute]
public static KeyWrapAlgorithm get_RsaOaep();
    [CompilerGeneratedAttribute]
public static KeyWrapAlgorithm get_Rsa15();
    [CompilerGeneratedAttribute]
public static KeyWrapAlgorithm get_RsaOaep256();
    [CompilerGeneratedAttribute]
public static KeyWrapAlgorithm get_A128KW();
    [CompilerGeneratedAttribute]
public static KeyWrapAlgorithm get_A192KW();
    [CompilerGeneratedAttribute]
public static KeyWrapAlgorithm get_A256KW();
    public static bool op_Equality(KeyWrapAlgorithm left, KeyWrapAlgorithm right);
    public static bool op_Inequality(KeyWrapAlgorithm left, KeyWrapAlgorithm right);
    public static KeyWrapAlgorithm op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public sealed virtual bool Equals(KeyWrapAlgorithm other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    internal RSAEncryptionPadding GetRsaEncryptionPadding();
    internal AesKw GetAesKeyWrapAlgorithm();
}
internal class Azure.Security.KeyVault.Keys.Cryptography.KeyWrapParameters : ValueType {
    private static JsonEncodedText s_algorithmPropertyNameBytes;
    private static JsonEncodedText s_keyPropertyNameBytes;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Key>k__BackingField;
    public string Algorithm { get; public set; }
    public Byte[] Key { get; public set; }
    private static KeyWrapParameters();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Byte[] value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.Cryptography.LocalCryptographyClientOptions : ClientOptions {
}
internal abstract class Azure.Security.KeyVault.Keys.Cryptography.LocalCryptographyProvider : object {
    private KeyProperties _keyProperties;
    [CompilerGeneratedAttribute]
private bool <CanRemote>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonWebKey <KeyMaterial>k__BackingField;
    public bool CanRemote { get; }
    protected internal JsonWebKey KeyMaterial { get; protected internal set; }
    protected bool MustRemote { get; }
    public LocalCryptographyProvider(JsonWebKey keyMaterial, KeyProperties keyProperties, bool localOnly);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanRemote();
    [CompilerGeneratedAttribute]
protected internal JsonWebKey get_KeyMaterial();
    [CompilerGeneratedAttribute]
protected internal void set_KeyMaterial(JsonWebKey value);
    protected bool get_MustRemote();
    public abstract virtual bool SupportsOperation(KeyOperation operation);
    public virtual DecryptResult Decrypt(DecryptParameters parameters, CancellationToken cancellationToken);
    public virtual Task`1<DecryptResult> DecryptAsync(DecryptParameters parameters, CancellationToken cancellationToken);
    public virtual EncryptResult Encrypt(EncryptParameters parameters, CancellationToken cancellationToken);
    public virtual Task`1<EncryptResult> EncryptAsync(EncryptParameters parameters, CancellationToken cancellationToken);
    public virtual SignResult Sign(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    public virtual Task`1<SignResult> SignAsync(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    public virtual UnwrapResult UnwrapKey(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    public virtual Task`1<UnwrapResult> UnwrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    public virtual VerifyResult Verify(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    public virtual Task`1<VerifyResult> VerifyAsync(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    public virtual WrapResult WrapKey(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    public virtual Task`1<WrapResult> WrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    internal static NotSupportedException CreateOperationNotSupported(string name, Exception innerException);
    protected void ThrowIfTimeInvalid();
}
internal static class Azure.Security.KeyVault.Keys.Cryptography.LocalCryptographyProviderFactory : object {
    public static ICryptographyProvider Create(KeyVaultKey key, bool localOnly);
    public static ICryptographyProvider Create(JsonWebKey keyMaterial, KeyProperties keyProperties, bool localOnly);
}
internal class Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient : object {
    private static string OTelKeyIdKey;
    private Uri _keyId;
    private string _keyIdStr;
    [CompilerGeneratedAttribute]
private KeyVaultPipeline <Pipeline>k__BackingField;
    internal KeyVaultPipeline Pipeline { get; }
    private bool Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.CanRemote { get; }
    internal RemoteCryptographyClient(Uri keyId, TokenCredential credential, CryptographyClientOptions options);
    internal RemoteCryptographyClient(KeyVaultPipeline pipeline);
    [CompilerGeneratedAttribute]
internal KeyVaultPipeline get_Pipeline();
    public sealed virtual bool SupportsOperation(KeyOperation operation);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<EncryptAsync>d__10")]
public virtual Task`1<Response`1<EncryptResult>> EncryptAsync(EncryptParameters parameters, CancellationToken cancellationToken);
    public virtual Response`1<EncryptResult> Encrypt(EncryptParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<DecryptAsync>d__12")]
public virtual Task`1<Response`1<DecryptResult>> DecryptAsync(DecryptParameters parameters, CancellationToken cancellationToken);
    public virtual Response`1<DecryptResult> Decrypt(DecryptParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<WrapKeyAsync>d__14")]
public virtual Task`1<Response`1<WrapResult>> WrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    public virtual Response`1<WrapResult> WrapKey(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<UnwrapKeyAsync>d__16")]
public virtual Task`1<Response`1<UnwrapResult>> UnwrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    public virtual Response`1<UnwrapResult> UnwrapKey(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<SignAsync>d__18")]
public virtual Task`1<Response`1<SignResult>> SignAsync(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    public virtual Response`1<SignResult> Sign(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<VerifyAsync>d__20")]
public virtual Task`1<Response`1<VerifyResult>> VerifyAsync(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    public virtual Response`1<VerifyResult> Verify(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<GetKeyAsync>d__22")]
internal virtual Task`1<Response`1<KeyVaultKey>> GetKeyAsync(CancellationToken cancellationToken);
    internal virtual Response`1<KeyVaultKey> GetKey(CancellationToken cancellationToken);
    private sealed virtual override bool Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.get_CanRemote();
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<Azure-Security-KeyVault-Keys-Cryptography-ICryptographyProvider-EncryptAsync>d__26")]
private sealed virtual override Task`1<EncryptResult> Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.EncryptAsync(EncryptParameters parameters, CancellationToken cancellationToken);
    private sealed virtual override EncryptResult Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.Encrypt(EncryptParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<Azure-Security-KeyVault-Keys-Cryptography-ICryptographyProvider-DecryptAsync>d__28")]
private sealed virtual override Task`1<DecryptResult> Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.DecryptAsync(DecryptParameters parameters, CancellationToken cancellationToken);
    private sealed virtual override DecryptResult Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.Decrypt(DecryptParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<Azure-Security-KeyVault-Keys-Cryptography-ICryptographyProvider-WrapKeyAsync>d__30")]
private sealed virtual override Task`1<WrapResult> Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.WrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    private sealed virtual override WrapResult Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.WrapKey(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<Azure-Security-KeyVault-Keys-Cryptography-ICryptographyProvider-UnwrapKeyAsync>d__32")]
private sealed virtual override Task`1<UnwrapResult> Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.UnwrapKeyAsync(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    private sealed virtual override UnwrapResult Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.UnwrapKey(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<Azure-Security-KeyVault-Keys-Cryptography-ICryptographyProvider-SignAsync>d__34")]
private sealed virtual override Task`1<SignResult> Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.SignAsync(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    private sealed virtual override SignResult Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.Sign(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.Cryptography.RemoteCryptographyClient/<Azure-Security-KeyVault-Keys-Cryptography-ICryptographyProvider-VerifyAsync>d__36")]
private sealed virtual override Task`1<VerifyResult> Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.VerifyAsync(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    private sealed virtual override VerifyResult Azure.Security.KeyVault.Keys.Cryptography.ICryptographyProvider.Verify(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
}
internal class Azure.Security.KeyVault.Keys.Cryptography.RsaCryptographyProvider : LocalCryptographyProvider {
    internal RsaCryptographyProvider(JsonWebKey keyMaterial, KeyProperties keyProperties, bool localOnly);
    public virtual bool SupportsOperation(KeyOperation operation);
    public virtual EncryptResult Encrypt(EncryptParameters parameters, CancellationToken cancellationToken);
    public virtual DecryptResult Decrypt(DecryptParameters parameters, CancellationToken cancellationToken);
    public virtual SignResult Sign(SignatureAlgorithm algorithm, Byte[] digest, CancellationToken cancellationToken);
    public virtual VerifyResult Verify(SignatureAlgorithm algorithm, Byte[] digest, Byte[] signature, CancellationToken cancellationToken);
    public virtual WrapResult WrapKey(KeyWrapAlgorithm algorithm, Byte[] key, CancellationToken cancellationToken);
    public virtual UnwrapResult UnwrapKey(KeyWrapAlgorithm algorithm, Byte[] encryptedKey, CancellationToken cancellationToken);
    private Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    private Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
}
public class Azure.Security.KeyVault.Keys.Cryptography.RSAKeyVault : RSA {
    private static KeySizes[] s_legalKeySizes;
    private CryptographyClient _client;
    private RSA _key;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    public string KeyId { get; }
    public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    internal RSAKeyVault(CryptographyClient client, string keyId, JsonWebKey keyMaterial);
    private static RSAKeyVault();
    [CompilerGeneratedAttribute]
public string get_KeyId();
    public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    protected virtual void Dispose(bool disposing);
    private static HashAlgorithm Create(HashAlgorithmName algorithm);
}
internal class Azure.Security.KeyVault.Keys.Cryptography.SecretKey : KeyVaultKey {
    private static string IdPropertyName;
    private static string ValuePropertyName;
    private static string ContentTypePropertyName;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    public string ContentType { get; private set; }
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(string value);
    internal virtual void ReadProperty(JsonProperty prop);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.Cryptography.SignatureAlgorithm : ValueType {
    internal static string RS256Value;
    internal static string RS384Value;
    internal static string RS512Value;
    internal static string PS256Value;
    internal static string PS384Value;
    internal static string PS512Value;
    internal static string ES256Value;
    internal static string ES384Value;
    internal static string ES512Value;
    internal static string ES256KValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <RS256>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <RS384>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <RS512>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <PS256>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <PS384>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <PS512>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <ES256>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <ES384>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <ES512>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureAlgorithm <ES256K>k__BackingField;
    public static SignatureAlgorithm RS256 { get; }
    public static SignatureAlgorithm RS384 { get; }
    public static SignatureAlgorithm RS512 { get; }
    public static SignatureAlgorithm PS256 { get; }
    public static SignatureAlgorithm PS384 { get; }
    public static SignatureAlgorithm PS512 { get; }
    public static SignatureAlgorithm ES256 { get; }
    public static SignatureAlgorithm ES384 { get; }
    public static SignatureAlgorithm ES512 { get; }
    public static SignatureAlgorithm ES256K { get; }
    public SignatureAlgorithm(string value);
    private static SignatureAlgorithm();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_RS256();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_RS384();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_RS512();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_PS256();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_PS384();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_PS512();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_ES256();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_ES384();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_ES512();
    [CompilerGeneratedAttribute]
public static SignatureAlgorithm get_ES256K();
    public static bool op_Equality(SignatureAlgorithm left, SignatureAlgorithm right);
    public static bool op_Inequality(SignatureAlgorithm left, SignatureAlgorithm right);
    public static SignatureAlgorithm op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SignatureAlgorithm other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    internal static SignatureAlgorithm FromHashAlgorithmName(HashAlgorithmName algorithm, RSASignaturePadding padding);
    internal HashAlgorithm GetHashAlgorithm();
    internal HashAlgorithmName GetHashAlgorithmName();
    internal KeyCurveName GetEcKeyCurveName();
    internal RSASignaturePadding GetRsaSignaturePadding();
}
public class Azure.Security.KeyVault.Keys.Cryptography.SignResult : object {
    private static string KeyIdPropertyName;
    private static string SignaturePropertyName;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureAlgorithm <Algorithm>k__BackingField;
    public string KeyId { get; internal set; }
    public Byte[] Signature { get; internal set; }
    public SignatureAlgorithm Algorithm { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
internal void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(Byte[] value);
    [CompilerGeneratedAttribute]
public SignatureAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
internal void set_Algorithm(SignatureAlgorithm value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
public class Azure.Security.KeyVault.Keys.Cryptography.UnwrapResult : object {
    private static string KeyIdPropertyName;
    private static string KeyPropertyName;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyWrapAlgorithm <Algorithm>k__BackingField;
    public string KeyId { get; internal set; }
    public Byte[] Key { get; internal set; }
    public KeyWrapAlgorithm Algorithm { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
internal void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Key();
    [CompilerGeneratedAttribute]
internal void set_Key(Byte[] value);
    [CompilerGeneratedAttribute]
public KeyWrapAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
internal void set_Algorithm(KeyWrapAlgorithm value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
public class Azure.Security.KeyVault.Keys.Cryptography.VerifyResult : object {
    private static string KeyIdPropertyName;
    private static string ValidPropertyName;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureAlgorithm <Algorithm>k__BackingField;
    public string KeyId { get; internal set; }
    public bool IsValid { get; internal set; }
    public SignatureAlgorithm Algorithm { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
internal void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
internal void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public SignatureAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
internal void set_Algorithm(SignatureAlgorithm value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
public class Azure.Security.KeyVault.Keys.Cryptography.WrapResult : object {
    private static string KeyIdPropertyName;
    private static string EncryptedKeyPropertyName;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EncryptedKey>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyWrapAlgorithm <Algorithm>k__BackingField;
    public string KeyId { get; internal set; }
    public Byte[] EncryptedKey { get; internal set; }
    public KeyWrapAlgorithm Algorithm { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
internal void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
internal void set_EncryptedKey(Byte[] value);
    [CompilerGeneratedAttribute]
public KeyWrapAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
internal void set_Algorithm(KeyWrapAlgorithm value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
public static class Azure.Security.KeyVault.Keys.CryptographyModelFactory : object {
    public static DecryptParameters DecryptParameters(EncryptionAlgorithm algorithm, Byte[] ciphertext, Byte[] iv, Byte[] authenticationTag, Byte[] additionalAuthenticatedData);
    public static DecryptResult DecryptResult(string keyId, Byte[] plaintext, EncryptionAlgorithm algorithm);
    public static EncryptParameters EncryptParameters(EncryptionAlgorithm algorithm, Byte[] plaintext, Byte[] iv, Byte[] additionalAuthenticatedData);
    [EditorBrowsableAttribute("1")]
public static EncryptResult EncryptResult(string keyId, Byte[] ciphertext, EncryptionAlgorithm algorithm);
    public static EncryptResult EncryptResult(string keyId, Byte[] ciphertext, EncryptionAlgorithm algorithm, Byte[] iv, Byte[] authenticatedTag, Byte[] additionalAuthenticatedData);
    public static SignResult SignResult(string keyId, Byte[] signature, SignatureAlgorithm algorithm);
    public static UnwrapResult UnwrapResult(string keyId, Byte[] key, KeyWrapAlgorithm algorithm);
    public static VerifyResult VerifyResult(string keyId, bool isValid, SignatureAlgorithm algorithm);
    public static WrapResult WrapResult(string keyId, Byte[] key, KeyWrapAlgorithm algorithm);
}
public class Azure.Security.KeyVault.Keys.DeletedKey : KeyVaultKey {
    private static string RecoveryIdPropertyName;
    private static string DeletedOnPropertyName;
    private static string ScheduledPurgeDatePropertyName;
    private string _recoveryId;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ScheduledPurgeDate>k__BackingField;
    public Uri RecoveryId { get; internal set; }
    public Nullable`1<DateTimeOffset> DeletedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> ScheduledPurgeDate { get; internal set; }
    internal DeletedKey(KeyProperties properties);
    internal DeletedKey(string name);
    public Uri get_RecoveryId();
    internal void set_RecoveryId(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedOn();
    [CompilerGeneratedAttribute]
internal void set_DeletedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ScheduledPurgeDate();
    [CompilerGeneratedAttribute]
internal void set_ScheduledPurgeDate(Nullable`1<DateTimeOffset> value);
    internal virtual void ReadProperty(JsonProperty prop);
}
public class Azure.Security.KeyVault.Keys.DeleteKeyOperation : Operation`1<DeletedKey> {
    private static TimeSpan s_defaultPollingInterval;
    private KeyVaultPipeline _pipeline;
    private OperationInternal _operationInternal;
    private DeletedKey _value;
    public string Id { get; }
    public DeletedKey Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal DeleteKeyOperation(KeyVaultPipeline pipeline, Response`1<DeletedKey> response);
    private static DeleteKeyOperation();
    public virtual string get_Id();
    public virtual DeletedKey get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.DeleteKeyOperation/<UpdateStatusAsync>d__16")]
public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<DeletedKey>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<DeletedKey>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.DeleteKeyOperation/<Azure-Core-IOperation-UpdateStateAsync>d__19")]
private sealed virtual override ValueTask`1<OperationState> Azure.Core.IOperation.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
internal class Azure.Security.KeyVault.Keys.GetRandomBytesRequest : object {
    private static JsonEncodedText s_countPropertyNameBytes;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    public GetRandomBytesRequest(int count);
    private static GetRandomBytesRequest();
    [CompilerGeneratedAttribute]
public int get_Count();
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.ImportKeyOptions : object {
    private static string KeyPropertyName;
    private static string HsmPropertyName;
    private static JsonEncodedText s_keyPropertyNameBytes;
    private static JsonEncodedText s_hsmPropertyNameBytes;
    [CompilerGeneratedAttribute]
private JsonWebKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HardwareProtected>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyProperties <Properties>k__BackingField;
    public string Name { get; }
    public JsonWebKey Key { get; }
    public Nullable`1<bool> HardwareProtected { get; public set; }
    public KeyProperties Properties { get; }
    public ImportKeyOptions(string name, JsonWebKey keyMaterial);
    private static ImportKeyOptions();
    public string get_Name();
    [CompilerGeneratedAttribute]
public JsonWebKey get_Key();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HardwareProtected();
    [CompilerGeneratedAttribute]
public void set_HardwareProtected(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public KeyProperties get_Properties();
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
[JsonConverterAttribute("Azure.Security.KeyVault.Keys.JsonWebKeyConverter")]
public class Azure.Security.KeyVault.Keys.JsonWebKey : object {
    private static string KeyIdPropertyName;
    private static string KeyTypePropertyName;
    private static string KeyOpsPropertyName;
    private static string CurveNamePropertyName;
    private static string NPropertyName;
    private static string EPropertyName;
    private static string DPPropertyName;
    private static string DQPropertyName;
    private static string QIPropertyName;
    private static string PPropertyName;
    private static string QPropertyName;
    private static string XPropertyName;
    private static string YPropertyName;
    private static string DPropertyName;
    private static string KPropertyName;
    private static string TPropertyName;
    private static JsonEncodedText s_keyIdPropertyNameBytes;
    private static JsonEncodedText s_keyTypePropertyNameBytes;
    private static JsonEncodedText s_keyOpsPropertyNameBytes;
    private static JsonEncodedText s_curveNamePropertyNameBytes;
    private static JsonEncodedText s_nPropertyNameBytes;
    private static JsonEncodedText s_ePropertyNameBytes;
    private static JsonEncodedText s_dPPropertyNameBytes;
    private static JsonEncodedText s_dQPropertyNameBytes;
    private static JsonEncodedText s_qIPropertyNameBytes;
    private static JsonEncodedText s_pPropertyNameBytes;
    private static JsonEncodedText s_qPropertyNameBytes;
    private static JsonEncodedText s_xPropertyNameBytes;
    private static JsonEncodedText s_yPropertyNameBytes;
    private static JsonEncodedText s_dPropertyNameBytes;
    private static JsonEncodedText s_kPropertyNameBytes;
    private static JsonEncodedText s_tPropertyNameBytes;
    private static KeyOperation[] s_aesKeyOperation;
    private static KeyOperation[] s_rSAPublicKeyOperation;
    private static KeyOperation[] s_rSAPrivateKeyOperation;
    private static KeyOperation[] s_eCPublicKeyOperation;
    private static KeyOperation[] s_eCPrivateKeyOperation;
    private IList`1<KeyOperation> _keyOps;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<KeyOperation> <KeyOps>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <N>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <E>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <DP>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <DQ>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <QI>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <P>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Q>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyCurveName> <CurveName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <X>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <D>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <K>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <T>k__BackingField;
    private static Func`2<RSAParameters, RSA> s_rsaFactory;
    private static Byte[] s_zeroBuffer;
    public string Id { get; public set; }
    public KeyType KeyType { get; public set; }
    public IReadOnlyCollection`1<KeyOperation> KeyOps { get; }
    public Byte[] N { get; public set; }
    public Byte[] E { get; public set; }
    public Byte[] DP { get; public set; }
    public Byte[] DQ { get; public set; }
    public Byte[] QI { get; public set; }
    public Byte[] P { get; public set; }
    public Byte[] Q { get; public set; }
    public Nullable`1<KeyCurveName> CurveName { get; public set; }
    public Byte[] X { get; public set; }
    public Byte[] Y { get; public set; }
    public Byte[] D { get; public set; }
    public Byte[] K { get; public set; }
    public Byte[] T { get; public set; }
    internal bool HasPrivateKey { get; }
    public JsonWebKey(IEnumerable`1<KeyOperation> keyOps);
    public JsonWebKey(Aes aesProvider, IEnumerable`1<KeyOperation> keyOps);
    public JsonWebKey(ECDsa ecdsa, bool includePrivateParameters, IEnumerable`1<KeyOperation> keyOps);
    public JsonWebKey(RSA rsaProvider, bool includePrivateParameters, IEnumerable`1<KeyOperation> keyOps);
    private static JsonWebKey();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public KeyType get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(KeyType value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<KeyOperation> get_KeyOps();
    [CompilerGeneratedAttribute]
public Byte[] get_N();
    [CompilerGeneratedAttribute]
public void set_N(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_E();
    [CompilerGeneratedAttribute]
public void set_E(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_DP();
    [CompilerGeneratedAttribute]
public void set_DP(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_DQ();
    [CompilerGeneratedAttribute]
public void set_DQ(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_QI();
    [CompilerGeneratedAttribute]
public void set_QI(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_P();
    [CompilerGeneratedAttribute]
public void set_P(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Q();
    [CompilerGeneratedAttribute]
public void set_Q(Byte[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<KeyCurveName> get_CurveName();
    [CompilerGeneratedAttribute]
public void set_CurveName(Nullable`1<KeyCurveName> value);
    [CompilerGeneratedAttribute]
public Byte[] get_X();
    [CompilerGeneratedAttribute]
public void set_X(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_D();
    [CompilerGeneratedAttribute]
public void set_D(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_K();
    [CompilerGeneratedAttribute]
public void set_K(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_T();
    [CompilerGeneratedAttribute]
public void set_T(Byte[] value);
    internal bool get_HasPrivateKey();
    public Aes ToAes();
    public ECDsa ToECDsa(bool includePrivateParameters);
    internal ECDsa ToECDsa(bool includePrivateParameters, bool throwIfNotSupported);
    public RSA ToRSA(bool includePrivateParameters);
    internal bool SupportsOperation(KeyOperation operation);
    internal void ReadProperties(JsonElement json);
    internal void WriteProperties(Utf8JsonWriter json, bool withId);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
    private static RSA CreateRSAProvider(RSAParameters parameters);
    private static Byte[] ForceBufferLength(string name, Byte[] value, int requiredLengthInBytes);
    private static Byte[] TrimBuffer(Byte[] value);
    private static void ValidateKeyParameter(string name, Byte[] value);
    private void Initialize(ECDsa ecdsa, bool includePrivateParameters);
    private ECDsa Convert(bool includePrivateParameters, bool throwIfNotSupported);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026")]
internal static MethodInfo <CreateRSAProvider>g__GetRsaCreateMethod|118_0();
}
internal class Azure.Security.KeyVault.Keys.JsonWebKeyConverter : JsonConverter`1<JsonWebKey> {
    public virtual JsonWebKey Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonWebKey value, JsonSerializerOptions options);
}
internal class Azure.Security.KeyVault.Keys.KeyAttributes : ValueType {
    private static string EnabledPropertyName;
    private static string NotBeforePropertyName;
    private static string ExpiresPropertyName;
    private static string CreatedPropertyName;
    private static string UpdatedPropertyName;
    private static string RecoverableDaysPropertyName;
    private static string RecoveryLevelPropertyName;
    private static string ExportablePropertyName;
    private static string HsmPlatformPropertyName;
    private static JsonEncodedText s_enabledPropertyNameBytes;
    private static JsonEncodedText s_notBeforePropertyNameBytes;
    private static JsonEncodedText s_expiresPropertyNameBytes;
    private static JsonEncodedText s_exportablePropertyNameBytes;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Exportable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <UpdatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RecoverableDays>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RecoveryLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HsmPlatform>k__BackingField;
    public Nullable`1<bool> Enabled { get; public set; }
    public Nullable`1<DateTimeOffset> NotBefore { get; public set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; public set; }
    public Nullable`1<bool> Exportable { get; public set; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> UpdatedOn { get; internal set; }
    public Nullable`1<int> RecoverableDays { get; internal set; }
    public string RecoveryLevel { get; internal set; }
    public string HsmPlatform { get; internal set; }
    internal bool ShouldSerialize { get; }
    private static KeyAttributes();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(Nullable`1<bool> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_Exportable();
    [CompilerGeneratedAttribute]
public void set_Exportable(Nullable`1<bool> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_UpdatedOn();
    [CompilerGeneratedAttribute]
internal void set_UpdatedOn(Nullable`1<DateTimeOffset> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_RecoverableDays();
    [CompilerGeneratedAttribute]
internal void set_RecoverableDays(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_RecoveryLevel();
    [CompilerGeneratedAttribute]
internal void set_RecoveryLevel(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_HsmPlatform();
    [CompilerGeneratedAttribute]
internal void set_HsmPlatform(string value);
    internal bool get_ShouldSerialize();
    internal void ReadProperties(JsonElement json);
    internal void WriteProperties(Utf8JsonWriter json);
}
internal class Azure.Security.KeyVault.Keys.KeyBackup : object {
    private static string ValuePropertyName;
    private static JsonEncodedText s_valuePropertyNameBytes;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; public set; }
    private static KeyBackup();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Byte[] value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.KeyClient : object {
    internal static string KeysPath;
    internal static string DeletedKeysPath;
    internal static string RngPath;
    private static string CallerShouldAuditReason;
    private static string OTelKeyNameKey;
    private static string OTelKeyVersionKey;
    private KeyVaultPipeline _pipeline;
    private ClientDiagnostics _clientDiagnostics;
    public Uri VaultUri { get; }
    public KeyClient(Uri vaultUri, TokenCredential credential);
    public KeyClient(Uri vaultUri, TokenCredential credential, KeyClientOptions options);
    public virtual Uri get_VaultUri();
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> CreateKey(string name, KeyType keyType, CreateKeyOptions keyOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<CreateKeyAsync>d__14")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> CreateKeyAsync(string name, KeyType keyType, CreateKeyOptions keyOptions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> CreateEcKey(CreateEcKeyOptions ecKeyOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<CreateEcKeyAsync>d__16")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> CreateEcKeyAsync(CreateEcKeyOptions ecKeyOptions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> CreateRsaKey(CreateRsaKeyOptions rsaKeyOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<CreateRsaKeyAsync>d__18")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> CreateRsaKeyAsync(CreateRsaKeyOptions rsaKeyOptions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> CreateOctKey(CreateOctKeyOptions octKeyOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<CreateOctKeyAsync>d__20")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> CreateOctKeyAsync(CreateOctKeyOptions octKeyOptions, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> UpdateKeyProperties(KeyProperties properties, IEnumerable`1<KeyOperation> keyOperations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<UpdateKeyPropertiesAsync>d__22")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> UpdateKeyPropertiesAsync(KeyProperties properties, IEnumerable`1<KeyOperation> keyOperations, CancellationToken cancellationToken);
    public virtual Response`1<KeyVaultKey> GetKey(string name, string version, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<GetKeyAsync>d__24")]
public virtual Task`1<Response`1<KeyVaultKey>> GetKeyAsync(string name, string version, CancellationToken cancellationToken);
    public virtual Pageable`1<KeyProperties> GetPropertiesOfKeys(CancellationToken cancellationToken);
    public virtual AsyncPageable`1<KeyProperties> GetPropertiesOfKeysAsync(CancellationToken cancellationToken);
    public virtual Pageable`1<KeyProperties> GetPropertiesOfKeyVersions(string name, CancellationToken cancellationToken);
    public virtual AsyncPageable`1<KeyProperties> GetPropertiesOfKeyVersionsAsync(string name, CancellationToken cancellationToken);
    public virtual Response`1<DeletedKey> GetDeletedKey(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<GetDeletedKeyAsync>d__30")]
public virtual Task`1<Response`1<DeletedKey>> GetDeletedKeyAsync(string name, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual DeleteKeyOperation StartDeleteKey(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<StartDeleteKeyAsync>d__32")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<DeleteKeyOperation> StartDeleteKeyAsync(string name, CancellationToken cancellationToken);
    public virtual Pageable`1<DeletedKey> GetDeletedKeys(CancellationToken cancellationToken);
    public virtual AsyncPageable`1<DeletedKey> GetDeletedKeysAsync(CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response PurgeDeletedKey(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<PurgeDeletedKeyAsync>d__36")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response> PurgeDeletedKeyAsync(string name, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual RecoverDeletedKeyOperation StartRecoverDeletedKey(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<StartRecoverDeletedKeyAsync>d__38")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<RecoverDeletedKeyOperation> StartRecoverDeletedKeyAsync(string name, CancellationToken cancellationToken);
    public virtual Response`1<Byte[]> BackupKey(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<BackupKeyAsync>d__40")]
public virtual Task`1<Response`1<Byte[]>> BackupKeyAsync(string name, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> RestoreKeyBackup(Byte[] backup, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<RestoreKeyBackupAsync>d__42")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> RestoreKeyBackupAsync(Byte[] backup, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> ImportKey(string name, JsonWebKey keyMaterial, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<ImportKeyAsync>d__44")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> ImportKeyAsync(string name, JsonWebKey keyMaterial, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> ImportKey(ImportKeyOptions importKeyOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<ImportKeyAsync>d__46")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> ImportKeyAsync(ImportKeyOptions importKeyOptions, CancellationToken cancellationToken);
    public virtual Response`1<Byte[]> GetRandomBytes(int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<GetRandomBytesAsync>d__48")]
public virtual Task`1<Response`1<Byte[]>> GetRandomBytesAsync(int count, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<ReleaseKeyResult> ReleaseKey(string name, string targetAttestationToken, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<ReleaseKeyResult> ReleaseKey(ReleaseKeyOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<ReleaseKeyAsync>d__51")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<ReleaseKeyResult>> ReleaseKeyAsync(string name, string targetAttestationToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<ReleaseKeyAsync>d__52")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<ReleaseKeyResult>> ReleaseKeyAsync(ReleaseKeyOptions options, CancellationToken cancellationToken);
    public virtual CryptographyClient GetCryptographyClient(string keyName, string keyVersion);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyRotationPolicy> GetKeyRotationPolicy(string keyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<GetKeyRotationPolicyAsync>d__55")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyRotationPolicy>> GetKeyRotationPolicyAsync(string keyName, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyVaultKey> RotateKey(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<RotateKeyAsync>d__57")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyVaultKey>> RotateKeyAsync(string name, CancellationToken cancellationToken);
    [CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Response`1<KeyRotationPolicy> UpdateKeyRotationPolicy(string keyName, KeyRotationPolicy policy, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.KeyClient/<UpdateKeyRotationPolicyAsync>d__59")]
[CallerShouldAuditAttribute("https://aka.ms/azsdk/callershouldaudit/security-keyvault-keys")]
public virtual Task`1<Response`1<KeyRotationPolicy>> UpdateKeyRotationPolicyAsync(string keyName, KeyRotationPolicy policy, CancellationToken cancellationToken);
    internal static Uri CreateKeyUri(Uri vaultUri, string name, string version);
}
public class Azure.Security.KeyVault.Keys.KeyClientOptions : ClientOptions {
    internal static ServiceVersion LatestVersion;
    [CompilerGeneratedAttribute]
private ServiceVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableChallengeResourceVerification>k__BackingField;
    public ServiceVersion Version { get; }
    public bool DisableChallengeResourceVerification { get; public set; }
    public KeyClientOptions(ServiceVersion version);
    [CompilerGeneratedAttribute]
public ServiceVersion get_Version();
    [CompilerGeneratedAttribute]
public bool get_DisableChallengeResourceVerification();
    [CompilerGeneratedAttribute]
public void set_DisableChallengeResourceVerification(bool value);
    internal string GetVersionString();
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.KeyCurveName : ValueType {
    private static string P256Value;
    private static string P256KValue;
    private static string P384Value;
    private static string P521Value;
    private static string P256OidValue;
    private static string P256KOidValue;
    private static string P384OidValue;
    private static string P521OidValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static KeyCurveName <P256>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyCurveName <P256K>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyCurveName <P384>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyCurveName <P521>k__BackingField;
    public static KeyCurveName P256 { get; }
    public static KeyCurveName P256K { get; }
    public static KeyCurveName P384 { get; }
    public static KeyCurveName P521 { get; }
    internal bool IsSupported { get; }
    internal int KeyParameterSize { get; }
    internal int KeySize { get; }
    internal Oid Oid { get; }
    public KeyCurveName(string value);
    private static KeyCurveName();
    [CompilerGeneratedAttribute]
public static KeyCurveName get_P256();
    [CompilerGeneratedAttribute]
public static KeyCurveName get_P256K();
    [CompilerGeneratedAttribute]
public static KeyCurveName get_P384();
    [CompilerGeneratedAttribute]
public static KeyCurveName get_P521();
    public static bool op_Equality(KeyCurveName left, KeyCurveName right);
    public static bool op_Inequality(KeyCurveName left, KeyCurveName right);
    public static KeyCurveName op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(KeyCurveName other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
    internal static KeyCurveName FromOid(Oid oid, int keySize);
    internal bool get_IsSupported();
    internal int get_KeyParameterSize();
    internal int get_KeySize();
    internal Oid get_Oid();
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.KeyExportEncryptionAlgorithm : ValueType {
    internal static string CkmRsaAesKeyWrapValue;
    internal static string RsaAesKeyWrap256Value;
    internal static string RsaAesKeyWrap384Value;
    private string _value;
    [CompilerGeneratedAttribute]
private static KeyExportEncryptionAlgorithm <CkmRsaAesKeyWrap>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyExportEncryptionAlgorithm <RsaAesKeyWrap256>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyExportEncryptionAlgorithm <RsaAesKeyWrap384>k__BackingField;
    public static KeyExportEncryptionAlgorithm CkmRsaAesKeyWrap { get; }
    public static KeyExportEncryptionAlgorithm RsaAesKeyWrap256 { get; }
    public static KeyExportEncryptionAlgorithm RsaAesKeyWrap384 { get; }
    public KeyExportEncryptionAlgorithm(string value);
    private static KeyExportEncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public static KeyExportEncryptionAlgorithm get_CkmRsaAesKeyWrap();
    [CompilerGeneratedAttribute]
public static KeyExportEncryptionAlgorithm get_RsaAesKeyWrap256();
    [CompilerGeneratedAttribute]
public static KeyExportEncryptionAlgorithm get_RsaAesKeyWrap384();
    public static bool op_Equality(KeyExportEncryptionAlgorithm left, KeyExportEncryptionAlgorithm right);
    public static bool op_Inequality(KeyExportEncryptionAlgorithm left, KeyExportEncryptionAlgorithm right);
    public static KeyExportEncryptionAlgorithm op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(KeyExportEncryptionAlgorithm other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
public static class Azure.Security.KeyVault.Keys.KeyModelFactory : object {
    public static JsonWebKey JsonWebKey(KeyType keyType, string id, IEnumerable`1<KeyOperation> keyOps, Nullable`1<KeyCurveName> curveName, Byte[] d, Byte[] dp, Byte[] dq, Byte[] e, Byte[] k, Byte[] n, Byte[] p, Byte[] q, Byte[] qi, Byte[] t, Byte[] x, Byte[] y);
    [EditorBrowsableAttribute("1")]
public static KeyProperties KeyProperties(Uri id, Uri vaultUri, string name, string version, bool managed, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> updatedOn, string recoveryLevel);
    public static KeyProperties KeyProperties(Uri id, Uri vaultUri, string name, string version, bool managed, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> updatedOn, string recoveryLevel, Nullable`1<int> recoverableDays);
    public static KeyVaultKey KeyVaultKey(KeyProperties properties, JsonWebKey key);
    public static DeletedKey DeletedKey(KeyProperties properties, JsonWebKey key, Uri recoveryId, Nullable`1<DateTimeOffset> deletedOn, Nullable`1<DateTimeOffset> scheduledPurgeDate);
    public static ReleaseKeyResult ReleaseKeyResult(string value);
    public static KeyRotationPolicy KeyRotationPolicy(Uri id, Nullable`1<DateTimeOffset> createdOn, Nullable`1<DateTimeOffset> updatedOn);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.KeyOperation : ValueType {
    private string _value;
    [CompilerGeneratedAttribute]
private static KeyOperation <Encrypt>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyOperation <Decrypt>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyOperation <Sign>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyOperation <Verify>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyOperation <WrapKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyOperation <UnwrapKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyOperation <Import>k__BackingField;
    public static KeyOperation Encrypt { get; }
    public static KeyOperation Decrypt { get; }
    public static KeyOperation Sign { get; }
    public static KeyOperation Verify { get; }
    public static KeyOperation WrapKey { get; }
    public static KeyOperation UnwrapKey { get; }
    public static KeyOperation Import { get; }
    public KeyOperation(string value);
    private static KeyOperation();
    [CompilerGeneratedAttribute]
public static KeyOperation get_Encrypt();
    [CompilerGeneratedAttribute]
public static KeyOperation get_Decrypt();
    [CompilerGeneratedAttribute]
public static KeyOperation get_Sign();
    [CompilerGeneratedAttribute]
public static KeyOperation get_Verify();
    [CompilerGeneratedAttribute]
public static KeyOperation get_WrapKey();
    [CompilerGeneratedAttribute]
public static KeyOperation get_UnwrapKey();
    [CompilerGeneratedAttribute]
public static KeyOperation get_Import();
    public static bool op_Equality(KeyOperation left, KeyOperation right);
    public static bool op_Inequality(KeyOperation left, KeyOperation right);
    public static KeyOperation op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(KeyOperation other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
public class Azure.Security.KeyVault.Keys.KeyProperties : object {
    private static string KeyIdPropertyName;
    private static string ManagedPropertyName;
    private static string AttributesPropertyName;
    private static string TagsPropertyName;
    private static string ReleasePolicyPropertyName;
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_tagsPropertyNameBytes;
    private static JsonEncodedText s_releasePolicyPropertyNameBytes;
    private Dictionary`2<string, string> _tags;
    private KeyAttributes _attributes;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Managed>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyReleasePolicy <ReleasePolicy>k__BackingField;
    public string Name { get; internal set; }
    public Uri Id { get; internal set; }
    public Uri VaultUri { get; internal set; }
    public string Version { get; internal set; }
    public bool Managed { get; internal set; }
    public IDictionary`2<string, string> Tags { get; }
    public Nullable`1<bool> Enabled { get; public set; }
    public Nullable`1<bool> Exportable { get; public set; }
    public Nullable`1<DateTimeOffset> NotBefore { get; public set; }
    public Nullable`1<DateTimeOffset> ExpiresOn { get; public set; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> UpdatedOn { get; internal set; }
    public Nullable`1<int> RecoverableDays { get; internal set; }
    public string RecoveryLevel { get; internal set; }
    public string HsmPlatform { get; internal set; }
    public KeyReleasePolicy ReleasePolicy { get; public set; }
    public KeyProperties(string name);
    public KeyProperties(Uri id);
    private static KeyProperties();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_VaultUri();
    [CompilerGeneratedAttribute]
internal void set_VaultUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Managed();
    [CompilerGeneratedAttribute]
internal void set_Managed(bool value);
    public IDictionary`2<string, string> get_Tags();
    public Nullable`1<bool> get_Enabled();
    public void set_Enabled(Nullable`1<bool> value);
    public Nullable`1<bool> get_Exportable();
    public void set_Exportable(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_NotBefore();
    public void set_NotBefore(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ExpiresOn();
    public void set_ExpiresOn(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_CreatedOn();
    internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_UpdatedOn();
    internal void set_UpdatedOn(Nullable`1<DateTimeOffset> value);
    public Nullable`1<int> get_RecoverableDays();
    internal void set_RecoverableDays(Nullable`1<int> value);
    public string get_RecoveryLevel();
    internal void set_RecoveryLevel(string value);
    public string get_HsmPlatform();
    internal void set_HsmPlatform(string value);
    [CompilerGeneratedAttribute]
public KeyReleasePolicy get_ReleasePolicy();
    [CompilerGeneratedAttribute]
public void set_ReleasePolicy(KeyReleasePolicy value);
    internal void ParseId(Uri id);
    internal void ReadProperty(JsonProperty prop);
    internal void ReadProperties(JsonElement json);
    internal void WriteAttributes(Utf8JsonWriter json);
    internal void WriteTags(Utf8JsonWriter json);
    internal void WriteReleasePolicy(Utf8JsonWriter json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
public class Azure.Security.KeyVault.Keys.KeyReleasePolicy : object {
    private static string ContentTypePropertyName;
    private static string DataPropertyName;
    private static string ImmutablePropertyName;
    private static JsonEncodedText s_contentTypePropertyNameBytes;
    private static JsonEncodedText s_dataPropertyNameBytes;
    private static JsonEncodedText s_immutablePropertyName;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryData <EncodedPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Immutable>k__BackingField;
    public string ContentType { get; public set; }
    public BinaryData EncodedPolicy { get; private set; }
    public Nullable`1<bool> Immutable { get; public set; }
    public KeyReleasePolicy(BinaryData encodedPolicy);
    private static KeyReleasePolicy();
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public BinaryData get_EncodedPolicy();
    [CompilerGeneratedAttribute]
private void set_EncodedPolicy(BinaryData value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Immutable();
    [CompilerGeneratedAttribute]
public void set_Immutable(Nullable`1<bool> value);
    internal void ReadProperties(JsonElement json);
    internal void WriteProperties(Utf8JsonWriter json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
internal class Azure.Security.KeyVault.Keys.KeyRequestParameters : object {
    private static string KeyTypePropertyName;
    private static string KeySizePropertyName;
    private static string KeyOpsPropertyName;
    private static string CurveNamePropertyName;
    private static string AttributesPropertyName;
    private static string TagsPropertyName;
    private static string PublicExponentPropertyName;
    private static string ReleasePolicyPropertyName;
    private static JsonEncodedText s_keyTypePropertyNameBytes;
    private static JsonEncodedText s_keySizePropertyNameBytes;
    private static JsonEncodedText s_keyOpsPropertyNameBytes;
    private static JsonEncodedText s_curveNamePropertyNameBytes;
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_tagsPropertyNameBytes;
    private static JsonEncodedText s_publicExponentPropertyNameBytes;
    private static JsonEncodedText s_releasePolicyPropertyNameBytes;
    private KeyAttributes _attributes;
    [CompilerGeneratedAttribute]
private KeyType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <KeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<KeyOperation> <KeyOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyCurveName> <Curve>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PublicExponent>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyReleasePolicy <ReleasePolicy>k__BackingField;
    public KeyType KeyType { get; public set; }
    public Nullable`1<int> KeySize { get; public set; }
    public KeyAttributes Attributes { get; public set; }
    public IList`1<KeyOperation> KeyOperations { get; public set; }
    public Nullable`1<bool> Enabled { get; public set; }
    public Nullable`1<DateTimeOffset> NotBefore { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public Nullable`1<bool> Exportable { get; public set; }
    public IDictionary`2<string, string> Tags { get; public set; }
    public Nullable`1<KeyCurveName> Curve { get; public set; }
    public Nullable`1<int> PublicExponent { get; public set; }
    public KeyReleasePolicy ReleasePolicy { get; public set; }
    internal KeyRequestParameters(KeyProperties key, IEnumerable`1<KeyOperation> operations);
    internal KeyRequestParameters(KeyType type, CreateKeyOptions options);
    internal KeyRequestParameters(CreateEcKeyOptions ecKey);
    internal KeyRequestParameters(CreateRsaKeyOptions rsaKey);
    internal KeyRequestParameters(CreateOctKeyOptions octKey);
    private static KeyRequestParameters();
    [CompilerGeneratedAttribute]
public KeyType get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(KeyType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_KeySize();
    [CompilerGeneratedAttribute]
public void set_KeySize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public KeyAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(KeyAttributes value);
    [CompilerGeneratedAttribute]
public IList`1<KeyOperation> get_KeyOperations();
    [CompilerGeneratedAttribute]
public void set_KeyOperations(IList`1<KeyOperation> value);
    public Nullable`1<bool> get_Enabled();
    public void set_Enabled(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_NotBefore();
    public void set_NotBefore(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_Expires();
    public void set_Expires(Nullable`1<DateTimeOffset> value);
    public Nullable`1<bool> get_Exportable();
    public void set_Exportable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<KeyCurveName> get_Curve();
    [CompilerGeneratedAttribute]
public void set_Curve(Nullable`1<KeyCurveName> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PublicExponent();
    [CompilerGeneratedAttribute]
public void set_PublicExponent(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public KeyReleasePolicy get_ReleasePolicy();
    [CompilerGeneratedAttribute]
public void set_ReleasePolicy(KeyReleasePolicy value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.KeyRotationLifetimeAction : object {
    private static string ActionPropertyName;
    private static string ActionTypePropertyName;
    private static string TriggerPropertyName;
    private static string TimeAfterCreatePropertyName;
    private static string TimeBeforeExpiryPropertyName;
    private static JsonEncodedText s_actionPropertyNameBytes;
    private static JsonEncodedText s_actionTypePropertyNameBytes;
    private static JsonEncodedText s_triggerPropertyNameBytes;
    private static JsonEncodedText s_timeAfterCreatePropertyNameBytes;
    private static JsonEncodedText s_timeBeforeExpiryPropertyNameBytes;
    [CompilerGeneratedAttribute]
private KeyRotationPolicyAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeAfterCreate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeBeforeExpiry>k__BackingField;
    public KeyRotationPolicyAction Action { get; private set; }
    public string TimeAfterCreate { get; public set; }
    public string TimeBeforeExpiry { get; public set; }
    public KeyRotationLifetimeAction(KeyRotationPolicyAction action);
    private static KeyRotationLifetimeAction();
    [CompilerGeneratedAttribute]
public KeyRotationPolicyAction get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(KeyRotationPolicyAction value);
    [CompilerGeneratedAttribute]
public string get_TimeAfterCreate();
    [CompilerGeneratedAttribute]
public void set_TimeAfterCreate(string value);
    [CompilerGeneratedAttribute]
public string get_TimeBeforeExpiry();
    [CompilerGeneratedAttribute]
public void set_TimeBeforeExpiry(string value);
    internal void ReadProperties(JsonElement json);
    internal void WriteProperties(Utf8JsonWriter json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.KeyRotationPolicy : object {
    private static string IdPropertyName;
    private static string LifetimeActionsPropertyName;
    private static string AttributesPropertyName;
    private static string ExpiryTimePropertyName;
    private static string CreatedPropertyName;
    private static string UpdatedPropertyName;
    private static JsonEncodedText s_lifetimeActionsPropertyNameBytes;
    private static JsonEncodedText s_attributesPropertyNameBytes;
    private static JsonEncodedText s_expiryTimePropertyNameBytes;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<KeyRotationLifetimeAction> <LifetimeActions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpiresIn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreatedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <UpdatedOn>k__BackingField;
    public Uri Id { get; internal set; }
    public IList`1<KeyRotationLifetimeAction> LifetimeActions { get; }
    public string ExpiresIn { get; public set; }
    public Nullable`1<DateTimeOffset> CreatedOn { get; internal set; }
    public Nullable`1<DateTimeOffset> UpdatedOn { get; internal set; }
    private static KeyRotationPolicy();
    [CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Uri value);
    [CompilerGeneratedAttribute]
public IList`1<KeyRotationLifetimeAction> get_LifetimeActions();
    [CompilerGeneratedAttribute]
public string get_ExpiresIn();
    [CompilerGeneratedAttribute]
public void set_ExpiresIn(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_CreatedOn();
    [CompilerGeneratedAttribute]
internal void set_CreatedOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_UpdatedOn();
    [CompilerGeneratedAttribute]
internal void set_UpdatedOn(Nullable`1<DateTimeOffset> value);
    internal void ReadProperties(JsonElement json);
    internal void ReadAttributeProperties(JsonElement json);
    internal void WriteProperties(Utf8JsonWriter json);
    internal void WriteAttributeProperties(Utf8JsonWriter json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.KeyRotationPolicyAction : ValueType {
    internal static string NotifyValue;
    internal static string RotateValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static KeyRotationPolicyAction <Notify>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyRotationPolicyAction <Rotate>k__BackingField;
    public static KeyRotationPolicyAction Notify { get; }
    public static KeyRotationPolicyAction Rotate { get; }
    public KeyRotationPolicyAction(string value);
    private static KeyRotationPolicyAction();
    [CompilerGeneratedAttribute]
public static KeyRotationPolicyAction get_Notify();
    [CompilerGeneratedAttribute]
public static KeyRotationPolicyAction get_Rotate();
    public static bool op_Equality(KeyRotationPolicyAction left, KeyRotationPolicyAction right);
    public static bool op_Inequality(KeyRotationPolicyAction left, KeyRotationPolicyAction right);
    public static KeyRotationPolicyAction op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(KeyRotationPolicyAction other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
[EventSourceAttribute]
internal class Azure.Security.KeyVault.Keys.KeysEventSource : AzureEventSource {
    internal static int AlgorithmNotSupportedEvent;
    internal static int KeyTypeNotSupportedEvent;
    internal static int PrivateKeyRequiredEvent;
    internal static int CryptographicExceptionEvent;
    internal static int GetPermissionDeniedEvent;
    private static string EventSourceName;
    [CompilerGeneratedAttribute]
private static KeysEventSource <Singleton>k__BackingField;
    public static KeysEventSource Singleton { get; }
    private static KeysEventSource();
    [CompilerGeneratedAttribute]
public static KeysEventSource get_Singleton();
    [NonEventAttribute]
public void AlgorithmNotSupported(string operation, T algorithm);
    [EventAttribute("1")]
public void AlgorithmNotSupported(string operation, string algorithm);
    [NonEventAttribute]
public void KeyTypeNotSupported(string operation, KeyVaultKey key);
    [EventAttribute("2")]
public void KeyTypeNotSupported(string operation, string keyType);
    [EventAttribute("3")]
public void PrivateKeyRequired(string operation);
    [NonEventAttribute]
public void CryptographicException(string operation, Exception ex);
    [EventAttribute("4")]
public void CryptographicException(string operation, string message);
    private static string FormatException(Exception ex);
    [EventAttribute("5")]
public void GetPermissionDenied(string operation, string keyName);
}
internal class Azure.Security.KeyVault.Keys.KeySignParameters : ValueType {
    private static JsonEncodedText s_algorithmPropertyNameBytes;
    private static JsonEncodedText s_digestPropertyNameBytes;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Digest>k__BackingField;
    public string Algorithm { get; public set; }
    public Byte[] Digest { get; public set; }
    private static KeySignParameters();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Digest();
    [CompilerGeneratedAttribute]
public void set_Digest(Byte[] value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.KeyType : ValueType {
    internal static string EcValue;
    internal static string EcHsmValue;
    internal static string RsaValue;
    internal static string RsaHsmValue;
    internal static string OctValue;
    internal static string OctHsmValue;
    private string _value;
    [CompilerGeneratedAttribute]
private static KeyType <Ec>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyType <EcHsm>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyType <Rsa>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyType <RsaHsm>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyType <Oct>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeyType <OctHsm>k__BackingField;
    public static KeyType Ec { get; }
    public static KeyType EcHsm { get; }
    public static KeyType Rsa { get; }
    public static KeyType RsaHsm { get; }
    public static KeyType Oct { get; }
    public static KeyType OctHsm { get; }
    public KeyType(string value);
    private static KeyType();
    [CompilerGeneratedAttribute]
public static KeyType get_Ec();
    [CompilerGeneratedAttribute]
public static KeyType get_EcHsm();
    [CompilerGeneratedAttribute]
public static KeyType get_Rsa();
    [CompilerGeneratedAttribute]
public static KeyType get_RsaHsm();
    [CompilerGeneratedAttribute]
public static KeyType get_Oct();
    [CompilerGeneratedAttribute]
public static KeyType get_OctHsm();
    public static bool op_Equality(KeyType left, KeyType right);
    public static bool op_Inequality(KeyType left, KeyType right);
    public static KeyType op_Implicit(string value);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(KeyType other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public virtual string ToString();
}
public class Azure.Security.KeyVault.Keys.KeyVaultKey : object {
    private static string KeyPropertyName;
    [CompilerGeneratedAttribute]
private JsonWebKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyProperties <Properties>k__BackingField;
    public Uri Id { get; }
    public string Name { get; }
    public JsonWebKey Key { get; internal set; }
    public KeyType KeyType { get; }
    public IReadOnlyCollection`1<KeyOperation> KeyOperations { get; }
    public KeyProperties Properties { get; }
    internal KeyVaultKey(KeyProperties properties);
    public KeyVaultKey(string name);
    public Uri get_Id();
    public string get_Name();
    [CompilerGeneratedAttribute]
public JsonWebKey get_Key();
    [CompilerGeneratedAttribute]
internal void set_Key(JsonWebKey value);
    public KeyType get_KeyType();
    public IReadOnlyCollection`1<KeyOperation> get_KeyOperations();
    [CompilerGeneratedAttribute]
public KeyProperties get_Properties();
    internal virtual void ReadProperty(JsonProperty prop);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
[IsReadOnlyAttribute]
public class Azure.Security.KeyVault.Keys.KeyVaultKeyIdentifier : ValueType {
    [CompilerGeneratedAttribute]
private Uri <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public Uri SourceId { get; }
    public Uri VaultUri { get; }
    public string Name { get; }
    public string Version { get; }
    public KeyVaultKeyIdentifier(Uri id);
    private KeyVaultKeyIdentifier(Uri sourceId, Uri vaultUri, string name, string version);
    [CompilerGeneratedAttribute]
public Uri get_SourceId();
    [CompilerGeneratedAttribute]
public Uri get_VaultUri();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    public static bool TryCreate(Uri id, KeyVaultKeyIdentifier& identifier);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(KeyVaultKeyIdentifier other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
internal class Azure.Security.KeyVault.Keys.KeyVerifyParameters : ValueType {
    private static JsonEncodedText s_algorithmPropertyNameBytes;
    private static JsonEncodedText s_digestPropertyNameBytes;
    private static JsonEncodedText s_signaturePropertyNameBytes;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Digest>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Signature>k__BackingField;
    public string Algorithm { get; public set; }
    public Byte[] Digest { get; public set; }
    public Byte[] Signature { get; public set; }
    private static KeyVerifyParameters();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Digest();
    [CompilerGeneratedAttribute]
public void set_Digest(Byte[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(Byte[] value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
internal class Azure.Security.KeyVault.Keys.RandomBytes : object {
    private static string ValuePropertyName;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; internal set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(Byte[] value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
public class Azure.Security.KeyVault.Keys.RecoverDeletedKeyOperation : Operation`1<KeyVaultKey> {
    private static TimeSpan s_defaultPollingInterval;
    private KeyVaultPipeline _pipeline;
    private OperationInternal _operationInternal;
    private KeyVaultKey _value;
    public string Id { get; }
    public KeyVaultKey Value { get; }
    public bool HasCompleted { get; }
    public bool HasValue { get; }
    internal RecoverDeletedKeyOperation(KeyVaultPipeline pipeline, Response`1<KeyVaultKey> response);
    private static RecoverDeletedKeyOperation();
    public virtual string get_Id();
    public virtual KeyVaultKey get_Value();
    public virtual bool get_HasCompleted();
    public virtual bool get_HasValue();
    public virtual Response GetRawResponse();
    public virtual Response UpdateStatus(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.RecoverDeletedKeyOperation/<UpdateStatusAsync>d__16")]
public virtual ValueTask`1<Response> UpdateStatusAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<KeyVaultKey>> WaitForCompletionAsync(CancellationToken cancellationToken);
    public virtual ValueTask`1<Response`1<KeyVaultKey>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.Keys.RecoverDeletedKeyOperation/<Azure-Core-IOperation-UpdateStateAsync>d__19")]
private sealed virtual override ValueTask`1<OperationState> Azure.Core.IOperation.UpdateStateAsync(bool async, CancellationToken cancellationToken);
}
public class Azure.Security.KeyVault.Keys.ReleaseKeyOptions : object {
    private static JsonEncodedText s_targetAttestationTokenPropertyNameBytes;
    private static JsonEncodedText s_noncePropertyNameBytes;
    private static JsonEncodedText s_algorithmPropertyNameBytes;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyExportEncryptionAlgorithm> <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetAttestationToken>k__BackingField;
    public string Name { get; }
    public string Version { get; public set; }
    public string Nonce { get; public set; }
    public Nullable`1<KeyExportEncryptionAlgorithm> Algorithm { get; public set; }
    public string TargetAttestationToken { get; }
    public ReleaseKeyOptions(string name, string targetAttestationToken);
    private static ReleaseKeyOptions();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Nonce();
    [CompilerGeneratedAttribute]
public void set_Nonce(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<KeyExportEncryptionAlgorithm> get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(Nullable`1<KeyExportEncryptionAlgorithm> value);
    [CompilerGeneratedAttribute]
public string get_TargetAttestationToken();
    internal void WriteProperties(Utf8JsonWriter json);
    private sealed virtual override void Azure.Security.KeyVault.IJsonSerializable.WriteProperties(Utf8JsonWriter json);
}
public class Azure.Security.KeyVault.Keys.ReleaseKeyResult : object {
    private static string ValuePropertyName;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(string value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
internal class Azure.Security.KeyVault.KeyVaultIdentifier : ValueType {
    public static string SecretsCollection;
    public static string KeysCollection;
    public static string CertificatesCollection;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public Uri Id { get; private set; }
    public Uri VaultUri { get; public set; }
    public string Name { get; public set; }
    public string Collection { get; public set; }
    public string Version { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Uri value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Uri get_VaultUri();
    [CompilerGeneratedAttribute]
public void set_VaultUri(Uri value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public static KeyVaultIdentifier Parse(Uri id);
    public static KeyVaultIdentifier ParseWithCollection(Uri id, string collection);
    public static bool TryParse(Uri id, KeyVaultIdentifier& identifier);
}
internal class Azure.Security.KeyVault.KeyVaultPage`1 : object {
    private T[] _items;
    private Func`1<T> _itemFactory;
    [CompilerGeneratedAttribute]
private Uri <NextLink>k__BackingField;
    public ReadOnlySpan`1<T> Items { get; }
    public Uri NextLink { get; private set; }
    internal KeyVaultPage`1(Func`1<T> itemFactory);
    public ReadOnlySpan`1<T> get_Items();
    [CompilerGeneratedAttribute]
public Uri get_NextLink();
    [CompilerGeneratedAttribute]
private void set_NextLink(Uri value);
    private sealed virtual override void Azure.Security.KeyVault.IJsonDeserializable.ReadProperties(JsonElement json);
}
internal class Azure.Security.KeyVault.KeyVaultPipeline : object {
    private HttpPipeline _pipeline;
    [CompilerGeneratedAttribute]
private ClientDiagnostics <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <VaultUri>k__BackingField;
    public HttpPipeline HttpPipeline { get; }
    public ClientDiagnostics Diagnostics { get; }
    public string ApiVersion { get; }
    public Uri VaultUri { get; }
    public KeyVaultPipeline(ClientDiagnostics clientDiagnostics);
    public KeyVaultPipeline(Uri vaultUri, string apiVersion, HttpPipeline pipeline, ClientDiagnostics clientDiagnostics);
    public HttpPipeline get_HttpPipeline();
    [CompilerGeneratedAttribute]
public ClientDiagnostics get_Diagnostics();
    [CompilerGeneratedAttribute]
public string get_ApiVersion();
    [CompilerGeneratedAttribute]
public Uri get_VaultUri();
    public Uri CreateFirstPageUri(string path);
    public Uri CreateFirstPageUri(string path, ValueTuple`2[] queryParams);
    public Request CreateRequest(RequestMethod method, Uri uri, bool appendApiVersion);
    public Request CreateRequest(RequestMethod method, String[] path);
    public Response`1<T> CreateResponse(Response response, T result);
    public DiagnosticScope CreateScope(string name);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<GetPageAsync>d__20`1")]
public Task`1<Page`1<T>> GetPageAsync(Uri firstPageUri, string nextLink, Func`1<T> itemFactory, string operationName, CancellationToken cancellationToken);
    public Page`1<T> GetPage(Uri firstPageUri, string nextLink, Func`1<T> itemFactory, string operationName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__22`2")]
public Task`1<Response`1<TResult>> SendRequestAsync(RequestMethod method, TContent content, Func`1<TResult> resultFactory, CancellationToken cancellationToken, String[] path);
    public Response`1<TResult> SendRequest(RequestMethod method, TContent content, Func`1<TResult> resultFactory, CancellationToken cancellationToken, String[] path);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__24`1")]
public Task`1<Response`1<TResult>> SendRequestAsync(RequestMethod method, Func`1<TResult> resultFactory, CancellationToken cancellationToken, String[] path);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__25`1")]
public Task`1<Response`1<TResult>> SendRequestAsync(RequestMethod method, Func`1<TResult> resultFactory, Uri uri, CancellationToken cancellationToken);
    public Response`1<TResult> SendRequest(RequestMethod method, Func`1<TResult> resultFactory, CancellationToken cancellationToken, String[] path);
    public Response`1<TResult> SendRequest(RequestMethod method, Func`1<TResult> resultFactory, Uri uri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__28")]
public Task`1<Response> SendRequestAsync(RequestMethod method, CancellationToken cancellationToken, String[] path);
    public Response SendRequest(RequestMethod method, CancellationToken cancellationToken, String[] path);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<GetResponseAsync>d__30")]
public Task`1<Response> GetResponseAsync(RequestMethod method, CancellationToken cancellationToken, String[] path);
    public Response GetResponse(RequestMethod method, CancellationToken cancellationToken, String[] path);
    [AsyncStateMachineAttribute("Azure.Security.KeyVault.KeyVaultPipeline/<SendRequestAsync>d__32")]
private Task`1<Response> SendRequestAsync(Request request, CancellationToken cancellationToken);
    private Response SendRequest(Request request, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Azure.Security.KeyVault.SerializationExtensions : object {
    [ExtensionAttribute]
public static void Deserialize(IJsonDeserializable obj, Stream content);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> Serialize(IJsonSerializable obj);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Extensions.Azure.KeyClientBuilderExtensions : object {
    [ExtensionAttribute]
public static IAzureClientBuilder`2<KeyClient, KeyClientOptions> AddKeyClient(TBuilder builder, Uri vaultUri);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<KeyClient, KeyClientOptions> AddKeyClient(TBuilder builder, TConfiguration configuration);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<CryptographyClient, CryptographyClientOptions> AddCryptographyClient(TBuilder builder, Uri vaultUri);
    [ExtensionAttribute]
public static IAzureClientBuilder`2<CryptographyClient, CryptographyClientOptions> AddCryptographyClient(TBuilder builder, TConfiguration configuration);
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
